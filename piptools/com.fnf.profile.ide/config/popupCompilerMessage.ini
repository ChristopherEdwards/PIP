###
$$NEW^%ZT is obsolete in v6.3
Cause:
 The $$NEW^%ZT function is not available in PSL in versions v6.3 and later.
 
Solution:
 This utility and SET^%ZT were used to trap errors. Replace these functions with a catch block.
 
 
 main // Main subroutine
 
    catch xyz {

        write !,"Tag main:",xyz.type," Thrown at:",xyz.thrownAt

        }

    do subr

    type RecordDEP dep=Db.getRecord("DEP",1212)

    quit

subr // 

    catch error{

        write !,"Tag subr:",error.type," Thrown at: ",error.thrownAt

        throw MyError

        }

    if x // will generate %GTM_E_UNDEF

quit
 

 
###
$$ Extrinsic not supported: <atom>
Cause:
 String methods are not supported on extrinsic functions.
 
 
      set x=a.extract(1)

     set x="String".extract(1)

     set x=$$tag^rou().extract(1)

     
 
Solution:
 Modify the code to not specify a string method for an extrinsic function.
 
###
Argumentless Kill is not supported
Cause:
 A Kill statement does not specify the required arguments.
 
Solution:
 PSL manages several variables in the background. If programmers kill all 
variables, that would result in undefined errors on those variables.

Instead, set a break in the program at the location where the kill is intended.
 Determine which variables are related to the processing, and kill each individually.
 

 
###
Block initiator expected
Cause:
 The beginning of a catch of code was not delimited by a { character.
 
Solution:
 Add the appropriate { to mark the beginning of the block of code; enter the 
necessary lines of code; and close the block with a closing }.
 

 
###
Cannot use an array identifier as a secondary point: <variable>
Cause:
 Multiple identifiers can be assigned to a single object. However, the second 
identifier cannot be an array.
 
 
 type RecordDEP dep-Db.getRecord ("DEP",":CID")

type RecordDEP dep2=dep

type RecordDEP a()

set a(1)=dep

 
 
Solution:
 Do not assign an array as a secondary identifier in an object.
 
 
 type RecordDEP dep-Db.getRecord ("DEP",":CID")

type RecordDEP dep2=dep

type RecordDEP dep3=dep
 

 
###
Casting terminator expected
Cause:
 An object is being cast as another Record class, but does not have the 
appropriate casting terminator (i.e., }).
 
 
 type RecordACN acn=Db.getRecord ("ACN","CID")

if acn.cls="D" do {

    set acn={RecordDEP.acn

}

 
 
Solution:
 Insert the casting terminator following the Record class.
 
 
 type RecordACN acn=Db.getRecord ("ACN","CID")

if acn.cls="D" do {

    set acn={RecordDEP}.acn

}
 

 
###
Class is not instantiable: <class>
Cause:
 A program attempts to instantiate a class that cannot be used to instantiate 
objects. That is, the Not Instantiable Flag (OBJECT.NOINSTANT) for that class is 
selected. For example, the Db class has this flag set because the class is used 
to provide methods to access the database. Those methods are used on objects 
created under other classes.

This error only occurs when using the Class.new method.
 
 
 type Db x=Class.new("Db")

 
 
Solution:
 There is no reason to instantiate an object of class Db.
 

 
###
Column name: <name> is not in the select list: <list>
Cause:
 A column name is referenced in the ResultSet.getCol method that has not 
previously been selected using Db.select ro Db.selectDbSet.
 
 
 type ResultSet rs=Db.select("LNM,CID","DEP")
while rs.next() do {
write !,rs.getCol("bal")," ",rs.getCol("lnm")
}

 
 
Solution:
 Include the column name in the select statement.
 
 
 type ResultSet rs=Db.select("BAL,LNM,CID","DEP")
while rs.next() do {
write !,rs.getCol("bal")," ",rs.getCol("lnm")
}
 

 
###
Column names can only be used in the instantiating scope
Cause:
 The ResultSet.getCol method used the columnName parameter in a subroutine other 
than where the result set is instantiated.
 
 
 xxx

type ResultSet rs=Db.select("IRN","DEP")

if rs.isEmpty() quit

while rs.next() do {

     do XXX(.rs)

     if rs.getCol("IRN")=5 quit

     }

quit

XXX(ResultSet rs)

     if rs.getCol("IRN")=5 quit

     quit

 
 
Solution:
 Use the columnNumber parameter in subroutines other than where the result set 
is instantiated.
 

 
###
Command delimiter expected
Cause:
 A catch statement is not followed by a block delimiter "{".
 
 
 catch error:RECNOF

 
 
Solution:
 Enter a delimiter in the catch statement.
 
 
 catch error:RECNOF {
 

 
###
Command does not support a post-conditional expression: <command>
Cause:
 A command in the procedure does not permit the use of post-conditional 
expressions. 
 
 
 if X new abc

OR

new abc:x

 
 
Solution:
 Remove the post-conditional expression from the offending command. You may need 
to modify the program logic to perform the same task as the post-conditional 
expression. 
 
 
 if X do {

            new abc

            do more

            }
 

 
###
Equal sign expected
Cause:
 An expression does not contain an equal sign. For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP",12345)

 

set dep.bal 100

quit

 
 
Solution:
 Modify the PSL source code to use an equal sign where you make an assignment. 
For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP",12345)

 

set dep.bal=100

quit
 

 
###
Error type parameter is required
Cause:
 The error type (i.e., from the Errors system table (ET)) must be specified when 
throwing a run-time error.
 
Solution:
 Specify the error type when throwing the error.
 
 
 catch ERROR {

set ET=ERROR.type

set CONTEXT=ERROR.context
 

 
###
Expression must return a class: <expression>
Cause:
 A method does not return a class, when it is required to do so.
 
 
 x=dep.newMethod()

 
 
Solution:
 Modify the code to return a class.
 

 
###
Expression must return a class: <expression>
Cause:
 A method does not return a class, when it is required to do so.
 
 
 x=dep.newMethod()

 
 
Solution:
 Modify the code to return a class.
 

 
###
Expression not allowed in group set: <expression>
Cause:
 A $ variable was included as part of a group of columns within one command.
 
 
 set ($ZT)=12

 
 
Solution:
 Do not set these special GTM variables as part of a group of columns in one 
command.
 
 
 set $ZT=12
 

 
###
Global name cannot exceed 8 characters
Cause:
 The global name specified in the Schema.createTable method parameter list is 
greater than 8 characters in length.
 
Solution:
 Specify a global name that is less than or equal to 8 characters in length.
 

 
###
Goto command is invalid in object scope
Cause:
 The GOTO command is invalid in the object scope. For example,
 
 
 abc //

     type RecordDEP dep

     set dep=Db.getRecord("DEP",CID)

     set bal=dep.bal

     go def

     quit

 

def //

     set bal=bal+tamt

     quit

 
 
Solution:
 Modify the source code to eliminate the GOTO command at the specified line. You 
may need to modify the logic as a result of this change. For example,
 
 
 abc //

     type RecordDEP dep

     set dep=Db.getRecord("DEP",CID)

     set bal=dep.bal

 

def //

     set bal=bal+tamt

     quit
 

 
###
Identifier must be local scope for dynamic SQL
Cause:
 The ResultSet is defined in one label passed to another, where the columns 
being selected are dynamic.
 
 
 type ResultSet rs

do xxx(.rs)

quit

 

xxx(ResultSet rs)

     #warn

     type Public String IRN

     set rs=Db.select(IRN,"DEP")

     if rs.isEmpty() quit

     while rs.next() do {

     quit

 
 
Solution:
 Move the type statement for the result set into the xxx level.
 

 
###
Illegal reference to abstract class: <class>
Cause:
 When using the Class.new method to create a new object, the object is defined 
for an abstract class. An abstract class is defined by selecting the Abstract 
Class Flag (OBJECT.ABSTRACT) option. Abstract classes should not be associated 
with a particular instance of an object. For example, the Record class is used 
to instantiate many different types of Table objects and should therefore not be 
associated with a particular instance of an object.
 
Solution:
 Use a valid class.
 

 
###
Illegal sentinel character
Cause:
 Reference was made to a variable that contains sentinel characters (i.e., the 
characters vo in the variable name). For example,
 
 
 new dep

type RecordDEP dep

set Db.getRecord("DEP",12345)

 

set dep.bal=100

s vo=100

quit

 
 
Solution:
 Rename the variable that begins with the characters "vo". These characters are 
sentinel characters, and are reserved for use by the PSL compiler. For example,
 
 
 new dep

type RecordDEP dep

set Db.getRecord("DEP",12345)

 

set dep.bal=100

s amt=100

quit
 

 
###
Invalid $SELECT syntax
Cause:
 An invalid $SELECT syntax exists. For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP",12345)

 

set dep.bal=100

set dep.bal=$SELECT(dep.bal>100,100)

quit

 
 
Solution:
 Check the syntax for $S[ELECT]. For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP",12345)

 

set dep.bal=100

set dep.bal=$SELECT(dep.bal>100,1:100)

quit
 

 
###
Invalid assignment function
Cause:
 An instrinsic function was used on the left side of an expression.
 
 
 set $E(FFF,"|",2)=3

 
 
Solution:
 The only intrinsic function that may appear on the left side of an expression 
is the $piece function. Review the code. It is possible that the programmer 
meant to use a $piece function.
 
 
 set $P(FFF,"|",2)=3
 

 
###
Invalid assignment on array: <expr>
Cause:
 An attempt was made to assign an array to a value with a type command.
 
 
 type RecordDEP dep()=Db.getRecord("DEP",":CID")

 
 
Solution:
 Remove the array assignment from the type command.
 
 
 type RecordDEP dep=Db.getRecord("DEP",":CID")
 

 
###
Invalid block termination
Cause:
 The system attempted to terminate a block that had not been opened. 
 For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP",12345)

 

set dep.bal=100

 

do {

     set dep.bal=100

     }

     }

quit

 
 
Solution:
 Modify the PSL source code to ensure that each block of code that opens with a 
left curly bracket { character also terminates with a right curly bracket } 
character. For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP",12345)

 

set dep.bal=100

 

do {

     set dep.bal=100

     }

quit
 

 
###
Invalid command
Cause:
 A specified M command does not exist. For example,
 
 
 x=y

 
 
Solution:
 Modify the PSL source code to include a valid M command (e.g., set, if, for, 
else) on the specified line. For example,
 
 
 set x=y
 

 
###
Invalid DATA-QWIK table: <tableName>
Cause:
 A Record<class> specified in the code does not exist in the database 
dictionary.
 
 
 x=y

 
 
Solution:
 Verify the spelling and case of the table specified in the object declaration. 
For example, the following statement produces this error because dep is not a 
valid DATA-QWIK table. Use DEP instead.
 
 
 type Recorddep deposit
 
 
 If referencing a new table, verify that it exists in DATA-QWIK.
 

 
###
Invalid function
Cause:
 A specified M function does not exist. For example,
 
 
 set x=$K(abc)

 
 
Solution:
 Modify the PSL source code to include a valid M function (e.g., $P[iece], 
$G[et], $D[ata], $L[ength], etc.). For example,
 
 
 set x=$L(abc)
 

 
###
Invalid in multiple command lines
Cause:
 A compiler command was used on a line with other application code.
 
 
 if X=3 #IF condition

 
 
Solution:
 Modify the code so that the compiler command appears by itself on a line of 
code.
 
 
 #if condition

      if X=3...

 

#ENDIF
 

 
###
Invalid inside nested structures
Cause:
 A GOTO command appears within a nested DO block. For example,
 
 
      do {

          set x=x+1

          if x> 10 goto abc

         }

     exit

 

abc set er=1

     exit

 
 
Solution:
 Remove the GOTO command within a nested DO block. This may require a change to 
the logic contained within the DO block. For example,
 
 
       do {

          set x=x+1

          }

      if x>10 set er=1

      exit
 

 
###
Invalid label reference inside block
Cause:
 A label appears within a nested DO block. For example,
 
 
 do {

     label set x=y

     }

 
 
Solution:
 Remove the label reference contained within the block at the specified line. 
For example,
 
 
 do {

     set x=y

     }
 

 
###
Invalid object identifier: <atom>
Cause:
 An array of objects was declared and set with a single command.
 
 
 type RecordACN acn(1)=Db.getRecord("ACN","CID=:CID")

 
 
Solution:
 Declare the array and instantiate objects on separate lines.
 
 
 type RecordACN acn()

set acn(1)=Db.getRecord("ACN","CID=:CID")
 

 
###
Invalid Subroutine name: <expression>
Cause:
 A subroutine label contains parameters and is either missing the closing 
parenthesis or does not terminate a parameter with a comma.
 
 
 label(parameter1            // Parameter #1

         parameter 2)         // Parameter #2

 
 
Solution:
 Insert missing parenthesis or comma.
 
 
 label(parameter1,            // Parameter #1

         parameter 2)          // Parameter #2
 

 
###
Invalid syntax
Cause:
 The syntax of a method is incorrect.
 
 
 s data=Db.getOneRow("ACN,TAXID","CIF","")

 
 
Solution:
 Correct the syntax to match the prescribed method format.
 
 
 s data=Db.getOneRow("ACN,TAXID","CIF","XACN")
 

 
###
Invalid table name
Cause:
 The following conditions exist for a table to be deleted using the 
Schema.deleteTable method:

The date the table was last updated (DBTBL1.LTD) is blank, AND the user ID of 
the person who last updated the table (DBTBL.USER) is blank.
OR
The user ID (DBTBL.USER) is ZZZZZZ.

AND

The file type associated with the table (DBTBL.FILETYP) is 5 (Dummy Table).
 
Solution:
 Review the code. Either a table was not created by a Schema.createTable, or 
there are multiple Schema.deleteTable commands in the code
 

 
###
Invalid void method in nested syntax: <atom>
Cause:
 A void method has been specified in a nested expression.
 
 
 type RecordDEP dep=Db.getRecord("DEP",":CID")

set x-dep.bal.curVal().len

set x=dep.save().extract(1)

 
 
Solution:
 Modify the code to remove the void method from the nested expression.
 

 
###
Label already exists: <label>
Cause:
 A label appears multiple times within the same source module. For example,
 
 
 label set x=y

label set y=z

 
 
Solution:
 Rename one of the label references within the source module. For example,
 
 
 label set x=y

label1 set y=z
 

 
###
Label Expected: <expression>
Cause:
 A Literal scope variable has a null value. This error occurs in the following 
example if the value of CUVAR.PGM is null.
 
 
 xecute "DO ^"_CUVAR.PGM"

 
 
Solution:
 Modify the code to ensure that the proper values are assigned at the time of 
compilation.
 

 
###
Literal parameter <parameter> expected
Cause:
 A method requires a literal as one of its parameters. However, the literal does 
not exist in the code. For example,
 
 
 new ts

 

type TranSet ts

set ts=Class.new()

 
 
Solution:
 Include the missing literal in the method’s parameter list. For example,
 
 
 new ts

 

type TranSet ts

set ts=Class.new("TranSet")
 

 
###
Literal scope not allowed in group set
Cause:
 A variable is typed as a Literal variable and subsequently initialized in a 
group set.
 
 
 type Literal String dim

set (x,dim)=1

 
 
Solution:
 Do not use a group set on a Literal scope variable.
 
 
 type Literal String dim

set x=1

set dim=1
 

 
###
Method can not be applied to local scope object: <objectName>
Cause:
 The RecordClass.setCreateOnly() or RecordClass.setUpdateOnly method was used 
with an object that is local scope.
 
Solution:
 These methods can only be used for objects that are either Public scope or 
passed in as a formal parameter.
 

 
###
Missing label name
Cause:
 A label is Public and includes parameters. However, the label was not named as 
such.
 
Solution:
 Include a label name in the line of code.
 
 
 Public (xcv)
 

 
###
Missing parameter terminator: <rec>
Cause:
 Subroutine parameters span multiple lines. However, each line of parameters is 
not terminated with either a comma or closing parentheses.
 
 
 XYZ(abc

        def

 
 
Solution:
 Insert the missing comma or closing parentheses at the end of each line in the 
parameter list.
 
 
 XYZ(abc,

       def)
 

 
###
Missing QUIT from previous subroutine: <subroutine>
Cause:
 A subroutine that instantiated an object did not include a quit command prior 
to the start of another label that receives parameters.
 
 
 XYZ

   type RecordDEP dep=Db.getRecord("DEP","cid")

 

tyu("xyt")

   quit

 
 
Solution:
 Insert a quit command prior to the start of the second label.
 
 
 XYZ

   type RecordDEP dep=Db.getRecord("DEP","cid")

   quit

 

tyu("xyt")

   quit
 

 
###
Missing table name
Cause:
 The method did not include the table name in its parameter list.
 
 
 s data=Db.getOneRow("ACN,TAXID","","XACN")

 
 
Solution:
 Include the necessary table name in the method parameter list.
 
 
 s data=Db.getOneRow("ACN,TAXID","CIF","XACN")
 

 
###
More actual parameters than formal parameters
Cause:
 A routine is attempting to pass more parameters to a label than the label has 
defined.
 
Solution:
 Review parameters of the label being called and the routine calling that label. 
 Determine which has the correct number of parameters. If you need to modify the 
label being called, review all routines calling that label to ensure that they 
pass the correct number of parameters.
 

 
###
Multiple dynamic selects or variable name conflict (exe,vsql)
Cause:
 A dynamic select was used, but the local variables "exe" or "vsql" are already 
in scope. This can occur in either of the following ways:

(1) The programmer used the names "exe" or "vsql".

(2) There is already a dynamic select used in the same scope as this one.
 
Solution:
 Correct the error as follows based on the cause listed above:

(1) Do not use the variable names "exe" or "vsql".

(2) Do not use more than one dynamic select in the same scope.
 

 
###
Multiple reference at parameters: <param1> and : <param2>
Cause:
 The same parameter was passed more than once.
 
 
 label(RecordDEP dep(), RecordDEP dep())

 
 
Solution:
 Modify the code to pass the parameter only once.
 
 
 label(RecordDEP dep())
 

 
###
MUMPS structured block syntax is not supported
Cause:
 The code includes a period (.) in a DO structure block.
 
 
 FOR I=1:1:10 DO

.S D=3

 
 
Solution:
 Implement a DO block with the { } syntax.
 
 
 for I=1:1:10 DO {

    S D=3

    }
 

 
###
Object cast cannot be conditionally executed
Cause:
 A cast expression cannot be placed into a conditional expression, because 
logical conditions cannot be tested at compile time. This error occurred because 
a cast expression was placed in a conditional expression.
 
 
 type RecordACN acn=Db.getRecord("ACN","CID=:AREF")

if acn.cls="L" set acn={RecordLN}acn

 
 
Solution:
 Modify the code to separate the conditional statement from the casting 
statement.
 
 
 type RecordACN acn=Db.getRecord("ACN","CID=:AREF")

if acn.cls="L"

   set acn={RecordLN}acn
 

 
###
Object identifier required
Cause:
 An object name (i.e., identifier) was not specified when attempting to catch a 
run-time error.
 
 
 CATCH

 
 
Solution:
 Enter the correct syntax for the CATCH command.
 
 
 CATCH vError{
 

 
###
Object invalid in FOR expression
Cause:
 A FOR command argument is not of the String data type. For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

for I=1:1:dep set x=x+1

 
 
 
 You cannot use the dep object in the above position in a FOR statement.
 
Solution:
 Remove the object from the FOR command, and use one of the following 
alternative statements:
 
 
 Example 1

for I=1:1:10 set x=x+1
 

Example 2

for I=1:1:dep.trmd set x=x+1
 
 

 
###
Object invalid in relational expression
Cause:
 A relational operand is not of the String data type. The code attempts to 
compare an M variable to an object. For example,
 
 
 new dep,x

set x="TEST"

type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

if x=dep quit

 
 
Solution:
 Use a field from the object for the test. For example,
 
 
 new dep,x

set x="TEST"

type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

if x=dep.title1 quit
 

 
###
Object is already instantiated: <objectName>
Cause:
 This error may occur if you re instantiate an object. For example, the 
following code attempts to instantiate an object that already exists for a given 
identifier within a given M scope:
 
 
 t RecordDEP dep

set dep=Db.getRecord("DEP",rs.getCol(1))

set dep=Db.getRecord("DEP",rs.getCol(2))

At run-time, the second assignment produces this error.

 
 
Solution:
 If you want to use the same identifier for two assignments, use the following 
coding structure:
 
 
 tagA

type RecordDEP dep

set dep=Db.getRecord("DEP",someKey)

do tag(.dep)

quit

 

tagB(RecordDEP dep)

if ?D(dep) set dep=Db.getRecord("DEP",someKey)
 

 
###
Object is already referenced: <objectName>
Cause:
 The object has been previously referenced within this subroutine.
 
 
 tag(RecordDEP dep)            //

            set x=dep.bal

            do dep.setUpdateOnly()

            quit

 
 
Solution:
 Place this method at the top of the subroutine.
 
 
 tag(RecordDEP dep)            //

            do dep.setUpdateOnly()

            set x=dep.bal

            quit
 

 
###
Object is an invalid subscript
Cause:
 An array subscript is not of the String data type. For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

set x(dep)=2

 
 
 
 Because dep is an object name, you cannot use it as a subscript to an array.
 
Solution:
 Either do not use the object name as a subscript, or use a field from the 
object. For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

set x(dep.cid)=2
 

 
###
Object is invalid function argument
Cause:
 An M function parameter is not of the String data type. For example, the 
compiler does not enable commands such as $EXTRACT to extract data from an 
object.
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

set xyz=$E(dep,1,2)

 
 
Solution:
 Change the object reference to a column within the object. For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

set xyz=dep.title1
 

 
###
Object reference required
Cause:
 The objectName parameter is missing from the Class.isValid method.
 
 
 if Class.isValid() quit

 
 
Solution:
 Specify the name of the object to validate.
 
 
 if Class.isValid(dep) quit
 

 
###
Objects must be passed by reference
Cause:
 An object that was passed to a subroutine as an actual parameter must be passed 
by reference.
 
 
 if Class.isValid() quit

 
 
Solution:
 When passing an object to a label, insert a dot (.) before the object name to 
pass the object by reference. For example,
 
 
 type RecordDEP dep

     set dep=Db.getRecord("DEP","CID")

     do abc(.dep)

 

abc(RecordDEP dep)

     quit
 

 
###
Parameter <parameter> is multiply defined
Cause:
 An object was passed twice to a subroutine.
 
 
 type RecordDEP dep=Db.getRecord("DEP","CID")

D XXX(x.,.dep,.dep)

quit

 

XXX(x,RecordDEP dep,RecordDEP dep)

 
 
Solution:
 Pass the parameter only once to the subroutine.
 
 
 type RecordDEP dep=Db.getRecord("DEP","CID")

D XXX(x.,.dep)

quit

 

XXX(x,RecordDEP dep)
 

 
###
Parameter list contains duplicate references
Cause:
 A variable or array reference appears more than once in a formal or actual 
parameter list. For example, parameter dep() below is multiply defined.
 
 
      do subr(dep,.dep(),.dep(),CID1,CID2)

 

subr(RecordDEP dep, ReocrdDEP dep(), CID1,CID2)

     quit

 
 
Solution:
 PSL allows a variable to be multiply defined in the actual parameters but not 
in the formal parameters. In order to support array passing by dimension, PSL 
does not support duplicate references in the actual parameters. Remove the 
duplicate references.
 
 
      do subr(dep,.dep(),CID1,CID2)

 

subr(RecordDEP dep, ReocrdDEP dep(), CID1,CID2)

     quit
 

 
###
Parameter list is too long: <expression>
Cause:
 The parameter list for a subroutine has more than 1024 characters.
 
Solution:
 Review the code to determine a better method to pass the data.
 

 
###
Parenthesis expected
Cause:
 Parentheses are mismatched.
 
Solution:
 Ensure that you include the same number of closing parentheses as opening 
parentheses in the line.
 

 
###
Property is not an index: <reference>
Cause:
 The code refers to an object as though the Array Flag (OBJECTPROP.ARRAY) is 
selected, indicating that the class is a container class.
 
 
 object.tts{SEQ}.tamt

 
 
Solution:
 Rewrite the code without {} references when referring to an object property.
 

 
###
Recursive loop, Label called by label within lower level of stack list: <list>
Cause:
 Subroutine "a" calls subroutine "n" which calls subroutine "a".
 
 
 a                  // Subroutine a

   do n

   quit

n                 // Subroutine n

   do a

   quit

 
 
Solution:
 Do not structure code for infinite loops.
 

 
###
Return type expected
Cause:
 The called method requires a return type. For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

do Db.isDefined("DEP","CID")

 
 
 
 The isDefined method uses the following syntax, expecting a value to be 
returned:
 
 
 if Db.isDefined("DEP","CID")

 
 
Solution:
 Review the correct use of the method. Rewrite the code to reflect the correct 
syntax.
 

 
###
Return type not expected
Cause:
 The called method does not require a return type. For example,
 
 
 new dep

type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

set x=dep.toArray("%A(CID")

 
 
 
 The toArray method is called using the following syntax:
 
 
 do dep.toArray("%A(CID")

 
 
Solution:
 Review the correct use of the method. Rewrite the code to reflect the correct 
syntax.
 

 
###
Right Index delimiter '}' Expected: <reference>
Cause:
 A class is defined as an array (i.e., the Array Flag (OBJECTPROP.ARRAY) is 
selected). However, a reference to the array does not include the closing 
delimiter.
 
 
 object.tts{SEQ.tamt
 
Solution:
 Insert the closing delimiter in the array reference.
 
 
 object.tts{SEQ}.tamt
 

 
###
Scope mismatch between: <var> and: <lvn>
Cause:
 An array expression does not have the same scope as the variable name.
 
 
 type Public ResultSet abc

type ResultSet abc()

 
 
Solution:
 Modify the code so that the variable and array expression have the same scope.
 
 
 type Public ResultSet abc

type Public ResultSet abc()
 

 
###
Space character expected
Cause:
 A FOR loop is written incorrectly. For example,
 
 
 for I=1:1:3:4

 
 
Solution:
 The compiler expects to find a space at the position where the third colon (:) 
appears. For example,
 
 
 for I=1:1:3
 

 
###
Thrown object must be class Error
Cause:
 An attempt was made to throw an error for an object that is not defined in the 
Error class.
 
 
 if XETC="" throw INVLDTC($$^MSG(2692))

 
 
Solution:
 Define the object in the Error class.
 
 
 if XETC="" throw Class.new("INVLDTC",$$^MSG(2692))
 

 
###
Transaction ID required
Cause:
 The first parameter of the runtime.start method is a Transaction ID that 
indicates if the process is batch or client/server. This message indicates that 
the related batch or client/server was not added.
 
Solution:
 Review the runtime.start method reference. Add the necessary process.
 

 
###
Type <eClass> can not be assigned to type <aClass>
Cause:
 This error appears when any of the following conditions exist:

(1) The identifier <aClass> is declared as a different type than the assignment 
expression <eClass>. For example, the following code generates this error, 
because it attempts to assign LN to dep, which has been defined as type 
RecordDEP.
 
 
 type RecordDEP dep

set dep=Db.getRecord("LN","CID")

 
 
 
 (2) The object is not defined. For example, the following code generates this 
error, because the dep identifier type was not defined.
 
 
 set dep=Db.getRecord("DEP","CID")

 
 
 
 (3) An attempt is made to copy an object of one class to an object of another 
class.
 
 
 type RecordACN acn=Db.getRecord("ACN","CID")

type RecordLN ln=acn.copy()

 
 
Solution:
 Correct the error as follows based on the cause listed above:

(1) Either change the class specified type statement to match the class of the 
object in the getRecord method, or vice versa. That is, either change RecordDEP 
to RecordLN, or change the "LN" in the getRecord method to "DEP".

(2)  Insert a type statement prior to the set statement defining the type of the 
identifier. For example,
 
 
 type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

 
 
 
 (3)  Only copy an object of one class to another object in the same class. For 
example,
 
 
 type RecordACN acn=Db.getRecord("ACN","CID")

type RecordACN acn1=acn.copy()
 

 
###
Type command cannot be conditionally executed
Cause:
 The type command appears on the same line as a conditional if statement.
 
 
 if x=3 type RecordDEP dep=Db.getRecord

 
 
Solution:
 The type command must appear on its own line. In the following example, the 
assumption is made that dep will be instantiated using either a class.new or 
getRecord method. Run-time errors will occur if you do not instantiate the 
object.
 
 
 type RecordDep dep

if x=3 set dep=Db.getRecord("DEP","CID")
 

 
###
Undefined instance variable: <var>
Cause:
 The instance variable was declared as a single variable but is referenced as an 
array. For example,
 
 
 type RecordTTX ttx

set ttx(seq)=x

 
 
Solution:
 Either correct the object declaration if using multiple elements, or correct 
the expression to reference the object as a single element. For example,
 
 
 type RecordTTX ttx()

set ttx(seq)=x
 

 
###
Undefined method: <method>
Cause:
 The method does not exist in the OBJECTMET table.
 
Solution:
 Verify the spelling and case of the specified method. Method names are case-
sensitive. Also, review the valid list of methods. If you specify a new method, 
verify that it also appears in the OBJECTMET table.
 

 
###
Unexpected character: <character>
Cause:
 There is a mismatch of quotes in a method statement. In the following example, 
TJD is intended to be a literal string. The rules for defining a literal string 
require two sets of quotes around it. The error reported will display T from 
TJD, because it is in the location where the second quote should be.
 
 
 do Schema.createTable("TMPREGDD",""TJD",JOB,PERS,REGD,CAT","BAL", tmpregd")

 
 
Solution:
 Enter the appropriate number of quotes.
 
 
 do Schema.createTable("TMPREGDD","""TJD"",JOB,PERS,REGD,CAT","BAL", tmpregd")
 

 
###
Unexpected compiler command: <command>
Cause:
 A # appears in front of code that is not one of the valid compiler commands.
 
 
 #set x=x+1

 
 
Solution:
 Determine the intent of the statement. Either add a compiler command that is 
valid, or remove the # symbol.
 
 
 set x=x+1
 

 
###
Unexpected expression: <expression>
Cause:
 The PSL parser could not interpret an expression. This can occur, for example, 
when GT.M special variables are used but not coded into PSL.
 
 
 quit:'$T

 
 
Solution:
 Review the code. GT.M special variables that have not been accounted for are 
probably intentionally not part of PSL and therefore should not be used.
 

 
###
Unexpected expression after catch block: <xrec>
Cause:
 The catch statement syntax does not allow for coding to follow the { on the 
same line.
 
 
 CATCH verror { q:x

   do ^xxx

   }

 
 
Solution:
 Move the extra code from the CATCH statement line to its own line.
 
 
 CATCH verror {

   do ^xxx

   }
 

 
###
Unexpected return expression in FOR loop
Cause:
 You cannot return a variable when quitting a FOR loop. For example,
 
 
 set x=2

for i=1:1 quit:x>2 x do {

     code?

     }

 
 
Solution:
 Rewrite the code to quit with the value after the loop finishes processing. For 
example,
 
 
 set x=2

for i=1:1 quit:x>2 do {

     code?

     }

quit x
 

 
###
Uninstantiated object: <objectName>
Cause:
 An object has been typed by not instantiated.
 
 
 type RecordDEP dep

set x=dep.bal

 
 
Solution:
 Modify the code to also instantiate the object.
 
 
 type RecordDEP dep

set dep=Db.getRecord("DEP","CID")

set x=dep.bal
 

 
###
Variable expected
Cause:
 This error may occur for several reasons. For example, 

(1) You use a global reference in v7.0.

(2) A column is excluded from a table.column reference.
 
 
 set DSP2=$$DSPRT(crcd.finspot,crcd.)

 
 
Solution:
 The solution depends on the cause of the error:

(1) Write the code without a global.

(2) Include the missing column reference.
 
 
 set DSP2=$$DSPRT(crcd.finspot,crcd.crcd)
 

 
###
Void method expected
Cause:
 A method that is not a void method is used incorrectly.
 
 
 type IO io=Class.new("IO")

do io.read()

 
 
Solution:
 Modify the code to use the method correctly.
 
 
 type IO io=Class.new("IO")

set x=io.read()
 

 
###
###
###
Accept requires: Date Field
Cause:
 An #ACCEPT compiler command does not include the Date parameter.
 
 
 #ACCEPT ;PGM=John Miller;DSGN=Joe Smith;CR=Jane Doe

 
 
Solution:
 Include the Date parameter in the command.
 
 
 #ACCEPT Date=10/25/2002;PGM=John Miller;DSGN=Joe Smith;CR=Jane Doe
 
###
Accept requires: PGM Field
Cause:
 An #ACCEPT compiler command does not include the PGM parameter.
 
 
 #ACCEPT Date=10/25/2002;;DSGN=Joe Smith;CR=Jane Doe

 
 
Solution:
 Include the PGM parameter in the command.
 
 
 #ACCEPT Date=20/25/2002;PGM=John Miller;DSGN=Joe Smith;CR=Jane Doe
 

###
Accept requires = sign: <parameter>
Cause:
 A parameter in the #ACCEPT compiler command did not include an equal sign.
 
 
 #ACCEPT ;;DSGN=Joe Smith;CRJane Doe

 
 
Solution:
 Insert the equal sign where required in the parameter.
 
 
 #ACCEPT ;;DSGN=Joe Smith;CR=Jane Doe
 

###
Assigning system variable
Cause:
 PSL code is attempting to assign a value to a system variable.
 
 
 type Public Number CID

set %SystemDate=2

 
 
Solution:
 This should be reserved for selected batches and service class drivers.
 

###
Dead code
Cause:
 The compiler identified dead code (i.e., code that has no reference).
 
 
 type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

do XXX(.dep)

quit

set X=4

 
 
Solution:
 Remove dead code from the program, as it adds to program complexity and size 
for no reason. You can temporarily warehouse code in a program by enclosing it 
within a comment fence /* and */.
 
 
 type Public Number CID

set %CurrentDate=2

type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

do XXX(.dep)

quit

 
 
###
Dynamic SQL statement
Cause:
 The compiler generated dynamic SQL code.
 
Solution:
 Because the use of dynamic SQL may negatively impact run-time performance, the 
compiler generates this warning to remind you to formally review and accept the 
code.
 

 
###
Invalid tag with parameters inside subroutine: <subroutine>
Cause:
 A subroutine contains a line label with parameters.
 
 
 a                               // Subroutine a

   do something

b(parameter)            // Illegal tag inside a

   quit

 
 
Solution:
 Do not place tags inside subroutines (even though M allows this).
 
 
 a                               // Subroutine a

   do something

   quit
 

 
###
M Global Reference: <atom>
Cause:
 This warning identifies a place where a global reference was included. This 
warning appears in versions prior to v7.0 only.
 
Solution:
 Modify the code to avoid the use of globals.
 

###
Possible run-time error RECEXISTS
Cause:
 This warning occurs for two reasons:

(1) An object was passed from one label to another. It is possible that the 
object may return from the subroutine call with a record that is totally 
different from the one passed to it.

(2) PSL instantiated a Record<class> object that contains multiple nodes and 
that may already be in scope. This could cause a fatal run-time condition for 
tables (e.g., DEP, LN) if an existing object is partially replaced. In addition 
to this warning, PSL inserts code to perform a run-time check, and will throw an 
error if an object is in scope.
 
 
 type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

do XXX(.dep)

quit

 

XXX(RecordDEP dep)

type Public Number ICID

 
 
Solution:
 The solution depends on the cause of the warning:

(1) Do not pass objects from one label to another.

(2) Type a new definition instead of reusing the same object without typing it.
 
 
 type RecordDEP dep=Db.getRecord("DEP","CID=:CID")

do XXX(.dep)

quit

 

set dep=Db.getRecord("DEP","CID=:ICID")

quit
 

 
###
Restricted command
Cause:
 The read command is included in a routine.
 
Solution:
 Modify the code to use the IO class methods instead.
 

 
###
Restricted command - runtime Xecute
Cause:
 The xecute command was used, causing run-time evaluation of the M code which 
results in slower performance than compiled code.
 
Solution:
 Limit the use of the xecute command.
 

###
Undefined variable
Cause:
 A variable is referenced within a subroutine but cannot be defined at 
compilation based on the scope and flow of the program. This occurs when a 
variable is locally scoped with a Type or New command and subsequently 
referenced before it is assigned or instantiated. 

However, after a subroutine, function, or method is called, this test is 
suspended because the variable may be assigned in the called code. This test is 
also suspended if a variable is passed in as a formal parameter or scoped as a 
Public variable.
 
Solution:
 Rewrite the code to assign or instantiate the variable before referencing the 
variable. Quit with the value after the loop finishes processing.
 

###
Unreferenced variable
Cause:
 A variable is passed into a subroutine or scoped within a subroutine and never 
referenced.
 
Solution:
 Rewrite the code to reference the variable, or do not pass or scope the 
variable in the subroutine.
 

 
###
Unscoped variable
Cause:
 A variable referenced in a subroutine has not been scoped, either as a formal 
input parameter, with the M New command, or with the PSL Type command.
 
Solution:
 Variables that are passed into a subroutine (if they are not parameters) should 
be scoped in the subroutine as Public variables. For example,
 
 
 Type Public [String|Number|Date|AnyClass] variable

 
