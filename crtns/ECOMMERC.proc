ECOMMERC		/*
	   Procedure ID: ECOMMERC
	   DESC: Utilities to support E-Commerce
	   ORIG: SIGDAE - 03/10/99
	   	
	   KEYWORDS: E-Commerce
	
	   RELATED:
	   . $$func^rtn - description of how related
	
	   LIBRARY:
           . ACCESS1  Validate CIFAUTH entries
           . ACCESS2  Validate CIF entries
	   . CIFVAL   CIF Validation
	   . CIFVAL2  CIF Validation
	   . GETACN   Retrieve valid ACN	
	   . ENCMD5   Encrypt password fields in input array 
           . ERRXML   Build XML message for errors
	   . IBANK    Determine if customer is an IBANK customer
	   . LOGFAIL  Updates CIFAUTH table with failed logon info
	   . LOGRESET Resets logon info based on successful logon
	   . STATUS   Code for computed column CIFACCTS.STATUS
	   . SRVSTAT  Status of CIFACCTS
	  ----------------------------------------------------------------------
	  ------Revision History------------------------------------------------

	   09/14/05 - PRAKASHJ - 17173
 	              Removed deprecated and unscoped warnings.
 	           	
	   12/11/00 - GALEONET - 42810
	              o Added additional argument, ENCMTHD - Encryption 
			method, to CIFVAL2
		      o Modified CIFVAL2 section to encrypt password fields
			PASSWORD, PWD2, and PWD3 if ENCMTHD is not null.
 			Currently only encryption method "MD5" is supported.
		      o Added section ENCMD5 to support password encryption
 
	   08/31/00 - SIGDAE - 41717
		      o Modified section GETACN to consider CIF.CO when
			using USERID1 to get customer number.  This is
			required when using affinity group processing.
		      o Modified section GETACN to uppercase USERID1.
			USERID1 is stored in uppercase in the database.
		      o Modified section CIFVAL2 to no longer normalize 
			(remove spaces and uppercase) input string.
		      o Modified sections ACCESS1 to no longer
			normalize the following fields: PASSWORD, PWD2,
			and PWD3.
		      o Modified sections ACCESS2 to no longer
			normalize the following fields: DOB, HPH, PIN,
			and TAXID.

	   06/26/00 - SIGDAE - 40730
		      o Modified section GETACN to consider CIF.CO when
			using TAXID to get customer number.  This is
			require when using Affinity group processing.
		      o Changed $D to be $G to avoid undefined host
			variable errors when tag exists without a value.
		      o Modified section ACCESS2 to include a check for
			CIF.LNM.

	   04/18/00 - CHOK - 37246
		      Modify ERRXML to take 2 more parameters.
		      If DTD is 0 or 2, it will build DTD info.  
		      Label is the routine name who calls ERRXML.

	   04/11/00 - MOTENJ - 37245
	              o Added sections CIFVAL2, GETACN, ACCESS1, and ACCESS2
	                to support Customer validation without using dynamic
	                SQL.
	              o Modified section LOGFAIL to update CIFAUTH.BLKRSN when
	                the maximum number of login failures has been exceeded.
	                BLKRSN will only be updated if the current value equals
	                zero, not blocked.  Although BLKRSN is linked to a user
	                table (UTBLBLKRSN) the bank must use 0 for 'not blocked'
	                and 1 for 'Exceeded maximum password failures'.
 
	   10/11/99 - DOUGANM - 33890
	              Converted M code into PSL
	
	   06/28/99 - CONARTYR - 33821
	              Modified section IBANK to ignore closed services when
		      looking for a qualified service for an ACN.
	
	   06/25/99 - SIGDAE - 33821
	              Added code in function CIFVAL to remove whitespace
	              prior to doing a compare.
	
	   06/14/99 - Phil Chenard - 33302
	              Create new function to support computed field for
	              CIFSERV.STATUS, $$SRVSTAT.  If one or more accounts
	              within a service are active, then the service is active.
	
	   05/22/99 - SIGDAE - 33224
	              Modified section STATUS to hard code known Service
	              Categories.
	
	   05/05/99 - Chris Rickards - 32326
	              Added code to catch errors in STATUS section.
	
	   04/29/99 - Chris Rickards - 32326
	              Added section ACCTSTAT for computed data item
	              CIFACCTS.STATUS.
	              Added section IBANK to determine if an ACN is an IBANK
	              customer.
	
	   04/19/99 - Phil Chenard - 32265
	              Modified LOGFAIL section to include a update to the login
	              failure data as well as setting the status to blocked
	              when the max fails counter is exceeded.
	              Also, in LOGRESET, code is added to reset the status to
	              active.
	*/
		
	quit

ACCESS1(ACN,noindex)	// Validate CIFAUTH entries
	
	type RecordCIFAUTH cifauth=Db.getRecord("CIFAUTH","ACN")
	
	if $D(noindex("CIFAUTH.PASSWORD")),noindex("CIFAUTH.PASSWORD")'=cifauth.password quit 2
	if $D(noindex("CIFAUTH.PWD2")),noindex("CIFAUTH.PWD2")'=cifauth.pwd2 quit 2
	if $D(noindex("CIFAUTH.PWD3")),noindex("CIFAUTH.PWD3")'=cifauth.pwd3 quit 2
	if $D(noindex("CIFAUTH.ANSWER")),$$UPPER^%ZFUNC($TR(noindex("CIFAUTH.ANSWER")," ",""))'=$$UPPER^%ZFUNC(cifauth.answer) quit 2
	if $D(noindex("CIFAUTH.HINT")),$$UPPER^%ZFUNC($TR(noindex("CIFAUTH.HINT")," ",""))'=$$UPPER^%ZFUNC(cifauth.hint) quit 2
	if $D(noindex("CIFAUTH.QUESTION")),$$UPPER^%ZFUNC($TR(noindex("CIFAUTH.QUESTION")," ",""))'=$$UPPER^%ZFUNC(cifauth.question) quit 2
	if $D(noindex("CIFAUTH.SCRTWRD")),$$UPPER^%ZFUNC($TR(noindex("CIFAUTH.SCRTWRD")," ",""))'=$$UPPER^%ZFUNC(cifauth.scrtwrd) quit 2
	if $D(noindex("CIFAUTH.USERID1")),$$UPPER^%ZFUNC($TR(noindex("CIFAUTH.USERID1")," ",""))'=$$UPPER^%ZFUNC(cifauth.userid1) quit 2
	quit 0

ACCESS2(ACN,noindex)	// Validate CIF entries

	type RecordCIF cif=Db.getRecord("CIF","ACN")

	if $D(noindex("CIF.DOB")),$$FDAT^%ZM(noindex("CIF.DOB"))'=cif.dob quit 2
	if $D(noindex("CIF.HPH")),noindex("CIF.HPH")'=cif.hph quit 2
	if $D(noindex("CIF.PIN")),noindex("CIF.PIN")'=cif.pin quit 2
	if $D(noindex("CIF.TAXID")),noindex("CIF.TAXID")'=$$UPPER^%ZFUNC(cif.taxid) quit 2
	if $D(noindex("CIF.CO")),$$UPPER^%ZFUNC($TR(noindex("CIF.CO")," ",""))'=$$UPPER^%ZFUNC(cif.co) quit 2
	if $D(noindex("CIF.EMAIL")),$$UPPER^%ZFUNC($TR(noindex("CIF.EMAIL")," ",""))'=$$UPPER^%ZFUNC(cif.email) quit 2
	if $D(noindex("CIF.EXTCIF")),$$UPPER^%ZFUNC($TR(noindex("CIF.EXTCIF")," ",""))'=$$UPPER^%ZFUNC(cif.extcif) quit 2
	if $D(noindex("CIF.LNM")),$$UPPER^%ZFUNC($TR(noindex("CIF.LNM")," ",""))'=$$UPPER^%ZFUNC(cif.lnm) quit 2
	if $D(noindex("CIF.PID")),$$UPPER^%ZFUNC($TR(noindex("CIF.PID")," ",""))'=$$UPPER^%ZFUNC(cif.pid) quit 2
	quit 0
	

CIFVAL(index,noindex,ACN) 

	/*
	   Public: Validate customer based on input arrays

	   ARGUMENTS:
	   . index  	Column value pairs on an indexed column which
			can guarantee CIF uniqueness.
	   . noindex	Column value pairs to validate the CIF
			determined from index.
	   . reply	Returns ACN if CIF record validated otherwise
			it will return a warning or error message.
	
	   RETURNS:
	   . -1  Processing Error
	   .  0  Found
	   .  1  Not Found
	   .  2  Failed Validation
	
	   Example:

	   set STAT=$$CIFVAL2("CIF.TAXID=191-33-3333,CIF.HPH=610-578-1111",.ACN)
           set STAT=$$CIFVAL2("CIFAUTH.USERID1=EDDIENEST,CIFAUTH.PASSWORD=*&!*&!&*",.ACN)
	*/
	
	new input

	/*
	  Concatenate the two input arguments together prior to call
	  to CIFVAL2. This label exists to enable backward compatibility.
	*/

	set input=index_","_noindex
	quit $$CIFVAL2(input,.ACN)
	

CIFVAL2(input,ACN,ENCMTHD)

	/*
	   Public: Validate customer based on input array

	   ARGUMENTS:
	   . input	Column value pairs which can guarantee CIF uniqueness.
			This must contain at least 1 index'd pair.

	   . ACN	Returns ACN if CIF record is valid, otherwise
			it is returned as null.
	
	   . ENCMTHD    Encryption method for password fields.  /NOREQ

	   RETURNS:
	   . -1  Processing Error
	   .  0  Found
	   .  1  Not Found
	   .  2  Failed Validation

	   EXAMPLE:
	
	   set STAT=$$CIFVAL2("CIF.TAXID=191-33-3333,CIF.HPH=610-578-1111",.ACN)
           set STAT=$$CIFVAL2("CIFAUTH.USERID1=EDDIENEST,CIFAUTH.PASSWORD=*&!*&!&*",.ACN)
	*/
	new notvalid,noindex,ret
	
	// Convert input string into "noindex" array
	do STR2ARR^UTLMRPC(input,.noindex)

	set ENCMTHD=$G(ENCMTHD)
	if ENCMTHD="MD5" set ret=$$ENCMD5(.noindex) quit:ret -1
		
        set ACN=$$GETACN(.noindex)
	set notvalid=0
	if 'ACN set notvalid=1				// Not found
	if ACN set notvalid=$$ACCESS1(ACN,.noindex)
	if ACN,'notvalid set notvalid=$$ACCESS2(ACN,.noindex)

	quit notvalid


GETACN(index)

	/*
	  Public: Return ACN based on index array

	  ARGUMENT:
	  . index	Input Array

	  RETURNS:
	  . $$	Customer Number

	  EXAMPLE:

	  set ACN=$$GETACN^ECOMMERC(.index)

	*/
        type Number ACN		
	set ACN=""

	// if index given is cif.acn, then no need to check

	if $G(index("CIF.ACN"))'="" do { quit ACN
		set ACN=index("CIF.ACN")
		if 'Db.isDefined("CIF","ACN") set ACN=""
		}
	// if index given is cifauth.acn, then no need to check

	if $G(index("CIFAUTH.ACN"))'="" do { quit ACN
		set ACN=index("CIFAUTH.ACN")
		if 'Db.isDefined("CIF","ACN") set ACN=""
		}

	// if index given is cifauth.userid1 then use that to find the ACN

	if $G(index("CIFAUTH.USERID1"))'="" do { quit ACN
		new rs,USERID1
		set USERID1=$$UPPER^%ZFUNC(index("CIFAUTH.USERID1"))
		if $G(index("CIF.CO"))'="" do { quit
			new CO
			set CO=index("CIF.CO")
			type ResultSet rs
			set rs=Db.select("ACN","CIFAUTH,CIF","USERID1=:USERID1 AND CO=:CO")
			if rs.isEmpty() quit
			set ACN=rs.next(),ACN=rs.getCol(1)
			}
		type ResultSet rs=Db.select("ACN","CIFAUTH","USERID1=:USERID1")
		if rs.isEmpty() quit	
		set ACN=rs.next(),ACN=rs.getCol(1)
		}

	// if index given is cif.taxid then use that to find the ACN

	if $G(index("CIF.TAXID"))'="" do { quit ACN
		new rs,TAXID
		set TAXID=index("CIF.TAXID")
		if $G(index("CIF.CO"))'="" do { quit
			new CO
			set CO=index("CIF.CO")
			type ResultSet rs
			set rs=Db.select("ACN","CIF","TAXID=:TAXID AND CO=:CO")
			if rs.isEmpty() quit
			set ACN=rs.next(),ACN=rs.getCol(1)
			}
		type ResultSet rs=Db.select("ACN","CIF","TAXID=:TAXID")
		if rs.isEmpty() quit
		set ACN=rs.next(),ACN=rs.getCol(1)
		}

	quit ACN

ENCMD5(array)
	/*
	  Public: Encrypt password fields stored in array argument

	  ARGUMENT:
	  .  array     Input Array

	  RETURNS:
          .  $$  Error status:  
	         0 - Success
		 1 - Encryption Error
	*/

	new ENC,FIELDS,I,P,RET
	set RET=0
        set FIELDS="CIFAUTH.PASSWORD,CIFAUTH.PWD2,CIFAUTH.PWD3,CIFAUTH.PWD1RESET,CIFAUTH.PWD2RESET,CIFAUTH.PWD3RESET"

        for I=1:1:$L(FIELDS,",") set P=$P(FIELDS,",",I) if $G(array(P))'="" do {  quit:RET
               set RET=$$ENC^%ENCRYPT(array(P),.ENC)
               quit:RET
               set array(P)=ENC
	}
	quit RET
	
	
ERRXML(MSGCODE,DTD,LABEL,ARG1,ARG2,ARG3,ARG4,ARG5)	;
	type String ARGUMENT
	new RETURN,MESSAGE

	type HTML xx=Class.new("HTML")

	if $G(DTD)=0!($G(DTD)=2) do {
		set RETURN=xx.addTitle(LABEL)
		set RETURN=xx.addElement(LABEL,"ERROR?")
		set RETURN=xx.addElement("ERROR","CODE,ARGUMENT?,DESCRIPTION")
		set RETURN=xx.addAttrib("ERROR","CODE=,ARGUMENT=,DESCRIPTION=")
		}

	set RETURN=xx.addString(LABEL,0)
	// add label to XML message
	set RETURN=xx.addString("ERROR",0)

	// add message code to XML mesage
	set RETURN=xx.addProp("CODE","MSG_"_MSGCODE)

	// add parameters of the error to the XML message
	I $G(ARG1)'="" do { set RETURN=xx.addProp("ARGUMENT",ARGUMENT)
		set ARGUMENT=ARG1
		if $G(ARG2)="" quit
		set ARGUMENT=ARGUMENT_$C(124)_ARG2
		if $G(ARG3)="" quit
		set ARGUMENT=ARGUMENT_$C(124)_ARG3
		if $G(ARG4)="" quit
		set ARGUMENT=ARGUMENT_$C(124)_ARG4
		if $G(ARG5)'="" S ARGUMENT=ARGUMENT_$C(124)_ARG5
		}
	set MESSAGE=$$^MSG(MSGCODE,.ARG1,.ARG2,.ARG3,.ARG4,.ARG5)

	// add the error description to the XML message
	set RETURN=xx.addProp("DESCRIPTION",MESSAGE)

	// add closing tag to XML message
	set RETURN=xx.addString("ERROR",1)
	set RETURN=xx.addString(LABEL,1)
	quit RETURN

IBANK(ACN)
	/*
	   ARGUMENTS:
	   ACN - Customer Number /TYP=N/REQ
	
	     RETURNS:
	   0 - Not IBANK
	   1 - IBANK
	*/

	new FLG,IBNK,rs

	type ResultSet rs=Db.select("SRVCAT,SERVICE","CTBLSRVNAM","BANKPROD=1")
	if 'rs.isEmpty() while rs.next() set IBNK(rs.getCol(1),rs.getCol(2))="" 
	
	set FLG=0
	new rs 
	type ResultSet rs=Db.select("SRVCAT,SERVICE","CIFACCTS","ACN=:ACN AND STATUS NOT =6")
	if rs.isEmpty() quit FLG
	while rs.next() do { quit:FLG  
		if $D(IBNK(rs.getCol(1),rs.getCol(2))) set FLG=1
		}
	quit FLG




LOGFAIL(ACN,XCDTRY)

	/*
	   Public: Track a failed logon attempt and return a flag if the system
	   defined maximum tries has been exceeded.
	
	   ARGUMENTS:
	   . ACN	Customer number /TYP=N/REQ/MECH=VAL
	   . XCDTRY	Exceeded maximum tries flag /TYP=L/REQ/MECH=REF
	
	   Update failed login fields:
	   LSTFAILDT - date of last failed attempt
	   LSTFAILTM - time of last failed attempt
	   LOGFAILS  - logon failure counter
	   STATUS    - user status
	   BLKRSN    - blocked reason
	*/

	new BLKRSN,LSTFAILDT,LSTFAILTM,LOGFAILS,MAXFAILS,STATUS
	
	set LSTFAILDT=%CurrentDate 
	set LSTFAILTM=%CurrentTime
	
	set XCDTRY=0	//Initialize exceeded tries flag
	
	type RecordCIFAUTH cifauth=Db.getRecord("CIFAUTH","ACN")
	set LOGFAILS=cifauth.logfails
	set STATUS=cifauth.status
	set BLKRSN=cifauth.blkrsn
	set MAXFAILS=CUVAR.maxlogfails
	if +MAXFAILS=0 set MAXFAILS=3
	set LOGFAILS=LOGFAILS+1
	if LOGFAILS'<MAXFAILS set XCDTRY=1 set STATUS=2
	if XCDTRY=1,+BLKRSN=0 set BLKRSN=1	// Exceeded maximum password failures
	
	do Db.update("CIFAUTH","LSTFAILDT=:LSTFAILDT,LSTFAILTM=:LSTFAILTM,LOGFAILS=:LOGFAILS,STATUS=:STATUS,BLKRSN=:BLKRSN","ACN=:ACN")

	quit 

	
LOGRESET(ACN)
	/*
	   Public: Reset login fields and failure counter

	   ARGUMENTS:
	   . ACN	Customer number /TYP=N/REQ/MECH=VAL

	   Update login fields and initialize failure counter.
	   LSTLOGDT  -  last logon date
	   LSTLOGTM  -  last logon time
	   LOGFAILS  -  logon failure counter
	   FRSTLOGDT -  first logon date (only set once)
	   FRSTLOGTM -  first login time (only set once)
	   STATUS    - user status
	   BLKRSN    - blocked reason
	*/

	type Number BLKRSN
	
	new LSTDT,LSTTM,LOGFLS,FRSTDT,FRSTTM,STATUS

	set LSTDT=%CurrentDate 
	set LSTTM=%CurrentTime 
	set LOGFLS=""
	set BLKRSN=0 
	set STATUS=1
	
	type RecordCIFAUTH cifauth=Db.getRecord("CIFAUTH","ACN")
	set FRSTDT=cifauth.frstlogdt
	set FRSTTM=cifauth.frstlogtm
	if FRSTDT="" set FRSTDT=%CurrentDate set FRSTTM=%CurrentTime
	do Db.update("CIFAUTH","LSTLOGDT=:LSTDT,LSTLOGTM=:LSTTM,LOGFAILS=:LOGFLS,FRSTLOGDT=:FRSTDT,FRSTLOGTM=:FRSTTM,STATUS=:STATUS,BLKRSN=:BLKRSN","ACN=:ACN")

	quit 
	

STATUS(SRVCAT,SERVICE,ACCKEY)
	/*
	   ;Public ;Code for Computed Data Item CIFACCTS.STATUS
	
	   ARGUMENTS:
	   	SRVCAT - Service Category /TYP=T/REQ
	   	SERVICE - Service Name  /TYP=T/REQ
	   	ACCKEY - Composite Access Key /TYP=T/REQ
	
	     RETURNS:
	   	Account Status  [CTBLESTATUS]
	*/
	type public Boolean ER
	new SQL,TABLE,ANS,STATUS

	type RecordACN acn=Db.getRecord("ACN","ACCKEY")
	type RecordMEMOCC memocc=Db.getRecord("MEMOCC","SERVICE,ACCKEY")
	type RecordMEMOBILLPAY memobillpay=Db.getRecord("MEMOBILLPAY","SERVICE,ACCKEY")
	type RecordMEMOBROKER memobroker=Db.getRecord("MEMOBROKER","SERVICE,ACCKEY")
	type RecordMEMOECOM memoecom=Db.getRecord("MEMOECOM","SERVICE,ACCKEY")
	type RecordMEMOPYMTS memopympts=Db.getRecord("MEMOPYMTS","SERVICE,ACCKEY")
	
	if SERVICE="PROFILE",((SRVCAT="DEPOSIT")!(SRVCAT="LOAN")) set STATUS=acn.stat quit $S(STATUS=0:1,STATUS=4:6,STATUS=1:5,STATUS=2:5,STATUS=3:2,1:0)
	if SRVCAT="CREDIT" set STATUS=memocc.status quit +STATUS
	if SRVCAT="BILLPAY" set STATUS=memobillpay.status quit +STATUS
	if SRVCAT="BROKER" set STATUS=memobroker.status quit +STATUS
	if SRVCAT="ECOMMERCE" set STATUS=memoecom.status quit +STATUS
	if SRVCAT="PAYMENTS" set STATUS=memopympts.status quit +STATUS
	/*
	If not hard coded above, dynamically create a SQL statement to
	return the status
	*/
	
	type RecordSTBLSRVCAT stblsrvcat=Db.getRecord("STBLSRVCAT","SRVCAT")
	set TABLE=stblsrvcat.datatbl
	if ($G(ER))!($G(TABLE)="") quit ""
	set SQL="STATUS FROM "_TABLE_" WHERE SERVICE=:SERVICE AND ACCKEY=:ACCKEY"
	set ER=$$^SQL("SELECT "_SQL,,,.ANS)

	quit +$G(ANS)

	
	
SRVSTAT(ACN,SRVCAT,SERVICE)
	/*
	   status of CIFACCTS
	
	   ARGUMENTS:
	   . SRVCAT - Service Category  /TYP=T/REQ/MECH=VAL
	
	   . SERVICE - Service name  /TYP=T/REQ/MECH=VAL
	
	
	   RETURNS:
	   . STATUS - Service status
	*/
	
	new rs,status,stat

	set stat=0
	type ResultSet rs=Db.select("STATUS","CIFACCTS","ACN=:ACN AND SRVCAT=:SRVCAT AND SERVICE=:SERVICE")
	if rs.isEmpty() quit stat
	while rs.next() do { quit:stat=1  
		set status=rs.getCol(1)
		if (status=1)!(status=7) set stat=1 quit 
		if (status=3)!(status=4)!(status=8) set stat=2
		}	
	quit stat

vSIG()	quit "60159^22217^Jaimano Prakash^16136"	// Signature - LTD^TIME^USER^SIZE
