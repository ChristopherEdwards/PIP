ZUCT7E0J		/*
	 ORIG: Frans S.C. Witte, 2005-08-26
	 DESC: DBI3 - PSL Full Optimization (CRs 18163/18164)

	---- Comments ----------------------------------------------------------
	Until this CRs the RDB code had been excluded from most of the
	optimizations that Frank built into the PSL compiler. As part of the
	DBI3 project, the optimizations have been applied to the RDB code a
	well.

	The existing optimization mechanisms have evolved over time, and had to
	be built into an earlier version of the code generator. This resulted in
	a mix of methodologies, with the code in the M routines as the primary
	(if not only) source of documentation, which made it quite
	understandable that RDB code had been excluded.

	The relevant optimizations
	==========================
	A number of optimizations are independent of the database. Literal
	optimization is a good example. The relevant optimizations for the
	database are:
	* Incremental loading of data nodes
	* Replacing subscripted vobj(oid,sub) nodes by unsubscripted local
	  variables voxn
	* Calculate the value of a complex computed column at most once per
	  load-section
	* Bypass the filer to save a record, provided this is safe.

	Incremental Loading of Data Nodes
	=================================
	Depending on the table's recordType, the code generated for
	Db.getRecord() will not retrieve the entire record. Instead only the
	"top" node (recordType 11) or the default node (if present for
	recordType 10) will be loaded within the vDbN()subroutine generated for
	this method. Additional nodes will be loaded at the start of the code
	block where and when a column is referenced that resides on that node.
	The code generated to load the node furthermore depends on the record
	mode: known to be new, known to be existing, unknown.

	In order to support incremental loading, the compiler needs to keep
	track of which nodes of a record instantiation are accessed in which
	code blocks.

	The implementation up to CR18163 used dbLoad(sr,varptr,loadnumber,node)
	to keep track of nodes that are accessed.

	Replacing vobj(oid,sub) by voxn
	===============================
	This technique extends the mechanism used for Reference descendants that
	are implemented as Primitives. Such objects are stored directly in the
	named object variable. Because the applicability is known immediately
	when the code is generated, it will be applied in the first pass of code
	generation. When used for Reference descendants for which the
	applicability is not known beforehand, the replacement needs to be
	postponed until the "second pass" of code generation. This mechanism is
	used for Record class instances and for ResultSet class instances. This
	technique could be applied to every reference class with a known, fixed
	structure.

	Implementing this is a lot more complex. Because the replacements are
	made after the first pass, so all applicable occurrences of
	vobj(oid,sub) need to be traceable. An additional complication is that
	the applicability of the replacement will depend on the context in which
	an object instance is used: One RecordDEP instance may be replaceable,
	the other may not, but the code generated in the first pass will use the
	same vDbN() subroutine for both.

	The implementation up to CR18163 used calls to $$patch^UCPATCH() to
	substitute optimizable code elements (expressions, command arguments) by
	tokens. The tokens were replaced by actual M code in the "patch pass"
	(^UCPATCH). This pass iterated over all nodes in
	patch(0,sr,var,declaration).

	Calculating the Value of Complex Computed Columns at Most Once
	==============================================================
	This technique is used for Record class instances. More precisely for
	computed columns that require an M extref to calculate the value. This
	technique could be applied to RDB masterfields and MDB subfields as
	well.

	Up to CR18163, when a "complex computed" was detected in the composition
	of a computed expression, code was added to assign the value to
	vobj(oid,-300,colname), and "vobj(oid,-300,colname)" was used as the
	"current column value" (instead of the extref). The variable
	dbLoad(sr,oid,ldnr,-1,colname) was used to indicate that additional
	assignments were needed after loading the nodes but before referencing
	any column value.

	Bypass the Filer to Save a Record, Provided that is Safe
	========================================================
	This technique is used for Record class instances under a very limited
	number of conditions:
	* recordType=1
	* Recordscope = "NEW" (i.e. Record declared, instantiated, and used in
	  single subroutine)
	* Record.setAuditFlag(0)
	* Instance not passed as parameter to other subroutine.
	* No index columns are modified
	* Record.bypassSave() is used to save the record

	An earlier decision to make bypassSave() equivalent to
	save("/well/defined/qualifiers") effectively removed this optimization
	because Record.save() would always call the filer routine if one was
	present.

	Other Known Limitations
	=======================
	Apart from the fact that the current implementation does not support
	optimization of RDB table access, the following limitations had been
	identified:
	* Instantiations within conditional code or in iterative code may lead
	  to incorrect incremental load code.
	* Incremental load code does not consider the possibility that an
	  instance passed to a subroutine is re-instantiated inside the
	  subroutine
	* Changes to a local variable that is used in the accesskey expression
	  of a record retrieval method may lead to incorrect retrievals of
	  incremetally loaded records (MDB only).
	* Instantiation and access on the same line (if table's recordType>1)
	* Two instantiations on the same line (if table's recordType>1)
	None of the above limitations were reported by the compiler.

	The subroutines in this unit were originally desgined to demonstrate the
	behavior and limitations of the optimizations before CR18163. As such
	they represent a nice test set to validate the capabilites of any changes
	that pretend to improve the optimization.

	---- Revision History --------------------------------------------------
	2005-08-26 Frans S.C. Witte
		Initial program, built for CR18163
	2006-10-20 Frans S.C. Witte
		Added introduction (from "pslFullOptimization.rtf") and included
		as part of the PSL Compiler Test Suite.
	*/
	quit

	// ---------------------------------------------------------------------
	/* ---------------------------------------------------------------------
	Subroutine that demonstrates one declaration with different kinds of
	instantiations and access occurrences.

	NOTES:
	. This subroutine contains a call to lbl^rtn(), which is a non-existing
		entrypoint. So the code cannot be executed, unless the call is
		replaced by a call to a different entrypoint, preferably within
		the PSL Compiler Testsuite that can be called without causing
		unintended side effects.
	*/
public sr( Number cid) //
	type Number anpto,boo,lrias,stp2
	type String cls,stp
	type RecordLN rec						// DECLARATION
	set rec=Db.getRecord("LN","CID=:cid")				// INSTANTIATION 1
	set cid = cid + 1
	if 10.random()>4 set rec=Db.getRecord("LN","CID=:cid") do {	// INSTANTIATION 2
		// code block
		set cid = cid + 1
		set stp = rec.stp					// ACCESS 1
	}
	if 10.random()>6 set rec=Class.new("RecordLN","CID=:cid") do { // INSTANTIATION 3
		// code block
		set cid = cid + 1
		set boo = rec.boo					// ACCESS 2
	}
	while 10.random() > 3 do {
		set boo = rec.boo					// ACCESS 3
		set rec = Db.getRecord("LN","CID=:cid")			// INSTANTATION 4
		set cid = cid + 1
		set stp2 = rec.stp2					// ACCESS 4
	}
	set anpto = rec.anpto / 2					// ACCESS 5
	type Number mode = rec.getMode()				// ACCESS 6
	type Number cid2 = rec.cid					// ACCESS 7
	do lbl^rtn(.rec)						// "INSTANTIATION" 5
	type Boolean b = rec.osgncrdc					// ACCESS 8
	set cid2 = rec.cid						// ACCESS 9
	quit

	// ---------------------------------------------------------------------
	/* ---------------------------------------------------------------------
	Similar subroutine. Hoever RecordLN is delcared as formal parameter
	with an implied instantiation).
	*/
sr2( RecordLN rec, Number cid) //					// DEC 1
	type Number boo,anpto,lrias,stp2
	type String cls,stp,ponpt
	set cid = cid + 1
	if 10.random()>4 set rec=Db.getRecord("LN","CID=:cid") do {	// INS 1
		// code block
		set cid = cid + 1
		set stp = rec.stp					// ACC01
	}
	if 10.random()>6 set rec=Class.new("RecordLN","CID=:cid") do {	// INS 2
		// code block
		set cid = cid + 1
		if 5.random()>2 set boo = rec.boo			// ACC02
	}
	while 10.random()>1 do {
		set boo = rec.boo					// ACC03
		set ponpt = rec.ponpt
		set rec = Db.getRecord("LN","CID=:cid",1)		// INS 3
		set cid = cid + 1
		set stp = rec.stp2 _"&"_rec.stp3			// ACC04
	}
	set anpto = rec.anpto / 2					// ACC05
	type Number mode = rec.getMode()				// ACC06
	type Number cid2 = rec.cid					// ACC07
	set boo = rec.boo						// ACC08
	do lbl^rtn(.rec)						// INS 4
	set mode = rec.getMode()
	set ponpt = rec.ponpt
	type Boolean b = rec.osgncrdc					// ACC09
	set rec.bal = rec.anpto + 10					// ACC10
	type Number cc = rec.bal + rec.lrias				// ACC11
	quit

	// ---------------------------------------------------------------------
sr3( Number cid) //
	type public Cache AppCache()
	type Number anpto
	type String stp
	type RecordLN rec = AppCache("LN").getRecord("LN","CID=:cid")	// INS 1
	// code block
	set cid = cid + 1
	set stp = rec.stp					// ACC01
	if 5.random()>2 set anpto = rec.anpto			// ACC02
	quit

	// ---------------------------------------------------------------------
	/* ---------------------------------------------------------------------
	Small examples of combinations of
	- declaration
	- (conditional) instantiation
	- call to local subroutine
	- column access
	*/
caller11( Number cid)	//
	type RecordLN rec				// declared, and ...
	if 10.random()>6 set rec = Db.getRecord("LN", "CID=:cid")
	do called1( .rec)				// ... maybe inst.
	type Number anpto = rec.anpto
	quit

caller12( Number cid)	//
	type RecordLN rec				// declared and ...
	set rec = Db.getRecord("LN", "CID=:cid")	// ... instantiated
	do called1( .rec)
	type Number anpto = rec.anpto
	quit

caller13( Number cid, RecordLN rec)			// passed only
	do called1( .rec)
	type Number anpto = rec.anpto
	quit

caller14( Number cid)	//
	type RecordLN rec				// declared and ...
	do called1( .rec)				// ... not instantiated
	type Number anpto = rec.anpto
	quit

called1( RecordLN rec) // [R] Only References the object
	type Number ponpt = rec.ponpt
	quit

caller21( Number cid)	//
	type RecordLN rec				// declared, and ...
	if 10.random()>6 set rec = Db.getRecord("LN", "CID=:cid")
	do called2( .rec)				// ... maybe inst.
	type Number anpto = rec.anpto
	quit

caller22( Number cid)	//
	type RecordLN rec				// declared and ...
	set rec = Db.getRecord("LN", "CID=:cid")	// ... instantiated
	do called2( .rec)
	type Number anpto = rec.anpto
	quit

caller23( Number cid, RecordLN rec)			// passed only
	do called2( .rec)
	type Number anpto = rec.anpto
	quit

caller24( Number cid)	//
	type RecordLN rec				// declared and ...
	do called2( .rec)				// ... not instantiated
	type Number anpto = rec.anpto
	quit
	
called2( RecordLN rec) // [M] References and modifies, no instantiation
	type Number ponpt = rec.ponpt
	set rec.bal = 300.random()
	quit

caller31( Number cid)	//
	type RecordLN rec				// declared, and ...
	if 10.random()>6 set rec = Db.getRecord("LN", "CID=:cid")
	do called3( .rec, cid)				// ... maybe inst.
	type Number anpto = rec.anpto
	quit

caller32( Number cid)	//
	type RecordLN rec				// declared and ...
	set rec = Db.getRecord("LN", "CID=:cid")	// ... instantiated
	do called3( .rec, cid)
	type Number anpto = rec.anpto
	quit

caller33( Number cid, RecordLN rec)			// passed only
	do called3( .rec, cid)
	type Number anpto = rec.anpto
	quit

caller34( Number cid)	//
	type RecordLN rec				// declared and ...
	do called3( .rec, cid)				// ... not instantiated
	type Number anpto = rec.anpto
	quit
	
called3( RecordLN rec, Number cid) // [I] re-instantiates (conditionally)
	if 8.random() < 5 set rec = Db.getRecord("LN", "CID=:cid")
	type Number ponpt = rec.ponpt
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60585^45994^Frans S.C. Witte^11914"	// Signature - LTD^TIME^USER^SIZE
