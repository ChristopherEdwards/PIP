RETOUT		/*
	  ---- Revision History ------------------------------------------------
	  
	   06/29/06 - DESHPANDE S K - CR 20748
	  	      Replace exc.disc with exc.sysbase in RTRN section.

	   05/15/06 - RussellDS - CR21296
		      Changed to use cache array instead of %CACHE, which is
		      reserved for PSL record objects.
		      
		      Corrected PSL warning issues.
	
	   11/18/05 - HAILEYM - CR18146
	   	      Updated to DBI Standards.
	   
	   02/02/01 - ITIGIB - 43028
	  	      Modified section RTRN to display the check number
		      associated with a return item within the return 
		      item history entry.	
		
	   08/16/00 - SCHWARTZC - 41392/41545
		      Prevent account history records for return items for
		      invalid accounts.

	   03/20/00 - REEDD - 37693
	 	       Roll Forward changes for ARQ 35159

  	   01/20/00 - SCHWARTZC - 35159
			Change which items are considered "Undecided."
			According to the project requirements, undecided
			items are those items where the review completed flag
			is null or zero.

	   12/13/99 - REEDD - 35159	
   		        If the return item flag is 3 - Undecided do not include
			undecided items in the return item file.

	   01/17/00 - SCHWARTZC - 36651/35136
		      Added call to VERITEM in section NEXCEP to determine if
		      an item in EXC should be returned or not.

		      Modified the RTRN section to create a non-financial history
		      record to the account for the returned item and to
		      generate the correct return item fees if the FOPT option
		      is set.

	   09/13/99 - SCHWARTZC - 33301
		      Add SRC and RETEXT to the EXT line tag parameters.
		      Added code at the top of EXT section to default SRC and
		      RETEXT.
	
	   08/17/99 - GRAY - 34423
		      Prevent non-financial and general ledger transactions
		      from being included in returned item output file.
	
	   08/05/99 - DOUGANM - 33890
		      Converted M code into PSL

	   02/20/99 - GEISSP - 32373
	              Modified RTRN section to use new user table UTBLEXTRSP1
	              to get the return reason(s).
	
	   02/15/99 - GEISSP - 31874
	              Initialize FILCNT to zero.
	
	   02/11/99 - GEISSP - 31874
	              Removed hardcoded language phrases.
	              Changed calls to ^%ZD to DAT^%ZM.
	
	   02/06/99 - SIGDAE
	              Modified section RTRN to set the RET array equal to
	              the override code.
	  ----------------------------------------------------------------------
	*/
	
	type Date DATE
	type Number FOPT,RETEXT
	type String %READ,%TAB,SRC,VFMQ

	set %TAB("DATE")=".XJD1/REQ"
	set %TAB("SRC")=".SOURCE/HLP=[CTBLINC]KEY/TBL=[CTBLINC]"
        set %TAB("RETEXT")=".DECISION/HLP=[STBLRETEXT]KEY/TBL=[STBLRETEXT]"
	set %TAB("FOPT")=".FEEOPT",FOPT=0
        set %READ="@@%FN/REV/CEN,,DATE,SRC,RETEXT,FOPT"
        do ^UTLREAD quit:VFMQ="Q"
        do EXT(DATE,SRC,RETEXT,FOPT)

	quit
	
	
EXT(Date DATE,		// Date
	String SRC,	// Inclearing Source
	Number RETEXT,	// Decision
	Number FOPT)	// Fee Option

	// Collate through CTBLINC to load parameters, external call tag
	
	type public Boolean ER
	type public String cache
	
	type Boolean SDRTY,XRET
	type Number FILCNT,FILCR,FILDR,XBRCD
	type String OUTREC,PGM,RTRY,WHERE,XCODE,XKEY,XTELLER,XTJD
	
	type DbSet ds
	type IO io,iolog
	type RecordCTBLINC ctblinc
	
	if DATE.get().isNull() set DATE=%SystemDate
	set FOPT=+FOPT.get()
	set SRC=SRC.get()
        set RETEXT=+RETEXT.get()
        set XTJD=DATE.toString("MMDDYEAR")

	if SRC.isNull() set WHERE=""
	else  set WHERE="KEY='"_SRC_"'"
	
	set io=Class.new("IO")
	set iolog=Class.new("IO")
	
	// Accept "Dynamic SQL statement" warning
	#ACCEPT Date=11/18/2005;PGM=Marie Hailey;CR=18146
	set ds=Db.selectDbSet("CTBLINC",WHERE)
	if ds.isEmpty() quit
	while ds.next() do {
		
		catch vERROR {
			do ZE^UTLERR
			do EXC
			set ER=0
			}
		
		set ctblinc=ds.getRecord("CTBLINC")
		
		quit:ctblinc.rtrn.isNull()	// No Return Program Defined

		set FILCNT=0                          
		set XKEY=ctblinc.key
		set XBRCD=ctblinc.brcd
		set XTELLER=ctblinc.teller
		set XRET=ctblinc.ret
		set PGM=ctblinc.rtrn.translate("^","")
	
		if 'cache("RETOUT", "SCAU", XTELLER).exists() do {
			type RecordSCAU scau = Db.getRecord("SCAU", "UID=:XTELLER", 1)
			if 'scau.getMode() set cache("RETOUT", "SCAU", XTELLER) = ""
			else  set cache("RETOUT", "SCAU", XTELLER) = scau.rtuid_9.char()_scau.sdrty
			}
		/*
		If the user does not want a file created when there are no 
		detail records (i.e. header,trailer only) then the following 
		line should be uncommented.
		*/	
		/* if '$$VERIFY(XTELLER,XBRCD,DATE) quit */

		do INIT^@PGM quit:ER.get() 
		do OPEN(.io,XTJD,XKEY) quit:ER.get()
		
		set XCODE="S OUTREC=$$HEADER^"_PGM_"(.io)"
		// Accept "Xecute" warning
		#ACCEPT Date=11/29/2005;PGM=Marie Hailey;CR=18146
		xecute XCODE
		do io.write(OUTREC)
		
		set RTRY = cache("RETOUT", "SCAU", XTELLER).piece(9.char(),1)
		set SDRTY = cache("RETOUT", "SCAU", XTELLER).piece(9.char(),2)            
		if 'SDRTY do EXCEP(.io,XKEY,XTELLER,XBRCD,DATE,RETEXT,FOPT)                  
	
		// if source teller has a retry teller get those rejected transactions
		if RTRY,$$VERIFY(RTRY,XBRCD,DATE) do EXCEP(.io,XKEY,RTRY,XBRCD,DATE,RETEXT,FOPT)
	
		set XCODE="S OUTREC=$$TRAILER^"_PGM_"(.io)"
		// Accept "Xecute" warning
		#ACCEPT Date=11/29/2005;PGM=Marie Hailey;CR=18146
		xecute XCODE
		do io.write(OUTREC)
		
		do io.close()
		do LOG(.iolog,XTJD,XKEY)
		}
	quit 
	
	
VERIFY(String XTELLER,	// Teller ID
	Number XBRCD,	// Branch Code
	Date DATE)	// Date

	// Verify Data File, initialize output format
	
	type ResultSet rs=Db.select("CID","EXC","UID=:XTELLER AND BRCD=:XBRCD AND TJD=:DATE")
	quit rs.isEmpty()
	

OPEN(IO io,		// IO Object
	String XTJD,	// Formatted Date - MMDDYEAR
	String XKEY)	// Inclearing Source

	// Open Return File Device
	
	type public Number RECSIZ
	
	set io.fileName="RETURN_"_XKEY_"-"_XTJD_".PBS"
	set io.openParams="WRITE/NEWV"
	set io.recordSize=RECSIZ.get()
	do io.open()
	quit 
	

EXCEP(IO io,		// IO Object
	String XKEY,	// Inclearing Source
	String XTELLER,	// Teller ID
	Number XBRCD,	// Branch Code
	Date DATE,	// Date
	Number RETEXT,	// Decision
	Number FOPT)	// Fee Option
	
	// Cycle through exception file
	
	type public Boolean ER
	type public String PGM
	
	type Boolean PAID,RETVAL,REVIEW
	type Number CHGFEE
	type String PRETRES,REASON,ZCODE,ZPRETRES
	
	type DbSet ds
	type RecordEXC exc
	
	set ZCODE="S OUTREC=$$DETAIL^"_PGM_"(.io)"
	
	set ds=Db.selectDbSet("EXC","UID=:XTELLER AND TJD=:DATE AND BRCD=:XBRCD AND RTY=0")
	while ds.next() do {
		
		catch vERROR {
			do ZE^UTLERR
	        	do EXC
        		set ER=0
			}
		
		set exc=ds.getRecord("EXC")
		
		quit:'$$VERITEM(.exc,.REASON,.CHGFEE,.RETVAL,.REVIEW,.ZPRETRES)
		
		// Do not process records not defined as returned (RET.RET=1) if
		// using return option 1
		if RETEXT=1,RETVAL<>1 quit

		// Set the Paid/Unpaid indicator for return option 2
		if RETEXT=2,RETVAL=1 set PAID=0
		else  set PAID=1

		// If the return item flag is 3 - Undecided do not include
		// undecided items in the return item file.
		if RETEXT=3,'REVIEW quit

		// Set the return reason for return options 1 and 2
		/*
		If this record has not been reviewd (REVIEW=0) or this record 
		does not have a primary return reason defined then we set the 
		primary return reason for the extract file to literal "None".
		*/
		if RETEXT>0 set PRETRES=$S('REASON.isNull():REASON,1:$$^MSG(7785))

		do RTRN(.io,.exc,XKEY,RETEXT,FOPT,PRETRES.get())
		}
	quit
	
	
RTRN(IO io,		// IO Object
	RecordEXC exc,	// EXC Record
	String XKEY,	// Inclearing Source
	Number RETEXT,	// Decision
	Number FOPT,	// Fee Option
	String PRETRES)	// Primary Return Reason
	
	// Create Return File
	
	type public Date DATE
	type public String cache
	type public Number CHGFEE,FILCNT,FILCR,FILDR,XBRCD
	type public String REASON,XTELLER,ZCODE,ZPRETRES
	
	type Boolean REJ
	type Number CID,X,XCID,XTSEQ
	type String C,ETC,OUTREC,REC,RET(),UTSO,VAL(),XTSO
	
	set VAL("ITC")=exc.itc
	if VAL("ITC").isNull() quit
	set (VAL("ETC"),ETC)=exc.etc
	if VAL("ETC").isNull() quit
	
	if 'cache("RETOUT", "TRN", ETC).exists() do {
		type RecordTRN trn = Db.getRecord("TRN", "ETC=:ETC", 1)
		if 'trn.getMode() set cache("RETOUT", "TRN", ETC) = ""
		else  set cache("RETOUT", "TRN", ETC) = trn.cls
		}
		
	if cache("RETOUT", "TRN", exc.etc) = "M" quit
	
	set C=9.char()
	set REC=exc.tseq_C_exc.brcd_C_exc.cid_C_exc.itc_C_exc.etc_C_exc.tamt
	set REC=REC_C_exc.efd_C_exc.tlo_C_exc.tso_C_exc.tcmt_C_exc.cdt_C_exc.tim
	set REC=REC_C_exc.brcde_C_exc.trc_C_exc.uidt_C_exc.spr_C_exc.tsb
	set REC=REC_C_exc.lnerc_C_exc.crcd_C_exc.rate_C_exc.sysbase_C_exc.ben
	set REC=REC_C_exc.dir_C_exc.chktyp_C_exc.rty_C_exc.endbal_C_exc.mult
	set REC=REC_C_exc.bseamt_C_exc.custcd_C_exc.tresref_C_exc.otcmt_C_exc.otso
	
	set (VAL,UTSO,RET)=""
	set XTSO=exc.tso
	set XCID=exc.cid
	set VAL("CID")=XCID
	set VAL("TAMT")=exc.tamt
	set VAL("EFD")=exc.efd
	set VAL("TSO")=XTSO
	set VAL("TCMT")=exc.tcmt
	set VAL("CRCD")=exc.crcd
	set:VAL("ITC").extract()=0 FILDR=VAL("TAMT")+FILDR.get()
	set:VAL("ITC").extract()=1 FILCR=VAL("TAMT")+FILCR.get()
	do OUT^UTSO(.UTSO,XTSO)
	set XTSEQ=exc.tseq              
	
	/*
	IF transaction was rejected due to overrides required array RET will
	contain the reject reason associated with the Override codes that is
	found in user table EXTINT_7 for the Source code (XKEY).  If an entry
	doesn't exist in the table then the override code will be used.
	
	ELSE if the teller comment can be found in the system error log,
	RET will contain the reject reason associated with the system error
	code that corresponds to the teller comment that is found in user
	table EXTINT_7.  If the system error code is not found in table
	EXTINT_7 then the system error code will be used. (for example
	teller comment:  Record not on File, would return RECNOF).
	
	ELSE RET will contain the default value associated with the source
	code in user table EXTINT_7.  If no default value is found the first
	6 characters of the teller comment will be used.
	*/

	if RETEXT=0 do {
		type ResultSet rs2=Db.select("OVR","EXC1","UID=:XTELLER AND TJD=:DATE AND CID=:XCID AND TSEQ=:XTSEQ AND BRCD=:XBRCD")
		set REJ='rs2.isEmpty()
		if REJ for X=1:1 quit:'rs2.next()  set RET(X)=$$ZEXTRSP(rs2.getRow(),XKEY)
		}

	if RETEXT>0 do {
		set RET(1)=$$ZEXTRSP(PRETRES,XKEY)
		if RET(1).isNull() set REJ=0 quit
		set REJ=1
		}
	
	if 'REJ set RET(1)=$$ZEXTRSP($$TRANS(VAL("TCMT")),XKEY)

	// Accept "Xecute" warning
	#ACCEPT Date=11/29/2005;PGM=Marie Hailey;CR=18146
	xecute ZCODE
	do io.write(OUTREC)
	
	set FILCNT=FILCNT.get()+1

	// Charge fee if applicable and build non-financial return item 
	// history entry
	if FOPT do EXT^RETFEE(DATE,XBRCD,XCID,XTELLER,XTSEQ,REASON,CHGFEE)
	
	if 'Db.isDefined("ACN","CID=:XCID") quit
	
	set %UserID=XTELLER
	set CID=XCID
	// Returned item for amount: ~p1
	if exc.ck.isNull() do HISTBLD^ACNFUNCS($$^MSG(3980,exc.tamt,ZPRETRES)) quit
	// Returned item for check #~p1 for amount ~p2
	do HISTBLD^ACNFUNCS($$^MSG(4715,exc.ck,exc.tamt,ZPRETRES))

	quit
	
	
TRANS(String RET)	// Error Message
	/*	
	Translate the value passed in to the corresponding System Error. For 
	example Record Not on File would return RECNOF. If the value passed in 
	does not exist in the system error table then return the first 6 
	characters of RET.
	*/
	
	if RET.get().isNull() quit ""
	
	type String ZRET
	
	type ResultSet rs
	
	if RET.extract()="#" set RET=RET.piece(" ",2,99)
	
	set rs=Db.select("KEY","STBLER","RM=:RET")
	if rs.isEmpty() quit ""
	
	if rs.next() set ZRET=rs.getCol(1)

	quit $S('ZRET.isNull():ZRET,1:RET.extract(1,6))
	

ZEXTRSP(String XCODE,	// PROFILE Error/Override Key
	String SRC)	// Inclearing Source	
	/*
	Return the value associated with XCODE from the EXTINT_7
	user table for the specified source code.  If this value is not
	defined then look for the default value.
	*/

	type public Boolean ER
	
	type String RM,ZRET
	
	type RecordUTBLEXTRSP1 uextrsp1

	if XCODE.get().isNull()!(SRC.get().isNull()) quit XCODE
	
	set uextrsp1=Db.getRecord("UTBLEXTRSP1","INTRFACE=:SRC,KEY=:XCODE",1)
	if 'uextrsp1.getMode() set ZRET=""
	else  set ZRET=uextrsp1.respcde1
	
	if 'ZRET.isNull() quit ZRET
	
	// No table entry
	set RM=$$^MSG(4858)_" - "_XCODE_"~"_SRC do EXC set ER=0

	// Look for a default reject code
	set uextrsp1=Db.getRecord("UTBLEXTRSP1","INTRFACE=:SRC,KEY='DEFAULT'",1)
	if 'uextrsp1.getMode() set ZRET=""
	else  set ZRET=uextrsp1.respcde1
	
	if 'ZRET.isNull() quit ZRET

	quit XCODE
	

VERITEM(RecordEXC exc,		// EXC Record
	String REASON,		// Primary Return Reason
	Number CHGFEE,		// Charge Fee Indicator
	Boolean RETVAL,		// Return Flag
	Boolean REVIEW,		// Account Review Completion
	String ZPRETRES)	// Primary Return Reason - SAVED
	
	// Determine if the current item should be returned.
	/*
         Return 0 if the item should not be returned
         Return 1 if the item should be returned or no return item record
               exist for the item.
        
         Returns
               REASON		Primary Return Reason
               CHGFEE		Charge Fee Indicator
               RETVAL		Return Flag
               REVIEW		Account Review Completion
               ZPRETRES		Primary Return Reason - SAVED
	-----------------------------------------------------------------------
	*/
	
	type Boolean RTNVAL
	type Number OFFDYS
	
	type RecordRET ret
	
	set ret=Db.getRecord("RET","TJD=exc.tjd,BRCD=:exc.brcd,CID=exc.cid,UID=exc.uid,TSEQ=:exc.tseq",1)
	if 'ret.getMode() do { quit 1
		set CHGFEE=0
		set (REASON,REVIEW,ZPRETRES)=""
		set RETVAL=1
		}

	set OFFDYS=$$OFFDAYS(ret.src,exc.tjd,exc.cid)
	set REVIEW=ret.review
	set ZPRETRES=ret.pretres

	if REVIEW!(OFFDYS=2) do {
		set CHGFEE=ret.fee
		set REASON=ret.pretres
		set RETVAL=ret.ret
		set RTNVAL=1
		}
	else  if OFFDYS=1 do {
		set CHGFEE=ret.dfee
		set REASON=ret.dpretres
		set RETVAL=ret.dret
		set RTNVAL=1
		}
        else  set RTNVAL=0
	
	/*
	Set CHGFEE and REASON to "" so that RETFEE quits without processing the 
	fee, since RET.FEEPROC is set we have already processed one if there is 
	one to process.
	*/
	if ret.feeproc set (CHGFEE,REASON)=""

        quit RTNVAL
        
       
OFFDAYS(String SRC,	// Inclearing Source
	Date DATE,	// Date
	Number CID)	// Account Number
	
	// Determine if the return item has exceed its offset days
        /*
	----------------------------------------------------------------------
         Return 2 if the posting source or offset days are not defined.
         Return 1 if the offset days have been exceeded.
         Return 0 if the offset days have not been exceeded.
       	-----------------------------------------------------------------------
	*/
	
	type Date OFFDATE
	type Number OFFSET
	type String NBDC
	
	type RecordACN acn
	type RecordCTBLINC ctblinc

	quit:SRC.isNull() 2

	set ctblinc=Db.getRecord("CTBLINC","KEY=:SRC",1)
	if 'ctblinc.getMode() quit 2
	if ctblinc.offset.isNull() quit 2

	if ctblinc.offset>0 do {
		set acn=Db.getRecord("ACN","CID=:CID",1)
		if 'acn.getMode() set NBDC=""
		else  set NBDC=acn.nbdc
		
		set OFFDATE=$$NBD^UNBD(DATE+1,ctblinc.offset,0,NBDC)
		}
	else  set OFFDATE=DATE
	
	if %SystemDate'<OFFDATE quit 1

        quit 0
        
	
LOG(IO iolog,		// IO Object
	String XTJD,	// Formatted Date - MMDDYEAR
	String XKEY)	// Inclearing Source
	
	// Open Return Log Device

	type public Number RECSIZ
	type public String PGM
	
	type Number TOTAL
	type String XCODE

	set TOTAL=0
	
	set iolog.fileName="RETURN_"_XKEY_"-"_XTJD_".LOG"
	set iolog.openParams="WRITE/NEWV"
	set iolog.recordSize=RECSIZ.get()
	do iolog.open()
	
	set XCODE="D LOGIT^"_PGM_"(.iolog)"
	// Accept "Xecute" warning
	#ACCEPT Date=11/29/2005;PGM=Marie Hailey;CR=18146
	xecute XCODE

	do iolog.close()

	quit 

EXC	// log error to DAYEND
	
	type public Boolean ER
	type public Number XCID
	type public String %ZTSEQ,DESC,ET,RM
	
	set ER=1
	if RM.get().isNull() set RM=ET.get()
	do LOG^UTLEXC(%RoutineName,"*",DESC.get(),XCID.get(),%ZTSEQ.get(),RM.get())
	kill ET,%ZTSEQ

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60457^33616^Shriram Deshpande^15466"	// Signature - LTD^TIME^USER^SIZE
