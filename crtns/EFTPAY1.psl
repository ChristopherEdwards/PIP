EFTPAY1	// Add free-format text to a SWIFT message
	/*

	---- Revision History -------------------------------------------------
	
	   01/17/06 - KELLYP - CR 18292
	   	Modified query fields for screen lookup tables to work
	   	properly.  Also modified SCREEN section to pass SID by 
	   	reference instead of by value so that SID will be equal to
	   	the last screen viewed when exiting that section.
	
	   10/14/05 - KUMARB - CR 17050
	   	Modified the Call to DRV^USID to pass EFTHLD and ACN object.
	   	Added two section CAN (Cancel/Reverse Payment Order) and
	   	RTN (Return Payment Order).

	   09/23/05 - KELLYP - CR 17050
		Re-added sections for handling NDPO's on the host that were
		previously obsoleted.  NDPO servicing functionality is still
		needed on the host since standing NDPO's are only handled
		in the back office.

           07/27/05 - SkariahV- CR16679
		Removed #WARN and #OPTIMIZE directives.

	   06/26/03 - GRAY - 51351
		Removed all code on longer supported in native Profile, except
		for the code called by function @SWFREE and MRPC108.  Converted
		the remaining code into PSL.

	   03/18/03 - Dan Russell - 51351
	        Removed call to obsolete executive ^EFTEXEC.

	        Removed old change history.

	*/

	quit

public NEW	// Create a new NDPO

	type String usrdi,usrfld
	
	set %ProcessMode=0,usrfld=51,usrdi="UIDADD"
	
	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")
	
	do INIT(.eftpay)
	
	quit


public NEWINT(RecordEFTPAY eftpay)	// Create a new NDPO for an intermediate NDPOIN

	type Boolean ACCFLG,NDPOB,NDPOH
	type Number usrfld
	type String SRC,PAYMET,usrdi
	
	set %ProcessMode=0,usrfld=51,usrdi="UIDADD"

	set SRC="NDPO",PAYMET="SWIFT",NDPOB=1,NDPOH=0,ACCFLG=0
		
	do INIT(.eftpay)
	
	quit
	

public UPG	// Upgrade a NDPO
	
	type Boolean UPGRADE
	type String EFTQRY,EFTQRY1,SRC,usrfld

	set %ProcessMode=1,SRC="NDPO",UPGRADE=1,usrfld=51
	set EFTQRY="[EFTPAY]STATUS=""AE"" AND [EFTPAY]EFTTYPE=<<SRC>>"
	set EFTQRY1="[EFTPAY]STATUS=""AE"" AND [EFTPAY]EFTTYPE=<<SRC>>"

	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")

	do INIT(.eftpay)
	
	quit


public UPD	// Modify a NDPO

	type public Boolean NDPOH	// Set by calling function

	type Number usrfld
	type String EFTQRY,SRC,usrdi
	
	set %ProcessMode=1,SRC="NDPO"
	set EFTQRY="[EFTPAY]STATUS=A AND [EFTPAY]EFTTYPE=<<SRC>>"
	
	if NDPOH set EFTQRY="([EFTPAY]STATUS=""V"" OR [EFTPAY]STATUS=""M"") AND [EFTPAY]EFTTYPE=<<SRC>>",usrfld=53,usrdi="UIDMOD"
	
	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")
	
	do INIT(.eftpay)
	
	quit


public VFY	// Verify (Branch)

	type Number usrfld
	type String EFTQRY,SRC,usrdi
	
	set %ProcessMode=1,usrfld=52,usrdi="UIDVER",SRC="NDPO"

	set EFTQRY="([EFTPAY]STATUS=""A"" OR [EFTPAY]STATUS=""V"") AND [EFTPAY]EFTTYPE=<<SRC>>"
	
	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")
	
	do INIT(.eftpay)
	
	quit


public APP	// Approve (HQ)

	type Number usrfld
	type String EFTQRY,SRC,usrdi

	set %ProcessMode=1,usrfld=54,usrdi="UIDAPP",SRC="NDPO"
	set EFTQRY="([EFTPAY]STATUS=""M"" OR [EFTPAY]STATUS=""AP"") AND [EFTPAY]EFTTYPE=<<SRC>>"

	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")

	do INIT(.eftpay)
	
	quit
	

public ACC	// Accept/Process (HQ)

	type Number usrfld
	type String EFTQRY,SRC,usrdi
	
	set %ProcessMode=2,usrfld=55,usrdi="UIDACC",SRC="NDPO"
	set EFTQRY="[EFTPAY]STATUS=""AP"" AND [EFTPAY]EFTTYPE=<<SRC>>"
	
	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")
	
	do INIT(.eftpay)
	
	quit
	

public DIS	// Display an NDPO

	type String EFTQRY,SRC

	set %ProcessMode=2,SRC="NDPO"
	set EFTQRY="[EFTPAY]EFTTYPE=<<SRC>>"
	
	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")
	
	do INIT(.eftpay)
	
	quit


public DEL	// Delete an NDPO
	
	type public Boolean NDPOH
	
	type Boolean DELETE
	type String EFTQRY
	
	set %ProcessMode=3,DELETE=1,SRC="NDPO"
	set EFTQRY="([EFTPAY]STATUS=""A"" OR [EFTPAY]STATUS=""V"") AND [EFTPAY]EFTTYPE=<<SRC>>"
	
	if NDPOH S EFTQRY="([EFTPAY]STATUS=""M"" OR [EFTPAY]STATUS=""AP"") AND [EFTPAY]EFTTYPE=<<SRC>>"

	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")

	do INIT(.eftpay)

	quit
	
	
public CAN	// Cancel/Reverse Payment Order

	type String EFTQRY,SRC

	set %ProcessMode=2,SRC="NDPO"
	set EFTQRY="[EFTPAY]STATUS=""C"" AND [EFTPAY]EFTTYPE=<<SRC>>"
	
	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")

	do INIT(.eftpay)

	quit


public RTN	// Return Payment Order

	type String EFTQRY,SRC

	set %ProcessMode=2,SRC="NDPO"
	set EFTQRY="[EFTPAY]STATUS=""REV"" AND [EFTPAY]EFTTYPE=<<SRC>>"
	
	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")

	do INIT(.eftpay)

	quit


INIT(RecordEFTPAY eftpay)

	type public Boolean CANCEL,DELETE,REVERSE,UPGRADE,VFYFLG
	type public Number usrfld
	type public String EFTQRY,PSTRTN,UPGREF,usrdi

	type Boolean gl,ogl
	type Date LOADDATE
	type Number BRCD,CID,DCC,SEQ,SOURCE
	type String %DUP(),EFT23E,EFT71F,EFT77T,GLQRY,IO,REFNO,SEQQRY,SID,SIDLNK,VFMQ

	set SOURCE=2,REFNO=""

	set GLQRY="{GLAD.TYPE}'=""H"""	// Query to exclude header GLs

	set usrfld=usrfld.get()
	set usrdi=usrdi.get()
	set CANCEL=CANCEL.get(),REVERSE=REVERSE.get()
	set VFYFLG=VFYFLG.get(),PSTRTN=PSTRTN.get()
	set DELETE=DELETE.get()
	set UPGRADE=UPGRADE.get()
	set UPGREF=UPGREF.get()
	
	// Query for sequence field
	if (%ProcessMode'=0) set SEQQRY=EFTQRY_" AND [EFTPAY]CID=<<CID>>"

	do QUERY(.eftpay)
	
	if VFMQ["Q" do VER(.eftpay) quit
	
	do SCREEN(.eftpay)
	
	do VER(.eftpay)

	quit


QUERY(RecordEFTPAY eftpay)

	type public Boolean gl,INTTRN,ogl,UPGRADE
	type public Date LOADDATE
	type public Number BRCD,CID,DCC,GL,SEQ
	type public String %DUP(),%FN,%NOPRMT,EFTQRY,IO,REFNO,SEQQRY,UPGREF,VFMQ

	type String %READ,%TAB()

	if INTTRN.get() do {
		if 'GL.get().isNull() set CID=""
		set (DCC,REFNO,SEQ)=""
		set %FN="NONDOCA1"
		}
	else  set (CID,GL,DCC,REFNO,SEQ)=""

	set %TAB("CID")=".CID1/XPP=D CIDPP^EFTPAY1"
	set %TAB("GL")=".GL1/TBL=[GLAD]:QUERY GLQRY/XPP=D GLPP^EFTPAY1"
	set %TAB("DCC")="[EFTPAY]CC/TBL=[UTBLCCNTR]"

	if %ProcessMode'=0 do {
		set %TAB("REFNO")="[EFTPAY]REFNO/TBL=[EFTPAY]REFNO,CID,SEQ,AMOUNT,STATUS:DISTINCT:QU """_EFTQRY_"""/XPP=D REFNOPP^EFTPAY1"
		set %TAB("SEQ")="[EFTPAY]SEQ/TBL=[EFTPAY]SEQ,REFNO,CID,AMOUNT,STATUS:DISTINCT:QU """_SEQQRY_"""/XPP=D POST^EFTPAY1"
		}
			
	if %ProcessMode=2 set %TAB("IO")=$$IO^SCATAB($I)

	if '%ProcessMode set %READ="@@%FN,,,CID,GL,DCC/REQ"
	else  set %READ="@@%FN,,,REFNO,CID,GL,SEQ"

	if UPGRADE do {
		kill %TAB
		set %TAB("LOADDATE")=".LOADDATE/TBL=[EFTPAY]LOADDATE:QU ""[EFTPAY]STATUS=""AE"""""
		set %TAB("BRCD")=".BRCD1/TBL=[EFTPAY]BRCD:QU ""[EFTPAY]STATUS=""AE"" & [EFTPAY]LOADDATE=<<LOADDATE>>"""
		set %TAB("CID")=".CID1/TBL=[EFTPAY]CID:QU ""[EFTPAY]STATUS=""AE"" & [EFTPAY]LOADDATE=<<LOADDATE>> & [EFTPAY]BRCD=<<BRCD>>""/XPP=D CIDPP^EFTPAY1"
		set %TAB("SEQ")=".SEQ8/TBL=[EFTPAY]SEQ:QU ""[EFTPAY]STATUS=""AE"" & [EFTPAY]LOADDATE=<<LOADDATE>> & [EFTPAY]BRCD=<<BRCD>> & [EFTPAY]CID=<<CID>>"""
		set %READ="@@%FN,,,LOADDATE/REQ,BRCD/REQ,CID/REQ,SEQ/REQ"
		set %TAB("REFNO")="[EFTPAY]REFNO/TBL=[EFTPAY]REFNO,CID,SEQ,STATUS:DISTINCT:QU EFTQRY""/XPP=D REFNOPP^EFTPAY1"
		set %TAB("IO")=$$IO^SCATAB($I)
		}

	if 'UPGREF.isNull() set %READ="@@%FN,,,REFNO#P,IO/REQ",REFNO=UPGREF
	
	if (%ProcessMode=2) set %READ=%READ_",,IO#1"

	set %NOPRMT="C"
	
	do ^UTLREAD 
	
	if "Q"[VFMQ quit

	if GL'="" set CID=GL,(gl,ogl)=1		// gl vs non-gl flags
	else  set (gl,ogl)=0

	// Load any pre-existing messages; if in create mode, default 'yes'
	if %ProcessMode=2,IO'=$I do OPEN^SCAIO
	
	if UPGRADE set %DUP("BRCD")=BRCD.get(),%DUP("LOADDATE")=LOADDATE.get()

	quit


REFNOPP	// Post processor for Transaction Reference Number

	type public Boolean CANCEL,ER,REVERSE
	type public Number CID,GL,SEQ,%OSAVE
	type public String I(),RM,UPGREF,X

	type String SAVEI

	if X.isNull() quit

	type RecordEFTREF eftref=Db.getRecord("EFTREF","REFNO=:X",1)

	// Transaction reference number does not exist
	if 'eftref.getMode() do Runtime.setErrMSG("EFTREF","7680") quit:ER

	if UPGREF.isNull() do {
		set GL=""
		do DEFAULT^DBSMACRO("@GL","")
		do DISPLAY^DBSMACRO("@GL","")
		}

	// Record locked by another user
	lock +EFTREF(X):3 else  do Runtime.setErrMSG("EFTREF","2333") quit:ER

	set CID=eftref.cid
	set SEQ=eftref.seq
	do UIDPP(CID,SEQ) quit:ER

	set CANCEL=CANCEL.get(),REVERSE=REVERSE.get()

	if Db.isDefined("GLAD","ACN=:CID"),'Db.isDefined("ACN","CID=:CID") set GL=CID

	/*
	 Verify that no integrity errors exist on the account
	 before continuing with the processing of reversal/cancellation.
	*/
	if (CANCEL!REVERSE) do { quit:ER
		type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
		if 'dep.getMode() quit
		
		do EXEC^DEPVER0(.dep)
		
		// Resolve account integrity errors before proceeding
		if RM.data() do Runtime.setErrMSG("DEP","2400") quit:ER
		}
	
	type String INTBL = ""
	if I(3).exists() set INTBL=$$VER^DBSTBL(I(3),X,"T")
	if INTBL.isNull() quit
	
	if %OSAVE=2 do GOTO^DBSMACRO("@IO") quit

	do GOTO^DBSMACRO("END")
	
	quit
	

CIDPP	// Check if account set up for Payment Orders.

	type public Boolean CANCEL,ER,REVERSE
	type public Number GL,%OSAVE
	type public String RM,X

	type Boolean %EXT
	type Number CID

	if X.isNull() quit

	// Not permitted to enter both a customer and a G/L number
	if 'GL.isNull() do Runtime.setErrMSG("EFTPAY","2045") quit:ER

	set %EXT=1
	do ^UACN quit:ER

	// ~p1 is not a valid account number
	if '+CID do Runtime.setErrMSG("ACN","7683",CID) quit:ER

	/*
	 Verify that no integrity errors exist on the account
	 before continuing with the processing of reversal/cancellation.
	*/
	if (CANCEL!REVERSE) do { quit:ER
		type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
		if 'dep.getMode() quit
		
		do EXEC^DEPVER0(.dep)
		
		// Resolve account integrity errors before proceeding
		if RM.data() do Runtime.setErrMSG("DEP","2400") quit:ER
		}

	type RecordACN acn=Db.getRecord("ACN","CID=:CID")
	
	// Account ~p1 is closed
	if acn.stat=4 do Runtime.setErrMSG("ACN","6050",CID) quit:ER

	// Account ~p1 not permitted for foreign payments
	if acn.eftdeb=0 do Runtime.setErrMSG("ACN","7664",CID) quit:ER
	else  if acn.eftdeb=1 do { quit
		if CID.length(),%OSAVE do GOTO^DBSMACRO("@SEQ")
		else  if CID.length(),'%OSAVE do GOTO^DBSMACRO("END")
		}

	type RecordPRODDFTD proddftd=Db.getRecord("PRODDFTD","TYPE=:acn.type")
	
	// Product ~p1 not permitted for foreign payments
	if proddftd.eftdeb=0 do Runtime.setErrMSG("PRODDFTD","7679",acn.type) quit:ER
	else  if proddftd.eftdeb=1 do { quit
		if CID.length(),%OSAVE do GOTO^DBSMACRO("@SEQ")
		else  if CID.length(),'%OSAVE do GOTO^DBSMACRO("END")
		}

	// Permisson for foreign payments on product ~p1 not defined
	do Runtime.setErrMSG("PRODDFTD","7678",acn.type) quit:ER

	quit


GLPP	// Post-processor for G/L Account

	type public Boolean ER,ogl
	type public Number CID,GL
	type public String X

	if X.isNull() set ogl="",GL=""
	
	// Must enter customer account or G/L account
	if X.isNull(),CID.isNull() do Runtime.setErrMSG("EFTPAY","7671") quit:ER

	if X.isNull() quit

	set CID=X,ogl=1

	quit
	
	
POST	// Post-processor for Sequence
	
	type public Boolean CANCEL,DELETE,ER,NDPOB,NDPOH
	type public Number CID,GL,%OSAVE
	type public String STATUS,X

	// Must enter sequence
	if X.isNull(),('CID.isNull()!'GL.isNull()) do Runtime.setErrMSG("EFTPAY","7672") quit:ER

	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:CID,SEQ=:X",1)
	if 'eftpay.getMode() quit

	// Account ~p1 Sequence ~p2 is for a G/L account 
	if eftpay.ttype=3,GL.isNull() do Runtime.setErrMSG("EFTPAY","7666",CID_"~"_X) quit:ER

	// Account ~p1 Sequence ~p2 is for a customer account
	if eftpay.ttype=0,'GL.isNull() do Runtime.setErrMSG("EFTPAY","7665",CID_"~"_X) quit:ER
	
	if 'NDPOB.exists() set NDPOB=0
	if 'NDPOH.exists() set NDPOH=0

	set STATUS=eftpay.status
	
	type RecordSTBLESTAT estat=Db.getRecord("STBLESTAT","STATUS=:STATUS")
	
	if NDPOB,DELETE do { quit:ER
		// Branch cannot delete record with a status of ~p1
		if (STATUS="C")!(STATUS="R")!(STATUS="CA")!(STATUS="D") do Runtime.setErrMSG("EFTPAY","7667",estat.desc) quit:ER
		}

	if NDPOH,DELETE do { quit:ER
		// Headquarters cannot delete record with a status of ~p1
		if (STATUS'="AP")!(STATUS'="M") do Runtime.setErrMSG("EFTPAY","7667",estat.desc) quit:ER
		}

	if %OSAVE=1 do { quit:ER
		// Cannot modify EFT record with a status of ~p1
		if (STATUS'="A")!(STATUS'="Y") do Runtime.setErrMSG("EFTPAY","7669",estat.desc) quit:ER
		}

	// Not permitted to cancel payment record with a status of ~p1
	if CANCEL,STATUS'="C" do Runtime.setErrMSG("EFTPAY","7677",estat.desc) quit:ER

	do UIDPP(CID,X) quit:ER

	quit

UIDPP(Number CID,Number SEQ)	// User ID validation

	type public Boolean APPFLG,ER,VFYFLG

	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ",1)
	if 'eftpay.getMode() quit
	
	if 'VFYFLG.exists() set VFYFLG=0
	if 'APPFLG.exists() set APPFLG=0

	// User who added payment order cannot verify it
	if VFYFLG,(eftpay.uidadd=%UserID) do Runtime.setErrMSG("EFTPAY","7681") quit:ER

	// User who modified payment order cannot approve it
	if APPFLG,(eftpay.uidmod=%UserID) do Runtime.setErrMSG("EFTPAY","7682") quit:ER
	
	quit


SCREEN(RecordEFTPAY eftpay)	// Display main screens

	type public Boolean ACCFLG,ER,gl,INTTRN,NDPOB,NDPOH,ogl
	type public Number CID,CC,DCC,SEQ
	type public String EFT23E,EFT71F,EFT77T,REFNO,SID,SIDLNK,SOURCE,SRC,VFMQ

	type Number BALAVL,FREEPTR
	type String SCRBR,SCRHQ

	set NDPOB=NDPOB.get(),NDPOH=NDPOH.get(),ACCFLG=ACCFLG.get(),INTTRN=INTTRN.get()
	
	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	type RecordCTBLEFTTYPE eftctbl=Db.getRecord("CTBLEFTTYPE","KEY=:SRC")

	// Define default values for new outgoing foreign payments
	if '%ProcessMode do { quit:ER
		type String TEMP
		set TEMP="EFTPAY|"_CID_"|"_SEQ.get()	// Keys into record
	
		do ^TRREFNO(SOURCE,.REFNO,TEMP) quit:ER
		
		if ogl set DCC=CC,eftpay.cc=CC
		else  if 'INTTRN set eftpay.crcd=acn.crcd

		set eftpay.status="A"
		set eftpay.met=eftctbl.paymetdft
		set eftpay.amttyp=1
		set eftpay.efttype=SRC
		set eftpay.feetype=eftctbl.feemetdft
		set eftpay.refno=REFNO
		set eftpay.brcd=DCC
		set eftpay.datecre=%SystemDate		
		set eftpay.origin=0
		set eftpay.feeamt=0
		set eftpay.feeamt2=0
		set eftpay.pri2="N"
		set eftpay.ccode=eftctbl.ccode
		set eftpay.intext=1
		set eftpay.ttype=$S(ogl:3,1:0)

		if ogl quit

		// Determine customer account information
		set eftpay.brcd=acn.boo
		set eftpay.cc=acn.cc
		set eftpay.acn=acn.acn		
		set BALAVL=$$BALAVL^DEPCDI(CID,0,0) quit:ER
		}
	
	if %ProcessMode set eftpay=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ")

	// Determine screens (Branch or HQ)
	set SCRBR=eftctbl.scrbr if SCRBR.isNull() set SCRBR="INTPAYBR00A"
	set SCRHQ=eftctbl.scrhq if SCRHQ.isNull() set SCRHQ="INTPAYHQ00A"

	if NDPOB set (SID,SIDLNK)=SCRBR
	if NDPOH set (SID,SIDLNK)=SCRHQ

	// Record locked by another user
	if %ProcessMode lock +EFTPAY(CID,SEQ):3 else  set VFMQ="Q" do Runtime.setErrMSG("EFTPAY","2333") quit:ER

	if REFNO.get().isNull() set REFNO=eftpay.refno

	// Record locked by another user
	lock +EFTREF(REFNO):3 else  set VFMQ="Q" do Runtime.setErrMSG("EFTPAY","2333") quit:ER

	if %ProcessMode do {

		if eftpay.ttype.isNull(),(gl!ogl) set eftpay.ttype=3
		
		if eftpay.freeptr.isNull() quit

		// Load instruction codes
		set EFT23E=$$MULT2^SWIFTCDI("OUT",FREEPTR,"23E")

		// Load sender's charges
		set EFT71F=$$MULT2^SWIFTCDI("OUT",FREEPTR,"71F")

		// Load extended remittance
		set EFT77T=$$MULT2^SWIFTCDI("OUT",FREEPTR,"77T")
		}

	quit:ER
	
	type RecordEFTHLD efthld=Class.new("RecordEFTHLD")
	
	do DRV^USID(%ProcessMode,.SID,.efthld,.eftpay,.acn)

	quit


VER(RecordEFTPAY eftpay)

	type public Boolean ACCFLG,APPFLG,CANCEL,DELETE,ER,INTTRN,REVERSE,VFYFLG
	type public Number CID,SEQ,SOURCE
	type public String %fkey,PSTRTN,REFNO,VFMQ

	if ("Q"[VFMQ)&(%ProcessMode=0)&(REFNO.exists()) do KTRN^DEAL(SOURCE,REFNO) 

	if ER.get() quit
	
	if 'ACCFLG.exists() set ACCFLG=0
	if 'VFYFLG.exists() set VFYFLG=0
	if 'APPFLG.exists() set APPFLG=0

	if (CID.exists())&(%fkey="ESC")&(INTTRN.exists()) do { do VER(.eftpay) quit
		type Number OPT
		type String MSG
		
		// Warning: Choosing Quit will not file this record.
		set MSG=$$^MSG(4729)
		set OPT=$$^DBSMBAR(161)
	
		if OPT'=1 set VFMQ="Q" quit
		set %ProcessMode=0
		do SCREEN(.eftpay)
		}

	// Set up screen was not passed (ref #, account, sequence, ... screen)
	I ('CID.exists())!('SEQ.exists()) do END quit

	/*
	 There is no confirmation prompt for creations (NONDOCA1),
	 modifications (NONDOCA2 & NONDOCB2), upgrades (NONDOCA5),
	 and inquiries (NONDOCB3)
	*/
	if (VFMQ="Q"),'DELETE,'VFYFLG,'APPFLG,'ACCFLG,'CANCEL,'REVERSE,'PSTRTN do END quit

	/*
	 Display confirmation prompts for deletions (NONDOCA3 &
	 NONDOCB5), verifications (NONDOCA4), approvals (NONDOCB1),
	 acceptance (NONDOCB4), cancellations (NONDOCB6), reversals
	 (NONDOCB7), and returns (NONDOCB8)
	*/
	set VFMQ="F"

	do FILE(.eftpay) quit:ER

	do END
	
	quit


FILE(RecordEFTPAY eftpay)	// File data

	type public Boolean ACCFLG,APPFLG,CANCEL,DELETE,ER,NDPOB,NDPOH,ogl
	type public Boolean PSTRTN,REVERSE,UPGRADE,VFYFLG
	type public Number CID,SEQ
	type public String EFT23E,EFT71F,EFT77T,SID,SIDLNK,SOURCE,SRC,usrdi,VFMQ

	type Boolean FREEPTR
	type Number CIDSUB,OPT,ZSEQ
	type String EFTTYPE
	
	do eftpay.setAuditFlag(1)
	
	set FREEPTR=eftpay.freeptr
	if FREEPTR.isNull() do {	 // Set up EFTPAY.FREEPTR for use in section RPCFILE

		if EFT23E.get().isNull(),EFT71F.get().isNull(),EFT77T.get().isNull() quit

		type RecordSWFREETOP swfftop=Db.getRecord("SWFREETOP","SWDIRECT='OUT'",1)
		
		set FREEPTR=+swfftop.ptr
		if FREEPTR=0 set FREEPTR=1
		set swfftop.ptr=FREEPTR+1

		do swfftop.save()	// Update the pointer

		if (%ProcessMode=1),eftpay.freeptr'=FREEPTR set eftpay.freeptr=FREEPTR
		}

	if usrdi.exists() set eftpay.@usrdi=%UserID

	// Deletion
	if DELETE do {  quit:(OPT'=1)!ER
		set OPT=$$^DBSMBAR(149)
		if OPT'=1 set VFMQ="Q" quit
		set eftpay.status="D"
		set %ProcessMode=1
		}

	// Upgrade
	if UPGRADE do {  quit:(OPT'=1)!ER
		set OPT=$$YN^DBSMBAR("",$$^MSG(3602),1)
		if OPT'=1 set VFMQ="Q" quit
		set eftpay.status="A"
		set eftpay.mt202flg=1
		}

	// Branch Verification
	if (%ProcessMode=1)&(NDPOB)&('DELETE)&(VFYFLG) do {  quit:(OPT'=1)!ER
		set OPT=$$^DBSMBAR(150)
		if OPT'=1 set VFMQ="Q" quit
		set eftpay.status="V"
		}

	// Approval by headquarters
	if (%ProcessMode=1)&(NDPOH)&('DELETE)&(APPFLG) do {  quit:(OPT'=1)!ER
		set OPT=$$^DBSMBAR(151)
		if OPT'=1 set VFMQ="Q" quit
		
		// Must view final screen prior to approval
		if SID'=$$LASTSID(SIDLNK) set OPT=0 do Runtime.setErrMSG("EFTPAY","7674") quit:ER

		// Cannot Approve without Sender's Nostro
		if eftpay.sendnos.isNull() do Runtime.setErrMSG("EFTPAY","7668") quit:ER

		set eftpay.status="AP"
		}

	// Modified by headquarters
	if (%ProcessMode=1)&(NDPOH)&('DELETE)&('APPFLG) set eftpay.status="M"

	// Accept/Process by headquarters
	if ACCFLG do {  quit
		set OPT=$$^DBSMBAR(152)
		if OPT'=1 set VFMQ="Q" quit

		// Must view final screen prior to acceptance
		if SID'=$$LASTSID(SIDLNK) set OPT=0 do Runtime.setErrMSG("EFTPAY","7673") quit:ER
		
		// Process payment
		do PROC(.eftpay)
		}

	// Cancel/Reverse/Returned payment order
	if (CANCEL)!(REVERSE)!(PSTRTN) do {  quit
		if CANCEL set OPT=$$^DBSMBAR(153)
		if REVERSE set OPT=$$^DBSMBAR(154)
		if PSTRTN set OPT=$$^DBSMBAR(155)
		if OPT'=1 set VFMQ="Q" quit

		// Process cancellation, reversal, or return
		do PROC(.eftpay)
		}

	set EFTTYPE=SRC
	set eftpay.lchdt=%SystemDate	// Store date of update

	// Substitute customer account number with G/L
	set CIDSUB=eftpay.subscid
	if UPGRADE,'CIDSUB.isNull() do {

		type String REFNO
	
		// Delete old payment under customer account
		set eftpay.ttype=0
		set eftpay.status="D",DELETE=1
		do RPCFILE(1,.eftpay)

		// Create new payment under substitute G/L
		do eftpay.setMode(0)
		set eftpay.antrate=""
		set eftpay.rate=""
		set eftpay.hldseq=""
		set eftpay.origcid=CID

		do ^TRREFNO(SOURCE,.REFNO,"") quit:ER
		set eftpay.refno=REFNO
		set eftpay.ttype=3
		set eftpay.mt202flg=1
		set eftpay.subscid=""
		set eftpay.cc=eftpay.subcc
		set eftpay.subcc=""
		set eftpay.origseq=SEQ
		set CID=CIDSUB
		set eftpay.status="A"
		set %ProcessMode=0,ogl=1,DELETE=0
		do eftpay.setMode(0)
		}
	
	// Get next sequence number
	if '%ProcessMode do {  quit:ER
		type RecordEFTPAY1 eftpay1=Db.getRecord("EFTPAY1","CID=:CID",1)
		if 'eftpay1.getMode() set (SEQ,ZSEQ)=1
		else  set (SEQ,ZSEQ)=eftpay1.seq+1
		}

	do RPCFILE(%ProcessMode,.eftpay)

	if UPGRADE&'ER do {
		// Print payment?
		set OPT=$$YN^DBSMBAR("",$$^MSG(3601),1)
		quit:'OPT
		do UPGPNT
		}

	quit
	

LASTSID(String SIDLNK)	// Determine the last screen in a linkage

	type Number LOOP
	type String LASTSID,NEXTSID,RECORD

	type RecordDBTBL2 dbtbl2=Db.getRecord("DBTBL2","LIBS='SYSDEV',SID=:SIDLNK",1)
	
	if dbtbl2.lnk1.isNull() quit SIDLNK
	
	set RECORD=dbtbl2.lnk1_"|"_dbtbl2.lnk2_"|"_dbtbl2.lnk3_"|"_dbtbl2.lnk4_"|"_dbtbl2.lnk5_"|"
	set RECORD=RECORD_dbtbl2.lnk6_"|"_dbtbl2.lnk7_"|"_dbtbl2.lnk8_"|"_dbtbl2.lnk9_"|"_dbtbl2.lnk10_"|"
	set RECORD=RECORD_dbtbl2.lnk11_"|"_dbtbl2.lnk12_"|"_dbtbl2.lnk13_"|"_dbtbl2.lnk14_"|"_dbtbl2.lnk15_"|"
	set RECORD=RECORD_dbtbl2.lnk16_"|"_dbtbl2.lnk17_"|"_dbtbl2.lnk18_"|"_dbtbl2.lnk19_"|"_dbtbl2.lnk20_"|"
	set RECORD=RECORD_dbtbl2.lnk21_"|"_dbtbl2.lnk22_"|"_dbtbl2.lnk23_"|"_dbtbl2.lnk24_"|"_dbtbl2.lnk25_"|"
	set RECORD=RECORD_dbtbl2.lnk26_"|"_dbtbl2.lnk27_"|"_dbtbl2.lnk28

	set LOOP=1,NEXTSID=""

	for  do {  quit:NEXTSID.isNull()
		set NEXTSID=RECORD.piece("|",LOOP)
		if NEXTSID.isNull() quit
		set LASTSID=NEXTSID
		set LOOP=LOOP+1
		}
	
	quit LASTSID


PROC(RecordEFTPAY eftpay)	// Process this and only this payment order.

	type public Boolean ACCFLG,CANCEL,ER,PSTRTN,REVERSE
	type public Number CID,SEQ
	type public String VFMQ

	type Boolean SWSENT
	type Number CRCID,OPT

	set SWSENT=0

	if (VFMQ="Q") quit
	if ('ACCFLG),('CANCEL),('REVERSE),('PSTRTN) quit

	set ER=0
	if (CANCEL)!(REVERSE)!(PSTRTN) do SWSENT(.SWSENT,.eftpay)  quit:ER
	if 'SWSENT.exists() set SWSENT=0
	if 'PSTRTN.exists() set PSTRTN=0

	// Process the foreign payment
	set OPT=$S(CANCEL:1,REVERSE:2,PSTRTN:3,1:0)
	do ^EFTNDPO(CID,SEQ,OPT,1,SWSENT)

	quit


END	// End Processing

	type public Boolean CANCEL,DELETE,ER,REVERSE,VFYFLG
	type public Number CID,SEQ,usrfld
	type public String RM,VFMQ

	// No message for inquiries (NONDOCB3), acceptance (NONDOCB4), or
	// returns (NONDOCB8)
	if ER.get() quit
	
	if (%ProcessMode=2),'CANCEL,'REVERSE quit
	
	if VFMQ="Q" do {
		// Foreign payment for account ~p1 not reversed
		if REVERSE set RM=$$^MSG(7746,CID.get()) quit
		// Foreign payment for account ~p1 not cancelled
		if CANCEL set RM=$$^MSG(7742,CID.get()) quit
		// Foreign payment for account ~p1 not deleted
		if DELETE set RM=$$^MSG(7744,CID.get()) quit
		// Foreign payment for account ~p1 not verified
		if VFYFLG set RM=$$^MSG(7747,CID.get()) quit
		// Foreign payment for account ~p1 not created
		if %ProcessMode=0 set RM=$$^MSG(7743,CID.get()) quit
		// Foreign payment for account ~p1 not approved
		if usrfld=54 set RM=$$^MSG(7741,CID.get()) quit
		// Foreign payment for account ~p1 not modified
		set RM=$$^MSG(7745,CID.get())
		}
	else  do {
		// Foreign payment for account ~p1 reversed
		if REVERSE set RM=$$^MSG(7711,CID.get()) quit
		// Foreign payment for account ~p1 cancelled
		if CANCEL set RM=$$^MSG(7707,CID.get()) quit
		// Foreign payment for account ~p1 deleted
		if DELETE set RM=$$^MSG(7709,CID.get()) quit
		// Foreign payment for account ~p1 verified
		if VFYFLG set RM=$$^MSG(7712,CID.get()) quit
		// Foreign payment for account ~p1 Sequence ~p2 created
		if %ProcessMode=0 set RM=$$^MSG(7708,CID.get()_" "_$$^MSG(6742,SEQ.get())) quit
		// Foreign payment for account ~p1 approved
		if usrfld=54 set RM=$$^MSG(7706,CID.get()) quit
		// Foreign payment for account ~p1 modified
		set RM=$$^MSG(7710,CID.get())
		}

	set ER="W"

	quit


RPCFILE(Number %ProcessMode,RecordEFTPAY eftpay)  // Dispatch routine for DQ filer EFTFILE called via RPC

	type public Boolean ER
	type public Number FREEPTR
	type public String EFT23E,EFT71F,EFT77T
	
	type Number I,SWSEQ
	type String DATA

	do eftpay.save()
	
	// No free format text to save
	if eftpay.freeptr.isNull() quit
	
	if ER.get() do {  quit
		// Roll back value of next FREEPTR in SWFREE
		type RecordSWFREETOP swfreetp=Db.getRecord("SWFREETOP","SWDIRECT='OUT'",1)
		if ('swfreetp.getMode())!('(swfreetp.ptr>1)) quit
		set swfreetp.ptr=swfreetp.ptr-1
		do swfreetp.save()
		}

	//  Delete existing instruction codes
	do Db.delete("SWFREE","SWDIRECT='OUT' AND PTR=:FREEPTR AND FLD='23E'")

	// Add new instruction codes to SWFREE
	set EFT23E=EFT23E.get()
	do SORTINST(.EFT23E)
	set SWSEQ=1
	for I=1:1 set DATA=EFT23E.piece($C(13,10),I)  quit:DATA.isNull()  do {
		type RecordSWFREE swfree23=Class.new("RecordSWFREE","SWDIRECT='OUT',PTR=:FREEPTR,FLD='23E',SEQ=:SWSEQ")
		set swfree23.fldtxt=DATA
		do swfree23.save()
		set SWSEQ=SWSEQ+.001
		}

	kill EFT23E

	// Delete existing sender's charges
	do Db.delete("SWFREE","SWDIRECT='OUT' AND PTR=:FREEPTR AND FLD='71F'")
	
	// Add new sender's charges to SWFREE
	set EFT71F=EFT71F.get()
	set SWSEQ=1
	for I=1:1 set DATA=EFT71F.piece($C(13,10),I)  quit:DATA.isNull()  do {
		type RecordSWFREE swfree71=Class.new("RecordSWFREE","SWDIRECT='OUT',PTR=:FREEPTR,FLD='71F',SEQ=:SWSEQ")
		set swfree71.fldtxt=DATA
		do swfree71.save()
		set SWSEQ=SWSEQ+.001
		}

	kill EFT71F

	// Delete existing extended remittance data
	do Db.delete("SWFREE","SWDIRECT='OUT' AND PTR=:FREEPTR AND FLD='77T'")
	
	// Add new extended remittance data to SWFREE
	set EFT77T=EFT77T.get()
	set SWSEQ=1
	for I=1:1:999 set DATA=EFT77T.extract(1,80)  quit:DATA.isNull()  do {
		type RecordSWFREE swfree77=Class.new("RecordSWFREE","SWDIRECT='OUT',PTR=:FREEPTR,FLD='77T',SEQ=:SWSEQ")
		set swfree77.fldtxt=DATA
		do swfree77.save()
		set SWSEQ=SWSEQ+.001
		set EFT77T=EFT77T.extract(81,EFT77T.length())
		}

	kill EFT77T
	
	quit


SWSENT(Boolean SWSENT,RecordEFTPAY eftpay)

	/* 
	 This section determines whether or not the SWIFT messages spawned
	 from the payment order have been processed (sent).

	 If the messages have been sent, and the system date is less than
	 the payment's value date, create MT192 and MT292.

	 If the messages have been sent, and the system date is greater than
	 the payment's value date, create MT199.

	 If the messages have not been sent, delete MT100 and MT202.
	*/
	
	type public Boolean ER
	
	type String REFNO,SWSTAT
	
	set REFNO=eftpay.refno
	if 'SWSENT.exists() set SWSENT=0
	
	type RecordSWIFT swift=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:REFNO,MSG='103'",1)

	// No SWIFT messages exist	
	if 'swift.getMode() do Runtime.setErrMSG("SWIFT","7676") quit:ER

	if $$SWACK^SWIFTGEN(eftpay.msg103dt,eftpay.msg202dt) set SWSENT=1

	if SWSENT do {  quit
		if %SystemDate<eftpay.efd do SWFT192(REFNO),SWFT292(REFNO)	// Request/Cancel
		if (%SystemDate=eftpay.efd)!(%SystemDate>eftpay.efd) do SWFT199(REFNO)	// Free format msg
		}
	
	if ER quit
	
	// If the messages have not been sent yet, delete them
	if 'SWSENT do SWDEL(REFNO)

	quit


SWFT192(String REFNO)	// SWIFT Message 192 - Request for Cancellation of MT103

	type public Date SWFTDT

	type String MSG,SWDIRECT,TRREFNO

	// Get original MT103
	type RecordSWIFT swift=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:REFNO,MSG='103'",1)
	if 'swift.getMode() quit	// No MT103 exists
	
	set swift.relref=swift.trnofmt
	set swift.status=6	// Review

	// Variables necessary to file SWIFT msg
	if swift.swftdt.isNull() set swift.swftdt=%SystemDate
	set swift.swdirect="OUT"
	set swift.trrefno=REFNO
	set swift.msg=192
	do swift.setMode(0)

	do swift.save()	// File the 192
	
	if '$$SEARCHQ("REV",REFNO,"192") do QUEUE^SWIFTGEN("REV")
	
	quit


SWFT292(String REFNO)	// SWIFT Message 292 - Request for Cancellation of MT202

	type public Date SWFTDT

	type String MSG,SWDIRECT,TRREFNO

	// Get original MT103
	type RecordSWIFT swift=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:REFNO,MSG='202'",1)
	if 'swift.getMode() quit	// No MT202 exists
	
	set swift.status=6	// Review

	// Variables necessary to file SWIFT msg
	if swift.swftdt.isNull() set swift.swftdt=%SystemDate
	set swift.swdirect="OUT"
	set swift.trrefno=REFNO
	set swift.msg=292
	do swift.setMode(0)

	do swift.save()	// File the 292

	if '$$SEARCHQ("REV",REFNO,"292") do QUEUE^SWIFTGEN("REV")

	quit



SWFT199(String REFNO)	// SWIFT Message 199 - Free Format Message

	// Create new MT199 and place into REV Review queue.
	type Date SWFTDT
	type String MSG,SWDIRECT,TRREFNO

	// Get original MT103
	type RecordSWIFT swift=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:REFNO,MSG='103'",1)
	if 'swift.getMode() quit	// No MT103 exists

	set swift.status=6	// Review

	if swift.swftdt.isNull() set swift.swftdt=%SystemDate
	set swift.swdirect="OUT"
	set swift.trrefno=REFNO
	set swift.msg=199
	do swift.setMode(0)

	do swift.save()	// File the 199
	
	if '$$SEARCHQ("REV",REFNO,"199") do QUEUE^SWIFTGEN("REV")
	
	quit


public SWFREE	// Add free-format text to a SWIFT message.

	// DATA-QWIK entry point for function @SWFREE.

	type Number I
	type String %TAB(),%READ,COL,MSG,SWDIRECT,TRREFNO
	type Public Date SWFTDT
	type Public Number %PAGE,%PG,%ProcessMode
	type Public String %fkey,%FN,SWARRAY(),VFMQ

	type RecordSWIFT fSWIFT
 
	set %TAB("TRREFNO")="[SWIFT]TRREFNO/XPP=do SWFREEPP^EFTPAY1"
	set %TAB("MSG")="[SWIFT]MSG/XPP=do MSGPP^EFTPAY1"
	set %READ="@@%FN,,,TRREFNO#1,MSG#1"

	do ^UTLREAD

	if (%fkey="ESC")!(VFMQ="Q")!(TRREFNO="") quit

	// if message already exists load it for updates
	type RecordSWIFT swift=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:TRREFNO,MSG=:MSG",1)
	if swift.getMode() do SWLOAD("OUT",TRREFNO,MSG,.fSWIFT)

	// otherwise, build it
	if 'swift.getMode() do {
		// load the original 100 for 192/199
		if (MSG=192)!(MSG=199) do SWLOAD("OUT",TRREFNO,100,.fSWIFT)

		// load the original 202 for 292
		if (MSG=292) do SWLOAD("OUT",TRREFNO,202,.fSWIFT)
		
		}

	set %PG=0 set %PAGE=0

	do ^SWFLD79

	do fSWIFT.setAuditFlag(1)

	// Status
	set fSWIFT.status=6

	// Message Transfer Date
	if 'SWFTDT.data() set SWFTDT=fSWIFT.swftdt 
	if SWFTDT="" set SWFTDT=%SystemDate

	set fSWIFT.f79data1=SWARRAY(1)
	set fSWIFT.f79data2=SWARRAY(2)
	set fSWIFT.f79data3=SWARRAY(3)
	set fSWIFT.f79data4=SWARRAY(4)
	set fSWIFT.f79data5=SWARRAY(5)
	set fSWIFT.f79data6=SWARRAY(6)
	set fSWIFT.f79data7=SWARRAY(7)
	set fSWIFT.f79data8=SWARRAY(8)
	set fSWIFT.f79data9=SWARRAY(9)
	set fSWIFT.f79data10=SWARRAY(10)
	set fSWIFT.f79data11=SWARRAY(11)
	set fSWIFT.f79data12=SWARRAY(12)
	set fSWIFT.f79data13=SWARRAY(13)
	set fSWIFT.f79data14=SWARRAY(14)
	set fSWIFT.f79data15=SWARRAY(15)

	do fSWIFT.save()

	if '$$SEARCHQ("REV",TRREFNO,MSG) do QUEUE^SWIFTGEN("REV")

	quit


SWFREEPP	// Post Processor on Trans. Reference Number.

	type Number REFCID,REFSEQ
	type String REFSTAT
	type Public Number ER
	type Public String RM,X

	type RecordEFTREF eftref=Db.getRecord("EFTREF","REFNO=:X",1)
	if 'eftref.getMode() quit
	
	set REFCID=eftref.cid quit:REFCID=""
	set REFSEQ=eftref.seq quit:REFSEQ=""
	set REFSTAT=eftref.status

	if (REFSTAT'="CA")&(REFSTAT'="REV") do {
		type RecordSTBLESTAT estat=Db.getRecord("STBLESTAT","STATUS=:REFSTAT",1)
		set ER=1
		// Status is ~p1
		set RM=$$^MSG(8413,estat.desc)
		}

	quit


MSGPP	// Post Processor on Message.
	
	type Number SWSTAT
	type Public Number ER
	type Public String RM,TRREFNO,X

	// Message type must be 192, 292, or 199
	if (X'=192)&(X'=292)&(X'=199) set ER=1 set RM=$$^MSG(7713) quit

	type RecordSWIFT swift=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:TRREFNO,MSG=:X",1)

	// No original messages exist for ~p1
	if 'swift.getMode() set ER=1 set RM=$$^MSG(7714,X) quit

	set SWSTAT=swift.status

	if SWSTAT'=6 do {
		type RecordSTBLSWSTAT swstat=Db.getRecord("STBLSWSTAT","KEY=:SWSTAT",1)
		set ER=1
		// Status is ~p1
		set RM=$$^MSG(8413,swstat.desc)
		}

	quit


SEARCHQ(String QUEUE,String REFNO,String MSG)	//

	// Search ^SWIFTQ for an entry for this transaction reference number.

	type Boolean FOUND=0
	
	type ResultSet rs=Db.select("DISTINCT TYPE","SWIFTQ2","QUE=:QUEUE AND TRREFNO=:REFNO AND TYPE=:MSG")
	if rs.next() set FOUND=1

	quit FOUND


SWLOAD(String swdirect,String swtran,String msgtyp,RecordSWIFT fSWIFT)	//

	// Load SWIFT record from [SWIFT]

	type Number I,TOT
	type String CS2,REC
	type Public String SWARRAY()

	set fSWIFT=Db.getRecord("SWIFT","SWDIRECT=:swdirect,TRREFNO=:swtran,MSG=:msgtyp",1)

	if fSWIFT.f79data1'="" do {

		// Load free format message into SWARRAY array which is used by filer
		set REC=$$MULT^SWIFTCDI(swdirect,swtran,msgtyp,79) 
		set CS2=$C(13,10) 
		set TOT=REC.length(CS2) 

		for I=1:1:TOT set SWARRAY(I)=REC.piece(CS2,I)
		}
	quit


SWDEL(String REFNO)	// SWIFT Delete

	/*
	 Delete all SWIFT messages that were spawned from this now cancelled/
	 reversed payment order.  Calls SWQDEL to update ^SWIFTQ.
	*/

	type String TCMT

	// Load and delete the original MT103
	type RecordSWIFT swift103=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:REFNO,MSG='103'",1)
	if swift103.getMode() do {
		do SWQDEL(swift103.status,REFNO,"103",swift103.swftdt)
		do swift103.setAuditFlag(1)
		set swift103.status=5	// Deleted
		set TCMT=$$^MSG(7652)	// Message deleted
		do swift103.save()
		}
	
	// Load and delete the original MT202 (if there was one)
	type RecordSWIFT swift202=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:REFNO,MSG='202'",1)
	if swift202.getMode() do {
		do SWQDEL(swift202.status,REFNO,"202","swift202.swftdt")
		do swift202.setAuditFlag(1)
		set swift202.status=5	// Deleted
		set TCMT=$$^MSG(7652)	// Message deleted
		do swift202.save()
		}

	quit


SWQDEL(Number STATUS,String REFNO,Number MSGTYP,Date SWFTDT)

	// Delete entry from ^SWIFTQ, and renumber counters.

	type String QTYPE

	if (STATUS=5)!(STATUS=3) quit	// Not for "deleted" or "completed" msgs

	set QTYPE=$S(STATUS=0:"RTT",STATUS=1:"PND",STATUS=2:"REP",STATUS=4:"PRC",STATUS=6:"REV",STATUS=7:"TLX",1:"NOQ")

	quit:QTYPE="NOQ"
	
	// Update SWQCNTD Counters
	type RecordSWQCNTD swqcntd=Db.getRecord("SWQCNTD","QUE=:QTYPE,DT=:SWFTDT",1)
	set swqcntd.tot=swqcntd.tot-1
	do swqcntd.save()
	
	do Db.delete("SWIFTQ1","QUE=:QTYPE AND DT=:SWFTDT AND TRREFNO=:REFNO AND TYPE=:MSGTYP")

	quit


UPGPNT	// Upgrade Print Function via Display Function

	type public String REFNO
	
	type String UPGREF,VFMQ
	
	write $$CLEAR^%TRMVT()
	
	set UPGREF=REFNO

	do DIS

	quit


public SORTINST(String INSTCD)	// Sort Instruction Codes

	type Number I,SORT
	type String CD,INSARR(),INSTR

	for I=1:1 set INSTR=INSTCD.piece($C(13,10),I) quit:INSTR=""  do { 
		set CD=INSTR.extract(1,4)
		type RecordSTBLSWINSTR swinstr=Db.getRecord("STBLSWINSTR","INSTRCD=:CD",1)
		set SORT=swinstr.sortord 
		if SORT'=""  set INSARR(SORT)=INSTR
		}

	set INSTCD="" set CD=""
	for  set CD=INSARR(CD).order() quit:CD=""  set INSTCD=INSTCD_INSARR(CD)_$C(13,10)

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60282^60728^Pat Kelly^33438"	// Signature - LTD^TIME^USER^SIZE
