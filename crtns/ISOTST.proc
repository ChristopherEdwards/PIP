ISOTST
	/*
	 Procedure ID: ISOTST
	 Description: ISO 8583 Message Test Utility
	 Originator: Ed Sigda - 04/10/2001

	 ---- Comments --------------------------------------------------------

	 This routine contains utilities to support an ISO 8583 message
	 interface.

	 LIBRARY:
	 . SINGLE	Individual Messages to Simulate ATM Activity
	 . BREAK	Set break to capture error information from EXT^TTXP2
	 . POSTERR	Capture and/or display error information from EXT^TTXP2
	 . UTILITY	Display and or replay stored messages

	 ----------------------------------------------------------------------
	 ---- Revision History ------------------------------------------------

	12/09/05 - chhabris - CR16677
		   Replaced the reference to index table UTBLCRCDNO with CRCD.

	09/26/05 - ALAGARSS - CR 16677
		   Removed deprecated method Db.getOneRow and replaced with
		   Db.getRecord. 
	
	01/02/04 - CARROLLJ - CR7658
		   Added #ACCEPT prior to xecute command.

	05/19/03 - CARROLLJ - 51349
		   Replaced call to TTXP2 with call to TRNDRV.

	 ----------------------------------------------------------------------
	*/
	quit

SINGLE
	/*
	 Individual Messages to Simulate ATM Activity

	 This test utility will build and process messages by either
	 calling PROC^PBSSRV directly (default) or through the MTM.  To be
	 able to process messages through the MTM, an environmental
	 variable, CS_MTMISO must be defined.

	 Add the following entry into gtmenv to support the online
	 processing option of ISOTST:

	 SCA_CS_MTMISO=ip_address/port_number/header_information
	 export SCA_CS_MTMISO

	 where

	 ip_address = the ip address of the ISO 8583 test MTM.
	 port_number = the port number of the ISO 8583 test MTM.
	 header_information = a complex field where we specify the header
	 information as agreed by the third-party provider.
	*/
	type Public Boolean ER
	type Public Number CRDNUM,CRCDNO,MID,OLNTB,ONLINE,%PAGE,%PG,REPAMT,REVERSE,TAMT
	type Public String %A,%CRCD,%CO,INTRFACE,%NOPRMT,VFMQ
	type Public String data,mysav,reply,request,sysav,%READ,%TAB
	type Public String ATMM,AUTCODE,BIT,CRCD,EXP,FCID,LKUP,PRCD,REFNUM,TCID,TBL,TRN
	
	set mysav=$$VSAV^PBSUTL("%TO,%FN,TJD")
	set sysav=$$INIT^PBSUTL
	do INIT(sysav,mysav)			// Initialize variables

	// Possible message types
	set TRN("100")="Pre-Authorization Request"
	set TRN("120")="Pre-Authorization Advice"
	set TRN("200")="Financial Transaction"
	set TRN("220")="Financial Transaction Advice"
	set TRN("400")="Reversal Request"
	set TRN("420")="Reversal Advice"

	set ONLINE=0

	set %TAB("MID")="/DES=Transaction Type/LEN=3/TYP=T/TBL=TRN("
	set %TAB("ONLINE")="/DES=Online/TYP=L"

	set %PAGE=2
	set %PG=1
	set %NOPRMT="N"
	set %READ="@@%FN/CEN/REV,,MID/REQ"
	if $$SCA^%TRNLNM("CS_MTMISO")'="" set %READ=%READ_",ONLINE"

	// Call input screen
	do ^UTLREAD
	if VFMQ="Q" quit

	set PRCD="000000"
	set (REPAMT,REVERSE,TAMT)=0
	set (ATMM,FCID,TCID,AUTCODE)=""
	set CRCD=%CRCD
	set REFNUM="1001"_$$DAT^%ZM(%CurrentDate,"MMDD")_$$TIM^%ZM(%CurrentTime,"60SS")

	set %TAB("CRDNUM")="/DES=Card Number/LEN=20/TBL=[CRD]:NOVAL"
	set %TAB("TAMT")="/DES=Transaction Amount/LEN=13/DEC=2/TYP=N"
	set %TAB("CRCD")="/DES=Currency Code/LEN=3/TBL=[CRCD]"
	set %TAB("PRCD")="/DES=Processing Code/LEN=6/TYP=T/XPP=D PRCDPP^ISOTST"
	set %TAB("REVERSE")="/DES=Follow-Up Reversal?/LEN=1/TYP=L"
	set %TAB("REPAMT")="/DES=Replacement Amount/LEN=13/DEC=2/TYP=N"
	set %TAB("REFNUM")="/DES=Reference Number/LEN=12/TYP=N"
	set %TAB("AUTCODE")="/DES=Authorization Code/LEN=6/TYP=N"
	set %TAB("FCID")="/DES=From Account/LEN=12/TYP=N/XPP=S %EXT=1 D ^UACN"
	set %TAB("TCID")="/DES=To Account/LEN=12/TYP=N/XPP=S %EXT=1 D ^UACN"
	set LKUP="[NSMLOG]MSGTYP="_INTRFACE
	set %TAB("ATMM")="[HIST]ATMM/TBL=[NSMLOG]MSGID,CDAT,CTIM,PID:DESC:QU LKUP"
	set %PAGE=1,%PG=1
	set %NOPRMT="N"
	set OLNTB=3000

	set %READ="CRDNUM/REQ,FCID,TCID,TAMT/REQ,CRCD/REQ,,PRCD/REQ,REFNUM/REQ"

	// Authorization code required
	if $E(MID,2)=2!(MID=400) do {
		set %READ=%READ_",AUTCODE/REQ"
		set AUTCODE=$$GET^NXTSEQ("ISOTST",6)
		}

	// Display Reverse or Reversal prompts
	if $E(MID)'=4 set %READ=%READ_",REVERSE/REQ"
	else  set %READ=%READ_",REPAMT/REQ,ATMM"

	// Call input screen
	do ^UTLREAD
	if VFMQ="Q" quit

	// Kill %A, causes problem with Available Balance
	kill %A

	// Clear screen
	write $$CLEAR^%TRMVT,!

	type RecordCRCD crcd=Db.getRecord("CRCD","CO=:%CO,CRCD=:CRCD")
	set EXP=10**crcd.curdec
	set CRCDNO=crcd.crcdno
	set TAMT=EXP*TAMT
	set REPAMT=EXP*REPAMT

	// Build request message
	set request=$$BLDMSG(MID,CRDNUM,PRCD,TAMT,REFNUM,CRCDNO,AUTCODE,REPAMT,.TBL)

	// Process the request message
	set reply=$$PROC(request,ONLINE)

	// Display the reply message
	do DISPRSP(reply,.TBL)

	if 'ER,REVERSE do {
		set request=$$BLDREV("04"_$E(MID,2,3),request,.TBL)

		if ONLINE hang 1

		// Process message
		set reply=$$PROC(request,ONLINE)
		// Display the reply message
		do DISPRSP(reply,.TBL)
		}

	// Continue?
	if $$YN^DBSMBAR("",$$^MSG(603),0) do SINGLE

	do XKILL^PBSUTL

	quit


INIT(sysav,mysav)
	/*
	 Clean up and initialize variables
	*/
	type Public Boolean ER
	type Public String INTRFACE,RM,vzsav
	type Public Number %STFHOST
	
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
	if %SystemDate'=cuvar.tjd set sysav=$$INIT^PBSUTL
	set vzsav=$$VSAV^PBSUTL("sysav,mysav")
	do XKILL^PBSUTL
	do VLOD^PBSUTL(vzsav)
	do VLOD^PBSUTL($G(sysav))
	do VLOD^PBSUTL($G(mysav))

	set ER=0
	set RM=""

	set %STFHOST=$$%STFHOST^PBSUTL
        set INTRFACE="ISOATM"
	do INIT^ISO8583(INTRFACE)

	quit


BLDMSG(MID,CRDNUM,PRCD,TAMT,REFNUM,CRCDNO,AUTCODE,REPAMT,TBL)
	/*
	 Build a request message
	*/
	type Public String ATMM,BIT,INTRFACE,FCID,OM,TCID
	

	set MID="0"_MID

	// Use original message
	if ATMM'="" do { quit OM
		set OM=$$GETMSG(ATMM,INTRFACE,1)
		if OM="" quit
		set OM=$$BLDREV(MID,OM,.TBL)
		}

	// Standard
	set BIT(2)=CRDNUM
	set BIT(3)=PRCD
	set BIT(4)=$$RJ^%ZTEXT(TAMT,12,0)
	set BIT(14)=$$DAT^%ZM(%SystemDate+10,"MMDD")
	set BIT(18)="0000"
	set BIT(19)="000"
	set BIT(22)="000"
	set BIT(25)="00"
	set BIT(32)="000000"
	set BIT(37)=$$RJ^%ZTEXT(REFNUM,12,0)
	set BIT(43)="ISO 8583 Test Utility  MALVERN      PA  "
	set BIT(49)=$$RJ^%ZTEXT(CRCDNO,3,0)
	if FCID'="" set BIT(102)=FCID
	if TCID'="" set BIT(103)=TCID

	// Unique
	set BIT(7)=$$DAT^%ZM(%CurrentDate,"MMDD")_$$TIM^%ZM(%CurrentTime,"2460SS")
	set BIT(11)=$$RJ^%ZTEXT($$GET^NXTSEQ("ZSIMT",6),6,0)
	set BIT(12)=$$TIM^%ZM(%CurrentTime,"2460SS")
	set BIT(13)=$$DAT^%ZM(%CurrentDate,"MMDD")

	// MID dependent
	if $E(MID,3)=2!(MID=400) set BIT(38)=$$RJ^%ZTEXT(AUTCODE,6,0)
	if $E(MID,3)=2 set BIT(39)="00"
	if $E(MID,2)=4 set BIT(95)=$$RJ^%ZTEXT(REPAMT,12,0)_$$RJ^%ZTEXT("",30,0)

	// Vendor specific
        #if $$VALID^%ZRTNS("ZISO8583") do BLDMSG^ZISO8583(MID,.BIT)

	// Build the message
	set OM=$$BLDOM^ISO8583(MID,.BIT,.TBL)

	// Build the message header
        #if $$VALID^%ZRTNS("ZISO8583") set OM=$$HDR^ZISO8583(OM)

	quit OM


BLDREV(NMID,IM,TBL)
	/*
	 Build a reversal request message based on the original request
	*/
	type Public Number REPAMT
	type Public String BIT,MID,OM

	// Strip off the header
	#if $$VALID^%ZRTNS("ZISO8583") do FAPIN^ZISO8583	

	// Set up array of data elements
	set MID=$$BITMAP^ISO8583(IM,.TBL,.BIT)

	// Original data elements
	set BIT(90)=MID_BIT(11)_BIT(7)_"0000000000000000000000"

	// Replacement amount
	if $G(REPAMT) set BIT(95)=$$RJ^%ZTEXT(REPAMT,12,0)_$$RJ^%ZTEXT("",30,0)

	// Vendor specific
        #if $$VALID^%ZRTNS("ZISO8583") do BLDMSG^ZISO8583(MID,.BIT)

	// Build the message
	set OM=$$BLDOM^ISO8583(NMID,.BIT,.TBL)

	// Build the message header
        #if $$VALID^%ZRTNS("ZISO8583") set OM=$$HDR^ZISO8583(OM)

	quit OM


PROC(REQUEST,ONLINE)
	/*
	 Process message
	*/
	type Public Number CRCDNO,CRDNUM,%PAGE,%PG,REFNUM,REPAMT,REVERSE,TAMT
	type Public String ASCII,ATMM,AUTCODE,BIT,CID,CRCD,EXP,FCID,mysav,%NOPRMT,reply,request,sysav,%TAB
	type Public String INTRFACE,MID,NETID,NSMPGM,OLNTB,PGM,PRCD,%READ,TCID,TBL,TJD,TRN,UID,VFMQ,VLB,X
	
	if ONLINE quit $$EXCHMSG(REQUEST)

	/*
	 To avoid any conflict with variables defined in ISOTST, all 
	 ISOTST variables should be newed, except REQUEST.
	*/


	set NSMPGM=$S(INTRFACE="ISOATM":"ISO8583",1:"ISOSBN")

	quit $$PROC^PBSSRV(REQUEST,"","","",NSMPGM)


EXCHMSG(REQUEST)
	/*
	 Exchange message via MTM

	 This function requires that a functioning MTM and dedicated
	 ISO 8583 server is running.  The following environmental variable
	 will also need to be defined in gtmenv:

	 SCA_CS_MTMISO=host_ip_address/port_number/message_header_information
	 export SCA_CS_MTMISO
	*/
	type Public String MTMID,RM,REPLY,X
	type Public Boolean ER
	
	set REPLY=""

	// Connect
	set X=$$CLCNCT^%MTAPI(.MTMID,"","MTMISO")
	// Client/server connection failed
	if X'="" set ER=1,RM=$$^MSG(554) quit ""

	// Exchange Message
	set X=$$EXCHMSG^%MTAPI(.REQUEST,.REPLY,"",MTMID,30)
	// Timeout waiting for response from ~p1
	if X'="" set ER=1,RM=$$^MSG(7332,"PROFILE Server")
	// Client/server error
	if $E(REPLY,1,3)="CS_" set ER=1,RM=REPLY

	// Disconnect
	set X=$$CLDSCNCT^%MTAPI(MTMID)

	quit REPLY


DISPRSP(IM,TBL)
	/*
	 Display reply message
	*/
	type Public String CRCD,MSGHDR,RM,RET,REC
	type Public Number BAL,BALAVL,BALS,BIT,EXP,MID,RSPCD

	// Check if the reply is null
	if $G(IM)="" quit

	// Strip off the header
	#if $$VALID^%ZRTNS("ZISO8583") do FAPIN^ZISO8583

	// Set up array of data elements
	set MID=$$BITMAP^ISO8583(IM,.TBL,.BIT)

	// Response code
	set RSPCD=$G(BIT(39))

	// Balance Information
	set BALS=$G(BIT(54))
	set BAL=$$BAL($E(BALS,5,20))
	set BALAVL=$$BAL($E(BALS,25,40))

	if RSPCD'="00",$G(RM)'="" do {
		set REC="ERROR: "_RM
		write REC,!!
		}

	set RET="Message: "_MID_"  Response Code: "_RSPCD_$C(13)
	write RET,!
	set RET="Ledger Balance: "_BAL_"  Available Balance: "_BALAVL
	write RET,!!

	quit


BAL(REC)
	/*
	 Parse balance record
	*/
	type Public String CRCD,%CO,%MSKE,SIGN
	type Public Number BAL,CRCDNO,DEC,EXP

	set CRCDNO=REC.extract(1,3)
	set SIGN=REC.extract(4)
	set BAL=+REC.extract(5,16)

	if BAL=0 quit BAL

	type ResultSet rs=Db.select("CRCD","CRCD","CRCDNO=:CRCDNO")
	if rs.next() set CRCD = rs.getCol("CRCD")

	// if CRCD="" try removing leading zeros
	if CRCD.isNull() do {
		set CRCDNO=+CRCDNO

		type ResultSet rs1=Db.select("CRCD","CRCD","CRCDNO=:CRCDNO")
		if rs1.next() set CRCD = rs1.getCol("CRCD")
		}

	type RecordCRCD crcd=Db.getRecord("CRCD","CO=:%CO,CRCD=:CRCD")
	set DEC=crcd.curdec
	set EXP=10**DEC

	if SIGN="D" set BAL=-BAL
	set BAL=$$NUM^%ZM(BAL/EXP,DEC,%MSKE.get())

	quit BAL


PRCDPP
	/*
	 PRCD Post Processor
	*/
	type Public Boolean ER
	type Public Number X
	type Public String RM

	if X'?6N set ER=1,RM="Processing Code must be six digits"

	quit


UTILITY
	/*
	 ISO 8583 Utilities
	*/
	type Public String INTRFACE,LKUP,%NOPRMT,OPT,%READ,%TAB,VFMQ
	type Public Number %PAGE,%PG,FSEQ,IO,MSGID,OLNTB
	type Public Number SEQ,TBL,TSEQ

	type ResultSet rs

	set OPT(1)="Selected Message Ids"
	set OPT(2)="Message Id Range"
	set OPT(3)="Replay message"

	set IO=$I
	if $G(INTRFACE)="" set INTRFACE="ISOATM"
	set %TAB("IO")="/DES=Output/TYP=T/LEN=60/XPP=do IOPP^ISOTST"
	set %TAB("OPT")="/TYP=N/LEN=1/TBL=OPT(/DES=Message Id(s) Option"

	set %PAGE=2
	set %PG=1
	set %NOPRMT="N"
	set %READ="@@%FN,,,IO/REQ,OPT/REQ"

	do ^UTLREAD
	if VFMQ="Q" quit

	set %PAGE=1
	set %PG=1
	set %NOPRMT="N"
	set OLNTB=7000

	// Define ISO variables
	do INIT^ISO8583(INTRFACE)

	set LKUP="[NSMLOG]MSGTYP="_INTRFACE
	set %TAB("MSGID")="/DES=Message Id/TYP=T/LEN=40/TBL=[NSMLOG]MSGID,CDAT,CTIM,PID:DESC:QU LKUP"
	set %TAB("MSGID(0)")=%TAB("MSGID")
	set %TAB("FSEQ")="/DES=From Message Id/TYP=T/LEN=40/TBL=[NSMLOG]MSGID,CDAT,CTIM,PID:DESC:QU LKUP"
	set %TAB("TSEQ")="/DES=To Message Id/TYP=T/LEN=40/TBL=[NSMLOG]MSGID,CDAT,CTIM,PID:DESC:QU LKUP/XPP=do TSEQPP^ISOTST"

	// Selected message ids
	if OPT=1 do {
		set %READ="MSGID(0)/REQ,MSGID/REP=10/NOREQ"

		do ^UTLREAD
		if VFMQ="Q" quit

		set SEQ=""
		for  set SEQ=$O(MSGID(SEQ)) quit:SEQ=""  do SHOW(MSGID(SEQ),INTRFACE,IO,.TBL)
		}

	// Range of message ids
	if OPT=2 do {
		set %READ="FSEQ/REQ,TSEQ/REQ"

		do ^UTLREAD
		if VFMQ="Q" quit

		set rs=Db.select("MSGID","NSMLOG","MSGTYP=:INTRFACE AND MSGID BETWEEN :FSEQ AND :TSEQ")
		if rs.isEmpty() quit
		while rs.next() do SHOW(rs.getCol(1),INTRFACE,IO,.TBL)
		}

	// Replay message
	if OPT=3 do {
		set %READ="MSGID(0)/REQ"

		do ^UTLREAD
		if VFMQ="Q" quit

		do REPLAY(IO,MSGID(0),INTRFACE)
		}

	do CLOSE^SCAIO

	quit


SHOW(MSGID,INTRFACE,IO,TBL)
	/*
	 Display messages for a message id
	*/
	type Public Date nsmtpd,nsmcdat
	type Public Number IM,STATUS,TYP,%TO
	type Public String DESC1,DESC2,DESC3

	type RecordNSMLOG nsm

	if MSGID="" quit
	set DESC1="Message Id: "_MSGID_" ******************************************"
	use IO write !!,DESC1
	set DESC1="No messages for message id "_MSGID
	if 'Db.isDefined("NSMLOG","INTRFACE,MSGID") use IO write !!,DESC1 quit
	
	set nsm=Db.getRecord("NSMLOG","MSGTYP=:INTRFACE,MSGID=:MSGID")
	set nsmcdat=nsm.cdat
	set nsmtpd=nsm.tpd
	set DESC1="Date: "_nsmcdat.toString("MM-DD-YEAR")
	set DESC2="  Time: "_$$TIM^%ZM(nsm.ctim)
	set DESC3="  System Date: "_nsmtpd.toString("MM-DD-YEAR")
	use IO write !,DESC1,?18,DESC2,?36,DESC3

	// TYP=1 for request messages, TYP=2 for reply messages
	for TYP=1,2 do {
		// Retrieve message from NSMLOGD
		set IM=$$GETMSG(MSGID,INTRFACE,TYP,.STATUS)

		do DISPLAY(IO,IM,TYP,STATUS)
		}

	write !,$$MSG^%TRMVT("",0,1,1,24,%TO,1)
	quit


DISPLAY(IO,IM,TYP,STATUS)
	/*
	 Display message
	*/
	type Public String DESC1,DESC2,MSGHDR,REC,TBL
	type Public Number BIT,MID,NUM

	// Strip header
	#if $$VALID^%ZRTNS("ZISO8583") do FAPIN^ZISO8583

	set MID=$$BITMAP^ISO8583(IM,.TBL,.BIT)
	set DESC1="*** Message Type: "_TYP
	set DESC2="Message ID: "_MID
	use IO write !!,?5,DESC1,!,?5,DESC2

	if TYP=2,$G(BIT(39))'="00",$G(STATUS)'="" do {
		
		set REC="ERROR: "_STATUS
		write !!,REC,!
		
		}

	set NUM=""
	for  set NUM=$O(BIT(NUM)) quit:NUM=""  use IO write !,?5,"Bit "_NUM_"="_""""_$G(BIT(NUM))_""""

	quit


GETMSG(MSGID,INTRFACE,TYP,STATUS)
	/*
	 Retrieve message from NSMLOGD
	*/
	type Public String msg
	type Public Number SEQ

	type ResultSet rs

	set msg=""
	type ResultSet rs=Db.select("TYP,SEQ","NSMLOGD","MSGTYP=:INTRFACE AND MSGID=:MSGID AND TYP=:TYP")
	if 'rs.isEmpty() while rs.next() do {
		set SEQ=rs.getCol(2)
		type RecordNSMLOGD nsmlogd=Db.getRecord("NSMLOGD","MSGTYP=:INTRFACE,MSGID=:MSGID,TYP=:TYP,SEQ=:SEQ")
		set msg=msg_nsmlogd.dtl
		}

	type RecordNSMLOG nsmlog=Db.getRecord("NSMLOG","MSGTYP=:INTRFACE,MSGID=:MSGID")
	set STATUS=nsmlog.status

	quit msg


REPLAY(IO,MSGID,INTRFACE)
	/*
	 Replay stored NSMLOG message
	*/
	type Public Boolean ER
	type Public Number %IPMODE,%TO,X
	type Public String RM,reply,request,NSMPGM
	
	// Retrieve message from NSMLOGD
	set request=$$GETMSG(MSGID,INTRFACE,1)

	// Set break after EXT^TTXP2 to capture error information
	do BREAK

	set NSMPGM=$S(INTRFACE="ISOATM":"ISO8583",1:"ISOSBN")

	set reply=$$PROC^PBSSRV(request,"","","",NSMPGM)

	do DISPLAY(IO,request,1,"")

	do DISPLAY(IO,reply,2,$G(RM))

	set (ER,RM)=""

	write !,$$MSG^%TRMVT("",0,1,1,24,%TO,1)
	quit


IOPP
	/*
	 IO Post Processor
	*/
	type Public Number X,IO
	type Public String RM
	type Public Boolean ER,Z 
	
	set IO=X
	if IO=$I quit

	set Z=$$FILE^%ZOPEN(IO,"NEWV/WRITE",10,80)
	if 'Z set ER=1,RM=$P(Z,"|",2)

	quit


TSEQPP
	/*
	 TSEQ Post Processor
	*/
	type Public Number FSEQ,X
	type Public String RM
	type Public Boolean ER

	if X<FSEQ set ER=1,RM="To message id must be greater than from message id"
	quit

BREAK
	/*
	 Set break to capture error information from EXT^TTXP2
	*/
	type Public Number BREAK
	
        S BREAK=$$nxtline^PBSTST("post^UCTS","TRNSINGL^TRNDRV")
        I BREAK="" Q
	//I18N=OFF
	S BREAK="ZB "_BREAK_":""I $G(ER) D POSTERR^ISOTST"""
	//I18N=ON
	#ACCEPT DATE=01/02/04;PGM=John Carroll
	X BREAK
	quit


POSTERR
	/*
	 Capture and/or display error information from EXT^TTXP2
	*/
	type Public Number SPV
	type Public String RJ,RM
	
	// Rejected Transaction Array
	if $G(RM)="",$D(RJ)>9 set RM=RJ($O(RJ("")))

	// Display Supervisory Override Array
	if $D(SPV)>9 do DISPSPV^MPSTST(.SPV)
	quit
	

vSIG()	quit "60243^25821^Sanjay Chhrabria^15447"	// Signature - LTD^TIME^USER^SIZE
