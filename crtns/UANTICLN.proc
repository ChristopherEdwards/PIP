UANTICLN	// Account Projection Utilities - Loans

	/*

	---------- Revision History -------------------------------------------
	
	12/12/06 - SANTHUMS - CR 22042
		   Modified LICHND section to add the condition 
		   ln.ichnd = EVNTJD prior to bumping the dates. Since 
		   the interest change next date(ln.ichnd) was not set properly
		   the error "New interest amount not defined - Account not 
		   reset" was getting displayed in EXTERN^BCHICHAN.
		   Removed .exists() since it is not required to get into LICHND 
		   from LNACR for basis indexes.
		   		 	
	11/30/06 - DHANALAKSHMI R - CR 21407
		   Modified the section RERUNFM to use DBTBL1D instead of 
		   the Table DBTBL11 and also added a condition to make sure 
		   that only the non-computed columns for LN and DEP records
		   are getting updated.

	11/27/06 - KELLYP - CR 24216
		   Modified the LICHND section to create a HIST record after 
		   updating the loan's interest rate.  This prevents a problem 
		   where variable rate loan accounts that were backdated over 
		   interest change dates did not have rate changes logged to 
		   HIST.  Also modifued the LICHND section not to pass the IX
		   is loaded parameter to CTL^UINDX.  The system cannot ensure
		   that all rate change dates have been loaded into the IX
		   array when back-dating or projecting.
	
	10/25/06 - KELLYP - CR 23485
		   Modified RUNBIL section to consider grace days when
		   determining whether to set up the late charge event for
		   future-dated payoffs.  This fixes a problem where the PFW
		   Payoff Status report did not calculate late charges for a
		   non-daily late charge plan.
	
	09/21/06 - Ravindra Rathi - CR 22770
	           Modified RERUNHIST^UANTICLN to pass the OVR array to 
	           TRNSINGL^TRNDRV for not processing overrides for any 
	           backdated processing.
	
	09/14/06 - SANTHUMS - CR 22181
		   Modified RUNDSBSCH section to re-retrieve the ln record 
		   after the call to EXEC^BCHLNDS since the updated ln object 
		   reference is lost after the call to EXEC^TRNDRV.
			   
	08/07/06 - KELLYP - CR 22530
		   Modified EVENTL section not to setup an accrual event for
		   EFD-1 for same-day error corrects/reversals.  This prevents
		   an accrual adjustment from being posted in error.

	08/01/06 - KELLYP - CR 22417
		   Modified LNACR section to prevent an UNDEFINED error on the
		   BASREL array.  The BASREL array is not defined when the
		   EFD of the transaction being reversed is the same as the
		   current system date.

	06/28/06 - chhabris - CR21762
		   Modified EVENTL section with 'ln.subpln.isNull() as 
		   subpln is a string and alawys turns out to be a false and 
		   does not call SETLNSUB section. Included the below changes
		   also.
		   o 06/27/06 - SmithCD
		     Replaced ln.intfre check in EVENTL with 'ln.intfre.isNull() 
		     before calling LNINDEX section to prevent potentially not 
		     including frequencies that do not start with a number (such 
		     as custom frequencies).

	06/15/06 - DHANALAKSHMI R - CR 21798
		   Modified the section SETDISB by changing 'rs.next() to 
		   rs.isEmpty() in the "if" block condition to avoid skipping   
		   the first disbursement record.

	06/09/06 - DHANALAKSHMI R - CR 21181
		   Modified the section RUNFEE by adding a condition before
		   calling the batch to prevent running BCHLNFEEDE batch for 
		   today's date since this batch is part of DAYEND at EOD and 
		   so will be processed during regular DAYEND processing on  
		   that date and should not be called by UANTICLN, to prevent 
		   double-posting.

	05/17/06 - Mugilvannan - CR 21147
		   Modified the comment in BUILDQ section for the BALIRN() array
		   as it populate vale if the interest rate or balance change.
		   		   
	05/03/06 - SANTHUMS - CR 20797
		   Modified RUNPMT section to set Payoff transaction code 
		   only if TAMT is greater than or equal to payoff amount.
		   	
	04/27/06 - SmithCD - CR 20965
		   Removed local scoping of ER in RERUNHIST section, and 
		   modified RERUNFM to properly handle deposit account file 
		   maintenance (was attempting to set the ln object instead of 
		   dep, which triggered an error, which in turn caused the 
		   rollback of the transaction up to that point). Also added 
		   consideration of ln.minacr and ln.minopt in LNACR section 
		   to prevent accrual on balances less than the minimum.
	
	04/07/06 - KELLYP - CR 20579
		   Modified SETICAP section to reference ln.iropt instead of
		   ln.icap when setting up FRE and NJD for int. capitalization.
	
	04/07/06 - KELLYP - CR 20520
		   Modified EVENTL section to check the FUPO variable when
		   determining whether to set up payment related events.  This
		   ensures that the payment events are called for future-dated
		   loan payoff status reports with anticipated payment activity
		   (partial retrofit of CR 5895 from Profile01).
	
	03/16/06 - Srinivar - CR 19664
		   Modified the BUILDQ section to remove the line of code which
		   was setting the promotional rate as interest rate. The above
		   change will prevent the problem of incorrect accrual of 
		   interest for promotional rate. Interest will be 
		   calculated on the promotional rate which is specified 
		   only till expiration date and after that the interest will be
		   calculated on regular rate.	
	
	03/16/06 - KELLYP - CR 19875
		   Modified SETQUE section to make CID local instead of public.
		   This prevents a TPTIMEOUT error when SETQUE is called from
		   RESETHIST for backdated loan accounts with escrow attached.
	
	03/14/06 - TITOVE - CR 20054
		   Modified SETFEE to prevent setting up multiple QUEUE entries
		   for the same date.

	03/13/06 - KUMARB - CR 19875
		   Modified section SETQUE to set the value of CID and also 
		   added quit:ER in "for" loop of "Multiple entries".
		   
	03/07/06 - S.Krishnan - CR 19711
		   In the RUNDSBSCH section, removed the CTL parameter in call
		   to EXEC^BCHLNDS as the use of CTL variable is removed from
		   the Batch BCHLNDSDE. 

	03/03/06 - KELLYP - CR 19885
		   Modified RUNAUT section to only pass the ln object to 
		   EXEC^PROCAUTO.  PROCAUTO should generate it's own ttx objects
		   and treat them locally, not accept them as a parameter.  This
		   prevents a ttx undefined error in PROCAUTO because ttx was
		   never initialized.  Also modified SETFEE to get LNFEEP object
		   from disk instead of %CACHE because it needed to be protected
		   with a 1 in the third parameter.
	
	03/01/06 - Hillanbrand - CR 19801
	           Modified SETQUE section change %EffectiveDate to SAVEEFD to
	           allow the LCHG queue to be set when backdating a disbursement.
	           if EVNTJD > %EffectiveDate quit to if EVNTJD > SAVEFD quit
	
	02/21/06 - KELLYP - CR 19338
		   Modified the EVENTL section to reset ln.ichld=ln.dtnt prior to 
		   resetting ln.ichnd (based on ln.ichld).  This prevents a
		   problem from occurring where the system would calculate the
		   ln.ichnd based upon a value that was prior to the date of note
		   and then reset ln.ichld anyway (so the ld and nd wouldn't be
		   in synch).
	
	02/06/06 - TITOVE - CR 18449
		   Modified SETFEE by restoring Profile01 logic: no need to
		   set first piece of DAYENDLNFEEC to 1 - there is no column
		   for that piece. Added check for SKIP piece 2 to special
		   event set up, to prevent double-booking at disbursement.

	02/03/06 - KELLYP - CR 19343
		   Modified SETFMEFD section to use ln.cid instead of CID to
		   prevent an UNDEFINED error.
	
	01/30/06 - SmithCD - CR 19343 (16890)
		   Retrofitted changes involving escrow-related CR 2916, and 
		   interest index fixes from p01. Changes include:
		   . Modified ACRADJ to be ACRADJ(,) to accommodate escrow 
		     accounts
		   . Modified ACRADJ section to call ESCADJ^UANTICDP when 
		     escrow accrual adjustments are necessary
		   . Changed ACRDT to ACRDT() throughout
		   . Modified QUEUE(,) to accommodate an extra second key (CID)
		   . Changed key structure of ttx1(,) to have account number 
		     as the second key to handle multiple accounts
		   . Added ESCSEC section
		   General changes not specifically related to escrow:
		   . Moved RATECHGL and INTFREL sections to ^UANTIC (enhanced 
		     for efficiency and renamed to RATECHG and INTFRE, 
		     respectively) b/c the basic index logic s/be mostly the 
		     same for loans and deposits
		   . Added LNINDEX section to drive loan-specific interest 
		     rate changes
		   . Removed EVNTSQ parameter from RUN* sections since they 
		     are no longer used in those sections
		   . Removed FHMTRN section - uses AuditFlag(1) instead
		   . Changed RERUNHIST to post transactions through 
		     TRNSINGL^TRNDRV instead of POST^LNTRB to prevent invalid 
		     HISTLST insertions to previously unwound transactions
		   . Removed CTL parameter in call to EXTERN^BCHLNSCH to 
		     prevent undefined error
		   . Added a quit from the top of the SETPPI if it is not a 
		     future projection to prevent accruals from incorrectly 
		     starting from the date of note on backdated transactions
		   . Labeled sections that are only called from within the 
		     system area as private (instead of public)
		   . Further cleaned up code
		     	
	10/07/05 - SmithCD - CR 16885
		   . Removed all occurrences of ACTVY(), which is no longer 
		     needed
		   . Modified ACCRUAL section to accept ACRADJ parameter by 
		     reference, so the set of it "sticks"
		   . Removed "ifless" else in SETFEE section
   		   . Eliminated occurrences of FRSTCHNG - not needed
   		   . Added quit:ER after calls to SET* sections in EVENTL
		   . Performed some general cleanup
	
	07/22/05 - CARROLLJ - CR16928
		   Modifed call to EXTERN^BCHLNFEE to pass the ttx object.  
		   Also modified SETFEE section to remove check on getMode, 
		   and pass FRE in SETQUE calls.

	05/31/05 - SmithCD - CR 15902
		   . Simplified the subtraction of ACRADJ from ln.acr by 
		     consolidating two sets (one in ACRADJ and one in ACCRUAL)
		     into a single one in ACRADJ, removing the need for the 
		     ACRL flag (Corrects doubling of ln.acr over the accrual 
		     adjustment that occurred when ACRADJ never got subtracted 
		     from ln.acr on non-discount/add-on loans)
		   . Modified RERUNHIST section to pass TSO and TCMT from 
		     ttx(,) to POST^LNTRB call for monetary transactions so 
		     they get populated (including "REAPPLY#" in the reapplied 
		     transaction
		   . Modified ACRADJ section to only call LATE2 section if 
		     ln.popt is defined to avoid RECNOFL error
		   . Removed occurrences of lnsysgen variable, which are no 
		     longer needed
		   . Removed call to INDDATA^LNU in LICHND section b/c it is 
		     no longer necessary / appropriate
		   . Performed some cleanup, and eliminated most warnings

	05/06/05 - KinI - 15524
		   Modified to replace lnbil1.bp1 first piece references 
		   with lnbil1.casd sub-field per DBI standards.		   

	04/18/05 - KELLYP - CR 13662
		   Made multiple changes throughout procedure to correct various
		   undefined errors during backdated loan account creation.

	03/14/05 - TITOVE - CR 13733
		   . Modified RUNDSBSCH to pass CTL to EXEC^BCHLNDS and added
		     the logic for checking of history sequences.
		   . Modified ACCRUAL to instantiate LNACR3 object, if it 
		     does not exist.
		   . Modified EVENTL to pass proper arguments to SETPMT and to
		     SETDISB.
	
	*/

	quit


private BUILDQ(RecordLN ln,		// Loan account			/REF:R
	       RecordTTX ttx,		// Transaction			/NOREQ/REF:R
	       Date %SystemDate,	// System date
	       Date %EffectiveDate,	// Effective (thru) date
	       String CTL,		// Control indicators		/NOREQ
	       String SKIP,		// Skip indicators		/NOREQ
	       String BALIRN(),		// Interest Accrual Projection	/REF:RW
	       Number ACRDT())		// Accrued-thru date		/REF:W

	/*
	Project loan %SystemDate through %EffectiveDate, and build QUEUE(,,)

	Additional notes on ARGUMENTS:

	. SKIP
		Position   
		1 - skip regular loan payments
		2 - skip initial disbursement
	*/
	
	type public Boolean ER
		
	// Initialize accrued-thru date
	set ACRDT(ln.cid) = %SystemDate - 1
	
	// For Interest Accrual Projection Report, set up BALIRN() entry for 
	// first day, and later whenever the interest rate or balance changes
	if BALIRN set BALIRN(%SystemDate) = ln.balint_"|"_ln.irn
	
	do EVENTL(.ln, .ttx) quit:ER
	
	quit
	

EVENTL(RecordLN ln,		// Loan account			/REF:R
       RecordTTX ttx)		// Transaction			/NOREQ/REF:R

	// Build events for loan accounts

	type public Boolean ER, FUPO, LNMDLR, LNPTSRV
	type public Number TRNSEQ
	type public String BALIRN(), CTL, SKIP, QUEUE(,,)
	type public Date ACRDT(), CUVAR2, SAVTJD

	type String EVNT

	// Set EFT Collection Orders (for MRPC100 only)
	if BALIRN = 1 do SETEFT^UANTIC(.ln, %SystemDate, %EffectiveDate, 2) quit:ER

	/*
	Check for Teaser Rate Expiration Date - set in QUEUE(,,) to
	force accrual calculations, if a teaser rate exists
	*/
	if ln.trexd > ACRDT(ln.cid), ln.trexd < %EffectiveDate do SETEASER(.ln) quit:ER

	// Set up return processing
	if 'ln.rdt.isNull(), ln.rdt < %EffectiveDate do SETQUE(.ln, "", ln.rdt, 0, 0, "Loan Return|RUNRTRN") quit:ER

	// Set up maturity date processing
	if 'ln.mdt.isNull(), ln.mdt '> %EffectiveDate do SETQUE(.ln, "", ln.mdt, 0, 0, "Maturity Date Process|RUNMDTL") quit:ER

	/*
	Future dated file maintenace application must precede proceeses
	such as the scheduled date roll.  Subsidy processing, for example,
	requires values as changed by the file maintenance process.
	*/
	do SETFMEFD(.ln, %SystemDate, %EffectiveDate) quit:ER

	/*
	Skip billing, date roll, interest and payment offset processing and
	change processing, if this account has no Distribution Frequency.
	*/
	if ('ln.dist1fre.isNull()), ((%SystemDate '= CUVAR2) ! (CTL = "01") ! (LNMDLR.get()) ! (FUPO.get())) do { quit:ER

		// Set bill
		do SETBIL(.ln)

		// Setup balance for interest calculations
		do SETIDGP(.ln, %SystemDate, %EffectiveDate, CUVAR2)

		// Setup for Scheduled date roll
		do SETQUE(.ln, ln.dist1fre, ln.schnd, 0, 0, "Scheduled Date Roll|RUNSCHND") quit:ER

		// Setup for Late Charges
		if 'ln.lchgnoto do SETLCHG(.ln, %SystemDate, %EffectiveDate, FUPO.get()) quit:ER

		// Set up custom notice date if custom notices trigger late charges
		if ln.lchgnoto, %SystemDate < CUVAR2 do SETCUS(.ln, 2, %SystemDate, CUVAR2) quit:ER

		// Interest offset processing setup

		if ln.ichnd, 'ln.intfre.isNull() do { quit:ER

			// Roll back ln.ichld / ln.ichnd if bringing loan current
			if CTL.extract(1) do { quit:ER
				if ln.intfre = "*2" quit
				for  quit:($$INTOFFDT^LNCDI(ln.ichld, ln.intoff, ln.intoffcl)) < ln.dtnt  set ln.ichld = ln.ichld.nextFreqDate("-"_ln.intfre) quit:ER
				if ln.ichld < ln.dtnt set ln.ichld = ln.dtnt
				set ln.ichnd = ln.ichld.nextFreqDate(ln.intfre) quit:ER
				}
				
			do LNINDEX(.ln)
			}

		// Set up for Payment offset processing
		if 'ln.pcoff.isNull() do SETQUE(.ln, ln.pcfre, ln.pchnd, ln.pcoff, 0, "Payment Offset Processing|RUNPCOFF") quit:ER

		// Set up for Payment change date
		if ln.pcfre do SETQUE(.ln, ln.pcfre, ln.pchnd, 0, 0, "Payment Change Date|RUNPCHND") quit:ER

		// Set up for deferred interest capitalization
		do SETDECAP(.ln) quit:ER

		/*
		Subsidy review processing, an end-of-day process which
		takes place after the previous beginning-of-day functions.
		*/

		if 'ln.subpln.isNull() do SETLNSUB(.ln, %SystemDate) quit:ER
		}

	// Loan fee setup	
	do SETFEE(.ln, %SystemDate, CUVAR2, SKIP) quit:ER
	
	/*	
	Prepaid (Odd) Interest setup.
	If a loan is not set up to renew, this section only be passed 
	through once.
	If a loan is set up to renew, the process calls this section
	twice. The first pass will set up all QUEUE entries up to the 
	renewal date.  The loan will then renew. Then, the second pass 
	will set up all of the QUEUE entries from the renewal date up 
	to EFD. 
	Prepaid Interest should be processed only once for all loans.  
	The check "if SAVTJD=%SystemDate" makes sure that SETPPI is 
	called only once.
	*/
		
	if SAVTJD = %SystemDate do SETPPI(.ln) quit:ER
		
	// Set up for future-dated disbursement(s)
	type Number PRISEQ
	
	if ttx.exists() set PRISEQ = +TRNSEQ.get()
	else  set PRISEQ = 0
	
	do SETDISB(.ln, %SystemDate, %EffectiveDate, PRISEQ, SKIP, LNPTSRV.get()) quit:ER

	// Set up for Automatic Loan payment
	do SETAUT(.ln, CUVAR2, CTL) quit:ER

	/*
	Loan payments are not set up through PAT, but other
	unscheduled loan transactions may be.  Process these.
	*/
	if 'ln.ptf do SETPAT^UANTIC(.ln, %SystemDate, %EffectiveDate) quit:ER

	/*
	Loan payments are made through PAT. If loan payments are
	not supposed to be skipped, process these.
	*/
	if ln.ptf, 'SKIP.extract(1) do SETPAT^UANTIC(.ln, %SystemDate, %EffectiveDate) quit:ER

	/*
	Loan payments are not made through PAT.  
	If we are not supposed to skip loan payments, set these up to be 
	processed.
	*/
	if 'ln.ptf, 'SKIP.extract(1) do SETPMT(.ln, %SystemDate, %EffectiveDate) quit:ER

	// Set up for capitalized interest due
	do SETICAP(.ln) quit:ER

	// Set up for EFT payment orders (for MRPC100 only)
	if BALIRN = 1 do SETEFT^UANTIC(.ln, %SystemDate, %EffectiveDate, 1) quit:ER

	// Set the end of month events
	do SETEOM(.ln, %SystemDate, CUVAR2) quit:ER

	// Ensure final accrual event is set
	if (SAVTJD '= CUVAR2)!(%EffectiveDate > CUVAR2) set QUEUE((%EffectiveDate - 1), ln.cid, 9999) = "Calculate accruals"
 
	quit


SETEASER(RecordLN ln)		// Loan account			/REF:R
	
	// Setup teaser
	
	type public Boolean ER
	
	do SETQUE(.ln, "", ln.trexd, 0, 0, "Teaser rate expires|TEASER") quit:ER

	quit


SETFMEFD(RecordLN ln,		// Loan account			/REF:R
	 Date %SystemDate,	// System date
	 Date %EffectiveDate)	// Effective date

	// Set up future-date file maintenance
	
	type public Boolean ER

	type Date JD
	
 	type ResultSet rs = Db.select("EFDATE", "EFD", "TABLE='LN' AND AKEY=:ln.cid AND EFDATE>:%SystemDate")
 	   
 	while rs.next() do { quit:JD > %EffectiveDate ! (ER)
 		set JD = rs.getCol("EFDATE")
		if JD > %EffectiveDate quit

 		do SETQUE(.ln, "", JD, 0, 0, "Future-dated File Maintenance|RUNFMEFD") quit:ER
		}

	quit


SETBIL(RecordLN ln)		// Loan account			/REF:R

	// Bill processing
	
	type public Boolean ER
	
	type String EVNT
	
	set EVNT ="Billing|RUNBIL"

	do SETQUE(.ln, ln.dist1fre, (ln.bndt + ln.bloff), ln.bloff, 1, EVNT)
	
	quit


SETLCHG(RecordLN ln,		// Loan account			/REF:R
	Date %SystemDate,	// System date
	Date %EffectiveDate,	// Effective date
	Boolean FUPO)		// Calculate future payoff	/NOREQ

	// Late charge processing
	
	type public Date CUVAR2
	type public Boolean ER

	// Late Charge Action Date
	if ln.lcad '< %SystemDate, ln.lcad < CUVAR2 do { quit:ER
		if (ln.lcad > %EffectiveDate) ! (ln.lcad.isNull()) quit
		if FUPO.get(), ln.lcad '> CUVAR2 quit
		
		do SETQUE(.ln, "", ln.lcad, 0, 0, "Late Charge Processing|RUNLCHG") quit:ER
		}

	quit


SETLNSUB(RecordLN ln,		// Loan account			/REF:R
	 Date %SystemDate)	// System date

	// Payment change date processing

	type public Boolean ER
	
	do SETQUE(.ln, ln.dist1fre, ln.schnd, 0, 0, "Subsidy Review Processing|RUNLNSUB") quit:ER

	/*
	If today is the last scheduled date, and today is not the opening date 
	for account, must also set up for today. The subsidy process is run
	end-of-day, so must be queued to occur for the first time on the 
	system date.
	*/
	if ln.schld '= %SystemDate ! (ln.schld = ln.odt) quit
	
	do SETQUE(.ln, "", ln.schld, 0, 0, "Subsidy Review Processing|RUNLNSUB") quit:ER

	quit


SETPMT(RecordLN ln,		// Loan account			/REF:R
       Date %SystemDate,	// System date
       Date %EffectiveDate)	// Efective date

	// Loan Payments processing
	
	type public Boolean ER

	do SETQUE(.ln, "", (%SystemDate + 1), 0, 0, "Post Delinquent Amounts|RUNPMT") quit:ER

	do SETQUE(.ln, ln.dist1fre, ln.schnd, 0, 0, "Post Due Amounts|RUNPMT") quit:ER

	quit


SETIDGP(RecordLN ln,		// Loan account			/REF:R
	Date %SystemDate,	// System date
	Date %EffectiveDate,	// Effective date
	Date CUVAR2)		// Customer variables system date

	// Setup balance for interest calculations
	
	type public Boolean ER

	type String EVNT
	type Date EXPDT

	set EVNT = "Free Interest Expiration Process|RUNIDGP"

	type DbSet ds = Db.selectDbSet("LNDS1", "CID=:ln.cid")	
	while ds.next() do { quit:ER
		type RecordLNDS1 lnds1 = ds.getRecord("LNDS1")

		// Grace Period Expiration Date
		set EXPDT = lnds1.expdt

		if 'EXPDT, ln.idgp set EXPDT = lnds1.sdd + ln.idgp - 1
		if %EffectiveDate '> CUVAR2, (EXPDT > (CUVAR2 - 1)) quit

		// Loan Scheduled Disbursement Date
		set EVNT.piece("|", 4) = lnds1.sdd
		if (EXPDT > (%SystemDate - 1)), (EXPDT '> %EffectiveDate) do SETQUE(.ln, ,(EXPDT + 1), 0, 0, EVNT) quit:ER
		}

	quit


SETCUS(RecordLN ln,		// Loan account			/REF:R
       Number DELQTYP,		// Delinquency type
       Date %SystemDate,	// System date
       Date CUVAR2)		// Customer variable system date

	/*
	Set up custom notice date
	
	Additional notes on ARGUMENTS:
	. DELQTYP		
	  2 Regular delinqency
	  5 Monetary transaction delinquency
	  12 Reversed transaction delinquency
	*/
	
	type public Boolean ER
	type public String LCHGNOT(), QUEUE(,,)

	type Number DELQ, MINNOTBA
	type String CUSTNOT, LCGRDNOT
	type Date NOTDT
	
	// Custom Notice Production
	if ln.custnot.isNull() quit

	// Billing - Last Sequence Number
	if ln.bseq.isNull() quit
	
	set CUSTNOT = ln.custnot	
 
	if 'LCHGNOT(CUSTNOT).exists() do LDLCNOT(CUSTNOT)
	if 'LCHGNOT(CUSTNOT).exists() quit
 
	// Delinquency
	set DELQ = LCHGNOT(CUSTNOT).piece("|", DELQTYP)
	if DELQ.isNull() quit
	
	type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:ln.bseq")
	
	// Payment Due Date
	if lnbil1.cdpd.isNull() quit
	
	// Regular delinqency
	if DELQTYP = 2 do { quit
		set NOTDT = $$PERIOD^LNU(lnbil1.cdpd, DELQ, ln.dist1fre) quit:ER
		if 'NOTDT.isNull(), NOTDT < CUVAR2 do { quit:ER
			type Number ZSEQ = ""
			type Boolean FOUND = 0
			 
			// Avoid duplicate queue entries
			for  set ZSEQ = QUEUE(NOTDT, ln.cid, ZSEQ).order() quit:ZSEQ.isNull()  do { quit:FOUND
				if QUEUE(NOTDT, ln.cid, ZSEQ).piece("|", 2) = "RUNCUS" set FOUND = 1
				}
			quit:FOUND
			do SETQUE(.ln, "", NOTDT, 0, 0, "Custom Notice Date|RUNCUS") quit:ER
			}
		}

	/*
	If DELQTYP '= 2 (Monetary transaction delinquency or
	Reversed trasnaction delinquency)
	*/
	type Date DDATE
	
	set DDATE = $$PERIOD^LNU(lnbil1.cdpd, DELQ, ln.dist1fre) quit:ER
	
	if DDATE '> %SystemDate do {
 
		// Don't create a notice if due amount is less than MINNOTBA
		if lnbil1.casd < MINNOTBA quit
	
		do NOTICE(.ln)
		}

	quit


LDLCNOT(String CUSTNOT)		// Delinquency notice name
 
 	/*
 	Load LCHGNOT array with Custom Notice category that triggers late 
 	charges
 	*/
 	
 	type public String LCHGNOT()
 
 	type ResultSet rs = Db.select("LCGRDNOT", "UTBLCUSNOT", "NOTICE=:CUSTNOT AND LCGRDNOT IS NOT NULL")
 	   
 	if rs.next() set LCHGNOT(CUSTNOT) = rs.getRow().toString()

	quit


SETDECAP(RecordLN ln)		// Loan account			/REF:R

	// Set up for deferred interest capitalization

	// Defer Interest In Excess of Accrual
	if ln.dxsi = 0 quit
	
	// Resolution Option
	if ln.iropt.isNull() quit

	type Number IROPT
	type String FRE = ""
	type Date NJD

	set IROPT = ln.iropt

	if IROPT = 2 set FRE = ln.dirfre set NJD = ln.dirnd
	if IROPT = 3 set FRE = ln.pcfre set NJD = ln.pchnd
	if IROPT = 4 set FRE = ln.dist1fre set NJD = ln.schnd

	if FRE.isNull() quit

	do SETQUE^UANTIC(.ln, FRE, NJD, 0, 0, "Capitalize Deferred Interest|RUNDECAP")

	quit


SETFEE(RecordLN ln,		// Loan account			/REF:R
       Date %SystemDate,	// System date
       Date CUVAR2,		// Customer variable system date
       String SKIP)		// Skip control indicators

	/*
	  Set up DAYENDLNFEEC record for every fee type, while making sure that
	  "Loan Fees" event should be run only once for every assessment date, 
	  which could include multiple fee types. 

	Additonal notes on ARGUMENTS:
	. SKIP
	  Position   1 - skip regular loan payments
		     2 - skip initial disbursement
	*/
	
	type public Boolean ER
	type public String QUEUE(,,)

	type String QUE(,)

	// Exclude fees that have a fee plan that is "Linked to Fee"
	type DbSet ds = Db.selectDbSet("LNFEE", "CID=:ln.cid AND LFEE<>1")
	
	while ds.next() do { quit:ER
		
		type RecordLNFEE lnfee = ds.getRecord("LNFEE")
		
		type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP=:lnfee.feetyp",1)

		// Fee Computation/Assessment Method = 0 (Special Event)
		if SKIP.extract(2), (lnfeep.amth = 0), (ln.dtnt < CUVAR2), (%SystemDate '> ln.dtnt) do { quit:ER

			// If an entry exists, prevent setting up multiple QUEUE entries
			if 'QUE(%SystemDate,ln.cid).exists() do SETQUE(.ln, "", %SystemDate, 0, 0, "Loan Fees|RUNFEE") quit:ER

			type RecordDAYENDLNFEEC daylnfee = Db.getRecord("DAYENDLNFEEC", "ASND=:%SystemDate,CID=:ln.cid,FEETYP=:lnfee.feetyp", 1)
			
			set daylnfee.reversed = 0
			
			do daylnfee.bypassSave()
			
			set QUE(%SystemDate,ln.cid) = ""
			}

		if lnfee.asnd, 'lnfeep.cfre.isNull() do { quit:ER

			// If an entry exists, prevent setting up multiple QUEUE entries
			if 'QUE(lnfee.asnd,ln.cid).exists() do SETQUE(.ln, lnfeep.cfre, lnfee.asnd, 0, 0, "Loan Fees|RUNFEE") quit:ER

			type RecordDAYENDLNFEEC daylnfee = Db.getRecord("DAYENDLNFEEC", "ASND=:lnfee.asnd,CID=:ln.cid,FEETYP=:lnfee.feetyp", 1)
			
			set daylnfee.reversed = 0
			
			do daylnfee.bypassSave()
			
			set QUE(lnfee.asnd,ln.cid) = ""
			}
		}

	quit


SETPPI(RecordLN ln)		// Loan account			/REF:R

	// Setup prepaid (odd days) interest event
	
	type public Boolean ER
	type public Date CUVAR2
	
	// For projections into future only
	if %SystemDate '> CUVAR2 quit

	// Disclosure - Prepaid Interest Amount	
	if 'ln.disppi quit

	// Odd Days Interest Option	
	if ln.odio = 1 quit
	
	do SETQUE(.ln, "", ln.dtnt, 0, 0, "Prepaid (Odd Days) Interest|RUNPPI") quit:ER

	quit


SETDISB(RecordLN ln,		// Loan record			/REF:R
	Date %SystemDate,	// System date
	Date %EffectiveDate,	// Effective (thru) date
	Number PRISEQ,		// Transaction sequence
	String SKIP,		// Skip control indicators
	Boolean LNPTSRV)	// Loan reverse/reapp indicator	/NOREQ

	/*
	Set-up for future-dated disbursement(s)

	Additonal notes on ARGUMENTS:
	. SKIP
	  Position   1 - skip regular loan payments
		     2 - skip initial disbursement

	*/
	
	type public Boolean ER

	type Number BALCMP, CRLMT
	type Date JD, ODD
	
	set BALCMP = +ln.bal
	if ln.aruf set BALCMP = BALCMP - ln.udbal

	set CRLMT = ln.crlmt

	type ResultSet rs = Db.select("SDD", "LNDS1", "CID=:ln.cid")
	if rs.isEmpty(),'SKIP.extract(2), 'BALCMP, 'ln.cntdr do { quit
		
		// Call made from LNPTSRV
		if LNPTSRV.get() quit
		
		if CRLMT = 0 quit
		
		// Original Disbursement Date
		set ODD = ln.odd
		
		// Use original disbursement date vs system (event) date
		if ln.odd < %SystemDate set ODD = %SystemDate

		type RecordLNDS1 lnds1 = Class.new("RecordLNDS1", "CID=:ln.cid,SDD=:ODD")

		set lnds1.sda = CRLMT
		
		do lnds1.bypassSave()	
		
		do SETQUE(.ln, "", ODD, 0, 0, "Single Loan Disbursement|RUNDSBSCH") quit:ER
		}

	set JD = %SystemDate - 1
	while rs.next() quit:(JD > %EffectiveDate)  do { quit:ER
		if rs.getCol("SDD") < %SystemDate quit
		set JD = rs.getCol("SDD")
		do SETQUE(.ln, "", JD, 0, 0, "Disbursement Schedule|RUNDSBSCH") quit:ER
		}

	quit


SETAUT(RecordLN ln,		// Loan account			/REF:R
       Date CUVAR2,		// Customer variable system date
       String CTL)		// Control indicators		/NOREQ

	// Automatic Loan payment
	
	type public Boolean ER

	// Automatic Loan Payment Due Method
	if 'ln.alpdue quit		

	type Date SCHND

	// Scheduled Payment - Next Date	
	set SCHND = ln.schnd

	if CTL="01", ln.dist1nd = CUVAR2, $$QUELOC^UANTIC("QUE079") = 1 set SCHND = CUVAR2

	do SETQUE(.ln, ln.dist1fre, SCHND, 0, 0, "Automatic Loan Payment|RUNAUT") quit:ER

	quit


SETICAP(RecordLN ln)		// Loan account			/REF:R
	
	// Set up for capitalized interest due
	
	type public Boolean ER
	
	// Interest Capitalization
	if 'ln.icap quit 	

	// Resolution Option	
	if ln.iropt.isNull() quit	
		
	type String FRE = ""
	type Date NJD

	if ln.iropt = 2 set FRE = ln.dirfre set NJD = ln.dirnd
	if ln.iropt = 3 set FRE = ln.pcfre set NJD = ln.pchnd
	if ln.iropt = 4 set FRE = ln.dist1fre set NJD = ln.schnd

	if FRE.isNull() quit

	do SETQUE(.ln, FRE, NJD, 0, 0, "Capitalize Interest Due|RUNICAP") quit:ER

	quit


SETEOM(RecordLN ln,		// Loan account			/REF:R
       Date %SystemDate,	// System date
       Date CUVAR2)		// Customer variable system date

	// Set the end of month events
	
	type public Boolean ER

	type Date EOMDATE
	
	set EOMDATE = $$EOMJD^SCADAT(%SystemDate, 1)
	
	for  quit:EOMDATE > CUVAR2  do { quit:ER
		do SETQUE(.ln, "", EOMDATE, 0, 0, "End of Month Balance|RUNEOM") quit:ER

		set EOMDATE = EOMDATE + 1
		set EOMDATE = $$EOMJD^SCADAT(EOMDATE, 1)
		}

	quit


private RESETHIST(RecordLN ln,		// Loan account			/REF:R
		  RecordTTX ttx1(,,))	// Transaction set from history	/REF:R

	/*
	Reset records previously found in ^HIST to QUEUE(,,)

	Additional notes on ARGUMENTS:
	. ttx1(,,)
		Contains previously-existing history entries that need
		to be examined and possibly overridden
	*/
	
	type public Boolean ER
	type public Date ACRDT()
	type public String QUEUE(,,)

	type Number CID, TSEQ
	type Date HEFD
	type String EVNT
	
	set (CID, HEFD) = ""
	
	set EVNT = "Reset history entries|RERUNHIST"

	for  set HEFD = ttx1(HEFD).order() quit:HEFD.isNull()  do { quit:ER
		for  set CID = ttx1(HEFD, CID).order() quit:CID.isNull()  do { quit:ER
			do SETQUE(.ln, "", HEFD, 0, 0, EVNT) quit:ER
			if CID = ln.cid do ESCSEC(.ttx1(,,), HEFD, CID, .QUEUE(,,))
			}
		}

	quit


ESCSEC(RecordTTX ttx1(,,),	// Transaction set from history		/REF:R
       Date HEFD,		// Effective date in history
       Number LCID,		// Loan account number
       String QUEUE(,,))	// Event queue				/REF:W

	/*
	Set accrual entries in QUEUE(,,) for attached escrow accounts
	
	For financial loan transactions, attached escrow accounts may be hit 
	via a secondary transaction (indicated in the lower levels of history)
	... since it is not known at this point how the transaction will 
	reapply, an accrual entry must be set for the escrow account in case 
	a secondary transaction to the escrow is spawned from it
	*/
	
	type public Date ACRDT()

	type Number ESCCID, TSEQ = ""

	for  set TSEQ = ttx1(HEFD, LCID, TSEQ).order() quit:TSEQ.isNull()  do {

        	// Monetary transaction
		if $translate(ttx1(HEFD, LCID, TSEQ).tamt, "0#") do {
			set ESCCID = ""

			for  set ESCCID = ACRDT(ESCCID).order() quit:ESCCID.isNull()  do {
				// Exclude the loan itself
				if ESCCID = LCID quit

				set QUEUE((HEFD - 1), ESCCID, 9999) = "Calculate accruals"
				}
			}
		}

	quit


	//*******************************************************
	// Run events
	//*******************************************************

private RUNFMEFD(RecordLN ln,		// Loan account			/REF:R
		 Date %SystemDate)	// System date

	// Set up future-date file maintenance
	
	type public Boolean ER

	type DbSet ds = Db.selectDbSet("EFD", "TABLE='LN' AND AKEY=:ln.cid AND EFDATE=:%SystemDate")

	while ds.next() do { quit:ER
		type RecordEFD efd = ds.getRecord("EFD")

		// Update the loan object using SQL statement from EFD table
		set ER = $$UPDLN(.ln, efd.sql)
		}
	
	quit


UPDLN(RecordLN ln,		// Loan account			/REF:R
      String TRN)		// SQL statement

	// Update the loan object using SQL statement from EFD table
	
	type public Boolean ER

	type Number I, SETLEN
	type String col, tok, val, x, NODATA, SET, WHERE
	
	set NODATA = $$RET^SQL($$TOK^SQL(TRN, "SET,WHERE", .tok), .tok)
	
	set SETLEN = SET.length(",")
	
	for I=1:1:SETLEN do { quit:ER
	       set x = $$POP^%ZS(SET.piece(",", I))
	       set col = $$RET^SQL(x.piece("=", 1), .tok)
	       set col = $$TRIM^%ZS(col)
	       if col.isLike("%.%") set col = col.piece(".",2)
	       set val = x.piece("=", 2, 999)
	       set val = $$TRIM^%ZS(val)
	       set ln.@col = val
	   }

	quit


private RUNCUS(RecordLN ln,		// Loan account			/REF:R
	       Date %SystemDate,	// System date
	       Date CUVAR2)		// Customer variable system date

	// Determine LCAD from custom notice date
	
	type public String LCHGNOT()

	type Number CUSTNOT, LCGRDNOT, MINNOTBA

	if ln.custnot.isNull() quit	// Custom Notice Production

	set CUSTNOT = ln.custnot

	if 'LCHGNOT(CUSTNOT).exists() do LDLCNOT(CUSTNOT)
	if 'LCHGNOT(CUSTNOT).exists() quit
	
	type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:ln.bseq")

	// Late Charge Grace Days Based on Notice
       	set LCGRDNOT = LCHGNOT(CUSTNOT).piece("|", 13)
	// Minimum Bill Amount for Notice
	set MINNOTBA = LCHGNOT(CUSTNOT).piece("|", 11)

	// Don't create a notice if due amount is less than MINNOTBA
	if lnbil1.casd < MINNOTBA quit
	
	do NOTICE(.ln)
	
	quit


NOTICE(RecordLN ln)		// Loan account		/REF:R

	type public String QUEUE(,,)
	type public Date CUVAR2
	type public Boolean ER
	type public Number LCGRDNOT

	// Late Charge Action Date
	set ln.lcad = $$PERIOD^LNU(%SystemDate + 1, LCGRDNOT, ln.dist1fre) quit:ER

	if ln.lcad '< CUVAR2 quit
	
	do SETQUE(.ln, "", ln.lcad, 0, 0, "Late Charge Processing|RUNLCHG") quit:ER

	// Set accrual event for end of current day
	set QUEUE(ln.lcad, ln.cid, 9999) = "Calculate accruals"

	quit

	
private RUNFEE(RecordLN ln,		// Loan account			/REF:RW
	       Date %SystemDate,	// System date
	       RecordTTX ttx)		// Primary transaction		/REF:R

	// Run frequency-based loan fees
	
	type public Boolean ER
	type public Date CUVAR2
	type public String CTL

	// If not projecting forward and fee batch is in EOD portion of DAYEND,
	// (where it should be), it will process today's fee records later today
	if (CTL '= "01"), (%SystemDate = CUVAR2), ($$QUELOC^UANTIC("QUE005") = 1) quit

	// Create and post transactions
	do EXTERN^BCHLNFEE(.ln, .ttx) quit:ER

	quit


private RUNMDTL(RecordLN ln,		// Loan account		/REF:RW
		Date %SystemDate)	// System date

	// Maturity date
	
	type public Boolean ER
	type public Date CUVAR2

	// These variables get changed by BCHROLL
	type String %UserClass, %UserID, ETC
	type Number BRCD
	
	// Generate transactions
	do EXTERN^BCHROLL(.ln) quit:ER

	quit


private RUNBIL(RecordLN ln,		// Loan record		/REF:RW
	       RecordTTX ttx,		// Transaction record	/NOREQ/REF:R
	       Date %SystemDate,	// System date
	       Date %EffectiveDate)	// Effective date

	// Generate bills
	
	type public Boolean ER, FUPO
	type public Date CUVAR2
	type public String QUEUE(,,)
 
 	type Date TPD
	
	set TPD = %SystemDate

	// Generate bill records 
	do EXEC^BCHLNLD(.ln, 1) quit:ER

	// No penalty option set up for this account

	// Penalty Calculation Method
	if ln.popt.isNull() quit

	type String NBDC
	
	// Get Calendar from CUVAR
	set NBDC = CUVAR.LCNBDC

	// Do not calculate late charges when error correcting a transaction
	if ttx.exists(), ttx.itc6 &(CUVAR2 = %SystemDate) quit

	// Late Charge Processing
	type Number BLOFF
	type Date BLDT, LCAD
	type String DIST1FRE, ITC, PMTGRC
	type Boolean LCHGNOTO
	
	// Billing - Last Date			
	set BLDT = ln.bldt
	// Billing Date Offset		
	set BLOFF = ln.bloff
	// Distribution 1 Frequency		
	set DIST1FRE = ln.dist1fre	
	// Payment Grace Period	
	set PMTGRC = ln.pmtgrc
	// Late Charge Notice Option	 	
	set LCHGNOTO = ln.lchgnoto	

	if LCHGNOTO, %SystemDate < CUVAR2 do SETCUS(.ln, 2, %SystemDate, CUVAR2) quit

	// Next Late Charge Action Date - projected based on the Payment Date
	set LCAD = $$PERIOD^LNU(BLDT+BLOFF, PMTGRC, DIST1FRE) quit:ER

	// Set LCAD to Next Business Day according to Calendar
	set LCAD = $$NBD^UNBD(LCAD, 1, 0, NBDC) quit:ER
	// Late Charge Action Date
	set ln.lcad = LCAD
	//  Late Charge Effective Date	
	set ln.lcefd = BLDT + BLOFF 	

	if 'FUPO.get(), LCAD '< CUVAR2 quit

	/*
	 Need to consider grace days, otherwise a future-dated payoff
	 never sets up the late charge event for non-daily late charges.
	*/
	if FUPO.get(), (LCAD > (%EffectiveDate+PMTGRC)) quit
	
	do SETQUE(.ln, "", LCAD, 0, 0, "Late Charge Processing|RUNLCHG") quit:ER
	set QUEUE(LCAD, ln.cid, 9999) = "Calculate accruals"

	if %SystemDate < $$BOYJD^SCADAT((CUVAR2 - 1), 1) do {
		if ttx.exists() do FISCAL^LNPTSR(.ln, ttx.efd) if 1
		else  do FISCAL^LNPTSR(.ln, %SystemDate)
		}
			
	quit


private RUNICHND(RecordLN ln,		// Loan account		/REF:RW
		 Date %SystemDate,	// System date
		 Date CUVAR2)		// Customer variable system date

	// Change interest rate at interest change next date, create history 
	// records as part of Interest Change processing
 
	type public Boolean ER
	type public String RM

	type Number OLDRATE

	set OLDRATE = +ln.irn

	do EXTERN^BCHICHAN(.ln, %SystemDate)
	
	// RM is returned as an array from BCHICHAN - report only the first one
	if 'RM(1).get().isNull() set RM = RM(1)

	quit


private RUNINTOFF(RecordLN ln,		// Loan account		/REF:RW
		  Date %SystemDate)	// System date

	// Rate change offset date - calculate new rate, store in LNVRCHG

	// DAYEND process: Adjust Variable Interest Rate Loans
	do EXTERN^BCHVRCHG(.ln, 1)

	quit


private RUNLNSUB(RecordLN ln,		// Loan account		/REF:RW
		 Date %SystemDate)	// System date

	// Loan subsidy review processing

	do EXTERN^BCHSUBDE(.ln, %SystemDate)

	quit


private RUNPCHND(RecordLN ln,		// Loan account		/REF:RW
		 Date %SystemDate)	// System date

	// Payment change date
	
	do EXTERN^BCHPMTCG(.ln,%SystemDate)

	quit


private RUNPCOFF(RecordLN ln,		// Loan account			/REF:RW
		 Date %SystemDate)	// System date

	//Payment change offset date - calculate new payment

	// No balance
	quit:ln.bal = 0

	do EXTERN^PRCPMTCG(.ln, 1)

	quit


private RUNPMT(RecordLN ln,		// Loan account			/REF:RW
	       RecordTTX ttx,		// Transaction			/REF:R
	       Date %SystemDate)	// System date

	// Post loan payment

	type String ETC
	type Number POFFAMT, TAMT

	// Get information from PRODCTL
	type public Cache %CACHE()
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:ln.type")

	// First, satisfy fee amounts not appearing in payment file

	set TAMT = $$MCNB^LNCO3(.ln)
	if TAMT do RUNPMT1(.ln, .ttx, prodctl.crtrmi, TAMT, %SystemDate)

	// Second, satisfy regular payment due

	// Total Due
	set TAMT = ln.tdue
	if TAMT < 0 set TAMT = 0
	
	// Late Charge Due
	set TAMT = TAMT + ln.lchg
	
	set ETC = prodctl.crtrgp

	// Payoff logic
	if $$PAYOFF(.ln, TAMT) do {
		set POFFAMT = $$EXEC^LNTCP1(.ln,.ttx)
		if TAMT '< POFFAMT set TAMT = POFFAMT,ETC = prodctl.crtrci
		}

	// Account Maturity Date
	if ln.mdt, %SystemDate '< ln.mdt do {
		set TAMT = $$EXEC^LNTCP1(.ln, .ttx)
		set ETC = prodctl.crtrci
		}

	if TAMT do RUNPMT1(.ln, .ttx, ETC, TAMT, %SystemDate)

	quit


RUNPMT1(RecordLN ln,			// Loan account			/REF:RW
	RecordTTX ttx,			// Transaction			/REF:R
	String ETC,			// External transaction code
	Number TAMT,			// Transaction amount
	Date %SystemDate)		// System date

	// Create payment transactions
	
	type public Boolean ER
	type public String CTL
	type public Date CUVAR2
	
	type Number BRCD,CID
	
 	set CID = ln.cid
	set BRCD = ln.boo
	if BRCD.isNull() set BRCD = CUVAR.BOBR

	// Create and post secondary payment transaction
	do POST^LNTRB(.ttx, CID, ETC, TAMT, %SystemDate, %UserStation, , , ln.crcd)
	if ER set ER=0 quit

	// Offset with "Cash In" if "cash flow" processing is used
	if CTL.extract(2) do { if ER set ER = 0 quit

		set ETC="CI"
		type public Cache %CACHE()
		type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")
		do POST^LNTRB(.ttx, trn.acn, ETC, TAMT, %SystemDate, %UserStation, , ,ln.crcd) quit:ER
		}

	quit
 

private RUNPPI(RecordLN ln,		// Loan account			/REF:RW
	       RecordTTX ttx,		// Primary transaction		/REF:R
	       Date %SystemDate)	// System date

	// Post Prepaid (Odd) Interest
	
	type public Date CUVAR2
	type public Boolean ER
	type public Cache %CACHE()
		
	type Number BRCD,DISPPI
	type String ETC
	
	quit:%SystemDate '> CUVAR2

	if ln.ipl '< ln.disppi quit	

	// Disclosure - Prepaid Interest Amount
	set DISPPI = ln.disppi - ln.ipl

	// Branch of Ownership
	set BRCD = ln.boo
	if BRCD.isNull() set BRCD = CUVAR.BOBR

	// Create and post Preapaid (Odd Days) Interest transaction

	// Get information from PRODCTL
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:ln.type")

	// Create secondary CR Int/Div Tran Code transaction
	do POST^LNTRB(.ttx, ln.cid, prodctl.crtrin, DISPPI, %SystemDate, %UserStation, , , ln.crcd)
	if ER.get() set ER = 0 quit
 
	set ETC = "CI"
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")
	do POST^LNTRB(.ttx, trn.acn, ETC, DISPPI, %SystemDate, %UserStation, , , ln.crcd) quit:ER

	quit


private RUNSCHND(RecordLN ln,		// Loan account			/REF:RW
		 Date %SystemDate,	// System date
		 Date CUVAR2)		// Customer variable system date

	// Scheduled date roll
	
	type public Boolean ER
	
	// Generate transactions
	do EXTERN^BCHLNSCH(.ln) quit:ER

	quit


private LICHND(RecordLN ln,		// Loan account			/REF:RW
	       Date %SystemDate,	// System date
	       Date CUVAR2)		// Customer variable system date

	// Change interest rate and bump interest change dates on this 
	// projected system date - loans
	
	type public Boolean ER

	type Number BASE, RATE, RRATE, SRATE, URATE
	type String PAR()

	// Bump interest change dates
	if ln.ichnd = EVNTJD do {
		set ln.ichld = %SystemDate
		set ln.ichnd = ln.ichld.nextFreqDate(ln.intfre) quit:ER
		}
		
	// If Base is null, set to Credit Limit or Amount Requested
	
	// Adjusted Balance for Accrual Calculations
	set BASE = ln.balint
	// Credit Limit - Current
	if BASE.isNull() set BASE = ln.crlmt
	// Amount Requested
	if BASE.isNull() set BASE = ln.amtreq	

	// Rounding flag	
	set PAR("ROUND") = 1
	// Check for limits flag	
	set PAR("LIMIT") = 1
		
	do CTL^UINDX(.ln, %SystemDate, BASE, .PAR())

	if ER quit

	// Set the rate change in account history
	if (ln.irn - RATE) '= 0 do {

		type Number TSEQ

		/*
		 The LNPTSRV/LNUEFD flags are checked here to ensure a HIST
		 record isn't created more than once for the same rate change.
		 
		 This will create a HIST record for a projected rate change 
		 during backdated account openings. A HIST record for the same 
		 rate change shouldn't be created when the backdated disbursement 
		 is processed.
		 
		 Similarly, a non-backdated account will have a HIST record created 
		 for actual rate changes by normal dayend processing, so there is
		 no need to create another HIST record when backdating over a rate
		 change date.
		 
		 In the event of future-dated projected activity (e.g., loan payoff 
		 status report), it doesn't matter if HIST is updated with a future-
		 dated rate change since the DB updates will be rolled back at the 
		 end of the projection.
		*/
		if LNUEFD.get()!LNPTSRV.get() set ln.irn = RATE quit

		set TSEQ = Db.nextVal("HIST", "CID")
	
		type RecordHIST hist = Class.new("RecordHIST", "CID = :CID, TSEQ = :TSEQ")
	
		set hist.tjd = CUVAR2
		set hist.efd = %SystemDate
		set hist.tcmt = "[LN]IRN:"_ln.irn_":"_RATE
		set hist.time = %CurrentTime
		set hist.cdt = %CurrentDate
		if (%UserID.exists() <> 0) set hist.uid = %UserID
		else  set hist.uid="BATCH"

		do hist.bypassSave()
		
		set ln.irn = RATE
		}

	quit


private RUNDECAP(RecordLN ln,		// Loan account			/REF:RW
		 Date %SystemDate,	// System date
		 Date %EffectiveDate)	// Effective date

	// Processing for deferred interest capitalization
	
	type public Boolean ER
	type public Date CUVAR2
	
	// Generate transactions
	do EXTERN^BCHLNDIC(.ln, %EffectiveDate) quit:ER

	quit


private RUNICAP(RecordLN ln,		// Loan account			/REF:RW
		Date %EffectiveDate)	// Effective date

	// Processing for capitalized interest due
	
	type public Boolean ER
	type public Date CUVAR2
	
	// Generate transactions
	do EXTERN^BCHLNCAP(.ln, %EffectiveDate) quit:ER

	quit


private RUNDSBSCH(RecordLN ln,		// Loan account			/REF:R
	          Date %SystemDate,	// Projected Date
	          Date CUVAR2)		// System date set in UANTIC	

	// Post disbursement from disbursement schedule

	type public Number CTL
	
	// Do not post disbursements for effective dated transaction
	if 'CTL.get(), (%SystemDate < CUVAR2) quit

	type Number BRCD, CID

	set BRCD = CUVAR.BOBR
	set CID = ln.cid
	
	do EXEC^BCHLNDS(.ln)
	
	set ln=Db.getRecord("LN","CID=:CID")	
	
	quit
	

private RUNAUT(RecordLN ln,		// Loan account			/REF:RW
	       RecordTTX ttx,		// Primary ransaction record	/REF:R
	       Date %SystemDate,	// System date
	       Date CUVAR2)		// Customer variable system date
	
	// Automatic Loan Payment
	
	type public String CTL
	type public Boolean ER

	type Number CID
	type String EVNT

	if CTL '= "01", %SystemDate = CUVAR2, $$QUELOC^UANTIC("QUE079") = 1 quit

	// Do not reapply autopayments being reversed on this date
	if ttx.exists() & (ttx.itc6 + ttx.itc12) & (ttx.tso.isLike("%AUTPMT%")) & (%SystemDate = ttx.efd) quit
 
 	// Create and post transactions
	do EXEC^PROCAUTO(.ln)

	if ln.schld + ln.alprtyd = %SystemDate quit 

	set EVNT = "Auto Loan Payment Capitalization|RUNAUT"
	if ln.alprtyd, ln.cintbnp = 1 do SETQUE(.ln, "", (ln.schld + ln.alprtyd), 0, 0, EVNT) quit:ER

	quit


private RUNRTRN(RecordLN ln,		// Loan account			/REF:RW
		Date %SystemDate)	// System date

	// Return process
	
	type public Boolean ER
	type public Date CUVAR2

	// DAYEND process: Automatic Return 
	do EXTERN^BCHLNRTN(.ln, 0) quit:ER

	quit

 
private TEASER(RecordLN ln,	// Loan account		/REF:R
	       Date EVNTJD)	// Event date

	// Teaser rate expiration
	
	quit


private RUNEOM(RecordLN ln,		// Loan account			/REF:RW
	       Date %SystemDate)	// System date

	// Month end balances

	// Balance (Computed)
	type Number BALCMP, PC
	type String MEBAL
	
	set BALCMP = +ln.bal

	if ln.aruf set BALCMP = BALCMP - ln.udbal

	set PC = +%SystemDate.month()

	// Set Month End Balance
	set MEBAL = "MEBAL"_PC
	set ln.@MEBAL = BALCMP

	quit


private RUNIDGP(RecordLN ln,		// Loan account			/REF:RW
		Date EVNTJD)		// Event date
 
	// Recalculate balance for interest calculation in BOD after the 
	// expiration date

	type RecordLNDS1 lnds1 = Db.getRecord("LNDS1", "CID=:ln.cid,SDD=:EVNTJD")
	
	set ln.balint = ln.balint + lnds1.sda - lnds1.repymt

	quit


private RUNLCHG(RecordLN ln,		// Loan account			/REF:RW
		RecordTTX ttx,		// Primary transaction		/REF:R
		Date %SystemDate,	// System date
		Date %EffectiveDate,	// Effective date
		Date SAVEFD,		// Original effective date
		Number LCHGADJ)		// Late charge adjustment

	/*
	Late Charge Processing
	
	This section will take care of all one time late charges and
	apply them to the account. All of the daily charges will be 
	taken care of in the ACRCALC section.
	*/
	
	type public Boolean CTCH, ER, FUPO
	
	// Future dated payoff
	if FUPO.get(), (%EffectiveDate > SAVEFD) quit

	// Daily - already accruing... will be done in ACRCALC
	if ln.dlcaf = 1 quit	

	// Penalty option
	if ln.popt.isNull() quit

	type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:ln.oseq", 1)

	// Bill does not exist
	if lnbil1.getMode() = 0 quit

	// Bill is satisfied		
	if lnbil1.casd '> 0 quit

	type String LCHRG

	type RecordLNPOPT lnpopt = Db.getRecord("LNPOPT", "GRP=:ln.grp,POPT=:ln.popt")

	// Set up entry in LNLCNOT if LCHGNOTO=1
	if ln.lchgnoto do {
		type RecordLNLCNOT lnlcnot = Db.getRecord("LNLCNOT", "CID=:ln.cid,LCAD=:%SystemDate", 1)
		if lnlcnot.getMode() = 1 quit	// Already defined
		
		do lnlcnot.bypassSave()
		}

	// Calculate the late charge for this period
	set LCHRG = $$EXTERN^BCHLNLAT(.ln, .ttx, ln.cid, %SystemDate, %SystemDate) quit:ER

	if lnpopt.cdf do { quit
		// Late Charge Adjustment from UANTIC
		set LCHGADJ = LCHGADJ + LCHRG 
		// Daily Late Charge Assessment Flag	 
		set ln.dlcaf = lnpopt.cdf
		// Late Charges Calculation Flag 		
		set CTCH = 1 			
		}

	if LCHRG.piece("|", 1) do POSTADJ^LNPTS12(.ln, .ttx, LCHRG.piece("|", 1))

	quit


private RERUNHIST(RecordLN ln,		// Loan record			/REF:RW
		  RecordTTX ttx1(,,),	// Transaction set from history	/NOREQ/REF:R
		  Date %SystemDate,	// System date
		  Date CUVAR2)		// Current date

	/*
	Reprocess history records on their simulated effective date

	Additional notes on ARGUMENTS:

	. ttx1(,,)
		An array set in LNUEFD
		Contains previously-existing history entries that need
		to be examined and possibly overridden
	*/
	
	type public Boolean ER
        type public String OVR(,,)
	type Number CID, SEQ, TAMT
	
	set (CID, SEQ) = ""
	for  set CID = ttx1(%SystemDate, CID).order() quit:CID.isNull()  do { quit:ER
		for  set SEQ = ttx1(%SystemDate, CID, SEQ).order() quit:SEQ.isNull()  do { quit:ER
			set TAMT = ttx1(%SystemDate, CID, SEQ).tamt

			// Monetary transaction
			if $translate(TAMT, "0#") do { quit:ER
				type String ITC
				type Number DELQTYP

				set ITC = ttx1(%SystemDate, CID, SEQ).itc
				
				// Reverse or error correct
				if (ITC.extract(6)) ! (ITC.extract(12)) set DELQTYP = 12
				else  set DELQTYP = 5
				
				if ln.lchgnoto, %SystemDate < CUVAR2 do SETCUS(.ln, DELQTYP, %SystemDate, CUVAR2)

				// Create and post transaction
				do TRNSINGL^TRNDRV(.ttx1(%SystemDate, CID, SEQ), .ln, %SystemDate, ln.boo, 4, , , OVR(,,)) quit:ER
				}
			// File maintenance transaction
			else  do RERUNFM(.ln, .ttx1(%SystemDate, CID, SEQ))
			}
		}

	quit


private RERUNFM(RecordLN ln,		// Loan account			/REF:RW
		RecordTTX ttx1)		// Transaction from set		/REF:R

	/*
	Reapply file maintenance from HIST
	
	Additional notes on ARGUMENTS:
	. ttx1
		An array set in LNUEFD
		Contains previously-existing history entries that need
		to be examined and possibly overridden
	*/
	
	type public RecordDEP dep()
	type public String OVR(,,)
	type public Number CID

	type String DI, FID, FMREC, NV

	// Get table name and data item from TCMT - example [LN]RELCODE
	set FMREC = ttx1.tcmt.piece(":", 1)
	set FMREC = FMREC.piece("[", 2)

	if FMREC.isNull() quit

	set FMREC = "["_FMREC

	set FID = FMREC.piece("]", 1).extract(2, 99)
	set DI = FMREC.piece("]", 2, 99)
	
	// Translate all lower case alpha to UPPER CASE
	set FID = FID.upperCase()
	set DI = DI.upperCase()

	// "Intervening bill record maint. Verify billed records."
	if FID = "LNBIL1" ! (FID = "LNBIL0") ! (FID = "LNBIL5") set OVR(ln.cid, "OVR", "BILLFM") = "" quit
	
	// Check if the table exists
	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:FID", 1)
	if dbtbl1.getMode() = 0 quit
	
	if FID '= "LN", FID '= "ZLN", FID '= "DEP", FID '= "ZDEP", FID '= "ACN" quit

	// File new data into account, if DI exists
	type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=:FID,DI=:DI", 1)

	if dbtbl1d.getMode() = 0 quit

	// Get new value from the TMCT
	set FMREC = ttx1.tcmt.piece(":", 2, 3)
	set NV = FMREC.piece(":", 2)
		
	if FID = "LN" ! (FID = "ZLN") ! (FID = "ACN" & (CID = ln.cid)) do {

		// Update only non computed columns
		if dbtbl1d.cmp.isNull() set ln.@DI = NV
			
		/*
		Update balance for interest calculations when credit 
		limit is adjusted and Capitalized Deferred Interest 
		flag set to 1
		*/
	
		type RecordUTBLICPA icpa = Db.getRecord("UTBLICPA", "KEY=:ln.icpa")

		if DI = "CRLMT", icpa.pc10 do {
			if ln.bal < ln.crlmt set ln.balint = ln.bal
			else  set ln.balint = ln.crlmt
			}
		}
	else  if FID = "DEP" ! (FID = "ZDEP") !  (FID = "ACN" & (CID '= ln.cid)) do {

		// Update only non computed columns
		if dbtbl1d.cmp.isNull() set dep(CID).@DI = NV
		}

	quit


private SETQUE(RecordLN ln,	// Loan account				/REF:R
	       String FRE,	// Posting frequency of this event	/NOREQ
	       Date NJD,	// Projected date
	       Number OFF,	// Date offset
	       Boolean PLUS1,	// Plus 1
	       String EVNT)	// Event name

	// Set the processing queue
	
	type public Date CUVAR2, SAVEFD
	type public String CTL, QUEUE(,,)
	type public Boolean ER

	type Date EVNTJD
	type Number CID
	type String EVNTNAME

	if 'NJD quit

	set CID=ln.cid
	set EVNTJD = NJD - OFF + PLUS1
	if EVNTJD > SAVEFD quit

	// Single entry	
	if FRE.get().isNull() do SETEVENT(ln.cid, EVNT, EVNTJD, .QUEUE(,,)) quit
		
	set EVNTNAME = EVNT.piece("|", 2)

	// Special case for Interest Review Offset Calendar
	if EVNTNAME = "RUNINTOFF" do { quit
		for  quit:($$INTOFFDT^LNCDI(NJD, OFF, ln.intoffcl) + PLUS1) > %EffectiveDate  do {
			set EVNTJD = $$INTOFFDT^LNCDI(NJD, OFF, ln.intoffcl) + PLUS1
			do SETEVENT(ln.cid, EVNT, EVNTJD, .QUEUE(,,))
			set NJD = NJD.nextFreqDate(FRE) quit:ER
			}
		}

	// Special case for billing offset; offset="1P" (first full payment) 
	// and date to queue is the projected to date
	if EVNTNAME = "RUNBIL", OFF = "1P", NJD = %EffectiveDate do {
		do SETEVENT(ln.cid, EVNT, NJD, .QUEUE(,,))
		set OFF = 0
		}

	// Multiple entries
	for  quit:EVNTJD > %EffectiveDate  do { quit:ER
		do SETEVENT(ln.cid, EVNT, EVNTJD, .QUEUE(,,))
		set NJD = NJD.nextFreqDate(FRE) quit:ER
		set EVNTJD = NJD - OFF + PLUS1
		}

	quit


SETEVENT(Number CID,		// Account number
	 String EVNT,		// Event data
	 Date EVNTJD,		// Event date
	 String QUEUE(,,))	// Event queue				/REF:RW


	// Set a single event and an accompanying accrual event
	type Number PRVQSQ

	// Get previous non-acrual sequence
	set PRVQSQ = QUEUE(EVNTJD, CID, 9999).order(-1)

	// Set new entry in QUEUE(,,)
	set QUEUE(EVNTJD, CID, PRVQSQ + 1) = EVNT

	// Set accrual event for end of prior day
	if EVNTJD > %SystemDate, EVNTJD '> %EffectiveDate set QUEUE(EVNTJD - 1, CID, 9999) = "Calculate accruals"

	quit
        

private LNACR(RecordLN ln,		// Loan record			/REF:RW
	      RecordTTX ttx,		// Primary transaction		/REF:R
	      Date EVNTJD,		// Event date
	      Date ACRDT(),		// Accrual date			/REF:RW
	      Number ACRADJ(,))		// Accrual adjustment		/REF:RW

	// Calculate accrued interest from ACRDT+1 through EVNTJD
	
	type public Boolean BASREL(), DAILYFRE(,), ER
	type public Date CUVAR2
	type public String ITC

	type Date ACRLD, ACRND
	type Number ACRAMT, IRN
	
	set ACRLD = ACRDT(ln.cid) + 1
	set (ACRND, ACRDT(ln.cid)) = EVNTJD 
	if ACRND < ACRLD set ACRLD = ACRND
	
	/*
	If BASREL (not basis index) check for interest rate change. If daily 
	freq, bump the interest change dates, skipping dates within the accrual
	period
        */
	if 'ln.index.isNull() do {
		// BASREL array won't exist if EFD=CUVAR2
		if BASREL(ln.index) do LICHND(.ln, ACRLD, CUVAR2)

		if DAILYFRE(ln.cid, 0) do {
			set ln.ichnd = ACRND + 1
			set ln.ichld = ACRND
			}
		}
	
	// Int/Div Calc Period Frequency
	set IRN = ln.irn

	// Teaser Rate
	if ln.trexd > EVNTJD set IRN = ln.trate

	// Consider minimum balance to accrue
	if 'ln.minacr.isNull(), (ln.balint < ln.minacr) do {
 		if (ln.minopt <> 0) set ACRAMT = 0		// Keep accrual
		else  set ACRAMT = -ln.acr			// Zero accrual
                }
	else  if ln.balint set ACRAMT = $$^UIC(ln.balint, ACRLD, ACRND, ln.iacm, IRN, 0, ln.dist1af, ln.dist1fre, ln.icpf, ln.schnd, ln.schld) quit:ER
	else  set ACRAMT = 0
	
	set ACRAMT = ACRAMT.roundDec(5)
	
	set ACRADJ(ln.cid, "ACR") = ACRADJ(ln.cid, "ACR") + ACRAMT
	set ln.acr = ln.acr + ACRAMT
	
	// Uncomment for trouble-shooting statistics (do not remove)
	//write !,"Re/apply LN "_ln.cid_": LNACR Accrue "_ln.balint_" at "_IRN_"% "_ACRLD.toString()_"-"_ACRND.toString()_" = "_ACRAMT
	//write !,$char(9)_"(ln.acr = "_ln.acr_")"

	//This is not Daily or already calculated
	if ln.dlcaf '= 1 quit 		

	type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:ln.oseq", 1)
	
	 
        // If no longer delinquent, reset DLCAF to 0 and quit
	if lnbil1.getMode() = 0 set ln.dlcaf = 0 quit
	if lnbil1.cdpd '> 0 set ln.dlcaf = 0 quit

	// Do not calculate late charges when error correcting a transaction
	if ITC.get().extract(6) & (CUVAR2 = EVNTJD) quit

	do DLYLATE(.ln, .ttx, ACRLD, EVNTJD)

	quit


DLYLATE(RecordLN ln,		// Loan account			/REF:RW
	RecordTTX ttx,		// Primary transaction		/REF:R
	Date FD,		// From date
	Date %SystemDate)	// Thru date

	// Late Charges - Daily
	
	type public Boolean CTCH, ER
	type public Number LCHGADJ

	type Number CID, LCHRG
	type Date TD, TPD

	/*
	If CTCH=1, then we have already calculated the late charge in
	RUNLCHG for today
	*/
	if CTCH.get() = 1 set CTCH = 0 quit

	set (TD, TPD) = %SystemDate

	set LCHRG = $$EXTERN^BCHLNLAT(.ln, .ttx, ln.cid, TD, FD) quit:ER

	set LCHGADJ = LCHGADJ + LCHRG

	quit


public	PAYOFF(RecordLN ln,		// Loan account			/REF:R
	       Number TAMT)		// Transaction amount		/NOREQ

	// Is this loan nearing payoff ?

	type Number BALCMP, POAMT, PMTAMT
	
	// Scheduled Internal Bill Sequence Number
	if 'ln.schseq quit ""
	if ln.dseq < ln.schseq quit ""

	set BALCMP = +ln.bal
	if ln.aruf set BALCMP = BALCMP - ln.udbal
		
	type RecordLNBIL1 bil = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:ln.schseq", 1)
	if bil.getMode() = 0 quit ""

	// balloon amount
	if ln.ballamt set BALCMP = BALCMP - ln.ballamt  	
	if 'TAMT.get().isNull() set PMTAMT = TAMT
	else  set PMTAMT = bil.casd

	set PMTAMT = PMTAMT * 2
	if PMTAMT > (BALCMP + ln.acr) quit 1

	// Number of Times Renewed

	// Total Principal Only Payments
	set POAMT = ln.poamt	

	// Total Disbursement Amount
	if POAMT, ln.tdr, (POAMT / ln.tdr) > .20 quit 1

	quit "" 


private ACRADJ(RecordLN ln,		// Loan account			/REF:RW
	       RecordTTX ttx,		// Pimary transaction		/NOREQ/REF:R
	       Number ACRADJ(,),	// Accrual adjustment		/REF:R
	       Date CUVAR2,		// Current date
	       Number LCHGADJ,		// Late charge adjustment	/NOREQ
	       RecordDEP dep())		// Escrow accounts		/NOREQ/REF:RW

	// Create transactions for accrual adjustment
	
	type public String CTL
	type public Boolean ER
	
	type Date ACRDT()
	type Number ACRTYPE, ESCCID, GLCID, OFFSET, TAMT
	type String CRCD, ETC, GLSC, TC

	/*
	Account projection functions have position 2 set (generate cash 
	offsets)... do not show interest accrual adjustments in this case
	*/
	if CTL.extract(2) quit

	set ACRADJ(ln.cid, "ACR") = ACRADJ(ln.cid, "ACR").roundCur(ln.crcd)

	set ln.acr = ln.acr - ACRADJ(ln.cid, "ACR")

	/*
	Determine if this is an add-on/discount loan.  If it is, then in
	primary sequence entry of TR array, retrieve EFD if it is there,
	else system date. If this date (ttx.efd) is prior to or on the
	month-end accrual adjustment last date, then month-end accrual 
	adjustment process has to be re-executed, by calling section 
	ACCRUAL.
	*/
	if ln.iam, ttx.exists() do {
		if 'ttx.efd set ACRDT(ln.cid) = ttx.tjd
		if ttx.efd '> CUVAR.AALD do ACCRUAL(.ln, CUVAR2, .ACRADJ(,))
		}
			
	/*	
	If this is not an add-on/discount loan, adjust ACR by subtracting out 
	ACRADJ(,) (accrual adjustment)
	*/
	if ACRADJ(ln.cid, "ACR") do {
		type public Cache %CACHE()
		
		set CRCD = ln.crcd 
		if CRCD.isNull() set CRCD = %SystemCurrency		
	
		// Get information from PRODCTL
		type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:ln.type")

		if ACRADJ(ln.cid, "ACR") < 0 do {
			set ETC = prodctl.cradin
			set TAMT = -ACRADJ(ln.cid, "ACR")
			}
		else  do {
			set ETC = prodctl.dradin
			set TAMT = ACRADJ(ln.cid, "ACR")
			}

		do POST^LNTRB(.ttx, ln.cid, ETC, TAMT, CUVAR2, %UserStation, "SYS#~SGAA#1", , CRCD) quit:ER

		/*
		Offset should always be MDR if the transaction is a credit,
		and MCR for a debit - even for CBLs and DBDs.
		*/
		type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")

		if trn.itc.extract(1) = 1 set OFFSET = "MDR"
		else  set OFFSET = "MCR"

		type RecordUTBLGLSC utblglsc = Db.getRecord("UTBLGLSC", "GLSC=:ln.glsc")

		// Post offset to Loan G/L # (Interest Income)
		do POST^LNTRB(.ttx, utblglsc.lgli, OFFSET, TAMT, CUVAR2, %UserStation, "SGAA#1", , CRCD, ln.cc) quit:ER
		}

	if 'ln.popt.isNull() do LATE2(.ln, .ttx, CUVAR2, LCHGADJ)
	
	// Create accrual adjustments for related escrow accounts if necessary
	set ESCCID = ""
	for  set ESCCID = ACRADJ(ESCCID).order() quit:ESCCID.isNull()  do { quit:ER
		set ACRTYPE = ""
		for  set ACRTYPE = ACRADJ(ESCCID, ACRTYPE).order() quit:ACRTYPE.isNull()  do { quit:ER
			if ESCCID = ln.cid quit
			set TAMT = +ACRADJ(ESCCID, ACRTYPE)
			do ESCADJ^UANTICDP(.ttx, .ln, .dep(), ESCCID, CUVAR2, ACRTYPE, TAMT) quit:ER
			}
		}
	
	quit
	

LATE2(RecordLN ln,		// Loan account			/REF:RW
      RecordTTX ttx,		// Primary transaction		/REF:R
      Date CUVAR2,		// Customer variable system date
      Number LCHGADJ)		// Late charge adjustment amount

	// Late charge adjustment
	
	type public String CTL

	type Boolean DLCAF
	type Date LCDEJD

	type RecordLNPOPT lnpopt = Db.getRecord("LNPOPT", "GRP=:ln.grp,POPT=:ln.popt")

	// Daily Late Charge Assessment Flag
	set DLCAF = ln.dlcaf	

	if ln.dlcaf set LCDEJD = %SystemDate
	// Late Charge Action Date
	else  set LCDEJD = ln.lcad

	if 'LCDEJD.isNull() do {
		// Set up LCHG dayend entry
		type RecordDAYENDLCHG delchg = Db.getRecord("DAYENDLCHG", "TJD=:LCDEJD,CID=:ln.cid", 1)
		if delchg.getMode() = 1 quit

		if CTL.extract(1), LCHGADJ do {
			set delchg.lchg = ""
			set delchg.lcefd = ln.dist1nd
			}
		
		do delchg.bypassSave()
		}

	// Quit if not daily
	if lnpopt.cdf '= 1 quit

	set LCHGADJ = LCHGADJ.roundCur(ln.crcd)
	if LCHGADJ do POSTADJ^LNPTS12(.ln, .ttx, LCHGADJ)
	if DLCAF set ln.lcla = CUVAR2 - 1

	quit


ACCRUAL(RecordLN ln,		// Loan account			/REF:RW
	Date %SystemDate,	// System date
	Number ACRADJ(,))	// Accrual adjustment amount	/REF:W
	
	/*
	Restate accrual for pre-calculated interest

	This will re-calculate the month-end accrual adjustment for
	add-on/discount loans by calling OL^LNACR3. LNACR3 table
	will be updated with the accrual adjustment information, just
	as it is when QUE011 (month-end accrual adjustment process)
	runs during dayends. Report SCA010 displays this information.
	*/
	
	type public Boolean ER
	
	type Boolean %PLDF
	
	// Not an add-on/discount loan
	if 'ln.iam quit
	
	set %PLDF = 0

	type RecordLNACR3 lnacr3 = Db.getRecord("LNACR3", "EFD=:%SystemDate,GRP=:ln.grp,TYPE=:ln.type,CID=:ln.cid", 1)

	do OL^LNACR3(.ln, .lnacr3) quit:ER

	do lnacr3.bypassSave()

	set ACRADJ(ln.cid, "ACR") = lnacr3.adj.roundCur(ln.crcd)

	quit


public	RENEW(RecordLN ln)	// Loan account			/REF:R

	/*
	Returns conversion date if renewal option sequence is null

	RETURNS:
           . $$  Conversion Date			/TYP=N/REQ/MECH=VAL

	*/

	if ln.cnvdt.isNull() quit 0

	type ResultSet rs = Db.select("ROSEQ", "LNRENEW", "CID=:ln.cid AND CNVAPP=1")

	if rs.next(), (%EffectiveDate > ln.cnvdt) quit ln.cnvdt

	quit 0
	
	
LNINDEX(RecordLN ln)		// Loan account			/REF:R

	// Set up all queues associated with Loan interest rate change 
	// processing
	
	type public Boolean DAILYFRE(,), ER
	
	type String EVNT
	type Number AF
	type Date JD

	if 'ln.intoff.isNull() do {
		set EVNT = "Interest Offset Processing|RUNINTOFF"

		/*
		If interest offset processing and daily frequency, queue 
		interest offset processing event as often as payment changes 
		(INTFRE^UANTIC will also be queued for entries in INDEX0 table 
		for daily frequencies)... for non-daily frequencies, 
		INTFRE^UANTIC will handle RUNICHND events
		*/
		set JD = %SystemDate.nextFreqDate(ln.intfre, .AF) quit:ER
		if AF > 360 do { quit:ER

			if ln.pcoff do SETQUE(.ln, ln.pcfre, ln.pchnd, ln.pcoff, 0, EVNT) quit:ER

			/*
			If interest offset different from payment offset, then 
			also set for the days corresponding to interest offset
			*/
			if ln.intoff '= ln.pcoff do SETQUE(.ln, ln.pcfre, ln.pchnd, ln.intoff, 0, EVNT) quit:ER
			}
		else  do SETQUE(.ln, ln.intfre, ln.ichnd, ln.intoff, 0, EVNT) quit:ER

		// RUNICHND events must be scheduled after RUNINTOFF events 
		// b/c RUNICHND relies on LNVRCHG records created by RUNINTOFF
		set EVNT = "Interest Change Date (offset)|RUNICHND"
		}
	else  set EVNT = "Interest Change (no offset)|LICHND"
	
	do INTFRE^UANTIC(.ln, ln.index, ln.intfre, ln.ichnd, EVNT, 0) quit:ER

	quit
	

vSIG()	quit "60614^20921^Sunitha Santhumayor^61361"	// Signature - LTD^TIME^USER^SIZE
