TTXOFST()
 	/*
 	 PROCEDURE ID:	TTXOFST
 	     Original:	Frank R. Sanchez
		 Date:	12/10/87
 	         Desc:	Generate cash balancing offsets
 
 	---- Comments ---------------------------------------------------------
 
	Library:
		. BALANCE	Check if the ttx() array is already balanced by
				currency.
		. $$BCRCD	Return the transaction's base currency
		. BLDTR		Build TTX record layout from local variables
		. $$CRCD	Returns the transaction's currency code
		. GMCOFF	General Ledger Cash offset transactions for 
				non-base currency
		. $$SBASE	Calculate the system base equivalent amount for
				the current transaction

 	---- Revision History -------------------------------------------------
 	
 	07/20/06 - DESHPANDE SK - CR20748
 		   Replaced Transaction Variable with Transaction Stored Value.
 	
 	05/15/06 - RussellDS - CR21296
 		   Corrected use of %CACHE to include table name.
 		   
 		   Cleaned up code related to PSL warnings.

	03/31/06 - KumarSS - CR 20190
		   Modified EMU secton to build "Euro balancing entry for 
		   the euro equiv. amount" correctly.

	03/20/06 - KELLYP - CR 20228
		   Modified BLDTR section to set ttx.brcd.  This ensures that
		   the branch code will be set into dtx.brcd by FILEDMJ^TRNDRV.

	03/07/06 - KinI - CR 19882
		   Modified BLDTR section to set ttx.tim that is needed in 
		   FILEDMJ^TRNDRV for copying to DMJ file where CTIM column
		   is required.

	12/13/05 - KinI - CR16664
		   Modified BALANCE, EXCB and EXCBSU sections to resolve the
		   problems during exchange-oriented transactions.

	12/08/05 - KELLYP - CR 17423
		   Removed the OPT and MEMO parameters for the GMCOFF section
		   and removed references to these two variables throughout the
		   procedure.  These two variables were only used for Trade 
		   Finance purposes, and all TFS elements are being obsoleted
		   from the system.  Also removed pre-2003 revision history.

 	08/04/05 - Srinivasan Rajesh - 16726
 		   Modified the section TTSBE that sets TTX.SYSBASE should
 		   plus the ttx.amt to return a numeric value since ttx.amt is
 		   complex text field.
 		    		    
	01/07/05 - JERUCHIMC - 13609
	           Modify code for Database independance project.

	12/29/03 - CARROLLJ - CR7658
		   Corrected parameter mismatch errors.

	07/29/03 - Erik Scheetz - 51349
		   General bug fixes (mostly undefined errors) in sections
		   GMCOFF, EXCB and EXCBSU that were found in unit testing.  
		   Also removed some documentation from the top as it is 
		   nolonger called since the removal of character teller screen.

	02/07/03 - ANTONOVV - 51351
		After conversion clean up.
	*/

	quit
	
public SBASE(RecordTTX ttx(),SEQ,AMT,CRCD,CRCDBASE)
	/* Calculate the system base equivalent amount for the current 
	transaction

	Arguments:
		. ttx()		Transaction array	/TYP=RecordTTX/REQ
		. SEQ		Current trn sequence	/TYP=N/REQ/MECH=VAL
		. AMT		Transaction amount	/TYP=N/REQ/MECH=VAL
		. CRCD		Currency code		/TYP=T/REQ/MECH=VAL
		. CRCDBASE 	Screen base currency	/TYP=T/REQ/MECH=VAL

	Inputs:
		. CCODE		Customer Code		/TYP=T
		. TTSBE		Screen rate code flg	/TYP=L 
		
	Returns: 
		. SYSBASE	System base equivalent	/TYP=N

	*/
	type public String CCODE
	type public String TTSBE
	
	type Number EXCAMT
	
	type String BSECSH
	type Number CSHSEQ
	type String CRFLG
	type String ETC
	type String SECCURFL

	if CRCD=%SystemCurrency quit AMT

	type Public Cache %CACHE()

	set ETC=ttx(SEQ).etc
	set CRFLG=ttx(SEQ).itc1

	if CRFLG="",ETC="" quit AMT

	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")
	
	//Check allocation
	if trn.trntyp=3 set CRFLG='CRFLG

	set EXCAMT=0
	if CCODE.get()="",TTSBE.get()="" do {
		// Customer Code
		set CCODE=ttx(SEQ).custcd quit:CCODE'=""
		set CCODE=$$CCODE^CRT3MC(.ttx())
		}

	set CSHSEQ=""
	set BSECSH=""
	for  set CSHSEQ=$O(ttx(CSHSEQ)) quit:CSHSEQ=""!BSECSH  do {
		new CSHETC

		if ttx(CSHSEQ).crcd'=CRCDBASE quit

		set CSHETC=ttx(CSHSEQ).etc
		type RecordTRN cshtrn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")
		
		// If cash transaction
		if cshtrn.trntyp=1 set BSECSH=1
		}

	// Secondary currency cash flag
	set SECCURFL=BSECSH_(trn.trntyp=1)
	do EXC^CRCDUTL(%SystemCurrency,CRCD,AMT,0,'CRFLG,SECCURFL,CCODE,%EffectiveDate,1)

	quit $$^SCARND(EXCAMT,0,"",%SystemCurrency)


public GMCOFF(RecordTTX ttx())
	/* 
	 General Ledger Cash offset transactions for non-base currency

	ARGUMENTS:
		. ttx()	Transaction array	/TYP=RecordTTX/REQ
	*/

	type Number AMT
	type Number BAL
	type Number BAMT
	type Number CHKTYP
	type Number CID
	type Number MAXRATE
	type Number MINRATE
	type Number MULTIPLY
	type Number OCC
	type Number RATE
	type Number SEQ
	type Number TSAMT
	type Number VARIANCE
	
	type String CACR()
	type String CCODE
	type String DACR()
	type String DTSO
	type String ITC
	type String ETC
	type String MSD			
	type String PBK
	type String SPR
	type String TCMT
	type String TRNCODES
	type String TSO
	
	type Date VDT
		
	// Offset trancode list
	set TRNCODES="|"_CUVAR.CEDR_"|"_CUVAR.CECR

	set BAL=$$BALANCE(.ttx())

	if 'BAL do {
		/* Loop through the ttx array and determine if we've got a
		situation in which one currency is foreign & one is the
		system base */
		new SEQ,FX

		set SEQ=""
		set FX=0
		for  set SEQ=$O(ttx(SEQ)) quit:SEQ=""  do { quit:FX>1
			// Exchange Rate
			if ttx(SEQ).rate'=1 set RATE=ttx(SEQ).rate
			// Currency Code
			if ttx(SEQ).crcd'=%SystemCurrency,ttx(SEQ).crcd'="" set FX=FX+1
			}

		do TTSBE(.ttx())

		do EXCB(.ttx())

		// Position offsets
		do BLDTSO(.ttx())
		do BLCTSO(.ttx())
		}

	else  do {
		/* Call into TTSBE even if in balance because
		PFW trans not getting HIST.SYSBASE set. */

		do TTSBE(.ttx())
		}
	quit


public BALANCE(RecordTTX ttx())
	/* Check if the ttx() array is already balanced by currency.  If all
	currencies contained in the ttx() array balance to 0, don't
	create any position offsets.

	Arguments:
		. ttx()	Array of transactions	/TYP=RecordTTX/NOREQ

	Inputs:
		. %EMUCRCD
	*/

	type Public Cache %CACHE()
	type public String %EMUCRCD
	type public String OUTFLG
	type public String CO
	
	type String CRCD
	type String NET()
	type String CRCDBASE
	
	
	type Number BTRNMOD
	type Number BAL
	type Number BALFLG
	type Number SEQ
	
	set SEQ=$O(ttx("")) quit:SEQ=""

	set CRCDBASE=ttx(SEQ).bcrcd
	if CRCDBASE="" set CRCDBASE=ttx(SEQ).crcd
	if CRCDBASE="" set CRCDBASE=%SystemCurrency

	set BALFLG=0
	set CO=$S(CO.exists():CO,%CompanyName.exists():%CompanyName,1:CUVAR.CO)

	set SEQ=""
	for  set SEQ=$O(ttx(SEQ)) quit:SEQ=""  do {
		type String AMT
		type Number AMT1
		type Number AMT2
		type Number AMT3
		type Number AMT6
		type Number AMT7
		type Number AMT11
		type Number AMT18
		
		if (ttx(SEQ).itc).extract()="" quit

		/* Handle all trans with escrow.  Piece 7 is escrow suspense.
		Piece 2 is principal.  Piece 3 is interest.  In a single
		currency or a multi-currency environment, prevents EXCH*
		trans from being generated in order to balance out screen.
		Exchange trans should never be generated for escrow. */

		set AMT=ttx(SEQ).tamt
		set AMT1=$P(AMT,"#",1)
		set AMT2=$P(AMT,"#",2)
		set AMT3=$P(AMT,"#",3)
		set AMT6=$P(AMT,"#",6)
		set AMT7=$P(AMT,"#",7)
		set AMT11=$P(AMT,"#",11)
		set AMT18=$P(AMT,"#",18)

		if (+AMT=AMT7)&((AMT7=AMT2)!(AMT7=AMT3)!(AMT7=AMT6)!(AMT7=AMT11)!(AMT7=AMT18)) quit

		set CRCD=$$CRCD(.ttx(SEQ))
		set NET(CRCD)=$G(NET(CRCD))+$S((ttx(SEQ).itc).extract():AMT,1:-AMT)

		type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
		if CRCD'=%EMUCRCD,crcd.emu'=1 set OUTFLG=1

		set BTRNMOD = ttx(SEQ).getStoredValue("TranMode")
		
		if CRCDBASE=CRCD quit
		set BALFLG=1
		}

	if ($G(BTRNMOD)=0!($G(BTRNMOD)=4)),BALFLG=0 quit 1
	set CRCD=""
	set BAL=1
	for  set CRCD=$O(NET(CRCD)) quit:CRCD=""!'BAL  if +NET(CRCD) set BAL=0

	quit BAL

public BCRCD(RecordTTX ttx)
	/* Return the transaction's base currency
	Arguments:
		. ttx	Transaction	/TYP=RecordTTX/REQ

	Returns:
		. $$	Transaction's base currency	/TYP=T
	*/

	quit $S(ttx.bcrcd="":$$CRCD(.ttx),1:ttx.bcrcd)


public CRCD(RecordTTX ttx)
	/* Return the transaction's currency code
	Arguments:
		. ttx	Transaction	/TYP=RecordTTX/REQ
	
	Returns:
		. $$	Transaction's currency code	/TYP=T
	*/

	quit $S(ttx.crcd="":%SystemCurrency,1:ttx.crcd) 


public BLDTR(RecordTTX ttx(),SEQ)
	/* Build TTX record layout from local variables

	Arguments:
		. ttx()		Transaction array	/TYP=RecordTTX/REQ
		. SEQ		Currently processed transaction sequence	
							/TYP=N/REQ/MECH=VAL
	
	Inputs:
		. AMT		Transaction Amount		TYP=T/REQ
		. BAMT		Base Amount (Currency Exchange)	TYP=$/NOREQ
		. BRCD		Branch Code			TYP=N/REQ
		. CID		Account Number			TYP=N/REQ
		. CHKTYP	Reg CC Check Type (Checks Rec'd)TYP=N/NOREQ
		. CCODE		Customer Code			TYP=T/NOREQ
		. CRCD		Currency Code			TYP=T/REQ
		. CRCDBASE	Base Currency			TYP=T/REQ
		. EC		Error-Correct Data		TYP=T/NOREQ
		. %EFD		Effective date			TYP=D/REQ
		. ETC		External Transaction Code	TYP=T/REQ
		. ITC		Internal Transaction Code	TYP=T/REQ
		. ITS
		. %MCP		Multicurrency processing flag
		. MSD		Miscellaneous screen data	TYP=T/NOREQ
		. MULTIPLY	Multiply/divide indicator	TYP=N/NOREQ
		. NBK()		No-book indicator array		TYP=L/NOREQ/W
		. OCC		Cost center			TYP=N/NOREQ
		. PBK						TYP=T/NOREQ
		. RATE		Exchange rate			TYP=N/NOREQ
		. SEQ		Trn seq number in the array	TYP=N/
		. SPR		Spray number			TYP=N/NOREQ
		. SYSBASE	System base currency equivalent TYP=$/NOREQ
		. TCMT		Transaction comment		TYP=T/NOREQ
		. TSAMT		System base currency equivalent TYP=$/REQ
		. TSO()		Transaction source of funds	TYP=T/NOREQ
		. VDT		Value date			TYP=D/NOREQ
	*/

	type public Date %EFD
	type public Date EFD
	type public Date VDT
	
	type public String CRCD	
	type public String CCODE
	type public String CRCDBASE
	
	type public String EC
	type public String ETC
	type public String ITC
	type public String ITS
	type public String MSD
	type public String %MCP
	type public String NBK()
	type public String PBK
	type public String SYSBASE
	type public String TCMT
	type public String TSO()
	
	type public Number AMT
	type public Number BAMT
	type public Number BRCD
	type public Number CHKTYP
	type public Number CID
	type public Number MULTIPLY
	type public Number OCC
	type public Number RATE
	type public Number TRESAMT
	type public Number TSAMT
	type public Number SPR	
	
	type Date EFDATE
			
	if 'ttx(SEQ).exists() set ttx(SEQ)=Class.new("RecordTTX")
	
	// Define TSO
	if $D(TSO)=0 set TSO=ttx(SEQ\1).tso
	// Build TSO
	if $D(TSO)=11 do IN^UTSO(.TSO, TSO)

	set OCC=OCC.get()
	set SPR=SPR.get()
	set TSO=TSO.get()
	set VDT=VDT.get()
	set TCMT=TCMT.get()
	set TSAMT=TSAMT.get()
	set RATE=RATE.get()

	set EFDATE=""
	if %EffectiveDate'=%SystemDate set EFDATE=%EffectiveDate
	if %EffectiveDate="",%EFD'="" set EFD=%EFD
	// No book trans
	if ETC.extract()="`" set ETC=ETC.extract(2,99)

	set ttx(SEQ).tjd=%SystemDate
	set ttx(SEQ).tim=%CurrentTime 
	set ttx(SEQ).uid=%UserID
 
	set ttx(SEQ).cid=CID
	set ttx(SEQ).itc=ITC
	set ttx(SEQ).etc=ETC
	set ttx(SEQ).tamt=AMT
	set ttx(SEQ).efd=EFD
	set ttx(SEQ).tlo=%UserStation
	set ttx(SEQ).tso=TSO
	set ttx(SEQ).tcmt=TCMT
	set ttx(SEQ).brcd=BRCD

	if SPR'="" set ttx(SEQ).spr=SPR

	if ITC.extract(6)!(ITC.extract(12)) set ttx(SEQ).lnerc=EC.get()

	if ttx(SEQ).mult'="",RATE'="" set ttx(SEQ).rate=RATE
	if VDT'="" set ttx(SEQ).vdt=VDT
	if OCC'="" set ttx(SEQ).cc=OCC
	// CC from FXV
	if ITS.exists() set ttx(SEQ).cc=ttx(1).cc

	if $$TRNTYP^TTXEXT(ETC)=2 set ttx(SEQ).chktyp=CHKTYP.get()

	if MSD.get()'="" set ttx(SEQ).msd=MSD

	if TSAMT'="" set ttx(SEQ).sysbase=TSAMT

	if %MCP do {
		set BAMT=BAMT.get()
		set TRESAMT(CRCD)=TRESAMT(CRCD).get()+BAMT
		set ttx(SEQ).crcd=CRCD
		// Base Amount
		set ttx(SEQ).bseamt=BAMT
		// Customer Code
		set ttx(SEQ).custcd=CCODE.get()
		// System base equivalent
		if $G(SYSBASE) set ttx(SEQ).sysbase=SYSBASE
		// Save screen base curr
		set ttx(SEQ).bcrcd=CRCDBASE
		// Check hold tran
		if CRCD=CRCDBASE quit
		// Exchange Rate
		set ttx(SEQ).rate=RATE
		// Multiply/Divide flag
		set ttx(SEQ).mult=MULTIPLY.get()
		}

	// Add No-book indicator
	if 'PBK.get() set NBK(SEQ)=""
	// Delete ...
	else  kill NBK(SEQ)
	kill SYSBASE

	quit


BLDTSO(RecordTTX ttx())
	/* Rebuild TSO to incude TCUR

	This is called from the top after the call to GMCOFF which is where
	the source currencies and amounts are identified and stored in the
	DTSO array.  Based upon the values in the DTSO array, the new tsotype
	TCUR is set and the customer account credit transactions are updated
	with the new TSO.
	*/
	type String TCUR
	type String CRCD
	type public String CACR()
	type public String DTSO
	type public String DACR()
	
	set (TCUR, CRCD) = ""
	type String I
	set I=$O(CACR(""))
	quit:I=""

	if $O(CACR(I))="" for  set CRCD=$O(DTSO(CRCD)) quit:CRCD=""  set TCUR=TCUR_"^"_DTSO(CRCD)_CRCD
	else  for  set CRCD=$O(DTSO(CRCD)) quit:CRCD=""  set TCUR=$G(TCUR)_"^"_CRCD

	set:$G(TCUR).extract()="^" TCUR=$G(TCUR).extract(2,$L(TCUR))

	set I=""
	for  set I=$O(CACR(I)) quit:I=""  do {
		new ATSO,TSO
		
		set TSO=CACR(I)

		do OUT^UTSO(.ATSO,TSO)
		set:$G(TCUR)'="" ATSO("TCUR")=TCUR

		do IN^UTSO(.ATSO,.TSO)
		set ttx(I).tso=TSO
		}

	quit


BLCTSO(RecordTTX ttx())
	/* Rebuild TSO to incude TCUR

	This is called from the top after the call to GMCOFF which is where
	the source currencies and amounts are identified and stored in the
	CTSO array.  Based upon the values in the CTSO array, the new tsotype
	TCUR is set and the customer account debit transactions are updated
	with the new TSO.
	*/

	type public String DACR
	type public String CTSO
	type String CRCD
	type String I
	
	type String TSO
	type String TCUR
	set (I,CRCD,TCUR)=""
	for  set I=$O(DACR(I)) quit:I=""  do {
		new ATSO
		
		if DACR(I)'="" do {
			set CRCD=$O(CTSO(CRCD))
			set TCUR="^"_$G(CTSO(CRCD))_CRCD
			set:$G(TCUR).extract()="^" TCUR=$G(TCUR).extract(2,$L(TCUR))
			}

		set TSO=DACR(I)
		do OUT^UTSO(.ATSO,TSO)
		set:TCUR'="" ATSO("TCUR")=TCUR
		do IN^UTSO(.ATSO,.TSO)
		set ttx(I).tso=TSO
		}
	quit

 

 

EXCB(RecordTTX ttx())
	/* Accumulate the amounts in the screen base.

	This will be used for generating the base equiv offsets with respect 
	to the currency of the transaction.
	*/

	new AMT,BASE,CCODE,CO,ITC,MULTIPLY,RATE,SYSBASE,SEQ,TROUT

	type public String %MCP
	type public String %EMUCRCD
	type public String CTSO
	type public String DTSO
	type public String CACR()
	type public String DACR()
	type public String TRNCODES
	
	type public Number NEWSEQ
	
	type String CRCD
	
	
	kill CTSO,DTSO,CACR,DACR

	type public Cache %CACHE()

	set BASE=1
	set TROUT=0
	set CO=CUVAR.CO

	// Loop through TR searching for non 'IN' currency transactions
	set SEQ=""
	for  set SEQ=$O(ttx(SEQ)) quit:SEQ=""  do {

		set CRCD=$$CRCD(.ttx(SEQ))
	
		type Public Cache %CACHE()
		type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")

		if '(crcd.emu!(CRCD=%EMUCRCD)) set TROUT=1
		}

	set SEQ=""
	for  set SEQ=$O(ttx(SEQ),-1) quit:SEQ=""  do {
		new DC,ETC,RATE,TSEQ

		kill SYSBASE

		if ttx(SEQ).itc="" quit
		set DC=(ttx(SEQ).itc).extract()

		// Quit if no amount
		set AMT=+ttx(SEQ).tamt
		if AMT=0 quit

		set CRCD=$$CRCD(.ttx(SEQ))

		// Set exchange rate
		set RATE=ttx(SEQ).rate
		set CCODE=ttx(SEQ).custcd
		set ETC=$P(TRNCODES,"|",$S(DC:2,1:3))

		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC")
		set ITC=trn.itc

		// Euro compliance
		if %MCP do {
			new CID

			quit:ttx(SEQ).cid=""

			set CID=ttx(SEQ).cid
			if (Db.isDefined("ACN","CID")&('Db.isDefined("GLAD","CID"))) do {
				if DC set CACR(SEQ)=ttx(SEQ).tso quit
				set DACR(SEQ)=ttx(SEQ).tso
				}
			if 'DC set DTSO(CRCD)=$G(DTSO(CRCD))+ttx(SEQ).tamt
			else  set CTSO(CRCD)=$G(CTSO(CRCD))+ttx(SEQ).tamt
			}

		type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")		 

		if (crcd.emu=1)!(TROUT=0) do EMU(.ttx(),.trn,SEQ,CRCD) quit

		do EXCBSU(.ttx(),.trn,SEQ)
		}
	quit


EMU(RecordTTX ttx(),	// ttx object
    RecordTRN trn,	// transaction object
    Number SEQ,		// transaction sequence
    String CRCD) 	// currency code
    
	//Euro balancing account offsets to balance 'IN' currencies

	
	type Public Cache %CACHE()
	type public String %EMUCRCD
	type public String TRNCODES()
	type public String EMU
	
	type public Number AMT
	type public Number OCC
	type public Number OUTFLG

	type Number CID
	type Number TSEQ
		
	set CID=CUVAR.EURBAL

	set TSEQ=$O(ttx((SEQ\1)+1),-1)+.01

	/* Set the cost center if not already set. OCC is Newed in GMCOFF and
	may not already be set. */
	if ($G(OCC)=""),ttx(SEQ\1).exists() set OCC=ttx(SEQ\1).cc

	// Euro balancing entry for the original transaction currency amount
	do BLDTR(.ttx(),TSEQ)

	if $G(OUTFLG)=1 do {

		/* Position account entry for the euro equiv. amount
		Rounded to euro cent */
		
		set AMT=$$EURRND^CRCDUTL(AMT,CRCD,%EMUCRCD)
		 
		set CRCD=%EMUCRCD

		do EXCBSU(.ttx(),.trn,SEQ)

		// Euro balancing entry for the euro equiv. amount
		set TSEQ=$O(ttx((SEQ\1)+1),-1)+.01
		set SEQ=SEQ+1

		set CID=CUVAR.EURBAL
		type String ETC
		set ETC=$P(TRNCODES,"|",$S((ttx(SEQ).itc).extract():2,1:3))
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC")
		
		type String ITC
		// Internal Transaction Code
		set ITC=trn.itc

		do BLDTR(.ttx(),TSEQ)
		}
	quit


EXCBSU(RecordTTX ttx(),RecordTRN trn,SEQ)
	/* Currency balancing transactions set up.

	Called from EXCB and EMU to set up the values needed in
	BLDTR to build the position entries for the base equivalent offsets
	with respect to the currency of the transaction.
	*/

	type String CID
	type String TSO
	type String TSEQ
	
	type public Number AMT
	type public String CCODE
	type public String CRCD
	type public String SYSBASE

	if CRCD'=%SystemCurrency set SYSBASE=$$SYSBASE(.ttx(SEQ\1),.trn,AMT,CRCD,CCODE,%EffectiveDate)

	set TSO=ttx(SEQ\1).tso

	if $$FIELD^UTSO(TSO,"XINTID")="TFS" set CID=$$tfsgl^CRCDUTL(CRCD)
	else  set CID=$$otcgl^CRCDUTL(CRCD)

	// Default Account Number
	if CID="" set CID=trn.acn
	if CID="" set CID=CUVAR.GLTS

	set TSEQ=$O(ttx((SEQ\1)+1),-1)+.01
	
	do BLDTR(.ttx(),TSEQ)

	quit


SYSBASE(RecordTTX ttx,RecordTRN trn,AMT,CRCD,CCODE,%EffectiveDate)
	/* Get system base equivalent rate, then calculate the system base 
	equivalent amount of the transaction. */

	new CASH,ETC,EXCAMT,MAXRATE,MINRATE,MULTIPLY,TRESREF,VARIANCE,RATE
	new SYSBASE,TRESREF

	if ttx.sysbase'="" quit ttx.sysbase

	set ETC=ttx.etc

	// Secondary crcd is always noncash
	if trn.trntyp=1 set CASH="10"
	else  set CASH="00"

	do EXC^CRCDUTL(CRCD,%SystemCurrency,AMT,1,trn.itc,CASH,CCODE,%EffectiveDate,1)
	//System base equivalent amount
	set SYSBASE=$$^SCARND(EXCAMT,,,CRCD)

	quit SYSBASE

 

TTSBE(RecordTTX ttx())
	/* Transaction Time Sytem Base Equivalent amount

	This code determines the transaction time system base equivalent and/or
	defines the transaction time system base equivalent rate when the rate
	is modified on the teller posting screen.
	*/
	
	type public String ER
	
	type Number MFX
	
	type Number RATE
	type Number SEQ
	
	set MFX=0
	set RATE=0
	set SEQ=""
	for  set SEQ=$O(ttx(SEQ)) quit:SEQ=""  do {
		if (ttx(SEQ).crcd'="")&(ttx(SEQ).crcd'=%SystemCurrency) set MFX=MFX+1
		if (ttx(SEQ).rate'=0)&(ttx(SEQ).rate'=1) set RATE=ttx(SEQ).rate
		}

	if RATE=0 set RATE=1

	set SEQ=""
	for  set SEQ=$O(ttx(SEQ)) quit:SEQ=""  do { quit:ER
		new CAMT,CRCD

		// System Base Currency Equivalent
		if ttx(SEQ).sysbase'="" quit

		// Screen Base Currency
		set CRCD=ttx(SEQ).bcrcd
		if ttx(SEQ).crcd="" set ttx(SEQ).crcd=%SystemCurrency
		if CRCD="" set CRCD=%SystemCurrency

		// System Base Currency Equivalent
		if MFX>1 set ttx(SEQ).sysbase=$$SBASE^TTXOFST(.ttx(),SEQ,ttx(SEQ).tamt,ttx(SEQ).crcd,ttx(SEQ).crcd) quit

		// System Base Currency Equivalent
		if ttx(SEQ).crcd=%SystemCurrency set ttx(SEQ).sysbase=+ttx(SEQ).tamt quit

		// System Base Currency Equivalent
		set ttx(SEQ).sysbase=$$^SCARND(ttx(SEQ).tamt*RATE,0,"",%SystemCurrency) quit
		}
	quit

vSIG()	quit "60466^56855^Shriram Deshpande^19042"	// Signature - LTD^TIME^USER^SIZE
