LNPTS69(RecordLN ln,RecordTTX ttx,RecordTRN trn)
 /*
	ORIG: scottc - 07/18/2002
	DESC: Purchase Remittance

	---- Comments --------------------------------------------------------

 	 PROCEDURE ID:	LNPTS69
 	     Original:	Tom Locke (2424) - 07/09/87
		 Date:	
 	         Desc:	Loan Purchase Remittance


 	ARGUMENTS:

	.ln	Loan Record			TYP/Record LN/REQ

	.ttx	Transaction Object 		TYP/Record TTX/REQ

	.trn	Transaction Code object		TYP/RecordTRN/REQ
 
 	RETURN:

	TAMT	Total Remittance due for loan purchase
 
 	
 	---- Revision History ------------------------------------------------
 	
 	01/05/07 - KUMARB - CR24680
		   Modified section ADJ1 to update the principal amounts on 
		   loans if LN.BAL is reduced Segments Allowed (LN.SEGMENTS)
		   selected by calling PURCHASE^LNSEG.

	02/09/06 - KinI - CR19503
		   Modified to send lnbil1 record to EXEC^LNBLDE.

	11/24/05 - chhabris - CR18008
		   Replaced depricated methods. Also, removed the revision 
		   history prior to 2004.

	----------------------------------------------------------------------
 */

	new BIL0INT,BIL0PRIN,X

	type RecordLNBIL1 lnbil1()	

	set X=ttx.tcmt
	for I=1:1:4 set PPREM(I)=$P(X,",",I)
	type RecordLNPPD lnppd=Db.getRecord("LNPPD","%SystemDate,PPREM(1),PPREM(2),PPREM(3),PPREM(4)")

	// Transaction Amount
	do PMT(.ttx,.ln,.lnbil1()) quit:ER
	set ttx.tamt=TAMT

	/*
	Process transaction through bill file with calculated amount
	to bring account current as of date in dayend file
	*/

	do EXEC(.ttx,.ln)
	
	if ER quit		
	
	// Transaction Amount
	set X=ttx.tamt
	
	// Due payment includes amounts other than P&I
 	if X-$P(X,"#",2)-$P(X,"#",3) do { quit
		set ER=1
		set RM=$$^MSG(862)
		do EXEC1
		}

	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID")
	set BIL0INT=$$BIL0^BILFUNCS(.lnbil0,"I")
	
	// Payment string does not contain interest
	if BIL0INT="" do { quit
		set ER=1
		set RM=$$^MSG(2169)
		do EXEC1
		}

	set PRI("I")=BIL0INT

	set BIL0PRIN=$$BIL0^BILFUNCS(.lnbil0,"P")
	
	// Payment string does not contain principal
	if BIL0PRIN="" do { quit
		set ER=1
		set RM=$$^MSG(2170)
		do EXEC1
		}

	set PRI("P")=BIL0PRIN

	// Initialize partial payment amounts
	if I="I" set PPA(I)=0
	if I="P" set PPA(I)=0

	/*
	Find P&I amounts for PPA by going backwards thru the 1 level in history
	Reset all payment amounts for this transaction in bill file.
	*/

	set HZ=0
	
	// partial payment
	set PPA=$P(PPREM,"|",2)	
	if I="I" set DIFF(I)=0
	if I="P" set DIFF(I)=0
	do HIST(.ttx,.lnbil1(),.ln)
	quit


HIST(RecordTTX ttx,RecordLNBIL1 lnbil1(),RecordLN ln)	// Private

	/*
	Arguments:

	. ttx		Transaction 				/TYP=Record TTX/REQ/MECH=VAL

	. lnbil1	Bill record array			/TYP=Record LNBIL1()/REQ/MECH=VALARY

	. ln		Loan Account record 			/TYP=Record LN/REQ/MECH=VAL

	*/

	new CID
	set CID=ttx.cid
	set HZ=0
	
	type ResultSet rs=Db.select("PE01,PE02,PE03,PE04,PE05,SLN","HISTSB","CID=:CID")
	if rs.isEmpty() do ADJ(.ttx,.lnbil1(),.ln,SEQ) quit
	
	while rs.next() do { quit:B=""
		for HZ=1:1:5 do {
			set PMTITM=rs.getRow(HZ)
			if PMTITM="" quit
			set Y=$P(PMTITM,"#",2)
			if "I/P"'[Y quit
			if PPA do PPA(.PMTITM)
			if '$P(PMTITM,"#",3) quit

			// Billing Sequence
			set SEQ=$P(PMTITM,"#",1)			
			do SETP(.lnbil1(),.B,PMTITM,SEQ)
			quit:B=""
			}
		}

	quit


SETP(RecordLNBIL1 lnbil1(),B,PMTITM,SEQ)	// Private

	/*
	Arguments:

	. lnbil1	Bill record array		/TYP=Record LNBIL1()/REQ/MECH=VALARY

	. PMTITM	Payment Item			/TYP=N/MECH=VAL

	. SEQ		Sequence from billing hist	/TYP=N/REQ

	Returns:

	. B		Payment element from LNBIL1	/TYP=N

	*/


	
	for P=2:1:20 do { quit:B=""
		set B=$$SUB^BILFUNCS(B,.lnbil1(SEQ)) quit:B=""
		set $P(B,"#",4)=$P(B,"#",4)+$P(PEO,"#",3)
		set $P(B,"#",1)=$P(B,"#",5)+$P(PMTITM,"#",3)
		set $P(B,"#",5)=$P(B,"#",5)+$P(PMTITM,"#",3)
		do SETELMT^BILFUNCS(.lnbil1(SEQ),.B,.P)
		}
	quit


EXEC(RecordTTX ttx,RecordLN ln)	//Private
	/*
	Arguments:

	. ttx		Transaction 				/TYP=Record TTX/REQ/MECH=VAL

	. ln		Loan Account record 			/TYP=Record LN/REQ/MECH=VAL

	*/


	catch vError {
		new ET,RM
		set ET=vError.type
		do ZE^UTLERR
		if $G(RM)="" set RM=$$ETLOC^%ZT
		if $G(ET)="" set ET=$G(RM)
		do LOG^UTLEXC($T(+0),"*",$G(RM),$G(CID),$G(%ZTSEQ),$G(ET),%TAMT)
		kill ET,%ZTSEQ

		}

	do ^LNPTS2(.ln,.ttx)
	
	if ER=1 do EXEC1
	
	quit


EXEC1           //Private

        set ER=1
        if $G(ET)="" set ET=$G(RM)
        
        do LOG^UTLEXC($T(+0),"*",$G(RM),$G(CID),$G(%ZTSEQ),$G(ET),%TAMT)
        kill ET,%ZTSEQ
        quit


PPA(PMTITM)	//Private

	/*
	Input:

	. PMTITM	Payment Item		/TYP=N/REQ

	*/
	
	if PPA'>$P(PMTITM,"#",3) set V=PPA
	else  set V=$P(PMTITM,"#",3)
	set PPA(Y)=PPA(Y)+V
	set PPA=PPA-V
	quit


DIFF(RecordTTX ttx,RecordLNBIL1 lnbil1(),OSEQ) 
	/*
	This function is used to determine if total bill amounts differ
	and to then adjust totals in bill file.

	Arguments:

	. ttx		Transaction 				/TYP=Record TTX/REQ/MECH=VAL

	. lnbil1	Bill record array			/TYP=Record LNBIL1()/REQ/MECH=VALARY

	*/
	
	new N1
	if 'OSEQ set N=Db.currVal("LNBIL1","CID")
	else  set N=$O(lnbil1(OSEQ-1))
	do DIFF1(.ttx,.lnbil1())
	while (PMT("I")!PMT("P")!TA("I")!TA("P")) do DIFF1(.ttx,.lnbil1())
	quit


DIFF1(RecordTTX ttx,RecordLNBIL1 lnbil1()) 
	/*
	Arguments:

	. ttx		Transaction 				/TYP=Record TTX/REQ/MECH=VAL

	. lnbil1	Bill record array			/TYP=Record LNBIL1()/REQ/MECH=VALARY

	*/

	// Adjust total amount for I
	set %B("I")=BIL0INT
	set %B("P")=BIL0PRIN	
	if 'TA("I") do TAP(.lnbil1(),.ttx,SEQ)
	if TA("I")'>0 set V=TA("I") do {
		set V=$S(-TA("I")>$P(%B("I"),"#",4):-$P(%B("I"),"#",4),1:TA("I"))
		if TA("I")=V quit
		/*
		Let's see if we can steal amounts from principal and set into interest
		so we can make more of an interest adjustment
		*/
		set X=$P(%B("P"),"#",4)
		if (V-X)<TA("I") set X=0-(TA("I")-V)
		for I=3,4 set $P(%B("P"),"#",I)=$P(%B("P"),"#",I)-X
		set V=V-X
		for I=3,4 set $P(%B("I"),"#",I)=$P(%B("I"),"#",I)+X
		}

	set TA("I")=TA("I")-V for I=3,4 set $P(%B("I"),"#",I)=$P(%B("I"),"#",I)+V
	for I=1,4,5,6 set $P(B,"#",I)=$P(B,"#",I)+V
	do TAP(.lnbil1(),.ttx,SEQ)
	quit


TAP(RecordLNBIL1 lnbil1(),RecordTTX ttx,SEQ)

	//   Adjust total amount for P

	/*
	Arguments:

	. ttx		Transaction 				/TYP=Record TTX/REQ/MECH=VAL

	. SEQ		Bill Sequence	 			/TYP=N/REQ/MECH=VAL

	*/

	if TA("P")>0 set V=TA("P")
	else  do {
		set V=$S(-TA("P")>$P(%B("P"),"#",4):-$P(%B("P"),"#",4),1:TA("P"))
		if TA("P")=V quit

		/*
		Let's see if we can steal amounts from interest and set into principal
		so we can make more of a principal adjustment
		*/

		set X=$P(%B("I"),"#",4)
		if (V-X)<TA("P") set X=0-(TA("P")-V)
		for I=3,4 set $P(%B("I"),"#",I)=$P(%B("I"),"#",I)-X
		set V=V-X
		for I=3,4 set $P(%B("P"),"#",I)=$P(%B("P"),"#",I)+X
		}

	set TA("P")=TA("P")-V
	for I=3,4 set $P(%B("P"),"#",I)=$P(%B("P"),"#",I)+V
	for I=1,4,5,6 set $P(B,"#",I)=$P(B,"#",I)+V

	// Can amounts be transferred from Prin to Int

	if PMT("I")>$P(%B("I"),"#",4) do {
		set X=$P(%B("P"),"#",4)-PMT("P")
		if X>(PMT("I")-$P(%B("I"),"#",4)) set X=PMT("I")-$P(%B("I"),"#",4)
		if X>0 for I=3,4 set $P(%B("P"),"#",I)=$P(%B("P"),"#",I)-X
		if   for I=3,4 set $P(%B("I"),"#",I)=$P(%B("I"),"#",I)+X
		}

	// Can amounts be transferred from I to P
	if PMT("P")>$P(%B("P"),"#",4) do {
		set X=$P(%B("I"),"#",4)-PMT("I")
		if X>(PMT("P")-$P(%B("P"),"#",4)) set X=PMT("P")-$P(%B("P"),"#",4)
		if X>0 for I=3,4 set $P(%B("I"),"#",I)=$P(%B("I"),"#",I)-X
		if   for I=3,4 set $P(%B("P"),"#",I)=$P(%B("P"),"#",I)+X
		}

	// apply P&I amounts to bill (vertical)
	if PMT("I") do {
		if PMT("I")>$P(%B("I"),"#",4) do {
			set V=$P(%B("I"),"#",4)
			set PMT("I")=PMT("I")-V
			}
		else  do {
			set V=PMT("I")
			set PMT("I")=0
			}
		if 'V quit
		set $P(%B("I"),"#",4)=$P(%B("I"),"#",4)-V
		for I=1,5 set $P(B,"#",I)=$P(B,"#",5)-V
		set HIST=1
		do %HSEQ^LNPTSU(.ttx,N_"#I#"_V,SEQ)
		}
		
	do PMTP(.lnbil1(),.ttx)
	
	quit


PMTP(RecordLNBIL1 lnbil1(),RecordTTX ttx)

	/*
	Arguments:

	. lnbil1	Bill record array			/TYP=Record LNBIL1()/REQ/MECH=VALARY

	*/

	if 'PMT("P") do {
		if PMT("P")>$P(%B("P"),"#",4) do {
			set V=$P(%B("P"),"#",4)
			set PMT("P")=PMT("P")-V
			}
		else  do {
			set V=PMT("P")
			set PMT("P")=0
			}
		if 'V quit
		set $P(%B("P"),"#",4)=$P(%B("P"),"#",4)-V
		if I=1 set $P(B,"#",I)=$P(B,"#",I)-V
		if I=5 set $P(B,"#",I)=$P(B,"#",I)-V
		set HIST=1 do %HSEQ^LNPTSU(.ttx,N_"#P#"_V,)
		}

	for I="I","P" do SETELMT^BILFUNCS(.lnbil1(N),%B(I),PRI(I))
	quit


public ADJ(RecordTTX ttx,RecordLNBIL1 lnbil1(),RecordLN ln,SEQ)	// 
	/*
	Arguments:

	. ttx		Transaction 				/TYP=Record TTX/REQ/MECH=VAL

	. lnbil1	Bill record array			/TYP=Record LNBIL1()/REQ/MECH=VALARY

	. ln		Loan Account record 			/TYP=Record LN/REQ/MECH=VAL

	. SEQ		Bill Sequence	 			/TYP=N/REQ/MECH=VAL

	*/


	set OSEQ=""
	for  set OSEQ=$O(lnbil(OSEQ)) quit:OSEQ=""  quit:lnbil1(OSEQ).pe01
	set X=ttx.tamt
	set DIFF("P")=$P(PPREM,"|",3)-$P(X,"#",2)
	set DIFF("I")=$P(PPREM,"|",4)-$P(X,"#",3)
	set DIFF=DIFF("I")+DIFF("P")

	for I="I","P" set TA(I)=DIFF(I)

	if (DIFF("I")<0),(DIFF("P")<0) do ADJ1(.ttx,.lnbil1(),.ln,SEQ)
	else  if (DIFF("I")>0),(DIFF("P")>0) do ADJ1(.ttx,.lnbil1(),.ln,SEQ)
	else  if DIFF("I")<0 set TA("I")=DIFF set TA("P")=0 do ADJ1(.ttx,.lnbil1(),.ln,SEQ)
	else  if DIFF("P")<0 set TA("P")=DIFF set TA("I")=0 do ADJ1(.ttx,.lnbil1(),.ln,SEQ)
	quit


Public ADJ1(RecordTTX ttx,RecordLNBIL1 lnbil1(),RecordLN ln,SEQ)	//
	/*
	Arguments:

	. ttx		Transaction 				/TYP=Record TTX/REQ/MECH=VAL

	. lnbil1	Bill record array			/TYP=Record LNBIL1()/REQ/MECH=VALARY

	. ln		Loan Account record 			/TYP=Record LN/REQ/MECH=VAL

	. SEQ		Bill Sequence	 			/TYP=N/REQ/MECH=VAL


	*/

	type Number ADJ
	type String ETC	

	set PMT("I")=$P(PPREM,"|",4)
	if PMT("I")<0 set PMT("I")=0
	set PMT("P")=$P(PPREM,"|",3)
	if PMT("P")<0 set PMT("P")=0
	set X=PPA("I")-PMT("I")
	if X>0 set PPA("I")=PPA("I")-X set PPA("P")=PPA("P")+X
	set X=PPA("P")-PMT("P")
	if X>0 set PPA("P")=PPA("P")-X set PPA("I")=PPA("I")+X
	do DIFF(.ttx,.lnbil1(),OSEQ)

	do INIT^LNPTS2A(.ln)
	set PDS=$$PDS^LNUBIL1(OSEQ,SCHSEQ)
	set N=ln.oseq-.00001

	type ResultSet rs=Db.select("SCHSEQ","LNBIL1","CID=:CID and SCHSEQ>:N")
	if rs.isEmpty() quit
	while rs.next() do {
		set SCHSEQ=rs.getCol(1)
		if 'lnbil(SCHSEQ).exists() set lnbil1(SCHSEQ)=Db.getRecord("LNBIL1","CID,SCHSEQ")
		}

	// Transaction Amount
	set TAMT=ttx.tamt

	// Set old P&I into dayend file
	set $P(PPREM,"|",9)=$P(TAMT,"#",2)
	set $P(PPREM,"|",10)=$P(TAMT,"#",3)
	set $P(PPREM,"|",11)=PPA("P")
	set $P(PPREM,"|",12)=PPA("I")

	set ETC=ttx.etc
	type RecordTRN trn=Db.getRecord("TRN","ETC")
	
	// Principal adjustment
	set ADJ=$P(PPREM,"|",3)-$P(TAMT,"#",2)
	if ADJ do {
		set ADJ=$S(ln.trb:ADJ,1:-ADJ)
		set PF=0

		// Adjust TAMT by adjustment amount ADJ
		set $P(TAMT,"#",2)=+$P(PPREM,"|",3)
		set $P(TAMT,"#",1)=$P(TAMT,"#",1)+ADJ
	
		// Adjust fields in account
		set ln.bal=ln.bal-ADJ set BAL=+ln.bal
		
		#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
			if ln.segments do PURCHASE^LNSEG(.ln, .ttx, ADJ)
		#ENDIF
		
		set ln.balint=ln.balint-ADJ
		if ln.bal<.01 set ln.habl2=+ln.bal

		// Processing Control Flags
		// Principal Variance
		if $E(trn.pcf,12) set ln.pvar=ln.pvar-ADJ
		
		// Total Principal Only Payments
		if $E(trn.pcf,5) set ln.poamt=ln.poamt-ADJ
		}
		
	do CALC2(.ttx,.ln)
	
	quit


CALC2(RecordTTX ttx,RecordLN ln)	//

	/*
	Arguments:

	. ttx		Transaction 				/TYP=Record TTX/REQ/MECH=VAL

	. ln		Loan Account record 			/TYP=Record LN/REQ/MECH=VAL

	*/
	
	// Interest adjustment
	set ADJ=$P(PPREM,"|",4)-$P(TAMT,"#",3)
	if ADJ do {
		set ADJ=$S(ln.trb:ADJ,1:-ADJ) set PF=0

		// Adjust TAMT by adjustment amount ADJ
		set $P(TAMT,"#",3)=+$P(PPREM,"|",4)
		set $P(TAMT,"#",1)=$P(TAMT,"#",1)+ADJ

		// Adjust fields in account
		set ln.acr=ln.acr-ADJ
		set ln.iytd=ln.iytd+ADJ
		set ln.ipl=ln.ipl+ADJ
		}

	// Transaction Amount
	set ttx.tamt=TAMT
	kill ICPA,SCHND
	do ^LNPTS(.ln)

	// Adjusted Balance for Accrual Calculation
	set ln.balint=BALINT
	
	// Current Escrow
	set ln.cuin=CUIN
	set ln.cupr=CUPR
	set ln.cues=CUES
	
	// Uncollected Escrow
	set ln.unin=UNIN
	set ln.unpr=UNPR
	set ln.unes=UNES
	
	// Payment - Partial Amount
	set ln.tdue=TDUE
	set ln.ppa=PPA
	
	// Next Due Date - Payment Amount
	set ln.dist1nd=DIST1ND
	set ln.dseq=DSEQ
	set ln.dpmt=DPMT
	
	// Total Outstanding Due Amount
	set ln.dist1ld=DIST1LD
	set ln.oseq=OSEQ
	set ln.tba=TBA
	
	// Last Bill - Loan Due Date Billed
	set ln.bseq=BSEQ
	set ln.lbdd=LBDD

	set $P(PPREM,"|",13)=+ln.bal

	new delnpp
	type RecordLNPPD delnpp=Class.new("RecordLNPPD")
	set delnpp.efd=%SystemDate
	set delnpp.slcd=PPREM(1)
	set delnpp.pl=PPREM(2)
	set delnpp.cid=PPREM(3)
	set delnpp.seq=PPREM(4)
	set delnpp.sfth=$P(PPREM,"|",1)
	set delnpp.ptpmt=$P(PPREM,"|",2)
	set delnpp.prin=$P(PPREM,"|",3)
	set delnpp.int=$P(PPREM,"|",4)
	set delnpp.fee=$P(PPREM,"|",5)
	set delnpp.prino=$P(PPREM,"|",6)
	set delnpp.into=$P(PPREM,"|",7)
	set delnpp.remt=$P(PPREM,"|",8)
	set delnpp.xprin=$P(PPREM,"|",9)
	set delnpp.xint=$P(PPREM,"|",10)
	set delnpp.ptprn=$P(PPREM,"|",11)
	set delnpp.ptint=$P(PPREM,"|",12)
	set delnpp.bal=$P(PPREM,"|",13)
	do delnpp.bypassSave()

	quit


PMT(RecordTTX ttx,RecordLN ln,RecordLNBIL1 lnbil1())
	/*
	Calculate amount needed to bring account current as of date in PPREM

	Arguments:

	. ttx		Transaction 				/TYP=Record TTX/REQ/MECH=VAL

	. lnbil1	Bill record array			/TYP=Record LNBIL1()/REQ/MECH=VALARY

	*/

	new B,N,X

	set %TAMT=ttx.tamt
	
	// Distribution 1 Next Due
	if PPREM<ln.dist1nd set TAMT=$P(PPREM,"|",4)+$P(PPREM,"|",5) quit

	// Not all bills are in the bill file, create the balance.
	if ln.lbdd<PPREM do BLOAD(.ttx,.ln,.lnbil()) quit:ER
	if ER quit

	set TAMT=-ln.ppa
	set N=ln.oseq-.00001
	type ResultSet rs=Db.select("SCHSEQ","LNBIL1","CID=:CID and SCHSEQ>:N")
	if rs.isEmpty() quit
	while rs.next() do {
		set SCHSEQ=rs.getCol(1)
		set X(SCHSEQ)=""
		}

	if '$D(X) quit
	set SCHSEQ=""

	for  set SCHSEQ=$O(X(SCHSEQ)) quit:SCHSEQ=""  do {
		set lnbil1(SCHSEQ)=Db.getRecord("LNBIL1","CID,SCHSEQ")
		}

	for  set N=$O(lnbil1(N)) quit:N=""  quit:($P(B(N),"#",3)>PPREM)!($P(B(N),"#",3)-PPREM=0)  do {
		set B=$$SUB^BILFUNCS(.B,.lnbil1(N))
		if $P(B(N),"#",3)>PPREM quit
		set TAMT=TAMT+$P(B(N),"#",4)
		if $P(B(N),"#",3)-PPREM=0 set TAMT=TAMT+$P(PPREM,"|",2) 
		}
	quit


BLOAD(RecordTTX ttx,		// Transaction Record
      RecordLN ln,		// Loan Record
      RecordLNBIL1 lnbil1())	// Bill Record Array

	// This sections calls into EXEC of LNBLDE to create bills that are 
	// due but not in bill file.
	
	type Number BLSEQ=""
	
	for  set BLSEQ=lnbil1(BLSEQ).order() do { quit:BLSEQ=""
		do EXEC^LNBLDE(.ln,.ttx,CID,%SystemDate,1,.lnbil1(BLSEQ)) quit:(ER)!(PPREM'>ln.lbdd)!('lnbil(ln.bseq).exists())
		}
		
	quit
	
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60675^66197^Balasubramonian Sankar^13986"	// Signature - LTD^TIME^USER^SIZE
