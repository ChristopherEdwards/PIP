CMSSTCH	// CMS Incoming File Routine
	/*
	       ORIG:  Carrie Baildon - 10 DEC 1997
	  CALLED BY:  Dayend Function (QUE089)
	      CALLS:  ^CARDFILE,CIFFILE,DEPFILE,^UTLO
	   PROJ #'S:  ARQ 25272
	       DESC:  This file reads incoming card status change files and
	        files the changes included in each record.


	  ---- Revision History -------------------------------------------------
	  
              12/12/05 - SPR - 18555
		      Card Management - General DBI3 system area cleanup.

	  -----------------------------------------------------------------------

	*/

	type public Number ER
	
	set ER=0

	// Init runtime variables
	do INIVAR 

	if ER quit
	
	catch vERROR {

		type String ET,RM

		set ET=vERROR.type

		set ET=ET_"-"_vERROR.thrownAt
		set RM=vERROR.description

		do ZTCRD^CMSSTCH
		}
	

	do LAYOUT
	
	quit


LAYOUT	//

	type public Number CONV,FILLER,LENGTH,LFTJUST,VALTYP,VALUE,VAL
	type public Number STPPOS,STRTPOS
	type public String DET,FLTYP,HDR,TRL

	type DbSet rs=Db.selectDbSet("UTBLCMSFILE2","FLTYP=:FLTYP")
	while rs.next() do {	
		type RecordUTBLCMSFILE2 utblcms2=rs.getRecord()
		
		set (LENGTH,FILLER,LFTJUST,CONV,VALTYP,VALUE,VAL)=""
		set STRTPOS=0 
		set STPPOS=0
	
		if utblcms2.rectyp="FH" set HDR(utblcms2.ord)=$$VAL(.utblcms2)
		if utblcms2.rectyp="DR" set DET(utblcms2.ord)=$$VAL(.utblcms2)
		if utblcms2.rectyp="FT" set TRL(utblcms2.ord)=$$VAL(.utblcms2)
		
		}	
		
	do BEGIN
	
	quit


VAL(RecordUTBLCMSFILE2 utblcms2)	//

	/* Returns the parameters for the piece of data at the position
	   defined by ORD.  These parameters are set up on the CMSFILE user
	   table.

	   ARGUMENTS
	   	.  utblcms2	Record UTBLCMSFILE2	/REQ /MECH=REF

	*/

	type public String FILLER,VAL,RECTYP,RECLN
	type public Number LENGTH,STRTPOS,STPPOS
	
	if 'RECLN(RECTYP).exists() set RECLN(RECTYP)=0

	set LENGTH=utblcms2.length

	set STRTPOS=STPPOS+1
	set STPPOS=STRTPOS+LENGTH-1

	set FILLER=utblcms2.filler
	
	if FILLER.get().isNull() set FILLER=" "

	set VAL=utblcms2.valtyp_"|"_utblcms2.value_"|"_STRTPOS_"|"_STPPOS_"|"_FILLER_"|"_utblcms2.lftjust_"|"_utblcms2.cnv

	set RECLN(RECTYP)=RECLN(RECTYP)+LENGTH

	quit VAL


BEGIN	/*  Opens the file that will contain the card status change information
	    written to it and establishes the initial conditions.
	*/

	type public String ARCH,DELIM,ER,FLTYP,RECORDS,RECDELIM,RDLM,RM,TBL,ULDIR
	type public Number FLNUM,INCFL,RECTOT
	type public Date ISDT
	type Number I
	type String FILE

	set ER=0

	type RecordUTBLCMSFILE utblcms=Db.getRecord("UTBLCMSFILE","FLTYP=:FLTYP",1)

	set DELIM=utblcms.delim
	set ULDIR=utblcms.uldir
	set ARCH=utblcms.archivedir

	// The delimiter used to separate records
	set RECDELIM=utblcms.recdelim
	
	if RECDELIM["$C(" do {
		set RECDELIM=RECDELIM.piece("(",2)
		set RECDELIM=RECDELIM.piece(")",1)
		set RDLM=""
		for I=1:1:RECDELIM.length(",") set RDLM=RDLM_$C(RECDELIM.piece(",",I))
		set RECDELIM=RDLM
		}

	//Table of files in the upload directory ULDIR
	do BLDTBL

	// Directory ~p1 does not contain status change files
	if 'TBL.exists() set ER=1 set RM=$$^MSG(3131,ULDIR) do EXC quit
		
	set FLNUM=""
	for  set FLNUM=TBL(FLNUM).order() quit:FLNUM.isNull()  do {
		set FILE=ULDIR_TBL(FLNUM)
	
		do OPEN(FILE)

		if ER do RENAME(FILE) quit

		if RECORDS.get()'=RECTOT do {
			set ER="W"
			// Record count does not match trailer
			set RM=$$^MSG(207)

			do EXC
			}

		else  do FILE

		do RENAME(FILE)
		}

	set INCFL=0

	quit


BLDTBL	// This builds the table of files found in a directory

	type public String FILE,LOGICAL,RM,REC,TBL,ULDIR,X
	type public Number CNT,ER,ETYP
	type Number I
	type String IO
	
	type IO io=Class.new("IO")

	set CNT=0

	set LOGICAL=$$SCAU^%TRNLNM(ULDIR)

	set IO=$select('LOGICAL.get().isNull():$$SCAU^%TRNLNM(ULDIR,"ZDIR.TMP"),1:ULDIR_"ZDIR.TMP")

	set X=$$DIROUT^%OSSCRPT(IO,ULDIR,"*.*")

	catch vERROR {
	        do ZT1(IO)
                }
	
	set io.fileName=IO
	set io.openParams="READ"
	
	do io.open()
	
	for I=1:1 set REC=io.read() do {
		if REC.isNull() quit

		// Directory ~p1 does not contain status change files
		if REC'["STCH" quit
		
		if (REC["Directory")!(REC["ZDIR")!(REC["Total") quit

		set CNT=CNT+1

		/*
		  This is making sure it is a status change file for processing.
		  This test may change according to how the file is named
		*/
		if REC.piece(" ",1)["STCH" set TBL(CNT)=REC.piece(" ",1)

		}

	do io.close()
	
	set X=$$DELETE^%OSSCRPT(IO)

	quit


OPEN(String FILE)	//

	/* This opens a file and puts the records into the REC array.
	   It processes the record according to the record type

	ARGUMENTS
		. FILE	File Name	/REQ /MECH=VAL

	*/

	type public String DELIM,REC,RM,X
	type public Number ER,ETYP,NUM,RECTOT
	type Number I

	kill REC

	type IO io=Class.new("IO")

	catch vERROR {
		do ZT1(FILE)
                }
	
	set io.openParams="READ"
	set io.fileName=FILE
	set io.timeout=5
	
	do io.open()
	
	for I=1:1 set REC(I)=io.read() 

	do io.close()

	set NUM=""

	/*
	  Processes records according to the record's type
	  If there is an error with any of the records, do not process the file
	*/
	set RECTOT=0
	
	for  set NUM=REC(NUM).order() quit:((NUM="")!(ER))  do {
		if (REC(NUM).extract(1,2)="DR")!(REC(NUM).extract(1,2)="DT") do {
			do PARSE
			if ER quit
			}

		if REC(NUM).extract(1,2)="FH" do HEADER
		if REC(NUM).extract(1,2)="FT" do TRAILER
		}

	quit



PARSE	/* This is used to break apart the record based on the user defined
	   table of file layouts.  This uses the parameters set on the CMSFILE
	   user table to determine how to use the contents of the file.

	   The file is comprised of fixed values, computed values, empty values,
	   and PROFILE data items.  Based on the start and stop position, a
	   single piece of data is extracted from the file.
	*/


	type public String BFLARR(,),CRDTYP,CONV,DATA,DET,DELIM,FILLER,LFTJUST,NS,ORD,REC,RECLN,RM,TYP,VALTYP,VALUE	
	type public Number CRDNUM,END,ER,ISDT,M,NUM,RECTOT,STRTPOS,STPPOS,VAL
	type Number I

	set ER=0

	if 'DELIM.get().isNull() do PARSEDLM quit

	//The table of detail records is DET(ORD)
	set ORD=""

	/*
	   This checks the length of the record against the total calculated by
	   the values in the user table.
	*/
	if REC(NUM).length()'=RECLN("DR") do { quit
		// Invalid record
		set ER=1 
		set RM=$$^MSG(8097)
		do EXC
		}
	
	for  set ORD=DET(ORD).order() quit:(ORD="")!ER  do {
		set VALTYP=DET(ORD).piece("|",1)

		// Quit if this is not a PROFILE data item
		if VALTYP'=2 quit

		set VALUE=DET(ORD).piece("|",2)
		set STRTPOS=DET(ORD).piece("|",3)
		set STPPOS=DET(ORD).piece("|",4)
		set FILLER=DET(ORD).piece("|",5)
		set LFTJUST=DET(ORD).piece("|",6)
		set CONV=DET(ORD).piece("|",7)

		set DATA=REC(NUM).extract(STRTPOS,STPPOS)

		// Remove the filler
		if LFTJUST do {
			/*
			   Find the last valid character in the data item and remove the
			   remaining filler.
			*/
			for I=1:1:DATA.length() if DATA.extract(I,I)'=FILLER set END=I

			set DATA=$select(END:DATA.extract(1,END),1:DATA)
			}

		else  do {
			for I=1:1 set DATA=DATA.extract($find(DATA,FILLER),DATA.length()) quit:'$find(DATA,FILLER)
			}

		/*
		   This sets NS to the MUMPS Expression that is equivalent to 
		   the PROFILE data item in VALUE
		*/

		do PARSE^DBSDD(VALUE)

		// If the data needs to be converted
		if 'CONV.get().isNull() set DATA=$$^CMSCONV(DATA,CONV)

		/*
		   This defines the card type needed to file to the card filer
		   This assumes that one of the data items is the card number
		   This is specific to the "Status Change File"
		*/
		if NS="CRDNUM" do { quit:ER
			set @NS=DATA
			set CRDTYP=""

			type DbSet ds=Db.selectDbSet("CRD","CRDNUM=:CRDNUM","CRDTYP")

			// Invalid card number ~p1
			if ds.isEmpty() set ER=1 set RM=$$^MSG(3784,CRDNUM) do EXC quit

			if ds.next() do {
				type RecordCRD crd=ds.getRecord("CRD")
				set CRDTYP=crd.crdtyp
				}
			}

		set VAL=$select(VALUE[".":VALUE.piece(".",2),VALUE["]":VALUE.piece("]",2),1:VALUE)
		}
		
	
	set RECTOT=RECTOT+1
		
	if ER quit

	set BFLARR(CRDTYP,CRDNUM)=VAL_"|"_DATA

	quit


PARSEDLM	// This will be coded if the file uses a data item delimiter

	quit

	

HEADER	// Nothing needs to be done in here for now.

	type public String DATA,END,FILLER,HDR,ISDT,REC,RECORDS
	type public Number LFTJUST,NUM,ORD,STRTPOS,STPPOS
	type Number I

	// This is hard coding the date to be at a given ORD
	set ORD=30
	set STRTPOS=HDR(ORD).piece("|",3)
	set STPPOS=HDR(ORD).piece("|",4)
	set FILLER=HDR(ORD).piece("|",5)
	set LFTJUST=HDR(ORD).piece("|",6)
	set RECORDS=REC(NUM).extract(STRTPOS,STPPOS)
	
	// Remove the filler
	if LFTJUST do {
		set END=$find(DATA,FILLER)
		set RECORDS=$select(END:+RECORDS.extract(1,END-2),1:RECORDS)
		}

	else  do {
		for I=1:1 set RECORDS=RECORDS.extract($select(RECORDS.extract()=FILLER:2,1:1),RECORDS.length()) quit:RECORDS.extract()'=FILLER
		}
	
	set ISDT=RECORDS
	set ISDT=ISDT.toDate("YEARMMDD")
	
	quit


TRAILER	/* This is very specific to CMSSTCH.  It is used to locate the number of
	   records.  The number of records indicated in the trailer
	   should be equal to the number of detail records received.

	   This is hard coding the number of records to be at a given ORD
	*/
	
	type public String DATA,END,FILLER,ISDT,REC,RECORDS,TRL
	type public Number STRTPOS,ORD,STPPOS,LFTJUST,NUM
	type Number I
	
	set ORD=20
	set STRTPOS=TRL(ORD).piece("|",3)
	set STPPOS=TRL(ORD).piece("|",4)
	set FILLER=TRL(ORD).piece("|",5)
	set LFTJUST=TRL(ORD).piece("|",6)
	set RECORDS=REC(NUM).extract(STRTPOS,STPPOS)

	// Remove the filler
	if LFTJUST do {
		set END=$F(DATA,FILLER)
		set RECORDS=$S(END:RECORDS.extract(1,END-2),1:RECORDS)
		}

	else  do {
		for I=1:1 set RECORDS=RECORDS.extract($select(RECORDS.extract()=FILLER:2,1:1),RECORDS.length()) quit:RECORDS.extract()'=FILLER
		}

	quit


RENAME(String FILE)	//

	/* 
	   Moves the file to the archive directory
           This renames the file with the file type prefix and a date and
           time stamp.

	   ARGUMENTS
		. FILE	File Name	/REQ /MECH=VAL

	*/
		
	type public Date DATE
	type public Number FLNUM,TIME
	type public String ARCH,FLTYP,FILENM,NEWFL,PATH,TBL,X

	set DATE=%CurrentDate.toString("MMDD")
	 
	set TIME=%CurrentTime.toString("2460")
	
	set NEWFL=ARCH_FLTYP_"_"_DATE_"_"_TIME_".DAT"
	
	set X=$$COPYFIL^%OSSCRPT(FILE,NEWFL)
	
	set FILENM=(TBL(FLNUM))
	
	set PATH=FILE.piece(FILENM,1)
	
	if PATH.extract(PATH.length())="/" set PATH=PATH.extract(1,PATH.length()-1)

	set X=$$DELETE^%OSSCRPT(FILENM,PATH)
	
	quit


INIVAR	// Init runtime variables

	type public String FLTYP,%LOGID,ER
	type public Number INCFL

	if '%LOGID.exists() set %LOGID=$$LOGID^SCADRV

	set ER=0
	set FLTYP="STCH"
	set %ProcessMode=1
	set INCFL=1

	quit


FILE	// File to disk

	type public String %LOCK,BFLARR(,),ET
	type public Number ER
	type public Date ISDT
	type String CRDTYP,DATA,VAL
	type Number CRDNUM

	set CRDTYP=""
	for  set CRDTYP=BFLARR(CRDTYP).order() quit:CRDTYP=""  do {
		set CRDNUM=""
		for  set CRDNUM=BFLARR(CRDTYP,CRDNUM).order() quit:CRDNUM=""  do {

			if '$$LOCK(CRDTYP,CRDNUM,.%LOCK) do { quit
				set ER=1 
				set ET="RECLOC" 
				do EXC
				set ER=0
				}

			set VAL=BFLARR(CRDTYP,CRDNUM).piece("|",1)
			set DATA=BFLARR(CRDTYP,CRDNUM).piece("|",2)
 
			type RecordCRD crd=Db.getRecord("CRD","CRDTYP=:CRDTYP,CRDNUM=:CRDNUM",1)
			do crd.setAuditFlag(1)

			// If there is no issue date and status is 0 (active) set issue date
			if VAL="STAT",crd.isdt="",DATA=0 do {
				// Issue Date
				set crd.isdt=ISDT
				}
			
			else  set crd.@VAL=DATA

			do crd.save()

			do UNLOCK(%LOCK,.%LOCK)
			}
		}

	quit


LOCK(String CRDTYP,String CRDNUM,String %LOCK)	//

	/*

	   This sub-routine will incrementally LOCK the card record
	   specified if it is not already contained in %LOCK.  If the
	   lock is successful, %LOCK is updated to include the card
	   number.

	   ARGUMENTS:
	       . CRDTYP    Card Type of Card to lock             /REQ/MECH=VAL
	       . CRDNUM    Card to lock                          /REQ/MECH=VAL
	       . %LOCK  Record lock string                       /NOREQ/MECH=REFNAM

	   EXAMPLE:
	       I '$$LOCK("DEBIT",123456,.%LOCK) S ER=1,ET="RECLOC" Q


	*/
	
	type public String CARD(,)
	
	set %LOCK=%LOCK.get() 

	if ","_%LOCK_","[(","_CRDTYP_"|"_CRDNUM_",") quit 1
	lock +CARD(CRDTYP,CRDNUM):2 else  quit 0

	if %LOCK.isNull() set %LOCK=CRDTYP_"|"_CRDNUM quit 1
	set %LOCK=%LOCK_","_CRDTYP_"|"_CRDNUM

	quit 1


UNLOCK(String STR,String %LOCK)	//

	/*
	   This sub-routine will decrement the LOCK for the card record(s)
	   specified by the character string 'STR' and remove it from
	   %LOCK (if it is contained in %LOCK).

	   ARGUMENTS:
	       . STR    Card(s) to unlock, comma separated    /REQ/MECH=VAL
	       . %LOCK  Record lock string                    /NOREQ/MECH=REF

	   EXAMPLE:
	       D UNLOCK(%LOCK,.%LOCK)


	*/

	type public String CRDTYP,CRDREC,CARD(,)
	type public Number CRDNUM
	type Number I,J

	set %LOCK=%LOCK.get()

	for I=1:1:STR.length(",") do {
		set CRDREC=STR.piece(",",I) quit:CRDREC.isNull()
		set CRDTYP=CRDREC.piece("|",1) set CRDNUM=CRDREC.piece("|",2)
		lock -CARD(CRDTYP,CRDNUM)
		for J=1:1:%LOCK.length(",") if %LOCK.piece(",",J)=CRDREC do { quit
			set %LOCK=%LOCK.piece(",",1,J-1)_","_%LOCK.piece(",",J+1,999)
			}
		}

	if %LOCK.extract(%LOCK.length())="," set %LOCK=%LOCK.extract(1,%LOCK.length()-1)

	quit


ZTCRD	// Error trap at account level

	do ZE^UTLERR

	quit


ZT1(String FILE)	// Error trap for opening files

	/*

	ARGUMENTS
		. FILE	File Name	/REQ /MECH=VAL

	*/


	type public Number %ZHALT,%ZTSEQ,CRDNUM
	type public String ET

	set %ZHALT=0
	do ZE^UTLERR

	// System error #~p1, contact system manager
	if %ZTSEQ.exists() set %ZTSEQ=$$^MSG(6747,%ZTSEQ)

	// Error opening ~p1
	set ET=$$^MSG(989,FILE)

	do LOG^UTLEXC(%RoutineName,"*",ET,CRDNUM.get(),%ZTSEQ.get())

	kill ET,%ZTSEQ

	quit


EXC	// Log error to DAYEND
	
	type public String ET,RM,%ZTSEQ
	type public Number CRDNUM

	// Card status change file
	do LOG^UTLEXC(%RoutineName,"*",$$^MSG(3785),CRDNUM.get(),%ZTSEQ.get(),RM.get())

	kill ET,%ZTSEQ

	quit

vSIG()	quit "60254^36762^Renga SP^13365"	// Signature - LTD^TIME^USER^SIZE
