LNCAL21		/*
	ORIG: GRAY - 01/14/2000
	DESC: Account modeling-anticipates future activity
    
	---- Revision History ------------------------------------------------

	07/12/06 - SANTHUMS - CR 22029 
		   Modified LOAD section to set ln.bal to bal variable
		   before calling EXEC^UANTIC since ln.bal was getting reset 
		   in LNPTS3 posting program.	
		
	03/13/06 - SANTHUMS - CR 19947
		   Made LNPROJ label as private and removed the code 
		   do ^UTLERR from LNPROJ section.
		   	
	03/07/06 - S.Krishnan - CR 19711
		   . Modified LOAD section to change the fetch logic of HIST 
		     records. The fetch logic "TSEQ<=:OTSEQ" is modified 
		     to "TSEQ>:OTSEQ".

	02/08/06 - SANTHUMS - CR 19710
		   . Modified to use the TMPRPT4 table instead of TMPRPT3
		   . Modified LOAD section to change the fetch logic of HIST 
		     records
		   . Modified LNPROJ section to pass the 2 nd parameter and to 
		     call do ^URID outside the if loop
		  		   
	02/08/06 - S.Krishnan - CR16885
		   . Modified to always use the TMPRPT3 table instead of TMP(,,).
		   . Modified RID.get() to RID.get().isNull()

	10/07/05 - SmithCD - CR 16885
		   . Removed 4th / 5th parameters in call to EXEC^UANTIC, 
		     and fixed the order of parameters
		   . Replaced ttxinq(,) use with code that uses the 
		     future HIST table entries generated by ^UANTIC, to 
		     retrieve the transaction information needed
		   . Performed some minor cleanup
		   . Removed old revision history

        07/26/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.

	*/

	quit


public CHKCID	//  Ensure that account is not locked and has no integrity errors

	type public Number CID
	type public Boolean ER
	type public String RM	
	
	type Number %EXT,%ProcessMode,CNT,seq,trannum
	type String verrors(),ZCLS

	set %EXT=1
	set ZCLS="L"
	do ^UACN 
	if CID.get().isNull() set ER=1
	quit:ER.get()
	
	
	// Ensure that account is integrity error free
	set CNT=0
	set %ProcessMode=2
	
	// Check for fatal errors only	
	do VERIFY^LNIC(CID)

	set trannum=""
	for  set trannum=verrors(trannum).order() quit:trannum.isNull()  do { quit:ER
		set seq=""
		for  set seq=verrors(trannum,seq).order() quit:seq.isNull()  do { quit:ER
			// Resolve account integrity errors before proceeding
			if verrors(trannum,seq).piece("|",1) do Runtime.setErrMSG("LN",2400)
			}
		}

	set RM=RM.get()
	
	quit

	
public LOAD(RecordLN ln, Date ENDDATE)	// Load activity array

	/*
	This section is called by MRPC014 and the LNPROJ section of this 
	procedure
	*/
	
	type public Number CID,ERRORCNT
	type public Boolean ER
	type public String ERRMSG(),RID,RM
	
	type Boolean LNMDLR,lnsysgen
	type Date BEGDATE,DATE
	type Number bal,ERRORFLG,FORSEQ,OTSEQ,TYPE
	type String FEETYP

	set LNMDLR=1
	set lnsysgen=1

	set (DATE,ERRORCNT,FORSEQ)=0
	
	set TYPE=ln.type
	
	set bal=ln.bal
	
	/*
	Because ^UANTIC utility (called later) will automatically make all 
	projected payments on each scheduled due date, we turn off the PAT 
	flag to ensure that the payments are not processed two times.
	*/
	
	set ln.ptf=0
	
	set BEGDATE=%SystemDate
		
	// Save original transaction sequence
	set OTSEQ=Db.nextVal("HIST","CID")-1

	do EXEC^UANTIC(.ln,,,ENDDATE)
	
	if ER.get(),'RID.get().isNull() quit
	if ER.get() do { quit		
		set ERRORFLG=ER
		set ERRORCNT=ERRORCNT+1
		set ERRMSG(ERRORCNT)=RM
		set ER=0
		}

	// Process all HIST records created by ^UANTIC
	type DbSet ds=Db.selectDbSet("HIST","CID=:CID AND TSEQ>:OTSEQ","TSEQ DESC")
	while ds.next() do { quit:ER
		type RecordHIST hist=ds.getRecord("HIST")
		type RecordTTX ttx = hist.copy("TIM=TIME,BRCDE=BRCD,UIDT=UID,LNERC=XHS16,CC=BEN")
		do FILLIT^LNCAL20(.ln,.ttx,"FORCASTED")
		}
	
	//  Place data in report file structure
 	type Number BALCMP
 	set BALCMP=bal
 	
	if ln.aruf=1 set BALCMP=BALCMP-ln.udbal

	do FILLFILE(BALCMP)

	quit

	
FILLFILE(Number BALIN)
	
	type public Date ENDDATE
	type public String ETC
	
	type Date DATE
	type Number ACTL,ACTBAL,SEQ,TYPE
		
	set (ACTBAL,ACTL)=+BALIN
	set (DATE,SEQ,ETC)=""
	
	do SET(.ACTBAL,,%SystemDate,0)
	
	type DbSet ds=Db.selectDbSet("TMPRPT4","PID=:%ProcessID")
 
        while ds.next() do { 
        	type RecordTMPRPT4 tmprpt4=ds.getRecord("TMPRPT4")                                   

	        type String TMPREC
        	
        	set DATE=tmprpt4.key2
		set SEQ=tmprpt4.key3
		set ETC=tmprpt4.key4
		
		if (DATE>ENDDATE) do Db.delete("TMPRPT4","PID=:%ProcessID") quit           

        	set TMPREC=tmprpt4.data
	        if TMPREC.piece("|",1)="*" set TMPREC.piece("|",1)="|||"
        	do SET(.ACTBAL,.TMPREC,DATE,SEQ,ETC)
		}
	quit
					
SET(Number BAL, String REC, Date DATE, Number SEQ, String ETC)

	// Calculate balance, set into temp table
        
	type public Number CID

	set REC=REC.get()
        
        // Define ETC as a space, if null, to avoid subscript error
        if ETC.get().isNull() set ETC=" "
        
        do CALCBAL^LNCAL20(.BAL,4,.REC)
       
	type RecordTMPRPT4 tmprpt31=Db.getRecord("TMPRPT4","PID=:%ProcessID,KEY1=:CID,KEY2=:DATE,KEY3=:SEQ,KEY4=:ETC",1)
	set tmprpt31.data=REC
	do tmprpt31.save()	
	quit

private LNPROJ(Number CID, String RID, String IO, Number F, Date ENDDATE)

	// Call from batch for activity report automatic generation during DAYEND
	
	type public String VFMQ
	type public Boolean ER

	type String PGM
	
	type RecordLN ln=Db.getRecord("LN","CID=:CID",1)
	
	// Invalid account ~p1
	if ln.getMode()=0 do Runtime.setErrMSG("LN",1259,CID) quit

	do LOAD(.ln,ENDDATE)
	
	if RID.get().isNull() set RID="SCA469"
 
	do ^URID 
 	
 	// Invalid report linkage <<RID>>
	if PGM.isNull() do Runtime.setErrSTBLER("LN","INVLDRPT") quit
 	
	do V0^@PGM
		
	set VFMQ="Q"   
	     
	quit

vSIG()	quit "60460^5221^Sunitha Santhumayor^5463"	// Signature - LTD^TIME^USER^SIZE
