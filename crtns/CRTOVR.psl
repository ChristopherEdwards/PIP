public	CRTOVR(RecordTTX ttx)

	/*

	Authorization Override Utility

	INPUT:	OVR(CID,L1,L2)
		TSPV(SEQ)
		%UCLS
		%UID
	
	OUTPUT:	ER
		SPV(SEQ\1,CID,L1,L2)
	
	Note:	Restriction MXULCLSTR is an exception to normal override
		processing.  For this restriction, the authorizing userclass
		MUST also pass the MXUCLSTR restriction.
	
	---- Revision History ------------------------------------------------
	
	07/14/06 - DESHPANDE S K - CR 20748
		   Modified CRTOVR to use ORIGTM instead of %TRNMODE if ORIGTM
		   is defined else use stored value for Transaction Mode.
		   	
	05/25/06 - ratht - CR 21426
		   Modified the PROC section to protect original value 
		   of GRP from being permanently reset with the loop
		   through OVR array. Removed the declaration of OVRSCR
		   variable since it is not used through out the procedure.
		   
		   
	04/04/06 - arpavc - CR 20198
		   Added code in TRN section to remove blanks from
		   the transaction code string so that it is processed
		   correctly.
		   
	04/01/06 - S.Krishnan - CR 20092
		   In the section OVR modified the declaration of the variable 
		   TSPV to TSPV(,,,).
		   
	02/22/06 - TITOVE - CR 19673
		   Modified FUNING section to prevent undefined on %FN
		   in cases when call comes from the client and also
		   restored original logic and performed light clean up.

	02/01/06 - SmithCD - CR 19343 (16890)
		   Made top public.
	  
	10/03/05 - RussellDS - CR16911
		   Corrected error in OVR.  Code was "if %TRNMODE", should be
		   (if %TRNMODE=1) since %TRNMODE is not boolean and only care
		   about value = 1.  (See older versions.)

	08/23/05 - KELLYP - CR 16972
		   Modified DSP section to use proper DESC* columns when setting
		   up restriction descriptions.  Previous code was using the
		   wrong description column (e.g., OVRLIT.DESC2 for loan
		   transactions instead of OVRLIT.DESC1) so the description was
		   not being displayed in PFW.  Also removed pre-2003 revision
		   history.

	03/05/05 - TITOVE - CR 13291
		   Renamed section NOINT to OVR and cleaned up the logic there
		   and in section WCGRP as part of DBI2 project.  

	*/

	type public Number FPRFLG, ORIGTM, usrfld

	type Number OTRNMODE
	
	if 'ORIGTM.get().isNull() set OTRNMODE = ORIGTM
	else  set OTRNMODE = ttx.getStoredValue("TranMode")

	// If foreign payment reversal CRT must be processed as if batch.
	if OTRNMODE.get()=1,(usrfld.get()=55!(FPRFLG.get())) do PROC(.ttx,0) quit

	do PROC(.ttx,OTRNMODE.get())
	
	quit 
	

PROC(RecordTTX ttx,
     Number OTRNMODE)

	type public Cache %CACHE()
	type public Number ER, FNRFLG
	type public String ET,OVR(),SPV()
	type public String RM = ""
	
	type Number CID,%ER,INDX,%SQ,UID,XCID,OTRNSEQ = ttx.getStoredValue("TranSeq")
	type String CLS,ETC,GRP,ITC,L1,L2,N,M,ORIGGRP,REC,SAVCLS,SAVGRP,UCLS,X
	
	set %SQ=((OTRNSEQ.get() * 1000) \ 1) / 1000
	set ETC=ttx.etc

	if ETC="" set (GRP,CLS)="*"
	else  do {
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")
		set CLS=trn.cls
		set GRP=trn.grp
		}
		
	set SAVCLS=CLS,SAVGRP=GRP
	set ITC=ttx.itc
	set (%ER,INDX)=0
	set (CID,L1,L2)=""
	kill SPV(%SQ)

	for  set CID=OVR(CID).order() quit:CID=""  do {
	
		if 'CID!(CLS'="M") set CLS=SAVCLS,GRP=SAVGRP
		else  if CLS'="*",GRP'="*" do GETDATA(CID,.CLS,.GRP)
	
		for  set L1=OVR(CID,L1).order() quit:L1=""  do {
			for  set L2=OVR(CID,L1,L2).order() quit:L2=""  do {
				
				set ORIGGRP = GRP
				
				if OVR(CID,L1,L2).piece("|",4)="CIF" set GRP="CIF"
				if OVR(CID,L1,L2).piece("|",4)="RPA" set GRP="RPA"

				// Create REC based on override/restriction record
				do WCGRP(L1,GRP,L2,.REC)
				
				if L1'="OVR",$$FUNIGN quit
				
				if ETC'="",$$IGNORE quit 

				do OVR(OTRNMODE.get())
				set GRP = ORIGGRP
				}
			}
		}
	
	// Override required
	if %ER do {
		set ER=1
		set RM=$$^MSG(2123)
		set ET="CRTOVR"
		do ^UTLERR
		}

	kill OVR
	
	quit 
	

OVR(Number OTRNMODE)	// Override Processing	

	

	/*
	   The variable TSPVST indicates the status of an authorization for a
	   particular violation.  If the supervisor array had been defined, TSPV,
	   and the associated userclass was still unable to authorize the
	   violation, this status will be set to 1 and reported back to the
	   client.
	   The logic for Client Teller is to come through first time with TSPV
	   not yet defined (done in PBSTSSP, section SPV), this way %TRNMODE = 1
	   and we set the override info that is reported back to client, where
	   override window is displayed. Once override info is entered by teller,
	   the TSPV array is defined and the code in this section will go through
	   proper authorization processing.
	   For Batch processing, since there is no interaction, we cannot display
	   the override window, thus we go through authorization processing the
	   first time around.
	
	*/
	
	type public Number CID, %ER, %SQ
	type public String ETC, GRP, L1, L2, TSPV(,,,)
	
	type Number ER, TSPVST, UID
	type String REC4, UCLS, X
	
	set (ER,TSPVST) = 0
	
	set UID = %UserID
	set UCLS = %UserClass
	
	if TSPV.data() do {
		if TSPV(%SQ,CID,L1,L2).exists() set X = TSPV(%SQ,CID,L1,L2)
		else  if TSPV(%SQ).data()#10 set X = TSPV(%SQ)
		else  if TSPV("*").data() set X = TSPV("*")
		else  do { quit
			set ER = 1
			do SETOVR("*")
			}

		set UID = X.piece("|",1)
		set UCLS = X.piece("|",2)
		set REC4 = $$WCGRP4(L1,GRP,L2,UCLS)
		if REC4.isNull() set ER = 1
		else  if '$$TRN(REC4) set ER = 1
		set TSPVST = ER
		}

	else  do {	
		// Batch processing
		if (OTRNMODE = 1) set ER = 1 quit
		set REC4 = $$WCGRP4(L1,GRP,L2,UCLS)
		if REC4.isNull() set ER = 1
		if '$$TRN(REC4) set ER = 1
		else  if 'ETC.isNull() set ER = '$$TRN(REC4)
		}
	
	do SETOVR($S(ER:"*",1:UID),TSPVST)
	
	quit
	

SETOVR(String X,
       Number STAT)	// Create override array

	/*
	   ARGUMENTS:
	   . X 		Override User ID 			/TYP=T/REQ/MECH=VAL
	    ("*" = not overridden)
	
	   . STAT 	Supervisor authorization status		/TYP=N/NOREQ/MECH=VAL  
	    If set, it indicates that the supervisor used to authorize
	    a violation does not have the ability to do so.	       		
	
	*/
	
	type public Number CID,ER,%ER,%SQ
	type public String GRP,ITC,L1,L2,OVR(),REC,RM,SPV()
	
	type String SPVREC = ""

	set SPVREC.piece("|",1)=X			// Override User ID
	set SPVREC.piece("|",2)=OVR(CID,L1,L2).piece("|",1) // Override Reason Value
	set SPVREC.piece("|",3)=CID			// Account Number
	set SPVREC.piece("|",4)=GRP			// Group
	set SPVREC.piece("|",5)=STAT.get()		// Supervisor Authorization Status
	set SPVREC.piece("|",6)=ITC.extract(10)		// Offline Indicator
	
	set SPV(%SQ,CID,L1,L2)=SPVREC
	
	if ER set %ER=1,RM(RM("").order(-1)+1)=$$DSP(REC)

	quit

	        	
DSP(String REC)	// Return display message (override description)

	/*
	ARGUMENTS:

	. REC	Override record	/TYP=T/REQ
	
	*/
	
	type public Number CID
	type public String CLS,L1,L2,OVR()
	
	type String M,X
	set M=""
	
	if L1="RFLG" do { quit M
		set M=OVR(CID,L1,L2).piece("|",1)
		if M="" set M=REC.piece("|",1)
		set M=L2_$justify("",5-L2.length())_M
		}
	
	if L1="OVR" do {
		// Descriptions for OVR
		type RecordOVRLIT ovrlit=Db.getRecord("OVRLIT","OVR=:L2",1)
		if 'ovrlit.getMode() quit
		
		if CLS="D" set M=ovrlit.desc
		else  if CLS="L" set M=ovrlit.desc1
		else  if CLS="*" set M=ovrlit.desc2
		else  if CLS="M" set M=ovrlit.desc3
		}

	if M="" set M=REC.piece("|",1)
	set X=M.find("<"_L2_">")
	if X set M=M.extract(1,X-L2.length()-3)_OVR(CID,L1,L2)_M.extract(X,99)
	quit M

IGNORE()
	/*
	Transaction codes contained at this level do not apply
	to the override/restriction and do not require an override.

	Required Input: REC
	   	
	*/
	type public String REC
	type String X
	
	set X=REC.get().piece("|",2,99)
	
	set X=$$RTBAR^%ZFUNC(X)
	
	set X=X.translate("|",",")
	
	if X.isNull() quit 0
	
	quit $$TRN(X)
	

public	TRN(String X)	// Transaction code validation

	/*
	   This line tag called from screen CRTOVR
	   
	   Parameters:  X - Transaction code string (comma separated).
	
	   Inputs:	ETC - External Transaction Code
	   		ITC - Internal Transaction Code
	   
	   Returns 0 if tran code is not found in string 'X' and;
	                tran code is a debit and "DR*" not found in 'X' or;
	                tran code is a credit and "CR*" not found in 'X'.
	
	   Returns 1 if tran code is null or;
	                tran code is found in string 'X' or;
	                tran code is a debit and "DR*" found in 'X' or;
	                tran code is a credit and "CR*" found in 'X'.
	
	*/

	type public String ETC,ITC
	
	set X=X.translate(" ","")  // Replace blanks in the string
	
	if ETC.get()="" quit 1
	
	if X["*" quit $$XPLODE(X,.ETC)
	
	set X=","_X_","

	if X[(","_ETC_",") quit 1
	
	if 'ITC,X[",DR*," quit 1
	
	if ITC,X[",CR*," quit 1

	quit 0
	
	
XPLODE(String list,
       String etc)	//  Parse list for wildcard tran codes and validate

	type Number piece = 0,found = 0
	type String longlist
	type String item = "",remainng = ""
	
	for piece=1:1:$L(list,",") quit:found!(list="")  do {
		set item=list.piece(",",piece)	
		if item="" quit 
		if item'["*" set found=(item=etc) quit 
		if item="DR*" set found=$$ALLDRCR^UTLASTK(item,.etc) quit 
		if item="CR*" set found=$$ALLDRCR^UTLASTK(item,.etc) quit 
	
		set longlist=$$TRN^UTLASTK(item,etc,.found)
		if found quit 
		set remainng=list.piece(piece+1,list.length(",")) quit:remainng["*" 
		if ","_etc_","[(","_remainng_",") set found=1
		}
	
	quit found


WCGRP(String L1,		// Override Type (OVR or RFLG)
      String GRP,		// Product Group
      String OVR,		// Override Name
      String REC)		// Restriction Data Array

	/*
	   Check user-table for existence of group wild card ("*") at the
	   second key level and return the appropriate record.
	   
	   Returns REC array, which represents the restrictions record:
	   UTBLRFLG:	DESC|TRIG1|TRIG2|TRIG3|TRIG4|TARES|FARES
	   UTBLOVR:	DESC|TRIG1|TRIG2|TRIG3|TRIG4|DUMP

	*/

	if L1 = "OVR" do {

		type RecordUTBLOVR utblovr = Db.getRecord("UTBLOVR", "GRP = :GRP, OVR = :OVR", 1)
		if utblovr.getMode() = 0 do { quit

			set GRP = "*"
			type RecordUTBLOVR utblovr = Db.getRecord("UTBLOVR", "GRP = :GRP, OVR = :OVR", 1)
			set REC = utblovr.desc_"|"_utblovr.trig1_"|"_utblovr.trig2_"|"_utblovr.trig3_"|"
			set REC = REC_utblovr.trig4_"|"_utblovr.dump
			}

		set REC = utblovr.desc_"|"_utblovr.trig1_"|"_utblovr.trig2_"|"_utblovr.trig3_"|"
		set REC = REC_utblovr.trig4_"|"_utblovr.dump
		}

	if L1 = "RFLG" do {
	
		type RecordUTBLRFLG utblrflg = Db.getRecord("UTBLRFLG", "GRP = :GRP, RFLG = :OVR", 1)	
		if utblrflg.getMode() = 0 do { quit

			set GRP = "*"
			type RecordUTBLRFLG utblrflg=Db.getRecord("UTBLRFLG", "GRP = :GRP, RFLG = :OVR", 1)
			set REC = utblrflg.desc_"|"_utblrflg.trig1_"|"_utblrflg.trig2_"|"_utblrflg.trig3_"|"
			set REC = REC_utblrflg.trig4_"|"_utblrflg.tares_"|"_utblrflg.fares
			}

		set REC = utblrflg.desc_"|"_utblrflg.trig1_"|"_utblrflg.trig2_"|"_utblrflg.trig3_"|"
		set REC = REC_utblrflg.trig4_"|"_utblrflg.tares_"|"_utblrflg.fares
		}		

	quit
	

WCGRP4(String L1,		// Override Type (OVR or RFLG)
       String GRP,		// Product Group
       String OVR,		// Override Name
       String UCLS)		// User Class

	/*
	   Check user-table for existence of a product group wild card ("*")
	   at the second key level and the userclass wild card at the fourth
	   key level and return the appropriate record
	
	*/
	type String REC = ""
	type literal String STAR = "*"
	
	if L1 = "OVR" do {

		do SETRP4A(GRP,OVR,UCLS) quit:REC '= ""
		do SETRP4A(STAR,OVR,UCLS) quit:REC '= ""
		do SETRP4A(GRP,OVR,STAR) quit:REC '= ""
		do SETRP4A(STAR,OVR,STAR) quit:REC '= ""
		}

	if L1 = "RFLG" do {
	
		do SETRP4B(GRP,OVR,UCLS) quit:REC '= ""
		do SETRP4B(STAR,OVR,UCLS) quit:REC '= ""
		do SETRP4B(GRP,OVR,STAR) quit:REC '= ""
		do SETRP4B(STAR,OVR,STAR) quit:REC '= ""
		}		

	quit REC
	

SETRP4A(String grp,		// Product Group
        String ovr,		// Override Name
        String ucls)		// User Class

	type public String REC

	type RecordUTBLOVR1 utblovr = Db.getRecord("UTBLOVR1", "GRP = :grp, OVR = :ovr, UCLS = :ucls", 1)

	set REC = utblovr.trncds

	quit
	

SETRP4B(String grp,		// Product Group
        String rflg,		// Override Name
        String ucls)		// User Class	

	type public String REC

	type RecordUTBLRFL1 utblrflg = Db.getRecord("UTBLRFL1", "GRP = :grp, RFLG = :rflg, UCLS = :ucls", 1)

	set REC = utblrflg.trncds

	quit


public	MXUGRP(String CRCD,
	       String UCLS,
	       String GRP)

	/*
	Check user-table for existence of a group wild card.  If found
	return "*", else return NGRP.  This function is the compliment to
	$$GRP.  It references file UTBLMXUCLS2 instead of UTBLOVR.
	*/

	type String NGRP

	if CRCD.isNull() set CRCD = %SystemCurrency
	
	if UCLS.isNull() set UCLS = %UserClass
	
	if Db.isDefined("UTBLMXUCLS2","CRCD=:CRCD,UCLS=:UCLS,GRP=:GRP") set NGRP = GRP
	
	else  if Db.isDefined("UTBLMXUCLS2","CRCD=:CRCD,UCLS=:UCLS,GRP='*'") set NGRP = "*"
	
	else  set NGRP = GRP
	
	quit NGRP
	

FUNIGN()
	/*
	   Functions contained at this level do not apply
	   to the override/restriction and do not require an override.	
	*/

	type public Number FNRFLG	// Indicates call from FRFLG procedure
	type public String %FN, GRP, L2, REC
	type Boolean FARES, TARES, VD = 0

	set TARES = REC.piece("|",6)
	set FARES = REC.piece("|",7)
	
	if FNRFLG.get() do {
		
		if 'FARES set VD = 1 quit
		
		// Processing not called by one of the Host functions
		if %FN.get().isNull() quit
		
		if Db.isDefined("UTBLRFLG2","GRP=:GRP,RFLG=:L2,FNIG=:%FN") set VD = 1
		}
	
	if 'FNRFLG.get(),'TARES set VD = 1
	
	quit VD
	

GETDATA(Number CID,
	String CLS,
	String GRP)

	type public String SAVCLS, SAVGRP
	
	type RecordACN acn = Db.getRecord("ACN", "CID = :CID", 1)
	
	if acn.getMode() = 0 set CLS = SAVCLS,GRP = SAVGRP quit
	
	set CLS = acn.cls
	
	set GRP = acn.grp
	
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60466^40320^Shriram Deshpande^13190"	// Signature - LTD^TIME^USER^SIZE
