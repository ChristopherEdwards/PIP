DBSDFF(RecordDBTBL1D dbtbl1d, String vpar, Boolean vparNorm) // DBTBL1D - Data Dictionary Data Items Filer
	// Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 11/09/2007 15:13 - chenardp
	// Generated from DATA-QWIK schema in: /profile/v72framework_gtm  by: /v72framework_gtmlx/crtns/DBSFILB.obj

	// Data Dictionary Data Items (39)             09/19/2006
	// Trigger Definition (4)                      07/31/2007
	/*
		vpar      Runtime qualifiers:      /NOREQ/MECH=REFARR:R

		/[NO]CASDEL   - Cascade delete
		/[NO]FRMFILER - Called from another filer
		/[NO]INDEX    - Update Indexes
		/[NO]JOURNAL  - Journal update
		/[NO]TRIGAFT  - After update triggers
		/[NO]TRIGBEF  - Before update triggers
		/[NO]UPDATE   - Update primary table
		/[NO]VALDD    - Validate column values
		/[NO]VALFK    - Validate foreign keys
		/[NO]VALREQ   - Validate not null values
		/[NO]VALRI    - Validate transaction integrity
		/[NO]VALST    - Validate database state
	*/

	type Public Number ER = 0
	type Public String RM

	type public String verrors()

	catch fERROR {
		if fERROR.type="%PSL-E-DBFILER" do {
			set ER = 1
			set RM = fERROR.description
		}
		else  throw fERROR
	}
	type String vx(), vxins()                              // audit column array
	type Number %O = dbtbl1d.getMode()                     // Processing mode
	set vpar = vpar.get()                                  // Initialize vpar

	if %O = 0 do AUDIT^UCUTILN(dbtbl1d,.vxins(),1,"|")
	if %O = 1 do AUDIT^UCUTILN(dbtbl1d,.vx(),1,"|")

	if 'vparNorm.get() set vpar = $$initPar^UCUTILN(vpar)  // Run-time qualifiers

	// Define local variables for access keys for legacy triggers
	type String %LIBS = dbtbl1d.%libs
	type String FID = dbtbl1d.fid
	type String DI = dbtbl1d.di

	if %O = 0 do { quit                                    // Create record control block
		do vinit                                              // Initialize column values
		if vpar["/TRIGBEF/" do VBI                            // Before insert triggers
		if vpar["/VALREQ/" do vreqn                           // Check required
		if vpar["/VALDD/" do vddver                           // Check values
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 1 do { quit                                    // Update record control block
		if vx("%LIBS").exists()!vx("FID").exists()!vx("DI").exists() do vkchged quit // Primary key changed
		if vpar["/TRIGBEF/" do VBU                            // Before update triggers
		if vpar["/VALREQ/" do vrequ                           // Check required
		if vpar["/VALDD/" do VDDUX^DBSFILER("DBTBL1D",.vx)
		set %O = 1 do vexec
		if vpar["/TRIGAFT/" do VAU                            // After update triggers
	}

	if %O = 2 do { quit                                    // Verify record control block
		if vpar["/VALREQ/" do vreqn                           // Check required
		set vpar = $$setPar^UCUTILN(vpar,"NOJOURNAL/NOUPDATE")
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 3 do { quit                                    // Delete record control block
		quit:'Db.isDefined("DBTBL1D","%LIBS = :dbtbl1d.%libs and FID = :dbtbl1d.fid and DI = :dbtbl1d.di") // No record exists
		do vdelete(0)
		if vpar["/TRIGAFT/" do VAD                            // After delete triggers
	}

	quit

vlegacy(Number %ProcessMode,String vpar) // Legacy interface (^DBSDF9 for %O=0, EXT^DBSFILER for %O = 2)

	type public String %LIBS
	type public String FID
	type public String DI

	type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D","%LIBS=:%LIBS,FID=:FID,DI=:DI")
	if (%ProcessMode = 2) do {
		do dbtbl1d.setMode(2)

		do DBSDFF(dbtbl1d,vpar)
	}
	else  do VINDEX(dbtbl1d)

	quit

vLITCHK() quit 0 // Table does not have columns involved in literals


vexec // Execute transaction

	type public Number %O
	type public String vpar,vobj(),vx(),vxins()

	type public RecordDBTBL1D dbtbl1d

	type String vERRMSG

	if vpar["/VALST/" if '(''Db.isDefined("DBTBL1D","%LIBS = :dbtbl1d.%libs and FID = :dbtbl1d.fid and DI = :dbtbl1d.di") = ''%O) set vERRMSG = $$^MSG($select(%O:7932,1:2327)) throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	if vpar["/VALFK/" do CHKFKS                            // Check foreign keys
	if vpar["/VALRI/" do VFKEYS                            // Foreign key definition

	if vpar'["/NOUPDATE/" do {

		set dbtbl1d.LTD = %CurrentDate
		if 'dbtbl1d.isChanged("USER", "USER") set dbtbl1d.USER = %UserName
		if %O = 0, vpar'["/NOLOG/" do ^DBSLOGIT(dbtbl1d,%O,.vxins())
		if %O = 1, vpar'["/NOLOG/" do ^DBSLOGIT(dbtbl1d,%O,.vx())

		// Allow global reference and M source code
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
		#BYPASS
		if $D(vobj(dbtbl1d)) S ^DBTBL(vobj(dbtbl1d,-3),1,vobj(dbtbl1d,-4),9,vobj(dbtbl1d,-5))=vobj(dbtbl1d)
		#ENDBYPASS
	}

	if vpar["/INDEX/",'(%O = 1)!'vx("").order().isNull() do VINDEX(.dbtbl1d) // Update Index files

	quit

vdelete(Boolean vkeychg) // Record Delete

	type public String vobj(),vpar
	type public RecordDBTBL1D dbtbl1d

	if vpar["/INDEX/" do VINDEX(.dbtbl1d)                  // Delete index entries
	if vpar'["/NOLOG/" do ^DBSLOGIT(dbtbl1d,3)

	// Allow global reference - Delete record
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	ZWI ^DBTBL(vobj(dbtbl1d,-3),1,vobj(dbtbl1d,-4),9,vobj(dbtbl1d,-5))
	#ENDBYPASS
	quit


vinit // Initialize default values

	type public RecordDBTBL1D dbtbl1d

	// Type local variables for access keys for defaults
	type public String %LIBS
	type public String FID
	type public String DI

	if dbtbl1d.ismaster.isNull() set dbtbl1d.ismaster = 0  // ismaster
	if dbtbl1d.itp.isNull() set dbtbl1d.itp = "S"          // itp
	if dbtbl1d.nullind.isNull() set dbtbl1d.nullind = 0    // nullind
	if dbtbl1d.req.isNull() set dbtbl1d.req = 0            // req
	if dbtbl1d.srl.isNull() set dbtbl1d.srl = 0            // srl
	if dbtbl1d.typ.isNull() set dbtbl1d.typ = "T"          // typ
	if dbtbl1d.val4ext.isNull() set dbtbl1d.val4ext = 0    // val4ext
	quit


vreqn // Validate required data items

	type public RecordDBTBL1D dbtbl1d

	if dbtbl1d.des.isNull() do vreqerr("DES") quit
	if dbtbl1d.ismaster.isNull() do vreqerr("ISMASTER") quit
	if dbtbl1d.nullind.isNull() do vreqerr("NULLIND") quit
	if dbtbl1d.req.isNull() do vreqerr("REQ") quit
	if dbtbl1d.srl.isNull() do vreqerr("SRL") quit
	if dbtbl1d.typ.isNull() do vreqerr("TYP") quit
	if dbtbl1d.val4ext.isNull() do vreqerr("VAL4EXT") quit
	quit

vrequ // Valid required columns on update


	type public String vx()
	type public RecordDBTBL1D dbtbl1d

	if dbtbl1d.%libs.isNull() do vreqerr("%LIBS") quit
	if dbtbl1d.fid.isNull() do vreqerr("FID") quit
	if dbtbl1d.di.isNull() do vreqerr("DI") quit

		if vx("DES").exists(),dbtbl1d.des.isNull() do vreqerr("DES") quit
		if vx("ISMASTER").exists(),dbtbl1d.ismaster.isNull() do vreqerr("ISMASTER") quit
		if vx("NULLIND").exists(),dbtbl1d.nullind.isNull() do vreqerr("NULLIND") quit
		if vx("REQ").exists(),dbtbl1d.req.isNull() do vreqerr("REQ") quit
		if vx("SRL").exists(),dbtbl1d.srl.isNull() do vreqerr("SRL") quit
		if vx("TYP").exists(),dbtbl1d.typ.isNull() do vreqerr("TYP") quit
		if vx("VAL4EXT").exists(),dbtbl1d.val4ext.isNull() do vreqerr("VAL4EXT") quit
	quit

vreqerr(di) // Required error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("DBTBL1D","MSG",1767,"DBTBL1D."_di)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit


VFKEYS // Foreign keys

	type public String vfkey(),vpar

	type public RecordDBTBL1D dbtbl1d
	if 'dbtbl1d.fid.isNull() set vfkey("^DBTBL("_""""_dbtbl1d.%libs_""""_","_1_","_""""_dbtbl1d.fid_""""_")")="DBTBL1D(%LIBS,FID) -> DBTBL1"
	quit

CHKFKS   // Check foreign keys when not under buffer


	type public RecordDBTBL1D dbtbl1d
	type public Number %O
	type String vERRMSG

	if 'Db.isDefined("DBTBL1",":dbtbl1d.%libs,:dbtbl1d.fid") set vERRMSG = $$^MSG(8563,"DBTBL1D(%LIBS,FID) -> DBTBL1") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	quit


VAD //
	type public Number ER = 0
	type public String vx(),RM
	do vad1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordDBTBL1D dbtbl1d
	do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(dbtbl1d,.vx(),1,"|")
	quit


vad1 // Trigger AFTER_DELETE - After Delete (remove reqd and dft index)

	type public RecordDBTBL1D dbtbl1d
	/* 
	---- Revision History---------------------------------------------------
	04/17/06 - RussellDS - CR20967
		   Code to delete from sub-type tables was duplicated.  Remove
		   first set, eliminating call to obsolete DBSDF1.
	
	02/22/06 - RussellDS - CR19723
		   Corrected invalid reference to dbtbl1.typ to make dbtbl1d.
		   
	02/15/06 - RussellDS - CR19556
		   Add coding to deal with logicals now being required and
		   having a default value..
		   
	11/19/05 - RussellDS - CR18065
		   Fix PSL warning on rs declared more than once.  Clean up
		   some code.
		   
		   Removed old revision history.
	------------------------------------------------------------------------
	
	NOTE:  New logicals will have the required flag and default values set,
	       but old logicals may not, so need to handle them specifically
	*/


	// Delete this data item from its descendants
	
	type String ZVAL
	
	quit:(dbtbl1d.di = " ") 

	// Remove entry from required and default list
	type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:dbtbl1d.fid",1)
	
	if dbtbl1d.req ! (dbtbl1d.typ = "L") do {
		
		set ZVAL = dbtbl1.listreq
		do remitem(dbtbl1d.di, .ZVAL)
		set dbtbl1.listreq = ZVAL
	}

	if 'dbtbl1d.dft.isNull() ! (dbtbl1d.typ = "L") do {
	
		set ZVAL = dbtbl1.listdft
		do remitem(dbtbl1d.di, .ZVAL)
		set dbtbl1.listdft = ZVAL
	}
		
	set dbtbl1.ltd = %CurrentDate
	do dbtbl1.save()

	// Delete this data item from its descendants
	type ResultSet rs = Db.select("FID", "DBTBL1","%LIBS='SYSDEV' AND PARFID=:dbtbl1d.fid")
	
	while rs.next() do {

		type String SUBFID
		
		set SUBFID = rs.getCol("FID")
		
		do Db.delete("DBTBL1D", "%LIBS='SYSDEV' AND FID=:SUBFID AND DI=:dbtbl1d.di")
	}

	quit  

vai1 // Trigger AFTER_INSERT - After Insert

	type public RecordDBTBL1D dbtbl1d
	/*
	---- Revision History -------------------------------------------------
	04/18/06 - RussellDS - CR20967
		   Changed DSTMDD call from obsolete DBSMDD to DBSDF.
		   
		   Fix setMode location in code.
		   
	11/19/05 - RussellDS - CR18065
		   Eliminate use of obsolete table DBTBLMDD.
		   
		   Fix various PSL warnings.
		   
		   Removed old revision history.
	*/
	
	type public String DI, FID
	
	// If this is a Master Dictionary, distribute changes to everyone
	type String ZDI, ZFID, ZVAL
	
	type ResultSet rs=Db.select("MDD","DBTBL1D","%LIBS='SYSDEV' AND MDDFID=:FID AND MDD=:DI") 

	if rs.next() do DSTMDD^DBSDF(FID,DI)

	// Copy this data item to its descendants
	set ZFID=dbtbl1d.fid
	set ZDI=dbtbl1d.di
	 
	type RecordDBTBL1D sub = dbtbl1d.copy()

	type ResultSet rs2 = Db.select("FID","DBTBL1","%LIBS='SYSDEV' AND PARFID=:ZFID")
	
	while rs2.next()  do {
		
		// copy data item to sub file
		set sub.fid = rs2.getCol("FID")
		
		do sub.setMode(0)
		do sub.save()
	}
	
	// Check required indicator (node 102)
	quit:(dbtbl1d.di = " ") 

	if dbtbl1d.req do {
		
		// Dummy key
		quit:((DI.extract(1)="""") ! (DI ? 1N.E))
		
		type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:FID")
		
		set ZVAL = dbtbl1.listreq

		// Add it to the list
		do additem(dbtbl1d.di,.ZVAL,.dbtbl1d)
		
		set dbtbl1.listreq = ZVAL
		
		do dbtbl1.save()
	}

	// Check items with default value (node 101)
	if 'dbtbl1d.dft.isNull() do {
	
		type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:FID")
		
		set ZVAL = dbtbl1.listdft
	
		do additem(dbtbl1d.di,.ZVAL,.dbtbl1d)
		
		set dbtbl1.listdft = ZVAL
		
		do dbtbl1.save()
	}

	quit
	

additem(String item,
	String list,
	RecordDBTBL1D dbtbl1d)

	type Number i
	type String z

	if list.isNull() set list = item quit
	
	// Already in the list
	if {List}list.contains(item) quit

	for i = 1:1:list.length(",") set z(list.piece(",", i)) = ""
	
	// Add it to the list
	set z(item) = ""
	set (i, list) = ""
	for  set i = z(i).order() quit:i.isNull()  set list = list_","_i
	set list = list.extract(2, list.length())
	
	quit
	

remitem(String item,
	String list,
	RecordDBTBL1D dbtbl1d)

	// Not in the list
	if '{List}list.contains(item) quit

	set list = ","_list_","
	set item = ","_item_","
	
	// Remove it from the list
	set list = list.piece(item, 1)_","_list.piece(item, 2, 99)
	
	// Remove extra comma
	set list = list.extract(2, list.length()-1)
	
	quit

vau1 // Trigger AFTER_UPDATE - After Update

	type public RecordDBTBL1D dbtbl1d
	/* ---- Revision History------------------------------------------------
	04/25/06 - RussellDS - CR20967
		   Changed DSTMDD call from obsolete DBSMDD to DBSDF.
	
	02/15/06 - CR19556
		   Add coding to deal with logicals now being required and
		   having a default value.
		   
	11/19/05 - RussellDS - CR18065
		   Eliminate use of obsolete table DBTBLMDD.
		   
		   Fix various PSL warnings.
		   
		   Removed old revision history.
	*/

	type public String DI, FID

	type String ZDI, ZFID, ZVAL
	
	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:FID")
	
	set dbtbl1.ltd = %CurrentDate
	
	// Add or remove from the required data item list
	if (dbtbl1d.di '= " "), (dbtbl1d.req.oldVal '= dbtbl1d.req) do {
		
		// Required list
		set ZVAL=dbtbl1.listreq
		
		if dbtbl1d.req ! (dbtbl1d.typ = "L") do {
			
			do additem(dbtbl1d.di,.ZVAL)
		}
		else  do remitem(dbtbl1d.di,.ZVAL)
		
		set dbtbl1.listreq = ZVAL
	}
	
	// Add or remove from the default list
	if (dbtbl1d.di '= " "), (dbtbl1d.dft.oldVal '= dbtbl1d.dft) do {
		
		set ZVAL=dbtbl1.listdft
		
		if 'dbtbl1d.dft.isNull() ! (dbtbl1d.typ = "L") do {
		
			do additem(dbtbl1d.di,.ZVAL)
		}
		else  do remitem(dbtbl1d.di,.ZVAL)
		
		set dbtbl1.listdft=ZVAL
	}
		
	do dbtbl1.save()
	
	// If this is a Master Dictionary, distribute changes to everyone
	type ResultSet rs = Db.select("MDD", "DBTBL1D", "%LIBS='SYSDEV' AND MDDFID=:FID AND MDD=:DI") 

	if rs.next() do DSTMDD^DBSDF(FID,DI)

							// Copy this data item to its descendants
	
	set ZFID = dbtbl1d.fid
	set ZDI = dbtbl1d.di
	
	type RecordDBTBL1D sub = dbtbl1d.copy()
	
	type ResultSet rs2 = Db.select("FID","DBTBL1","%LIBS='SYSDEV' AND PARFID=:ZFID")
	
	while rs2.next()  do {
		
		set sub.fid = rs2.getCol("FID")    // copy data item to sub file
		do sub.save()
	}	

	quit

vbi1 // Trigger BEFORE_UPDATE - Before Insert/Update

	do vbu1

	quit

vbu1 // Trigger BEFORE_UPDATE - Before Insert/Update

	type public RecordDBTBL1D dbtbl1d
	do dbtbl1d.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------
	07/30/07 - RussellDS - CR28507
		   Eliminated upate of user and date columns.  This is managed
		   by the audit function of the filer.
		   
		   Removed old revision history.
		   
	08/31/06 - RussellDS - CR22719
		   Add code to ensure that if a non-literal default value is
		   provided, the table has a filer.  Otherwise, it's an error.
		   
	02/16/06 - RussellDS - CR19065
		   Remove references to obsolete column DBTBL1D.DEL.
	
	02/13/06 - RussellDS - CR19556
		   Added logic to set default value and required for logicals.
	*/
	
	type public String FID, RM
	type public Number ER
	
	type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:FID")
	
	if (dbtbl1d.typ.oldVal'=dbtbl1d.typ)!((dbtbl1d.len.oldVal'=dbtbl1d.len)) do FKEYCHK(.dbtbl1d) quit:ER 
	
	/* In the past, logical data types could have values of 0, 1, or null.
	   This has created problems for database indepedence, so we've made a
	   change to require logicals to be either 0 or 1, be required, and have
	   a default value.  Because there are old column definitions, we will
	   leave those alone in this regard.  However, new definitions or changes
	   in data type to logical must meet these requirements.  UCXDD.proc has
	   been modified to return logicals as required and with a default,
	   regardless of the schema definition for older columns.
	*/
	if (dbtbl1d.typ = "L"),((%ProcessMode = 0) ! (dbtbl1d.typ.oldVal '= "L")) do {
	
		set dbtbl1d.req = 1
		if dbtbl1d.dft.isNull() set dbtbl1d.dft = 0
	}
	
	if 'dbtbl1d.dft.isNull(), 'dbtbl1d.dft.isLiteral(), dbtbl1.udfile.isNull() do {
		
		set ER = 1
		set RM = "Non-literal default values require a filer for the table"
	}
	
	quit
	

FKEYCHK(RecordDBTBL1D dbtbl1d, RecordDBTBL1 dbtbl1) // check foreign key relationship

	type Public String DI,FID,RM
	type Public Number ER

	type String FKEYS,TESTDI,X
	
	set TESTDI=","_DI_","

	type ResultSet rs=Db.select("FID,TBLREF,FKEYS","DBTBL1F","( TBLREF=:FID OR FID=:FID ) AND %LIBS='SYSDEV'")

	while rs.next()  set FKEYS=rs.getRow()  do { quit:ER  
		set FKEYS=","_$TR(FKEYS,$C(9),",")_","
		if FKEYS'[TESTDI quit 
		set ER=1
		if $P(FKEYS,",",2)'=FID set RM=$$^MSG(3963,$P(FKEYS,",",2))
		else  set RM=$$^MSG(3963,$P(FKEYS,",",3))
		}
	quit 


vddver // Validate data dictionary attributes

	type public Number %O
	type public String vpar,vx()

	type String vRM,X
	type public RecordDBTBL1D dbtbl1d

	if dbtbl1d.%libs.length()>12 set vRM = $$^MSG(1076,12) do vdderr("%LIBS", vRM) quit
	set X = dbtbl1d.fid if 'X.isNull() set vRM = $$VAL^DBSVER("U",256,1,,"X?1A.AN!(X?1""%"".AN)!(X?.A.""_"".E)",,,0) if 'vRM.isNull() set vRM = $$^MSG(979,"DBTBL1D.FID"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = dbtbl1d.di if 'X.isNull() set vRM = $$VAL^DBSVER("U",256,1,,"X?1""%"".AN!(X?.A.""_"".E)",,,0) if 'vRM.isNull() set vRM = $$^MSG(979,"DBTBL1D.DI"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	if dbtbl1d.alias.length()>40 set vRM = $$^MSG(1076,40) do vdderr("ALIAS", vRM) quit
	if dbtbl1d.cmp.length()>255 set vRM = $$^MSG(1076,255) do vdderr("CMP", vRM) quit
	set X = dbtbl1d.cnv if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("CNV", vRM) quit
	set X = dbtbl1d.dec if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DEC", vRM) quit
	set X = dbtbl1d.del if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DEL", vRM) quit
	if dbtbl1d.depostp.length()>255 set vRM = $$^MSG(1076,255) do vdderr("DEPOSTP", vRM) quit
	if dbtbl1d.deprep.length()>255 set vRM = $$^MSG(1076,255) do vdderr("DEPREP", vRM) quit
	if dbtbl1d.des.length()>40 set vRM = $$^MSG(1076,40) do vdderr("DES", vRM) quit
	if dbtbl1d.dft.length()>58 set vRM = $$^MSG(1076,58) do vdderr("DFT", vRM) quit
	if dbtbl1d.dom.length()>20 set vRM = $$^MSG(1076,20) do vdderr("DOM", vRM) quit
	if '("01"[dbtbl1d.ISMASTER) set vRM=$$^MSG(742,"L") do vdderr("ISMASTER", vRM) quit
	set X = dbtbl1d.itp if 'X.isNull(),'{List}"S,N,B1,B2,B3,B4".contains(X) set vRM = $$^MSG(1485,X) do vdderr("ITP", vRM) quit
	set X = dbtbl1d.len if 'X.isNull(),X'?1.5N,X'?1"-"1.4N set vRM=$$^MSG(742,"N") do vdderr("LEN", vRM) quit
	set X = dbtbl1d.ltd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LTD", vRM) quit
	if dbtbl1d.max.length()>25 set vRM = $$^MSG(1076,25) do vdderr("MAX", vRM) quit
	if dbtbl1d.mdd.length()>12 set vRM = $$^MSG(1076,12) do vdderr("MDD", vRM) quit
	if dbtbl1d.min.length()>25 set vRM = $$^MSG(1076,25) do vdderr("MIN", vRM) quit
	if dbtbl1d.nod.length()>26 set vRM = $$^MSG(1076,26) do vdderr("NOD", vRM) quit
	if '("01"[dbtbl1d.NULLIND) set vRM=$$^MSG(742,"L") do vdderr("NULLIND", vRM) quit
	set X = dbtbl1d.pos if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("POS", vRM) quit
	if dbtbl1d.ptn.length()>60 set vRM = $$^MSG(1076,60) do vdderr("PTN", vRM) quit
	if '("01"[dbtbl1d.REQ) set vRM=$$^MSG(742,"L") do vdderr("REQ", vRM) quit
	if dbtbl1d.rhd.length()>40 set vRM = $$^MSG(1076,40) do vdderr("RHD", vRM) quit
	if dbtbl1d.sfd.length()>20 set vRM = $$^MSG(1076,20) do vdderr("SFD", vRM) quit
	set X = dbtbl1d.sfd1 if 'X.isNull(),'Db.isDefined("DBCTLDELIM","X") set vRM = $$^MSG(1485,X) do vdderr("SFD1", vRM) quit
	set X = dbtbl1d.sfd2 if 'X.isNull(),'Db.isDefined("DBCTLDELIM","X") set vRM = $$^MSG(1485,X) do vdderr("SFD2", vRM) quit
	set X = dbtbl1d.sfp if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("SFP", vRM) quit
	if dbtbl1d.sft.length()>12 set vRM = $$^MSG(1076,12) do vdderr("SFT", vRM) quit
	set X = dbtbl1d.siz if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("SIZ", vRM) quit
	if '("01"[dbtbl1d.SRL) set vRM=$$^MSG(742,"L") do vdderr("SRL", vRM) quit
	if dbtbl1d.tbl.length()>255 set vRM = $$^MSG(1076,255) do vdderr("TBL", vRM) quit
	set X = dbtbl1d.typ if 'X.isNull(),'Db.isDefined("DBCTLDVFM","X") set vRM = $$^MSG(1485,X) do vdderr("TYP", vRM) quit
	if dbtbl1d.user.length()>20 set vRM = $$^MSG(1076,20) do vdderr("USER", vRM) quit
	if '("01"[dbtbl1d.VAL4EXT) set vRM=$$^MSG(742,"L") do vdderr("VAL4EXT", vRM) quit
	if dbtbl1d.xpo.length()>58 set vRM = $$^MSG(1076,58) do vdderr("XPO", vRM) quit
	if dbtbl1d.xpr.length()>58 set vRM = $$^MSG(1076,58) do vdderr("XPR", vRM) quit
	quit

vdderr(di, vRM) // Column attribute error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("DBTBL1D","MSG",979,"DBTBL1D."_di_" "_vRM)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit


public VINDEX(RecordDBTBL1D dbtbl1d) // Update index entries

		type Public String vx()

	if %ProcessMode=1 do { quit
		if vx("DOM").exists() do vi1(.dbtbl1d)
		if vx("MDD").exists() do vi2(.dbtbl1d)
		if vx("NOD").exists()!vx("POS").exists() do vi3(.dbtbl1d)
	}
	do vi1(.dbtbl1d)
	do vi2(.dbtbl1d)
	do vi3(.dbtbl1d)

	quit
	

vi1(RecordDBTBL1D dbtbl1d) // Maintain DOMAIN index entries (Domain Name)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = dbtbl1d.%libs
	type String v4 = dbtbl1d.dom
	if v4.isNull() set v4=(PSL.maxCharValue-1).char()
	type String v5 = dbtbl1d.fid
	type String v6 = dbtbl1d.di

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if $D(^DBTBL(vobj(dbtbl1d,-3),1,vobj(dbtbl1d,-4),9,vobj(dbtbl1d,-5)))#2,'$D(^DBINDX(v1,"DOM","PBS",v4,v5,v6)) do vidxerr("DOMAIN")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DBINDX(v1,"DOM","PBS",v4,v5,v6)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("DOM").exists() set v4=vx("DOM").piece("|",1) set:v4.isNull() v4=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DBINDX(v1,"DOM","PBS",v4,v5,v6)
	#ENDBYPASS
	quit

vi2(RecordDBTBL1D dbtbl1d) // Maintain MDD index entries (Master Dictionary Pointer)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = dbtbl1d.%libs
	type String v3 = dbtbl1d.mdd
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = dbtbl1d.fid
	type String v5 = dbtbl1d.di

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if $D(^DBTBL(vobj(dbtbl1d,-3),1,vobj(dbtbl1d,-4),9,vobj(dbtbl1d,-5)))#2,'$D(^DBINDX(v1,"MDD",v3,v4,v5)) do vidxerr("MDD")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DBINDX(v1,"MDD",v3,v4,v5)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("MDD").exists() set v3=vx("MDD").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DBINDX(v1,"MDD",v3,v4,v5)
	#ENDBYPASS
	quit

vi3(RecordDBTBL1D dbtbl1d) // Maintain NODEPOS index entries (Node/Position )

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = dbtbl1d.%libs
	type String v3 = dbtbl1d.fid
	type String v4 = dbtbl1d.nod
	if v4.isNull() set v4=(PSL.maxCharValue-1).char()
	type String v5 = dbtbl1d.pos
	if v5.isNull() set v5=(PSL.maxCharValue-1).char()
	type String v6 = dbtbl1d.di

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if $D(^DBTBL(vobj(dbtbl1d,-3),1,vobj(dbtbl1d,-4),9,vobj(dbtbl1d,-5)))#2,'$D(^DBINDX(v1,"STR",v3,v4,v5,v6)) do vidxerr("NODEPOS")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DBINDX(v1,"STR",v3,v4,v5,v6)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("NOD").exists() set v4=vx("NOD").piece("|",1) set:v4.isNull() v4=(PSL.maxCharValue-1).char()
	if vx("POS").exists() set v5=vx("POS").piece("|",1) set:v5.isNull() v5=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DBINDX(v1,"STR",v3,v4,v5,v6)
	#ENDBYPASS
	quit

public VIDXBLD(List vlist) // Rebuild index files (External call)


	type Number %ProcessMode=0                             // Create mode
	type Number i

	if vlist.get().isNull() set vlist="VINDEX"             // Build all

	type DbSet ds=Db.selectDbSet("DBTBL1D")

	while ds.next() do {
		type RecordDBTBL1D dbtbl1d=ds.getRecord("DBTBL1D")
		if vlist.contains("VINDEX") do VINDEX(.dbtbl1d) quit
		if vlist.contains("DOMAIN") do vi1(.dbtbl1d)
		if vlist.contains("MDD") do vi2(.dbtbl1d)
		if vlist.contains("NODEPOS") do vi3(.dbtbl1d)
	}

	quit


public VIDXBLD1(RecordDBTBL1D dbtbl1d, List vlist) // Rebuild index files for one record (External call)


	type Number i

	if vlist.contains("VINDEX") do VINDEX(.dbtbl1d) quit
	if vlist.contains("DOMAIN") do vi1(.dbtbl1d)
	if vlist.contains("MDD") do vi2(.dbtbl1d)
	if vlist.contains("NODEPOS") do vi3(.dbtbl1d)

	quit


vidxerr(di) // Error message

	D SETERR^DBSEXECU("DBTBL1D","MSG",1225,"DBTBL1D."_di)

	quit


vkchged // Access key changed

	type public RecordDBTBL1D dbtbl1d

	type public Boolean ER = 0
	type public String RM,vpar,vx()

	type Number %O = 1
	type String vnewkey,voldkey,vux
	type String voldpar = vpar.get()                       // Save filer switches

	if vx("%LIBS").exists() set vux("%LIBS") = vx("%LIBS")
	if vx("FID").exists() set vux("FID") = vx("FID")
	if vx("DI").exists() set vux("DI") = vx("DI")
	do vkey(1) set voldkey = dbtbl1d.%libs_","_dbtbl1d.fid_","_dbtbl1d.di // Copy old keys into object

	set vpar = $$setPar^UCUTILN(vpar,"NOINDEX")            // Switch Index off
	if vpar["/VALREQ/" do vrequ
	if vpar["/TRIGBEF/" do VBU
	if vpar["/VALDD/" do vddver
	do vexec

	do vkey(2) set vnewkey = dbtbl1d.%libs_","_dbtbl1d.fid_","_dbtbl1d.di // Copy new keys into object
	type RecordDBTBL1D vnewrec = dbtbl1d.copy()
	do vnewrec.setMode(0)
	do vnewrec.save("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")

	set %O = 1 do CASUPD^DBSEXECU("DBTBL1D",voldkey,vnewkey) if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~")) // Cascade update
	set vpar = voldpar
	if vpar["/TRIGAFT/" do VAU

	do vkey(1)                                             // Reset key for delete
	set vpar = $$initPar^UCUTILN("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")
	set %O = 3 do vdelete(1)                               // Delete old record

	quit

vkey(Number i) // Restore access keys

	type public String vux()
	type public RecordDBTBL1D dbtbl1d

	if vux("%LIBS").exists() set dbtbl1d.%libs = vux("%LIBS").piece("|",i)
	if vux("FID").exists() set dbtbl1d.fid = vux("FID").piece("|",i)
	if vux("DI").exists() set dbtbl1d.di = vux("DI").piece("|",i)
	quit

VIDXPGM()	quit "DBSDFF"	// Location of index program

