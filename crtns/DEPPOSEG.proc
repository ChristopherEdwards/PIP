DEPPOSEG		/*
	   ORIG: RATMANSKYD - 07/20/98
	   DESC: Segmented Account Paid-Out

	   KEYWORDS: Withdrawal, Segment

	   I18N=QUIT:   Excluded from I18N standards.

	---- Revision History ------------------------------------------------

	06/19/06 - DESHPANDE S K - CR 21721
		   Modified subroutine NOACRUPD to use depseg.segment as a 
		   parameter to PROC^SEGINIDT. Also added key names to 
		   DB.getrecord calls for table DEPSEG as a cleanup.
		    
	12/18/03 - CARROLLJ - CR7239
			Correctd compile errors.

	11/14/02 - ZWITKOWITSM - 43583
		   PSL clean-up.

	06/13/02 - ZWITKOWITSM - 43583
		   Converted to PSL.

	10/31/01 - JERUCHIMC - 48147 (fix for 44340)
		   Modified section PENPOS2. Added section TRN.
		   Now, for penalty method 3, to reduce accrual,
		   post transactions instead of adjusting %A array.
		   Added check for $G(EVNTDT) to TRN and SEGPNEC sections
		   to not post secondary accrual adjustment when unwinding
		   and reapplying from RECALSEG.

	10/29/01 - TITOVE - 48056
		   Modified DIRSWTH section to pass AMTP instead of AMT to
		   NOACRUPD section, to prevent undefined error.

	09/20/01 - ITIGIB - 44340
		   Modified section PENPOS1 and PENPOS2 to define and
		   update the columns DEP.PENTYTD (node 432),DEP.PPL and
		   DEP.PYTD (node 55) if not already defined.
		   Modified MINSEG section to avoid the error which was
		   giving if a user enters an Authorization Number when
		   WDPRIO=2, while doing withdrawals of a segmented account.

	08/31/01 - JERUCHIMC/VETSENM - 47322
		   Section MINSEG has been modified do not quit if Interest
		   Accrued equal to zero.

	06/01/01 - CHHABRIAS/TITOVE - 44341
		   Added new function NOACRUPD, called when CUVAR.USEGOPT=1,
		   to handle enhancement for Non-Accrual Balance.

	05/02/01 - ITIGIB - 44340
		   .  Modified section NMATWTH to skip the Withdrawal
		   Authorization processing when the Withdrawal Priority
		   Option is 2 and the processing will be continued in
		   MINSEG section.
		   .  Added new section MINSEG,  which will go through
		   each Segment Account and calculate the RATIO for Segment
		   Balance to Interest for each segment.  This RATIO
		   will be stored in RATARR array and sorted by using
		   Quick Sort Algorithm.
		   .  Modified section PEN to Calculate/Update Penalty
		   Amount when Segment Penalty Calculation Method
		   will be 3.
		   .  Added new section PENPOS2 for Penalty Posting
		   against accrual for one segment.
		   .  Added new section SEGPNEC for Segment Penalty
		   Error Correct.  This will be used for only
		   penalties that were obtained from Segment Penalty
		   Method 3.

	----------------------------------------------------------------------
	*/

	quit


Public START(RecordDEP dep,RecordTTX ttx,RecordTRN trn)
	/*
	   Primary linetag to process withdrawal transactions on
	   segmented accounts.

	   INPUT:
		dep	- Deposit account object	/TYP=RecordDEP
		ttx	- Transaction object		/TYP=RecordTTX

	   EXAMPLE:
		do START^DEPPOSEG(.dep,.ttx)
	*/

	new CID,ETC,INTTFR,SEGI,SEGMENT,SEGP

	set CID=dep.cid
	set (INT,INTAVL,PRIN)=0
	set ETC=ttx.etc
	set SEGP=$$FIELD^UTSO(ttx.tso,"SEGP")
	set SEGI=$$FIELD^UTSO(ttx.tso,"SEGI")
	if SEGI'=""!(SEGP'="") do DIRSWTH(.dep,.ttx,SEGP,SEGI) quit

	// Load account segments into SEGMENT
	do INIT^DEPPISEG(CID)

	// Teller comment indicates transfer transaction
	if ttx.tcmt["TFR-" set INTTFR=1
	else  set INTTFR=0

	// Non-Matured Principal Withdrawal flag
	if trn.pcfd19=1 do NMATWTH(.dep,.ttx,.trn,TAMT) quit

	do MATWTH(.dep,.ttx,TAMT)

	quit


NMATWTH(RecordDEP dep,RecordTTX ttx,RecordTRN trn,TAMT)

	new PENAMT,PENTSO,REPAID,SEGI,SEGP,SEGSTART,TOTAMT,WTHAUT

	set REPAID=0
	set WTHAUT=$$FIELD^UTSO(ttx.tso,"WTHAUT")
	set PENTSO=ttx.penalty
	set PENAMT=0

	// Skip Withdrawal Authorization processing for this priority option
	if dep.wdprio'=2 do {

		// Invalid withdrawal authorization number
		if WTHAUT="" set OVR(CID,"OVR","AUTHNUM")="" quit

		type RecordWTHAUT wthaut=Db.getRecord("WTHAUT","CID,WTHAUT",1)

		if wthaut.getMode()=0 set OVR(CID,"OVR","AUTHNUM")="" quit

		new WTHRC

		// no need for authorization - reversing/reapplying a withdrawal
		if $G(RECALSEG),'$G(CURR) quit

		/*
		 Non-matured principal withdrawal teller must differ from
		 authorization teller
		*/
		if ttx.uid=wthaut.uid set OVR(CID,"OVR","WITHTELL")=""

		// Transaction amount is different than authorized amount
		if TAMT'=wthaut.amt set OVR(CID,"OVR","TAMTDIF")=""

		set WTHRC=wthaut.wthrc

		type RecordUTBLWTREAS1 uwtreas1=Db.getRecord("UTBLWTREAS1","WTHRC")

		set REPAID=uwtreas1.upfdrep

		if wthaut.trproc do Runtime.setErrMSG("DEP",3921,"WTHAUT") quit

		if wthaut.freq="" do {

			set wthaut.trproc=1

			do wthaut.bypassSave()
			}
		}
	if ER quit

	set TOTAMT=TAMT

	set SEGSTART=%EffectiveDate-$S('dep.wdprio:1,1:-1)

	// FIFO
	if dep.wdprio=0 for  set SEGSTART=$O(SEGMENT(SEGSTART)) quit:SEGSTART=""!(TOTAMT=0)  do NMW(.dep,.ttx,SEGMENT(SEGSTART))

	// LIFO
	if dep.wdprio=1 for  set SEGSTART=$O(SEGMENT(SEGSTART),-1) quit:SEGSTART=""!(TOTAMT=0)  do NMW(.dep,.ttx,SEGMENT(SEGSTART))

	if dep.wdprio=2 do MINSEG(.dep,.ttx)

	// Withdrawal exceeds available Non-Matured Principal Balance
	if TOTAMT>0 do Runtime.setErrMSG("DEP",3325) quit

	// Put WFR into TSO
	if REPAID=1 set ttx.tso=$$FIELDIN^UTSO(ttx.tso,"WFR",1)

	// Store the TRPROC,PENCALC flag
	if WTHAUT'="" do {

		type RecordWTHAUT wthaut=Db.getRecord("WTHAUT","CID,WTHAUT")

		if wthaut.trproc'=1 quit

		// get the computed penalty
		set wthaut.pencalcs=$$PEN^SEGPEN(CID,TAMT,WTHAUT)

		if $G(RECALSEG),TAMT<0 set wthaut.trproc=0

		do wthaut.bypassSave()
		}

	// Restrict Cash Withdrawals for Non-Matured Principal
	do CASH(.trn,.ttx)

	quit


MINSEG(RecordDEP dep,RecordTTX ttx)	// Calculates Ratio for Bal to Interest

	new NUM,RATARR,RATIO,SEGDT

	set SEGDT=0
	set SEGSTART=0
	set WTHAUT=""

	for  set SEGSTART=$O(SEGMENT(SEGSTART)) quit:SEGSTART=""  do {

		set NUM=SEGMENT(SEGSTART)

		type RecordDEPSEG depseg=Db.getRecord("DEPSEG","CID=:CID,SEGMENT=:NUM")

		// Invalid Segment
		if (depseg.segval=0)!(NUM=0) quit
		// quit if POSACR or BAL zero
		if (depseg.posacr'>0)!(depseg.bal'>0) quit

		// Calculating the ratio, for balance to the accrued int
		set RATIO=(depseg.posacr/depseg.bal)
		set RATARR(RATIO,NUM)=""
		}

	set (NUM,RATIO)=""
	for  set RATIO=$O(RATARR(RATIO)) quit:((RATIO="")!(TOTAMT=0))  do {
		for  set NUM=$O(RATARR(RATIO,NUM)) quit:((NUM="")!(TOTAMT=0))  do NMW(.dep,.ttx,NUM)
		}

	// If there is more money to withdraw, drive zero segment negative.
	if TOTAMT>0 do DZSN(.dep,.ttx)

	quit


NMW(RecordDEP dep,RecordTTX ttx,NUM)	// Non-Matured Withdrawal (one segment)

	type Public Cache %CUVAR

	// If zero segment quit
	if NUM=0 quit

	new MATFLG

	set MATFLG=0

	type RecordDEPSEG depseg=Db.getRecord("DEPSEG","CID=:CID,SEGMENT=:NUM")

	// coming in from RECALSEG
	if $G(RECALSEG) do {

		new SEGTSO,PIECE,CNT

		type RecordCUVAR cuvar=%CUVAR.getRecord("CUVAR")

		if depseg.segmdt>cuvar.tjd quit

		set MATFLG=1

		// If current transaction, don't hit this segment if it has since matured
		if $G(CURR) quit

		// retrieve previous TSO amount for this segment
		type ResultSet rs=Db.select("LASTSO","SEGTXN","CID=:CID AND HSEQ=:RHSEQ")

		if rs.isEmpty() quit

		if rs.next() set SEGTSO=rs.getCol(1)

		if SEGTSO="" quit

		set SEGTSO=$$FIELD^UTSO(SEGTSO,"SEGP")
		set CNT=1

		new PAMT,SEG

		for  set PIECE=$P(SEGTSO,"^",CNT) quit:PIECE=""  set CNT=CNT+1 do {

			set SEG=$P(PIECE,":",1)
			if SEG'=NUM quit

			set PAMT=$P(PIECE,":",2)
			if 'PAMT quit

			set TOTAMT=TOTAMT-PAMT

			do TSOSEG(.ttx,"SEGP",NUM,PAMT,1)

			set dep.tsnmpb=dep.tsnmpb-PAMT

			if REPAID do {
				set depseg.wfr=depseg.wfr+PAMT
				set dep.totwfr=dep.totwfr+PAMT
				}

			// Update Non-Accrual Balance and Expiration Date
			#if CUVAR.USEGOPT=1 do NOACRUPD(.dep,.depseg,PAMT)

			set depseg.bal=depseg.bal-PAMT
			}

		do depseg.bypassSave()
		}

	if MATFLG quit

	if depseg.bal,TOTAMT>depseg.bal do {

		// Update Non-Accrual Balance and Expiration Date
		#if CUVAR.USEGOPT=1 do NOACRUPD(.dep,.depseg,TAMT)

		set TOTAMT=TOTAMT-depseg.bal

		// Update Total Segment Non-Matured Prin Balance
		set dep.tsnmpb=dep.tsnmpb-depseg.bal

		do TSOSEG(.ttx,"SEGP",NUM,depseg.bal,1)

		if REPAID do {
			// Update Withdrawan Funds to be Repaid
			set depseg.wfr=depseg.wfr+depseg.bal

			// Update Total Seg W/d Funds to be Repaid
			set dep.totwfr=dep.totwfr+depseg.bal
			}

		// Calculate and Update Penalty
		if PENTSO="",WTHAUT="" set PENAMT=$$PEN(.dep,.depseg,depseg.bal)

		set depseg.bal=0

		if PENAMT,dep.segpopt=3 do PENPOS(.dep,.depseg,.ttx,PENAMT)
		}

	else  do {
		if '(dep.segacr=0&(INTTFR)) do {
			// Update Non-Accrual Balance and Expiration Date
			#if CUVAR.USEGOPT=1 do NOACRUPD(.dep,.depseg,TAMT)

			// Update Ledger Balance
			set depseg.bal=depseg.bal-TOTAMT

			// Update Total Segment Non-Matured Prin Bal
			set dep.tsnmpb=dep.tsnmpb-TOTAMT
			}

		do TSOSEG(.ttx,"SEGP",NUM,TOTAMT,1)

		if REPAID do {
			// Update Withdrawan Funds to be Repaid
			set depseg.wfr=depseg.wfr+TOTAMT

			// Update Total Seg W/d Funds to be Repaid
			set dep.totwfr=dep.totwfr+TOTAMT
			}

		if PENTSO="",WTHAUT="" do {
			// Calculate and Post penalty
			set PENAMT=$$PEN(.dep,.depseg,TOTAMT)

			do PENPOS(.dep,.depseg,.ttx,PENAMT)
			}

		if PENTSO="",WTHAUT'="" do {

			type RecordWTHAUT wthaut=Db.getRecord("WTHAUT","CID,WTHAUT",1)

			if wthaut.getMode()=0 quit

			// Calculate penalty based on withdrawal authorization
			set PENAMT=wthaut.penamt

			if PENAMT="" set PENAMT=$$PEN^SEGPEN(CID,TAMT,WTHAUT)

			do PENPOS(.dep,.depseg,.ttx,PENAMT)
			}

		// Post penalty from TSO
		if PENTSO'="" do PENPOS(.dep,.depseg,.ttx,PENTSO)

		set TOTAMT=0
		}

	// Offer processing
	if dep.offproc do OFFPROC^DEPPISEG(.depseg)

	do depseg.bypassSave()

	quit


MATWTH(RecordDEP dep,RecordTTX ttx,TOTAMT)

	// Withdrawal Order Option 0
	if dep.wdord=0 do OPT0(.dep,.ttx)

	// Withdrawal Order Option 1
	if dep.wdord=1 do OPT1(.dep,.ttx)

	quit


OPT0(RecordDEP dep,RecordTTX ttx)
	/*
	   Withdrawal Order Option 0 - Matured Principal, Available
	   Interest (Matured), Available Interest (Non-matured)
	   Principal Balance on Zero Segment
	*/

	do PBZS(.dep,.ttx)

	if TOTAMT=0 quit

	// Available Interest on Zero Segment
	do AIS(.dep,.ttx,0)

	if TOTAMT=0 quit

	// Available Interest on Non-Matured Segments
	do AINMS(.dep,.ttx)

	if TOTAMT=0 quit

	// Drive Zero Segment Negative
	do DZSN(.dep,.ttx)

	quit


OPT1(RecordDEP dep,RecordTTX ttx)
	/*
	   Withdrawal Order Option 1 - Available Interest (Non-matured), Matured
	   Principal, Available Interest (Matured)
	   Available Interest on Non-Matured Segments
	*/

	do AINMS(.dep,.ttx)

	if TOTAMT=0 quit

	// Principal Balance on Zero Segment
	do PBZS(.dep,.ttx)

	if TOTAMT=0 quit

	// Available Interet on Zero Segment
	do AIS(.dep,.ttx,0)

	if TOTAMT=0 quit

	// Drive Zero Segment Negative
	do DZSN(.dep,.ttx)

	quit


AINMS(RecordDEP dep,RecordTTX ttx)	// Available Interest on Non-Matured Segments

	new NUM,START

	if dep.segacr do AIS(.dep,.ttx,1) quit

	set START=""

	for  set START=$O(SEGMENT(START)) quit:START=""!(TOTAMT=0)  do {

		// Segment number
		set NUM=SEGMENT(START)

		if NUM=0 quit

		// Available Interest on Segment
		do AIS(.dep,.ttx,NUM)
		}

	quit


DZSN(RecordDEP dep,RecordTTX ttx)	// Drive Zero Segment Negative

	type RecordDEPSEG depseg0=Db.getRecord("DEPSEG","CID,0")

	set depseg0.bal=-TOTAMT

	do depseg0.bypassSave()

	// Update Total Segment Matured Principal Balance
	set dep.tsmpb=dep.tsmpb-TOTAMT

	do TSOSEG(.ttx,"SEGP",0,TOTAMT,1)

	// Transaction results in Negative Matured Principal Balance
	set OVR(CID,"OVR","MATBAL")=""

	quit


PBZS(RecordDEP dep,RecordTTX ttx)	// Principal Balance on Zero Segment

	type RecordDEPSEG depseg0=Db.getRecord("DEPSEG","CID,0")

	if TOTAMT>depseg0.bal do {

		if 'depseg0.bal quit

		set TOTAMT=TOTAMT-depseg0.bal

		// Update Total Segment Matured Principal Balance
		set dep.tsmpb=dep.tsmpb-depseg0.bal

		do TSOSEG(.ttx,"SEGP",0,depseg0.bal,1)

		// segment Ledger Balance
		set depseg0.bal=0
		}

	else  do {

		// Update segment Ledger Balance
		set depseg0.bal=depseg0.bal-TOTAMT

		// Update Total Segment Matured Principal Balance
		set dep.tsmpb=dep.tsmpb-TOTAMT

		do TSOSEG(.ttx,"SEGP",0,TOTAMT,1)

		set TOTAMT=0
		}

	do depseg0.bypassSave()

	quit


AIS(RecordDEP dep,RecordTTX ttx,NUM)	// Available Interest on Segment
	/*
	   INPUT:
	    dep		Deposit account object		/TYP=RecordDEP
	    ttx		Transaction object		/TYP=RecordTTX
	    NUM - Segment Number
	*/

	type Public Cache %CUVAR

	new MATFLG

	set MATFLG=0

	type RecordDEPSEG depseg=Db.getRecord("DEPSEG","CID=:CID,SEGMENT=:NUM",1)

	if depseg.getMode()=0 quit

	// coming in from RECALSEG and not zero segment
	if $G(RECALSEG),NUM do {

		type RecordCUVAR cuvar=%CUVAR.getRecord("CUVAR")

		if depseg.segmdt>cuvar.tjd quit

		// If current transaction, don't hit this segment if it has since matured
		if $G(CURR) quit

		new CNT,IAMT,PIECE,SEG,SEGTSO

		set MATFLG=1

		// retrieve previous TSO amount for this segment
		type ResultSet rs=Db.select("LASTSO","SEGTXN","CID=:CID AND HSEQ=:RHSEQ")

		if rs.isEmpty() quit

		if rs.next() set SEGTSO=rs.getCol(1)

		if SEGTSO="" quit
		set SEGTSO=$$FIELD^UTSO(SEGTSO,"SEGI")

		set CNT=1

		for  set PIECE=$P(SEGTSO,"^",CNT) quit:PIECE=""  do {

			set CNT=CNT+1
			set SEG=$P(PIECE,":",1)
			if SEG'=NUM quit

			set IAMT=$P(PIECE,":",2)
			if 'IAMT quit

			set TOTAMT=TOTAMT-IAMT

			do TSOSEG(.ttx,"SEGI",NUM,IAMT,1)

			// Total Avail Int on Non-Matured Segments
			set dep.tainms=dep.tainms-IAMT

			// Interest Paid Not Credited
			set dep.intavlncr=dep.intavlncr-IAMT

			// Available Interest Balance
			set depseg.aibal=depseg.aibal-IAMT
			}

		do depseg.bypassSave()
		}

	if MATFLG quit

	if dep.segacr do { quit

		new AVLINT,PRININT

		do ACCTINT(.dep,NUM,.PRININT,.AVLINT)

		// Consider principal interest at account level
		if TOTAMT>PRININT do {

			set TOTAMT=TOTAMT-PRININT

			// Update Total Segment Matured Prin Bal
			if NUM=0 set dep.tsmpb=dep.tsmpb-PRININT

			// Update Total Segment Non-Matured Prin Bal
			else  set dep.tsnmpb=dep.tsnmpb-PRININT

			// Update principal
			do UPDTAMT(.ttx,.dep,PRININT,2)
			}

		else  do {
			// Update Total Segment Matured Prin Bal
			if NUM=0 set dep.tsmpb=dep.tsmpb-TOTAMT

			// Update Total Segment Non-Matured Prin Bal
			else  set dep.tsnmpb=dep.tsnmpb-TOTAMT

			// Update principal
			do UPDTAMT(.ttx,.dep,TOTAMT,2)

			set TOTAMT=0
			}

		// Consider available interest at account level
		if TOTAMT>AVLINT do {

			set TOTAMT=TOTAMT-AVLINT

			// Update Interest Available Not Credited
			set dep.intavlncr=dep.intavlncr-AVLINT

			// Update Total Available Int Matured Seg
			if NUM=0 do {

				do TSOSEG(.ttx,"SEGI",0,AVLINT,0)

				set dep.taims=dep.taims-AVLINT
				}

			// Update Total Available Int Non-Matured Seg
			else  set dep.tainms=dep.tainms-AVLINT

			// Update Available Int
			do UPDTAMT(.ttx,.dep,AVLINT,8)
			}

		else  do {
			// Update Interest Available Not Credited
			set dep.intavlncr=dep.intavlncr-TOTAMT

			// Update Total Available Int Matured Seg
			if NUM=0 do {

				do TSOSEG(.ttx,"SEGI",0,TOTAMT,0)

				set dep.taims=dep.taims-TOTAMT
				}

			// Update Total Available Int Non-Matured Seg
			else  set dep.tainms=dep.tainms-TOTAMT

			// Update Available Int
			do UPDTAMT(.ttx,.dep,TOTAMT,8)

			set TOTAMT=0
			}
		}

	if TOTAMT>depseg.aibal do {

		if 'depseg.aibal quit

		set TOTAMT=TOTAMT-depseg.aibal

		do TSOSEG(.ttx,"SEGI",NUM,depseg.aibal,1)

		// Update Total Avail Int on Matured Segments
		if NUM=0 set dep.taims=dep.taims-depseg.aibal

		// Update Total Avail Int on Non-Matured Segments
		else  set dep.tainms=dep.tainms-depseg.aibal

		// Update Interest Paid Not Credited
		set dep.intavlncr=dep.intavlncr-depseg.aibal

		// Update Available Interest Balance
		set depseg.aibal=0
		}

	else  do {
		/*
		 segment Available Interest Balance has enough
		 funds to cover total amount.
		*/
		set depseg.aibal=depseg.aibal-TOTAMT

		// Update Total Avail Int on Matured Segments
		if NUM=0 set dep.taims=dep.taims-TOTAMT

		// Update Total Avail Int on Non-Matured Segments
		else  set dep.tainms=dep.tainms-TOTAMT

		// Update Interest Paid Not Credited
		set dep.intavlncr=dep.intavlncr-TOTAMT

		do TSOSEG(.ttx,"SEGI",NUM,TOTAMT,1)

		set TOTAMT=0
		}

	do depseg.bypassSave()

	quit


ACCTINT(RecordDEP dep,NONMAT,PRININT,AVLINT)	// Account level interest determination
	/*
	   INPUT:
	    dep	      Deposit account object	/TYP=RecordDEP
	    NONMAT    Non-matured flag
	    PRININT   Principal interest
	    AVLINT    Available interest
	*/

	if 'NONMAT do { quit

		type RecordDEPSEG depseg=Db.getRecord("DEPSEG","CID,0")

		// Calculate matured interest
		set PRININT=dep.tsmpb-depseg.bal
		set AVLINT=dep.taims-depseg.aibal
		}

	new SEGAVL,SEGPRIN

	set (SEGAVL,SEGPRIN)=0

	type ResultSet rs=Db.select("BAL,AIBAL","DEPSEG","CID=:CID AND SEGMENT >0")

	if rs.isEmpty() quit

	// Collate non-matured segments
	while rs.next() do {
		set SEGPRIN=SEGPRIN+rs.getCol(1)
		set SEGAVL=SEGAVL+rs.getCol(2)
		}

	// Calculate non-matured interest
	set PRININT=dep.tsnmpb-SEGPRIN
	set AVLINT=dep.tainms-SEGAVL

	quit


UPDTAMT(RecordTTX ttx,RecordDEP dep,AMT,PIECE)
	/*
	   INPUT:
	    ttx	      Transaction object	/TYP=RecordTTX
	    dep	      Deposit account object	/TYP=RecordDEP
	    AMT     Amount
	    PIECE   Piece of HIST.TAMT to update
	*/
	if 'AMT quit

	new TAMT

	set TAMT=ttx.tamt
	set $P(TAMT,"#",PIECE)=$P(TAMT,"#",PIECE)+AMT
	set ttx.tamt=TAMT

	if dep.iaf'=2 set PRIN=PRIN+AMT

	quit


Public TSOSEG(RecordTTX ttx,TYPE,NUM,AMT,UPD)
	/*
	   INPUT:
	    ttx	      Transaction object	/TYP=RecordTTX
	    TYPE - TSO type (SEGP,SEGI,SEGA,SEGAA)
	    NUM  - Segment Number
	    AMT  - Amount
	    UPD  - Update TAMT (1- yes, 0-no)
	*/

	new TAMT,TSOSEG

	if TYPE'="SEGPEN" set AMT=$$^SCARND(AMT,0,ttx.cid)

	set TSOSEG=$$FIELD^UTSO(ttx.tso,TYPE)

	if TSOSEG'="" set TSOSEG=TSOSEG_"^"_NUM_":"_AMT
	else  set TSOSEG=NUM_":"_AMT

	set ttx.tso=$$FIELDIN^UTSO(ttx.tso,TYPE,TSOSEG)

	if UPD=0 quit

	set TAMT=ttx.tamt

	if TYPE="SEGP" do { quit
		set $P(TAMT,"#",2)=$P(TAMT,"#",2)+AMT
		set ttx.tamt=TAMT
		set PRIN=PRIN+AMT
		}

	if TYPE="SEGAA" do { quit
		set $P(TAMT,"#",14)=$P(TAMT,"#",14)+AMT
		set ttx.tamt=TAMT
		set INT=INT+AMT
		}

	if TYPE="SEGI" do { quit
		set $P(TAMT,"#",8)=$P(TAMT,"#",8)+AMT
		set ttx.tamt=TAMT
		if $G(INTAVL)'="" set INTAVL=INTAVL+AMT
		}

	// SEGA
	set $P(TAMT,"#",3)=$P(TAMT,"#",3)+AMT
	set ttx.tamt=TAMT
	set INT=INT+AMT

	quit


Public PEN(RecordDEP dep,RecordDEPSEG depseg,AMT)
	/*
	   INPUT:
	     dep	Deposit account object	/TYP=RecordDEP
	     AMT	Penalty Base for segment
	   RETURNS:
	     Total Penalty Amount
	*/

	// Penalty already defined
	if $G(PENTSO)'="" quit PENTSO
	// No penalties on interest transfers
	if INTTFR quit 0

	// Segment Penalty Calc Method
	if dep.segpopt="" quit 0

	new PEN,SEGMDT

	// Segment Penalty Option 3 - penalize accrual on withdrawal amount
	if dep.segpopt=3 do { quit PENAMT

		new LASTPST,METHDYS,ACRDAYS

		/*
		 Penalty = Withdrawal amount * Interest Rate * (days since
		 last interest posting / days in accrual method)
		*/

		set LASTPST=depseg.ipld
		if LASTPST="" set LASTPST=dep.origopd

		if $E(dep.iacm,2)="0" set METHDYS=360
		if $E(dep.iacm,2)="3" set METHDYS=365
		if $E(dep.iacm,2)="1" do {
			new YEAR

			set YEAR=$$YEAR^SCADAT(%SystemDate,1)

			if (YEAR#4=0)&('(YEAR#100=0)!(YEAR#400=0)) set METHDYS=366
			else  set METHDYS=365
			}

		if dep.iacm="" set PENAMT=0 quit

		set ACRDAYS=(%SystemDate-LASTPST)/METHDYS
		set PENAMT=depseg.irn*ACRDAYS*AMT/100
		if PENAMT>depseg.posacr set PENAMT=depseg.posacr
		set PENAMT=$$^SCARND(PENAMT,,dep.cid)
		}

	if %EffectiveDate="" set %EffectiveDate=%SystemDate

	// Withdrawal amount for remaining term, grace period after int change
	if dep.segpopt=2,(%EffectiveDate'<dep.ichnd!(%EffectiveDate'>(dep.ichnd+dep.pengr))) quit 0

	set SEGMDT=depseg.segmdt
	if SEGMDT=%EffectiveDate quit 0
	if SEGMDT>%EffectiveDate set SEGMDT=SEGMDT-1

	quit PENAMT+$$^SCARND($$^UIC(AMT,%EffectiveDate,SEGMDT,dep.iacm,dep.prate),0,dep.cid)


PENPOS(RecordDEP dep,RecordDEPSEG depseg,RecordTTX ttx,AMT)
	/*
	   INPUT:
	    dep	      Deposit account object	/TYP=RecordDEP
	    depseg    Segment object		/TYP=RecordDEPSEG
	    ttx	      Transaction object	/TYP=RecordTTX
	    AMT - Penalty Amount
	*/

	new SEGSTART,TAMT

	// Withdrawal exceeds available Non-Matured Principal Balance
	if dep.wdprio'=2,AMT>dep.tsnmpb do Runtime.setErrMSG("DEP",3325) quit
	if AMT=0 quit

	if dep.wdprio=2 do PENPOS2(.dep,.depseg,.ttx) quit

	// Put Penalty amount into ttx array
	set TAMT=ttx.tamt
	set $P(TAMT,"#",4)=$P(TAMT,"#",4)+AMT
	set ttx.tamt=TAMT

	set SEGSTART=""

	// FIFO
	if dep.wdprio=0 for  set SEGSTART=$O(SEGMENT(SEGSTART)) quit:SEGSTART=""!(AMT=0)  do PENPOS1(.dep,.depseg,.ttx)

	// LIFO
	if dep.wdprio=1 for  set SEGSTART=$O(SEGMENT(SEGSTART),-1) quit:SEGSTART=""!(AMT=0)  do PENPOS1(.dep,.depseg,.ttx)

	quit


PENPOS2(RecordDEP dep,RecordDEPSEG depseg,RecordTTX ttx)	// Penalty posting against accrual for one segment

	new CID,CRADPAC,SEGMENT,TYPE

	set TYPE=dep.type
	set CID=dep.cid
	set SEGMENT=depseg.segment

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")

	if prodctl.dradin="" do { quit
		new DI
		set DI="PRODCTL.DRADIN"
		do Runtime.setErrMSG("DEP",3699,"DI~TYPE")
		}

	set CRADPAC=prodctl.cradpac
	if CRADPAC="" set CRADPAC=prodctl.crtrgp
	if CRADPAC="" do { quit
		new DI
		set DI="PRODCTL.CRADPAC"
		do Runtime.setErrMSG("DEP",3699,"DI~TYPE")
		}

	//??
	// Section TRN will use secondary transactions to update dep and depseg.
	do dep.bypassSave()
	do depseg.bypassSave()

	do TRN(.dep,.ttx,AMT,prodctl.dradin,CRADPAC,SEGMENT)

	//??
	// Re-instantiate depseg to get any changes made by section TRN.
	set depseg=Db.getRecord("DEPSEG","CID=:CID,SEGMENT=:SEGMENT")

	if '(ttx.itc6!ttx.itc12) do TSOSEG(.ttx,"SEGPEN",NUM,AMT,0)

	// Update Penalty Year-to-Date
	set dep.pytd=dep.pytd+AMT

	// Update Penalty Paid Life
	set dep.ppl=dep.ppl+AMT

	quit


PENPOS1(RecordDEP dep,RecordDEPSEG depseg,RecordTTX ttx)	// Penalty Posting (one segment)

	new NUM

	set NUM=SEGMENT(SEGSTART)

	// If zero segment quit
	if NUM=0 quit

	/*
	  If segment number NUM is segment number of the already instantiated depseg object,
	  just update the current object and leave, it will be saved elsewhere.  Otherwise 
	  instantiate the object and save it here.
	*/
	if NUM=depseg.segment do PENPOS1B(.dep,.depseg,.ttx) quit

	type RecordDEPSEG depseg2=Db.getRecord("DEPSEG","CID=:CID,SEGMENT=:NUM",1)

	if depseg2.getMode()=0 quit

	do PENPOS1B(.dep,.depseg2,.ttx)

	do depseg2.bypassSave()

	quit


PENPOS1B(RecordDEP dep,RecordDEPSEG depseg,RecordTTX ttx)

	if AMT>depseg.bal do {

		if 'depseg.bal quit

		set AMT=AMT-depseg.bal

		// Update Total Segment Non-Matured Prin Balance
		set dep.tsnmpb=dep.tsnmpb-depseg.bal

		do TSOSEG(.ttx,"SEGP",NUM,depseg.bal,1)

		if REPAID do {
			// Update Withdrawan Funds to be Repaid
			set depseg.wfr=depseg.wfr+depseg.bal

			// Update Total Seg W/d Funds to be Repaid
			set dep.totwfr=dep.totwfr+depseg.bal
			}

		// Update segment Ledger Balance
		set depseg.bal=0

		// Update Penalty Year-to-Date
		set dep.pytd=dep.pytd+AMT

		// Update Penalty Paid Life
		set dep.ppl=dep.ppl+AMT

		// Update Penalty Tax Year-to-Date
		set dep.pentytd=dep.pentytd+AMT
		}

	else  do {
		// Update segment Ledger Balance
		set depseg.bal=depseg.bal-AMT

		// Update Total Segment Non-Matured Principal Bal
		set dep.tsnmpb=dep.tsnmpb-AMT

		do TSOSEG(.ttx,"SEGP",NUM,AMT,1)

		if REPAID do {
			// Update Withdrawan Funds to be Repaid
			set depseg.wfr=depseg.wfr+AMT

			// Update Total Seg W/d Funds to be Repaid
			set dep.totwfr=dep.totwfr+AMT
			}

		// Update Penalty Year-to-Date
		set dep.pytd=dep.pytd+AMT

		// Update Penalty Paid Life
		set dep.ppl=dep.ppl+AMT

		// Update Penalty Tax Year-to-Date
		set dep.pentytd=dep.pentytd+AMT

		set AMT=0
		}

	quit


TRN(RecordDEP dep,RecordTTX ttx,TAMT,DRADIN,CRADPAC,SEGNUM)	// Build secondaries for accrual penalty
	/*
	 This section builds a decrease-accrual transaction to the customer
	 account and a deposit transaction to the customer account
	 which only hits the penalty part of the amount field.

	 Do not process secondary transactions if unwinding.  Only
	 Post for a true error-correct or reversal.
	*/

	if $G(EVNTDT)'="" quit

	new TSO

	set TSO=$$FIELDIN^UTSO(ttx.tso,"SEG",SEGNUM)

	// Post reduction of accrual
	do BLDTR(.dep,DRADIN,TAMT,%SystemDate,TSO,ttx.crcd)

	/*
	 Set UPSCSEG so RECALSEG deals properly with secondary.  Only
	 for this transaction.  Acrrual transaction should not have
	 this set; otherwise, RECALSEG would post 2 accrual adjustments.
	*/
	set TSO=$$FIELDIN^UTSO(TSO,"UPSCSEG",1)
	set TAMT=TAMT_"###"_TAMT

	do BLDTR(.dep,CRADPAC,TAMT,%EffectiveDate,TSO,ttx.crcd)

	quit


BLDTR(RecordDEP dep,ETC,TAMT,TEFD,TSO,CRCD)	// Build secondary transaction

	type Public Cache %CACHE()

	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC")
	type RecordTTX ttx=Class.new("RecordTTX")

	set ttx.cid=dep.cid
	set ttx.itc=trn.itc
	set ttx.etc=ETC
	set ttx.tamt=TAMT
	set ttx.efd=TEFD
	set ttx.tlo=%UserStation
	set ttx.tso=TSO
	set ttx.crcd=CRCD

	do TRNSINGL^TRNDRV(.ttx,.dep,TPD,BRCD,4)

	quit


Public EC(RecordDEP dep,RecordTTX ttx)

	new AIBAL,CID,PRIN,SEGI,SEGP,UTSO,WFR

	set CID=dep.cid

	do OUT^UTSO(.UTSO,ttx.tso)

	set SEGP=$G(UTSO("SEGP"))
	set WFR=$G(UTSO("WFR"))
	set SEGI=$G(UTSO("SEGI"))
	set SEGPEN=$G(UTSO("SEGPEN"))

	if dep.segacr do {
		new TAMT

		set TAMT=ttx.tamt

		if TAMT["#" set PRIN=-$P(TAMT,"#",2)
		else  set PRIN=-TAMT

		set AIBAL=-$P(TAMT,"#",8)
		}

	do SEGPEC(.dep,SEGP)
	if ER quit

	do SEGIEC(.dep,SEGI)
	if ER quit

	do SEGPNEC(.dep,.ttx,SEGPEN)

	quit


SEGPEC(RecordDEP dep,REC)
	/*
	   INPUT:
	     dep	Deposit account object		/TYP=RecordDEP
	     REC	"SEGP" TSO subfield
	*/

	new AMT,COUNT,EXIT,NUM,PIECE

	set EXIT=0

	for COUNT=1:1  do { quit:EXIT=1

		set PIECE=$P(REC,"^",COUNT)

		if PIECE="" set EXIT=1 quit

		set NUM=$P(PIECE,":",1)
		set AMT=$P(PIECE,":",2)

		type RecordDEPSEG depseg=Db.getRecord("DEPSEG","CID=:CID,SEGMENT=:NUM",1)

		// Invalid segment number
		if depseg.getMode()=0 set EXIT=1 do Runtime.setErrMSG("DEP",3326) quit

		// Update segment Ledger Balance
		set depseg.bal=depseg.bal+AMT

		// Update Non-Accrual Deposit balance, if applicable
		#if CUVAR.USEGOPT=1 do NOACRUPD(.dep,.depseg,AMT)

		// Update Total Segment Matured Principal Balance
		if NUM=0 set dep.tsmpb=dep.tsmpb+AMT

		// Update Total Segment Non-Matured Prin Balance
		else  set dep.tsnmpb=dep.tsnmpb+AMT

		if dep.segacr set PRIN=PRIN-AMT

		if WFR do {
			// Update Withdrawn Funds to be Repaid
			set depseg.wfr=depseg.wfr-AMT

			// Update Total Seg W/d Funds to be Repaid
			set dep.totwfr=dep.totwfr-AMT
			}

		// Offer processing
		if dep.offproc do OFFPROC^DEPPISEG(.depseg)

		do depseg.bypassSave()
		}

	/*
	 If there is principal remaining, must be interest posted at
	 account level - update Total Segment Non-Matured Prin Bal
	*/
	if dep.segacr,PRIN set dep.tsnmpb=dep.tsnmpb+PRIN

	quit


SEGPNEC(RecordDEP dep,RecordTTX ttx,REC)	// Segment penalty error correct
	/*
	       This would be used for only penalties that were obtained
	       from segment penalty method 3.

	   INPUT:
	    dep		Deposit account object	/TYP=RecordDEP
	    ttx		Transaction object	/TYP=RecordTTX
	    REC		"SEGPEN" TSO subfield
	*/

	if $G(EVNTDT)'="" quit

	new AMT,COUNT,EXIT,NUM,PIECE,REPAID

	set EXIT=0
	set REPAID=0

	for COUNT=1:1  do { quit:EXIT=1

		set PIECE=$P(REC,"^",COUNT)

		if PIECE="" set EXIT=1 quit

		set NUM=$P(PIECE,":",1)
		set AMT=$P(PIECE,":",2)

		set AMT=-AMT

		type RecordDEPSEG depseg=Db.getRecord("DEPSEG","CID=:CID,SEGMENT=:NUM",1)

		// Invalid segment number
		if depseg.getMode()=0 set EXIT=1 do Runtime.setErrMSG("DEP",3326) quit

		do PENPOS2(.dep,.depseg,.ttx)

		do depseg.bypassSave()
		}

	quit


SEGIEC(RecordDEP dep,REC)
	/*
	   INPUT:
	    dep		Deposit account object	/TYP=RecordDEP
	    ttx		Transaction object	/TYP=RecordTTX
	    REC		"SEGI" TSO subfield
	*/

	new AMT,COUNT,EXIT,NUM,PIECE

	set EXIT=0

	for COUNT=1:1  do { quit:EXIT=1

		set PIECE=$P(REC,"^",COUNT)

		if PIECE="" set EXIT=1 quit

		set NUM=$P(PIECE,":",1)
		set AMT=$P(PIECE,":",2)

		type RecordDEPSEG depseg=Db.getRecord("DEPSEG","CID=:CID,SEGMENT=:NUM",1)

		// Invalid segment number
		if depseg.getMode()=0 set EXIT=1 do Runtime.setErrMSG("DEP",3326) quit

		// Update Available Interest Balance
		if 'dep.segacr set depseg.aibal=depseg.aibal+AMT
		else  set AIBAL=AIBAL-AMT

		// Update Total Avail Int on Matured Segments
		if NUM=0 set dep.taims=dep.taims+AMT

		// Update Total Avail Int on Non-Matured Segments
		else  set dep.tainms=dep.tainms+AMT

		// UpdateInterest Available Not Credited
		set dep.intavlncr=dep.intavlncr+AMT

		do depseg.bypassSave()
		}

	/*
	 If there is available interest remaining, must be interest posted at
	 account level - update Total Available Int NonMatured Seg
	*/
	if dep.segacr,AIBAL set dep.tainms=dep.tainms+AIBAL

	quit


DIRSWTH(RecordDEP dep,RecordTTX ttx,SEGP,SEGI)
	/*
	   INPUT:
	    dep		Deposit account object		/TYP=RecordDEP
	    ttx		Transaction object		/TYP=RecordTTX
	    SEGP	"SEGP" TSO subfield
	    SEGI	"SEGI" TSO subfield
	*/

	new AMTI,AMTP,NUMI,NUMP,NUM,TAMT

	set NUMP=$P(SEGP,":",1)
	set AMTP=$P(SEGP,":",2)
	set NUMI=$P(SEGI,":",1)
	set AMTI=$P(SEGI,":",2)

	if NUMP'="",AMTP'="" do {

		type RecordDEPSEG depseg=Db.getRecord("DEPSEG","CID=:CID,SEGMENT=:NUMP",1)

		if depseg.getMode()=0 quit

		set depseg.bal=depseg.bal-AMTP

		// Insufficient Funds Wrong Transaction Information
		if depseg.bal<0 do Runtime.setErrMSG("DEP",3335) quit

		if NUMP=0 set dep.tsmpb=dep.tsmpb-AMTP
		else  set dep.tsnmpb=dep.tsnmpb-AMTP

		// Update Non-Accrual Deposit balance, if applicable
		#if CUVAR.USEGOPT=1 do NOACRUPD(.dep,.depseg,AMTP)

		do depseg.bypassSave()
		}

	if NUMI'="",AMTI'="" do {

		// Wrong Transaction Information
		if NUMP'="",NUMP'=NUMI do Runtime.setErrMSG("DEP",3335) quit

		type RecordDEPSEG depseg=Db.getRecord("DEPSEG","CID=:CID,SEGMENT=:NUMI",1)

		if depseg.getMode()=0 quit

		set depseg.aibal=depseg.aibal-AMTI

		// Wrong Transaction Information
		if depseg.aibal<0 do Runtime.setErrMSG("DEP",3335) quit

		if NUMI=0 set dep.taims=dep.taims-AMTI
		else  set dep.tainms=dep.tainms-AMTI

		set dep.intavlncr=dep.intavlncr-AMTI

		do depseg.bypassSave()
		}

	set INTAVL=INTAVL+AMTI
	set PRIN=PRIN+AMTP
	set TAMT=ttx.tamt
	set $P(TAMT,"#",2)=AMTP
	set $P(TAMT,"#",8)=AMTI
	set ttx.tamt=TAMT

	quit


CASH(RecordTRN trn,RecordTTX ttx)	// Restrict Cash Withdrawals for Non-Matured Principal
	/*
	   This function is looking for any credit cash transaction
	   in the TR array.
	*/

	type Public Cache %CACHE()

	if 'trn.pcfd20 quit

	new ETC,EXIT,SEQ

	set SEQ=""
	set EXIT=0

	//??? what to do with this ???
	/*
	for  set SEQ=ttx.next(SEQ) quit:SEQ=""!(EXIT=1)  do {

		set ETC=ttx.etc

		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC")

		// if not cash type tran, quit
		if trn.trntyp'=1 quit

		// if debit, quit
		if $E(trn.itc,1)=0 quit

		// Non-matured principal withdrawals restricted by transaction code
		set OVR(CID,"OVR","NMWITH")=""
		set EXIT=1
		}
	*/

	quit


Public NOACRUPD(RecordDEP dep,RecordDEPSEG depseg,STAMT)

	if '%EffectiveDate set %EffectiveDate=%SystemDate

	do PROC^SEGINIDT(.dep, .depseg, %EffectiveDate, STAMT, depseg.segment)

	quit

vSIG()	quit "60435^45717^Shriram Deshpande^30211"	// Signature - LTD^TIME^USER^SIZE
