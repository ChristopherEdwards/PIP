LNINTRC(RecordLN ln)	
	/*
	       ORIG:  Chuck Hardy (6721) - 03/31/87
	       DESC:  Attempt to recalc Billed int with BAL, etc.
		      Called from LNCONBL procedure.
	  ARGUMENTS:

		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF

	      INPUT:
	     OUTPUT:

	   The goal of this routine is to determine what the value of BALINT
	   will be if unpaid principal is subtracted from the ledger balance.

	   Loans which are delinquent:

	    1)  Start with today's ledger balance.  That's the balance in the
	        first bill to be generated.

	    2)  DECREASE that balance to find what the balance was for the next
	        due payment.  The XBAL array should begin with today's ledger
	        balance.

	    3)  Delinquency is when the next due date is less than CEFD.


	   Loans which are paid in advance:

	    1)  Start with today's ledger balance.  That's the balance that
	        should be in the final bill generated.

	    2)  INCREASE that balance to find what the balance was for each
	        previous due future payment.  The XBAL array should begin with
	        the balance that existed "n" payments ago.  The final entry
	        should be the current balance (PPA's aside).

	    3)  Advance is when the next due date is greater than SCHND, where
	        SCHND was determined from CEFD.

	    4)  A partial payment balance requires that an additional bill be
	        generated.


	   NOTE:  This routine is only intended to support ICPA's which subtract
	          unpaid principal.  Other permutations cannot necessarily be
	          determined.

	---- Revision History ------------------------------------------------

	04/19/02 - Diana Shvachkina - 49794
		   Converted to PSL.
	
	1/18/97 -  Spier
	           Modified A1 section to set values for BAL and LD, this seems
	           to have been missed in 2/3/95 retrofit.

	09/24/96 - Bob Chiang - 20948
	           Modified routine to remove node 49 default logic.

	02/03/95 - Steve Canfield - 10194
	           Retrofit changes from V4.4, ARQ 15171:

	           Modify section B to call ^UIC for interest, and add
	           logic to not subtract unpaid principal if ICPA was set
	           to zero.

	11/17/93 - Steve Canfield - 9932
	           Replace product type access with call to ^SKLLOAD
	           as part of multicurrency product type processing.

	7/18/92 -  Chuck Hardy

	           Modified "B" paragraph to call the ^UFINC utility to
	           compute future values.  This resolves the problem of zero
	           interest rates.

	*/	

	catch vError {
		new ET,RM
		set ET=vError.type

		if ET["%GTM-" do ZE^UTLERR quit

		set ET=ET_"-"_vError.thrownAt
		set RM=vError.description
		do ^UTLERR
		}

	new B,C,D,E,F,I,IR,O,PA,PT,PV,X
	new DIST1AF,DIST1FRE,FRE,IACM,ICPF,ICPA,IRN,PA,PCM,PT,SCHND,SCHLD 

	if '$D(CEFD) set CEFD=%SystemDate
	set C=0

	if 'ln.getPointer() do {
		type RecordLN ln=Db.getRecord("LN","CID=:CID")
		}

	//Ledger Balances
	set B=ln.bal

	// Unadvanced Balance
	if ln.aruf set B=B-ln.udbal

	// Int/Div Paid - Life
	else  if $E(ln.iam)=1 set B=B-(ln.iun-ln.ipl)
	set F=B

	// Distribution 1 Annual Factor
	set DIST1AF=ln.dist1af

	// Distribution 1 Frequency
	set DIST1FRE=ln.dist1fre

	// Nominal Int/Div Rate
	set IRN=ln.irn

	// Interest Accrual Method
	set IACM=ln.iacm

	// Interest Calculation Period Frequency
	set ICPF=ln.icpf

	// Scheduled Payment - Next Date
	set SCHND=ln.schnd

	// Scheduled Payment - Last Date
	set SCHLD=ln.schld

	// Interest Calc Principal Adjustments
	set ICPA=ln.icpa 

	type RecordUTBLICPA utblicpa=Db.getRecord("UTBLICPA","KEY=:ICPA")
	set ICPA=utblicpa.prio

	// Distribution 1 Frequency
	set FRE=ln.dist1fre
	if FRE="" set X(0)=B do END quit

	// Payment Calculation Method
	set PCM=ln.pcm

	if '$D(PCM(PCM)) do {
		type RecordSTBLPCM stblpcm=Db.getRecord("STBLPCM","PCM")
		set PCM(PCM)=stblpcm.pcmp
		}

	if '$E(PCM(PCM)) set X(0)=B do END quit

	// Distribution 1 Annual Factor
	set IR=ln.irn/(ln.dist1af*100)

	// Principal and Interest Payment
	set PT=ln.pmtpi

	set PA=ln.ppa 
	if 'PA do A(.ln) quit

	// Payment Escrow Amount
	set E=ln.pmttrs

	while O-B do { quit:ER
		set I=$$^SCARND(B*IR,0,"","",8) 
		set O=B 
		set B=F+PA-I-E
		}

	if ER quit
	set F=$$^SCARND(O,0,$G(CID))
	do A(.ln)

	quit

Public A(RecordLN ln)	// Determine direction

	set X(0)=B
	// Distribution 1 Next Due
	set ND=ln.dist1nd

	// Loans which are delinquent (BALINT drops from today's balance)
	if ND<CEFD do { quit
		set FRE="-"_FRE 
		set JD=CEFD 
		set D=-1 
		do A1
		}

	// Scheduled Payment - Next Date
	set SCHND=ln.schnd

	if SCHND'>CEFD do { quit:ER
		set JD=CEFD
		set SCHND=$$NJD^UFRE(JD,FRE) 
		}

	// Loans which are current
	if SCHND=ND,'PA do END quit

	/*
	 Loans which are advance (BALINT starts higher than today's balance
	 and drops)
	*/
	set JD=SCHND 
	set D=1 
	set C=-1
	set X(-1)=B

	do A1
	
	quit
	
A1	//

	new QUIT
	set QUIT=0

	for  set NJD=$$NJD^UFRE(JD,FRE) quit:QUIT!(ER)  do {
		set JD=NJD
		set C=C+D 
		if D>0,NJD>ND do { quit
			set BAL=B
			set LD=SCHLD+1
			set ND=SCHND
			set QUIT=1
			}
		if D<0,NJD<ND do { quit
			set BAL=B
			set LD=SCHLD+1
			set ND=SCHND
			set QUIT=1
			}
		}
	
	if QUIT do B quit
	
	quit


B	// Place entries in X in order

	if C=0 do END quit

	while C'=0 do { quit:ER
		if 'ICPA set X(C)=BAL
		else  do { quit:ER
			set %INT=$$^UIC(BAL,LD,ND,IACM,IRN,0,DIST1AF,DIST1FRE,ICPF,SCHND,SCHLD)
			set %INT=$$^SCARND(%INT,0,$G(CID))
			set X(C)=BAL-PT+%INT
			set BAL=X(C)
			set LD=ND+1
			set ND=$$NJD^UFRE(ND,DIST1FRE)
			}
		set C=C-D
		}
	
	if ER quit

	if C=0 do END

	quit


END	// Place entries in XBAL in reverse order.

	new I
	set N=""
	set XBAL(1)=$$^SCARND(X(0),0,$G(CID))
	for I=2:1 set N=$O(X(N)) quit:(N=0!(N=""))  set XBAL(I)=$$^SCARND(X(N),0,$G(CID))
	quit

vSIG()	quit "59877^41846^Pat Kelly^5496"	// Signature - LTD^TIME^USER^SIZE
