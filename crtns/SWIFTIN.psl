public SWIFTIN	//Public;Incoming SWIFT Message Server
	/*
	   ORIG: CHENARDP - 03/17/94
	   DESC: Incoming SWIFT Message Server

	-------- Revision History ---------------------------------------------

	09/09/05 - KELLYP - CR 17050
		   Modified entire procedure to no longer reference the ST400
		   interface which has been obsoleted by SWIFT.  No new core 
		   interface for SWIFT is currently available (ICG maintains
		   an SAA interface).  The core linetags have been preserved
		   to allow for an easy transition to another interface at a
		   later time.  ST400 specific linetags have been removed.
		   Also removed pre-2003 revision history.
	
        07/26/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.
	              	
	01/13/04 - RussellDS - CR 7514
		   Modified to use change to table structure for table SWIFTERR.
		   Key column SWDIRECT was replaced with literal "INERR".
		   
		   Also, in SWFTIN section, moved setting of SWIFTERR to occur
		   only if we get an error in saving the SWIFT record.

	06/02/03 - SRIVASTAVAN - 51351
		   Converted to PSL
	  -------------------------------------------------------------------------

	*/

	type public Boolean ER

	type Boolean STOP

	set STOP=0

	// Call INIT to initialize server variables
	do INIT^SWIFTUTL
	
	// Open the connection

	if ER do { do CLOSE quit

		do ERR^SWIFTUTL

		// Server closed by an error - write to journal
		}

	catch vERROR {

		type String ET,RM

		set ET=vERROR.type

		if ET["%GTM-" do ZE^UTLERR quit

		set ET=ET_"-"_vERROR.thrownAt
		set RM=vERROR.description

		do ^UTLERR

		}
	
	while 'STOP do MAIN
	
	quit
	

MAIN	// Begin main processing loop

	// Check for stop signal (e.g., STOPCHK^SWIFTUTL)

	// Read incoming message

	// Handle timeout
	
	// Journal incoming msgs

	// Process message	
	do MSG
	
	quit
	

MSG	// Handle an incoming message

	// Verify message is formatted properly

	// Handle incoming response to an outgoing msg

	// Handle incoming unsolicited SWIFT message

	// Handle response

	// Journal (as necessary)

	quit


ACKNAK(String msg)

	/*
	 Determine whether incoming message is an acknowledgement or
	 a negative acknowledgement.
	
	   ARGUMENT:
	   . msg   	Incoming message to reformat		/REQ/MECH=VAL

	   RETURNS:
	   . 0 if we should reply with a NAK
	   . 1 if we should reply with an ACK

	   EXAMPLE:
	   . set reply=$$ACKNAK(msg)
	   
	*/

	// Requeue as necessary

	quit 1


CLOSE	// Close network channel

	// Close connections
	
	// Close journal files

	quit


REPLY(String reply)	// Format response

	/*
	   ARGUMENT:
	   . reply   	Response		/REQ/MECH=VAL

	   RETURNS:
	   . x	message 
	    
	   EXAMPLE:
	    
	    $$REPLY(reply)
	*/
	
	type String X
	
	set X=""

	quit X


SWFTIN(String msg)	// Process unsolicited incoming SWIFT message

	/*
	   ARGUMENT:
	   . msg   	Incoming Swift message			/REQ/MECH=VAL

	   RETURNS:
	   . 
	   EXAMPLE:
	    set reply=$$SWFTIN(msg)
	*/

	type public String ER,MSG,RM,SWDIRECT,svrdir,SWIFT(),TRREFNO
	type public String SWARR13C,SWARR23E,SWARR71F,SWARR77T
	type String MESSAGE1,MESSAGE2,MESSAGE3,MESSAGE4
	type Number ack
	type Public Number dupl,refno,typ
	type RecordSWIFT fSWIFT
	type RecordSWIFTSEQ fSWIFTSE()

	kill SWARR13C,SWARR23E,SWARR71F,SWARR77T

	set ack=0
	
	set ack=$$MSGIN^SWIFTFMT(msg,.fSWIFT,.fSWIFTSE(),.refno,.typ,.dupl)

	// If hit a mumps error, stop here
	if ack.get().isNull() quit (0)

	// No error except for ack/nack
	if ER set ER=0,RM="" quit (0)

	// What about duplicate handling....(dupl)
	set MSG=typ
	set SWDIRECT=svrdir

	set fSWIFT=Db.getRecord("SWIFT","SWDIRECT=:SWDIRECT,TRREFNO=:refno,MSG=:MSG",1)

	set fSWIFT.swftdt=%SystemDate 
	set fSWIFT.status=8

	// Lock the record & store last nbr
	lock +SWIFT("IN"):2

	type RecordSWIFTREF fSWIFTR=Db.getRecord("SWIFTREF","SWDIRECT='IN'",1)
	set TRREFNO=fSWIFTR.trrefno+1
	set fSWIFTR.trrefno=TRREFNO

	do fSWIFTR.bypassSave()

	lock -SWIFT("IN")

	// File into SWIFT global
	do fSWIFT.save()
	
	if ER do {
	
		type RecordSWIFTERR fSWIFTER=Db.getRecord("SWIFTERR","TRREFNO=:TRREFNO,MSG=:MSG",1)

		set MESSAGE1=fSWIFTER.message1
		set MESSAGE2=fSWIFTER.message2
		set MESSAGE3=fSWIFTER.message3
		set MESSAGE4=fSWIFTER.message4

		do fSWIFTER.save()
		}
		
	// File into "REC" queue
	do QUEUE^SWIFTGEN("REC",%SystemDate)

	if ER do ERR^SWIFTUTL

	quit (ack)
 #OPTION ResultClass ON
Public String vSIG()	quit "60156^58290^Pat Kelly^4079"	// Signature - LTD^TIME^USER^SIZE
