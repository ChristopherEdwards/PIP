public LNPTS2(RecordLN ln, RecordTTX ttx, RecordTRN trn)

	/*
		Loan Transaction Processing Controller
	
	---- Revision History ------------------------------------------------

	11/30/06 - SANTHUMS - CR 24210
		   Modified TSOESC section to set UTSO("LNFEEIN")if posting 
		   action control is LNPTS41 with a CTL of "0110" and 
		   ttx.tso contains "LNFEE" this was required to prevent 
		   error "Fee type required to process transaction" 
		   during reapplying the transaction in ^LNPTS41. 
		   
	08/31/06 - GIRIDHAL - CR 22780
		   Modified UPDAVB to set EOMJD and BJD to %EffectiveDate
		   instead of ttx.efd since the top of the routine sets 
		   %EffectiveDate to %SystemDate when ttx.efd is null.
	
	07/31/06 - KELLYP - CR 22048
		   Modified PLSUB section to eliminate PRECEDENCE warning.

	06/15/06 - Dhanalakshmi R - CR 22041
		   Modified the section MLSPENTR by moving the block that sets
		   OVR(CID,"OVR","DARCLS") before calling the section AL. This
		   ensures that OVR for DARCLS is set before quitting MLSPENTR.

	06/15/06 - KELLYP - CR 20910
		   Modified the AL2 section to set STRC = 0 when STR is
		   re-defined.  In this case, STR1A should start w/ the PAC 
		   routine at the beginning of STR because it means that ZAMT 
		   hasn't been entirely used up and the PDC and PF values 
		   changed at some point in the posting process (e.g., the loan 
		   was brought current during grid-based payment processing). 
		   Also added detailed documentation to the AL2, STR1, STR1A,
		   and STR2 sections.  Also modified EXIT and PLSUB sections 
		   to use ttx stored values.

	05/03/06 - KELLYP - CR 21025
		   Modified PDC section to retrieve the LNPDAG.LIMIT value
		   based on PDS-1 instead of PDS.  This corrects a problem 
		   where the system was returning the wrong payment due
		   category, which caused the payment string for grid-oriented
		   payments to be incorrect, and is consistent with how the
		   same code works in P01.  Also removed extraneous call to
		   STR2 at the end of STR1A (was not called this way in prior 
		   versions).

	04/18/06 - TITOVE - CR 20701
		   Retrofitted CR 260 from Profile01. Changed comparison in 
		   NBTR section from LN.PMTORG to LN.PMT, since PMTORG is
		   usually null for revolving credit loans.

	03/17/06 - BHOLT - CR19731
		   Modified the STR2 section, substituted ttx.itc1 in place of 
		   trn.itc which causing error in LCTO transcation.
		   
	03/03/06 - KELLYP - CR 19885
		   Modified MLSPENTR to use %SystemDate instead of CUVAR.TJD.
		   Also modified reference of ln.pmtdelqr'="" to ln.pmtdelqr
		   (this is a logical field so it will never be null).

	02/27/06 - KELLYP - CR 19794
		   Modified SBTP section to use Db.getRecord(,,1) instead of
		   Class.new for the DAYENDSBT record. This prevents a "RECONFL"
		   error from occurring during backdated transaction posting.

	02/09/06 - TITOVE - CR 19271
		   Modified SBWAMT section not to reset the value of
		   TTX.TAMT (logic restored from Profile01). This caused
		   incorrect amounts to be filed into TTX and HIST tables.

	02/02/06 - DHANALAKSHMI R - CR 19273
		   Modified the section MLSPENTR by adding the condition to 
		   check the Scheduled Payment - Last Date with the System 
		   Date for setting the override OVR(CID,"OVR","DEL2").

	01/27/06 - SmithCD - CR 19343 (16890)
		   Removed setting of LFD, as promised below with CR 18300.
		   Removed newing of %NOREV before call to LNPTSRV (%NOREV is 
		   no longer used).
	
	01/05/06 - Hillanbrand - 17730
		   Removed additional check if ln.trb-trn.pcf do 
		   STR2A(.ln,.trn,.ttx) quit in the STR2 subsection which was 
		   causing the transaction to quit early and get a not all 
		   funds applied error.  	   
		   
	11/18/05 - SmithCD - CR 18300
		   Temporarily put back the setting of LFD that was removed 
		   with CR 16890 to resolve a loading conflict. This will be 
		   once again removed when CR 16890 is ready for release.
	
	10/14/05 - HILLANBRAND - CR 17727
		   Modified PDC section to get the next value in
		   LNPDAG.LIMIT.  Removed the - 1 when setting PDS.

	10/05/05 - SRINIVAR - CR 16890
		   Removed the call to to EXIT on error in MLSPENTR^LNPTS2
		   to avoid the undefined error on BALCMP.
		   Removed the variable LFD and its related code since this
		   is no longer needed since unwind/reapply logic was added 
		   to the system. 

	08/12/05 - TITOVE - CR 16844
		   Modified STR2 tag by removing unused argument from call
		   to MRPT^SUSPROC.

	06/10/05 - KELLYP - CR 16218
		   Modified PDC and GRID sections to retrieve LNPDAG.LIMIT 
		   correctly.

	06/07/05 - Carol Scott - CR 15816
		   Added checks for ttx.efd to determine if it is defined 
		   before using it to do date compairs.
		   Typed some of the variables.
		 
	05/10/05 - HILLANBRAND - CR 13281
	           Changed variable checking on transaction mode to check
	           TRNMODE.
	
	04/06/05 - HILLANBRAND - CR 13281
		   Correct several issues that was preventing a payment to 
		   process. Removed new of SEQ in MLSPENTR as SEQ should be
		   public when used throughout LNPTS* transaction routines. 
		   SEQ should be public when used. In DELP change ttx.efd to 
		   %EffectiveDate since the top of the routine sets 
		   %EffectiveDate to %SystemDate when ttx.efd is null.  In AL2 
		   changed PDAG to ln.pdag since PDAG is not a public variable.
		   Removed quit in STR2A after call to SBTA so that the call
		   to EXIT is done which will finish with a call LNPTS1.
		 
	04/01/05 - KELLYP - CR 13667
		   Moved initialization of STRC variable from AL2 to Al1A to
		   prevent an infinite loop from occurring on loan payments
		   that used a payment grid instead of specified posting
		   control routines.
	
	01/14/05 - KELLYP - CR 13667
		   Removed code from the STR1 & STR1A sections that built the 
		   parameter lists for loan posting routines.  The TRNINI* 
		   procedures have been updated with the correct parameter 
		   lists so the transaction code def's now contain the correct
		   parameter lists (so they don't need to be built).  
		   
		   Modified the STR1, F1, and GRID sections to use a tab, 
		   instead of a comma, as the delimter between posting routines 
		   in the PSTR variable since parameter lists now contain 
		   commas.  Also modified the STR1, STR1A, F1, and GRID sections
		   to conform to current PSL standards.
	
	01/20/04 - CARROLLJ - CR 7444
		   Roll changed forward to remove call to LNPTS2B.

	----------------------------------------------------------------------
	
	*/


	set %EffectiveDate=ttx.efd 
	if %EffectiveDate="" set %EffectiveDate=%SystemDate
	do MLSPENTR(.ln,.ttx,.trn)
	quit

	
public MLSPENTR(RecordLN ln,RecordTTX ttx,RecordTRN trn)

	/*
	   If backdated, and loan has already been "brought current",
	   run auto-reversal process.
	
	   If a new account is being created, don't call ^LNPTSRV
	
	*/

	// External Transaction Code
	set ETC=ttx.etc

	if %EffectiveDate<%SystemDate do { if ln.bndt'<%SystemDate,ttx.tcmt'=$$^MSG(3956) do ^LNPTSRV(.ln,.trn,.ttx) quit
		set CUVAR2=%SystemDate
		}
	
	if '$D(CUVAR2) set CUVAR2=%SystemDate
	new FINB,TAXB,TAXYEOFF,YEOFF
	set YEOFF=CUVAR.YEOFF
	set TAXYEOFF=CUVAR.TAXYEOFF
	set FINB=$$BOFY^SCADAT(CUVAR2,1)
	set TAXB=$$BOTY^SCADAT(CUVAR2,1)
	
	new ADJ,AP,B,BILL,CTL,DATA,DELP,E23,I,IDC,INT,LCFLG,LNPDT,LTC,N
	new NSTR,OE23,OTP,P,PCFL30,PDC,PDS,PF,PMT,PP,PR,PRETRN,PRI,PRN
	new PSTR,RFLAG,SAVE,SSEQ,STR,STRC,T,TAMT,TB,TP,UAVB,XPDC,Y,Z,ZAMT
	

	// New all data items initialized by LNPTS2A
	new ADDLCHG,BSEQ,CNTDR,CRLMT,DDRA,DIC,DIST1FRE,DIST1LD,DIST1ND,DPMT,EPA
	new FRE,IAM,ICPA,INCRS,IPL,IPY,LCHG,LIMIT,MCHG,NARL,OSEQ,OVR1,PAF,PCM
	new PDAG,PFLG,PNTMIN,PPA,prvbil,RFLG,RND,SBALCMP,SCHSEQ,SIRN,TFLG,TRB
	new TSEQ,UTSO


	// "Do grid" = 0/1.  Indicates whether or not to process the grid.
	type Boolean dogrid 
	set dogrid=0

	new X
	
	set CTL=1
	set %RM="" 
	if RM.get() set %RM=RM


	set LCFLG=$S(+ttx.tamt-$P(ttx.tamt,"#",4)=0:1,1:0)
	set TAMT=+ttx.tamt 
	set ttx.tamt=TAMT
	set OE23=$P(ttx.lnerc,"#",1) 
	if ttx.itc6 set OE23=""
	if OE23?5N set OE23=""
	do TSOESC(.ttx)
	set TSO=ttx.tso do OUT^UTSO(.TSO,TSO)
	set RFLAG=$G(TSO("RFLAG"))

	set IDC=ttx.itc1
	
	set TYPE=ln.type
	set DIST1LD=ln.dist1ld
	do INIT^LNPTS2A(.ln,.ttx)
	set INCRS=ln.trb-trn.itc
	
	// EFFECTIVE DATE PROCESSING
	set CRCD=ln.crcd 
	
	if %EffectiveDate<ln.odd do { quit:ER
		new odd

		// Accept if undisbursed principal transaction
		if %SystemDate=%EffectiveDate,$$UNDTRAN quit 
	
		//Allow payoff transaction
		if trn.pcfl5 quit
	
		/*
		If fee transaction, acceptable.  Fee assessments and
		deferrals are often effective prior to the first disbursement.
		*/
		if $$FEETRAN(.ttx) quit
	
		// Allow accrual adjustments 
		if trn.pcfl20 quit
	
		set ER=1
		// Return error if EFD is less than date of note.
		if %EffectiveDate<ln.dtnt set ET="EFDDTNT" do ^UTLERR quit
	
		// Otherwise, return error
		do Runtime.setErrMSG("LN",447,$$DAT^%ZM(ln.odd,$G(%MSKD)))
		}

	/*
	Process override if an asset classification is defined on account.
	[LN]DARCLS contains a value or if [LN]DARCOVR has a value
	*/

	if ln.darcls'=""!(ln.darcovr'="") do { 
		new AC,DESC
		set AC=ln.darcls
		if ln.darcovr'="" set AC=ln.darcovr
		Type RecordUTBLACC utblacc=Db.getRecord("UTBLACC","CLS=:""L"",AC=:AC")
		set DESC=utblacc.desc

		//	|This account is <DARCLS> 
		set OVR(CID,"OVR","DARCLS")=DESC
		}

	set T=",I,P,M,L,U,"
	set %ATA=0
	
	kill TP set TP=1 set OTP=0
	if ln.stat,ln.stat'=1 set OVR(CID,"OVR","STAT"_ln.stat)=""
	if ln.rflg do ^UFLG(.ln)
	set PDS=$$PDS^LNUBIL1(ln.dseq,ln.schseq)

	if (ln.trb&('ttx.itc1)) do AL(.ln,.trn,.ttx) quit
	if 'ln.trb&ttx.itc1 do AL(.ln,.trn,.ttx) quit

	/*
	Process override if loan payment (credit) on a delinquent account.
	[LN]PMTDELQR contains a value.
		|Delinquent account - transaction requires approval 
	*/

	if (%SystemDate>ln.schld),(ln.pmtdelqr),(-(PDS)'<ln.pmtdelqr) set OVR(CID,"OVR","DEL2")=""
	
	// DEFINE PDS AND PDC USE THE LOAN RECORD TO INSURE TOTAL FLEX
	set Z=ln.ppdcat1_"|"_ln.ppdcat2_"|"_ln.ppdcat3_"|"_ln.ppdcat4
	set Z=Z_"|"_ln.ppdcat5_"|"_ln.ppdcat6_"|"_ln.ppdcat7_"|"_ln.ppdcat8
	set Z=Z_"|"_ln.ppdcat9_"|"_ln.ppdcat10	
	for I=1:1:ln.npc set XPDC($P(Z,"|",I+ln.npc))=I set PRI(I)=$P(Z,"|",I)
	
	// Force vertical payment
	if trn.pcfl17 for I=1:1:ln.npc set PRI(I)=$TR(PRI(I),">#","vv")
	
	do AL(.ln,.trn,.ttx)
	quit
	
public AL(RecordLN ln,RecordTRN trn,RecordTTX ttx)
	
	set BALCMP=ln.bal+0
	if ln.aruf set BALCMP=BALCMP-ln.udbal
	
	do PRETRN(.ln)
	
	if 'ln.pflg do DELP(.ln,.trn,.ttx) quit
	
	// Set data for daily reporting of sold loans
	set LNPDT=BALCMP_"||"_ln.teb_"|"_ln.tld      
	set LNPDT=LNPDT_"|"_ln.dist1ld_"|"_ln.lpdt   

	do DELP(.ln,.trn,.ttx)
	quit
	
public DELP(RecordLN ln,RecordTRN trn,RecordTTX ttx)

	// If account is delinquent, capture data for reporting
	if ((ln.dist1nd+ln.ddra)'<%EffectiveDate)!('trn.pcfl9) do AL1A(.ln,.trn,.ttx) quit
	
	// Distribution 1 Last Due
	set DELP=ln.type_"|"_ln.tld_"|"_ln.lpdt_"|"_ln.dist1ld

	// Late Charge Due
	set DELP=DELP_"|"_ln.ppa_"|"_ln.lchg_"|"

	// Total Escrow Balance
	set DELP=DELP_ln.tdue_"|"_BALCMP_"|"_ln.teb
	do AL1A(.ln,.trn,.ttx)
	quit

public AL1A(RecordLN ln,RecordTRN trn,RecordTTX ttx)
	
	type Number STRC
	type public Number TAMT
	
	set ZAMT=+TAMT
	set STRC=0

	/*
	Set partial/full flag to zero (partial) as a default.
	This will be reset correctly later if the grid is to be used.
	*/

	set PF=0
	set DPMT=ln.dpmt
	set PDC=$$PDC(.ln)

	/*
	Get value for STR:
	  - Will be a Posting Action Control (PAC) routine name & parameters
	    (e.g., ^LNPTS7(.acn,.ttx,.trn))
	  - Or will be numbers indicating which pieces of product 
	    to extract tran codes from
	    (e.g., 20,4,6  etc..)
	*/
	set STR=trn.pac	

	kill TB for I="P","I","L","U","M" set TB(I)=""
	if (ln.trb&'ttx.itc1)!(ln.cls'="L") do AL2(.ln,.trn,.ttx) quit
	if ('ln.trb&ttx.itc1) do AL2(.ln,.trn,.ttx) quit

	if ln.bseq>0 do {
		type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:ln.bseq",1)
		set Z=$$BIL1ELE^BILFUNCS(.lnbil1)
		}
	else  do {
		type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID=:CID")
		set Z=$$BIL0ELE^BILFUNCS(.lnbil0)
		}
	for I=1:1:20 set X=$P($P(Z,$C(9),I),"#",1) quit:X=""  set TB(X)=0
	//300#58945#58946#300#300#300#10000###9|I|P##300#300
 
	// Determine status of payment: partial or full
	set BILL=0
	if STR="" do {
		set dogrid=1
		if ln.dist1nd>ln.lbdd,$E($$PCM(ln.pcm),5) set DPMT=$$AMT^LNBLDE(.ln,.ttx,CID)
		if TAMT<(DPMT-ln.ppa) set PF=0
		else  set PF=1
		if 'DPMT set PF=0
		}
	else  set PF=0
	do AL2(.ln,.trn,.ttx)
	quit

AL2(RecordLN ln,RecordTRN trn,RecordTTX ttx)
	/*
	 This is essentially the "top" of the transaction application 
	 process.  It is called from several places within this procedure, 
	 but primarily is either called from AL1A (making it the true "top"
	 of the application process) or from STR1A (after a posting routine 
	 has been called).  
	 
	 In the latter case it means grid-based processing is being used & 
	 the payment due category (PDC) and full payment indicator (PF) 
	 changed while there were still funds left to distribute (ZAMT>0).  
	 This can happen when a payment is due and a payment in excess of 
	 the due amount is made using a general purpose payment transaction 
	 code (e.g., LP, RP, etc.).
	*/

	type public Boolean dogrid
	type public Number STRC
	type public String ETC, PF, PDC, PSTR, SAVE, STR
	
	if dogrid do {
		type RecordLNPDAG lnpdag=Db.getRecord("LNPDAG","GRP=:ln.grp,TABLE=:ln.pdag,PFF=:PF,LIMIT=:PDC")
		set STR=lnpdag.pymt

		// Since STR is re-defined here, STRC needs to be re-initialized to
		// zero so that we start at the beginning of the new payment string.
		set STRC=0
		}

	// PROCCESS PER THE PSTR VARIABLE	
	if STR'?1N.N.",".E set PSTR=STR_":"_ETC
	// BUILD PGMS IF STR IS A STRING OF NUMBERS
	else  do FIND(STR,.PSTR,.ln,.trn,.ttx)
	
	/*
	 For PAC's: PSTR="^LNPTS7(.acn,.ttx,.trn):MD"
	 For Num's: PSTR="^LNPTS9(.acn,.ttx):MLC,^LNPTS8(.acn,.ttx):MMC,^LNPTS7(.acn,.ttx,.trn):MDEB"
	*/

	kill SAVE

	do STR1(.ttx,.ln,.trn)

	quit

public STR1(RecordTTX ttx,RecordLN ln,RecordTRN trn)

	/*
	 This is the "middle" of the transaction application process and
	 is responsible for:

	 	- Incrementing STRC which is the piece of the STR posting 
	 	  routine control string that is about to be processed.
	 	  
	 	- Calling STR2 when we run out of posting routines to call.
	 	
	 	- Other processing, notably setting up var's used by STR1A.
	*/
	
	type public Boolean dogrid,ODSWP,PF,RFLAG
	type public Number PDS,STRC,ZAMT
	type public String ER,LTC,NSTR,OE23,PDAG,PSTR

	set STRC=STRC+1
	
	// 13667 - Use Tab delimiter instead of comma for separating posting routines in PSTR
	set NSTR=$P(PSTR,$C(9),STRC) if NSTR="" do STR2(.ln,.trn,.ttx) quit
	
	if NSTR=0,'$D(ODSWP) do { quit
		type RecordPDAG pdag=Db.getRecord("PDAG","GRP=:ln.grp,TABLE=:PDAG")
		type ResultSet rs=Db.select("DES","LNPDS2","TABLE=:pdag.pdst AND UPLIMIT>:PDS-1")
		if rs.next() do {
		
			// Transaction rejected by action grid (full payment, ~p1 category)
			if PF do Runtime.setErrMSG("LN",2735,rs.getCol(1))

			// Transaction rejected by action grid (partial payment, ~p1 category)
			else  do Runtime.setErrMSG("LN",2736,rs.getCol(1))
			}
		}
	
	if NSTR=0,RFLAG do { quit
		/*
		If there is still an amount in ZAMT, then send the remainder
		back in the transaction.
		*/
		set ttx.tso=$$FIELDIN^UTSO(ttx.tso,"REMAINDER",ZAMT)
		}
	
	// 13667 - Use Tab delimiter instead of comma for separating posting routines in PSTR
	if NSTR="*" do GRID(.ln,.trn,.ttx) set NSTR=PSTR.piece($C(9),STRC) set dogrid=1
	
	set LTC=NSTR.piece(":",2) 
	set NSTR=NSTR.piece(":",1)
	
	// Processing Control Flags
	type String E23
	set E23=trn.pcf 
	if 'OE23.isNull() set E23=OE23

	do STR1A(.ln,.trn,.ttx)
	quit

public STR1A(RecordLN ln,RecordTRN trn,RecordTTX ttx)

	/*
	 This is the posting control routine execution label and is
	 responsible for calling the posting control routine defined
	 by the NSTR input variable.  The end of this section makes
	 decisions on what to do after calling @NSTR based on what
	 happens to the loan as a result of calling the posting 
	 control routine. 
	*/

	type public Boolean dogrid,PF
	type public Number %ATA,CID,PDC,ZAMT
	type public String E23,ER,NSTR,OVR(,,),PR(,),STR

	// Call the posting control routine
	if NSTR.length()>1 do @NSTR

	if ER do EXIT(.ln,.trn,.ttx) quit
	
	// TRN.PCFL7 - Display restriction if Late Charge Ignored	
	if E23.extract(7) do {
		// Payment ignores late charge of $<LCHG> 
		if ln.lchg set OVR(CID,"OVR","LCHG")=$$^SCARND(ln.lchg,0,CID)
		}
	// TRN.PCFL6 - Display restriction if Misc Charge Ignored
	if E23.extract(6) do {
		// Payment ignores miscellaneous charge of $<MCHG> 
		if $$MCND^LNCO3(,.ln) set OVR(CID,"OVR","MCHG")=$$^SCARND(ln.lchg,0,CID)
		}

	type Number N
	set N=""
	for  set N=PR(CID,N).order() quit:(N.isNull())!(N>ln.bseq)  kill PR(CID,N)

	// Apply Transaction Again
	if %ATA=1 set %ATA=2 do AL2(.ln,.trn,.ttx) quit

	// Unapplied transaction amount remaining and we're using a PAC instead
	// of a grid.  Go to STR1 to call the next PAC.
	if ZAMT,'dogrid do STR1(.ttx,.ln,.trn) quit
	
	// No unapplied transaction amount remains (ZMT all used up).  Go to
	// STR2 to finish up.
	if 'ZAMT do STR2(.ln,.trn,.ttx) quit
	
	/*
	 The following code is for on-line bill generation for loans that permit
	 it and that are generating bills in advance.  DPMT is redefined here to 
	 determine the next full bill amount so that the remainder of ZAMT can be
	 used to satisfy it, if appropriate.
	*/
	type Number DPMT
	set DPMT=ln.dpmt
	if ln.dist1nd>ln.lbdd,$$PCM(ln.pcm).extract(5) set DPMT=$$AMT^LNBLDE(.ln,.ttx,CID)

	/*
	 Not enough ZAMT for a full payment and the payment due category
	 hasn't changed as a result of calling the last PAC.  Go to STR1 
	 to process the next PAC.
	*/
	if 'PF,PDC=$$PDC(.ln) do STR1(.ttx,.ln,.trn) quit

	/*
	 Full payment status and payment due category both haven't changed
	 as a result of calling the last PAC.  Go to STR1 to process the 
	 next PAC.
	*/
	if PF=$$PF(.ln),PDC=$$PDC(.ln) do STR1(.ttx,.ln,.trn) quit

	// Redefined full payment/payment due category statuses
	set PF=$$PF(.ln) 
	set PDC=$$PDC(.ln) 
	set STR=""
	
	// Call AL2 to start applying the remaining ZAMT using a new 
	// set of PAC's based on the new PF & PDC values.
	do AL2(.ln,.trn,.ttx)

	quit


public STR2(RecordLN ln,RecordTRN trn,RecordTTX ttx) 

	/*
	 This section is the "end" of the transaction application process 
	 and is used primarily for setting up various overrides and 
	 redefining account values for the "post-transaction" state.
	*/

	type public Date CUVAR2
	type public String OVR(,,)

	// Call AL2 to start applying the remaining ZAMT using a new 
	// set of PAC's based on the new PF value.
	if '%ATA,PF,ZAMT set PF=0 if dogrid do AL2(.ln,.trn,.ttx) quit

	/*
	  If remainder flag is activated, then this is a sweep. Set
	  the remainder and send it back.
	*/
	
	new UTSO,REMAINDER,RFLAG,DLFP,LPDT
	
	do LDATE(.ln,.trn,.ttx)
	
	set TSO=ttx.tso
	do OUT^UTSO(.UTSO,.TSO)
	
	set RFLAG=$G(UTSO("RFLAG"))
	set REMAINDER=$G(UTSO("REMAINDER"))
	
	if $D(ODSWP),RFLAG,ZAMT do {
		set REMAINDER=ZAMT
		set UTSO("REMAINDER")=REMAINDER
		set TSO=""
		do IN^UTSO(.UTSO,.TSO)
		set ttx.tso=TSO
		}

	/*
	 The following error message is returned when the full set of
	 PAC routines has been called but the entire transaction amount
	 could not be applied based on the posting action control routine
	 defined on the initial transaction code or as per the grid 
	 derived from the payment due category and full payment status.
	 
	 This could be caused by a configuration issue with the payment
	 due action grid (e.g., when an LP is processed but the loan's 
	 grid doesn't include principal-only payments).  It could also be 
	 caused by an excessive amount entered for a "targeted" transaction 
	 code (e.g., LPCO will only pay down late charges and misc. charges
	 and if the transaction amount is greater than the sum of those, then
	 there will be a remainder that can't be distributed).
	 
	 Don't assume this error message is a bug!!!
	*/

	// Trans not processed. Funds not applied.
	else  if ZAMT do Runtime.setErrMSG("LN",4172) do EXIT(.ln,.trn,.ttx) quit
	
	// Transaction - Last Date
	set ln.tld=CUVAR2
	
	if ln.dist1nd>PRETRN("DIST1ND") do {
		// Store old value of DLFP in case this transaction is reversed
		set ttx.tso=$$FIELDIN^UTSO(ttx.tso,"DLFP",ln.dlfp)
	
		// Set new value in loan record
		set ln.dlfp=%SystemDate
		}
	
	if 'trn.pcfl5,+ln.paylkamt do {

		/*
		Locked for payoff - transaction requires approval
			|Locked for payoff - transaction requires approval 
		*/

		if (ttx.efd),ln.paylkfrm'>ttx.efd,ln.paylkto'<ttx.efd set OVR(CID,"OVR","POLO")=""
		}

	if trn.pcfl7 do {
		set Y=ln.lchg
		//	|Payment ignores late charge of $<LCHG> 
		if ln.lchg set OVR(CID,"OVR","LCHG")=$$^SCARND(Y,0,CID)
		}

	if trn.pcfl6 do {
		set Y=$$MCND^LNCO3(,.ln,CID)
		//	|Payment ignores miscellaneous charge of $<MCHG> 
		if Y set OVR(CID,"OVR","MCHG")=$$^SCARND(Y,0,CID)
		}

	if trn.pcfl9 do {

		//	|Loan is in a purchased pool 
		if ln.ppflg set OVR(CID,"OVR","PPFLG")=""
	
		// Store old value of LPDT in case this transaction is reversed
		set ttx.tso=$$FIELDIN^UTSO(ttx.tso,"LPDT",ln.lpdt)

		/*
		Set new value of LPDT for the very last loan record for 
		all previous records in case we need to reverse any.
		*/
	
		set ln.lpdt=ln.tld
		else  set ln.lpdt=ln.tld
		}
	
	
	// Check if balance is reduced and flag to "Ignore Neg Am Fields" is off
	set PAMT=ttx.tamt 
	set PAMT=$P(ttx.tamt,"#",2)+$P(ttx.tamt,"#",5)
	do EXPCOM(.ln,.trn,.ttx,PAMT)

	// Check restrictions related to problem loan sub-account processing
	do PLSUB(.ln,.trn,.ttx) 
	if ER quit 
	if ln.trb-ttx.itc1 do STR2A(.ln,.trn,.ttx) quit
	
	do CHGOF(.ln,.ttx)
	set TSO=ttx.tso
	set RECOV=$$RECOV(TSO)
	do CONT(.ln,.ttx)
	
	if ttx.tso="" do OUT^UTSO(.TSO,ttx.tso)
	if ER do EXIT(.ln,.trn,.ttx) quit
	if 'PAMT do STR2A(.ln,.trn,.ttx) quit
	if trn.pcfl3 do STR2A(.ln,.trn,.ttx) quit

	/*	
	Check for custom notice production based on monetary transaction on
	a delinquent account.
	*/

	// Custom Notice Production
	if ln.custnot'="" do ^LNCUSNOT(.ln,CID,1) 
	
	/*
	Update Suspense file for movement of interest suspense
	if flag is on to report
	*/

	if CUVAR.MRPT,ln.darcls do {
		new AMT,LN,XHS16
		set AMT=$P(ttx.tamt,"#",3)
  
		do MRPT^SUSPROC(.ln,CID,.AMT,$$EOMJD^SCADAT(CUVAR2,1),1,ln.woff)

		// written off
		set XHS16=ttx.lnerc
		if ln.woff set $P(XHS16,"#",31)=AMT_","_CUVAR2

		// written back
		else  set $P(XHS16,"#",30)=AMT_","_CUVAR2

		// Loan Error-Correct Data
		set ttx.lnerc=XHS16
		}
	set NAR=$S(PAMT>(ln.dic-ln.narl):ln.dic-ln.narl,1:PAMT) 
	if NAR'>0 do STR2A(.ln,.trn,.ttx) quit
	set ln.narl=ln.narl+NAR 
	set ln.ipl=ln.ipl+NAR 

	// Reserved - Neg Am Reduction
	if (ttx.efd),(YEOFF)&(ttx.efd<FINB)&(CUVAR2'>(FINB+YEOFF)) set ln.ipy=ln.ipy+ttx.dir
	else  set ln.iytd=ln.iytd+ttx.dir

	if (ttx.efd),(TAXYEOFF)&(ttx.efd<TAXB)&(CUVAR2'>(TAXB+TAXYEOFF)) set ln.ipty=ln.ipty+ttx.dir
	else  set ln.itytd=ln.itytd+ttx.dir

	// Commercial Commitment Link
	if $E($$ICPA(ln.icpa),10) set ln.balint=ln.balint+ttx.dir

	/*

	// Adjusted Balance for Accrual Calculation
	set ln.balint=ln.balint

	// Int/Div Paid Financial Year-to-Date
	set ln.iytd=ln.iytd

	// Int/Div Paid Prior Financial Year
	set ln.ipy=ln.ipy

	// Int/Div Paid - Life
	set ln.ipl=ln.ipl

	// Int/Div Paid Tax Year-to-date
	set ln.itytd=ln.itytd

	// Int/Div Paid Prior Tax Year
	set ln.ipty=ln.ipty

	// Negative Amortization Reduction - Life
	set ln.narl=ln.narl
	*/
	do STR2A(.ln,.trn,.ttx)
	quit


public STR2A(RecordLN ln,RecordTRN trn,RecordTTX ttx)
	
	// Unadvanced Balance
	set BALCMP=ln.bal+0 
	if ln.aruf set BALCMP=BALCMP-ln.udbal
	
	// Minimum Balance
	if ttx.itc,ln.sbwamt'="",BALCMP'>ln.sbwamt do SBWAMT(.ln,.ttx)

	// Loan is in nonaccrual status. Transaction requires approval. 
	if ln.nai set OVR(CID,"OVR","LNNA")=""
	
	// If credit transaction, call line tag SBTP for Small Balance Threshold Processing.
	if ttx.itc do SBTP(.ln)
	
	if (ttx.efd),ttx.efd<CUVAR2 do {
		set FINB=$$BOFY^SCADAT(CUVAR2,1)
		if ttx.efd<FINB do FISCAL^LNPTSR(.ln,ttx.efd)
		}
		
	do EXIT(.ln,.trn,.ttx)
	
	quit

public EXIT(RecordLN ln,RecordTRN trn,RecordTTX ttx)
	
	// Update the Dollar Days Balance Field
	if 'ER do UPDAVB(.ln,.ttx)

	// Processing Control Flags
	set PCFL30=trn.pcfl30

	if $G(LNMDLR) kill OVR

	// Negative balance transfer
	if (BALCMP < 0), ln.nbtr, 'ln.pmt.isNull(), 'ER do NBTR(.ln, .ttx, BALCMP)

	if $G(ER)=1 do ^LNPTS1(.ln,.ttx)	

	//  For commercial participation payments...
	if trn.pac="",'PCFL30 do {
		new INCD,PICM,PL
		Type ResultSet rs=Db.select("INCD,PL","LNLS4C","CID=:CID")
		if 'rs.isEmpty() while rs.next() do {
			set INCD=rs.getCol(1)
			set PL=rs.getCol(2)
			type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:INCD,PL=:PL")
			set PICM=lnls2.picm
			if PICM=6 set PCFL30=1
			}
		}
	// Directed transactions for commercial participation
	if PCFL30>0&($G(MLSP)'=1) do {
		new ECINF,%EffectiveDate,SAVSEQ,TCSARL,TCSARP
		set EFD=ttx.efd
		set SAVSEQ=ttx.getStoredValue("TranSeq")
		do PRIPROC^PROCPTL(.ttx,.trn,PCFL30)
		if $G(TCSARP)>0 do {
			// Total Commercial Remittance Paid
			if PCFL30=1 set ln.tcrp=ln.tcrp+TCSARP

			// Total Commercial Sold Amount
			if PCFL30=2 set ln.tcsa=ln.tcsa+TCSARP

			// Loan Error-Correct Data
			set ECINF=ttx.lnerc
			set $P(ECINF,"#",34)=TCSARP
			set ttx.lnerc=ECINF
			}

		if $G(TCSARL)>0 do {
			if PCFL30=1 set ln.tcrl=ln.tcrl+TCSARL
			if PCFL30=2 set ln.tcsl=tcsl+TCSARL
			set ECINF=ttx.lnerc
			set $P(ECINF,"#",42)=TCSARL
			set ttx.lnerc=ECINF
 			}
		}
	do ^LNPTS1(.ln,.ttx) 
	quit

	
SBTP(RecordLN ln) // Small Balance Threshold Processing

	/*
	
	   If debit or credit balance processing, store entries
	   of loan pmts in the DAYENDSBT file.
	
	*/
	
	new PAMT
	// If revolving loan, quit.
	if ln.revf quit
	
	/*
	Determine if thresholds are defined or small balance payoff
	processing is needed
	*/
	if '(ln.dbt!ln.cbt) quit 
	if '($$CHKPOFF^BCHLNSBT(CID,.ln)) quit 
	
	// Log entries for further small balance payoff processing.
	type RecordDAYENDSBT desbt=Db.getRecord("DAYENDSBT","TJD=:%SystemDate,CID=:CID",1)
	if desbt.getMode() quit
	do desbt.bypassSave() 
	
	quit 
	
SBWAMT(RecordLN	ln,RecordTTX ttx)
	
	type public Number BALCMP, CID
	type public String OVR(,,)

	// Below minimum balance of $<BALMIN> 
	if BALCMP < ln.sbwamt set OVR(CID,"OVR","BALMIN") = $$^SCARND(ln.sbwamt,0,CID)
	
	// Small balance check
	if ((BALCMP + ttx.tamt.piece("#",2) + ttx.tamt.piece("#",5)) '> ln.sbwamt) quit
	
	// Set up day end file
	type RecordDAYENDLSBW delsbw = Db.getRecord("DAYENDLSBW","EFD=:%SystemDate,CLS=:ln.cls,GRP=:ln.grp,TYPE=:ln.type,CID=:ln.cid", 1) 
	
	if delsbw.getMode() quit
		
	do delsbw.bypassSave() 
	
	quit 

	
FIND(STR,PSTR,RecordLN ln,RecordTRN trn,RecordTTX ttx)	// Build string of posting programs

	/*
	
	   This section will build a string of posting programs based upon
	   the grid or posting action control.  I.e.  a string of
	   numbers will be converted to posting programs.  4,6,20,2
	   may be converted to (in variable PSTR):
	    LNPTS12:MPLO.LNPTS13:MPMO,LNPTS3:MPS,LNPTS4:MPPO
	   in the case of the grid  specified in the middle of the
	   posting action control (tran code MPC = 4,6,1), a "*" will
	   be inserted, and the grid will be deciphered at the time
	   it is needed.  This will make sure the proper partial/full
	   and due categories are set:
	    4,6,1 = LNPTS12:MPLO,LNPTS13:MPMO,*
	
	*/
	new AP,NODE,NSTR,PRODCTL,STRC
	
	set STRC=0 
	set PSTR=""
	set NODE=$S(ln.trb-ttx.itc1=0:15,1:14)

	do LOADPROD
	
	for  do { quit:NSTR=""
		set STRC=STRC+1
		set NSTR=$P(STR,",",STRC)
		if NSTR="" set PSTR=$E(PSTR,1,$L(PSTR)-1) quit
		do F1(.ln,.ttx)
		}

	quit


F1(RecordLN ln,RecordTTX ttx)

	type Public Number NODE,STRC,TYPE
	type Public String LNPTS2(,),NSTR,PSTR,STR

	type String LTC,LTCPAC

	// 13667 - Use Tab delimiter instead of comma for separating posting routines in PSTR
	if NSTR="0" set PSTR=PSTR_"0"_$C(9) quit

	set LTC=LNPTS2(TYPE,NODE).piece("|",NSTR)
	if NSTR="7" set LTC=LTC_ln.rnd
	
	type RecordTRN trn=Db.getRecord("TRN","ETC=:LTC")
	set LTCPAC=trn.pac	// Posting Action Control
	
	// 13667 - Use Tab delimiter instead of comma for separating posting routines in PSTR
	if LTCPAC.isNull() set PSTR=PSTR_"*"_$C(9) quit
	
	if LTCPAC?1N.N.",".E set STR.piece(",",STRC)=STR.piece(",",STRC)_","_LTCPAC quit
	
	// 13667 - Use Tab delimiter instead of comma for separating posting routines in PSTR
	set PSTR=PSTR_LTCPAC_":"_LTC_$C(9)
 	
	quit


UNDTRAN()

	/*
	If ODD or DTNT are in the future allow some transactions
	           to be processed.
	
	*/

	do LOADPROD

	// Undisbursed transactions
	//PRODCTL.DRTRIR
	if ETC=$P(LNPTS2(TYPE,14),"|",11) quit 1

	//PRODCTL.DRTRAF
	if ETC=$P(LNPTS2(TYPE,14),"|",14) quit 1

	//PRODCTL.CRTRIR
	if ETC=$P(LNPTS2(TYPE,15),"|",11) quit 1

	//PRODCTL.CRTRAF
	if ETC=$P(LNPTS2(TYPE,15),"|",14) quit 1
	quit 0

	
CHGOF(RecordLN ln,RecordTTX ttx)
	
	new CHGOF
	set NCOA=ln.coa-ln.rec
	if '$P(ttx.tamt,"#",10) quit
	set CHGOF=$P(ttx.tamt,"#",10)
	if CHGOF-NCOA=0 quit 
	//	|Charge-off balance exists 
	set OVR(CID,"OVR","CHGOF")=""
	quit 
	
RECOV(TSO)
	
	do OUT^UTSO(.TSO,TSO)
	quit $G(TSO("RECOV"))
	
CONT(RecordLN ln,RecordTTX ttx)
	
	if 'RECOV quit 
	if RECOV>PAMT set ER=1 set ET="RECXPAMT" do ^UTLERR quit 
	if RECOV>NCOA set ER=1 set ET="RECXCOA" do ^UTLERR quit 

	new DATA,PCS,TC,TC1,XCID

	Type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
	set TC=prodctl.drtprec

	//~p1 not defined for product type ~p2
	if TC="" do Runtime.setErrMSG("LN","prodctl.drtprec~TYPE") quit 
	set TC1=prodctl.crtprec
	do POST^LNTRB(.ttx,CID,TC,RECOV,ttx.efd,%UserStation,TSO,"",CRCD,ln.cc,"")

	Type RecordTRN trn1=Db.getRecord("TRN","ETC=:TC1")
	set XCID=trn1.acn
	do POST^LNTRB(.ttx,XCID,TC1,RECOV,ttx.efd,%UserStation,TSO,"",CRCD,ln.cc,"")
	
	quit 

Public PREC(RecordLN ln,RecordTTX ttx,RecordTRN trn)	// Update Recovery Amount and Recovery Amount YTD; called from LNPTS1
	
	do GL^LNPTSU(.ttx,TAMT,11)
	
	//Decrement ZAMT by amount of transaction
	set ZAMT=ZAMT-TAMT
	
	do ECPREC(.ln)
	quit
	
Public ECPREC(RecordLN ln) 

	// Recovery Amount
	set ln.rec=ln.rec+TAMT	

	// Recovery Financial YTD
	set ln.recytd=ln.recytd+TAMT
	quit 
	
PLSUB(RecordLN ln,RecordTRN trn,RecordTTX ttx) 
	
	/*
	 Check transaction code and problem loan status and process problem
	   loans.
	
	  Direct Transaction processing on a sub-account
	*/
	
	type public Boolean ER
	type public String OVR(,,)
	
	if (ttx.getStoredValue("isPrimary")) do { quit:ER 
	
		if ('ttx.getStoredValue("isSystemGenerated")) do { quit:ER 
			//The transaction code used is not valid for loans with linked problem sub-accounts
			if trn.pcfl40'=1,ln.paoi!(ln.pcidstat>0) do Runtime.setErrMSG("LN",4307)

			//The transaction code used is only valid for loans with linked problem sub-accounts
			if trn.pcfl40 do { quit:ER 
				if 'ln.paoi,'ln.pcidstat do Runtime.setErrMSG("LN",4308)

				//	|Direct transaction to sub-account 
				if ln.pcidstat>0 set OVR("*","OVR","PRLOAN")=""
				}
			}
		/*
		System generated transactions (TRNMODE=3) to a problem loan
		parent ('ln.pcidstat,ln.paoi) that are not the result of
		fees (TSO'["LNFEEIN") or late charges ('LCFLG) assessing
		should not be allowed.
		Also sys. gen. transactions to sub-accounts without
		the sub-acct breakout in TSO should not be allowed.
		The transaction code used is not valid for loans with linked problem sub-accounts
		*/

		if (ttx.getStoredValue("isSystemGenerated")),(trn.pcfl40'=1) do { quit:ER 
			//The transaction code used is not valid for loans with linked problem sub-accounts
			if 'ln.pcidstat,ln.paoi,('$$FEETRAN(.ttx)),(TSO'["COP"),'LCFLG do Runtime.setErrMSG("LN",4307) quit
			//if (ln.pcidstat),(TSO'["CRNP"),(TSO'["CRNI"),(TSO'["CRNF"),(TSO'["CRNLC"),(TSO'["NAP"),(TSO'["NAI"),(TSO'["NAF"),(TSO'["NALC"),(TSO'["COP"),(TSO'["COI"),(TSO'["COF"),(TSO'["COLC") do Runtime.setErrMSG("LN",4307) quit
			if ln.pcidstat,("CRNP,CRNI,CRNF,CRNLC,NAP,NAI,NAF,NALC,COP,COI,COF,COLC,"[TSO) do Runtime.setErrMSG("LN",4307) quit
			}
		}
	
	type Number LTRNSEQ = ttx.getStoredValue("TranSeq")
	
	do ^SUBPROC(CID,LTRNSEQ,ETC,TSO,ttx.itc) quit:ER 

	quit 

	
PRETRN(RecordLN	ln) // Capture data prior to transaction being processed
	
	set PRETRN("BALCMP")=BALCMP
	// Late Charge Due
	set PRETRN("LCHG")=ln.lchg

	// Current Principal
	set PRETRN("CUPR")=ln.cupr

	// Uncollected Principal
	set PRETRN("UNPR")=ln.unpr

	// Fixed Principal Amount
	set PRETRN("FPA")=ln.fpa

	// Internal Bill Seq Nbr Next Due Date
	set PRETRN("DSEQ")=ln.dseq
	set PRETRN("DIST1ND")=ln.dist1nd
	quit 


PDC(RecordLN ln)	// Determine the loan's payment due category

	type String GRP,PDAG,STR
	type Number APST,OSEQ,PDS,SCHSEQ,STRC
	
	// Payment Due Action Grid
	set PDAG=ln.pdag

	// Product Group
	set GRP=ln.grp

	// Scheduled Internal Bill Sequence Number
	set SCHSEQ=ln.schseq
	
	set PDS=$$PDS^LNUBIL1(ln.dseq,ln.schseq)
	
	set APST=""
	set PDS=PDS-1
	
	type ResultSet rs=Db.select("LIMIT","LNPDAG","GRP=:GRP AND TABLE=:PDAG AND PFF=1 AND LIMIT>:PDS","LIMIT ASC")
	if rs.next() set APST=rs.getCol("LIMIT")
	
	quit APST


PF(RecordLN ln)
	/*
	 Returns 0 when we cannot make a full payment because there isn't
	 enough ZAMT to go around or because there's nothing due.
	 
	 Returns 1 when we can make a full payment when there is an amount
	 due.
	*/
	
	type public Number DPMT, ZAMT
	
	if 'DPMT quit 0
	// Payment - Partial Amount
	if ZAMT<(DPMT-ln.ppa) quit 0
	quit 1
	
ICPA(ICPA)	// Return ICPA flags

	if ICPA="" quit ""
	Type RecordUTBLICPA utblicpa=Db.getRecord("UTBLICPA","KEY=:ICPA")
	quit utblicpa.prio	
	

PCM(PCM)	// Return PCM flags
	
	Type RecordSTBLPCM stblpcm=Db.getRecord("STBLPCM","KEY=:PCM")
	quit stblpcm.pcmp

	
TSOESC(RecordTTX ttx)

	
	new UTSO,TSO,TSOESC
	do OUT^UTSO(.UTSO,ttx.tso)
	do TSOESC^LNCO(ttx.etc) if $G(TSOESC) do {
		if $G(UTSO("ESC"))="" set UTSO("ESC")="ESC1"
		if $G(UTSO("ESCT"))'="" set UTSO("ESC")=UTSO("ESC")_":"_UTSO("ESCT")
		}
	kill UTSO("ESCT")
	
	type RecordTRN trn = Db.getRecord("TRN", "ETC=:ttx.etc")
	if (trn.pac["^LNPTS41(.acn,.ttx,.trn,""0110"")")&(ttx.tso["LNFEE")&'(UTSO("LNFEE").get().isNull()) set UTSO("LNFEEIN")=UTSO("LNFEE").get()
	
	/*
	Kill off TSO fields that are set by the transaction to avoid
	doubling if this transaction is re-processed due to batch reject
	handling.
	*/
	
	kill UTSO("LNFEE")
	kill UTSO("PVAR")
	set TSO=""
	do IN^UTSO(.UTSO,.TSO)
	set ttx.tso=TSO
	quit 
	
GRID(RecordLN ln,RecordTRN trn,RecordTTX ttx)	// look to grid for payment application

	type Public Boolean PF
	type Public Number PDC,PDS,STRC
	type Public String PDAG,PSTR
	
	type Number X
	type String pstr
	
	set PF=$$PF(.ln) 
	set PDC=$$PDC(.ln)

	set X=PDS-1
	type ResultSet rs=Db.select("LIMIT","LNPDAG","GRP=:ln.grp AND TABLE=:PDAG AND PFF=:PF AND LIMIT>:X","LIMIT ASC")
	if rs.next() set X=rs.getCol("LIMIT")

	type RecordLNPDAG lnpdag=Db.getRecord("LNPDAG","GRP=:ln.grp,TABLE=:PDAG,PFF=:PF,LIMIT=:X")

	do FIND(lnpdag.pymt,.pstr,.ln,.trn,.ttx)
	
	// 13667 - Use Tab delimiter instead of comma for separating posting routines in PSTR
	set PSTR.piece($C(9),STRC)=pstr
	
	quit 

	
FEETRAN(RecordTTX ttx)

	
	new FEEAMT
	
	if $$FIELD^UTSO(ttx.tso,"LNFEEIN")'="" quit 1
	if $P(ttx.tamt,"#",6)+$P(ttx.tamt,"#",13)=$P(ttx.tamt,"#",1) quit 1
	
	quit 0
	
EXPCOM(RecordLN	ln,RecordTRN trn,RecordTTX ttx,PRN)

	
	
	new ADJ,BALCMP

	// exclude CBL loans
	if 'ln.trb quit 

	// Credit Limit - Current
	set BALCMP=ln.bal

	// Unadvanced Balance
	if ln.aruf set BALCMP=BALCMP-ln.udbal
	
	set ADJ=0
	if trn.itc do {
		if BALCMP+PRN>ln.crlmt do {
			set ADJ=PRN
			if BALCMP<ln.crlmt set ADJ=BALCMP+PRN-ln.crlmt
			set ADJ=-ADJ
			}
		}
	else  do {          // increase
		if BALCMP>ln.crlmt do {
			set ADJ=PRN
			if BALCMP-PRN<ln.crlmt set ADJ=BALCMP-ln.crlmt
			}
		}
	
	if ADJ set ttx.tso=$$FIELDIN^UTSO(ttx.tso,"EXPCOM",ADJ)

	quit 

	
LOADPROD	// Load product fields into LNPTS2 array

	if $D(LNPTS2(TYPE)) quit
	set %="|"
	Type RecordPRODCTL ctl=Db.getRecord("PRODCTL","TYPE=:TYPE")

	set PRODCTL14=ctl.drtrgp_%_ctl.drtrpr_%_ctl.drtrin_%_ctl.drtrpe_%
	set PRODCTL14=PRODCTL14_ctl.drtrdc_%_ctl.drtrmi_%_ctl.drtrts_%
	set PRODCTL14=PRODCTL14_ctl.drtrci_%_ctl.drtrct_ctl.drtrfr_%
	set PRODCTL14=PRODCTL14_ctl.drtrdf_%_ctl.drtrcd_%_ctl.drtrdm_%
	set PRODCTL14=PRODCTL14_ctl.drtraf_%_ctl.drtrri_%_%_%_%_ctl.drtrmu
	set PRODCTL14=PRODCTL14_%_ctl.drtrst_%_%_%_ctl.drtrcu_%_ctl.drtrpv
	set PRODCTL14=PRODCTL14_%_ctl.drtrcp_%_ctl.drtrcf_%_%_ctl.drtrna
	set PRODCTL14=PRODCTL14_%_%_ctl.drtrei_%_ctl.drtrcv_%_%_ctl.drtacn1
	set PRODCTL14=PRODCTL14_%_ctl.drtacn2_%_%_ctl.drters_%_ctl.drtprec
	set PRODCTL14=PRODCTL14_%_ctl.drtreuld_%_ctl.drtreued_%_%_ctl.drtrdi
	set PRODCTL14=PRODCTL14_%_ctl.drtrdfda_%_ctl.drtrmfi_%_%_ctl.drtrppp
	set LNPTS2(TYPE,14)=PRODCTL14


	set PRODCTL15=ctl.crtrgp_%_ctl.crtrpr_%_ctl.crtrin_%_ctl.crtrpe_%
	set PRODCTL15=PRODCTL15_ctl.crtrdc_%_ctl.crtrmi_%_ctl.crtrts_%
	set PRODCTL15=PRODCTL15_ctl.crtrci_%_ctl.crtrct_%_%_ctl.crtrdf_%
	set PRODCTL15=PRODCTL15_ctl.crtrcd_%_ctl.crtrdm_%_ctl.crtraf_%
	set PRODCTL15=PRODCTL15_ctl.crtrri_%_ctl.crtvrt_%_ctl.crtcpc_%
	set PRODCTL15=PRODCTL15_ctl.crtrep_%_ctl.crtrmu_%_ctl.crtrst_%
	set PRODCTL15=PRODCTL15_ctl.crtrea_%_ctl.crtric_%_ctl.crtrcu_%
	set PRODCTL15=PRODCTL15_ctl.crtrpv_%_ctl.crtrcp_%_ctl.crtrcf_%
	set PRODCTL15=PRODCTL15_ctl.crtria_%_ctl.crtrpp_%_ctl.crtrna_%
	set PRODCTL15=PRODCTL15_ctl.crtrei_%_ctl.crtrcv_%_ctl.crtros_%
	set PRODCTL15=PRODCTL15_ctl.crtacn1_%_ctl.crtacn2_%_ctl.crtrmp_%_%
	set PRODCTL15=PRODCTL15_ctl.crtprec_%_ctl.crtreuec_%_ctl.crtreulc
	set PRODCTL15=PRODCTL15_%_ctl.crtlcr_%_ctl.crtrdi_%_ctl.crtrdfia_%
	set PRODCTL15=PRODCTL15_ctl.crtrmfr_%_ctl.crtrsp_%_ctl.crtrppa
	set LNPTS2(TYPE,15)=PRODCTL15

	quit 

	
UPDAVB(RecordLN	ln,RecordTTX ttx) // Update the Average Balance fields

	/*
	This section will update the current dollar days balance field
	based on the transaction amount.
	*/
	
	new DLIM,EOMJD,PRIN,BJD,MON
	
	// Get the principle amount from the transaction
	set PRIN=$P(ttx.tamt,"#",2)+$P(ttx.tamt,"#",5)
	
	// If there is no principle adjustment, quit
	if PRIN=0 quit 
	
	if ln.trb-ttx.itc1=0 set PRIN=-PRIN

	/*
	Get each end of month from the effective date until todays date and
	update the average balance for each.
	*/	

	set (EOMJD,BJD)=%EffectiveDate
	
	for  quit:EOMJD>CUVAR2  do {
		// Get the current month
		set MON=$$MON^SCADAT(BJD,1)

		// Date of the last day in month
		set EOMJD=$$EOMJD^SCADAT(BJD,1)

		// Days left in the month
		set DLIM=EOMJD-BJD+1
	
		// Update current month bucket
		if EOMJD>CUVAR2 set ln.ddbalcur=ln.ddbalcur+(DLIM*PRIN)

		// Update the month bucket
		else  do {
			if MON=1 set ln.ddbal1=ln.ddbal1+(DLIM*PRIN) quit
			if MON=2 set ln.ddbal2=ln.ddbal2+(DLIM*PRIN) quit
			if MON=3 set ln.ddbal3=ln.ddbal3+(DLIM*PRIN) quit
			if MON=4 set ln.ddbal4=ln.ddbal4+(DLIM*PRIN) quit
			if MON=5 set ln.ddbal5=ln.ddbal5+(DLIM*PRIN) quit
			if MON=6 set ln.ddbal6=ln.ddbal6+(DLIM*PRIN) quit
			if MON=7 set ln.ddbal7=ln.ddbal7+(DLIM*PRIN) quit
			if MON=8 set ln.ddbal8=ln.ddbal8+(DLIM*PRIN) quit
			if MON=9 set ln.ddbal9=ln.ddbal9+(DLIM*PRIN) quit
			if MON=10 set ln.ddbal10=ln.ddbal10+(DLIM*PRIN) quit
			if MON=11 set ln.ddbal11=ln.ddbal11+(DLIM*PRIN) quit
			if MON=12 set ln.ddbal12=ln.ddbal12+(DLIM*PRIN) quit
			}
		set BJD=EOMJD+1
		}
	
	// Process commission corrections for portfolio plans
	do COMCOR^TTXCOM(.ln,ttx.efd)
	
	quit 


NBTR(RecordLN ln,
     RecordTTX ttx,
     Number BALCMP)	

	// This section checks if this is OK for an account to be
	// filed into DAYENDLNNBTR table

	type Date TFRDT = %SystemDate + ln.troffd
	
	// Transfer negative balance if equal to or greater than the payment amount
	if (ln.ntropt = 1), (-BALCMP < ln.pmt) quit

	type RecordDAYENDLNNBTR daylnnbtr = Db.getRecord("DAYENDLNNBTR", "CID = :ln.cid, TFRDT = :TFRDT", 1)
	
	if daylnnbtr.getMode() quit
	
	do daylnnbtr.save()
	
	quit
	
	
LDATE(RecordLN ln,RecordTRN trn,RecordTTX ttx) //   Advances the loan's due date
	
	new RAMT
	set RAMT=ln.dpmt-ln.ppa
	if trn.pcfl9 do {
		if (ln.trb&ttx.itc1)!('ln.trb&'ttx.itc1) do {
			if ($P(ttx.tamt,"#",1)'<ln.dpmt),($P(ttx.tamt,"#",4)'<RAMT)&(ln.addlchg) do BUMP(.ln,.ttx)
			}
		}
	quit 
	
BUMP(RecordLN ln,RecordTTX ttx)
	
	new AMT,B,BL1,DATA,ELMNT,elmnt,I,OSEQ
	
	// Find oldest bill with amounts due
	set OSEQ=ln.oseq
	set AMT=ln.dpmt-ln.ppa

	type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:OSEQ")

	set B=$P($$BIL1ELE^BILFUNCS(.lnbil1),$C(9),1,20)
	for I=1:1:$L(B,$C(9)) set elmnt=$P($P(B,$C(9),I),"#",1) if elmnt'=""  set elmnt=I

	set BL1=lnbil1.bp1
	// Payment amount still due
	set $P(BL1,"#",1)=0

	// Total Prin Plus Interest Amt Still Due
	set $P(BL1,"#",5)=0
	set lnbil1.bp1=BL1

	do lnbil1.bypassSave()
	do CALC^LNUBIL(.ln,"01001")
	quit 
	

vSIG()	quit "60600^7680^Sunitha Santhumayor^39499"	// Signature - LTD^TIME^USER^SIZE
