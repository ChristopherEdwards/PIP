SWIFTFMT   //
	/*
	   DESC: Formatting routine for all SWIFT msg.(blocks)

	   LIBRARY:
	   . MSGOUT - formats outgoing Swift message from SWIFT
	   . MSGIN  - Converts incoming Swift message to SWIFT
	   . parse  - parse incoming msg into segments
	   . getval - gets db fld values based on DI
	   . getDI  - gets dataitem name based on DI

	  ---- Revision History -------------------------------------------------

   	   01/11/06 - ratht - CR 18292
   	   	      Modified section MSGOUT to define variable
   	   	      msgbdy as public. Removed the Deprecated 
   	   	      warning in the section MSGIN.

           07/27/05 - SkariahV- CR16679
	              Removed #WARN and #OPTIMIZE directives.
	              
	   05/26/03 - DATTAR - 51351
	   	      Conversion to PSL

	  -----------------------------------------------------------------------

	*/

	quit


public MSGOUT(String refno,String typ,String dup) //Public;Format msg. from SWIFT

	/*

	   ARGUMENTS:
	   . refno Transaction reference number 	/REQ/NONULL/MECH=VAL
	   . typ Message type				/REQ/NONULL/MECH=VAL
	   . dup Possible duplicate transmission	/REQ/NONULL/MECH=VAL

	   RETURNS:
	   . $$ Formatted Swift msg.    		

	   EXAMPLE:
	    swmsg=$$MSGOUT^SWIFTFMT(ref,typ,0)

	*/


	//The variables fs1,fs2,fs3,fs4,fs5 are set up in the ^SWIFTUTL
	
	type Public String ER,fs1,fs5,msgbdy,RM,STsess,STseqO
	type String envhdr,envtrl,sendadr,sendadr1,sendadr2
	
	// No message data to format
	type RecordSWIFT swift=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:refno,MSG=:typ",1)
	if swift.getMode()=0 set ER=1,RM=$$^MSG(7304) quit ""
	
	set envhdr="#PA"_STsess_STseqO_"MMSG"_fs1 
	set envtrl=fs5

	set sendadr=CUVAR.SWIFTADD
	set sendadr1=sendadr.extract(1,8)
	set sendadr2=sendadr.extract(9,11)
	set sendadr=sendadr1_"A"_$Select(sendadr2.length()=3:sendadr2,1:"XXX")
	set sendadr="{1:F01"_sendadr_STsess_STseqO_"}"
		
	set msgbdy=sendadr_$$apphdr(.swift,"OUT")_$$txtblc(.swift)
	if dup set msgbdy=msgbdy_"{5:{PDE:}}"
	
	quit envhdr_msgbdy_envtrl


apphdr(RecordSWIFT swift,String SWDIRECT) // Format the Application Header
	
	/*
	   ARGUMENTS:
	   . swift	SWIFT object		/REQ/MECH=REF
	   
 	*/
	
	type Public String delmon,obsper
	type String apphdr,delobs,destadr,destadr1,destadr2,pri

	set destadr=swift.rcvr
	set destadr1=destadr.extract(1,8)
	set destadr2=destadr.extract(9,11)

	set destadr=destadr1_"X"_$Select(destadr2.length()=3:destadr2,1:"XXX")
	set pri=swift.priority
	set pri=pri.extract(1,1)
	if pri="U" set delobs=delmon_obsper
	else  set delobs=""

	if SWDIRECT="IN" set apphdr="{2:O"_swift.msg_destadr_pri_delobs_"}"
	else  set apphdr="{2:I"_swift.msg_destadr_pri_delobs_"}"

	quit apphdr


public tfsapp(RecordSWIFT swift) // Format the Application Header for TFS transations
	
	/*
	   ARGUMENTS:
	   . swift 	SWIFT object		/REQ/MECH=REF
	   
   	   RETURNS:
	   . $$ Formatted Swift msg.    		
	*/
	
	type String apphdr,mir,outtim,pri,respdat,resptim
	type Date date

	set date=$$DAT^%ZM(swift.date,"YYMMDD")

	set mir=swift.sndr_swift.sess_swift.inseq

	set resptim=$$TIM^%ZM(%CurrentTime,"2460")

	set respdat=$$DAT^%ZM(%SystemDate,"YYMMDD")

	set outtim=resptim

	set pri=swift.priority
	
	quit "{2:O"_swift.msg_resptim_date_mir_respdat_resptim_pri_"}"


txtblc(RecordSWIFT swift) // Format the "real" swiftmessage Text Block

	/*
	   ARGUMENTS:
	   . swift 	SWIFT object		/REQ/MECH=REF
	   
 	*/
 	
	type Public String ER,fs2,fs3,fs4,RM
	type Public Number typ
	type String fldid,fldopt,fldtag,fldval,fmttabval,I,i,mandat,rep,txt,txtblc
	type Number seq

	set txt=""
	set seq=0

	type DbSet ds=Db.selectDbSet("STBLSWIFT","TYPE=:typ")
	while ds.next() do {
		type RecordSTBLSWIFT stblsw=ds.getRecord("STBLSWIFT")
		if seq=0 set seq=stblsw.seq
		set fldtag=stblsw.tag
		set fldopt=stblsw.option
		if 'fldopt.isNull() set fldopt=$$getval(fldopt,.swift) quit:fldtag'[fldopt
		set fldid=stblsw.di1_"|"_stblsw.di2_"|"_stblsw.di3_"|"_stblsw.di4_"|"_stblsw.di5_"|"_stblsw.di6_"|"_stblsw.di7_"|"_stblsw.di8_"|"_stblsw.di9_"|"_stblsw.di10
		set fldval=$$getval(fldid,.swift)
		if fldval.isNull(),stblsw.mandflg,'stblsw.nullflg do {
			set ER=1
			
			// Mandatory field ~p1 missing for ~p2~p3:~p4
			set RM=$$^MSG(7303,fldtag,"MT",swift.msg,swift.trrefno)
			}
		
		if (fldval.isNull()),'stblsw.nullflg quit

		// 40847 - For repeating fields 23E and 71F
		if (typ=103)&((fldtag="23E:")!(fldtag="71F:")!(fldtag="13C:")) do {
			for I=1:1 quit:fldval.piece($C(13,10),I).isNull()  do {
			
				set rep=fldval.piece($C(13,10),I)
				if (rep.length()>4),(rep.extract(1,4)?4a) set rep=rep.extract(1,4)_"/"_rep.extract(5,rep.length())
				set txt=txt_fs3_fldtag_rep
				}
			}
	
		else  set txt=txt_$Select(seq!(fldtag.isNull())!(txt.isNull()):"",1:fs3)_fldtag_fldval    
		}	

	if ER do ERR^SWIFTUTL

	quit "{4:"_fs2_txt_fs4_"}"


public MSGIN(String msg,RecordSWIFT swift,RecordSWIFTSEQ swiftse(),Number typ,String dupl) // Format msg. to SWIFT

	/*

	   ARGUMENTS:
	   . msg   	Incoming message to reformat		/REQ/MECH=VAL
	   . swift	SWIFT object				/REQ/MECH=REF
	   . swiftse	SWIFTSEQ object				/REQ/MECH=REF
	   . typ	Message typ				/REQ/MECH=VAL
	   . dupl	Possible duplicate flag			/REQ/MECH=REF

	   RETURNS:
	   . $$ Result    	
	     0 : Succes
	     1 : Fail

	   EXAMPLE:
	    status=$$MSGIN^SWIFTFMT(message,.swift,.swiftse())

	*/

	//The variables fs1,fs2,fs3,fs4,fs5 are set up in the ^SWIFTUTL

	type Public String ER,ET,RM,segarr
	type String status
	type Number tfs
	
	//Error trap
	catch vERROR {
           
                set ET=vERROR.type
 
                set ET=ET_"-"_vERROR.thrownAt
                set RM=vERROR.description
                
                do ^UTLERR
 
                do ERR^SWIFTUTL
                }

	set ER=0
		
	set status=$$PARSE(msg,.segarr)

	// Not able to parse incoming message.
	if status set RM=$$^MSG(7306) do ERR^SWIFTUTL quit 0

	if 'segarr(2,1).exists() do { quit 0

		// Could not find incoming message Only ~p1
		set RM=$$^MSG(7300,"Ack/CBT")
		do ERR^SWIFTUTL
		}

	// msg. type MTxxx
	set typ=segarr(2,2).extract(5,7)
	
	if 'Db.isDefined("STBLSWFTDSC","TYPE=:typ") do { quit 0
	
		// Incoming message type ~p1 is not supported
		set ER=1 
		set RM=$$^MSG(7302,typ)
		do ERR^SWIFTUTL
		}

	set tfs=typ\100
	
	//handle 400 and 700 series messages differently
	if tfs=4!(tfs=7) do {
	
		do TFS(.swift,.swiftse()) 
		}

	else  do {

		do bashdrI(.swift) 
		
		do apphdrI(.swift) 

		do txtblcI(.swift) 
		
		//Format the Trailer Block
		set dupl=$Select(segarr(2,5).get()["{PDE:":1,1:0)
					
		}
		
	if ER quit 0
	
	quit 1


bashdrI(RecordSWIFT swift) // Format the Basic Header

	/*
	   ARGUMENTS:
	   . swift 	SWIFT object		/REQ/MECH=REF
	   
 	*/
 
        type Public String segarr
         
        // Receiver
        set swift.rcvr=segarr(2,1).extract(7,14)_segarr(2,1).extract(16,18)
 
        quit
 
 
apphdrI(RecordSWIFT swift) // Format the Application Header

	/*
	   ARGUMENTS:
	   . swift 	SWIFT object		/REQ/MECH=REF
	*/
 	
        type Public String segarr
        
        // send TID
        set swift.sndr=segarr(2,2).extract(18,25)_segarr(2,2).extract(27,29)
 
        // resp. date
        set swift.date=%SystemDate
 
        // resp. time
        set swift.time=%CurrentTime
 
        // priority
        set swift.priority=segarr(2,2).extract(50,50)
 
        quit


bashdrV(RecordSWIFT swift)	 // Format the Basic Header for messages originating from Vision

	/*
	   ARGUMENTS:
	   . swift 	SWIFT object		/REQ/MECH=REF
	   
 	*/

	/*
	   Since the messages from Vision are treated as incoming therefore
	   it is needed to switch receiver/sender header information. Otherwise
	   the originating institution will become a receiver when the message
	   is routed to ST400.

	*/
	type Public String segarr

	// Sender
	set swift.sndr=segarr(2,1).extract(7,14)_segarr(2,1).extract(16,18)

	quit


apphdrV(RecordSWIFT swift) // Format the Application Header for messages originating from Vision

	/*
	   ARGUMENTS:
	   . swift 	SWIFT object		/REQ/MECH=REF
 	*/

	// Refer to the comment in section - bashdrV
	type Public String segarr

	// send TID
	set swift.rcvr=segarr(2,2).extract(8,15)_segarr(2,2).extract(17,19)

	// resp. date
	set swift.date=%SystemDate

	// resp. time
	set swift.time=%CurrentTime

	// priority
	set swift.priority=segarr(2,2).extract(20)

	quit


txtblcI(RecordSWIFT swift)	// Format the "real" swiftmessage Text Block

	/*
	   ARGUMENTS:
	   . swift 	SWIFT object		/REQ/MECH=REF
	*/

	type Public String ER,ET,fs2,fs3,segarr,typ
	type Public Number cs2
	type String atags,dival,fldopt,fldval,fldtag,fmtseq,newtag,refno,subval,tag,txt
	type Number fldcnt,found,loc,pce,status,subcnt,subval,tfldcnt

	type RecordSTBLSWIFT stblsw 

	// These tags may also contain the account and/or institution
	set atags="42,51,52,53,54,55,56,57,58,82,83,84,85,87,88"

	set status=0
	set txt=segarr(2,4).piece(fs2,2,999)
	
	//count how many tag in blk
	set (tfldcnt,fldcnt)=txt.length(fs3)
	
	for fldcnt=fldcnt:-1:1 do { quit:ER
		
		//get tag
		set fldtag=txt.piece(fs3,(tfldcnt-fldcnt+1))
		set fldtag=fldtag.piece(":",1)
		set newtag=1
		set tag=fldtag.extract(1,2)

		//get option if any
		if fldtag.length()=4 set fldopt=fldtag.extract(3)
		else  set fldopt=""
		
		//get content of the field
		set fldval=txt.piece(fs3,(tfldcnt-fldcnt+1))
		
		// Field value preprocesser grab the content under the field tag.
		set fldval=fldval.extract(fldval.piece(";",1).length()+2,fldval.length())
		
		//count how many lines in the field
		set subcnt=fldval.length(cs2)

		//last line in blk is "-}
		if fldcnt=1 set subcnt=subcnt-1
		
		//loc control which DI to fill out
		set loc=0
		if ('fldopt.isNull())&((fldval.piece(cs2,1).extract(1,1))'["/")&(atags[tag) set loc=1
		set found=0
		for subcnt=subcnt:-1:1 do { quit:ER
			set subval=fldval.piece(cs2,subcnt)
			set dival=$$getDI(typ,fldtag,subcnt,.stblsw)
			if ER quit
						
			if 'dival do multI(fldtag,.swift)
			if dival set swift.@dival=subval
			
			if ER quit
			}
			
		// If there is an option, store it into swift
		
		if 'fldopt.isNull() set status=$$savopt(fldopt,.stblsw,.swift)

		// Not able to save option for ~p1 ~p2 field ~p3.
		if status  do {
			set ER="W"
			
			set ET=$$^MSG(7308,"SWIFT",typ,fldtag)
			
			do ERR^SWIFTUTL
			}
		}

	/*
	  next 2 lines are for Vision interface.
	  Transaction Reference Number (Formatted)
	*/

	if refno.isNull() set refno=swift.trnofmt

	// SWFTDT req'd
	if swift.swftdt="" set swift.swftdt=%SystemDate
	quit


savopt(String fldopt,RecordSTBLSWIFT stblsw,RecordSWIFT swift) // To save the option into local array swift

	/*

	   ARGUMENTS:
	   . fldopt 	field option (A,D...) 		/REQ/NONULL/MECH=VAL
	   . stblsw	Record STBLSWIFT object		/REQ/NONULL/MECH=VAL
	   . swift	Record SWIFT object		/REQ/NONULL/MECH=VAL


	   RETURNS:
	   . $$ Condition value  
	    0 - Succes
	    1 - Failiure

	   EXAMPLE:
	    X=$$savopt^SWIFTUTL(fldopt,.stblsw,.swift)

	*/

	type String di
	if stblsw.option="" quit 1
	
	set di=stblsw.option
	set swift.@di=fldopt
	quit 0


multI(String fldtag,RecordSWIFT swift)	//

	/*
	   ARGUMENTS:
	   . fldtag	Tag for SWIFT msg	/REQ/MECH=VAL
	   . swift 	SWIFT object		/REQ/MECH=REF
	   
 	*/

	type Public String ER,ET,RM,subval,typ
	type Number len,subscript
	type String ARRAY,ARRAY(),cmp,di,FLD,SWFREE()

	/*
	Determine if the TAG exists in the SWIFT format system table for
	the message type.
	*/

	type ResultSet rs=Db.select("DI1","STBLSWIFT","TYPE=:typ AND TAG=:fldtag")
	if rs.next() set di=rs.getCol("di1")
		

	/*	
		SWIFT Tags with large size and or repeating fields, at least to this
		point only have one DI associated with them.
	*/
	
	// Unable to map the field ~p1 of ~p2~p3
	if 'di set ET=$$^MSG(7307,fldtag.piece(":",1),"MT",typ.get()) quit

	type RecordDBTBL1D dbtbl1d=Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID='SWIFT',DI=:di",1)
	if 'dbtbl1d.getMode() quit

	// Get the computed field of the SWIFT Data Item.
	set cmp=dbtbl1d.cmp

	if (cmp["$$MULT2^SWIFTCDI") do {

		// Remove quotes
		set FLD=cmp.piece(",",3).extract(2,4)
		set ARRAY="SWARR"_FLD
		
		type Public String @ARRAY
		set subscript=@ARRAY("").order(-1)+1
		set len=0

		// Break the SWIFT field into 80 characters per subscript
		for  quit:subval.length()<(len*80)  do {
			set ARRAY=ARRAY_"("_subscript_")"
			set @ARRAY=subval.extract(1+(80*len),80*(len+1))
			set len=len+1
			set subscript=subscript+1
			}

		// SWIFT Free Format Field Pointer Ref.
		if swift.freeptr="" do {
			type Number PTR

			lock +SWFREE("IN"):2  
			else  set ER=1,RM=$$^MSG(7354,"SWFREE") quit

			type RecordSWFREETOP swtop=Db.getRecord("SWFREETOP","SWDIRECT='IN'",1)
			set PTR=swtop.ptr+1
			set swtop.ptr=PTR
			do swtop.bypassSave()

			lock -SWFREE("IN")

			// SWIFT Free Format Field Pointer Ref.
			set swift.freeptr=PTR
			}
		}
	quit


public PARSE(String msg, String segar) //Public;Parsing msg. type from incoming chan.

	/*

	   ARGUMENTS:
	   . msg Swift incoming message 				/REQ/NOTNULL/MECH=VAL
	  
	   . segar array containing each segment of the input record.	/REQ/NOTNULL/MECH=REF


	   RETURNS:
	   . $$ Condition value  /TYP=T
	    0 - Succes
	    1 - Failiure

	   EXAMPLE:
	    status=$$PARSE^SWIFTUTL(msg,.segarray)

	   The following code will parse the message into it's main blocks.
	   The main message might be preseeded by an CBT response. They can be
	   separated by the first value in segment 1: . A CBT contains 'F21' ,
	   while a ordinary msg. contains 'F01' .
	   Each block will be stored in the two dimensional array 'seg' where
	   the key is the segment name. Valid segment names are 1,2,3,4,5,S.
	   The Acknowledgement/CBT Response in seg(1,x), and an incoming message
	   in seg(2,x)

	  Here's an example (Acknowledge/CBT Response):

	   Input message: {1:F21AAAAAAAAAAAA0001000001}{4:{177:9403190945}
	     {451:0}}{S:{MID:IDID}{SES:0002}{SEQ:000002}
	     {MST:300}{TRN:1234567890123456}}

	   Segment array:
	     seg(1,1)="{1:F21AAAAAAAAAAAA0001000001}"
	     seg(1,4)="{4:{177:9403190945}{451:0}}"
	     seg(1,"S")="{S:{MID:IDID}{SES:0002}{SEQ:000002}
	            {MST:300}{TRN:1234567890123456}}"

	*/

	type String char,msgtyp,seg,segcnt,segdim,segment,segstart
	type Number cnt,I
	
	set segstart=1 
	set segcnt=1 
	set cnt=0 
	set segdim=1
	
	for I=1:1:msg.length() do {
		
		/*
		This subroutine scans each character in the message and if it's a
	   	"{", a counter is incremented by 1.  If it's a "}", the counter is
	   	decremented by 1.  If the counter reaches zero (0), then we've just
	   	finished scanning a segment.  Store that segment in a segment array
	   	keyed by the segment name.
	   	*/
		set char=msg.extract(I)
		if "{}"'[char quit
		
		set cnt=$Select(char="{":cnt+1,1:cnt-1)
		if cnt quit
	
		set segment=msg.extract(segstart,I)
		set seg=segment.piece("{",2) 
		set seg=seg.piece(":",1)
	
		// check if Ack/CBT or message
		if seg="1" do {
			set msgtyp=segment.extract(4,6)
			set segdim=$Select(msgtyp="F21":1,msgtyp="F01":2)
			}
			
		set segar(segdim,seg)=segment
		set segcnt=segcnt+1 
		set segstart=I+1
		}
	quit 0


getval(String DI,RecordSWIFT swift) // return all fldvalues

	/*
	   ARGUMENTS:
	   . DI		Data Item	 	/REQ/MECH=VAL
	   . swift 	SWIFT object		/REQ/MECH=REF
	   
 	*/

	type Number i
	type Public String cs2
	type String di,val,valtmp
	
	set val=""
	for i=1:1:10 set di=DI.piece("|",i) do {
		if di.isNull() quit

		//if numeric, use it as is. 
		if di?.N do { quit
			set valtmp=di
			set val=val_$Select(val.isNull():"",1:cs2)_valtmp 
			}

		set valtmp=swift.@di	
		if valtmp.isNull() quit

		type RecordDBTBL1D dbtbl1d=Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID='SWIFT',DI=:di")
		if dbtbl1d.typ="D" do {
			set valtmp=$$EXTYP^DBSCRT8(valtmp,"D")
			set valtmp=valtmp.translate("/","")
			}
			
		// set in proper subfld deli.
		set val=val_$Select(val.isNull():"",1:cs2)_valtmp
		}

	quit val


getDI(String typ,String fldtag,Number subcnt,RecordSTBLSWIFT stblsw)  //Get di name of fd SWIFT from fldtag/subcnt

	/*
	   ARGUMENTS:
	   . typ	Data Item	 	/REQ/MECH=VAL
	   . fldtag	Tag for Swift msg	/REQ/MECH=VAL
	   . subcnt	Count			/REQ/MECH=VAL
	   . stblsw 	STBLSW object		/REQ/MECH=REF
	   
 	*/

	type Public String fmtseq,newtag	
	type String ER,dinam,dival,RM
	type Number fmtcnt,found,loc,seq

	set fmtseq=fmtseq.get()-1

	//Allow processing multiple entries of the same field.

	if newtag.get() do { quit:ER

		type DbSet ds=Db.selectDbSet("STBLSWIFT","TYPE=:typ")
		while ds.next() do { quit:found
			type RecordSTBLSWIFT stblsw=ds.getRecord("STBLSWIFT")
			set fmtseq=stblsw.seq
			set found=$Select(stblsw.tag=fldtag:1,1:0)
			}

		set newtag=0
		if 'found do { quit

			// Fieldtag ~p1 not recognized in ~p2
			set ER=1 
			set RM=$$^MSG(fldtag.get().piece(":",1),"STBLSWIFT")
			
			do ERR^SWIFTUTL
			
			}
		}
	
	set stblsw=Db.getRecord("STBLSWIFT","TYPE=:typ,SEQ=:fmtseq")
	set fmtcnt=subcnt
	if stblsw.option'="" set fmtcnt=subcnt+loc
	set dival="di"_fmtcnt
	set dinam=stblsw.@dival

	quit dinam


TFS(RecordSWIFT swift,RecordSWIFTSEQ swiftse()) //Process trade finance messages

	/*
	   ARGUMENTS:
	   . swift 	SWIFT object		/REQ/MECH=REF
	   . swiftse 	SWIFTSE object		/REQ/MECH=REF
	   
 	*/

	type Public String fs2,fs6,segarr
	type String txt
	
	do bashdrI(.swift)
	do apphdrI(.swift) 

	set txt=segarr(2,4).get().piece(fs2,2,999)
	set txt=txt.piece(fs6,1)

	do 500^SWIFTUTL(txt,400,.swift,.swiftse())
	
	quit

vSIG()	quit "60276^25828^Tarini Charan Rath^16666"	// Signature - LTD^TIME^USER^SIZE
