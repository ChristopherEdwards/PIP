CIFFILE(RecordCIF cif, String vpar, Boolean vparNorm) // CIF - Customer Information Filer
	// Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/30/2007 14:13 - joynerd
	// Generated from DATA-QWIK schema in: /profile/v72qa_gtmlx  by: /v72qa_gtmlx/crtns/DBSFILB.obj

	// Data Dictionary Data Items (280)            08/24/2007
	// Trigger Definition (49)                     08/09/2007
	// Journal File Definition (9)                 03/14/2007
	/*
		vpar      Runtime qualifiers:      /NOREQ/MECH=REFARR:R

		/[NO]CASDEL   - Cascade delete
		/[NO]FRMFILER - Called from another filer
		/[NO]INDEX    - Update Indexes
		/[NO]JOURNAL  - Journal update
		/[NO]TRIGAFT  - After update triggers
		/[NO]TRIGBEF  - Before update triggers
		/[NO]UPDATE   - Update primary table
		/[NO]VALDD    - Validate column values
		/[NO]VALFK    - Validate foreign keys
		/[NO]VALREQ   - Validate not null values
		/[NO]VALRI    - Validate transaction integrity
		/[NO]VALST    - Validate database state
	*/

	type public String verrors()

	type String vx(), vxins()                              // audit column array
	type Number %O = cif.getMode()                         // Processing mode
	set vpar = vpar.get()                                  // Initialize vpar

	if %O = 0 do AUDIT^UCUTILN(cif,.vxins(),10,"|")
	if %O = 1 quit:'cif.isChanged()  do AUDIT^UCUTILN(cif,.vx(),10,"|")

	if 'vparNorm.get() set vpar = $$initPar^UCUTILN(vpar)  // Run-time qualifiers

	// Define local variables for access keys for legacy triggers
	type String ACN = cif.acn

	if %O = 0 do { quit                                    // Create record control block
		do vinit                                              // Initialize column values
		if vpar["/TRIGBEF/" do VBI                            // Before insert triggers
		if vpar["/VALREQ/" do vreqn                           // Check required
		if vpar["/VALDD/" do vddver                           // Check values
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 1 do { quit                                    // Update record control block
		if vx("ACN").exists() do vkchged quit                 // Primary key changed
		if vpar["/TRIGBEF/" do VBU                            // Before update triggers
		if vpar["/VALREQ/" do vrequ                           // Check required
		if vpar["/VALDD/" do VDDUX^DBSFILER("CIF",.vx)
		set %O = 1 do vexec
		if vpar["/TRIGAFT/" do VAU                            // After update triggers
	}

	if %O = 2 do { quit                                    // Verify record control block
		if vpar["/VALREQ/" do vreqn                           // Check required
		set vpar = $$setPar^UCUTILN(vpar,"NOJOURNAL/NOUPDATE")
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 3 do { quit                                    // Delete record control block
		quit:'Db.isDefined("CIF","ACN = :cif.acn")            // No record exists
		if vpar["/TRIGBEF/" do VBD                            // Before delete triggers
		do vdelete(0)
		if vpar["/TRIGAFT/" do VAD                            // After delete triggers
	}

	quit

vlegacy(Number %ProcessMode,String vpar) // Legacy interface (^DBSDF9 for %O=0, EXT^DBSFILER for %O = 2)

	type public String ACN

	type RecordCIF cif = Db.getRecord("CIF","ACN=:ACN")
	if (%ProcessMode = 2) do {
		do cif.setMode(2)

		do CIFFILE(cif,vpar)
	}
	else  do VINDEX(cif)

	quit

vLITCHK() quit 0 // Table does not have columns involved in literals


vexec // Execute transaction

	type public Number %O
	type public String vpar,vobj(),vx(),vxins()

	type public RecordCIF cif

	type String vERRMSG

	if vpar["/VALST/" if '(''Db.isDefined("CIF","ACN = :cif.acn") = ''%O) set vERRMSG = $$^MSG($select(%O:7932,1:2327)) throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	if vpar["/VALFK/" do CHKFKS                            // Check foreign keys
	if vpar["/VALRI/" do VFKEYS                            // Foreign key definition

	if vpar'["/NOUPDATE/" do {

		set cif.FMLD = %SystemDate
		set cif.USERID = %UserID
		type String n = -1
		type String x

		if %O = 0 for  set n = vobj(cif,n).order() quit:n.isNull()  do {
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^CIF(vobj(cif,-3),n)=vobj(cif,n)
			#ENDBYPASS
		}

		else  for  set n = vobj(cif,-100,n).order() quit:n.isNull()  do {
			quit:'$D(vobj(cif,n))
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^CIF(vobj(cif,-3),n)=vobj(cif,n)
			#ENDBYPASS
		}


		if vpar["/JOURNAL/" do VJOURNAL(.cif)                 // Create journal files
	}

	if vpar["/INDEX/",'(%O = 1)!'vx("").order().isNull() do VINDEX(.cif) // Update Index files

	quit

vload // Record Load - force loading of unloaded data

	type public RecordCIF cif
	type String n = ""

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	for  set n=$order(^CIF(vobj(cif,-3),n)) quit:n=""  if '$D(vobj(cif,n)),$D(^CIF(vobj(cif,-3),n))#2 set vobj(cif,n)=^(n)
	#ENDBYPASS
	quit

vdelete(Boolean vkeychg) // Record Delete

	type public String vobj(),vpar
	type public RecordCIF cif

	if 'vkeychg.get(),cif.isChanged() throw Class.new("Error","%PSL-E-DBFILER,Deleted object cannot be modified")

	if vpar["/CASDEL/" do VCASDEL                          // Cascade delete
	if vpar["/INDEX/" do VINDEX(.cif)                      // Delete index entries
	if vpar["/JOURNAL/" do VJOURNAL(.cif)                  // Create journal entries

	// Allow global reference - Delete record
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^CIF(vobj(cif,-3))
	#ENDBYPASS
	quit


vinit // Initialize default values

	type public RecordCIF cif

	// Type local variables for access keys for defaults
	type public String ACN

	if cif.afinst.isNull() set cif.afinst = 0              // afinst
	if cif.agent.isNull() set cif.agent = 0                // agent
	if cif.bwf.isNull() set cif.bwf = 0                    // bwf
	if cif.cifdatsb.isNull() set cif.cifdatsb = 0          // cifdatsb
	if cif.cls.isNull() set cif.cls = "*"                  // cls
	if cif.cmsflg.isNull() set cif.cmsflg = 0              // cmsflg
	if cif.crbrauth.isNull() set cif.crbrauth = 0          // crbrauth
	type public String %CRCD
	if cif.crcd.isNull() set cif.crcd = %CRCD              // crcd
	type public String TJD
	if cif.dao.isNull() set cif.dao = TJD                  // dao
	if cif.ddbip.isNull() set cif.ddbip = 0                // ddbip
	if cif.edbi.isNull() set cif.edbi = 0                  // edbi
	if cif.expflg.isNull() set cif.expflg = 0              // expflg
	if cif.finstreq.isNull() set cif.finstreq = 0          // finstreq
	if cif.govt.isNull() set cif.govt = 0                  // govt
	if cif.grp.isNull() set cif.grp = "CIF"                // grp
	if cif.hldcomind.isNull() set cif.hldcomind = 0        // hldcomind
	if cif.idshare.isNull() set cif.idshare = 0            // idshare
	if cif.idtheft.isNull() set cif.idtheft = 0            // idtheft
	if cif.intactdet.isNull() set cif.intactdet = 0        // intactdet
	if cif.interbank.isNull() set cif.interbank = 0        // interbank
	type public String TJD
	if cif.isdadt.isNull() set cif.isdadt = TJD            // isdadt
	if cif.mardm.isNull() set cif.mardm = 0                // mardm
	if cif.marem.isNull() set cif.marem = 0                // marem
	if cif.martel.isNull() set cif.martel = 0              // martel
	if cif.mt320.isNull() set cif.mt320 = 0                // mt320
	if cif.mt900.isNull() set cif.mt900 = 0                // mt900
	if cif.mt910.isNull() set cif.mt910 = 0                // mt910
	if cif.mt940.isNull() set cif.mt940 = 0                // mt940
	if cif.mt942.isNull() set cif.mt942 = 0                // mt942
	if cif.mt950.isNull() set cif.mt950 = 0                // mt950
	if cif.nopurge.isNull() set cif.nopurge = 0            // nopurge
	if cif.nr.isNull() set cif.nr = 0                      // nr
	if cif.pin1cntr.isNull() set cif.pin1cntr = 0          // pin1cntr
	if cif.pin1del.isNull() set cif.pin1del = 0            // pin1del
	if cif.pin2cntr.isNull() set cif.pin2cntr = 0          // pin2cntr
	if cif.pin2del.isNull() set cif.pin2del = 0            // pin2del
	if cif.polexpper.isNull() set cif.polexpper = 0        // polexpper
	if cif.pubhldind.isNull() set cif.pubhldind = 0        // pubhldind
	if cif.rflgc.isNull() set cif.rflgc = 0                // rflgc
	if cif.selfemp.isNull() set cif.selfemp = 0            // selfemp
	type public String TJD
	if cif.statusdt.isNull() set cif.statusdt = TJD        // statusdt
	if cif.swiftsak.isNull() set cif.swiftsak = 0          // swiftsak
	if cif.taxexm.isNull() set cif.taxexm = 0              // taxexm
	type public String %UID
	if cif.userid.isNull() set cif.userid = %UID           // userid
	if cif.votexm.isNull() set cif.votexm = 0              // votexm
	if cif.w8req.isNull() set cif.w8req = 0                // w8req
	if cif.zrelpoexper.isNull() set cif.zrelpoexper = 0    // zrelpoexper
	quit


vreqn // Validate required data items

	type public RecordCIF cif

	if cif.afinst.isNull() do vreqerr("AFINST") quit
	if cif.agent.isNull() do vreqerr("AGENT") quit
	if cif.boo.isNull() do vreqerr("BOO") quit
	if cif.bwf.isNull() do vreqerr("BWF") quit
	if cif.cc.isNull() do vreqerr("CC") quit
	if cif.ccode.isNull() do vreqerr("CCODE") quit
	if cif.cifdatsb.isNull() do vreqerr("CIFDATSB") quit
	if cif.cls.isNull() do vreqerr("CLS") quit
	if cif.cmsflg.isNull() do vreqerr("CMSFLG") quit
	if cif.crbrauth.isNull() do vreqerr("CRBRAUTH") quit
	if cif.crcd.isNull() do vreqerr("CRCD") quit
	if cif.dao.isNull() do vreqerr("DAO") quit
	if cif.ddbip.isNull() do vreqerr("DDBIP") quit
	if cif.edbi.isNull() do vreqerr("EDBI") quit
	if cif.expflg.isNull() do vreqerr("EXPFLG") quit
	if cif.finstreq.isNull() do vreqerr("FINSTREQ") quit
	if cif.govt.isNull() do vreqerr("GOVT") quit
	if cif.grp.isNull() do vreqerr("GRP") quit
	if cif.hldcomind.isNull() do vreqerr("HLDCOMIND") quit
	if cif.idshare.isNull() do vreqerr("IDSHARE") quit
	if cif.idtheft.isNull() do vreqerr("IDTHEFT") quit
	if cif.intactdet.isNull() do vreqerr("INTACTDET") quit
	if cif.interbank.isNull() do vreqerr("INTERBANK") quit
	if cif.lnm.isNull() do vreqerr("LNM") quit
	if cif.mad1.isNull() do vreqerr("MAD1") quit
	if cif.mardm.isNull() do vreqerr("MARDM") quit
	if cif.marem.isNull() do vreqerr("MAREM") quit
	if cif.martel.isNull() do vreqerr("MARTEL") quit
	if cif.mcity.isNull() do vreqerr("MCITY") quit
	if cif.mcntry.isNull() do vreqerr("MCNTRY") quit
	if cif.mt320.isNull() do vreqerr("MT320") quit
	if cif.mt900.isNull() do vreqerr("MT900") quit
	if cif.mt910.isNull() do vreqerr("MT910") quit
	if cif.mt940.isNull() do vreqerr("MT940") quit
	if cif.mt942.isNull() do vreqerr("MT942") quit
	if cif.mt950.isNull() do vreqerr("MT950") quit
	if cif.nam.isNull() do vreqerr("NAM") quit
	if cif.nopurge.isNull() do vreqerr("NOPURGE") quit
	if cif.nr.isNull() do vreqerr("NR") quit
	if cif.pad1.isNull() do vreqerr("PAD1") quit
	if cif.pcity.isNull() do vreqerr("PCITY") quit
	if cif.pcntry.isNull() do vreqerr("PCNTRY") quit
	if cif.pers.isNull() do vreqerr("PERS") quit
	if cif.pin1cntr.isNull() do vreqerr("PIN1CNTR") quit
	if cif.pin1del.isNull() do vreqerr("PIN1DEL") quit
	if cif.pin2cntr.isNull() do vreqerr("PIN2CNTR") quit
	if cif.pin2del.isNull() do vreqerr("PIN2DEL") quit
	if cif.polexpper.isNull() do vreqerr("POLEXPPER") quit
	if cif.pubhldind.isNull() do vreqerr("PUBHLDIND") quit
	if cif.rflgc.isNull() do vreqerr("RFLGC") quit
	if cif.selfemp.isNull() do vreqerr("SELFEMP") quit
	if cif.swiftsak.isNull() do vreqerr("SWIFTSAK") quit
	if cif.taxexm.isNull() do vreqerr("TAXEXM") quit
	if cif.type.isNull() do vreqerr("TYPE") quit
	if cif.votexm.isNull() do vreqerr("VOTEXM") quit
	if cif.w8req.isNull() do vreqerr("W8REQ") quit
	if cif.zrelpoexper.isNull() do vreqerr("ZRELPOEXPER") quit
	quit

vrequ // Valid required columns on update


	type public String vx()
	type public RecordCIF cif

	if cif.acn.isNull() do vreqerr("ACN") quit

	if 'vobj(cif,-100,1,"").order().isNull() do {
		if vx("NAM").exists(),cif.nam.isNull() do vreqerr("NAM") quit
	}
	if 'vobj(cif,-100,3,"").order().isNull() do {
		if vx("LNM").exists(),cif.lnm.isNull() do vreqerr("LNM") quit
	}
	if 'vobj(cif,-100,5,"").order().isNull() do {
		if vx("MCITY").exists(),cif.mcity.isNull() do vreqerr("MCITY") quit
		if vx("MCNTRY").exists(),cif.mcntry.isNull() do vreqerr("MCNTRY") quit
		if vx("MAD1").exists(),cif.mad1.isNull() do vreqerr("MAD1") quit
	}
	if 'vobj(cif,-100,6,"").order().isNull() do {
		if vx("PCITY").exists(),cif.pcity.isNull() do vreqerr("PCITY") quit
		if vx("PCNTRY").exists(),cif.pcntry.isNull() do vreqerr("PCNTRY") quit
		if vx("PAD1").exists(),cif.pad1.isNull() do vreqerr("PAD1") quit
	}
	if 'vobj(cif,-100,10,"").order().isNull() do {
		if vx("AGENT").exists(),cif.agent.isNull() do vreqerr("AGENT") quit
	}
	if 'vobj(cif,-100,13,"").order().isNull() do {
		if vx("BOO").exists(),cif.boo.isNull() do vreqerr("BOO") quit
		if vx("CC").exists(),cif.cc.isNull() do vreqerr("CC") quit
		if vx("CCODE").exists(),cif.ccode.isNull() do vreqerr("CCODE") quit
		if vx("RFLGC").exists(),cif.rflgc.isNull() do vreqerr("RFLGC") quit
		if vx("BWF").exists(),cif.bwf.isNull() do vreqerr("BWF") quit
		if vx("TAXEXM").exists(),cif.taxexm.isNull() do vreqerr("TAXEXM") quit
		if vx("W8REQ").exists(),cif.w8req.isNull() do vreqerr("W8REQ") quit
		if vx("NR").exists(),cif.nr.isNull() do vreqerr("NR") quit
		if vx("EXPFLG").exists(),cif.expflg.isNull() do vreqerr("EXPFLG") quit
	}
	if 'vobj(cif,-100,14,"").order().isNull() do {
		if vx("DAO").exists(),cif.dao.isNull() do vreqerr("DAO") quit
	}
	if 'vobj(cif,-100,15,"").order().isNull() do {
		if vx("NOPURGE").exists(),cif.nopurge.isNull() do vreqerr("NOPURGE") quit
	}
	if 'vobj(cif,-100,17,"").order().isNull() do {
		if vx("VOTEXM").exists(),cif.votexm.isNull() do vreqerr("VOTEXM") quit
	}
	if 'vobj(cif,-100,18,"").order().isNull() do {
		if vx("AFINST").exists(),cif.afinst.isNull() do vreqerr("AFINST") quit
		if vx("EDBI").exists(),cif.edbi.isNull() do vreqerr("EDBI") quit
		if vx("DDBIP").exists(),cif.ddbip.isNull() do vreqerr("DDBIP") quit
	}
	if 'vobj(cif,-100,19,"").order().isNull() do {
		if vx("MAREM").exists(),cif.marem.isNull() do vreqerr("MAREM") quit
		if vx("MARDM").exists(),cif.mardm.isNull() do vreqerr("MARDM") quit
		if vx("MARTEL").exists(),cif.martel.isNull() do vreqerr("MARTEL") quit
	}
	if 'vobj(cif,-100,50,"").order().isNull() do {
		if vx("TYPE").exists(),cif.type.isNull() do vreqerr("TYPE") quit
		if vx("CLS").exists(),cif.cls.isNull() do vreqerr("CLS") quit
		if vx("GRP").exists(),cif.grp.isNull() do vreqerr("GRP") quit
		if vx("PERS").exists(),cif.pers.isNull() do vreqerr("PERS") quit
		if vx("CRCD").exists(),cif.crcd.isNull() do vreqerr("CRCD") quit
	}
	if 'vobj(cif,-100,67,"").order().isNull() do {
		if vx("CMSFLG").exists(),cif.cmsflg.isNull() do vreqerr("CMSFLG") quit
	}
	if 'vobj(cif,-100,75,"").order().isNull() do {
		if vx("GOVT").exists(),cif.govt.isNull() do vreqerr("GOVT") quit
	}
	if 'vobj(cif,-100,85,"").order().isNull() do {
		if vx("POLEXPPER").exists(),cif.polexpper.isNull() do vreqerr("POLEXPPER") quit
		if vx("INTACTDET").exists(),cif.intactdet.isNull() do vreqerr("INTACTDET") quit
		if vx("PUBHLDIND").exists(),cif.pubhldind.isNull() do vreqerr("PUBHLDIND") quit
		if vx("HLDCOMIND").exists(),cif.hldcomind.isNull() do vreqerr("HLDCOMIND") quit
	}
	if 'vobj(cif,-100,90,"").order().isNull() do {
		if vx("INTERBANK").exists(),cif.interbank.isNull() do vreqerr("INTERBANK") quit
		if vx("SWIFTSAK").exists(),cif.swiftsak.isNull() do vreqerr("SWIFTSAK") quit
	}
	if 'vobj(cif,-100,91,"").order().isNull() do {
		if vx("PIN1CNTR").exists(),cif.pin1cntr.isNull() do vreqerr("PIN1CNTR") quit
		if vx("PIN1DEL").exists(),cif.pin1del.isNull() do vreqerr("PIN1DEL") quit
	}
	if 'vobj(cif,-100,92,"").order().isNull() do {
		if vx("PIN2CNTR").exists(),cif.pin2cntr.isNull() do vreqerr("PIN2CNTR") quit
		if vx("PIN2DEL").exists(),cif.pin2del.isNull() do vreqerr("PIN2DEL") quit
	}
	if 'vobj(cif,-100,420,"").order().isNull() do {
		if vx("SELFEMP").exists(),cif.selfemp.isNull() do vreqerr("SELFEMP") quit
	}
	if 'vobj(cif,-100,422,"").order().isNull() do {
		if vx("FINSTREQ").exists(),cif.finstreq.isNull() do vreqerr("FINSTREQ") quit
	}
	if 'vobj(cif,-100,424,"").order().isNull() do {
		if vx("IDSHARE").exists(),cif.idshare.isNull() do vreqerr("IDSHARE") quit
		if vx("IDTHEFT").exists(),cif.idtheft.isNull() do vreqerr("IDTHEFT") quit
		if vx("CIFDATSB").exists(),cif.cifdatsb.isNull() do vreqerr("CIFDATSB") quit
	}
	if 'vobj(cif,-100,426,"").order().isNull() do {
		if vx("CRBRAUTH").exists(),cif.crbrauth.isNull() do vreqerr("CRBRAUTH") quit
	}
	if 'vobj(cif,-100,438,"").order().isNull() do {
		if vx("MT900").exists(),cif.mt900.isNull() do vreqerr("MT900") quit
		if vx("MT910").exists(),cif.mt910.isNull() do vreqerr("MT910") quit
		if vx("MT320").exists(),cif.mt320.isNull() do vreqerr("MT320") quit
		if vx("MT940").exists(),cif.mt940.isNull() do vreqerr("MT940") quit
		if vx("MT942").exists(),cif.mt942.isNull() do vreqerr("MT942") quit
		if vx("MT950").exists(),cif.mt950.isNull() do vreqerr("MT950") quit
	}
	if 'vobj(cif,-100,1000,"").order().isNull() do {
		if vx("ZRELPOEXPER").exists(),cif.zrelpoexper.isNull() do vreqerr("ZRELPOEXPER") quit
	}
		if vx("AFINST").exists(),cif.afinst.isNull() do vreqerr("AFINST") quit
		if vx("AGENT").exists(),cif.agent.isNull() do vreqerr("AGENT") quit
		if vx("BOO").exists(),cif.boo.isNull() do vreqerr("BOO") quit
		if vx("BWF").exists(),cif.bwf.isNull() do vreqerr("BWF") quit
		if vx("CC").exists(),cif.cc.isNull() do vreqerr("CC") quit
		if vx("CCODE").exists(),cif.ccode.isNull() do vreqerr("CCODE") quit
		if vx("CIFDATSB").exists(),cif.cifdatsb.isNull() do vreqerr("CIFDATSB") quit
		if vx("CLS").exists(),cif.cls.isNull() do vreqerr("CLS") quit
		if vx("CMSFLG").exists(),cif.cmsflg.isNull() do vreqerr("CMSFLG") quit
		if vx("CRBRAUTH").exists(),cif.crbrauth.isNull() do vreqerr("CRBRAUTH") quit
		if vx("CRCD").exists(),cif.crcd.isNull() do vreqerr("CRCD") quit
		if vx("DAO").exists(),cif.dao.isNull() do vreqerr("DAO") quit
		if vx("DDBIP").exists(),cif.ddbip.isNull() do vreqerr("DDBIP") quit
		if vx("EDBI").exists(),cif.edbi.isNull() do vreqerr("EDBI") quit
		if vx("EXPFLG").exists(),cif.expflg.isNull() do vreqerr("EXPFLG") quit
		if vx("FINSTREQ").exists(),cif.finstreq.isNull() do vreqerr("FINSTREQ") quit
		if vx("GOVT").exists(),cif.govt.isNull() do vreqerr("GOVT") quit
		if vx("GRP").exists(),cif.grp.isNull() do vreqerr("GRP") quit
		if vx("HLDCOMIND").exists(),cif.hldcomind.isNull() do vreqerr("HLDCOMIND") quit
		if vx("IDSHARE").exists(),cif.idshare.isNull() do vreqerr("IDSHARE") quit
		if vx("IDTHEFT").exists(),cif.idtheft.isNull() do vreqerr("IDTHEFT") quit
		if vx("INTACTDET").exists(),cif.intactdet.isNull() do vreqerr("INTACTDET") quit
		if vx("INTERBANK").exists(),cif.interbank.isNull() do vreqerr("INTERBANK") quit
		if vx("LNM").exists(),cif.lnm.isNull() do vreqerr("LNM") quit
		if vx("MAD1").exists(),cif.mad1.isNull() do vreqerr("MAD1") quit
		if vx("MARDM").exists(),cif.mardm.isNull() do vreqerr("MARDM") quit
		if vx("MAREM").exists(),cif.marem.isNull() do vreqerr("MAREM") quit
		if vx("MARTEL").exists(),cif.martel.isNull() do vreqerr("MARTEL") quit
		if vx("MCITY").exists(),cif.mcity.isNull() do vreqerr("MCITY") quit
		if vx("MCNTRY").exists(),cif.mcntry.isNull() do vreqerr("MCNTRY") quit
		if vx("MT320").exists(),cif.mt320.isNull() do vreqerr("MT320") quit
		if vx("MT900").exists(),cif.mt900.isNull() do vreqerr("MT900") quit
		if vx("MT910").exists(),cif.mt910.isNull() do vreqerr("MT910") quit
		if vx("MT940").exists(),cif.mt940.isNull() do vreqerr("MT940") quit
		if vx("MT942").exists(),cif.mt942.isNull() do vreqerr("MT942") quit
		if vx("MT950").exists(),cif.mt950.isNull() do vreqerr("MT950") quit
		if vx("NAM").exists(),cif.nam.isNull() do vreqerr("NAM") quit
		if vx("NOPURGE").exists(),cif.nopurge.isNull() do vreqerr("NOPURGE") quit
		if vx("NR").exists(),cif.nr.isNull() do vreqerr("NR") quit
		if vx("PAD1").exists(),cif.pad1.isNull() do vreqerr("PAD1") quit
		if vx("PCITY").exists(),cif.pcity.isNull() do vreqerr("PCITY") quit
		if vx("PCNTRY").exists(),cif.pcntry.isNull() do vreqerr("PCNTRY") quit
		if vx("PERS").exists(),cif.pers.isNull() do vreqerr("PERS") quit
		if vx("PIN1CNTR").exists(),cif.pin1cntr.isNull() do vreqerr("PIN1CNTR") quit
		if vx("PIN1DEL").exists(),cif.pin1del.isNull() do vreqerr("PIN1DEL") quit
		if vx("PIN2CNTR").exists(),cif.pin2cntr.isNull() do vreqerr("PIN2CNTR") quit
		if vx("PIN2DEL").exists(),cif.pin2del.isNull() do vreqerr("PIN2DEL") quit
		if vx("POLEXPPER").exists(),cif.polexpper.isNull() do vreqerr("POLEXPPER") quit
		if vx("PUBHLDIND").exists(),cif.pubhldind.isNull() do vreqerr("PUBHLDIND") quit
		if vx("RFLGC").exists(),cif.rflgc.isNull() do vreqerr("RFLGC") quit
		if vx("SELFEMP").exists(),cif.selfemp.isNull() do vreqerr("SELFEMP") quit
		if vx("SWIFTSAK").exists(),cif.swiftsak.isNull() do vreqerr("SWIFTSAK") quit
		if vx("TAXEXM").exists(),cif.taxexm.isNull() do vreqerr("TAXEXM") quit
		if vx("TYPE").exists(),cif.type.isNull() do vreqerr("TYPE") quit
		if vx("VOTEXM").exists(),cif.votexm.isNull() do vreqerr("VOTEXM") quit
		if vx("W8REQ").exists(),cif.w8req.isNull() do vreqerr("W8REQ") quit
		if vx("ZRELPOEXPER").exists(),cif.zrelpoexper.isNull() do vreqerr("ZRELPOEXPER") quit
	quit

vreqerr(di) // Required error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("CIF","MSG",1767,"CIF."_di)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit


VFKEYS // Foreign keys

	type public String vfkey(),vpar

	type public RecordCIF cif
	if 'cif.type.isNull() set vfkey("^UTBLDFTC("_""""_cif.type_""""_","_50_")")="CIF(TYPE) -> PRODDFTC"
	quit

CHKFKS   // Check foreign keys when not under buffer


	type public RecordCIF cif
	type public Number %O
	type String vERRMSG

	if 'Db.isDefined("PRODDFTC",":cif.type") set vERRMSG = $$^MSG(8563,"CIF(TYPE) -> PRODDFTC") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	quit


VAD //
	type public Number ER = 0
	type public String vx(),RM
	do vad1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	do vau10 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() quit
	if vx("AUD1").exists()!vx("AUD1CF").exists()!vx("AUD1ND").exists()!vx("AUD1LD").exists()!vx("AUD2").exists()!vx("AUD2CF").exists()!vx("AUD2ND").exists()!vx("AUD2LD").exists() do vau3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CIFOFF").exists() do vau4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CO").exists() do vau5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CRRATEND").exists()!vx("CRRATELD").exists() do vau6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DARCOVR").exists() do vau7 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DEPCLOVR").exists() do vau8 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DOD").exists() do vau9 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("EMPSTATE").exists()!vx("EMPZIP").exists()!vx("EMPCNTRY").exists() do vau11 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GOVT").exists()!vx("SIC").exists() do vau2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("INTYPE").exists() do vau12 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MAD1").exists()!vx("MAD2").exists()!vx("MAD3").exists()!vx("MAD4").exists()!vx("MCITY").exists()!vx("MCNTRY").exists()!vx("MLOC").exists()!vx("MSTATE").exists()!vx("MZIP").exists()!vx("PAD1").exists()!vx("PAD2").exists()!vx("PAD3").exists()!vx("PAD4").exists()!vx("PCITY").exists()!vx("PCNTRY").exists()!vx("PLOC").exists()!vx("PSTATE").exists()!vx("PZIP").exists() do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT900").exists()!vx("MT900THR").exists() do vau13 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT910").exists()!vx("MT910THR").exists() do vau14 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MZIP").exists() do vau15 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NR").exists() do vau16 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PLAN").exists() do vau17 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PZIP").exists() do vau18 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SCHRVND").exists()!vx("SCHRVLD").exists() do vau19 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SEMFIN").exists() do vau20 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STMTRVND").exists()!vx("STMTRVLD").exists() do vau21 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBD //
	type public Number ER = 0
	type public String vx(),RM
	do vbd1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordCIF cif
	do vbu16 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do vbu19 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() do AUDIT^UCUTILN(cif,.vx(),10,"|") quit
	if vx("BOO").exists() do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CREREFRE").exists() do vbu2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DOB").exists() do vbu3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DOD").exists() do vbu4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DODSABL").exists() do vbu5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("FINSTFRE").exists() do vbu6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT320").exists() do vbu7 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT900").exists() do vbu8 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT910").exists() do vbu9 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT940").exists() do vbu10 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT942G1").exists()!vx("MT942G2").exists()!vx("MT942").exists() do vbu11 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT950").exists() do vbu12 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NAM").exists()!vx("LNM").exists()!vx("FNAME").exists()!vx("MNAME").exists()!vx("SUFFIX").exists() do vbu13 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PIN1CNTR").exists() do vbu14 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PIN1DEL").exists() do vbu15 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PIN2CNTR").exists() do vbu17 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PIN2DEL").exists() do vbu18 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PZIP").exists()!vx("MZIP").exists() do vbu24 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STAT").exists()!vx("CUSTCHDT").exists() do vbu20 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TAXID").exists() do vbu21 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("USRESTAT").exists() do vbu22 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("XNAME").exists() do vbu23 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(cif,.vx(),10,"|")
	quit


vad1 // Trigger AFTER_DELETE - After delete

	type public RecordCIF cif
	kill par("CASDEL")
	quit
	

vai1 // Trigger AFTER_INSERT_UPDATE - After Insert Trigger

	type public RecordCIF cif
	/*
	--Revision History-----------------------------------------------------------

	03/14/07 - KumarSS - CR 25177
		   Removed Invalid Unicode Characters.

	06/02/06 - GIRIDHAL - 21207
	 	   Trigger has been modified to validate the ZIP code, state, and
	 	   country fields associated with a customer's employer
	 	    
	01/17/05 - HILLANBRAND - 13686
		   Changed call for TAXID verfication to call directly into EXT^VERTIN.

	06/14/04 - SCHWARTZC - CR10219
		   Removed code to default the relationship matrix (CIF.RELMAT)
		   from the product type.  The code has been moved to the
		   BEFORE_INSERT trigger to prevent calling the CIF filer
		   from the triggers, which was causing a "Record already
		   exists" error when creating customers.

	11/12/02 - CARROLLJ - 43583
		   PSL conversion cleanup.	

	08/23/01 - VETSENM - 46279:18
		   Trigger modified to default Relationship Matrix value from
		   from product type to customer record.            

 	11/2/00 - Spier - 42606
		   Added call to CHKSTATE^ADDRUTL to validate states against the
		   STBLCNTRY1 table. This check can not be done by DQ table validate.

								03/29/00 - SIVCHUKA - 37734
																			Add new check to prevent account creation prior to
																			PRODCTL.DTBEG
		   Optimized performance by passing a parameter to SCADAT
																			calls, reference LRQ 58163-03

	01/17/00 - KELLYP - 36682
		   Added checks on MT900THR and MT910THR (RF of these triggers
		   from 6.2). 

	12/08/99 - Chiang - 33890
																			Modified to convert triggers into PSL format.

	04/16/99 - CARROLLJ - 31428
	           Added integrity check to check if plan owner's date of death for
		   records with dates with the year prior to the current year.
	*/

	// ----- Validate Postal/zip code
	
	do ZIP^PROCZIP(cif.pcntry,cif.pstate,cif.pzip) if $G(ER) do Runtime.setErrMSG("CIF",3333,RM) quit:ER 
	do ZIP^PROCZIP(cif.mcntry,cif.mstate,cif.mzip) if $G(ER) do Runtime.setErrMSG("CIF",3333,RM) quit:ER 
	do ZIP^PROCZIP(cif.empcntry,cif.empstate,cif.empzip) if $G(ER) do Runtime.setErrMSG("CIF",3333,RM) quit:ER
	
 	//Validate State

	if cif.mstate'="",$$CHKSTATE^ADDRUTL("CIF",cif.mcntry,cif.mstate) quit:ER
	if cif.pstate'="",$$CHKSTATE^ADDRUTL("CIF",cif.pcntry,cif.pstate) quit:ER
	if cif.empstate'="",$$CHKSTATE^ADDRUTL("CIF",cif.empcntry,cif.empstate) quit:ER


	// ----- Validate Tax Id	
	do EXT^VERTIN(.cif)
	if ER do Runtime.setErrSTBLER("CIF","INVLDTX") quit:ER         // Log fatal error
	
								// ----- New check to prevent account creation prior to PRODCTL.DTBEG
															new ddate,diff,TYPE
	       set TYPE=cif.type
	       set dtbeg=Db.getOneRow("DTBEG","PRODCTL","TYPE")
	       set dao=cif.dao
															if dao<dtbeg set ER=1
	       if ER set ddate=$$DAT^%ZM(dtbeg) do Runtime.setErrMSG("CIF",2036,"TYPE~ddate") quit:ER
													 
	// ----- Validate audit information
	do { quit:ER 
		if cif.aud1="",cif.aud1cf="",cif.aud1nd="",cif.aud1ld="" quit 
		if cif.aud1'="",cif.aud1cf'="",cif.aud1nd'="",cif.aud1ld'="" quit 
		do Runtime.setErrMSG("CIF",1767,"AUD1 AUD1CF AUD1ND AUD1LD") quit:ER 

		}
	do { quit:ER 
		if cif.aud2="",cif.aud2cf="",cif.aud2nd="",cif.aud2ld="" quit 
		if cif.aud2'="",cif.aud2cf'="",cif.aud2nd'="",cif.aud2ld'="" quit 
		do Runtime.setErrMSG("CIF",1767,"AUD2 AUD2CF AUD2ND AUD2LD") quit:ER 
		}
	
	// Verify the value exist in [UTBLACC]
	if cif.darcovr,'Db.isDefined("UTBLACC","'L',cif.darcovr") do Runtime.setErrMSG("CIF",1485,"UTBLACC.AC") quit:ER 


	// Verify the date entered if it is end of the month
	if cif.semfin'="",cif.semfin'=$$EOMJD^SCADAT(cif.semfin,1) do Runtime.setErrMSG("CIF",2848) quit:ER 
	

	// Only execute following code during account creation
	if %ProcessMode=0 do { quit:ER 
		// Duplicate Customer Search
		if 'Db.isDefined("UTBLDUPCIF","1") quit 
		new xacn,XACN,CIFDATA
		set CIFDATA=""
		do SEARCH^DUPLCIF(CIFDATA,.XACN) quit:ER 
		set xacn=$P($O(XACN("")),$C(9),1) if xacn'="" do Runtime.setErrXBAD("CIF","DUPCIF",xacn) quit:ER 
		}


	// Check Plan Owner's Date of Death
	if %ProcessMode=2 do { quit:ER 
		if 'cif.dod quit 
		set TYR=$$YEAR^SCADAT(%SystemDate,1)
		set DYR=$$YEAR^SCADAT(cif.dod,1)
		if (TYR-1)'>DYR quit 
	
		new rs 
		type ResultSet rs=Db.select("PLNFMV,PVMAD","IRA","ACN=:ACN AND TAXYR=:TYR") 
		if rs.isEmpty() quit
		set INFO=rs.next()
	
		if (rs.getCol(1))!(rs.getCol(2)) do Runtime.setErrXBAD("CIF","CIFPLN",) quit:ER 
		}

	// MT900THR - MT900 Debit Threshold
	if (cif.mt900=1)&(cif.mt900thr="") do Runtime.setErrMSG("CIF",4077) quit:ER

	// MT910THR - MT910 Credit Threshold
	if (cif.mt910=1)&(cif.mt910thr="") do Runtime.setErrMSG("CIF",4078) quit:ER

	quit

vau1 // Trigger AFTER_UPD_ADDRESS - AFTER ADDRESS FIELDS ARE UPDATED

	type public RecordCIF cif
	/*
	---- Revision History ------------------------------------------------	
	 05/31/06 - GIRIDHAL - 21510
	 	Rewriting the trigger logic to use PSL objects.
	 	
	 05/15/01 - ANTONOVS - 43026
		Add logic to update SADDRCIF - seasonal address table if 
		seasonal address is in effect (currently is mailing address)
	
	 11/02/00 - Spier - 42606
		Modified to add lookup table checking for states PSTATE,MSTATE
		Since the defined lookup requires 2 keys, DQ can not do the validation.

	 02/25/00 - BECKERW - 35821
		TOTCOMEXP and TOTOUTEXP need to rounded to the precision
		indicated by the currency code.  It was causing decimal
		format errors.  Added rounding function when inserting or
		updating EXPCNTRY.	

	 09/17/99 - SCHWARTZC - 28966
		Added the /FRMFILER parameter to the sql update of ACN.  This
		should prevent the DOD and DODSABL restriction messages from
		being displayed for each account.
	
	 05/04/99 - SCHWARTZC - 32889
		Added "N"ew of ACN inside of the I LCCADR D statement.  This
		prevents an undefined error after the SQL UPDATE of the ACN file.
	
	*/
	
	// Update CCLD on the accounts linked to the account as the primary owner.
	if CUVAR.LCCADR do {
		type Number XCID
		type ResultSet rs=Db.select("CID","RELCIF","ACN=:cif.acn AND ROLE='1'")
		while rs.next() do { 
			set XCID=rs.getCol("CID")
			do Db.update("ACN","CCLD=:%SystemDate","CID=:XCID","/NOJOURNAL/FRMFILER")  //cds 9/17/99
			}
		}

	// Country Update
	if (cif.pcntry.oldVal'=cif.pcntry),(CUVAR.LIMPRO = 1) do {
		type Number TOTCOM, TOTOUT
		type String NCN, PCN, TMP

		// PCN - Country before, NCN - Country after
		set PCN = cif.pcntry.oldVal 
		set NCN = cif.pcntry
		set TMP = $$ACCUM^PROCLIM(ACN) 
		set TOTCOM = TMP.piece("|",1) 
		set TOTOUT = TMP.piece("|",2)

		type RecordEXPCNTRY expcnto = Db.getRecord("EXPCNTRY","CNTRY=:PCN",1)		
		set expcnto.totcomexp = expcnto.totcomexp - TOTCOM 
		set expcnto.totoutexp = expcnto.totoutexp - TOTOUT
		set expcnto.totcomexp = expcnto.totcomexp.roundDec()	//WVB - 35821
		set expcnto.totoutexp = expcnto.totoutexp.roundDec()	//WVB - 35821

		do expcnto.save()
	
		type RecordEXPCNTRY expcntn = Db.getRecord("EXPCNTRY","CNTRY=:NCN",1)
		set expcntn.totcomexp = expcntn.totcomexp + TOTCOM
		set expcntn.totoutexp = expcntn.totoutexp + TOTOUT
		set expcntn.totcomexp = expcntn.totcomexp.roundDec()  //WVB - 35821
		set expcntn.totoutexp = expcntn.totoutexp.roundDec()  //WVB - 35821

		do expcntn.save()


		// Update Sovereign Risk Limits
		if cif.govt do {
			type RecordEXPCNSOV expsovo = Db.getRecord("EXPCNSOV","CNTRY=:PCN",1)
			set expsovo.totcomexp = expsovo.totcomexp - TOTCOM 
			set expsovo.totoutexp = expsovo.totoutexp - TOTOUT
			set expsovo.totcomexp = expsovo.totcomexp.roundDec()  //WVB - 35821
			set expsovo.totoutexp = expsovo.totoutexp.roundDec()  //WVB - 35821

			do expsovo.save()	
			
			type RecordEXPCNSOV expsovn = Db.getRecord("EXPCNSOV","CNTRY=:NCN",1)
			set expsovn.totcomexp = expsovn.totcomexp + TOTCOM 
			set expsovn.totoutexp = expsovn.totoutexp + TOTOUT
			set expsovn.totcomexp = expsovn.totcomexp.roundDec()  //WVB - 35821
			set expsovn.totoutexp = expsovn.totoutexp.roundDec()  //WVB - 35821

			do expsovn.save()
			}
		}
		
	//Validate state form lookup table
	type Public Boolean ER
	if cif.isChanged("PSTATE"),cif.pstate'="",$$CHKSTATE^ADDRUTL("CIF",cif.pcntry,cif.pstate) Q:ER
	if cif.isChanged("MSTATE"),cif.mstate'="",$$CHKSTATE^ADDRUTL("CIF",cif.mcntry,cif.mstate) Q:ER

	//Update SADDRCIF with seasonal address if seasonal address is in effect

	type RecordSADDRCIF saddrcif=Db.getRecord("SADDRCIF","ACN",1)

	if saddrcif.getMode() = 0 quit
	
	if saddrcif.sadsd = "",saddrcif.saded = "" quit

	if ((%SystemDate'<saddrcif.sadsd)&(%SystemDate'>saddrcif.saded)) do { quit:ER
		set saddrcif.sad1=cif.mad1
		set saddrcif.sad2=cif.mad2
		set saddrcif.sad3=cif.mad3
		set saddrcif.sad4=cif.mad4
		set saddrcif.scity=cif.mcity
		set saddrcif.scntry=cif.mcntry
		set saddrcif.sstate=cif.mstate
		set saddrcif.szip=cif.mzip

		do saddrcif.bypassSave()
		}

	quit 

vau2 // Trigger AFTER_UPD_LIM - After UPDATE trigger (Limits)

	type public RecordCIF cif
	/*
	 Revision History
	
	02/25/00 - BECKERW - 35821
		TOTCOMEXP and TOTOUTEXP need to rounded to the precision
		indicated by the currency code.  It was causing decimal
		format errors.  Added rounding function when inserting or
		updating EXPCNTRY.
	
	 06/17/98 - ZWITKOWITS - ARQ 29058
	          Modified setting up of EXPIND for the new SIC to fix "Record already
	          exists" error.  Retrofitted following:
	
	     KLINEB - ARQ 28193
	              Added code to check if SIC is not null before inserting/updating
	              exposure data to EXPIND.
	
	*/

	
	quit:'Db.getOneRow("LIMPRO","CUVAR","") 

	if cif.govt.oldVal'=cif.govt do {
		new CONDATA,CNTRY,TMP,TOTCOM,TOTCOMEXP,TOTOUT,TOTOUTEXP,X
		set TMP=$$ACCUM^PROCLIM(ACN) set TOTCOM=$P(TMP,"|",1) set TOTOUT=$P(TMP,"|",2) set TMP=""
		set CNTRY=cif.pcntry
		set CONDATA=Db.getOneRow("TOTCOMEXP,TOTOUTEXP","EXPCNSOV","CNTRY")
		set TOTCOMEXP=$P(CONDATA,$C(9),1) set TOTOUTEXP=$P(CONDATA,$C(9),2)
		if cif.govt=0 do {
			set TOTCOMEXP=TOTCOMEXP-TOTCOM set TOTOUTEXP=TOTOUTEXP-TOTOUT
			if 'TOTCOMEXP,'TOTOUTEXP set X=0 do Db.delete("EXPCNSOV","CNTRY=:CNTRY")
			else  do {
				set TOTCOMEXP=$$^SCARND(TOTCOMEXP,0,"")  //WVB - 35821
				set TOTOUTEXP=$$^SCARND(TOTOUTEXP,0,"")  //WVB - 35821
				set X=0 do Db.update("EXPCNSOV","TOTCOMEXP=:TOTCOMEXP,TOTOUTEXP=:TOTOUTEXP","CNTRY=:CNTRY")
				}
			}
		else  do {
			set TOTCOMEXP=$$^SCARND(TOTCOMEXP,0,"")   //WVB - 35821
			set TOTOUTEXP=$$^SCARND(TOTOUTEXP,0,"")   //WVB - 35821
			if 'TOTCOMEXP,'TOTOUTEXP set X=0 do Db.insert("EXPCNSOV","CNTRY,TOTCOMEXP,TOTOUTEXP",":CNTRY,:TOTCOM,:TOTOUT") quit 
			set TOTCOMEXP=TOTCOMEXP+TOTCOM set TOTOUTEXP=TOTOUTEXP+TOTOUT
			set TOTCOMEXP=$$^SCARND(TOTCOMEXP,0,"")   //WVB - 35821
			set TOTOUTEXP=$$^SCARND(TOTOUTEXP,0,"")   //WVB - 35821
			set X=0 do Db.update("EXPCNSOV","TOTCOMEXP=:TOTCOMEXP,TOTOUTEXP=:TOTOUTEXP","CNTRY=:CNTRY")
			}
		}
	if cif.sic.oldVal'=cif.sic do {
		new CONDATA,SIC,TMP,TOTCOM,TOTCOMEXP,TOTOUT,TOTOUTEXP,X
		set TMP=$$ACCUM^PROCLIM(ACN) 
		set TOTCOM=$P(TMP,"|",1)
		set TOTOUT=$P(TMP,"|",2)

		// Old Industy Code
		set SIC=cif.sic.oldVal
		if $G(SIC)'="" do {
			set CONDATA=Db.getOneRow("TOTCOMEXP,TOTOUTEXP","EXPIND","SIC")
			set TOTCOMEXP=$P(CONDATA,$C(9),1) set TOTOUTEXP=$P(CONDATA,$C(9),2) set CONDATA=""
			set TOTCOMEXP=TOTCOMEXP-TOTCOM set TOTOUTEXP=TOTOUTEXP-TOTOUT
			if 'TOTCOMEXP,'TOTOUTEXP set X=0 do Db.delete("EXPIND","IND=:SIC")
			else  do {
				set TOTCOMEXP=$$^SCARND(TOTCOMEXP,0,"")   //WVB - 35821
				set TOTOUTEXP=$$^SCARND(TOTOUTEXP,0,"")   //WVB - 35821
				do Db.update("EXPIND","TOTCOMEXP=:TOTCOMEXP,TOTOUTEXP=:TOTOUTEXP","IND=:SIC")
				}
			}

		// New Industy Code
		set SIC=cif.sic
		if $G(SIC)'="" do {
			if 'TOTCOM,'TOTOUT quit 
			set CONDATA=Db.getOneRow("TOTCOMEXP,TOTOUTEXP","EXPIND","SIC")
			set TOTCOMEXP=$P(CONDATA,$C(9),1) set TOTOUTEXP=$P(CONDATA,$C(9),2)
			set TOTCOMEXP=$$^SCARND(TOTCOMEXP,0,"")   //WVB - 35821
			set TOTOUTEXP=$$^SCARND(TOTOUTEXP,0,"")   //WVB - 35821
			if TOTCOMEXP="",TOTOUTEXP="" do Db.insert("EXPIND","IND,TOTCOMEXP,TOTOUTEXP",":SIC,:TOTCOM,:TOTOUT") quit 
			set TOTCOMEXP=TOTCOMEXP+TOTCOM set TOTOUTEXP=TOTOUTEXP+TOTOUT
			set TOTCOMEXP=$$^SCARND(TOTCOMEXP,0,"")   //WVB - 35821
			set TOTOUTEXP=$$^SCARND(TOTOUTEXP,0,"")   //WVB - 35821
			do Db.update("EXPIND","TOTCOMEXP=:TOTCOMEXP,TOTOUTEXP=:TOTOUTEXP","IND=:SIC")
			}
		}
	quit 

	/* References to other routines

	   PROCLIM    (ACCUM)        - Procedure LIMCHK - Consolidated Limit Check
	*/
	
	quit

vau3 // Trigger AU_AUDIT - After Update Audit Information

	type public RecordCIF cif
	/*
	---- Revision History ------------------------------------------------

	 01/17/05 - HILLANBRAND - 13686
	 	    Place Audit Columns verification in this new trigger with
	 	    description to identify the columns that are being verified.

	*/	



	// ----- Validate audit information
	do { quit:ER 
		if cif.aud1="",cif.aud1cf="",cif.aud1nd="",cif.aud1ld="" quit 
		if cif.aud1'="",cif.aud1cf'="",cif.aud1nd'="",cif.aud1ld'="" quit 
		do Runtime.setErrMSG("CIF",1767,"AUD1 AUD1CF AUD1ND AUD1LD") quit:ER 
		}
	do { quit:ER 
		if cif.aud2="",cif.aud2cf="",cif.aud2nd="",cif.aud2ld="" quit 
		if cif.aud2'="",cif.aud2cf'="",cif.aud2nd'="",cif.aud2ld'="" quit 
		do Runtime.setErrMSG("CIF",1767,"AUD2 AUD2CF AUD2ND AUD2LD") quit:ER 
		}
	
	quit
	

vau4 // Trigger AU_CIFOFF - After Update of CIFOFF

	type public RecordCIF cif

	// Update CIF Officer Code on Deposit accounts where the CIF is the primary CIF.

	new X,XACN,XCID,XOFF
	set XACN=cif.acn
	set XOFF=cif.cifoff

	new rs 
	type ResultSet rs=Db.select("CID","RELCIF","ACN=:XACN AND ROLE='1'")
	if rs.isEmpty() quit
	while rs.next()  do { 
		set XCID=rs.getCol(1)
		set ER=0 do Db.update("DEP","OFF2=:XOFF","CID=:XCID AND CLS='D'","/NOJOURNAL")
		}
	quit

vau5 // Trigger AU_CO - After Update of Company Code

	type public RecordCIF cif
	/*
		-----Revision History-------------------------------------------------
	01/17/05 - HILLANBRAND - 13686
	 	   Changed call for TAXID verfication to call directly 
		   into EXT^VERTIN.


	05/09/00 - SKLYUTD - 38116
		   On the company code change perform taxid verification.
		----------------------------------------------------------------------
	*/
	do EXT^VERTIN(.cif)
	quit

vau6 // Trigger AU_CRRATE - After Upd of Next/Last Credit Rating Dt

	type public RecordCIF cif
	/*
	---- Revision History ------------------------------------------------	
	
	 06/05/06 - GIRIDHAL - CR 21207
									Validate Credit Rating Next Date and Last Date.
								 
	----------------------------------------------------------------------
	*/
	//Enter a date after the current system date
	if cif.crratend,(cif.crratend < %SystemDate) do Runtime.setErrMSG("CIF",914) quit:ER
	//Date must be the same as or before the system date
	if cif.crrateld,(cif.crrateld > %SystemDate) do Runtime.setErrMSG("CIF",753) quit:ER
	quit

vau7 // Trigger AU_DARCOVR - CIF.DARCOVR after update

	type public RecordCIF cif
	/*
	---- Revision History ------------------------------------------------

	08/10/05 - TITOVE - CR 16844
		   Minor clean up as part of DBI3 project. 

	*/
	
	// Default CIF.DARCOVR modifications to LN.DARCOVR, if applicable
	
	// Verify the value exist in UTBLACC: "Invalid table value ~p1"
	if cif.darcovr,'Db.isDefined("UTBLACC","'L',cif.darcovr") do Runtime.setErrMSG("CIF",1485,"UTBLACC.AC") quit:ER 

	// Select accounts with Loan Account Direct Liability Indicator set
	type ResultSet rs = Db.select("CID","RELCIF","ACN=:cif.acn AND LDI=1") 

	while rs.next()  do { 

		set XCID = rs.getCol("CID")

		type RecordLN ln = Db.getRecord("LN","CID = :XCID")

		type RecordPRODCTL prodctl = Db.getRecord("PRODCTL","TYPE = :ln.type")
		
		// If product type delinquency reclassification processing is "N",
		// the override can not be set
		if cif.darcovr,'prodctl.darcpo quit
		
		do ln.setAuditFlag(1)
		
		set ln.darcovr = cif.darcovr
		
		do ln.save()
		}
		
	quit

vau8 // Trigger AU_DEPCLOVR - Deposit Asset Class Override

	type public RecordCIF cif
	/*
	---- Revision History ------------------------------------------------

	08/10/05 - TITOVE - CR 16844
		   Minor clean up as part of DBI3 project. 

	*/
	
	// Default [CIF]DEPCLOVR modifications to [DEP]DARCOVR

	// Verify the value exist in UTBLACC: "Invalid table value ~p1"
	if cif.depclovr,'Db.isDefined("UTBLACC","'D',cif.depclovr") do Runtime.setErrMSG("CIF",1485,"UTBLACC.AC") quit:ER 

	// Select accounts with Deposit Account Owner Indicator set
	type ResultSet rs = Db.select("CID","RELCIF","ACN=:cif.acn AND DOI=1")

	while rs.next()  do { 

		set XCID = rs.getCol("CID")

		type RecordDEP dep = Db.getRecord("DEP","CID = :XCID")

		type RecordPRODCTL prodctl = Db.getRecord("PRODCTL","TYPE = :dep.type")
		
		// If product type deposit reclassification processing is "N",
		// the override can not be set
		if cif.depclovr,'prodctl.darcpo quit
		
		do dep.setAuditFlag(1)
		
		set dep.darcovr = cif.depclovr
		
		do dep.save()
		}
		
	quit

vau9 // Trigger AU_DOD - After Update Date of Death

	type public RecordCIF cif
	/*
	----------Revision History--------------------------------------------

	01/03/05 - HILLANBRAND - 13686
	           Changed call to ^CIFDOD to DODCALC^CIFDOD and pass cif 
	
	02/07/01 - ANTONOVS - 43472
		   Display error message "Date cannot be less than date of
		   creation" if Date of Death is less then CIF created date	

	12/28/99 - MAGERAM - 36114
		   Roll Forward for ARQ# 33138 - Problems with deceased customer
		   account inquiry.
	-----------------------------------------------------------------------
	*/
	
	// Update DOD data fields.
	if (cif.dod'="")&(cif.dod<cif.dao) do Runtime.setErrMSG("CIF",8368) quit:ER
	do DODCALC^CIFDOD(.cif)
	quit

vau10 // Trigger AU_DOD_INTEG - Date of Death/Disability Integrity Check

	type public RecordCIF cif
	/*
	---- Revision History ------------------------------------------------
	
	 02/15/00 - SCHWARTZC - 35048
		    Added code to check if DOD and DODSABL restrictions have
		    already been triggered.
	
	----------------------------------------------------------------------
	
	This trigger should never have a column name associated with it.  It should
	be called for any and all CIF maintenance.
	*/

	// cds 9/21/99 Verify that the CIFDOD and CIFDODSABL restrictions have
	// not been set.  Do not set the restrictions a second time.

	new DODRST,DISBRST set (DODRST,DISBRST)=0
	new VERR1,VERR2 set (VERR1,VERR2)=""
	for  set VERR1=$O(verrors(VERR1)) quit:VERR1=""  do {
		for  set VERR2=$O(verrors(VERR1,VERR2)) quit:VERR2=""  do {
			if $P(verrors(VERR1,VERR2),"|",3)="CIFDOD" set DODRST=1
			if $P(verrors(VERR1,VERR2),"|",3)="CIFDODSABL" set DISBRST=1
			}
		}

	if cif.dod,'DODRST do Runtime.setErrXBAD("CIF","CIFDOD",) quit:ER 
	if cif.dodsabl,'DISBRST do Runtime.setErrXBAD("CIF","CIFDODSABL",) quit:ER 
	quit 

vau11 // Trigger AU_EMPADDR - After Update of Employer Address

	type public RecordCIF cif
	/*
	---- Revision History ------------------------------------------------	
	
	  06/02/06 - GIRIDHAL - CR 21207
	  Trigger has been modified to validate the ZIP code,state,
	  and country fields associated with a customer's employer
								 
	----------------------------------------------------------------------
	*/
	
	// Validate postal/zip code
	do ZIP^PROCZIP(cif.empcntry,cif.empstate,cif.empzip) if $G(ER) do Runtime.setErrMSG("CIF",3333,RM) quit:ER
	
	// Validate state
	if cif.empstate'="",$$CHKSTATE^ADDRUTL("CIF",cif.empcntry,cif.empstate) quit:ER
	quit

vau12 // Trigger AU_INTYPE - Institution Type

	type public RecordCIF cif
	/*
	---- Revision History -------------------------------------------------------
	
	 02/05/99 - KONGJ - 30071
	       Changed table name from CIFTYP to PRODCTL for INTYPRST.
	


	*/
	new INTYPRST,VCNT,DATA,CID,ATYPE,CIFTYPE
	
	// If CIF.INTYPE is null, do nothing; else check for Institution Type Restriction.
	
	if cif.intype'="" do { quit:ER 
		set CIFTYPE=cif.type
		set INTYPRST=Db.getOneRow("INTYPRST","PRODCTL","CIFTYPE")

		// If INTYPRST is set to Yes, check the user table UTBLINTTBL for a valid
		// combination for every account tied to this CIF.
	
		if INTYPRST do { quit:ER 
			new rs 
			type ResultSet rs=Db.select("CID,TYPE","ACN","ACN=:ACN")
			if rs.isEmpty() quit
			while rs.next()  do { 
				set CID=rs.getCol(1)
				set ATYPE=rs.getCol(2)
				if Db.isDefined("UTBLINTTBL","CIFTYPE,cif.intype,ATYPE") quit 
				do Runtime.setErrXBAD("CIF","INTYPRST") quit:ER 
				}
			}
		}
	quit

vau13 // Trigger AU_MT900THR - After Update MT900 Debit Threshold Trgr

	type public RecordCIF cif
	// Check to ensure that MT900 Debit Threshold is defined if Generate MT900="Y"
	
	if (cif.mt900=1)&(cif.mt900thr="") do Runtime.setErrMSG("CIF",4077) quit:ER
	quit

vau14 // Trigger AU_MT910THR - After Update MT910 Credit Threshold Trgr

	type public RecordCIF cif
	// Check to ensure that MT910 Credit Threshold is defined if Generate MT910="Y"
	
	if (cif.mt910=1)&(cif.mt910thr="") do Runtime.setErrMSG("CIF",4078) quit:ER
	quit

vau15 // Trigger AU_MZIP - After Update of ZIP Code

	type public RecordCIF cif

	/*
	--Revision History-----------------------------------------------------------

	08/21/06 - KumarSS - 22169
		   Initial Revision.
		   This trigger validates ZIP code column associated with 
		   customer's mailing address.
	-----------------------------------------------------------------------------
	*/

	type public Boolean ER
	type public String RM

	do ZIP^PROCZIP(cif.mcntry, cif.mstate, cif.mzip)
	if ER.get() do Runtime.setErrMSG("CIF", 3333, RM)

	quit

vau16 // Trigger AU_NR - After Update Non-Residency flag

	type public RecordCIF cif
	/*
	---------- Revision History ------------------------------------------
	
	 08/04/99 - HAYMANP - 34326
	            This code was moved from before update to after update.
	
	*/

	
	if %RESPROC do CUST^ALLWACCT(cif.acn)
	quit
	

vau17 // Trigger AU_PLAN - After Update Limit Plan

	type public RecordCIF cif
	/*
	 ---------- Revision History ------------------------------------------
		      
	    08/9/07 - VanithaK - CR28441
	     	      Added trigger to delete all entries in CIFGRPLIM when 
	     	      limit plan is modified.
		
	*/
	do Db.delete("CIFGRPLIM","ACN=:cif.acn")
	quit

vau18 // Trigger AU_PZIP - After Update of ZIP Code

	type public RecordCIF cif

	/*
	--Revision History-----------------------------------------------------------

	08/21/06 - KumarSS - 22169
		   Initial Revision.
		   This trigger validates ZIP code column associated with customer's
		   legal address.
	-----------------------------------------------------------------------------
	*/

	type public Boolean ER
	type public String RM

	do ZIP^PROCZIP(cif.pcntry, cif.pstate, cif.pzip)
	if ER.get() do Runtime.setErrMSG("CIF", 3333, RM)

	quit

vau19 // Trigger AU_SCHRV - After Update of Next/Last Credit Review

	type public RecordCIF cif
	/*
	---- Revision History ------------------------------------------------	
	
	06/05/06 - GIRIDHAL - CR 21207 
	Validate Credit Review Next Date and Last Date. 

	----------------------------------------------------------------------
	*/
	
	if 'cif.crerefre.isNull() do {
		//Enter a date after the current system date
		if cif.schrvnd < %SystemDate do Runtime.setErrMSG("CIF",914) quit:ER
		//Date must be the same as or before the system date
		if cif.schrvld > %SystemDate do Runtime.setErrMSG("CIF",753) quit:ER
	}
	
	quit

vau20 // Trigger AU_SEMFIN - AFTER UPDATE End of Study

	type public RecordCIF cif
							/*
								--Revision History-----------------------------------------------------^
	
									12/14/05 - PUTTASWH - 18157
		    Modified to change the code to DBI Standards.
		    
									03/29/00 - SIVCHUKA - 37587 
																					Optimized performance by passing a parameter to SCADAT
																				calls, reference LRQ 58163-03
							*/  

	if cif.semfin="" quit 
	if cif.semfin'="",cif.semfin'=$$EOMJD^SCADAT(cif.semfin,1) do Runtime.setErrMSG("CIF",2848) quit:ER 
	new AKEY,BATCH,BUFF,CID,DATE,DEFAL,IDPF,IGRC,MDT,PTF,SEMFIN,SEQ,SRC,TABLE,TYPE,XACN
	
	set XACN=cif.acn
	type ResultSet rs=Db.select("CID","RELCIF","ACN=:XACN")
	while rs.next()  do {
		
		set CID=rs.getCol(1)		
		type ResultSet rs=Db.select("IGRC,PTF,DEFAL,IDPF,TYPE","LN,PRODCTL","PRODCTL.DEFAL=1 AND LN.IDPF=1 and LN.CID=:CID AND PRODCTL.TYPE=LN.TYPE")		
		while rs.next()  do { 
			
			set IGRC=rs.getCol(1)
			set PTF=rs.getCol(2)
			set DEFAL=rs.getCol(5)
			set IDPF=rs.getCol(5)
			set XTYPE=rs.getCol(5)
			
			type RecordUTBLSEMFIN utblsem=Db.getRecord("UTBLSEMFIN","TYPE=:XTYPE",1)						
			if utblsem.term set XMDT=$$EXT^UMDT(utblsem.term,cif.semfin)
			else  set XMDT=cif.semfin
			
			set ER=0 
			type RecordLN ln=Db.getRecord("LN","CID=:CID",1)
			set ln.mdt=XMDT
			do ln.save()
			quit:ER	
			
			type ResultSet rs=Db.select("SRC,ACN,BATCH","PAT","CID=:CID")			
			while rs.next()  do { 
				new ACN
				set (ACN,SRC,BATCH,SEQ)=""
				set SRC=rs.getCol(1)
				set ACN=rs.getCol(2)
				set BATCH=rs.getCol(3)
				if IGRC set XSTOP=$$EXT^UMDT(IGRC,cif.semfin)+10
				else  set XSTOP=cif.semfin+10
				set ER=0 
				type RecordPAT1 pat1=Db.getRecord("PAT1","SRC=:SRC,ACN=:ACN,BATCH=:BATCH",1)
				set pat1.stop=XSTOP
				do pat1.save()
				
				}


			// PTF Update
			if cif.semfin.oldVal do { quit:ER 
				set (BUFF,DATE,SQL)=""
				if IGRC set DATE=$$EOMJD^SCADAT(($$EXT^UMDT(IGRC,cif.semfin.oldVal,"","N")),1) quit:ER 
				else  set DATE=$$EOMJD^SCADAT(cif.semfin.oldVal) quit:ER 
				set AKEY=CID
				set SQL="UPDATE LN SET PTF=1 WHERE CID="_CID         // Set PTF back to 1
				set TABLE="LN" set SEQ=1	
				
				type ResultSet rs=Db.select("BUFF","EFD","EFDATE=:DATE","BUFF DESC") 
				if rs.isEmpty() set BUFF=""
	    			else  set BUFF=rs.next(),BUFF=rs.getCol(1) 
				set BUFF=BUFF+1
				
				type RecordEFD efd=Db.getRecord("EFD","EFDATE=:DATE,BUFF=:BUFF,SEQ=:SEQ",1)
				set efd.akey=AKEY
				set efd.table=TABLE
				set efd.sql=SQL
				do efd.save()
				quit:ER 
				
				}
			if cif.semfin do { quit:ER 
				set (BUFF,DATE,SQL)=""
				if IGRC set DATE=$$EOMJD^SCADAT(($$EXT^UMDT(IGRC,cif.semfin,"","N")),1) quit:ER 
				else  set DATE=$$EOMJD^SCADAT(cif.semfin,1) quit:ER 
				set AKEY=CID
				set SQL="UPDATE LN SET PTF=0 WHERE CID="_CID         // Set PTF to O
				set TABLE="LN" set SEQ=1	
	 			
	    			type ResultSet rs=Db.select("BUFF","EFD","EFDATE=:DATE","BUFF DESC") 
				if rs.isEmpty() set BUFF=""
	    			else  set BUFF=rs.next(),BUFF=rs.getCol(1) 
				set BUFF=BUFF+1
				set ER=0 
				
				type RecordEFD efd=Db.getRecord("EFD","EFDATE=:DATE,BUFF=:BUFF,SEQ=:SEQ",1)
				set efd.akey=AKEY
				set efd.table=TABLE
				set efd.sql=SQL
				do efd.save()
				quit:ER 
				
				}
			}
		}
	quit 

vau21 // Trigger AU_STMTRV - After Update of Next/Last Stmt Review Dt

	type public RecordCIF cif
	/*
	---- Revision History ------------------------------------------------	
	
	06/05/06 - GIRIDHAL - CR 21207
	Validate statement review next date and last date.
								 
	----------------------------------------------------------------------
	*/

	if 'cif.finstfre.isNull() do {
		//Enter a date after the current system date
		if cif.stmtrvnd < %SystemDate do Runtime.setErrMSG("CIF",914) quit:ER
		//Date must be the same as or before the system date
		if cif.stmtrvld > %SystemDate do Runtime.setErrMSG("CIF",753) quit:ER
	}
	quit

vbd1 // Trigger BEFORE_DELETE - Before Delete

	type public RecordCIF cif
	// Allow to delete?
	
	if cif.nopurge do Runtime.setErrMSG("CIF",445) quit:ER 
	
	set par("CASDEL")=1                    // In cascade delete mode
	quit
	

vbi1 // Trigger BEFORE_INSERT - Before INSERT new record

	type public RecordCIF cif

	/*
	 Revision History----------------------------------------------------
	06/01/06 - GIRIDHAL - CR 21207
		   Added new code to default date values for the credit review
		   next date/last date fields
		   
	12/07/05 - KELLYP - CR 17423
		   Modified to remove references to the TFSBANK, TFSCIFID, 
		   and TFSHOEXT columns which are being obsoleted.  Also
		   removed pre-2003 revision history and cleaned up.
	
	06/14/04 - SCHWARTZC - CR10219
		   Moved code to default the product level relationship
		   matrix (CIF.RELMAT)from the AFTER_INSERT_UPDATE
		   trigger.  This prevents the need to call the CIF filer 
		   from the trigger which was causing a "Record already
		   exists" error when creating customers.
	*/
	
	// US Residency Status
	if cif.usrestat=1 set cif.nr=1
	
	// If the UTBLBRCD.INACTV (inactive flag) is Y no accounts can be opened
	// under this branch.
	do { quit:ER 
		new XBRCD,INACTV,XTYPE,A
		set XBRCD=cif.boo
		set XTYPE=cif.type
		set INACTV=Db.getOneRow("INACTV","UTBLBRCD","XBRCD") quit:ER 
		if INACTV=1 do Runtime.setErrMSG("CIF",3830,XBRCD) quit:ER 
		if Db.isDefined("UTBLPRODAUTH","XBRCD,XTYPE") do Runtime.setErrMSG("CIF",4358,"XTYPE~XBRCD") quit:ER  //MJ 09/08/00
		}
	
	// Customer Full Name default
	if 'cif.pers,cif.nam="" do {
		if cif.fname'="" set cif.fname=$$TRIM^%ZS(cif.fname)
		if cif.mname'="" set cif.mname=$$TRIM^%ZS(cif.mname)
		if cif.lnm'="" set cif.lnm=$$TRIM^%ZS(cif.lnm)
		if cif.suffix'="" set cif.suffix=$$TRIM^%ZS(cif.suffix)
		set cif.nam=$$NAM^CIFFUNCS(cif.fname,cif.mname,cif.lnm,cif.suffix)
		}
	
	// Calulate alpha index name
	if 'cif.pers set cif.xname=$$XNAME^XALPHA(cif.nam,cif.lnm)
	else  set cif.xname=$$UPPER^%ZFUNC($E(cif.nam,1,35))
	
	// Cost center default
	if cif.boo'="",cif.cc="" do {
		type RecordUTBLBRCD ubrcd=Db.getRecord("UTBLBRCD","BRCD=:cif.boo")
		set cif.cc=ubrcd.ccdef
		}

 	// Check if SWIFT Address is defined, return error message if it's not
 	if cif.mt320=1 do {
		if cif.mt320a="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER
		if cif.mt320a="",cif.swiftadd'="" set cif.mt320a=cif.swiftadd 
 		}
 	if cif.mt900=1 do {
		if cif.mt900a="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER
        	if cif.mt900a="",cif.swiftadd'="" set cif.mt900a=cif.swiftadd
		}
 	if cif.mt910=1 do {
		if cif.mt910a="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER
        	if cif.mt910a="",cif.swiftadd'="" set cif.mt910a=cif.swiftadd
        	}
 	if cif.mt940=1 do { 
		if cif.mt940a="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER
        	if cif.mt940a="",cif.swiftadd'="" set cif.mt940a=cif.swiftadd
		}
 	if cif.mt942=1 do { 
		if cif.mt942a="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER
        	if cif.mt942a="",cif.swiftadd'="" set cif.mt942a=cif.swiftadd
		}
 	if cif.mt950=1 do { 
		if cif.mt950a="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER
        	if cif.mt950a="",cif.swiftadd'="" set cif.mt950a=cif.swiftadd
        	}
 	// Checking for CIF.MT942G1 AND CIF.MT942G2
 	if cif.mt942=1 do {
 		if cif.mt942g1'=""!cif.mt942g2'="" do Runtime.setErrMSG("CIF",4113) quit:ER
 		}
 		
 	// Checking for CIF.MT942G1
 	if cif.mt942g1="",cif.mt942g2'="" do Runtime.setErrMSG("CIF",4114) quit:ER
	
 	// Checking for values (greater or not)
 	if cif.mt942g2'="",cif.mt942g1>cif.mt942g2 do Runtime.setErrMSG("CIF",4121) quit:ER
	
 	if cif.mt942g1#900'=0 do Runtime.setErrMSG("CIF",4186) quit:ER
 	if cif.mt942g2#900'=0 do Runtime.setErrMSG("CIF",4186) quit:ER

	// Region Code validation through the branch of ownership
	if cif.brreg="" do {
		if cif.boo="" quit
		type ResultSet rs2=Db.select("REGION","UTBLREGIONS","KEY=:cif.boo")
		if rs2.next() set cif.brreg=rs2.getCol(1)
		}

	// Defaulting LCL and DCL from CUVAR
	if cif.dcl="" set cif.dcl=+CUVAR.dcl
	if cif.lcl="" set cif.lcl=+CUVAR.lcl
 	
	// Mailing address default
	if (cif.mad1'="")!(cif.mad2'="")!(cif.mad3'="")!(cif.mad4'="")
	else  do {
		set cif.mad1=cif.pad1
		set cif.mad2=cif.pad2
		set cif.mad3=cif.pad3
		set cif.mad4=cif.pad4
		set cif.mcity=cif.pcity
		set cif.mstate=cif.pstate
		set cif.mzip=cif.pzip
		set cif.mcntry=cif.pcntry
		}
	
	// Validate Tax Id
	if cif.taxid'="" do {  quit:ER
		new X,TYPE
		set TYPE=cif.type
		set X=cif.taxid
		do EXT^VERTIN(.cif)
		if X'=cif.taxid set cif.taxid=X
		}
	
	// Default Relationship Matrix value from product type level.
	type RecordPRODDFTC proddftc=Db.getRecord("PRODDFTC","TYPE=:cif.type")
	set cif.relmat=proddftc.relmat
	
	//Default values for credit review next date/last dates
	if 'cif.crerefre.isNull(),cif.schrvnd.isNull() do {  quit:ER
		set cif.schrvnd = %SystemDate.nextFreqDate(cif.crerefre) quit:ER
		set cif.schrvld = %SystemDate
		} 
	
	if 'cif.finstfre.isNull(),cif.stmtrvnd.isNull() do {  quit:ER
		set cif.stmtrvnd = %SystemDate.nextFreqDate(cif.finstfre) quit:ER
		set cif.stmtrvld = %SystemDate
		} 
	quit

vbu1 // Trigger BU_BOO - BEFORE UPDATE BRANCH CODE

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/* 
	--------------------Revision History-------------------------
	09/05/00 JavakovM Added logic to return an error message if the product type
	not authorized for a branch.
	*/
	// If the UTBLBRCD.INACTV (inactive flag) is Y no accounts can be opened
	// under this branch.
	do { quit:ER
	 new XBRCD,INACTV,XTYPE,A                
									set XBRCD=cif.boo
									set XTYPE=cif.type              
									set INACTV=Db.getOneRow("INACTV","UTBLBRCD","XBRCD") quit:ER
									if INACTV=1 do Runtime.setErrMSG("CIF",3830,XBRCD) quit:ER
									if Db.isDefined("UTBLPRODAUTH","XBRCD,XTYPE") do Runtime.setErrMSG("CIF",4358,"XTYPE~XBRCD") quit:ER  
	}
	quit

vbu2 // Trigger BU_CREREFRE - Before Update of Credit Review Frequency

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------	
	
	   06/02/06 - GIRIDHAL - CR 21207
	   Trigger created to set Credit Review Next Date.
								 
	----------------------------------------------------------------------
	*/
	
	 if 'cif.crerefre.isNull(),cif.schrvnd.isNull() do {  quit:ER
		set cif.schrvnd = %SystemDate.nextFreqDate(cif.crerefre) quit:ER
		set cif.schrvld = %SystemDate
	 	} 	
	 
	quit

vbu3 // Trigger BU_DOB - Date of birth before update validation

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	   ---- Revision History -------------------------------------------------------
	
	   12/01/05 - DHANALAKSHMI R - 16851
		      Modified by eliminating the usage of the index table XRSPPLID.
	*/

	if cif.dob'="" quit 
	new count,XACN
	set XACN=cif.acn
	
	new rs 
	type ResultSet rs=Db.select("RPASEQ","DEP","ACN=:XACN AND DEP.STAT<>4")
	if rs.isEmpty() set count=0
	else  set count=rs.next(),count=rs.getCol("RPASEQ")

	if count do Runtime.setErrXBAD("CIF","CIFDOB") quit:ER 
	quit
	

vbu4 // Trigger BU_DOD - Before update of Date of Death

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	----------Revision History--------------------------------------------

	4/18/05 - Hillanbrand - 13686
	          Added delete and insert to RFLGC since RFLGC is relational
	          to RFGLCCID. Modified entire trigger per PSL standards.
	
	11/02/01 - SHVACHKINAD - 47709
		   Replaced direct call to RFLGCCFL filer with Db.delete to
		   prevent host update error that happened because vobj was
		   not set with necessary data for keys in RFLGCCID table.

	12/28/99 - MAGERAM - 36114
		   Roll Forward for ARQ# 33138 - Problems with deceased customer
		   account inquiry.
		 
	-----------------------------------------------------------------------
	*/
	
	type String RFLG
	
	// Check that the restriction exists
	if CUVAR.DODRST.isNull() quit
	
	set RFLG=CUVAR.DODRST

	type RecordUTBLRFLG rflg=Db.getRecord("UTBLRFLG","""CIF"",RFLG",1)
	if rflg.getMode()=0 quit
		
	// Remove restrictions if DOD is removed.
	if cif.dod="" do {
		type ResultSet rs=Db.select("CID","RELCIF","ACN=:ACN")
		if rs.isEmpty() quit
		while rs.next()  do { 
			set CID=rs.getCol(1)
			do Db.delete("RFLGCCID","ACN=:ACN AND RFLG=:RFLG AND CID=:CID")
			}
		do Db.delete("RFLGC","ACN=:ACN AND RFLG=:RFLG")
		}
	
	// Place restrictions if DOD is set.
	if cif.dod'="" do {
		type RecordRFLGC rflgc=Db.getRecord("RFLGC",":ACN,RFLG",1)
		set rflgc.acn=ACN
		set rflgc.rflg=RFLG
		do rflgc.save()

		type ResultSet rs=Db.select("CID","RELCIF","ACN=:ACN")
		if rs.isEmpty() quit
		while rs.next()  do {
			set CID=rs.getCol(1)
                	type RecordRFLGCCID rflgccid=Db.getRecord("RFLGCCID",":ACN,RFLG,CID",1)
                	set rflgccid.acn=ACN
                	set rflgccid.rflg=RFLG
			set rflgccid.cid=CID
                	do rflgccid.save()
 			}
		}
	
	quit 

vbu5 // Trigger BU_DODSABL - Before Update of Date of Disability

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	----------Revision History--------------------------------------------
 	
	4/18/05 - Hillanbrand - 13686
		  Added delete and insert to RFLGC since RFLGC is relational
		  to RFGLCCID. Modified entire trigger per PSL standards.
	-----------------------------------------------------------------------
	*/
	
	type String RFLG
	
	// Check that the restriction exists
	if CUVAR.DISBRST.isNull() quit
	
	set RFLG=CUVAR.DISBRST

	type RecordUTBLRFLG rflg=Db.getRecord("UTBLRFLG","""CIF"",RFLG",1)
	if rflg.getMode()=0 quit
		
	// Remove restrictions if DODSABL is removed.
	if cif.dodsabl="" do {
		type ResultSet rs=Db.select("CID","RELCIF","ACN=:ACN")
		if rs.isEmpty() quit
		while rs.next()  do { 
			set CID=rs.getCol(1)
			do Db.delete("RFLGCCID","ACN=:ACN AND RFLG=:RFLG AND CID=:CID")
			}
		do Db.delete("RFLGC","ACN=:ACN AND RFLG=:RFLG")
		}
	
	// Place restrictions if DODSABL is set.
	if cif.dodsabl'="" do {
		type RecordRFLGC rflgc=Db.getRecord("RFLGC",":ACN,RFLG",1)
		set rflgc.acn=ACN
		set rflgc.rflg=RFLG
		do rflgc.save()

		type ResultSet rs=Db.select("CID","RELCIF","ACN=:ACN")
		if rs.isEmpty() quit
		while rs.next()  do {
			set CID=rs.getCol(1)
                	type RecordRFLGCCID rflgccid=Db.getRecord("RFLGCCID",":ACN,RFLG,CID",1)
                	set rflgccid.acn=ACN
                	set rflgccid.rflg=RFLG
			set rflgccid.cid=CID
                	do rflgccid.save()
 			}
		}
	
	quit 

vbu6 // Trigger BU_FINSTFRE - Before Update of Financial Stmt Freq

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------	
	
	06/05/06 - GIRIDHAL - CR 21207
	Trigger created to set Statement Review Next Date.
								 
	----------------------------------------------------------------------
	*/
	
	 if 'cif.finstfre.isNull(),cif.stmtrvnd.isNull() do {  quit:ER
		set cif.stmtrvnd = %SystemDate.nextFreqDate(cif.finstfre) quit:ER
		set cif.stmtrvld = %SystemDate
	 	} 
	quit

vbu7 // Trigger BU_MT320 - Before Update MT320 Trigger

	type public RecordCIF cif
	do cif.setAuditFlag(1)
 	/*	
	 10/05/00 - VETSENM - 42053
	     Roll forward for ARQ#34282
	*/
	//Check if SWIFT address is defined, if not then return error message
	if cif.mt320=1 do {
		if cif.mt320="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER 
		if cif.mt320="",cif.swiftadd'="" set cif.mt320a=cif.swiftadd
		}
 	quit

vbu8 // Trigger BU_MT900 - Before Update MT900 Trigger

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	 10/05/00 - VETSENM - 42053
		Roll forward for ARQ#42053
	*/
	 	           

		//Check if SWIFT address is defined, if not then return error message
	if cif.mt900=1 do {
		if cif.mt900a="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER 
		if cif.mt900a="",cif.swiftadd'="" set cif.mt900a=cif.swiftadd
		}
	quit

vbu9 // Trigger BU_MT910 - Before Update MT910 Trigger

	type public RecordCIF cif
	do cif.setAuditFlag(1)
						/*
									10/05/00 - VETSENM - 42053
																Roll forward for ARQ#42053
								*/
	
	
		//Check if SWIFT address is defined, if not then return error message
								if cif.mt910=1 do {
																if cif.mt910a="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER
																if cif.mt910a="",cif.swiftadd'="" set cif.mt910a=cif.swiftadd
																}
								quit

vbu10 // Trigger BU_MT940 - Before Update MT940 trigger

	type public RecordCIF cif
	do cif.setAuditFlag(1)
					/*
									10/05/00 - VETSENM - 42053
																Roll forward for ARQ#42053
								*/
	
	
		//Check if SWIFT address is defined, if not then return error message
								if cif.mt940=1 do {
																if cif.mt940a="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER
																if cif.mt940a="",cif.swiftadd'="" set cif.mt940a=cif.swiftadd
																}
								quit

vbu11 // Trigger BU_MT942TIME - Before Update MT942TIME trigger

	type public RecordCIF cif
	do cif.setAuditFlag(1)
 	/*
	---------------Revision History---------------------------------------

	09/19/05 - KELLYP - CR 17050
		   Modified to correct logic errors throughout trigger
		   and removed pre-2003 revision history.
 	*/

	type public Boolean ER

	if cif.mt942=1,cif.mt942a.isNull() do { quit:ER
		// SWIFT Address must be defined
		if cif.swiftadd.isNull() do Runtime.setErrMSG("CIF",4029) quit:ER
		else  set cif.mt942a=cif.swiftadd
		}

	// Generate MT942 must be set to "Yes"
	if cif.mt942=0,(('cif.mt942g1.isNull())!('cif.mt942g2.isNull())) do Runtime.setErrMSG("CIF",4113) quit:ER

	// A value must be entered in MT942 Generate Time 1
	if ('cif.mt942g2.isNull()),(cif.mt942g1.isNull()) do Runtime.setErrMSG("CIF",4114) quit:ER

	// Value must be greater than MT942 Generate Time 1
	if ('cif.mt942g2.isNull()),(cif.mt942g1>cif.mt942g2) do Runtime.setErrMSG("CIF",4121) quit:ER

	// Field must be defined in 15-minute increments only
	if '((cif.mt942g1#900)=0) do Runtime.setErrMSG("CIF",4186) quit:ER
								if '((cif.mt942g2#900)=0) do Runtime.setErrMSG("CIF",4186) quit:ER

	if 'cif.mt942g1.isNull() do {
		// Check all the accounts on the CIF
		type ResultSet rs=Db.select("CID","RELCIF","ACN=:cif.acn")
		while rs.next() do DCHEK(rs.getCol("CID"),cif.mt942g1,cif.mt942g2)
		}
	
	quit


DCHEK(Number CID,Time GTIME1,Time GTIME2)
	// Determine the next date and time to generate an MT942

	type Date TMPDT
	type Time TMPTM

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	if 'dep.getMode() quit	// Not a deposit account

	// MT942 generation not enabled for this account
	if 'dep.mt942 quit

	// Account-level MT942 generation time supercedes CIF level generation time
	if 'dep.mt942g1.isNull() set GTIME1=dep.mt942g1
	if 'dep.mt942g2.isNull() set GTIME2=dep.mt942g2

	// GTIME1 has not passed
	if GTIME1>%CurrentTime do {
		set TMPDT=%SystemDate
		set TMPTM=GTIME1
		}
		
	// GTIME1 has passed but GTIME2 hasn't
	else  if GTIME1<%CurrentTime,GTIME2>%CurrentTime do {
		set TMPDT=%SystemDate
		set TMPTM=GTIME2
		}
		
	// GTIME1 and GTIME2 have both passed
	else  if GTIME1<%CurrentTime,GTIME2<%CurrentTime do {
		set TMPDT=%SystemDate+1
		set TMPTM=GTIME1
		}

	if 'TMPDT.isBusDate(dep.nbdc) do {
		set TMPDT=TMPDT.nextBusDate(1,dep.nbdc)
		set TMPTM=GTIME1
		}
			
	// Create the SW942 record
	type RecordSW942 sw942=Class.new("RecordSW942","SWDATE=:TMPDT,SWTIME=:TMPTM,CID=:dep.cid")
	set sw942.status=0
	do sw942.save()

	quit

vbu12 // Trigger BU_MT950 - Before Update NT950 trigger

	type public RecordCIF cif
	do cif.setAuditFlag(1)
					/*
									10/05/00 - VETSENM - 42053
																Roll forward for ARQ#42053
								*/
	
	
		//Check if SWIFT address is defined, if not then return error message
								if cif.mt950=1 do {
																if cif.mt950a="",cif.swiftadd="" do Runtime.setErrMSG("CIF",4029) quit:ER
																if cif.mt950a="",cif.swiftadd'="" set cif.mt950a=cif.swiftadd
																}
								quit

vbu13 // Trigger BU_NAME - Full name or last name changed

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------
	
	 10/04/99 - SIGDAE - 33268
	            Add customer full name default logic to support structured
	            name.

	*/
	
	new new,old,default
	
	set default=0
	if (cif.fname.oldVal'=cif.fname) do {
		set default=1
		set old=cif.fname.oldVal
		set new=$$TRIM^%ZS(cif.fname)
		if cif.fname=new quit 
		set cif.fname=old
		set cif.fname=new
		}
	if (cif.mname.oldVal'=cif.mname) do {
		set default=1
		set old=cif.mname.oldVal
		set new=$$TRIM^%ZS(cif.mname)
		if cif.mname=new quit 
		set cif.mname=old
		set cif.mname=new
		}
	if (cif.lnm.oldVal'=cif.lnm) do {
		set default=1
		set old=cif.lnm.oldVal
		set new=$$TRIM^%ZS(cif.lnm)
		if cif.lnm=new quit 
		set cif.lnm=old
		set cif.lnm=new
		}
	if (cif.suffix.oldVal'=cif.suffix) do {
		set default=1
		set old=cif.suffix.oldVal
		set new=$$TRIM^%ZS(cif.suffix)
		if cif.suffix=new quit 
		set cif.suffix=old
		set cif.suffix=new
		}
	if (cif.nam.oldVal'=cif.nam) do {
		set default=0
		set old=cif.nam.oldVal
		set new=$$TRIM^%ZS(cif.nam)
		if cif.nam=new quit 
		set cif.nam=old
		set cif.nam=new
		}
	
	// Structured Name only changed
	if 'cif.pers,default do {
		// If old NAM was defaulted, default new NAM
		set old=$$NAM^CIFFUNCS(cif.fname.oldVal,cif.mname.oldVal,cif.lnm.oldVal,cif.suffix.oldVal)
		if old=cif.nam.oldVal set cif.nam=$$NAM^CIFFUNCS(cif.fname,cif.mname,cif.lnm,cif.suffix)
		}
	
	if 'cif.pers set new=$$XNAME^XALPHA(cif.nam,cif.lnm)   // Calculate new index name
	else  set new=$$UPPER^%ZFUNC($E(cif.nam,1,35))
	set cif.xname=new
	quit 

vbu14 // Trigger BU_PIN1CNTRT - Before Update PIN1CNTR

	type public RecordCIF cif
	do cif.setAuditFlag(1)

	/*
	---- Revision History --------------------------------------------------------
	
	12/12/05 - SPR - 18555
		   Card Management - General DBI3 system area cleanup.
		   
	------------------------------------------------------------------------------
	*/	
	
	type public Boolean ER
	type public Number ACN,NEXTSEQ
	type public String CARDNUM,CARDTYPE
	type Number AC,CARDUF
	type String DTTIME
		
	if cif.pin1cntr=1 do {
		set cif.pin1cntr=0
		quit:CUVAR.cmsacopt'=1
		set DTTIME=%SystemDate_" "_%CurrentTime
		
		type RecordCIF xcif=Db.getRecord("CIF","ACN=:ACN",1)
		if xcif.getMode() do { quit:ER
			set CARDUF=xcif.carduf
			}

		if CARDUF'=1 quit 
	
		if CARDNUM.get().isNull() do {
			type ResultSet rs=Db.select("CRDNUM","CRD","ACN=:ACN")
			if rs.next() set CARDNUM=rs.getCol("CRDNUM")
			else  set CARDNUM=""
			} 
	
		if CARDTYPE.get().isNull() do {
			type ResultSet rs=Db.select("CRDTYP","CRD","ACN=:ACN") 
			if rs.next() set CARDTYPE=rs.getCol("CRDTYP")
			else  set CARDTYPE="" 
			} 
	
		if NEXTSEQ.get().isNull() do { quit:ER
			type ResultSet rscmsact=Db.select("SEQ","CMSACT",,"SEQ DESC")
			if rscmsact.next() set NEXTSEQ=rscmsact.getCol("SEQ")+1
			else  set NEXTSEQ=1
			}
		set AC=15
		set ER=0 
		type RecordCMSACT cmsact1=Class.new("RecordCMSACT") 
		set cmsact1.seq=NEXTSEQ
		set cmsact1.crdtyp=CARDTYPE
		set cmsact1.crdnum=CARDNUM
		set cmsact1.acn=ACN
		set cmsact1.ac=AC
		set cmsact1.dttime=DTTIME
		do cmsact1.bypassSave()	
		}
			
	quit 

vbu15 // Trigger BU_PIN1DEL - Before Update PIN1DEL

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------------
	
	12/12/05 - SPR - 18555
		   Card Management - General DBI3 system area cleanup.
		   
	------------------------------------------------------------------------------	
	*/
	
	type public Boolean ER
	type public Number ACN,NEXTSEQ
	type public String CARDNUM,CARDTYPE
	type Number AC,CARDUF
	type String DTTIME
	
	if cif.pin1del=1 do {
		set cif.pin1stat=0
		quit:CUVAR.cmsacopt'=1 
		set DTTIME=%SystemDate_" "_%CurrentTime 
		
		type RecordCIF xcif=Db.getRecord("CIF","ACN=:ACN",1)
		if xcif.getMode() do { quit:ER
				set CARDUF=xcif.carduf
				}
				
		if CARDUF'=1 quit 
	
		if CARDNUM.get().isNull() do { 
			type ResultSet rs=Db.select("CRDNUM","CRD","ACN=:ACN") 
			if rs.next() set CARDNUM=rs.getCol("CRDNUM")
			else  set CARDNUM=""
			} 
	
		if CARDTYPE.get().isNull() do { 
			type ResultSet rs=Db.select("CRDTYP","CRD","ACN=:ACN") 
			if rs.next() set CARDTYPE=rs.getCol("CRDTYP")
			else  set CARDTYPE="" 
			} 
	
		if NEXTSEQ.get().isNull() do { quit:ER
			type ResultSet rscmsact=Db.select("SEQ","CMSACT",,"SEQ DESC")
			if rscmsact.next() set NEXTSEQ=rscmsact.getCol("SEQ")+1
			else  set NEXTSEQ=1
			}
		set AC=18
		set ER=0 
		type RecordCMSACT cmsact=Class.new("RecordCMSACT")
		set cmsact.seq=NEXTSEQ
		set cmsact.crdtyp=CARDTYPE
		set cmsact.crdnum=CARDNUM
		set cmsact.acn=ACN
		set cmsact.ac=AC
		set cmsact.dttime=DTTIME
		do cmsact.bypassSave()
		}
		
	quit 

vbu16 // Trigger BU_PIN1STAT - Before Update

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------------
	
	12/12/05 - SPR - 18555
		   Card Management - General DBI3 system area cleanup.
		   
	------------------------------------------------------------------------------

	*/
	type public Boolean ER
	type public Number ACN,NEXTSEQ
	type public String CARDNUM,CARDTYPE
	type Number AC,CARDUF
	type String DTTIME,ENCPIN1,PIN1TLO

	
	set DTTIME=%SystemDate_" "_%CurrentTime
	
	type RecordCIF cif1=Db.getRecord("CIF","ACN=:ACN",1)
	if cif1.getMode() do { quit:ER
		set CARDUF=cif1.carduf
		}
		
	if CARDUF'=1 quit 
	
	if CARDNUM.get().isNull() do { 
		type ResultSet rs=Db.select("CRDNUM","CRD","ACN=:ACN") 
		if rs.next() set CARDNUM=rs.getCol("CRDNUM")
		else  set CARDNUM=""
		} 
	
	if CARDTYPE.get().isNull() do { 
		type ResultSet rs=Db.select("CRDTYP","CRD","ACN=:ACN") 
		if rs.next() set CARDTYPE=rs.getCol("CRDTYP")
		else  set CARDTYPE="" 
		} 
	
	if cif.pin1gen=1,cif.pin1stat=3 do {
		if NEXTSEQ.get().isNull() do { quit:ER
			type ResultSet rscmsact=Db.select("SEQ","CMSACT",,"SEQ DESC")
			if rscmsact.next() set NEXTSEQ=rscmsact.getCol("SEQ")+1
			else  set NEXTSEQ=1
			}
			
		set cif.pin1gen=0
		quit:CUVAR.cmsacopt'=1 
		set AC=6
		
		type RecordCIF xcif=Db.getRecord("CIF","ACN=:ACN",1)
		if xcif.getMode() do { quit:ER
			set ENCPIN1=xcif.encpin1
			set PIN1TLO=xcif.pin1tlo
			}
			
		set ER=0 
		
		type RecordCMSACT cmsact=Db.getRecord("CMSACT","SEQ=:NEXTSEQ",1)
		if cmsact.getMode() quit
		
		type RecordCMSACT cmsact1=Class.new("RecordCMSACT")
		set cmsact1.seq=NEXTSEQ
		set cmsact1.crdtyp=CARDTYPE
		set cmsact1.crdnum=CARDNUM
		set cmsact1.acn=ACN
		set cmsact1.ac=AC
		set cmsact1.encpin=ENCPIN1
		set cmsact1.tlo=PIN1TLO
		set cmsact1.dttime=DTTIME
		do cmsact1.bypassSave()
		}
		
	if cif.pin1gen=2,cif.pin1stat=3 do {
		if NEXTSEQ.get().isNull() do { quit:ER
			type ResultSet rscmsact=Db.select("SEQ","CMSACT",,"SEQ DESC")
			if rscmsact.next() set NEXTSEQ=rscmsact.getCol("SEQ")+1
			else  set NEXTSEQ=1
			}
			
		set cif.pin1gen=0
		quit:CUVAR.cmsacopt'=1 
		set AC=7
		set ER=0 
		
		type RecordCMSACT cmsact=Db.getRecord("CMSACT","SEQ=:NEXTSEQ",1)
		if cmsact.getMode() quit
		
		type RecordCMSACT cmsact1=Class.new("RecordCMSACT")
		set cmsact1.seq=NEXTSEQ
		set cmsact1.crdtyp=CARDTYPE
		set cmsact1.crdnum=CARDNUM
		set cmsact1.acn=ACN
		set cmsact1.ac=AC
		set cmsact1.dttime=DTTIME
		do cmsact1.bypassSave()
		}
		
	quit 
	
	
	

vbu17 // Trigger BU_PIN2CNTRT - Before Update PIN2CNTR

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------------
	
	12/12/05 - SPR - 18555
		   Card Management - General DBI3 system area cleanup.
		   
	------------------------------------------------------------------------------

	*/
	
	type public Boolean ER
	type public Number ACN,NEXTSEQ
	type public String CARDNUM,CARDTYPE
	type Number AC,CARDUF
	type String DTTIME
	
	
	if cif.pin2cntr=1 do {
		set cif.pin2cntr=0
		quit:CUVAR.cmsacopt'=1  
		set DTTIME=%SystemDate_" "_%CurrentTime
		
		type RecordCIF xcif=Db.getRecord("CIF","ACN=:ACN",1)
		if xcif.getMode() do { quit:ER
			set CARDUF=xcif.carduf
			}
			
		if CARDUF'=1 quit 
	
		if CARDNUM.get().isNull() do { 
			type ResultSet rs=Db.select("CRDNUM","CRD","ACN=:ACN") 
			if rs.next() set CARDNUM=rs.getCol("CRDNUM")
			else  set CARDNUM=""
			} 
	
		if CARDTYPE.get().isNull() do { 
			type ResultSet rs=Db.select("CRDTYP","CRD","ACN=:ACN") 
			if rs.next() set CARDTYPE=rs.getCol("CRDTYP")
			else  set CARDTYPE="" 
			} 
	
		if NEXTSEQ.get().isNull() do { quit:ER
			type ResultSet rscmsact=Db.select("SEQ","CMSACT",,"SEQ DESC")
			if rscmsact.next() set NEXTSEQ=rscmsact.getCol("SEQ")+1
			else  set NEXTSEQ=1
			}
		set AC=16
		set ER=0 
		type RecordCMSACT cmsact=Class.new("RecordCMSACT")
		set cmsact.seq=NEXTSEQ
		set cmsact.crdtyp=CARDTYPE
		set cmsact.crdnum=CARDNUM
		set cmsact.acn=ACN
		set cmsact.ac=AC
		set cmsact.dttime=DTTIME
		do cmsact.bypassSave()
		}
		
	quit 

vbu18 // Trigger BU_PIN2DEL - Before Update PIN2DEL

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------------
	
	12/12/05 - SPR - 18555
		   Card Management - General DBI3 system area cleanup.
		   
	------------------------------------------------------------------------------
	
	*/
	
	type public Boolean ER
	type public Number ACN,NEXTSEQ
	type public String CARDNUM,CARDTYPE
	type Number AC,CARDUF
	type String DTTIME
	
	
	if cif.pin2del=1 do {
		set cif.pin2stat=0
		quit:CUVAR.cmsacopt'=1
		set DTTIME=%SystemDate_" "_%CurrentTime
		
		type RecordCIF xcif=Db.getRecord("CIF","ACN=:ACN",1)
		if xcif.getMode() do { quit:ER
			set CARDUF=xcif.carduf
			}
			
		if CARDUF'=1 quit 
	
		if CARDNUM.get().isNull() do { 
			type ResultSet rs=Db.select("CRDNUM","CRD","ACN=:ACN") 
			if rs.next() set CARDNUM=rs.getCol("CRDNUM")
			else  set CARDNUM=""
			} 
	
		if CARDTYPE.get().isNull() do { 
			type ResultSet rs=Db.select("CRDTYP","CRD","ACN=:ACN") 
			if rs.next() set CARDTYPE=rs.getCol("CRDTYP")
			else  set CARDTYPE="" 
			}
	
		if NEXTSEQ.get().isNull() do { quit:ER
			type ResultSet rscmsact=Db.select("SEQ","CMSACT",,"SEQ DESC")
			if rscmsact.next() set NEXTSEQ=rscmsact.getCol("SEQ")+1
			else  set NEXTSEQ=1
			}
			
		set AC=19
		set ER=0 
		type RecordCMSACT cmsact=Class.new("RecordCMSACT")
		set cmsact.seq=NEXTSEQ
		set cmsact.crdtyp=CARDTYPE
		set cmsact.crdnum=CARDNUM
		set cmsact.acn=ACN
		set cmsact.ac=AC
		set cmsact.dttime=DTTIME
		do cmsact.bypassSave()
		}
		
	quit 
	
	

vbu19 // Trigger BU_PIN2STAT - Before Update

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------------
	
	12/12/05 - SPR - 18555
		   Card Management - General DBI3 system area cleanup.
		   
	------------------------------------------------------------------------------
	
	*/
	
	type public Boolean ER
	type public Number ACN,NEXTSEQ
	type public String CARDNUM,CARDTYPE
	type Number AC,CARDUF
	type String DTTIME,ENCPIN2,PIN2TLO
	
	
	set DTTIME=%SystemDate_" "_%CurrentTime
	
	type RecordCIF cif1=Db.getRecord("CIF","ACN=:ACN",1)
	if cif1.getMode() do { quit:ER
		set CARDUF=cif1.carduf
		}
	
	if CARDUF'=1 quit 
	
	if CARDNUM.get().isNull() do { 
		type ResultSet rs=Db.select("CRDNUM","CRD","ACN=:ACN") 
		if rs.next() set CARDNUM=rs.getCol("CRDNUM")
		else  set CARDNUM=""
		} 
	
	if CARDTYPE.get().isNull() do { 
		type ResultSet rs=Db.select("CRDTYP","CRD","ACN=:ACN") 
		if rs.next() set CARDTYPE=rs.getCol("CRDTYP")
		else  set CARDTYPE="" 
		} 
	
	if cif.pin2gen=1,cif.pin2stat=3 do {
		if NEXTSEQ.get().isNull() do { quit:ER
			type ResultSet rscmsact=Db.select("SEQ","CMSACT",,"SEQ DESC")
			if rscmsact.next() set NEXTSEQ=rscmsact.getCol("SEQ")+1
			else  set NEXTSEQ=1
			}
		set cif.pin2gen=0
		quit:CUVAR.cmsacopt'=1
		
		set AC=8
		
		type RecordCIF xcif=Db.getRecord("CIF","ACN=:ACN",1)
		if xcif.getMode() do { quit:ER
			set ENCPIN2=xcif.encpin2
			set PIN2TLO=xcif.pin2tlo
			}
			
		set ER=0 
		
																type RecordCMSACT cmsact=Db.getRecord("CMSACT","SEQ=:NEXTSEQ",1)
		if cmsact.getMode() quit
		
		type RecordCMSACT cmsact1=Class.new("RecordCMSACT")
		set cmsact1.seq=NEXTSEQ
		set cmsact1.crdtyp=CARDTYPE
		set cmsact1.crdnum=CARDNUM
		set cmsact1.acn=ACN
		set cmsact1.ac=AC
		set cmsact1.encpin=ENCPIN2
		set cmsact1.tlo=PIN2TLO
		set cmsact1.dttime=DTTIME
		do cmsact1.bypassSave()
		}
		
	if cif.pin2gen=2,cif.pin2stat=3 do {
		if NEXTSEQ.get().isNull() do { quit:ER
			type ResultSet rscmsact=Db.select("SEQ","CMSACT",,"SEQ DESC")
			if rscmsact.next() set NEXTSEQ=rscmsact.getCol("SEQ")+1
			else  set NEXTSEQ=1
			}
			
		set cif.pin2gen=0
		quit:CUVAR.cmsacopt'=1
		set AC=9
		set ER=0 
	      
	        type RecordCMSACT cmsact=Db.getRecord("CMSACT","SEQ=:NEXTSEQ",1)
		if cmsact.getMode() quit
		
		type RecordCMSACT cmsact1=Class.new("RecordCMSACT")
		set cmsact1.seq=NEXTSEQ
		set cmsact1.crdtyp=CARDTYPE
		set cmsact1.crdnum=CARDNUM
		set cmsact1.acn=ACN
		set cmsact1.ac=AC
		set cmsact1.dttime=DTTIME
		do cmsact1.bypassSave()
		}
		
	quit 
	
	

vbu20 // Trigger BU_STAT - Before Update of Customer Status

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------	
	
	06/05/06 - GIRIDHAL - CR 21207
	This trigger sets the Customer Status Change Date when 
	the customer status is modified.
								 
	----------------------------------------------------------------------
	*/
	type public Boolean ER

	// Future-dated request invalid
	if cif.custchdt > %SystemDate do Runtime.setErrMSG("CIF",1152) quit:ER

	if cif.custchdt.oldVal = cif.custchdt set cif.custchdt = %SystemDate
	quit

vbu21 // Trigger BU_TAXID - Verify TAXID before update.

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	new X,TYPE
	set TYPE=cif.type
	set X=cif.taxid
	do EXT^VERTIN(.cif)
	if X'=cif.taxid set cif.taxid=X
	quit 

vbu22 // Trigger BU_USRESTAT - Before Update U. S. Residency Status

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---------- Revision History ------------------------------------------
	
	01/12/01 - Terrie Dougherty - 42579
		   Modified to check on new CUVAR.USRESTAT column before
																			processing call to RELAT^USRESTAT.

	08/18/99 - HAYMANP - 33049
		   Added call to CUST^USRESTAT.
	
	*/
	
	if cif.usrestat=1 set cif.nr=1
	else  set cif.nr=0
	
	// Update U. S. Residency Status on all accounts linked to this customer

	if Db.getOneRow("USRESTAT","CUVAR") do CUST^USRESTAT(ACN,cif.usrestat) quit:ER 

	quit

vbu23 // Trigger BU_XNAME - Index name XNAME changed

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	if (cif.nam.oldVal'=cif.nam) quit 
	if (cif.lnm.oldVal'=cif.lnm) quit 
	
	// Protect calculated field XNAME
	
	do Runtime.setErrMSG("CIF",412,"CIF.XNAME") quit:ER 
	quit 
	

vbu24 // Trigger BU_ZIPCODE - Before Update of Zip Code

	type public RecordCIF cif
	do cif.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------
	
	07/31/00 - HUNDERMARKD - 41048  (Retrofit of ARQ 40839)
		   Added the Before Update trigger for Zip Code - BU_ZIPCODE
	
	*/
	
	if (cif.pzip.oldVal'=cif.pzip) do {
		do ZIP^PROCZIP(cif.pcntry,cif.pstate,cif.pzip) if $G(ER) do Runtime.setErrMSG("CIF",3333,RM) quit:ER
		}
	if (cif.mzip.oldVal'=cif.mzip) do {
		do ZIP^PROCZIP(cif.mcntry,cif.mstate,cif.mzip) if $G(ER) do Runtime.setErrMSG("CIF",3333,RM) quit:ER
		}
	quit


vddver // Validate data dictionary attributes

	type public Number %O
	type public String vpar,vx()

	type String vRM,X
	type public RecordCIF cif

	if (%O = 2) do vload

	if vobj(cif,1).exists() do {

		if cif.nam.length()>40 set vRM = $$^MSG(1076,40) do vdderr("NAM", vRM) quit
		if cif.xname.length()>40 set vRM = $$^MSG(1076,40) do vdderr("XNAME", vRM) quit
	}

	if vobj(cif,2).exists() do {

		if cif.taxid.length()>20 set vRM = $$^MSG(1076,20) do vdderr("TAXID", vRM) quit
	}

	if vobj(cif,3).exists() do {

		if cif.fname.length()>17 set vRM = $$^MSG(1076,17) do vdderr("FNAME", vRM) quit
		if cif.lnm.length()>20 set vRM = $$^MSG(1076,20) do vdderr("LNM", vRM) quit
		if cif.mname.length()>17 set vRM = $$^MSG(1076,17) do vdderr("MNAME", vRM) quit
		if cif.pref.length()>5 set vRM = $$^MSG(1076,5) do vdderr("PREF", vRM) quit
		if cif.suffix.length()>8 set vRM = $$^MSG(1076,8) do vdderr("SUFFIX", vRM) quit
	}

	if vobj(cif,5).exists() do {

		if cif.mad1.length()>40 set vRM = $$^MSG(1076,40) do vdderr("MAD1", vRM) quit
		if cif.mad2.length()>40 set vRM = $$^MSG(1076,40) do vdderr("MAD2", vRM) quit
		if cif.mad3.length()>40 set vRM = $$^MSG(1076,40) do vdderr("MAD3", vRM) quit
		if cif.mad4.length()>40 set vRM = $$^MSG(1076,40) do vdderr("MAD4", vRM) quit
		if cif.mcity.length()>40 set vRM = $$^MSG(1076,40) do vdderr("MCITY", vRM) quit
		set X = cif.mcntry if 'X.isNull(),'Db.isDefined("STBLCNTRY","X") set vRM = $$^MSG(1485,X) do vdderr("MCNTRY", vRM) quit
		if cif.mloc.length()>40 set vRM = $$^MSG(1076,40) do vdderr("MLOC", vRM) quit
		if cif.mstate.length()>2 set vRM = $$^MSG(1076,2) do vdderr("MSTATE", vRM) quit
		if cif.mzip.length()>10 set vRM = $$^MSG(1076,10) do vdderr("MZIP", vRM) quit
	}

	if vobj(cif,6).exists() do {

		if cif.pad1.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PAD1", vRM) quit
		if cif.pad2.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PAD2", vRM) quit
		if cif.pad3.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PAD3", vRM) quit
		if cif.pad4.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PAD4", vRM) quit
		if cif.pcity.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PCITY", vRM) quit
		set X = cif.pcntry if 'X.isNull(),'Db.isDefined("STBLCNTRY","X") set vRM = $$^MSG(1485,X) do vdderr("PCNTRY", vRM) quit
		if cif.ploc.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PLOC", vRM) quit
		if cif.pstate.length()>2 set vRM = $$^MSG(1076,2) do vdderr("PSTATE", vRM) quit
		if cif.pzip.length()>10 set vRM = $$^MSG(1076,10) do vdderr("PZIP", vRM) quit
	}

	if vobj(cif,10).exists() do {

		if '("01"[cif.AGENT) set vRM=$$^MSG(742,"L") do vdderr("AGENT", vRM) quit
		if cif.brreg.length()>6 set vRM = $$^MSG(1076,6) do vdderr("BRREG", vRM) quit
		set X = cif.cifoff if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("CIFOFF", vRM) quit
		set X = cif.dep if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DEP", vRM) quit
		set X = cif.dob if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DOB", vRM) quit
		set X = cif.dod if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DOD", vRM) quit
		set X = cif.dodsabl if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DODSABL", vRM) quit
		set X = cif.educ if 'X.isNull(),'Db.isDefined("UTBLEDUC","X") set vRM = $$^MSG(1485,X) do vdderr("EDUC", vRM) quit
		set X = cif.emplno if 'X.isNull(),'Db.isDefined("UTBLEMPLOYER","X") set vRM = $$^MSG(1485,X) do vdderr("EMPLNO", vRM) quit
		set X = cif.extcif if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("EXTCIF", vRM) quit
		set X = cif.inc if 'X.isNull(),'Db.isDefined("UTBLIC","X") set vRM = $$^MSG(1485,X) do vdderr("INC", vRM) quit
		set X = cif.locale if 'X.isNull(),'Db.isDefined("UTBLLOCALE","X") set vRM = $$^MSG(1485,X) do vdderr("LOCALE", vRM) quit
		set X = cif.mar if 'X.isNull(),'Db.isDefined("UTBLMS","X") set vRM = $$^MSG(1485,X) do vdderr("MAR", vRM) quit
		set X = cif.occ if 'X.isNull(),'Db.isDefined("UTBLOC","X") set vRM = $$^MSG(1485,X) do vdderr("OCC", vRM) quit
		set X = cif.own if 'X.isNull(),'Db.isDefined("UTBLOWN","X") set vRM = $$^MSG(1485,X) do vdderr("OWN", vRM) quit
		set X = cif.sex if 'X.isNull(),'Db.isDefined("UTBLSEX","X") set vRM = $$^MSG(1485,X) do vdderr("SEX", vRM) quit
		set X = cif.shhld if 'X.isNull(),'Db.isDefined("UTBLSHHLD","X") set vRM = $$^MSG(1485,X) do vdderr("SHHLD", vRM) quit
		if cif.spouse.length()>40 set vRM = $$^MSG(1076,40) do vdderr("SPOUSE", vRM) quit
	}

	if vobj(cif,11).exists() do {

		set X = cif.as if 'X.isNull() set vRM = $$VAL^DBSVER("$",14,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.AS"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if cif.con.length()>30 set vRM = $$^MSG(1076,30) do vdderr("CON", vRM) quit
		set X = cif.cre if 'X.isNull() set vRM = $$VAL^DBSVER("$",14,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.CRE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if cif.fye.length()>4 set vRM = $$^MSG(1076,4) do vdderr("FYE", vRM) quit
		set X = cif.ne if 'X.isNull(),X'?1.5N,X'?1"-"1.4N set vRM=$$^MSG(742,"N") do vdderr("NE", vRM) quit
		set X = cif.nw if 'X.isNull() set vRM = $$VAL^DBSVER("$",14,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.NW"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = cif.pp1 if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("PP1", vRM) quit
		set X = cif.sic if 'X.isNull(),'Db.isDefined("UTBLSIC","X") set vRM = $$^MSG(1485,X) do vdderr("SIC", vRM) quit
		set X = cif.sicdsc if 'X.isNull(),'Db.isDefined("UTBLSIC","X") set vRM = $$^MSG(1485,X) do vdderr("SICDSC", vRM) quit
		set X = cif.ta if 'X.isNull() set vRM = $$VAL^DBSVER("$",14,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.TA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(cif,12).exists() do {

		if cif.aph.length()>12 set vRM = $$^MSG(1076,12) do vdderr("APH", vRM) quit
		if cif.bph.length()>12 set vRM = $$^MSG(1076,12) do vdderr("BPH", vRM) quit
		set X = cif.bphext if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("BPHEXT", vRM) quit
		if cif.email.length()>55 set vRM = $$^MSG(1076,55) do vdderr("EMAIL", vRM) quit
		if cif.hph.length()>12 set vRM = $$^MSG(1076,12) do vdderr("HPH", vRM) quit
		set X = cif.pin if 'X.isNull(),X'?1.10N,X'?1"-"1.9N set vRM=$$^MSG(742,"N") do vdderr("PIN", vRM) quit
		if cif.telex.length()>30 set vRM = $$^MSG(1076,30) do vdderr("TELEX", vRM) quit
	}

	if vobj(cif,13).exists() do {

		set X = cif.boo if 'X.isNull(),'Db.isDefined("UTBLBRCD","X") set vRM = $$^MSG(1485,X) do vdderr("BOO", vRM) quit
		if '("01"[cif.BWF) set vRM=$$^MSG(742,"L") do vdderr("BWF", vRM) quit
		set X = cif.cc if 'X.isNull(),'Db.isDefined("UTBLCCNTR","X") set vRM = $$^MSG(1485,X) do vdderr("CC", vRM) quit
		set X = cif.ccode if 'X.isNull(),'Db.isDefined("UTBLCC","X") set vRM = $$^MSG(1485,X) do vdderr("CCODE", vRM) quit
		if '("01"[cif.EXPFLG) set vRM=$$^MSG(742,"L") do vdderr("EXPFLG", vRM) quit
		set X = cif.intwcalc if 'X.isNull(),'Db.isDefined("UTBLWCALC","X") set vRM = $$^MSG(1485,X) do vdderr("INTWCALC", vRM) quit
		set X = cif.intwr if 'X.isNull(),'Db.isDefined("UTBLINTWR","X") set vRM = $$^MSG(1485,X) do vdderr("INTWR", vRM) quit
		set X = cif.lnsa if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("LNSA", vRM) quit
		set X = cif.mf if 'X.isNull(),'Db.isDefined("UTBLMF","X") set vRM = $$^MSG(1485,X) do vdderr("MF", vRM) quit
		if '("01"[cif.NR) set vRM=$$^MSG(742,"L") do vdderr("NR", vRM) quit
		set X = cif.priv if 'X.isNull(),'Db.isDefined("STBLCIFPRIV","X") set vRM = $$^MSG(1485,X) do vdderr("PRIV", vRM) quit
		set X = cif.revnotdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("REVNOTDT", vRM) quit
		if '("01"[cif.RFLGC) set vRM=$$^MSG(742,"L") do vdderr("RFLGC", vRM) quit
		set X = cif.sol if 'X.isNull(),'Db.isDefined("STBLCIFSOL","X") set vRM = $$^MSG(1485,X) do vdderr("SOL", vRM) quit
		if '("01"[cif.TAXEXM) set vRM=$$^MSG(742,"L") do vdderr("TAXEXM", vRM) quit
		set X = cif.w8date if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("W8DATE", vRM) quit
		if '("01"[cif.W8REQ) set vRM=$$^MSG(742,"L") do vdderr("W8REQ", vRM) quit
		set X = cif.w9stat if 'X.isNull(),'Db.isDefined("UTBLW9ST","X") set vRM = $$^MSG(1485,X) do vdderr("W9STAT", vRM) quit
	}

	if vobj(cif,14).exists() do {

		set X = cif.dao if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DAO", vRM) quit
		set X = cif.fmld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("FMLD", vRM) quit
		set X = cif.lfu if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LFU", vRM) quit
	}

	if vobj(cif,15).exists() do {

		set X = cif.atm if 'X.isNull(),'Db.isDefined("UTBLATM","X") set vRM = $$^MSG(1485,X) do vdderr("ATM", vRM) quit
		if cif.cen.length()>12 set vRM = $$^MSG(1076,12) do vdderr("CEN", vRM) quit
		if cif.convcif.length()>20 set vRM = $$^MSG(1076,20) do vdderr("CONVCIF", vRM) quit
		set X = cif.empcd if 'X.isNull(),'Db.isDefined("UTBLEMPCD","X") set vRM = $$^MSG(1485,X) do vdderr("EMPCD", vRM) quit
		set X = cif.intype if 'X.isNull(),'Db.isDefined("UTBLINTYPE","X") set vRM = $$^MSG(1485,X) do vdderr("INTYPE", vRM) quit
		set X = cif.lang if 'X.isNull(),'Db.isDefined("UTBLLAN","X") set vRM = $$^MSG(1485,X) do vdderr("LANG", vRM) quit
		if cif.legal.length()>2 set vRM = $$^MSG(1076,2) do vdderr("LEGAL", vRM) quit
		set X = cif.nation if 'X.isNull(),'Db.isDefined("STBLCNTRY","X") set vRM = $$^MSG(1485,X) do vdderr("NATION", vRM) quit
		if '("01"[cif.NOPURGE) set vRM=$$^MSG(742,"L") do vdderr("NOPURGE", vRM) quit
		if cif.pasnum.length()>20 set vRM = $$^MSG(1076,20) do vdderr("PASNUM", vRM) quit
		if cif.pid.length()>20 set vRM = $$^MSG(1076,20) do vdderr("PID", vRM) quit
		set X = cif.rescd if 'X.isNull(),'Db.isDefined("UTBLRESCD","X") set vRM = $$^MSG(1485,X) do vdderr("RESCD", vRM) quit
		if cif.rescntry.length()>2 set vRM = $$^MSG(1076,2) do vdderr("RESCNTRY", vRM) quit
		set X = cif.sbli if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.SBLI"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = cif.sdb if 'X.isNull(),'Db.isDefined("UTBLSDB","X") set vRM = $$^MSG(1485,X) do vdderr("SDB", vRM) quit
	}

	if vobj(cif,16).exists() do {

		set X = cif.aud1 if 'X.isNull(),'Db.isDefined("UTBLAUDIT","X") set vRM = $$^MSG(1485,X) do vdderr("AUD1", vRM) quit
		set X = cif.aud1cf if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[CIF]AUD1CF",0) if 'vRM.get().isNull() do vdderr("AUD1CF", vRM) quit
		set X = cif.aud1ld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("AUD1LD", vRM) quit
		set X = cif.aud1nd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("AUD1ND", vRM) quit
		set X = cif.aud2 if 'X.isNull(),'Db.isDefined("UTBLAUDIT","X") set vRM = $$^MSG(1485,X) do vdderr("AUD2", vRM) quit
		set X = cif.aud2cf if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[CIF]AUD2CF",0) if 'vRM.get().isNull() do vdderr("AUD2CF", vRM) quit
		set X = cif.aud2ld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("AUD2LD", vRM) quit
		set X = cif.aud2nd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("AUD2ND", vRM) quit
	}

	if vobj(cif,17).exists() do {

		set X = cif.dlv if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DLV", vRM) quit
		set X = cif.qaod if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("QAOD", vRM) quit
		set X = cif.shcid if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("SHCID", vRM) quit
		if '("01"[cif.VOTEXM) set vRM=$$^MSG(742,"L") do vdderr("VOTEXM", vRM) quit
	}

	if vobj(cif,18).exists() do {

		if '("01"[cif.AFINST) set vRM=$$^MSG(742,"L") do vdderr("AFINST", vRM) quit
		set X = cif.citzshp if 'X.isNull(),'Db.isDefined("STBLCNTRY","X") set vRM = $$^MSG(1485,X) do vdderr("CITZSHP", vRM) quit
		set X = cif.dcl if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.DCL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[cif.DDBIP) set vRM=$$^MSG(742,"L") do vdderr("DDBIP", vRM) quit
		set X = cif.dlexpdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DLEXPDT", vRM) quit
		set X = cif.dlisdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DLISDT", vRM) quit
		if cif.dlnum.length()>20 set vRM = $$^MSG(1076,20) do vdderr("DLNUM", vRM) quit
		if cif.dlstate.length()>2 set vRM = $$^MSG(1076,2) do vdderr("DLSTATE", vRM) quit
		if '("01"[cif.EDBI) set vRM=$$^MSG(742,"L") do vdderr("EDBI", vRM) quit
		set X = cif.efdtxbr if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("EFDTXBR", vRM) quit
		if cif.empcity.length()>20 set vRM = $$^MSG(1076,20) do vdderr("EMPCITY", vRM) quit
		if cif.empstate.length()>2 set vRM = $$^MSG(1076,2) do vdderr("EMPSTATE", vRM) quit
		set X = cif.lcl if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.LCL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = cif.mtamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.MTAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if cif.resd.length()>6 set vRM = $$^MSG(1076,6) do vdderr("RESD", vRM) quit
	}

	if vobj(cif,19).exists() do {

		if '("01"[cif.MARDM) set vRM=$$^MSG(742,"L") do vdderr("MARDM", vRM) quit
		if '("01"[cif.MAREM) set vRM=$$^MSG(742,"L") do vdderr("MAREM", vRM) quit
		if '("01"[cif.MARTEL) set vRM=$$^MSG(742,"L") do vdderr("MARTEL", vRM) quit
		set X = cif.usrestat if 'X.isNull(),'Db.isDefined("STBLUSRESTAT","X") set vRM = $$^MSG(1485,X) do vdderr("USRESTAT", vRM) quit
	}

	if vobj(cif,20).exists() do {

		if cif.atn.length()>50 set vRM = $$^MSG(1076,50) do vdderr("ATN", vRM) quit
	}

	if vobj(cif,50).exists() do {

		set X = cif.apps if 'X.isNull(),X'?1.10N,X'?1"-"1.9N set vRM=$$^MSG(742,"N") do vdderr("APPS", vRM) quit
		set X = cif.cls if 'X.isNull() set vRM = $$VAL^DBSVER("T",1,1,,,"*","*",0) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.CLS"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = cif.co if 'X.isNull(),'Db.isDefined("UTBLCO","X") set vRM = $$^MSG(1485,X) do vdderr("CO", vRM) quit
		set X = cif.crcd if 'X.isNull(),'Db.isDefined("UTBLCRCDX","X") set vRM = $$^MSG(1485,X) do vdderr("CRCD", vRM) quit
		set X = cif.grp if 'X.isNull(),'Db.isDefined("STBLGRP","CLS=""*"",GRP=:X") set vRM = $$^MSG(1485,X) do vdderr("GRP", vRM) quit
		set X = cif.pers if 'X.isNull(),'Db.isDefined("STBLPERS","X") set vRM = $$^MSG(1485,X) do vdderr("PERS", vRM) quit
		set X = cif.secgrp if 'X.isNull(),'Db.isDefined("UTBLSECGRP","X") set vRM = $$^MSG(1485,X) do vdderr("SECGRP", vRM) quit
		set X = cif.semfin if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SEMFIN", vRM) quit
		set X = cif.type if 'X.isNull(),X'?1.4N,X'?1"-"1.3N set vRM=$$^MSG(742,"N") do vdderr("TYPE", vRM) quit
	}

	if vobj(cif,51).exists() do {

		set X = cif.darcovr if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DARCOVR", vRM) quit
		set X = cif.depclovr if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("DEPCLOVR", vRM) quit
	}

	if vobj(cif,55).exists() do {

		set X = cif.how if 'X.isNull(),'Db.isDefined("UTBLHOW","X") set vRM = $$^MSG(1485,X) do vdderr("HOW", vRM) quit
		if cif.prad1.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PRAD1", vRM) quit
		if cif.prad2.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PRAD2", vRM) quit
		if cif.prad3.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PRAD3", vRM) quit
		if cif.prad4.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PRAD4", vRM) quit
		if cif.prcity.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PRCITY", vRM) quit
		set X = cif.prcntry if 'X.isNull(),'Db.isDefined("STBLCNTRY","X") set vRM = $$^MSG(1485,X) do vdderr("PRCNTRY", vRM) quit
		if cif.prstate.length()>2 set vRM = $$^MSG(1076,2) do vdderr("PRSTATE", vRM) quit
		if cif.przip.length()>10 set vRM = $$^MSG(1076,10) do vdderr("PRZIP", vRM) quit
	}

	if vobj(cif,66).exists() do {

		set X = cif.vosfreq if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[CIF]VOSFREQ",0) if 'vRM.get().isNull() do vdderr("VOSFREQ", vRM) quit
	}

	if vobj(cif,67).exists() do {

		if '("01"[cif.CMSFLG) set vRM=$$^MSG(742,"L") do vdderr("CMSFLG", vRM) quit
	}

	if vobj(cif,75).exists() do {

		set X = cif.cusamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.CUSAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = cif.cusdate if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CUSDATE", vRM) quit
		if '("01"[cif.GOVT) set vRM=$$^MSG(742,"L") do vdderr("GOVT", vRM) quit
		if cif.plan.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PLAN", vRM) quit
		set X = cif.pmaxbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.PMAXBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(cif,85).exists() do {

		if cif.altnam.length()>40 set vRM = $$^MSG(1076,40) do vdderr("ALTNAM", vRM) quit
		if '("01"[cif.HLDCOMIND) set vRM=$$^MSG(742,"L") do vdderr("HLDCOMIND", vRM) quit
		set X = cif.income if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.INCOME"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[cif.INTACTDET) set vRM=$$^MSG(742,"L") do vdderr("INTACTDET", vRM) quit
		set X = cif.mts if 'X.isNull(),'Db.isDefined("UTBLMTSO","X") set vRM = $$^MSG(1485,X) do vdderr("MTS", vRM) quit
		if '("01"[cif.POLEXPPER) set vRM=$$^MSG(742,"L") do vdderr("POLEXPPER", vRM) quit
		if '("01"[cif.PUBHLDIND) set vRM=$$^MSG(742,"L") do vdderr("PUBHLDIND", vRM) quit
		if cif.verdiscr.length()>40 set vRM = $$^MSG(1076,40) do vdderr("VERDISCR", vRM) quit
		set X = cif.verfdate if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("VERFDATE", vRM) quit
		if cif.vermthd.length()>40 set vRM = $$^MSG(1076,40) do vdderr("VERMTHD", vRM) quit
		if cif.verresol.length()>40 set vRM = $$^MSG(1076,40) do vdderr("VERRESOL", vRM) quit
	}

	if vobj(cif,90).exists() do {

		if cif.credline.length()>15 set vRM = $$^MSG(1076,15) do vdderr("CREDLINE", vRM) quit
		set X = cif.custgrp if 'X.isNull(),'Db.isDefined("UTBLCUSTGRP","X") set vRM = $$^MSG(1485,X) do vdderr("CUSTGRP", vRM) quit
		if cif.detnum.length()>1 set vRM = $$^MSG(1076,1) do vdderr("DETNUM", vRM) quit
		if cif.faxnum.length()>30 set vRM = $$^MSG(1076,30) do vdderr("FAXNUM", vRM) quit
		if '("01"[cif.INTERBANK) set vRM=$$^MSG(742,"L") do vdderr("INTERBANK", vRM) quit
		set X = cif.isdadt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ISDADT", vRM) quit
		set X = cif.locn if 'X.isNull(),'Db.isDefined("UTBLLOCN","X") set vRM = $$^MSG(1485,X) do vdderr("LOCN", vRM) quit
		set X = cif.statusdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("STATUSDT", vRM) quit
		set X = cif.swiftadd if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("SWIFTADD", vRM) quit
		set X = cif.swiftcon if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("SWIFTCON", vRM) quit
		if '("01"[cif.SWIFTSAK) set vRM=$$^MSG(742,"L") do vdderr("SWIFTSAK", vRM) quit
	}

	if vobj(cif,91).exists() do {

		if cif.encpin1.length()>200 set vRM = $$^MSG(1076,200) do vdderr("ENCPIN1", vRM) quit
		if '("01"[cif.PIN1CNTR) set vRM=$$^MSG(742,"L") do vdderr("PIN1CNTR", vRM) quit
		if '("01"[cif.PIN1DEL) set vRM=$$^MSG(742,"L") do vdderr("PIN1DEL", vRM) quit
		set X = cif.pin1gen if 'X.isNull(),'Db.isDefined("STBLCMSPGEN","X") set vRM = $$^MSG(1485,X) do vdderr("PIN1GEN", vRM) quit
		set X = cif.pin1stat if 'X.isNull(),'Db.isDefined("STBLCMSPSTAT","X") set vRM = $$^MSG(1485,X) do vdderr("PIN1STAT", vRM) quit
		if cif.pin1tlo.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PIN1TLO", vRM) quit
		if cif.pin1uid.length()>20 set vRM = $$^MSG(1076,20) do vdderr("PIN1UID", vRM) quit
	}

	if vobj(cif,92).exists() do {

		if cif.encpin2.length()>200 set vRM = $$^MSG(1076,200) do vdderr("ENCPIN2", vRM) quit
		if '("01"[cif.PIN2CNTR) set vRM=$$^MSG(742,"L") do vdderr("PIN2CNTR", vRM) quit
		if '("01"[cif.PIN2DEL) set vRM=$$^MSG(742,"L") do vdderr("PIN2DEL", vRM) quit
		set X = cif.pin2gen if 'X.isNull(),'Db.isDefined("STBLCMSPGEN","X") set vRM = $$^MSG(1485,X) do vdderr("PIN2GEN", vRM) quit
		set X = cif.pin2stat if 'X.isNull(),'Db.isDefined("STBLCMSPSTAT","X") set vRM = $$^MSG(1485,X) do vdderr("PIN2STAT", vRM) quit
		if cif.pin2tlo.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PIN2TLO", vRM) quit
		if cif.pin2uid.length()>20 set vRM = $$^MSG(1076,20) do vdderr("PIN2UID", vRM) quit
	}

	if vobj(cif,93).exists() do {

		set X = cif.incpdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("INCPDT", vRM) quit
		if cif.issr.length()>20 set vRM = $$^MSG(1076,20) do vdderr("ISSR", vRM) quit
		set X = cif.oed if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("OED", vRM) quit
		if cif.oin.length()>20 set vRM = $$^MSG(1076,20) do vdderr("OIN", vRM) quit
		set X = cif.oisdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("OISDT", vRM) quit
		set X = cif.oit if 'X.isNull(),'Db.isDefined("UTBLID","X") set vRM = $$^MSG(1485,X) do vdderr("OIT", vRM) quit
		set X = cif.pci if 'X.isNull(),'Db.isDefined("STBLCNTRY","X") set vRM = $$^MSG(1485,X) do vdderr("PCI", vRM) quit
		set X = cif.ped if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PED", vRM) quit
		set X = cif.pisdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PISDT", vRM) quit
	}

	if vobj(cif,94).exists() do {

		if cif.crdnam.length()>40 set vRM = $$^MSG(1076,40) do vdderr("CRDNAM", vRM) quit
		set X = cif.relcode if 'X.isNull(),'Db.isDefined("UTBLRELSTAT","X") set vRM = $$^MSG(1485,X) do vdderr("RELCODE", vRM) quit
		set X = cif.relcodovr if 'X.isNull(),'Db.isDefined("UTBLRELSTAT","X") set vRM = $$^MSG(1485,X) do vdderr("RELCODOVR", vRM) quit
		set X = cif.relmat if 'X.isNull(),'Db.isDefined("UTBLRELMAT","X") set vRM = $$^MSG(1485,X) do vdderr("RELMAT", vRM) quit
	}

	if vobj(cif,410).exists() do {

		set X = cif.nrcntry if 'X.isNull(),'Db.isDefined("STBLCNTRY","X") set vRM = $$^MSG(1485,X) do vdderr("NRCNTRY", vRM) quit
	}

	if vobj(cif,414).exists() do {

		set X = cif.adtlidt if 'X.isNull(),'Db.isDefined("UTBLADTLIDT","X") set vRM = $$^MSG(1485,X) do vdderr("ADTLIDT", vRM) quit
		set X = cif.adtlidtexpdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ADTLIDTEXPDT", vRM) quit
		if cif.adtlidtiss.length()>20 set vRM = $$^MSG(1076,20) do vdderr("ADTLIDTISS", vRM) quit
		set X = cif.adtlidtissdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("ADTLIDTISSDT", vRM) quit
		if cif.adtlidtn.length()>20 set vRM = $$^MSG(1076,20) do vdderr("ADTLIDTN", vRM) quit
	}

	if vobj(cif,420).exists() do {

		set X = cif.creapdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CREAPDT", vRM) quit
		set X = cif.crerefre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[CIF]CREREFRE",0) if 'vRM.get().isNull() do vdderr("CREREFRE", vRM) quit
		if cif.crertsc.length()>6 set vRM = $$^MSG(1076,6) do vdderr("CRERTSC", vRM) quit
		set X = cif.crrateld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CRRATELD", vRM) quit
		set X = cif.crratend if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CRRATEND", vRM) quit
		if cif.empad1.length()>40 set vRM = $$^MSG(1076,40) do vdderr("EMPAD1", vRM) quit
		if cif.empad2.length()>40 set vRM = $$^MSG(1076,40) do vdderr("EMPAD2", vRM) quit
		if cif.empad3.length()>40 set vRM = $$^MSG(1076,40) do vdderr("EMPAD3", vRM) quit
		set X = cif.empcntry if 'X.isNull(),'Db.isDefined("STBLCNTRY","X") set vRM = $$^MSG(1485,X) do vdderr("EMPCNTRY", vRM) quit
		if cif.empcnty.length()>40 set vRM = $$^MSG(1076,40) do vdderr("EMPCNTY", vRM) quit
		if cif.empname.length()>40 set vRM = $$^MSG(1076,40) do vdderr("EMPNAME", vRM) quit
		if cif.emptitle.length()>20 set vRM = $$^MSG(1076,20) do vdderr("EMPTITLE", vRM) quit
		if cif.empzip.length()>10 set vRM = $$^MSG(1076,10) do vdderr("EMPZIP", vRM) quit
		if cif.mcounty.length()>40 set vRM = $$^MSG(1076,40) do vdderr("MCOUNTY", vRM) quit
		set X = cif.mincome if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.MINCOME"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if cif.pcounty.length()>40 set vRM = $$^MSG(1076,40) do vdderr("PCOUNTY", vRM) quit
		set X = cif.schrvld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SCHRVLD", vRM) quit
		set X = cif.schrvnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SCHRVND", vRM) quit
		if '("01"[cif.SELFEMP) set vRM=$$^MSG(742,"L") do vdderr("SELFEMP", vRM) quit
	}

	if vobj(cif,422).exists() do {

		set X = cif.altoff if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("ALTOFF", vRM) quit
		set X = cif.custchdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CUSTCHDT", vRM) quit
		set X = cif.doodpror if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DOODPROR", vRM) quit
		set X = cif.finstfre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[CIF]FINSTFRE",0) if 'vRM.get().isNull() do vdderr("FINSTFRE", vRM) quit
		if '("01"[cif.FINSTREQ) set vRM=$$^MSG(742,"L") do vdderr("FINSTREQ", vRM) quit
		set X = cif.naics if 'X.isNull(),'Db.isDefined("UTBLNAICS","X") set vRM = $$^MSG(1485,X) do vdderr("NAICS", vRM) quit
		set X = cif.stat if 'X.isNull(),'Db.isDefined("UTBLSTATC","X") set vRM = $$^MSG(1485,X) do vdderr("STAT", vRM) quit
		set X = cif.stmtrvld if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("STMTRVLD", vRM) quit
		set X = cif.stmtrvnd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("STMTRVND", vRM) quit
		set X = cif.totliab if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.TOTLIAB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}

	if vobj(cif,424).exists() do {

		if '("01"[cif.CIFDATSB) set vRM=$$^MSG(742,"L") do vdderr("CIFDATSB", vRM) quit
		if '("01"[cif.IDSHARE) set vRM=$$^MSG(742,"L") do vdderr("IDSHARE", vRM) quit
		if '("01"[cif.IDTHEFT) set vRM=$$^MSG(742,"L") do vdderr("IDTHEFT", vRM) quit
	}

	if vobj(cif,426).exists() do {

		if cif.aph2.length()>12 set vRM = $$^MSG(1076,12) do vdderr("APH2", vRM) quit
		if cif.aph3.length()>12 set vRM = $$^MSG(1076,12) do vdderr("APH3", vRM) quit
		if cif.aph4.length()>12 set vRM = $$^MSG(1076,12) do vdderr("APH4", vRM) quit
		if cif.bemail.length()>55 set vRM = $$^MSG(1076,55) do vdderr("BEMAIL", vRM) quit
		if '("01"[cif.CRBRAUTH) set vRM=$$^MSG(742,"L") do vdderr("CRBRAUTH", vRM) quit
		set X = cif.dbnumber if 'X.isNull(),X'?1.10N,X'?1"-"1.9N set vRM=$$^MSG(742,"N") do vdderr("DBNUMBER", vRM) quit
		set X = cif.dwf if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DWF", vRM) quit
		if cif.empnum.length()>15 set vRM = $$^MSG(1076,15) do vdderr("EMPNUM", vRM) quit
		set X = cif.empverdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EMPVERDT", vRM) quit
		set X = cif.esign if 'X.isNull(),X'?1.20N,X'?1"-"1.19N set vRM=$$^MSG(742,"N") do vdderr("ESIGN", vRM) quit
		if cif.hfaxnum.length()>12 set vRM = $$^MSG(1076,12) do vdderr("HFAXNUM", vRM) quit
		if cif.legalnam.length()>80 set vRM = $$^MSG(1076,80) do vdderr("LEGALNAM", vRM) quit
		if cif.mmname.length()>20 set vRM = $$^MSG(1076,20) do vdderr("MMNAME", vRM) quit
	}

	if vobj(cif,430).exists() do {

		if cif.userid.length()>20 set vRM = $$^MSG(1076,20) do vdderr("USERID", vRM) quit
	}

	if vobj(cif,438).exists() do {

		if '("01"[cif.MT320) set vRM=$$^MSG(742,"L") do vdderr("MT320", vRM) quit
		if cif.mt320a.length()>11 set vRM = $$^MSG(1076,11) do vdderr("MT320A", vRM) quit
		if '("01"[cif.MT900) set vRM=$$^MSG(742,"L") do vdderr("MT900", vRM) quit
		if cif.mt900a.length()>11 set vRM = $$^MSG(1076,11) do vdderr("MT900A", vRM) quit
		set X = cif.mt900thr if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.MT900THR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[cif.MT910) set vRM=$$^MSG(742,"L") do vdderr("MT910", vRM) quit
		if cif.mt910a.length()>11 set vRM = $$^MSG(1076,11) do vdderr("MT910A", vRM) quit
		set X = cif.mt910thr if 'X.isNull() set vRM = $$VAL^DBSVER("$",18,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"CIF.MT910THR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[cif.MT940) set vRM=$$^MSG(742,"L") do vdderr("MT940", vRM) quit
		if cif.mt940a.length()>11 set vRM = $$^MSG(1076,11) do vdderr("MT940A", vRM) quit
		if '("01"[cif.MT942) set vRM=$$^MSG(742,"L") do vdderr("MT942", vRM) quit
		if cif.mt942a.length()>11 set vRM = $$^MSG(1076,11) do vdderr("MT942A", vRM) quit
		set X = cif.mt942crth if 'X.isNull(),X'?1.18N,X'?1"-"1.17N set vRM=$$^MSG(742,"N") do vdderr("MT942CRTH", vRM) quit
		set X = cif.mt942drth if 'X.isNull(),X'?1.18N,X'?1"-"1.17N set vRM=$$^MSG(742,"N") do vdderr("MT942DRTH", vRM) quit
		set X = cif.mt942g1 if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"C") do vdderr("MT942G1", vRM) quit
		set X = cif.mt942g2 if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"C") do vdderr("MT942G2", vRM) quit
		if '("01"[cif.MT950) set vRM=$$^MSG(742,"L") do vdderr("MT950", vRM) quit
		if cif.mt950a.length()>11 set vRM = $$^MSG(1076,11) do vdderr("MT950A", vRM) quit
		set X = cif.sw940freq if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[CIF]SW940FREQ",0) if 'vRM.get().isNull() do vdderr("SW940FREQ", vRM) quit
	}

	if vobj(cif,1000).exists() do {

		if cif.zpolexnam.length()>40 set vRM = $$^MSG(1076,40) do vdderr("ZPOLEXNAM", vRM) quit
		set X = cif.zpolexrel if 'X.isNull(),'Db.isDefined("ZUTBLPER","X") set vRM = $$^MSG(1485,X) do vdderr("ZPOLEXREL", vRM) quit
		if '("01"[cif.ZRELPOEXPER) set vRM=$$^MSG(742,"L") do vdderr("ZRELPOEXPER", vRM) quit
	}
	set X = cif.acn if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("ACN", vRM) quit
	quit

vdderr(di, vRM) // Column attribute error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("CIF","MSG",979,"CIF."_di_" "_vRM)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VJOURNAL(RecordCIF cif)	//CIF Journal file entries

	type Public Date %EffectiveDate
	type Public String %TSRC,vpar,vx()
	type String TSRC,vdi,vdx()

	if %TSRC.get().isNull() set TSRC="O"
	else  set TSRC=%TSRC

	if %ProcessMode=3 do {
		if TSRC="B" do {
			do vj1(.cif)	// Mode=D Tran=B EFD=N,E Seq=1 JRNID=CIFD_D
			}
		else  if TSRC="O" do {
			do vj1(.cif)	// Mode=D Tran=O EFD=N,E Seq=1 JRNID=CIFD_D
			}
		}
	else  if %ProcessMode=0 do {
		if TSRC="B" do {
			if 'EFD.get() do {
				do vj2(.cif)	// Mode=I Tran=B EFD=N Seq=1 JRNID=CIFH_I
				do vj5(.cif)	// Mode=I Tran=B EFD=N Seq=1 JRNID=DTJNA
				}
			}
		else  if TSRC="O" do {
			if 'EFD.get() do {
				do vj2(.cif)	// Mode=I Tran=O EFD=N Seq=1 JRNID=CIFH_I
				do vj5(.cif)	// Mode=I Tran=O EFD=N Seq=1 JRNID=DTJNA
				}
			}
		}
	else  if %ProcessMode=1 do {
		if TSRC="B" do {
			if EFD.get() do {
				do vj3(.cif)	// Mode=U Tran=B EFD=E Seq=1 JRNID=CIFH_U
				}
			else  do {
				do vj3(.cif)	// Mode=U Tran=B EFD=N Seq=1 JRNID=CIFH_U
				quit:'vx.data()
				for vdi="BOO","LNM","NAM","NATION","MAD1","MAD2","MAD3","MAD4" if vx(vdi).exists() do vj4(.cif,vdi) quit	// Mode=U Tran=B EFD=N Seq=1 JRNID=CMSRECACN
				for vdi="MAD1","MAD2","MAD3","MAD4" if vx(vdi).exists() do vj6(.cif,vdi) quit	// Mode=U Tran=B EFD=N Seq=1 JRNID=MADDR_UP
				for vdi="PAD1","PAD2","PAD3","PAD4" if vx(vdi).exists() do vj7(.cif,vdi) quit	// Mode=U Tran=B EFD=N Seq=1 JRNID=PADDR_UP
				if vx("PCNTRY").exists() do vj9(.cif,"PCNTRY")	// Mode=U Tran=B EFD=N Seq=1 JRNID=ZAMLCIFJNL
				}
			}
		else  if TSRC="O" do {
			if EFD.get() do {
				do vj3(.cif)	// Mode=U Tran=O EFD=E Seq=1 JRNID=CIFH_U
				}
			else  do {
				do vj3(.cif)	// Mode=U Tran=O EFD=N Seq=1 JRNID=CIFH_U
				quit:'vx.data()
				for vdi="BOO","LNM","NAM","NATION","MAD1","MAD2","MAD3","MAD4" if vx(vdi).exists() do vj4(.cif,vdi) quit	// Mode=U Tran=O EFD=N Seq=1 JRNID=CMSRECACN
				for vdi="MAD1","MAD2","MAD3","MAD4" if vx(vdi).exists() do vj6(.cif,vdi) quit	// Mode=U Tran=O EFD=N Seq=1 JRNID=MADDR_UP
				for vdi="PAD1","PAD2","PAD3","PAD4" if vx(vdi).exists() do vj7(.cif,vdi) quit	// Mode=U Tran=O EFD=N Seq=1 JRNID=PADDR_UP
				if vx("XNAME").exists() do vj8(.cif,"XNAME")	// Mode=U Tran=O EFD=N Seq=1 JRNID=XPRIOR
				if vx("PCNTRY").exists() do vj9(.cif,"PCNTRY")	// Mode=U Tran=O EFD=N Seq=1 JRNID=ZAMLCIFJNL
				}
			}
		}

	quit


vj1(RecordCIF cif)	// CIFD_D  Table CIFD  Daily transaction Journal

	type Public String EFD,%UID,TJD,TLO
	type String v1,v2,vlastkey
	set v1=TJD
	set v2=cif.acn
	set vlastkey=Db.nextVal("CIFD","TJD=:v1,ACN=:v2")
	type RecordCIFD cifd=Db.getRecord("CIFD","TJD=:v1,ACN=:v2,SEQ=:vlastkey",1)
	set cifd.efd=$G(EFD)
	set cifd.hdate=+$H
	set cifd.htime=$P($H,",",2)
	set cifd.tcmt=$$^MSG(704,cif.acn)
	set cifd.tlo=TLO
	set cifd.uid=%UID

	do cifd.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj2(RecordCIF cif)	// CIFH_I  Table CIFH  History file

	type Public String %IDENT,%UID,TJD,TLO
	type String v1,vlastkey
	set v1=cif.acn
	set vlastkey=Db.nextVal("CIFH","ACN=:v1")
	type RecordCIFH cifh=Db.getRecord("CIFH","ACN=:v1,SEQ=:vlastkey",1)
	set cifh.hdate=+$H
	set cifh.htime=$P($H,",",2)
	set cifh.ident=%IDENT
	set cifh.tcmt=$$^MSG(6793)
	set cifh.tjd=TJD
	set cifh.tlo=TLO
	set cifh.uid=%UID

	do cifh.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj3(RecordCIF cif)	// CIFH_U  Table CIFH  Maintenance History

	type Public String vx()
	type String vdi
	set vdi="" for  set vdi=vx(vdi).order() quit:vdi=""  if 'vx(vdi).piece("|",3) if vdi'="XNAME" do {
		type Public String vx(),EFD,%IDENT,%UID,TJD,TLO
		type String v1,vlastkey

		type String vold,vnew

		set vold=vx(vdi).piece("|",1)
		set vnew=vx(vdi).piece("|",2)

		set v1=cif.acn
		set vlastkey=Db.nextVal("CIFH","ACN=:v1")
		type RecordCIFH cifh=Db.getRecord("CIFH","ACN=:v1,SEQ=:vlastkey",1)
		set cifh.efd=$G(EFD)
		set cifh.hdate=+$H
		set cifh.htime=$P($H,",",2)
		set cifh.ident=%IDENT
		set cifh.tcmt=$$TCMTFM^CIFFUNCS(cif.acn,cif.cls,vdi,vold,vnew,$G(EFD))
		set cifh.tjd=TJD
		set cifh.tlo=TLO
		set cifh.uid=%UID

		do cifh.save("/NOVALFK/NOVALDD/NOVALRI")
		}

	quit


vj4(RecordCIF cif,String vdi)	// CMSRECACN  Table CMSRECACN  Adds CMSREC entry for mod. CIF record.

	if +cif.carduf=1
	else  quit

							//// Save this line for Public datatyping, if needed
	type String vlastkey
	set vlastkey=Db.nextVal("CMSRECACN","")
	type RecordCMSRECACN cmsrecacn=Db.getRecord("CMSRECACN","SEQ=:vlastkey",1)
	set cmsrecacn.acn=cif.acn
	set cmsrecacn.cmsflg=cif.cmsflg

	do cmsrecacn.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj5(RecordCIF cif)	// DTJNA  Table DTJNA  New CIF Account File

	type Public String TJD
	type String v1,v2,v3,v4,vlastkey
	set v1=TJD
	set v2="*"
	set v3="CIF"
	set v4=cif.type
	set vlastkey=cif.acn
	type RecordDTJNA dtjna=Db.getRecord("DTJNA","TJD=:v1,CLS=:v2,GRP=:v3,TYP=:v4,CID=:vlastkey",1)

	do dtjna.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj6(RecordCIF cif,String vdi)	// MADDR_UP  Table DTJADDRCHG  Mailing Address Update Journal

	if +cif.maddrflg'=1
	else  quit

	type Public String TJD
	type String v1,v2,vlastkey
	set v1=TJD
	set v2=cif.acn
	set vlastkey=5
	type RecordDTJADDRCHG dtjaddrchg=Db.getRecord("DTJADDRCHG","SJD=:v1,ACN=:v2,AKEY=:vlastkey",1)
	set dtjaddrchg.oad1=cif.mad1.oldVal
	set dtjaddrchg.oad2=cif.mad2.oldVal
	set dtjaddrchg.oad3=cif.mad3.oldVal
	set dtjaddrchg.oad4=cif.mad4.oldVal
	set dtjaddrchg.ocity=cif.mcity.oldVal
	set dtjaddrchg.ocntry=cif.mcntry.oldVal
	set dtjaddrchg.ostate=cif.mstate.oldVal
	set dtjaddrchg.ozip=cif.mzip.oldVal

	do dtjaddrchg.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj7(RecordCIF cif,String vdi)	// PADDR_UP  Table DTJADDRCHG  Legal Address Update Journal

	if +cif.paddrflg'=1
	else  quit

	type Public String TJD
	type String v1,v2,vlastkey
	set v1=TJD
	set v2=cif.acn
	set vlastkey=6
	type RecordDTJADDRCHG dtjaddrchg=Db.getRecord("DTJADDRCHG","SJD=:v1,ACN=:v2,AKEY=:vlastkey",1)
	set dtjaddrchg.oad1=cif.pad1.oldVal
	set dtjaddrchg.oad2=cif.pad2.oldVal
	set dtjaddrchg.oad3=cif.pad3.oldVal
	set dtjaddrchg.oad4=cif.pad4.oldVal
	set dtjaddrchg.ocity=cif.pcity.oldVal
	set dtjaddrchg.ocntry=cif.pcntry.oldVal
	set dtjaddrchg.ostate=cif.pstate.oldVal
	set dtjaddrchg.ozip=cif.pzip.oldVal

	do dtjaddrchg.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj8(RecordCIF cif,String vdi)	// XPRIOR  Table XPRIOR  Prior Name

							//// Save this line for Public datatyping, if needed
	type String v1,vlastkey
	set v1=cif.xname.oldVal
	set vlastkey=cif.acn
	type RecordXPRIOR xprior=Db.getRecord("XPRIOR","NAM=:v1,ACN=:vlastkey",1)

	do xprior.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj9(RecordCIF cif,String vdi)	// ZAMLCIFJNL  Table ZAMLJNL  Modified Columns for AML Reporting

	type Public String TJD
	type String v1,v2,vlastkey
	set v1=TJD
	set v2="CIF"
	set vlastkey=cif.acn
	type RecordZAMLJNL zamljnl=Db.getRecord("ZAMLJNL","ZTJD=:v1,TABTYPE=:v2,CID=:vlastkey",1)

	do zamljnl.save("/NOVALFK/NOVALDD/NOVALRI")

	quit



public VINDEX(RecordCIF cif) // Update index entries

		type Public String vx()

	if %ProcessMode=1 do { quit
		type String vf,vi,viMap,vxn
		set viMap=",AUD1ND,~1~|,AUD2ND,~2~|,PCNTRY,~3~|,CREREFRE,~4~|,EMPLNO,~5~|,FINSTFRE,~6~|,GOVT,~7~|,MCNTRY,MSTATE,MZIP,MCITY,MAD1,MAD2,~8~|,XNAME,~9~|,NR,~10~|,PCNTRY,PSTATE,PZIP,PCITY,PAD1,PAD2,~11~|,SIC,~12~|,TAXID,~13~|,TYPE,XNAME,~14~|,EXTCIF,~15~|,EMPNAME,~16~|,PCOUNTY,~17~|,SPOUSE,~18~|"
		set vf=0
		set vxn=""
		for  set vxn=vx(vxn).order() quit:vxn=""  do {
			for  set vf=$F(viMap,(","_vxn_","),vf) quit:vf=0  do {
				set vi=viMap.extract(vf,999).piece("~",2)
				set viMap.piece("|",vi)=""
				do @("vi"_vi_"(.cif)")
			}
		}
	}
	do vi1(.cif)
	do vi2(.cif)
	do vi3(.cif)
	do vi4(.cif)
	do vi5(.cif)
	do vi6(.cif)
	do vi7(.cif)
	do vi8(.cif)
	do vi9(.cif)
	do vi10(.cif)
	do vi11(.cif)
	do vi12(.cif)
	do vi13(.cif)
	do vi14(.cif)
	do vi15(.cif)
	do vi16(.cif)
	do vi17(.cif)
	do vi18(.cif)

	quit
	

vi1(RecordCIF cif) // Maintain AUD1ND index entries (Auditor #1 - Next Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = cif.aud1nd
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"AUDIT",v3)) do vidxerr("AUD1ND")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"AUDIT",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("AUD1ND").exists() set v1=vx("AUD1ND").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"AUDIT",v3)
	#ENDBYPASS
	quit

vi2(RecordCIF cif) // Maintain AUD2ND index entries (Auditor #2 - Next Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = cif.aud2nd
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"AUDIT",v3)) do vidxerr("AUD2ND")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"AUDIT",v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("AUD2ND").exists() set v1=vx("AUD2ND").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"AUDIT",v3)
	#ENDBYPASS
	quit

vi3(RecordCIF cif) // Maintain CIFCNTRY index entries (Sort by country)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.pcntry
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("XCNTRY",v2,v3)) do vidxerr("CIFCNTRY")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("XCNTRY",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("PCNTRY").exists() set v2=vx("PCNTRY").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("XCNTRY",v2,v3)
	#ENDBYPASS
	quit

vi4(RecordCIF cif) // Maintain CREREFRE index entries (Credit Review Frequency)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.crerefre
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("CREREFRE",v2,v3)) do vidxerr("CREREFRE")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("CREREFRE",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("CREREFRE").exists() set v2=vx("CREREFRE").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("CREREFRE",v2,v3)
	#ENDBYPASS
	quit

vi5(RecordCIF cif) // Maintain EMPLACN index entries (Employer/Employee Index)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.emplno
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("EMPLACN",v2,v3)) do vidxerr("EMPLACN")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("EMPLACN",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("EMPLNO").exists() set v2=vx("EMPLNO").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("EMPLACN",v2,v3)
	#ENDBYPASS
	quit

vi6(RecordCIF cif) // Maintain FINSTFRE index entries (Financial Statement Frequency)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.finstfre
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("FINSTFRE",v2,v3)) do vidxerr("FINSTFRE")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("FINSTFRE",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("FINSTFRE").exists() set v2=vx("FINSTFRE").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("FINSTFRE",v2,v3)
	#ENDBYPASS
	quit

vi7(RecordCIF cif) // Maintain GOVT index entries (Sovereign Risk)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = +cif.govt
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XCIF("GOVT",v2,v3)) do vidxerr("GOVT")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XCIF("GOVT",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("GOVT").exists() set v2=vx("GOVT").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XCIF("GOVT",v2,v3)
	#ENDBYPASS
	quit

vi8(RecordCIF cif) // Maintain MADDR index entries (Mailing Address Index)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.mcntry.upperCase()
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.mstate.upperCase()
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = cif.mzip.upperCase()
	if v4.isNull() set v4=(PSL.maxCharValue-1).char()
	type String v5 = cif.mcity.upperCase()
	if v5.isNull() set v5=(PSL.maxCharValue-1).char()
	type String v6 = cif.mad1.upperCase()
	if v6.isNull() set v6=(PSL.maxCharValue-1).char()
	type String v7 = cif.mad2.upperCase()
	if v7.isNull() set v7=(PSL.maxCharValue-1).char()
	type String v8 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XADDR("CIFM",v2,v3,v4,v5,v6,v7,v8)) do vidxerr("MADDR")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XADDR("CIFM",v2,v3,v4,v5,v6,v7,v8)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("MCNTRY").exists() set v2=vx("MCNTRY").piece("|",1).upperCase()  set:v2.isNull() v2=(PSL.maxCharValue-1).char() set:v2'=vx("MCNTRY").piece("|",2).upperCase() vdelete=1
	if vx("MSTATE").exists() set v3=vx("MSTATE").piece("|",1).upperCase()  set:v3.isNull() v3=(PSL.maxCharValue-1).char() set:v3'=vx("MSTATE").piece("|",2).upperCase() vdelete=1
	if vx("MZIP").exists() set v4=vx("MZIP").piece("|",1).upperCase()  set:v4.isNull() v4=(PSL.maxCharValue-1).char() set:v4'=vx("MZIP").piece("|",2).upperCase() vdelete=1
	if vx("MCITY").exists() set v5=vx("MCITY").piece("|",1).upperCase()  set:v5.isNull() v5=(PSL.maxCharValue-1).char() set:v5'=vx("MCITY").piece("|",2).upperCase() vdelete=1
	if vx("MAD1").exists() set v6=vx("MAD1").piece("|",1).upperCase()  set:v6.isNull() v6=(PSL.maxCharValue-1).char() set:v6'=vx("MAD1").piece("|",2).upperCase() vdelete=1
	if vx("MAD2").exists() set v7=vx("MAD2").piece("|",1).upperCase()  set:v7.isNull() v7=(PSL.maxCharValue-1).char() set:v7'=vx("MAD2").piece("|",2).upperCase() vdelete=1
	quit:'vdelete                                          // Only case has changed

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XADDR("CIFM",v2,v3,v4,v5,v6,v7,v8)
	#ENDBYPASS
	quit

vi9(RecordCIF cif) // Maintain NAME index entries (Name)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.xname
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XALPHA("A",v2,v3)) do vidxerr("NAME")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XALPHA("A",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("XNAME").exists() set v2=vx("XNAME").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XALPHA("A",v2,v3)
	#ENDBYPASS
	quit

vi10(RecordCIF cif) // Maintain NR index entries (NRes Alien Indicator)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = +cif.nr
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("NR",v2,v3)) do vidxerr("NR")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("NR",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("NR").exists() set v2=vx("NR").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("NR",v2,v3)
	#ENDBYPASS
	quit

vi11(RecordCIF cif) // Maintain PADDR index entries (Permanent Address Index)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.pcntry.upperCase()
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.pstate.upperCase()
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = cif.pzip.upperCase()
	if v4.isNull() set v4=(PSL.maxCharValue-1).char()
	type String v5 = cif.pcity.upperCase()
	if v5.isNull() set v5=(PSL.maxCharValue-1).char()
	type String v6 = cif.pad1.upperCase()
	if v6.isNull() set v6=(PSL.maxCharValue-1).char()
	type String v7 = cif.pad2.upperCase()
	if v7.isNull() set v7=(PSL.maxCharValue-1).char()
	type String v8 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XADDR("CIFL",v2,v3,v4,v5,v6,v7,v8)) do vidxerr("PADDR")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XADDR("CIFL",v2,v3,v4,v5,v6,v7,v8)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("PCNTRY").exists() set v2=vx("PCNTRY").piece("|",1).upperCase()  set:v2.isNull() v2=(PSL.maxCharValue-1).char() set:v2'=vx("PCNTRY").piece("|",2).upperCase() vdelete=1
	if vx("PSTATE").exists() set v3=vx("PSTATE").piece("|",1).upperCase()  set:v3.isNull() v3=(PSL.maxCharValue-1).char() set:v3'=vx("PSTATE").piece("|",2).upperCase() vdelete=1
	if vx("PZIP").exists() set v4=vx("PZIP").piece("|",1).upperCase()  set:v4.isNull() v4=(PSL.maxCharValue-1).char() set:v4'=vx("PZIP").piece("|",2).upperCase() vdelete=1
	if vx("PCITY").exists() set v5=vx("PCITY").piece("|",1).upperCase()  set:v5.isNull() v5=(PSL.maxCharValue-1).char() set:v5'=vx("PCITY").piece("|",2).upperCase() vdelete=1
	if vx("PAD1").exists() set v6=vx("PAD1").piece("|",1).upperCase()  set:v6.isNull() v6=(PSL.maxCharValue-1).char() set:v6'=vx("PAD1").piece("|",2).upperCase() vdelete=1
	if vx("PAD2").exists() set v7=vx("PAD2").piece("|",1).upperCase()  set:v7.isNull() v7=(PSL.maxCharValue-1).char() set:v7'=vx("PAD2").piece("|",2).upperCase() vdelete=1
	quit:'vdelete                                          // Only case has changed

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XADDR("CIFL",v2,v3,v4,v5,v6,v7,v8)
	#ENDBYPASS
	quit

vi12(RecordCIF cif) // Maintain SIC index entries (Standard Industry Code)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.sic
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("SIC",v2,v3)) do vidxerr("SIC")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("SIC",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("SIC").exists() set v2=vx("SIC").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("SIC",v2,v3)
	#ENDBYPASS
	quit

vi13(RecordCIF cif) // Maintain TAXID index entries (Tax ID Number)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.taxid
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XALPHA("T",v2,v3)) do vidxerr("TAXID")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XALPHA("T",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("TAXID").exists() set v2=vx("TAXID").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XALPHA("T",v2,v3)
	#ENDBYPASS
	quit

vi14(RecordCIF cif) // Maintain TYPXNAM index entries (Order by Type and Name)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.type
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.xname
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("TYPXNAM",v2,v3,v4)) do vidxerr("TYPXNAM")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("TYPXNAM",v2,v3,v4)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("TYPE").exists() set v2=vx("TYPE").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("XNAME").exists() set v3=vx("XNAME").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("TYPXNAM",v2,v3,v4)
	#ENDBYPASS
	quit

vi15(RecordCIF cif) // Maintain XEXTCIF index entries (Customer Search by EXTCIF)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.extcif
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("EXTCIF",v2,v3)) do vidxerr("XEXTCIF")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("EXTCIF",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("EXTCIF").exists() set v2=vx("EXTCIF").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("EXTCIF",v2,v3)
	#ENDBYPASS
	quit

vi16(RecordCIF cif) // Maintain ZEMPNAME index entries (Employer Name)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.empname
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XCIF("EMPNAME",v2,v3)) do vidxerr("ZEMPNAME")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XCIF("EMPNAME",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("EMPNAME").exists() set v2=vx("EMPNAME").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XCIF("EMPNAME",v2,v3)
	#ENDBYPASS
	quit

vi17(RecordCIF cif) // Maintain ZPCOUNTY index entries (County - Legal Address)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.pcounty
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XCIF("PCOUNTY",v2,v3)) do vidxerr("ZPCOUNTY")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XCIF("PCOUNTY",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("PCOUNTY").exists() set v2=vx("PCOUNTY").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XCIF("PCOUNTY",v2,v3)
	#ENDBYPASS
	quit

vi18(RecordCIF cif) // Maintain ZSPOUSE index entries (Name of Spouse)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cif.spouse
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cif.acn

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XCIF("SPOUSE",v2,v3)) do vidxerr("ZSPOUSE")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XCIF("SPOUSE",v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("SPOUSE").exists() set v2=vx("SPOUSE").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XCIF("SPOUSE",v2,v3)
	#ENDBYPASS
	quit

public VIDXBLD(List vlist) // Rebuild index files (External call)


	type Number %ProcessMode=0                             // Create mode
	type Number i

	if vlist.get().isNull() set vlist="VINDEX"             // Build all

	type DbSet ds=Db.selectDbSet("CIF")

	while ds.next() do {
		type RecordCIF cif=ds.getRecord("CIF")
		if vlist.contains("VINDEX") do VINDEX(.cif) quit
		if vlist.contains("AUD1ND") do vi1(.cif)
		if vlist.contains("AUD2ND") do vi2(.cif)
		if vlist.contains("CIFCNTRY") do vi3(.cif)
		if vlist.contains("CREREFRE") do vi4(.cif)
		if vlist.contains("EMPLACN") do vi5(.cif)
		if vlist.contains("FINSTFRE") do vi6(.cif)
		if vlist.contains("GOVT") do vi7(.cif)
		if vlist.contains("MADDR") do vi8(.cif)
		if vlist.contains("NAME") do vi9(.cif)
		if vlist.contains("NR") do vi10(.cif)
		if vlist.contains("PADDR") do vi11(.cif)
		if vlist.contains("SIC") do vi12(.cif)
		if vlist.contains("TAXID") do vi13(.cif)
		if vlist.contains("TYPXNAM") do vi14(.cif)
		if vlist.contains("XEXTCIF") do vi15(.cif)
		if vlist.contains("ZEMPNAME") do vi16(.cif)
		if vlist.contains("ZPCOUNTY") do vi17(.cif)
		if vlist.contains("ZSPOUSE") do vi18(.cif)
	}

	quit


public VIDXBLD1(RecordCIF cif, List vlist) // Rebuild index files for one record (External call)


	type Number i

	if vlist.contains("VINDEX") do VINDEX(.cif) quit
	if vlist.contains("AUD1ND") do vi1(.cif)
	if vlist.contains("AUD2ND") do vi2(.cif)
	if vlist.contains("CIFCNTRY") do vi3(.cif)
	if vlist.contains("CREREFRE") do vi4(.cif)
	if vlist.contains("EMPLACN") do vi5(.cif)
	if vlist.contains("FINSTFRE") do vi6(.cif)
	if vlist.contains("GOVT") do vi7(.cif)
	if vlist.contains("MADDR") do vi8(.cif)
	if vlist.contains("NAME") do vi9(.cif)
	if vlist.contains("NR") do vi10(.cif)
	if vlist.contains("PADDR") do vi11(.cif)
	if vlist.contains("SIC") do vi12(.cif)
	if vlist.contains("TAXID") do vi13(.cif)
	if vlist.contains("TYPXNAM") do vi14(.cif)
	if vlist.contains("XEXTCIF") do vi15(.cif)
	if vlist.contains("ZEMPNAME") do vi16(.cif)
	if vlist.contains("ZPCOUNTY") do vi17(.cif)
	if vlist.contains("ZSPOUSE") do vi18(.cif)

	quit


vidxerr(di) // Error message

	D SETERR^DBSEXECU("CIF","MSG",1225,"CIF."_di)

	quit


vkchged // Access key changed

	type public RecordCIF cif

	type public Boolean ER = 0
	type public String RM,vpar,vx()

	type Number %O = 1
	type String vnewkey,voldkey,vux
	type String voldpar = vpar.get()                       // Save filer switches

	set vux = vx("ACN")
	set voldkey = vux.piece("|",1),vobj(cif,-3) = voldkey  // Copy old keys into object

	set vpar = $$setPar^UCUTILN(vpar,"NOINDEX")            // Switch Index off
	do vload                                               // Make sure all data is loaded locally
	if vpar["/VALREQ/" do vrequ
	if vpar["/TRIGBEF/" do VBU
	if vpar["/VALDD/" do vddver
	do vexec

	set vnewkey = vux.piece("|",2),vobj(cif,-3) = vnewkey  // Copy new keys into object
	type RecordCIF vnewrec = cif.copy()
	do vnewrec.setMode(0)
	do vnewrec.save("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")

	set %O = 1 do CASUPD^DBSEXECU("CIF",voldkey,vnewkey) if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~")) // Cascade update
	set vpar = voldpar
	if vpar["/TRIGAFT/" do VAU

	set vobj(cif,-3) = vux.piece("|",1)                    // Reset key for delete
	set vpar = $$initPar^UCUTILN("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")
	set %O = 3 do vdelete(1)                               // Delete old record

	quit

VCASDEL // Cascade delete logic

	type public RecordCIF cif
	type public String vpar

	type String vERRMSG

	do Db.delete("CCEXT","ACN=:cif.acn",vpar)              // Cascade delete

	do Db.delete("CIFACCTS","ACN=:cif.acn",vpar)           // Cascade delete

	do Db.delete("CIFAUTH","ACN=:cif.acn",vpar)            // Cascade delete

	do Db.delete("CIFEXT","ACN=:cif.acn",vpar)             // Cascade delete

	do Db.delete("CIFEXTREG","ACN=:cif.acn",vpar)          // Cascade delete

	do Db.delete("CIFFSD","ACN=:cif.acn",vpar)             // Cascade delete

	do Db.delete("CIFGRPLIM","ACN=:cif.acn",vpar)          // Cascade delete

	do Db.delete("CIFH","ACN=:cif.acn",vpar)               // Cascade delete

	do Db.delete("CIFHH","ACN=:cif.acn",vpar)              // Cascade delete

	do Db.delete("CIFPIC","ACN=:cif.acn",vpar)             // Cascade delete

	do Db.delete("CIFSERV","ACN=:cif.acn",vpar)            // Cascade delete

	do Db.delete("CIFSIG","ACN=:cif.acn",vpar)             // Cascade delete

	do Db.delete("CMBGRP","ACN=:cif.acn",vpar)             // Cascade delete

	if Db.isDefined("CMSRECCRD","ACN=:cif.acn") set vERRMSG = $$^MSG(8563,"CMSRECCRD(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~")) // Restriction on delete

	type ResultSet rs15=Db.select("ACN","CRD","ACN=:cif.acn") // Restriction on delete
	if 'rs15.isEmpty() set vERRMSG = $$^MSG(8563,"CRD(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	type ResultSet rs16=Db.select("ACN","CRDEXT","ACN=:cif.acn") // Restriction on delete
	if 'rs16.isEmpty() set vERRMSG = $$^MSG(8563,"CRDEXT(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	do Db.delete("CUSTATTINFO","ACN=:cif.acn",vpar)        // Cascade delete

	do Db.delete("CUSTTOEVENTS","ACN=:cif.acn",vpar)       // Cascade delete

	do Db.delete("DAYENDCRDFI","ACN=:cif.acn",vpar)        // Cascade delete

	type ResultSet rs20=Db.select("ACN","DAYENDUSRAUT","ACN=:cif.acn") // Restriction on delete
	if 'rs20.isEmpty() set vERRMSG = $$^MSG(8563,"DAYENDUSRAUT(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	type ResultSet rs21=Db.select("ACN","DAYENDXBADC","ACN=:cif.acn") // Restriction on delete
	if 'rs21.isEmpty() set vERRMSG = $$^MSG(8563,"DAYENDXBADC(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	if Db.isDefined("DEP","ACN=:cif.acn") set vERRMSG = $$^MSG(8563,"DEP(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~")) // Restriction on delete

	do Db.delete("DTJADDRCHG","ACN=:cif.acn",vpar)         // Cascade delete

	do Db.delete("EMAIL","ACN=:cif.acn",vpar)              // Cascade delete

	type ResultSet rs25=Db.select("ACN","IRA","ACN=:cif.acn") // Restriction on delete
	if 'rs25.isEmpty() set vERRMSG = $$^MSG(8563,"IRA(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	type ResultSet rs26=Db.select("ACN","IRABEN","ACN=:cif.acn") // Restriction on delete
	if 'rs26.isEmpty() set vERRMSG = $$^MSG(8563,"IRABEN(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	type ResultSet rs27=Db.select("BENACN","IRABEN","BENACN=:cif.acn") // Restriction on delete
	if 'rs27.isEmpty() set vERRMSG = $$^MSG(8563,"IRABEN(BENACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	if Db.isDefined("LN","ACN=:cif.acn") set vERRMSG = $$^MSG(8563,"LN(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~")) // Restriction on delete

	do Db.delete("LNAP1","ACN=:cif.acn",vpar)              // Cascade delete

	do Db.delete("LNAP1COL","ACN=:cif.acn",vpar)           // Cascade delete

	do Db.delete("LNAP1CRM","SECACN=:cif.acn",vpar)        // Cascade delete

	do Db.delete("LNAP1HIST","ACN=:cif.acn",vpar)          // Cascade delete

	do Db.delete("LNAP1OWN","ACN=:cif.acn",vpar)           // Cascade delete

	do Db.delete("LNAP1SCH","ACN=:cif.acn",vpar)           // Cascade delete

	do Db.delete("LNLS1","ACN=:cif.acn",vpar)              // Cascade delete

	do Db.delete("LNOLC2","ACN=:cif.acn",vpar)             // Cascade delete

	do Db.delete("MDATACIF","ACN=:cif.acn",vpar)           // Cascade delete

	do Db.delete("MPROD","ACN=:cif.acn",vpar)              // Cascade delete

	type ResultSet rs39=Db.select("ACN","PAT","ACN=:cif.acn") // Restriction on delete
	if 'rs39.isEmpty() set vERRMSG = $$^MSG(8563,"PAT(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	type ResultSet rs40=Db.select("ACN","PAT1","ACN=:cif.acn") // Restriction on delete
	if 'rs40.isEmpty() set vERRMSG = $$^MSG(8563,"PAT1(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	do Db.delete("PURGDCIF","ACN=:cif.acn",vpar)           // Cascade delete

	do Db.delete("Q1042S","ACN=:cif.acn",vpar)             // Cascade delete

	type ResultSet rs43=Db.select("ACN","RELCIF","ACN=:cif.acn") // Restriction on delete
	if 'rs43.isEmpty() set vERRMSG = $$^MSG(8563,"RELCIF(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	do Db.delete("SADDRCIF","ACN=:cif.acn",vpar)           // Cascade delete

	do Db.delete("STOP1","ACN=:cif.acn",vpar)              // Cascade delete

	do Db.delete("TIKLCIF","ACN=:cif.acn",vpar)            // Cascade delete

	type ResultSet rs47=Db.select("ACN","USRAUTH","ACN=:cif.acn") // Restriction on delete
	if 'rs47.isEmpty() set vERRMSG = $$^MSG(8563,"USRAUTH(ACN) -> CIF(ACN)") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	quit

VIDXPGM()	quit "CIFFILE"	// Location of index program

