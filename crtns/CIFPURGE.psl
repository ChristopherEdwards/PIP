public CIFPURGE	// CIF batch purge
	/*
	       ORIG:  Dan S. Russell (2417) - 08/17/86
	       DESC:  Batch delete of CIF records and associated files.
	              ALSO SEE:  ^CIFDEL for single CIF delete

	              DELETION CRITERIA:

	               a)  CIF not opened with last 30 days
	               b)  No accounts linked to CIF
	               c)  Not a head-of-household with members
	               d)  No current or prior year IRA information
	               e)  Number of days since last CIF file maintenace exceeds
	                   days held in ^CUVAR("CIF") piece 4.  If not set up,
	                   defaults to 365 days.
	               f)  CIF not tied to PAT system
	               g)  Not an IRA beneficiary (^IRABEN)
	               h)  No purge flag [CIF]NOPURGE is not set

	               Files entry in ^CIFD for daily tran report

	               Writes all files deleted to RMS file SAVE.CIFPURGE

	  ---- Revision History ------------------------------------------------
	  
	   07/28/06 - KELLYP - CR 22048
	   	      Modified DATA section to eliminate DYNAMIC warning.
	  
	   04/19/06 - RussellDS - CR20209
	   	      Removed references to investments as mutual funds/
	   	      securities have been obsoleted.
	  
	   04/18/06 - ChhabriS - CR20727
		      Modified IRAX section, replaced Class.new with Db.getRecord(,,1)
		      for TMPRPT1 to avoid unique constraint error.
	  
	   04/04/06 - RussellDS - CR20208
	   	      Removed references to table PATACN and fixed code in PAT
	   	      section to check to see if any PAT data.
	   
	   12/05/05 - Satyanas - 18155
	   	      Clean up the M code to PSL.
	   
	   06/01/04 - Scottc 9756
	   		Remove reference to DAYENDSTM.  Table was deleted
		      	because the file exists as an index for CMBGRP.  The
			CMBGRP index will be removed automatically when CMBGRP
		 	is purged. Type the variables to make the compiler
			happy.

	   01/28/03 - Spier 51423
		      Correct this line in IRAX
			set Z=rs.getCol(3)		TO
			set Z=rs.getCol(2)

	   10/21/02 - GRAY - 49794
		      Removed all logic that writes globals to RMS files. 
		      Also, cleaned up coding errors and replaced all global
		      references.
	
	   07/15/02 - SRIVASTAVAN - 49794
		      Converted to PSL

	   06/16/01 - JERUCHIMC - 43026
	              Modified section DELHH to deal with new household file
	              key structure.

	   03/14/00 - TANY - 37587
	              Modified section IRA with passing an additional parameter (1)
	              in SCADAT calls to improve performance.

	------------------------------------------------------------------------
	*/

	do INIT
	quit


INIT	//
	
	type public Boolean ANT,ER
	type public Number SORT
	type public String CONT,COLLIST(),%NOPRMT,%READ,RM,SORTTBL,%TAB,TYP,VFMQ
	type Date CUTOFF
	type Number ACN
	
	set %READ=""

	type public IO io = Class.new("IO")

	do Db.fastDelete("TMPRPT0","PID=:%ProcessID")
	do Db.fastDelete("TMPCIFP0","PID=:%ProcessID")
	do Db.fastDelete("TMPCIFP1","PID=%ProcessID")
	do Db.fastDelete("TMPCIFP2","PID=:%ProcessID")

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

	// Sort by Product Type
	set SORTTBL(0)=$$^MSG(8274)

	// Sort by Customer Number
	set SORTTBL(1)=$$^MSG(8275)

	// Sort by Customer Name
	set SORTTBL(2)=$$^MSG(8454)

	set %TAB("TYP")=".TYPE3/TBL=[PRODDFTC]:NOVAL" set TYP="ALL"
	set %TAB("ANT")=".ANT1" set ANT=1
	set %TAB("SORT")=".SORT3/TBL=SORTTBL(" set SORT=0

	set %READ="@@%FN/REV/CEN,,,TYP/REQ,ANT/REQ,SORT/REQ"
	do ^UTLREAD 
	if VFMQ="Q" quit

	if 'ANT do { if 'CONT quit

		type String OLNTB,TEXT

		// CIF Purge Verification
		set TEXT(1)=$$^MSG(3137)

		// CONTINUING AT THIS POINT WILL PURGE CIF RECORDS
		set TEXT(2)=$$^MSG(3139)

		set %TAB("CONT")=".CONT1" set CONT=0
		set %READ="@@%FN/REV/CEN,,,@TEXT(1),,@TEXT(2),,,CONT/REQ"
		set %NOPRMT="F" do ^UTLREAD if 'CONT.exists() quit
		}

	do IRAX

	// find data extraction routine
	type String PGM,PURGE
	type Number CIFPRGD,CNT
	
	type RecordEXTRACTDESC extractdesc=Db.getRecord("EXTRACTDESC","MAP='ZCIFCL'",1)
	set PGM=extractdesc.rtn
	
	// Data extraction routine does not exist
	if PGM.isNull()!('$$VALID^%ZRTNS(PGM)) set RM=$$^MSG(3845)
	
	// set file characterisitcs and open
	
	if 'ANT do {
		
		set io.fileName ="SAVE.CIFPURGE"
 		set io.openParams = "NEWV/WRITE"
		set io.timeout = 5
	
		catch ioExc {
			// catch exception error
			if ioExc'["%PSL-E-IO" throw ioExc

			// Error opening ~p1. Process stopped for type ~p2
			write $$^MSG(992,io.fileName,ioExc.type), !
	
			}
			
		do io.open()
		
		// Writing deleted files to ~p1
		do io.write($$^MSG(6969, io.fileName))

		// write headers
		
		do io.write($$HEADER("LNAP1CRM",.COLLIST()))
		do io.write($$HEADER("LNAP1",.COLLIST()))
		do io.write($$HEADER("LNAP1COL",.COLLIST()))
		do io.write($$HEADER("LNAP1HIST",.COLLIST()))
		do io.write($$HEADER("LNAP1SCH",.COLLIST()))
		do io.write($$HEADER("IRA",.COLLIST()))
		do io.write($$HEADER("CIFH",.COLLIST()))
		do io.write($$HEADER("CIFFSD",.COLLIST()))
		do io.write($$HEADER("CIF",.COLLIST()))
		do io.write($$HEADER("XPRIOR",.COLLIST()))
		do io.write($$HEADER("XHHLD1",.COLLIST()))
		do io.write($$HEADER("CIFHH0",.COLLIST()))
		
		do io.write("EOH")
		
		}
		
	set CIFPRGD=cuvar.cifprgd 
	if 'CIFPRGD set CIFPRGD=365

	// Last file maintenance date  
	set CIFPRGD=%SystemDate-CIFPRGD

	set CUTOFF=%SystemDate-30 
	set PURGE="" 
	set CNT=0

	type ResultSet rs=Db.select("ACN","CIF")
	if 'rs.isEmpty() while rs.next()  do {
        	set ACN=rs.getCol(1)
		type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN")
		set ER=0 
		do DTL(.cif,ACN,.io,.COLLIST())
		}

	do EXIT 

	quit


HEADER(String TABLE, 
       String COLLIST())	// write header
	
	set COLLIST = $$COLLIST^DBSDD(TABLE,1,1,1)
	set COLLIST(TABLE) = COLLIST

	quit (TABLE_9.char()_COLLIST.translate(",",9.char()))


DTL( RecordCIF cif, 
     Number ACN, 
     IO io,
     String COLLIST())	//

	type public Boolean ANT,ER
	type public Date CUTOFF
	type public Number CIFPRGD,CNT
	type public String TYP
	type Number N

	if TYP'="ALL",TYP'=cif.type quit 
	
	// Purge criteria
	
	// NOPURGE flag
	if cif.nopurge quit
	
	// Prior to cutoff date
	if cif.dao>CUTOFF quit
	
	// File maintenance within range
	if cif.fmld>CIFPRGD quit

	// Accounts linked to this CIF

	type ResultSet rs=Db.select("CID","RELCIF","ACN=:ACN") 
	if 'rs.isEmpty() while rs.next()  do { quit:ER
		set N=rs.getCol(1)
		if Db.isDefined("ACN","CID=:N") set ER=1 quit
		}

    	// Check householding
	do HH(ACN) if ER quit

	// Check IRA's
	do IRA(ACN) if ER quit

	// Check for PAT entries
	do PAT(ACN) if ER quit

	// Check ATM Card File
	do CARD(ACN) if ER quit

	set CNT=CNT+1
	
	do TMPBUILD(.cif,ACN)

	if 'ANT do DELETE(.cif,ACN,.io,.COLLIST()) do FILE(.cif,ACN)

	quit


private HH( Number ACN)	// Check household linkages

	type public Boolean ER

	type ResultSet rs=Db.select("HHTYP,MACN","CIFHH0","ACN=:ACN")
	if rs.isEmpty() quit
	
	set ER=1
	
	quit


private PAT( Number ACN) // Check Pre-Authorized Transfers

	type public Boolean ER

        type ResultSet rs=Db.select("SRC","PAT1","ACN=:ACN")
        if rs.isEmpty() quit
        
	set ER=1
	
	quit

private IRA( Number ACN)	// Check IRA linkages

	type public Boolean ER
	type Number I,IRA,RPASEQ,TAXYR,YEAR,YR
	
	type ResultSet rsiraben=Db.select("DISTINCT ACN","IRABEN","ACN=:ACN")
	if 'rsiraben.isEmpty()!(Db.isDefined("TMPRPT1","PID=:%ProcessID,KEY1=:ACN")) set ER=1 quit

	// No IRA's
	type ResultSet rsiratype=Db.select("DISTINCT ACN","IRATYPE","ACN=:ACN")
	if rsiratype.isEmpty() quit

    	set YEAR=$$YEAR^SCADAT(%SystemDate,1)
	set YR=YEAR-2
	set IRA=0 
	
	type ResultSet rs=Db.select("RPASEQ,TAXYR","IRA","ACN=:ACN AND TAXYR>:YR")
        if rs.isEmpty() quit
	while rs.next()  do { quit:ER

	        set RPASEQ=rs.getCol(1)
		set TAXYR=rs.getCol(2)
		type RecordIRA ira=Db.getRecord("IRA","ACN=:ACN,RPASEQ=:RPASEQ,TAXYR=:TAXYR",1)
		if 'ira.getMode() quit
		for I=0,1 do { quit:ER
			type RecordIRAVER iraver=Db.getRecord("IRAVER","ACN=:ACN,RPASEQ=:RPASEQ,TAXYR=:TAXYR,VAR=:I",1)
			if iraver.getMode() set ER=1
			}
		}

	quit


Private CARD(ACN)	// Check ATM Card File Linkages

	type public Boolean ER

	type ResultSet rs=Db.select("DISTINCT ACN","CRD","ACN=:ACN")
	if rs.isEmpty() quit
	
	set ER=1
	
	quit
	

IRAX	// Set up temporary X reference file for IRA beneficiaries

	do Db.fastDelete("TMPRPT1","PID=:%ProcessID")

	type Number X,Z

        type ResultSet rs=Db.select("ACN,BENSEQ","IRABEN")
        if rs.isEmpty() quit
        while rs.next() do {
                set X=rs.getCol("ACN")
		set Z=rs.getCol(2)
		type RecordTMPRPT1 tmp=Db.getRecord("TMPRPT1","PID=:%ProcessID,KEY1=:Z",1)
		set tmp.data=X
		do tmp.bypassSave()
		}
	quit


DELETE( RecordCIF cif, 
	Number ACN, 
	IO io,
	String COLLIST())	// Delete the CIF and associated files

	type public String PGM
	type Date SNDT
	type Number STMGRP,XAPPNUM,XAPPS,XCRSEQ,XSECACN 

	//Purged CIF file
	type RecordPURGDCIF purgdcif=Class.new("RecordPURGDCIF")
	set purgdcif.acn=ACN
	do purgdcif.bypassSave()	
	
	//Archive CIF info
	if 'PGM.isNull()!($$VALID^%ZRTNS(PGM)) do ^@PGM

	type ResultSet rscmbgrp=Db.select("STMGRP","CMBGRP","ACN=:ACN")
	if 'rscmbgrp.isEmpty() while rscmbgrp.next() do {
		
		set STMGRP=rscmbgrp.getCol(1)
		type RecordCMBGRP cmbgrp=Db.getRecord("CMBGRP","ACN=:ACN,STMGRP=:STMGRP")
		set SNDT=cmbgrp.sndt
		if SNDT.isNull() quit

		}
	

	do Db.fastDelete("STOP1","ACN=:ACN")

	type ResultSet rscifhh=Db.select("ACN","CIFHH0","ACN=:ACN")
	if 'rscifhh.isEmpty() do DELHH(ACN,.io)

	
	// Get all records from LNAP1CRM for this application

	type ResultSet rs=Db.select("APPS","LNAP1","ACN=:ACN")
	if 'rs.isEmpty() while rs.next() do {
        	set XAPPS=rs.getCol(1)
		type RecordLNAP1 lnap1=Db.getRecord("LNAP1","ACN=:ACN,APPS=:XAPPS")
		set XAPPNUM=lnap1.appnum
		if XAPPNUM.isNull() quit			

		type ResultSet rs1=Db.select("SECACN,CRSEQ","LNAP1CRM","APPNUM=:XAPPNUM")
		if rs1.isEmpty() quit
		while rs1.next()  do {
			set XSECACN=rs1.getCol(1)
			set XCRSEQ=rs1.getCol(2)
 			type DbSet ds = Db.selectDbSet("LNAP1CRM","APPNUM=:XAPPNUM AND SECACN=:XSECACN AND CRSEQ=:XCRSEQ")

			while ds.next() do {
		
				type RecordLNAP1CRM lnap1crm = ds.getRecord("LNAP1CRM")
			
				do DATA(COLLIST("LNAP1CRM"),"LNAP1CRM",XSECACN,.io)
				}
			// kill LNAP1CRM
			do Db.delete("LNAP1CRM","APPNUM=:XAPPNUM AND SECACN=:XSECACN AND CRSEQ=:XCRSEQ")
			}

		}

	do DATA(COLLIST("LNAP1"),"LNAP1",ACN,.io)
	
	do Db.fastDelete("LNAP1","ACN=:ACN")
	
	do DATA(COLLIST("LNAP1COL"),"LNAP1COL",ACN,.io)
	
	// kill LNAP1COL
	do Db.fastDelete("LNAP1COL","ACN=:ACN")

	do DATA(COLLIST("LNAP1HIST"),"LNAP1HIST",ACN,.io)
	
	// kill LNAP1HIST
	do Db.fastDelete("LNAP1HIST","ACN=:ACN")

	do DATA(COLLIST("LNAP1SCH"),"LNAP1SCH",ACN,.io)
	
	// kill LNAP1SCH
	do Db.fastDelete("LNAP1SCH","ACN=:ACN")

	do DATA(COLLIST("IRA"),"IRA",ACN,.io)
	
	// kill IRA
	do Db.fastDelete("IRA","ACN=:ACN")

	do DATA(COLLIST("CIFH"),"CIFH",ACN,.io)
	
	// kill CIFH
	do Db.fastDelete("CIFH","ACN=:ACN")

	do DATA(COLLIST("CIFFSD"),"CIFFSD",ACN,.io)
	
	// kill CIFFSD
	do Db.fastDelete("CIFFSD","ACN=:ACN")

	do DATA(COLLIST("CIF"),"CIF",ACN,.io)
	
	// kill CIF
	do Db.delete("CIF","ACN=:ACN")

	quit


XPRIOR	//Delete XPRIOR index 

	type public Boolean ANT
	type Number ZACN
	type String ZNAM
	
	if ANT quit

	type ResultSet rs=Db.select("NAM,ACN","XPRIOR")
	if rs.isEmpty() quit
	while rs.next()  do {
       		set ZNAM=rs.getCol(1)
		set ZACN=rs.getCol(2)

		if 'Db.isDefined("CIF","ACN=:ZACN") do {
			do Db.delete("XPRIOR","NAM=:ZNAM AND ACN=:ZACN")
			}
		}
	quit 

private DELHH( Number ACN, IO io)	//Delete household info

	type public String COLLIST()
	type Number N
	type String HHTYP
	
	type ResultSet rs=Db.select("HHTYP,HEADACN","CIFHH","ACN=:ACN")
	if rs.isEmpty() quit
	while rs.next()  do {
		set HHTYP=rs.getCol(1)
		set N=rs.getCol(2)
		
		// Head of household				
		if ACN=N do { quit
			type DbSet ds = Db.selectDbSet("XHHLD1","HHTYP=:HHTYP AND ACN=:ACN AND MACN=:N")

			while ds.next() do {
		
				type RecordXHHLD1 xhhld1 = ds.getRecord("XHHLD1")
			
				do DATA(COLLIST("XHHLD1"),"XHHLD1",ACN,.io)
				}
			do Db.delete("XHHLD1","HHTYP=:HHTYP AND ACN=:ACN AND MACN=:N")
			}

		type DbSet ds = Db.selectDbSet("CIFHH0","ACN=:N AND HHTYP=:HHTYP AND MACN=:ACN")
		while ds.next() do {
		
				type RecordCIFHH0 cifhho = ds.getRecord("CIFHH0")
			
				do DATA(COLLIST("CIFHH0"),"CIFHH0",ACN,.io)	
				}
				
			do Db.delete("CIFHH0","ACN=:N AND HHTYP=:HHTYP AND MACN=:ACN")
		}
	
	quit
	

DATA( String COLLIST,
      String TABLE, 
      Number ACN,
      IO io)	// write data

	type String DATA

	#ACCEPT DATE=07/28/06;PGM=KELLYP;CR=unknown
	type ResultSet rs = Db.select( COLLIST,TABLE,"ACN=:ACN")
	
	while rs.next() do {

		type Row rw = rs.getRow()

		set DATA = TABLE_9.char()_ACN_rw.toString()

		do io.write(.DATA)
		}

	quit


private FILE( RecordCIF cif, Number ACN)	// File entry in CIFD for daily reporting

	type String TCMT

	// CIF purged from file: ~p1
	// Customer Name
	set TCMT=$$^MSG(3138,cif.nam)

	type RecordCIFD cifd=Class.new("RecordCIFD")
	
	set cifd.tjd=%SystemDate
	set cifd.acn=ACN
	set cifd.seq=Db.nextVal("CIFD","TJD=:%SystemDate,ACN=:ACN")

	set cifd.tlo=%UserStation
	set cifd.tcmt=TCMT
	set cifd.hdate=%CurrentDate
	set cifd.htime=%CurrentTime
	set cifd.uid=%UserID
	do cifd.bypassSave()

	quit


private TMPBUILD( RecordCIF cif, Number ACN)	// Build temporary global to run report...

	type public Number SORT
		
	type RecordTMPCIFP0 tmpcifp0=Class.new("RecordTMPCIFP0")
	type RecordTMPCIFP1 tmpcifp1=Class.new("RecordTMPCIFP1")
	type RecordTMPCIFP2 tmpcifp2=Class.new("RecordTMPCIFP2")

	if SORT=0 do {  
		
		set tmpcifp0.pid=%ProcessID
		set tmpcifp0.type=cif.type
		set tmpcifp0.acn=ACN
		set tmpcifp0.name=cif.nam
		set tmpcifp0.ltd=cif.fmld
		
		do tmpcifp0.bypassSave()
		}

	if SORT=1 do {

		set tmpcifp1.pid=%ProcessID
		set tmpcifp1.acn=ACN
		set tmpcifp1.type=cif.type
		set tmpcifp1.name=cif.nam
		set tmpcifp1.ltd=cif.fmld

		do tmpcifp1.bypassSave()
		}
	
	if SORT=2 do {

		set tmpcifp2.pid=%ProcessID
		set tmpcifp2.lname=cif.lnm
		set tmpcifp2.acn=ACN
		set tmpcifp2.name=cif.nam
		set tmpcifp2.ltd=cif.fmld

		do tmpcifp2.bypassSave()	
		}

	quit
	

EXIT	//

	type public Boolean ANT 
	type public Number CNT,SORT
	type public String ER,RID,RM
	
	do XPRIOR
	
	set RID=$S(SORT=0:"CIFPURT",SORT=1:"CIFPURA",1:"CIFPURN") do DRV^URID
	
	do Db.fastDelete("TMPRPT0","PID=:%ProcessID")

	do Db.fastDelete("TMPCIFP0","PID=:%ProcessID")

	do Db.fastDelete("TMPCIFP1","PID=:%ProcessID")

	do Db.fastDelete("TMPCIFP2","PID=:%ProcessID")

	// Purge complete...~P1 CIF'S purged
	if 'ANT set RM=$$^MSG(5550,CNT)

	set ER="W"

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60477^65443^Pat Kelly^14028"	// Signature - LTD^TIME^USER^SIZE
