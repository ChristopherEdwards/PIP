ESCFUNCS	
	/*
	ORIG: CHIANG - 07/23/96
	Procedure ID: ESCFUNCS
	DESC: Escrow filer library functions
	
	KEYWORDS:     Escrow
	
	LIBRARY:
		. DELESC   - Delete escrow accounts for a single loan record.
		. CHGESC   - Change escrow account Loan Account Reference (AREF).
		. GETBILPE - Get a passed list of columns from the LNBIL1 file,
			     allows a flexible request of fields

	----- Revision History -----------------------------------------------
	
	03/21/07 - SHANKK - CR26075
			Fixed undefined errors in section GETBILPE.
	
	05/23/06 - SmithCD - CR 19732
		   Replaced calls to $$LETC for interest expense / income 
		   offset transactions with appropriate MDR / MCR and GL 
		   account numbers in WAIVE section.
	
	05/17/06 - SmithCD - CR 20855
		   Replaced prodctl.drtrin reference with prodctl.dradni in 
		   DETC section when TCCTL=3 (Post negative interest) and 
		   DRCR=0 (debit). Added .ttx parameter to calls to ACRTRAN 
		   from WAIVE. Further cleaned up procedure.
	
	10/13/05 - Srinivar - 16890
		   Modifications were made to accomodate escrow account 
	 	   interest accrual processing.
	 	   Included new sections WAIVE,POST,POSTTRAN,DETC,LETC,ACRTAN,
	 	   INTRDX.  

	----------------------------------------------------------------------
	*/
	
	quit
	
		   
public DETC(Number DTYPE, 		// Deposit product type
            Number TCCTL,		// Transaction code control
            Boolean DRCR) 		// Debit/credit indicator
            
	/*
	Determine deposit escrow transaction code
	
	Description:
	
	This function determines the proper deposit escrow transaction
	code to be used to update escrow accounts for interest 
	accrual/posting amounts  based on control parameters passed in. If the 
	transaction code cannot be found in the deposit non-defaulting product 
	type, an error will be returned.
	
	Arguments: 	

		.  TCCTL
	
		   0 - Post (positive) interest/dividend
		   1 - Adjust (positive) interest/dividend accrual
		   2 - Adjust (positive) interest/dividend paid
		   3 - Post negative interest
		   4 - Adjust negative (authorized) interest accrual
		   5 - Adjust negative (authorized /unauthorized) interest charged
		   6 - Adjust negative unauthorized interest accrual
		   7 - Adjust negative uncollected interest accrual
		   8 - Adjust negative uncollected interest charged
	
	Format:	
		   set ETC = $$DETC^ESCFUNCS(TYPE, 1, 1) quit:ER
	
	Returns:
		   ETC	
		   External transaction code
	*/	   
	
	type public Cache %CACHE()

	type String TETC = ""
	
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:DTYPE")	
	
	if DRCR = 0 do { quit TETC

		if TCCTL = 0 do { quit
			// DR Adj Int/Div Expense Tran Code
			set TETC = prodctl.dradie
			if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "DRADIE")
			}

		if TCCTL = 1 do { quit
			// DR Adj Accrued Int/Div Tran Code
			set TETC = prodctl.dradin
			if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "DRADIN")
			}

		if TCCTL = 2 do { quit
			// DR Adj Int/Div Expense Tran Code
			set TETC = prodctl.dradie
			if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "DRADIE")
			}

		if TCCTL = 3 do { quit
			// DR Adj Neg Interest Posted Tran Code
			set TETC = prodctl.dradni
			if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "DRADNI")
			}

		if TCCTL = 4 do { quit
			// DR Adj Neg Accrued Interest Tran Code
			set TETC=prodctl.dradna
			if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "DRADNA")
			}

		if TCCTL = 5 do { quit
			// DR Adj Neg Interest Posted Tran Code
			set TETC=prodctl.dradni
			if TETC.isNull() D ETCERR^TTXEXT(DTYPE, "DRADNI")
			}

		if TCCTL = 6 do { quit
			// DR ADJ Neg Accrued Unauth Tran Code
			set TETC = prodctl.drnegacrua
			if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "DRNEGACRUA")
			}

		if TCCTL = 7 do { quit
			// DR Accrued Interest on Uncollected Funds
			set TETC = prodctl.draiud
			if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "DRAIUD")
			}
			
		if TCCTL = 8 do { quit
			// DR Interest on Uncollected Funds
			set TETC = prodctl.driufd

			// DR Adj Neg Interest Posted Tran Code
			if TETC.isNull() set TETC = prodctl.dradni

			if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "DRADNI")
			}
		}	

	if TCCTL = 0 do {
		// CR Int/Div Tran Code
		set TETC=prodctl.crtrin
		if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "CRADIE")
		}

	if TCCTL = 1 do {
		// CR Adj Int/Div Accrued Tran Code
		set TETC=prodctl.cradin
		if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "CRADIN")
		}

	if TCCTL = 2 do { 
		// CR Adj Int/Div Expense Tran Code
		set TETC = prodctl.cradie
		if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "CRADIE")
		}

	if TCCTL = 3 do {
		// CR Adj Neg Interest Posted Tran Code
		set TETC = prodctl.cradni
		if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "CRADNI")
		}

	if TCCTL = 4 do {
		// CR Adj Neg Accrued Interest Tran Code
		set TETC = prodctl.cradna
		if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "CRADNA")
		}

	if TCCTL = 5 do { 
		// CR Adj Neg Interest Posted Tran Code
		set TETC = prodctl.cradni
		if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "CRADNI")
		}

	if TCCTL = 6 do { 
		// CR ADJ Neg Accrued Unauth Tran Code
		set TETC = prodctl.crnegacrua
		if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "CRNEGACRUA")
		}

	if TCCTL = 7 do {
		// CR Accrued Interest on Uncollected Funds
		set TETC = prodctl.craiuc
		if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "CRAIUC")
		}

	if TCCTL = 8 do {
		// CR Interest on Uncollected Funds
		set TETC = prodctl.criufc
		
		// CR Adj Neg Interest Posted Tran Code
		if TETC.isNull() set TETC = prodctl.cradni
		if TETC.isNull() do ETCERR^TTXEXT(DTYPE, "CRIUFC")
		}
	
	quit TETC
	
		
public LETC(Number LTYPE,		// Loan product type
	    Number TCCTL,		// Transaction code control
	    Boolean DRCR)		// Debit/credit indicator
	
	/*
	Determine loan transaction code

	Description:
	
	This function determines the proper loan transaction code to be used 
	to update escrow accounts  for interest accrual/posting amounts	
	based on control parameters passed in. The transaction created using 
	this transaction code, when processed, will generatea secondary 
	transaction to the escrow deposit account to update the appropriate 
	interest-related fields. If the transaction code cannotbe found in 
	the loan non-defaulting product type, an error will be returned.
	
	Arguments:

		.  TCCTL
		   Transaction code control
	
		   0 - Post (positive) interest/dividend
		   1 - Adjust (positive) interest/dividend accrual
		   2 - Adjust (positive) interest/dividend paid
		   3 - Post negative interest
		   4 - Adjust negative (authorized) interest accrual
		   5 - Adjust negative (authorized /unauthorized) interest charged
		   6 - Adjust negative unauthorized interest accrual
		   7 - Adjust negative uncollected interest accrual
		   8 - Adjust negative uncollected interest charged
	
	Format:	
		 set ETC = $$LETC^ESCFUNCS(TYPE, 1, 1) quit:ER
	
	Returns:
		.  ETC	
		   External transaction code
	
	*/
	
	type public Cache %CACHE()

	type String TETC = ""
	
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:LTYPE")
	
	if DRCR = 0 do { quit TETC

		if (TCCTL = 0) ! (TCCTL = 2) do { quit
			// DR Escrow Int Paid Adj Tran Code
			set TETC = prodctl.drtrepa
			if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "DRTREPA") 
			}

		if TCCTL = 1 do { quit
			// DR Escrow Accrual Adj Tran Code
			set TETC = prodctl.drtrei
			if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "DRTREI")
			}
		
		// DR Escrow Neg Interest Post Tran Code
		if TCCTL = 3 do { quit
			// DR Escrow Neg Interest Post Tran Code
			set TETC = prodctl.drtrenp

			// DR Escrow Neg Int Charged Adj Tran Code
			if TETC.isNull() set TETC = prodctl.drtrenpa
			if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "DRTRENP")
			}

		if TCCTL = 4 do { quit
			// DR Escrow Neg Accrual Adj Tran Code
			set TETC = prodctl.drtrena
			if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "DRTRENA") 
			}

		if TCCTL = 5 do { quit
			// DR Escrow Neg Int Charged Adj Tran Code
			set TETC = prodctl.drtrenpa
			if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "DRTRENPA")
			}
		
		if TCCTL = 6 do { quit
			// DR Escrow Neg Unauth Accr Tran Code
			set TETC = prodctl.drtrenau
			if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "DRTRENAU")
			} 

		if TCCTL = 7 do { quit
			// DR Escrow Neg Uncol Accrual Tran Code
			set TETC = prodctl.drtrenac
			if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "DRTRENAC")
			}
			
		if TCCTL = 8 do { quit
			// DR Escrow Neg Uncol Charge Adj Tran Code
			set TETC = prodctl.drtrenpu	

			// DR Escrow Neg Int Charged Adj Tran Code
			if TETC.isNull() set TETC = prodctl.drtrenpa
			if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "DRTRENPA")
			}
		}
		
	if TCCTL = 0 do {
		// CR Escrow Interest Post Tran Code
		set TETC = prodctl.crtrep

		// CR Escrow Int Paid Adj Tran Code
		if TETC.isNull() set TETC = prodctl.crtrepa
		if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "CRTREP")
		} 

	if TCCTL = 1 do {
		// CR Escrow Accrual Adj Tran Code
		set TETC = prodctl.crtrei
		if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "CRTREI")
		}

        if (TCCTL = 2) do {
		// CR Escrow Int Paid Adj Tran Code
		set TETC = prodctl.crtrepa
		if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "CRTREPA")
		}

	if (TCCTL = 3) ! (TCCTL = 5) do {
		// CR Escrow Neg Int Charged Adj Tran Code
		set TETC = prodctl.crtrenpa
		if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "CRTRENPA")
		}

	if TCCTL = 4 do {
		// CR Escrow Neg Accrual Adj Tran Code
		set TETC = prodctl.crtrena
		if TETC.isNull() D ETCERR^TTXEXT(LTYPE, "CRTRENA") 
		}

	if TCCTL = 6 do {
		// CR Escrow Neg Unauth Accr Tran Code
		set TETC = prodctl.crtrenau
		if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "CRTRENAU")
		}

	if TCCTL = 7 do {
		// CR Escrow Neg Uncol Accrual Tran Code
		set TETC = prodctl.crtrenac
		if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "CRTRENAC") 
		}

	if TCCTL = 8 do {
		// CR Escrow Neg Uncol Charge Adj Tran Code
		set TETC = prodctl.crtrenpu

		// CR Escrow Neg Int Charged Adj Tran Code
		if TETC.isNull() set TETC = prodctl.crtrenpa
		if TETC.isNull() do ETCERR^TTXEXT(LTYPE, "CRTRENPA")
		}
	
	quit TETC
	

public INTRDX(RecordLN ln, 		// Loan account			/REF:RW
              RecordDEP dep,		// Deposit account		/REF:RW
              RecordTTX ttx,		// Primary transaction		/REF:R
              Boolean WAIVE,		// Waive interest
              String ESCTYPE,		// Escrow type
              Boolean DIRECT) 		// Setting the secondary transaction
               
	/*
	Reduce interest on escrow account

	This function builds and executes secondary transactions to reduce
	all or specified types of interest on a escrow account (through the 
	associated loan account). It will typically be called from closeout 
	or renewal processes.
	 
	Additional notes on ARGUMENTS:

		. WAIVE
		  Waive Interest (0 - do not waive (post); 1 - waive)

		. DIRECT
			  null - set secondary transaction on the loan
			  1    - set secondary transaction on escrow
			         account
		
	 FORMAT:
		do INTRDX^ESCFUNCS(.ln, .dep, .ttx, 1, ESCTYPE) quit:ER
	*/
	
	type public Number ZAMT

        type String TSO
        type Number CID, EXACTACR, PRTYPE
		
	set DIRECT = DIRECT.get()
	
	if DIRECT new ZAMT do {
		set CID = dep.cid
		set PRTYPE = dep.type
		set ZAMT = ""
		}
	else  do {
		set CID = ln.cid
		set PRTYPE = ln.type
		}
		
	set TSO = $$FIELDIN^UTSO("", "ESC", ESCTYPE)
	
	if WAIVE.get() do WAIVE(.dep, .ln, .ttx)
	if 'WAIVE.get() do POST(.dep, .ln, .ttx)
	
	quit

	
WAIVE(RecordDEP dep,		// Deposit account			/REF:RW
      RecordLN ln,		// Loan account				/REF:RW
      RecordTTX ttx)		// Primary transaction			/REF:R
      
        // Waive all accrual through account
		
	type public Boolean DRCR, ER
	type public String TSO
	type public Number PRTYPE, TAMT
	type public Cache %CACHE()

	type String OFFSET, TCMT
	type Number GLCID
	
	// Earnings adjustment
	set TCMT = $$^MSG(6748)

	type RecordUTBLGLSC utblglsc = %CACHE("UTBLGLSC").getRecord("UTBLGLSC", "GLSC=:dep.glsc")
			
	// Positive interest accrued
	if dep.posacr do { quit:ER
		set TAMT = dep.posacr
		do ACRTRAN(.dep, .ln, .ttx, 1, .TAMT, .DRCR) quit:ER
		
		// Dep G/L # (Interest Expense)
		set GLCID = utblglsc.dgli
		set OFFSET = $select(DRCR=1:"MDR",1:"MCR")
		do POST^LNTRB(.ttx, GLCID, OFFSET, TAMT, %EffectiveDate.get(), %UserStation, TSO, "", dep.crcd)
		}

	// Negative interest accrued
	if dep.negacr do { quit:ER
		set TAMT=dep.negacr
		do ACRTRAN(.dep, .ln, .ttx, 4, .TAMT, .DRCR) quit:ER
		
		// Dep G/L # (O/D Interest Income)
		set GLCID = utblglsc.dglii
		set OFFSET = $select(DRCR=1:"MDR",1:"MCR")
		do POST^LNTRB(.ttx, GLCID, OFFSET, TAMT, %EffectiveDate.get(), %UserStation, TSO, "", dep.crcd)
		}
	
	// Negative interest unauthorized accrued 
	if dep.negacrun do { quit:ER
		set TAMT = dep.negacrun
		do ACRTRAN(.dep, .ln, .ttx, 6, .TAMT, .DRCR) quit:ER
		
		// Dep G/L # (O/D Interest Income)
		set GLCID = utblglsc.dglii
		set OFFSET = $select(DRCR=1:"MDR",1:"MCR")
		do POST^LNTRB(.ttx, GLCID, OFFSET, TAMT,%EffectiveDate.get(), %UserStation, TSO, "", dep.crcd)
		}
	
	// Uncollected interest accrued
	if dep.uncacr do { quit:ER
		set TAMT = dep.uncacr
		do ACRTRAN(.dep, .ln, .ttx, 7, .TAMT, .DRCR) quit:ER
		
		// Dep G/L # (O/D Interest Income)
		set GLCID = utblglsc.dglii
		set OFFSET = $select(DRCR=1:"MDR",1:"MCR")
		do POST^LNTRB(.ttx, GLCID, OFFSET, TAMT, %EffectiveDate.get(), %UserStation,TSO, "", dep.crcd)
		}
		
	quit


POST(RecordDEP dep,		// Deposit account			/REF:RW
     RecordLN ln,		// Loan account				/REF:RW
     RecordTTX ttx)		// Primary transaction			/REF:R
     
     	// Post all interest to account
	
	type public Number TAMT, CID
	type public Boolean DRCR, ER

	// Post positive interest	
	if dep.posacr do { quit:ER
		set TAMT = dep.posacr
		do ACRTRAN(.dep, .ln, .ttx, 1, .TAMT, .DRCR) quit:ER
		do POSTTRAN(.dep, .ln, .ttx, 0, TAMT, 'DRCR) quit:ER
		}
	
	// Post negative interest
	if dep.negacr do { quit:ER
		set TAMT = dep.negacr
		do ACRTRAN(.dep, .ln, .ttx, 4, .TAMT, .DRCR) quit:ER
		do POSTTRAN(.dep, .ln, .ttx, 3, TAMT, 'DRCR) quit:ER
		}
	
	// Post negative interest unauthorized 
	if dep.negacrun do { quit:ER
		set TAMT = dep.negacrun
		do ACRTRAN(.dep, .ln, .ttx, 6, .TAMT, .DRCR) quit:ER
		do POSTTRAN(.dep, .ln, .ttx, 5, TAMT, 'DRCR) quit:ER
		}
	
	// Post uncollected interest
	if dep.uncacr do { quit:ER
		set TAMT = dep.uncacr
		do ACRTRAN(.dep, .ln, .ttx, 7, .TAMT, .DRCR) quit:ER
		do POSTTRAN(.dep, .ln, .ttx, 8, TAMT, 'DRCR) quit:ER	
		}
	
	quit

	
ACRTRAN(RecordDEP dep,		// Deposit account			/REF:RW
        RecordLN ln,		// Loan account				/REF:RW
        RecordTTX ttx,		// Primary transaction			/REF:R
        Number TCCTL,		// Control variables
        Number TAMT,		// Transaction amount			/REF:RW
        Boolean DRCR)		// Debit/credit indicator		/REF:W
	
	/*
	Build/post interest accrual reduction transaction
	
	Additional notes on ARGUMENTS
		. TCCTL	  Control variables
	
		  1 - Adjust (positive) interest/dividend accrual
		  4 - Adjust negative (authorized) interest accrual
		  6 - Adjust negative unauthorized interest accrual
		  7 - Adjust negative uncollected interest accrual	  
	*/
	
	type public Number CID, DIRECT, EXACTACR, PRTYPE, ZAMT
	type public String ETC, TSO
	type public Boolean ER

	set EXACTACR = TAMT
	
	// Flip DR/CR indicator and reset TAMT if necessary
	if TCCTL = 1 do {
		// Positive accrual < 0 is a credit to escrow
		if TAMT < 0 set DRCR = 1, TAMT = -TAMT
		set DRCR = 0
		}
	if TCCTL '= 1 do {
		// Negative accrual < 0 is a debit to escrow
		if TAMT < 0 set DRCR = 0, TAMT = -TAMT
		set DRCR = 1
		}
	
	set TSO = $$FIELDIN^UTSO(TSO, "EXACTACR", EXACTACR)

	set TAMT = TAMT.roundCur(ln.crcd)
	
	if DIRECT = 1 do {  quit:ER
		set ETC = $$DETC(PRTYPE, TCCTL, DRCR) quit:ER
		set TSO = $$FIELDIN^UTSO(TSO, "SGAA", 0)
		set ZAMT = TAMT
		}
	else  set ETC = $$LETC(PRTYPE, TCCTL, DRCR) quit:ER
	
	do POST^LNTRB(.ttx, CID, ETC, TAMT, %EffectiveDate.get(), %UserStation, TSO, "", dep.crcd) quit:ER
		 
	quit
	
	
POSTTRAN(RecordDEP dep,		// Deposit account			/REF:RW
	 RecordLN ln,		// Loan account				/REF:RW
         RecordTTX ttx,		// Primary transaction			/REF:R
         Number TCCTL,		// Control variables
         Number TAMT,		// Transaction amount
         Boolean DRCR)		// Debit/credit indicator
	
	/*
	Build/process interest posting transaction
	
	Additional notes on ARGUMENTS:
	
		. TCCTL	  Control variables
	
		  0 - Post (positive) interest/dividend
		  3 - Post negative interest
		  5 - Adjust negative (authorized /unauthorized) interest charged
		  8 - Adjust negative uncollected interest charged
	*/
	
	type public Boolean ER
	type public Number CID, DIRECT, EXACTACR, PRTYPE, SEQ, TSO, ZAMT
	type public String ETC

	set TSO = $$FIELDIN^UTSO(TSO, "EXACTACR", EXACTACR)
	
	if DIRECT = 1 do {  quit:ER
		set ETC = $$DETC(PRTYPE, TCCTL, DRCR)  quit:ER
		set TSO = $$FIELDIN^UTSO(TSO, "SGAA", 0)
		set ZAMT = TAMT
		}
	else  set ETC = $$LETC(PRTYPE, TCCTL, DRCR) quit:ER
	
	do POST^LNTRB(.ttx, CID, ETC, TAMT, %EffectiveDate.get(), %UserStation, TSO, "", dep.crcd) quit:ER
	
	quit
	

public	DELESC(Number CID)		// Loan account number

	// Delete closed escrow accounts for a single loan account
	
	type Number ECID, ELENUM = 0
	type String ESC
	
	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0", "CID=:CID")

	// Get escrow account
	for  set ESC = $$ESCACT^BILFUNCS(.lnbil0, .ELENUM) quit:ESC.isNull()  do {
		set ECID = ESC.piece($char(9), 1)	
		// Delete it if closed
		do Db.delete("DEP", "CID=:ECID AND STAT=4")
		}
	
	quit 


public	CHGESC(Number OCID,		// Old loan account number
	       Number NCID)		// New loan account number

	/*
	Change escrow account AREF number (loan account reference)
	
	OUTPUT:
		ER	Error code

	EXAMPLE:
		do CHGESC(123,456)

	*/

	type Number ECID, ELENUM = 0
	type String ESC

	/*
	Use new CID to get information since key change will have already
	moved LN related data
	*/
	
	// Get escrow account
	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0", "CID=:NCID")

	for  set ESC = $$ESCACT^BILFUNCS(.lnbil0, .ELENUM) quit:ESC.isNull()  do {
		set ECID = ESC.piece($char(9), 1)
		// Change loan acct ref
		do Db.update("DEP", "AREF=:NCID", "CID=:ECID")
		}

	quit 



public	GETBILPE(Number CID,		// Loan Account number			
                 Number SCHSEQ,		// Bill sequence Number
                 String DITEMS,		// Data item name acronym
                 String DITEMT)		// Data item name for Bill total ditems
        
	/*
	Select LNBIL1 repeating payment elements and control fields
        
	The lnbil1 object is passed to the function BIL1ELE^BILFUNCS to 
	retrieve LNBIL1 elements. The data is returned delineated with a tab.
	
	Additional notes on ARGUMENTS:
		. DITEMS  Data item element acronym for name "," delineated
			  return all 20 of the repeating payment element fields

	RETURNS:
		. $$ List of LNBIL1 items CDIB,CTAB followed by 20 of the
		  repeating payment element fields. All fields tab delineated.
		  
	OUTPUT:
		ER Error code
	
	EXAMPLE:
		S data=$$GETBILPE(CID,SCHSEQ,"EA,AD","CDIB,CTAB")
		returns LNBIL1 data items tab delineated in the following order
		CDIB,CTAB,PE01EA,PE01AD,PE02EA,PE02AD....PE20EA,PE20AD
	*/

	type literal String TAB = $char(9)
	
	type String DATA, RETURN = ""
	type Number DATALEN, DILEN, I, J, Z
	
	type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:CID,SCHSEQ=:SCHSEQ",1)
	if lnbil1.getMode()=0 quit RETURN  // KS CR26075 
	set DATA = $$BIL1ELE^BILFUNCS(.lnbil1)

	set DITEMT=DITEMT.get()  // KS CR26075 
	set DIITEMS=DITEMS.get() // KS CR26075
	set DATALEN = DITEMT.length(",")
	
	for Z = 1:1:DATALEN do {
		if DITEMT.piece(",", Z) = "CASD" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 1) quit
		if DITEMT.piece(",", Z) = "CBCD" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 2) quit
		if DITEMT.piece(",", Z) = "CDPD" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 3) quit
		if DITEMT.piece(",", Z) = "CTAB" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 4) quit
		if DITEMT.piece(",", Z) = "CPID" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 5) quit
		if DITEMT.piece(",", Z) = "CPIB" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 6) quit
		if DITEMT.piece(",", Z) = "COPB" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 7) quit
		if DITEMT.piece(",", Z) = "COIA" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 8) quit
		if DITEMT.piece(",", Z) = "CDIB" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 9) quit
		if DITEMT.piece(",", Z) = "CIRN" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 10) quit
		if DITEMT.piece(",", Z) = "CSUBAMT" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 11) quit
		if DITEMT.piece(",", Z) = "CSUBDUE" set RETURN = RETURN_TAB_DATA.piece(TAB, 1).piece("#", 12)
		}
	
	set RETURN = RETURN.extract(2, 999)
	set DATALEN = DATA.length(TAB)

	for I = 2:1:DATALEN quit:DATA.piece(TAB, I).isNull()  do {

		set DILEN = DITEMS.length(",")
		for J = 1:1:DILEN do {
			if DITEMS.piece(",", J) = "EA" set RETURN = RETURN_TAB_DATA.piece(TAB,I).piece("#", 1) quit
			if DITEMS.piece(",", J) = "DA" set RETURN = RETURN_TAB_DATA.piece(TAB,I).piece("#", 2) quit
			if DITEMS.piece(",", J) = "AB" set RETURN = RETURN_TAB_DATA.piece(TAB,I).piece("#", 3) quit
			if DITEMS.piece(",", J) = "AD" set RETURN = RETURN_TAB_DATA.piece(TAB,I).piece("#", 4) quit
			if DITEMS.piece(",", J) = "LA" set RETURN = RETURN_TAB_DATA.piece(TAB,I).piece("#", 5)
			}
		}
		
	if DITEMT.isNull() set RETURN=RETURN.extract(2,999)  //KS CR26075
	quit RETURN
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60710^36770^Keith Shank^20637"	// Signature - LTD^TIME^USER^SIZE
