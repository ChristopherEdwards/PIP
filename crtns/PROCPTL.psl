PROCPTL	 /* 
    ORIG: JERUCHIMC - 02/24/2000
    DESC: Commercial Participation Loan procedure
   
    ---- Comments -----------------------------------------------------------
   
    ---- Revision History ---------------------------------------------------

	07/13/06 - KELLYP - CR 22174
		   Corrected operator precedence warnings.

	03/31/06 - BHOLT - CR19735
		   Added the call to OPTOFF in PRIPROC2 section and the 
		   section OPTOFF which creates normal vobj reference 
		   and optimizes off the object and solving the 
		   undefined erorr vobj(dep) coming in DBI3 auto suite.
		   
	01/03/06 - chhabris - CR18008
		   Code clean up for DBI3.

	11/23/05 - chhabris - CR18008
		   Replaced depricated methods. Also, removed the revision 
		   history prior to 2004.

     -------------------------------------------------------------------------
 
 */

	quit

public	MLSP(RecordLN lnbas,RecordTTX ttx,RecordTRN trn)
	/* Misc Loan Sale Posting
	Entry point for Misc. loan sale posting transactions.
	(Not for normal priority method or disbursements)
	*/
	
	// If we already processed this, quit now.
	if $G(MLSP)=1 quit
 	new ACCOUNT,BASELN,CRCD,LN,MLSP,ORIGAMT,TCSARP,TCSARL,TLO
	set MLSP=1
 	set BASELN=CID
 	set CRCD=ttx.crcd
 	set TAMT=ttx.tamt
 	set TAMT=$P(TAMT,"#",1)
 	if TAMT'=0 set ER=1,RM="0 "_$$^MSG(283) quit
 	// if no currency is specified in the transaction, then it is the base currency.
 	if CRCD="" set CRCD=%SystemCurrency

	set TLO=ttx.tlo

	// Get base loan 
	set ORIGAMT=lnbas.balcmp-lnbas.tcsa+lnbas.tcrp-lnbas.tcsl+lnbas.tcrl
	if '(ORIGAMT>0) quit 
	set PCFL30=2
	set IUDBAL=0
	// Create secondaries
 	do PRIPROC2(.lnbas,.ttx,.trn)
	if $G(ER)=1 quit
	// reset LN.TCSA
	set lnbas.tcsa=lnbas.tcsa+TCSARP
	// reset LN.TCSL
	set lnbas.tcsl=lnbas.tcsl+TCSARL 
	set ECINF=ttx.lnerc
	set $P(ECINF,"#",34)=TCSARP
	set $P(ECINF,"#",42)=TCSARL
	set ttx.lnerc=ECINF

	// Call to ^LNPTS2 to post secondaries
	set %EffectiveDate=ttx.efd
	if %EffectiveDate="" set %EffectiveDate=%SystemDate
	do MLSPENTR^LNPTS2(.lnbas,.ttx,.trn)
	quit 

PRIPROC(RecordTTX ttx,RecordTRN trn,PCFL30)
	/* Priority Method Processing
	This section of code handles the processing for priority method
	payment,disbursements, and loan sale postings.
	*/
	
	// Start with a fresh LN array
        
	// For directed transactions...
	if (PCFL30>2) do MAINDT(.ttx,PCFL30)  quit 
	new ACCOUNT,BASELN,CRCD,ORGAMT,ORIGAMT,ORIGINT,TLO

	new %EffectiveDate

	/* EXPLAINATION OF VARIABLES:
	INCD is the investor code 
	PL is pool
	BASELN is the base loan account
	DPPER is disbursement/payment percentage
	WASH is the wash account
	DPAR is the disburesement/payment array 
	ORIGAMT is the original amount of the disbursement
	UDRAMT is the undisbursed/unremitted amount
	LEAD represents LNLS1.LEADINST for the investor
	LEADFND specifies if we have found a lead investor in this transaction
	TCSARP is Total Commercial Sold Amount/Remittance Paid
	TCSARL is Total Commercial Sold/Remittance Paid for the lead investor
	ADP is adjusted percentage factor.  
	It is used to adjust percentages during reiteration of
	the main loop.  For instance, if ADP=.5, then 30% becomes 60% (.3/.5)
	NADP is new ADP, which is reset for each new priority code level
	NADP and ADP are used for pro-rata calculations when a priority code
	is used more than once.  
	PRICODE is the priority code
	PRIUFL specifies if a priority level is unfulfilled
	BPRIN and UBPRIN specify billed and unbilled principal amounts
	PRIMSEQ is the primary sequence number for the TR array.
	ORIGINT is the original interest amount being paid.
	*/

	// Get account number of base loan, amount and currency of transaction
	set BASELN=ttx.cid
	set ORGAMT=ttx.tamt

	// Get base loan record
        type RecordLN lnbas
        set lnbas=Db.getRecord("LN","CID=:BASELN")

	set ORIGAMT=$P(ORGAMT,"#",1) 
	if PCFL30=1 set ORIGAMT=$P(ORGAMT,"#",2),ORIGINT=$P(ORGAMT,"#",3) // Use Principal/Interest amount - ARQ 47023
	if lnbas.aruf=1,lnbas.revf=1,PCFL30=1 set ORIGAMT=$P(ORGAMT,"#",5)
	if ORIGAMT="" set ORIGAMT=0
	if $G(ORIGINT)="" set ORIGINT=0
	set CRCD=ttx.crcd
	set %EffectiveDate=ttx.efd

	// if no currency is specified in the transaction, then it is the base currency.
	if CRCD="" set CRCD=%SystemCurrency
	set TLO=ttx.tlo
 
	/* Turn off IUDBAL processing mode.
	We are processing transactions, not just making calculations
	*/
	set IUDBAL=0
	do PRIPROC2(.lnbas,.ttx,.trn)
	quit	


PRIPROC2(RecordLN lnbas,RecordTTX ttx,RecordTRN trn)

	new CBLTOT,CBLORG,BAL,DISPER,DPAR,INCD,ITC,POOL,TAMT,WASH,WASHTC,WASHTYP
	new ADP,BALCMP,CBL,DATA,LEAD,LEADFND,TSO,UDRAMT
	new DPPER,IDPTC,LEADDN,LEADINV,LEADLIM,PRIUFL,PRICODE,TCSL,TCRL
	new BPRIN,BLSEQ,CBLTYPE,FINPLS,NBS,UBPRI

	// Get base loan's balance, Sold Amount, and Remittance Paid.
	set BALCMP=lnbas.balcmp
	set TCSL=lnbas.tcsl
	set TCRL=lnbas.tcrl
	set TCSARP=0,TCSARL=0

	/* Use UDRAMT variable to track unsold portion of original disbursement
	or unremitted portion of original payment
	*/

	set UDRAMT=ORIGAMT
	set INCD="",CBLTOT=0,CBLORG=0

	// Set up DPAR array, and for a payment, pay interest due on CBLs.
	type ResultSet rs=Db.select("INCD,PL,GRP,DISPRI,PAYPRI","LNLS4C","CID=:BASELN","INCD,PL,GRP")
	while rs.next() do {
		
		set INCD=rs.getCol("INCD")
		set PL=rs.getCol("PL")
		set GRP=rs.getCol("GRP")

		// if this pool is not using remittance method 6, do nothing.
		type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:INCD,PL=:PL",1)
		if lnls2.getMode() set PICM=lnls2.picm
		else  set PICM=""
		if PICM'=6 quit 
        	
		// Get Disbursement/Payment Priority
       		if PCFL30=2 set PRICODE=rs.getCol("DISPRI")
       		if PCFL30=1 set PRICODE=rs.getCol("PAYPRI")

		if $G(PRICODE)="" set ER=1,RM=$$^MSG(4426) quit
    		set DPAR(PRICODE,INCD,PL)=""
		type RecordLNLS1 lnls1=Db.getRecord("LNLS1","INCD=:INCD",1)
		if lnls1.getMode() set LEAD=lnls1.leadinst
		else  set LEAD=""

		if LEAD.get()'=1 do {
			type RecordLNLS4 lnls4=Db.getRecord("LNLS4","INCD=:INCD,PL=:PL,GRP=:GRP,CID=:BASELN",1)
			if lnls4.getMode() set CBL=lnls4.contra
			else  set CBL=""
			
			type RecordLN lncbl
               		set lncbl=Db.getRecord("LN","CBL")

			// Set up array of limits for the CBLs
                	if PCFL30=1 set LIMCBL(INCD,PL)=lncbl.balcmp
			if PCFL30=2 set LIMCBL(INCD,PL)=lncbl.udbal
			set CBLTOT=CBLTOT+LIMCBL(INCD,PL)
			set CBLORG=CBLORG+lncbl.crlmt
			}

		/* If we are making a payment, pay the interest on the CBL now.
 	   	But skip this section for the lead investor. */
		if ($G(LEAD)'=1),(PCFL30=1) do {

			// Get the WASH account
			type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:INCD,PL=:PL",1)
			if lnls2.getMode() set WASH=lnls2.wash
			else  set WASH=""
        			
			type RecordLN lncbl=Db.getRecord("LN","CBL")
       				
			type RecordDEP washacc=Db.getRecord("DEP","WASH")

			/* Get the interest due, including current interest
		 	And then subtract the interest from the amount to remit.
			*/

			set DUIN=lncbl.duin
			set CBLTYPE=lncbl.type
			set CRCD=lncbl.crcd
			set WASHTYP=washacc.type
			if lnbas.duin>0,lnbas.duin>ORIGINT do {
				set DUIN=$$^SCARND(DUIN*(ORIGINT/lnbas.duin),,BASELN)	   	
				}
			// Simply use the DUIN amount.  We will not decrease UDRAMT here - 47023
			
        		// Get the interest due payment trancode from the product type
        		if '(DUIN>0) quit

		       	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:CBLTYPE",1)
		       	if prodctl.getMode() set IDPTC=prodctl.crpipd
			else  set IDPTC=""
		       		
			if IDPTC="" set ER=1,RM=$$^MSG(3699,"PRODCTL.CRPIPD",CBLTYPE) quit
		
			// don't include interest paid as part of the amount to distribute.
			set TSO=$$FIELDIN^UTSO("","PE","I")

			// post the interest payment
			do {
				new PCFL30
				do POST^LNTRB(.ttx,CBL,IDPTC,DUIN,%EffectiveDate,TLO,TSO,"",CRCD)
			   	}

			// Post the offset to the wash account
			type RecordPRODCTL prodctl1=Db.getRecord("PRODCTL","TYPE=:WASHTYP",1)
			if prodctl1.getMode() set WASHTC=prodctl1.crtrgp
			else  set WASHTC=""

			if WASHTC="" set ER=1,RM=$$^MSG(3699,"PRODCTL.CRTRGP",WASHTYP) quit
			do {
				new PCFL30
				do POST^LNTRB(.ttx,WASH,WASHTC,DUIN,%SystemDate,TLO,$G(TSO),"",CRCD)
				}
			}
		}	

	/* Now the DPAR array is built; loop through it to process transactions.
	The following code contains two loops for priority code because we will continue with one
	priority if it not fulfilled and there are remaining funds.
	*/

	if $G(ER)=1 quit 
	if $D(DPAR)=0 set ER=1,RM=$$^MSG(4261) quit
	set PRICODE=""
	set LEAD=0,LEADFND=0
 	kill FINPLS
	for  set PRICODE=$O(DPAR(PRICODE)) quit:PRICODE=""  do {
 		set NADP=1,PRIDONE=0  
 		for P=1:1 quit:PRIDONE=1  do {
			set ADP=NADP
			set NADP=0
			kill PRIUFL
			set INCD=""
			set PRIAMT=UDRAMT
			for  set INCD=$O(DPAR(PRICODE,INCD)) quit:INCD=""  do {
				set PL=""
				for  set PL=$O(DPAR(PRICODE,INCD,PL)) quit:PL=""  do {
						
					// if this pool is finished, do nothing.
					if $G(FINPLS(INCD,PL))=1 quit

					// There should only be one record per group.
		                	set GRP=""
                			type ResultSet rs3=Db.select("GRP,PAYPER,DISPER","LNLS4C","CID=:BASELN AND INCD=:INCD AND PL=:PL","GRP")
        				if rs3.next() do {
        					set GRP=rs3.getCol("GRP")

						// Get Disbursement/Payment Percentage
						if PCFL30=1 set DPPER=rs3.getCol("PAYPER")
						if PCFL30=2 set DPPER=rs3.getCol("DISPER")
        					}
        				
					// Lead Institution Processing
					type RecordLNLS1 lnls1=Db.getRecord("LNLS1","INCD=:INCD",1)
					if lnls1.getMode() set LEAD=lnls1.leadinst
					else  set LEAD=""
					
					/* if the the investor is a lead instituion 
				   	and we already found a lead insitution
				   	investor, and its not the same investor & pool, set an error.
					*/
					if (LEAD=1),(LEADFND=1),(($P(LEADINV,"|",1)'=INCD)!($P(LEADINV,"|",2)'=PL)) set ER=1,RM=$$^MSG(4219) quit
					
					if (LEAD=1) do {  quit
						/* Mark the lead as having been found,
					   	adjust undisbursed/unremitted amount
						*/
						set LEADFND=1
						set LEADINV=INCD_"|"_PL
						set TAMT=PRIAMT*((DPPER/100)/ADP)
						set TAMT=$$^SCARND(TAMT,,BASELN)

						/* Determine lead investor's limit
						For a payment, the limit to pay
						is simply what we've disbursed
						to the lead investor minus what we've paid him */
						if PCFL30=1 set LEADLIM=TCSL-TCRL
						
						/* For a disbursement, we need to take the original ownership amount (lnbas.crlmt-CBLORG)
						and subtract what has been sold to him (disbursed) already.
						Then, we'll add what we've paid to him if this is a revolving loan. */
						if PCFL30=2 do {
							set LEADLIM=lnbas.crlmt-CBLORG-TCSL
							if lnbas.revf=1	set LEADLIM=LEADLIM+TCRL				
							}
		
						// In any event, we need to subtract what we've processed on this transaction already 
						set LEADLIM=LEADLIM-TCSARL

						if (LEADLIM>TAMT)&((UDRAMT-TAMT)>0) do {
                                      	        	set PRIUFL=1
                                        	        set NADP=NADP+(DPPER/100)
                                                	}
                                        	else  set FINPLS(INCD,PL)=1
						if LEADLIM<TAMT set TAMT=LEADLIM
						if UDRAMT<TAMT set TAMT=UDRAMT
						set UDRAMT=UDRAMT-TAMT
						set LEADLIM=LEADLIM-TAMT
						if IUDBAL=1 set IUDAMT=IUDAMT+TAMT
						set TCSARL=TCSARL+TAMT
						} // do block
					
					// Get the CBL
                        		type RecordLNLS4 lnls4=Db.getRecord("LNLS4","INCD=:INCD,PL=:PL,GRP=:GRP,CID=:BASELN",1)
                        		if lnls4.getMode() set CBL=lnls4.contra
					else  set CBL=""

                        		type RecordLN lncbl
                        		set lncbl=Db.getRecord("LN","CBL")
				
					/* Calculate amount of loan to sell based on disbursement percentage multiplied
				   	by amount of the original disbursement. Or, for a payment, amount of priniciapl to
				   	remit based on payment percentage multipied by amount of the original payment.
        				*/
					set TAMT=PRIAMT*((DPPER/100)/ADP)
		
					/* Round the amount
					first get number of decimal places in the currency 
 					*/
					new CURDEC,CO
					set CO=%CompanyName
					type RecordCRCD crcd=Db.getRecord("CRCD","CO=:CO,CRCD=:CRCD",1)
					if crcd.getMode() set CURDEC=crcd.curdec
					else  set CURDEC=""

					// Normal rounding for all amounts over minimum currency unit
 					if TAMT>(1/(10**CURDEC)) set TAMT=$$^SCARND(TAMT,,CBL)

					// if amount is not zero, but less than minimum unit, use minimum unit.
					if TAMT'=0,(TAMT<(1/(10**CURDEC))) set TAMT=(1/(10**CURDEC))
  				
					// Get credit limit of CBL
       					set CBLLIM=LIMCBL(INCD,PL)

		  			/* If the credit limit of CBL has not been reached by the disbursement or
        	  			brought back to zero by the payment, mark priority level incomplete
          				and adjust NADP so our amounts will be correct when we go through this loop again.
                        	        otherwise mark the pool as finished, so if we go through loop again, we won't look at this pool 
					*/
					if (CBLLIM>TAMT)&((UDRAMT-TAMT)>0) do {
						set PRIUFL=1
						set NADP=NADP+(DPPER/100)
						}
					else  set FINPLS(INCD,PL)=1
				
					/* If balance of the CBL is less than amount calculated, adjust the
					amount to be the balance of the CBL.  We don't want to disburse more than the
                                   	the CBL's limit allows, nor do we want to remit more than is owed.
                                	*/
					if CBLLIM<TAMT set TAMT=CBLLIM			

        				// If for any reason the CBL balance is negative, reset to zero.
        				if TAMT<0 set TAMT=0
        				if TAMT=0 quit
				
					/* Reset the amount to disburse/remit if the remaining funds from the original
        			   	disbursement or payment is less than either the amount specified by the
        			   	cbl limit or the percentage multiplied by the original amount.
					*/
					if UDRAMT<TAMT set TAMT=UDRAMT
					if TAMT=0,($G(PRIUFL)'=1) set PRIDONE=1
					if TAMT=0 quit
		
					// For disbursements...
					if PCFL30=2,IUDBAL=0 do {

						// Disburse funds from CBL
						set CBLTYPE=lncbl.type
						type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:CBLTYPE",1)
						if prodctl.getMode() do {	
							set CBLTC=prodctl.drtrgp
							set TCMT=$$^MSG(7110)_" - "_BASELN	
							}
						else  set (CBLTC,TCMT)=""

						do {
                                                        new PCFL30
							do POST^LNTRB(.ttx,CBL,CBLTC,TAMT,%EffectiveDate,TLO,"",TCMT,CRCD)
                                                        }					
						}

					// For payments...
					if PCFL30=1,IUDBAL=0 do {
						/* We need to create two principal payment transactions,
        				   	one for billed principal, one for non-billed.
        				   	Determine billed and non-billed amounts.
						*/
						set BPRIN=0,UBPRIN=0
						set BPRIN=lncbl.unpr+lncbl.cupr
 						set BLSEQ=lncbl.schseq+1
						set NBS=lncbl.bseq

						do PBND

 						set BPRIN=BPRIN+PRIREM
						set UBPRIN=lncbl.balcmp-BPRIN

						// If the billed and unbilled amounts are greater than the uremitted amount...
						if (BPRIN+UBPRIN)>TAMT do {
							/* if the billed portion is larger than the amount to remit,
						   	just pay the amount to remit for billed principal , 
						   	and don't pay any unbilled principal.
						   	Otherwise, leave the billed amount alone,
						   	and pay the unbilled amount of the difference between
						   	the amount to remit and the billed amount. 
				 			*/
							if BPRIN>TAMT do {
								set BPRIN=TAMT
								set UBPRIN=0
								}
							else  set UBPRIN=TAMT-BPRIN
							}	
				
							// Pay the principal
							do PAYPRIN(.ttx,CBL)	
				
						}

					// Update undisbursed/unremitted amount by subtracting amount of transaction.
                                	set UDRAMT=UDRAMT-TAMT 

					// Update amount of limit used
					set LIMCBL(INCD,PL)=LIMCBL(INCD,PL)-TAMT

					// Adjust Total Commercial Sold Amount/Remittance Paid
					set TCSARP=TCSARP+TAMT
					
        				// Get Wash account number
					type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:INCD,PL=:PL",1)
					if lnls2.getMode() set WASH=lnls2.wash
					else  set WASH=""

        				// Build Debit/Credit to Wash account
					type RecordDEP dep=Db.getRecord("DEP","CID=:WASH",1)
					if dep.getMode() set WASHTYP=dep.type
					else  set WASHTYP=""

					if PCFL30=1 do {
						type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:WASHTYP",1)
						if prodctl.getMode() set WASHTC=prodctl.crtrgp
						else  set WASHTC=""
						}
		
					if PCFL30=2 do {
						type RecordPRODCTL prodctl1=Db.getRecord("PRODCTL","TYPE=:WASHTYP",1)
						if prodctl1.getMode() set WASHTC=prodctl1.drtrgp
						else  set WASHTC=""
						}

        				if WASHTC.get()="",PCFL30=2 set ER=1,RM=$$^MSG(3699,"PRODCTL.DRTRGP",WASHTYP) quit
					if WASHTC.get()="",PCFL30=1 set ER=1,RM=$$^MSG(3699,"PRODCTL.CRTRGP",WASHTYP) quit
					if ER.get()=1 quit
					if IUDBAL=0 do {
						new PCLF30
						do OPTOFF(.dep)
	 					}
				} // PL Loop
			} // INCD Loop

	  	// If the priority level is unfulfilled and there are still funds to sell/remit,
          	// go through loop again
	  	I ($G(PRIUFL)'=1)!(UDRAMT=0) set PRIDONE=1
          	I ($G(PRIUFL)=1)&(UDRAMT>0) set PRIDONE=0
		} // Priority Code loop
	}	 // Priority Code from DPAR for loop

 	if $G(ER)=1 quit

	// Transaction not processed. Not all funds applied. 
	if $D(DPAR)>0,UDRAMT>0,($G(IUDBAL)'=1) set ER=1,RM=$$^MSG(4172) quit
	if $D(DPAR)>0,UDRAMT>0,($G(IUDBAL)=1) set IUDAMT=0 quit
	quit

OPTOFF(RecordDEP dep)

	//creates normal vobj reference and optimizes off the object
	
	do POST^LNTRB(.ttx,WASH,WASHTC,TAMT,%SystemDate,TLO,"","",CRCD)
	quit
	
IUDBAL(BASELN)
	/* Return institution's unadvanced balance.
	Called externally to compute LN.IUDBAL.
	*/

	type Public Cache %CACHE()

	// First check if the loan is sold commercially.
	new GRP,INCD,IUDAMT,PICM,PL
	set INCD=""
	type ResultSet rs4=Db.select("INCD","LNLS4C","CID=:BASELN","INCD")
       	if rs4.next() set INCD=rs4.getCol("INCD")
	
	if INCD="" quit ""
	set PL=""
	type ResultSet rs5=Db.select("PL","LNLS4C","CID=:BASELN AND INCD=:INCD","PL")
	if rs5.next() set PL=rs5.getCol("PL")
	
	if PL="" quit ""
	type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:INCD,PL=:PL",1)
	if lnls2.getMode() set PICM=lnls2.picm
	else  set PICM=""
		
	if PICM'=6 quit ""
 
	// If so...,
	set IUDBAL=1
	set PCFL30=2
 
	// Get base loan record
	type RecordLN lnbas
	set lnbas=Db.getRecord("LN","BASELN")
	set BALCMP=lnbas.balcmp
	set ORIGAMT=lnbas.udbal
	set CRCD=lnbas.crcd
	if CRCD="" set CRCD=%SystemCurrency 
	set IUDAMT=0

	Type RecordTTX ttx=Class.new("RecordTTX")
	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")
	do PRIPROC2(.lnbas,.ttx,.trn)
	set IUDBAL=0
	quit IUDAMT

MAINDT(RecordTTX ttx,PCFL30)
	/* Entry point from LNPTS2
 	Main part for directed transactions
 	*/

 	new BASELN,CBLORG,CRLIM,CRCD,INCD,LEAD,LEADLIM,PL,%SystemDate,TLO,TSO
 	new CBL,data,CBLBAL,CRLMT,GRP,WASH,XINCD,XPL,XGRP

 	set BASELN=ttx.cid
 	set TSO=ttx.tso
 	set INCD=$$FIELD^UTSO(TSO,"INCD")
 	set PL=$$FIELD^UTSO(TSO,"PL")
 	set TLO=ttx.efd
 	set TAMT=ttx.efd
 	set TAMT=$P(TAMT,"#",1)
 	set CRCD=ttx.crcd

	// Get last key into LNLS4C
	set GRP=""

	// Investor Record not found for this account
	if (INCD="")!(PL="") S ER=1,RM=$$^MSG(4261) Q

	type ResultSet rs6=Db.select("GRP","LNLS4C","CID=:BASELN AND INCD=:INCD AND PL=:PL","GRP")
	if rs6.next() set GRP=rs6.getCol("GRP")
        		
	// Investor Record not found for this account
	if GRP.get()="" S ER=1,RM=$$^MSG(4261) Q 
 
	// Determine Wash account and CBL account
	type RecordLNLS4 lnls4=Db.getRecord("LNLS4","INCD=:INCD,PL=:PL,GRP=:GRP,CID=:BASELN",1)
	if lnls4.getMode() set CBL=lnls4.contra
	else  set CBL=""
	
	type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:INCD,PL=:PL",1)
	if lnls2.getMode() set WASH=lnls2.wash
	else  set WASH=""

	type RecordLNLS1 lnls1=Db.getRecord("LNLS1","INCD=:INCD",1)
	if lnls1.getMode() set LEAD=lnls1.leadinst
	else  set LEAD=""

	if (CBL.get().isNull())!(WASH.get().isNull()),LEAD'=1 set ER=1,RM=$$^MSG(4261) quit 

	// Create base loan object
        type RecordLN lnbas
        set lnbas=Db.getRecord("LN","BASELN")

	if LEAD=1 do {
		
		if PCFL30>3 set LEADLIM=lnbas.tcsl-lnbas.tcrl
		if PCFL30=3 do {
			// Determine CBLORG (original credit limit of CBLs)
	
			set XINCD="",CBLORG=0
			type ResultSet rs7=Db.select("INCD","LNLS4C","CID=:BASELN","INCD")
				if rs7.next()  set XINCD=rs7.getCol("INCD")
				
			for  quit:XINCD=""  do {
	                	set XPL=""
	                	type ResultSet rs8=Db.select("PL","LNLS4C","CID=:BASELN AND INCD=:XINCD","PL")
				if rs8.next() set XPL=rs8.getCol("PL")
					
        	        	for  quit:XPL=""  do {
					if (INCD'=XINCD)!(PL'=XPL) do {
						set XGRP=""
						type ResultSet rs9=Db.select("GRP","LNLS4C","CID=:BASELN AND INCD=:XINCD AND PL=:XPL","GRP")
        					if rs9.next() set XGRP=rs9.getCol("GRP")
												
                                		type RecordLNLS4 lnls4=Db.getRecord("LNLS4","INCD=:XINCD,PL=:XPL,GRP=:XGRP,CID=:XBASELN",1)
                               			if lnls4.getMode() set CBL=lnls4.contra
                                		else  set CBL=""

        					type RecordLN ln=Db.getRecord("LN","CID=:CBL",1)
        					if ln.getMode() set CRLIM=ln.crlmt 
						else  set CRLIM=""
        					
                                		set CBLORG=CBLORG+CRLIM	
						}
					}	// end of for loop	
				}  // end of for loop

				set LEADLIM=lnbas.crlmt-CBLORG-lnbas.tcsl
                 		if lnbas.revf=1 set LEADLIM=LEADLIM+lnbas.tcrl
				} // end of do block for PCFL30=3

			// Transaction amount exceeds the lead investor's limit
			I TAMT>LEADLIM S ER=1,RM=$$^MSG(5095)  Q
			S TCSARL=TAMT			
			} // end of do block for LEAD=1

	  if LEAD'=1 do {
	  	type RecordLN ln=Db.getRecord("LN","CID=:CBL",1)
		if ln.getMode() do {
	                set CBLBAL=ln.balcmp
        	        set CRLMT=ln.crlmt
			}
		else  set (CBLBAL,CRLMT)=""

                if PCFL30=3 do PTDD(.ttx,BASELN,INCD,PL,TAMT,%EffectiveDate,TLO,CRCD) quit
		if PCFL30=4 do PTPAY1(.ttx,BASELN,INCD,PL,TAMT,%EffectiveDate,TLO,CRCD) quit
		if PCFL30=5 do PTPAY2(.ttx,BASELN,INCD,PL,TAMT,%EffectiveDate,TLO,CRCD) quit
		}
	quit

PTDD(RecordTTX ttx,BASELN,INCD,PL,TAMT,%EffectiveDate,TLO,CRCD)

	/* Directed Disbursement
	Credit CBL and Debit Wash account
	*/

	// Cannot disburse to investor. Insufficient credit for CBL account
	if TAMT>(CRLMT-CBLBAL) set ER=1,RM=$$^MSG(4264) quit

	// Transaction Comment - Disburement for base loan
	set TCMT=$$^MSG(7110)_" - "_BASELN

	// Credit CBL account

	// Get Product Type
	type RecordLN ln=Db.getRecord("LN","CID=:CBL",1)
	if ln.getMode() set CBLTYPE=ln.type
	else  set CBLTYPE=""
  
	// Get Debit trancode (which should really be a credit)
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:CBLTYPE",1)
	if prodctl.getMode() set CBLTC=prodctl.drtrgp
	else  set CBLTYP=""
  
	if CBLTC="" set ER=1,RM=$$^MSG(3699,"PRODCTL.DRTRGP",CBLTYPE) quit
	do {
		new PCFL30
		do POST^LNTRB(.ttx,CBL,CBLTC,TAMT,%EffectiveDate,TLO,"",TCMT,CRCD)
 		}
	// Debit WASH account
 
	// Get Product Type
	type RecordDEP dep=Db.getRecord("DEP","CID=:WASH",1)
	if dep.getMode() set WASHTYP=dep.type
	else  set WASHTYP=""
 
	// Get Debit trancode (which should be in fact a debit)
	type RecordPRODCTL prodctl1=Db.getRecord("PRODCTL","TYPE=:WASHTYP",1)
	if prodctl1.getMode() set WASHTC=prodctl1.drtrgp
	else  set WASHTC=""

	if WASHTC="" set ER=1,RM=$$^MSG(3699,"PRODCTL.DRTRGP",WASHTYP)
	do {
		new PCLF30
		do POST^LNTRB(.ttx,WASH,WASHTC,TAMT,%SystemDate,TLO,"",TCMT,CRCD)
	   }
	set TCSARP=TAMT
	quit


PTPAY1(RecordTTX ttx,BASELN,INCD,PL,TAMT,%EffectiveDate,TLO,CRCD)
 
	/* Directed Principal Payment
	Debit CBL and Credit Wash account
	*/

	// Cannot remit to investor. Payment exceeds balance of CBL account.
	if TAMT>(CBLBAL) S ER=1,RM=$$^MSG(4265) quit

	new BPRIN,NBS,PRIREM,TSO,UBPRIN
	
	type RecordLN ln1
	set ln1=Db.getRecord("LN","CBL")
 
	set BLSEQ=ln1.schseq,NBS=ln1.bseq 
	set BPRIN=ln1.unpr+ln1.cupr
	set UBPRIN=ln1.balcmp-BPRIN
	do PBND
	set BPRIN=BPRIN+PRIREM
	if BPRIN>TAMT do {
		set BPRIN=TAMT
		set UBPRIN=0
		}
	else  set UBPRIN=TAMT-BPRIN

	do PAYPRIN(.ttx,CBL)

	// Credit WASH account 
 
	// Get Product Type
	type RecordDEP dep=Db.getRecord("DEP","CID=:WASH",1)
	if dep.getMode() set WASHTYP=dep.type
	else  set WASHTYP=""
 		
	// Get Credit trancode (which should be in fact a credit)
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:WASHTYP",1)
	if prodctl.getMode() set WASHTC=prodctl.crtrgp
	else  set WASHTC=""
 
	if WASHTC="" set ER=1,RM=$$^MSG(3699,"PRODCTL.CRTRGP",WASHTYP)
	do {
		new PCFL30
		do POST^LNTRB(.ttx,WASH,WASHTC,TAMT,%SystemDate,TLO,"",TCMT,CRCD)
		}
	set TCSARP=TAMT
	quit

PAYPRIN(RecordTTX ttx,CBL)

	// Get Product Type
	type RecordLN ln=Db.getRecord("LN","CID=:CBL",1)
	if ln.getMode() set CBLTYPE=ln.type
	else  set CBLTYPE=""
 
	// Get Transaction Code
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:CBLTYPE",1)
	if prodctl.getMode() set CBLTC=prodctl.crpipd
	else  set CBLTC=""
		
	if CBLTC="" set ER=1,RM=$$^MSG(3699,"PRODCTL.CRPIPD",CBLTYPE) quit
	set TCMT=""

	// pay billed principal
	set TSO=$$FIELDIN^UTSO("","PE","P")

	if BPRIN>0 do {
		new PCFL30	
		do POST^LNTRB(.ttx,CBL,CBLTC,BPRIN,%EffectiveDate,TLO,TSO,TCMT,CRCD)
  		}
	// Get Transaction Code
	
	type RecordPRODCTL prodctl1=Db.getRecord("PRODCTL","TYPE=:CBLTYPE",1)
	if prodctl1.getMode() set CBLTC=prodctl1.crtrpr
	else  set CBLTC=""
 
	if CBLTC="" set ER=1,RM=$$^MSG(3699,"PRODCTL.CRTRPR",CBLTYPE) quit
 
	// pay unbilled principal
	if UBPRIN>0 do {
		new PCFL30
		do POST^LNTRB(.ttx,CBL,CBLTC,UBPRIN,%EffectiveDate,TLO,"",TCMT,CRCD)
	 	}
	quit
 
PTPAY2(RecordTTX ttx,BASELN,INCD,PL,TAMT,%EffectiveDate,TLO,CRCD)
 
	// Directed Interest Due Payment
 
	// Debit CBL and Credit Wash account
 	new CBL,GRP,WASH
 
	// Get last key into LNLS4C
	set GRP=""
	type ResultSet zrs=Db.select("GRP","LNLS4C","CID=:BASELN AND INCD=:INCD AND PL=:PL","GRP")
        if zrs.next() set GRP=zrs.getCol("GRP")
 
	// Investor Record not found for this account
	if $G(GRP)="" S ER=1,RM=$$^MSG(4261) quit
 
	// Determine Wash account and CBL account
	type RecordLNLS4 lnls4=Db.getRecord("LNLS4","INCD=:INCD,PL=:PL,GRP=:GRP,CID=:BASELN",1)
	if lnls4.getMode() set CBL=lnls4.contra
	else  set CBL=""

	type RecordLN ln1=Db.getRecord("LN","CBL")
 
	type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:INCD,PL=:PL",1)
	if lnls2.getMode() set WASH=lnls2.wash
	else  set WASH=""
		
	if ($G(CBL)="")!($G(WASH)="") set ER=1,RM=$$^MSG(4261) quit
 
	// Cannot remit to investor. Payment exceeds interest due on CBL account.
	if TAMT>(ln1.duin+ln1.cuin) set ER=1,RM=$$^MSG(4266) quit  
 
	// Get Product Type
	type RecordLN ln=Db.getRecord("LN","CID=:CBL",1)
	if ln.getMode() set CBLTYPE=ln.type
	else  set CBLTYPE=""
 
	// Get Transaction Code
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:CBLTYPE",1)
	if prodctl.getMode() set CBLTC=prodctl.crpipd
	else  set PRODCTL=""
	
	if CBLTC="" set ER=1,RM=$$^MSG(3699,"PRODCTL.CRPIPD",CBLTYPE) quit

	set TSO=$$FIELDIN^UTSO("","PE","I")
	do {
		new PCFL30
		do POST^LNTRB(.ttx,CBL,CBLTC,TAMT,%EffectiveDate,TLO,TSO,TCMT,CRCD)
 		}

	// Get Product Type
	type RecordDEP dep=Db.getRecord("DEP","CID=:WASH",1)
	if dep.getMode() set WASHTYP=dep.type
	else  set WASHTYP=""
 
	// Get Transaction Code
	type RecordPRODCTL prodctl1=Db.getRecord("PRODCTL","TYPE=:WASHTYP",1)
	if prodctl1.getMode() set WASHTC=prodctl1.crtrgp
	else  set WASHTC=""
		
	if WASHTC="" set ER=1,RM=$$^MSG(3699,"PRODCTL.CRTRGP",WASHTYP) quit 

	do {
		new PCFL30
		do POST^LNTRB(.ttx,WASH,WASHTC,TAMT,%SystemDate,TLO,"",TCMT,CRCD)
 		}
	quit
  
  
PBND    
	/* Previously Billed/Not Due
	Sets PRIREM variable to amount of principal remaining on bills not due
	*/
	
	set PRIREM=0
	new J,I,payel
	for J=1:1 do {  quit:BLSEQ'<NBS        
		new bill,billex,FOUND
		type RecordLNBIL1 bill
		
		/* FOUND - did we find the principal element
		   PRIREM - principal remaining
		*/
		
		set bill=Db.getRecord("LNBIL1","CBL,BLSEQ")
		if +bill.cbcd=0 set BLSEQ=BLSEQ+1 quit
		set N=$$SUB^BILFUNCS("P",.bill) quit:N=""
		set PRIREM=PRIREM+$P(N,"#",4)
		set BLSEQ=BLSEQ+1
		}
 	quit
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60459^50284^Pat Kelly^27440"	// Signature - LTD^TIME^USER^SIZE
