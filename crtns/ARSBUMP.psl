public ARSBUMP	// Account Reconciliation
	/*
	   ORIG: Marty Ronky - (3623) 12/13/89

	   This routine allows the moving of a single check
	   or group of checks to another check number or
	   check range.

	  ---- Revision History ------------------------------------------------

	   07/28/06 - KELLYP - CR 22048
	   	      Modified INI2 section to elminate PRECEDENCE warnings.

	   06/14/06 - PUTTASWH - 21650
	   	      Modified POS2 section to pause until keyboard activity 
	   	      to make the message text visible to the user while
	   	      displaying the warning message.	   	     
	   
	   04/05/06 - PUTTASWH - 20535
	   	      Modified FILE section in order to save the check being
	   	      advanced starting with the next available successive 
	   	      number if the 'Thru check number' exists. Modified POS1
	   	      section to display the 'Invalid Range' message and POS2 
	   	      section to display the overlapping message after checking 
	   	      for the appropriate conditions. 	   
	   
	   11/07/05 - PUTTASWH - 17011	   	      
	  	      Modified INIT section to contain the code of VPG and 
	  	      VPG0 sections and removed VPG and VPG0 sections.
	   	      Modified POS2 section to verify the check numbers 
	   	      with in a given range. Modified VER, FILE and END
	   	      sections to reference FTOFST variable.  	   	      
	   	    
	   02/05/03 - GRAY - 51349
		      Removed quit from top of procedure and changed the
		      INIT line tag to not require an argument.  Native
		      function @ARS005 calls ARSBUMP from the top.

	   05/08/02 - GORDONT - 49794
                      Converted to PSL
                      Removed Pre-2000 revision history.
	
	   01/04/00 - GRAY - 32507
	              Changed call from POSCID^ARS to POSCID^ARSBUMP.  ARS.M
	              was obsoleted due to the Elimination of Teller/Branch
	              Character Interface.

	*/
	
	do INIT
	quit

INIT 	//Initialize standard variables
	
	type public String VFMQ	
	type Number OLNTB,%PAGE,%PG,%ProcessMode	
	
	set %ProcessMode=1 
	set %PG=0 
	set %PAGE=1
	
	kill OLNTB,VFMQ
	
	do VPG00
	
	if "DFQ"[VFMQ do VER quit
	set %PG=%PG+1
	
	do VPG01(.OLNTB)
	do VER
	
	quit

VPG00	// Entry for page 1
	
	type public Boolean ER
	type public String %NOPRMT,%READ,%TAB,VFMQ

	set %TAB("CID")=".CID1/XPP=D POSCID^ARSBUMP"

	set %READ="@@%FN,,,CID/REQ" set %NOPRMT="N"
	do ^UTLREAD if VFMQ="Q" set ER=1

	quit

POSCID	// Account number post-processor

	type public Boolean ER
	type public String %EXT,RM
	
	quit:X=""  
	set %EXT=1 
	set (CLS,ZCLS)="D" 
	do ^UACN quit:ER  

	set CID="" 

        type RecordDEP dep=Db.getRecord("DEP","CID=:X")	
	if dep.ars set CID=X quit

	// Account not set up for Account Reconciliation System
	set ER=1 set RM=$$^MSG(85)

	quit
	
	
VPG01(Number OLNTB)	// OLNTB	
	// Check Range
	
	type public Boolean ER
	type public String VFMQ
	
	do INI2(.OLNTB) 
	do ^UTLREAD
	if VFMQ="Q" set ER=1

	quit
	
	
INI2(Number OLNTB)	// OLNTB	
	// Initalize %TAB for a new bump.	
	
	type public String %READ,%TAB

	// Range to be Bumped
	set HDG1=$$^MSG(6375) set HDG1=$J("",(80-$L(HDG1))\2)_HDG1
	// Range to be Created
	set HDG2=$$^MSG(6376) set HDG2=$J("",(80-$L(HDG2))\2)_HDG2

	set %TAB("CKB")=".MIN1/TBL=[SYSDEV,ARS]"
	set %TAB("CKE")=".CKE2/TBL=[SYSDEV,ARS]/XPP=D POS1^ARSBUMP/MIN=<<CKB>>"
	set %TAB("CKNB")=".CKNB1/XPP=D POS2^ARSBUMP(OLNTB)"

	set %READ="@HDG1,,CKB/REQ,CKE/REQ,,,@HDG2,,CKNB/REQ"

	quit

POS1	// Ending Check post-processor

	new CKNO,I,Y	
	
	set Y=""
	set ER=0
	
	// Ending check number greater than or equal to starting check number
	if X<CKB set ER=1 set RM=$$^MSG(895) quit
	
	if X'=CKB do {
		set Y=CKB\1	

		type ResultSet rs=Db.select("CKNO","ARS","CID=:CID AND CKNO>:Y")
		while rs.next() do { quit:(Y>X)!(Y="")!(ER=1)
			set Y=rs.getCol(1)			
				
			if Y\1'=Y set ER=1 
			}
			
		// Check number ~p1 must be moved first
		if ER set RM=$$^MSG(534,Y) quit		
		}	

	// Invalid range.  Check number ~p1 missing.	
	for I=0:1 quit:CKB+I=X  do { quit:ER
		type RecordARS ars=Db.getRecord("ARS","CID,CKB+I",1)
		if 'ars.getMode() set ER=1 set RM=$$^MSG(1437,(CKB+I))
		}		

	/*
	Set RNG (range) to 0 if bumping one check, otherwise set RNG to
	the difference+1.
	*/
	set RNG=$S(X=CKB:0,1:X-CKB+1)

	quit

	
POS2(Number OLNTB)	// OLNTB
	// To Check post-processor	
	
	// Select new starting check number
	if X=CKB set ER=1 set RM=$$^MSG(2468) quit

	/*
	If the old range and new range are disjoint, assure no checks exists
	in the new range.
	*/
	
	new I,J,Z 
	set ER=0
		
	type ResultSet rs=Db.select("CKNO","ARS","CID=:CID AND CKNO<:X","CKNO DESC")
	if rs.next() set Z=rs.getCol("CKNO")

	if (((X>CKE)!((X+RNG)<CKB))&(Z.get())) do { 
		
		type ResultSet rs=Db.select("CKNO","ARS","CID=:CID AND CKNO>:Z")
		if rs.next() set I=rs.getCol("CKNO")
		
		}	
	
	// Invalid, check number ~p1 exists
	if I.get()&(I<(X+RNG)) set ER=1 if I&(I<(X+RNG)) set RM=$$^MSG(1516,I) quit		
	
	// Warning - ranges overlap	
	if (X>CKB)&(X<=CKE) write $$MSG^%TRMVT($$^MSG(2969),0,1) set OLNTB=22000 quit

	/*
	Ranges overlap, check part of range that doesn't overlap for existing
	checks, and give warning about overlap.
	*/
	
	set I=X-.01

	type ResultSet rs=Db.select("CKNO","ARS","CID=:CID AND CKNO>:I")
	while rs.next() do { quit:ER
	
		set I=rs.getCol(1)		
		quit:(I'<(X+RNG))
		// Invalid, check number ~p1 exists
		if (I<CKB)!(I>CKE) set ER=1 set RM=$$^MSG(1516,I) quit
		  
		}	
	
	quit

VER 	
	type Number FTOFST
	
	set FTOFST=0
	
	if ER!(VFMQ="Q") do END(FTOFST) quit
	do FILE(.FTOFST)
	do END(FTOFST)
	
	quit	
	
FILE(Number FTOFST)	// Offset Value
	// File data
		
	type Boolean FLG	
	type RecordARS ars
	
	// If only one check is being moved, just move one check to the other.
	if CKB=CKE do {  quit	
		
		set ars=Db.getRecord("ARS","CID=:CID,CKNO=:CKB")
		do ars.setAuditFlag(1)	
		set ars.ckno=CKNB
		do ars.save()
		
		}

	set FLG=0
	
	for  do {  quit:(FLG=1)		
		set ars=Db.getRecord("ARS","CID=:CID,CKNO=:CKNB",1)	
		if ars.getMode() set CKNB=CKNB+1
		else set FLG=1			
		}
	
	set FTOFST=CKNB-CKB	
	
	for I=CKB:1:CKE do {
				
		set ars=Db.getRecord("ARS","CID=:CID,CKNO=:I")	
		do ars.setAuditFlag(1)				
		set ars.ckno=ars.ckno+FTOFST
		do ars.save()
		
		}
	
	quit

END(Number FTOFST)	// Offset Value
	
	kill %TAB
		
	quit:ER  
	set ER="W"
	
	// Check number not incremented
	if VFMQ="Q" set RM=$$^MSG(531) quit

	// Account ~p1, checks ~p2 thru ~p3 incremented to checks ~p4 thru ~p5
	if CKE-CKB set RM=$$^MSG(7224,CID,CKB,CKE,CKNB,(CKE+FTOFST))
	
	// Account ~p1, check ~p2 incremented to check ~p3
	else  set RM=$$^MSG(7223,CID,CKE,CKNB)
	
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60477^65441^Pat Kelly^6288"	// Signature - LTD^TIME^USER^SIZE
