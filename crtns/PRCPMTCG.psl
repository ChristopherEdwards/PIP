public PRCPMTCG
	/*
	 ---- Revision History ------------------------------------------------

	12/12/06 - SANTHUMS - CR 22042
		   . Modified N1 Section to remove call to IP since it was 
		     going infinite loop.
		   . Removed if DIA="" quit since it has to process to 
                     Calculate remaining term.
		   . Modified TRM section to process if remaining Term Equals 
		     to Zero. If REMTRM<0 then only "Calculated Remaining Term 
		     Equals Zero" error message to be displayed. 
		    	
	10/31/06 - SANTHUMS - CR22420
		   Modified NM section to declare BAL as public.
		   Modified N1,IP sections to use NEW.get() to resolve undefined 
		   local variable on NEW.   	
	
	07/31/06 - KELLYP - CR 22048
		   Modified TRM, R1, and R3 sections to eliminate PRECEDENCE
		   warnings.
	 
	06/01/06 - KUMARB - CR 21464
		   Modified all the reference to PMTPI variable with ln.pmtpi
		   to resolve undefined error.

	05/09/06 - Dhanalakshmi R - 21105
		   Modified the section LNNOT to use Db.getRecord with getMode 
		   instead of Class.new for all 3 instances of DAYENDLNNOT.
 
	02/27/06 - KELLYP - CR 19777
		   Modified to correct compiler errors.

	01/22/04 - CARROLLJ - CR7989
		   Corrected parameter mismatch error.
	*/

	do NXTS
	
	quit

public NXTS	// Single Account entry
	
	new BAL,HIT,ICHND,IRNC,MDT,PCHLD,PCOFF,PDAT,TYPE
	new INTOFF,INTOFFCL,INTOFFDT
	set NEW=0
	
	// Obtain account variables
	type RecordLN ln=Db.getRecord("LN","CID=:CID")
	do PROC(.ln)
	quit

PROC(RecordLN ln)

	type public Number DONE
	
	if ln.stat=4 set DONE=2 do END1(.ln) quit

	type String TYPE,PCHLD,PCOFF
	
	set TYPE=ln.type
	
	set ICHND=ln.ichnd
	set PCHLD=ln.pchld
	set PCOFF=ln.pcoff,PCHND=EJD+PCOFF
 	
	set BAL=ln.bal
	if ln.ballamt set BAL=BAL-ln.ballamt
	set MDT=ln.mdt
	if %SystemDate<ln.odd!(%SystemDate>MDT) quit
  	if ICHND do {
		set X=$G(PCBD(CID,"ICHND",ICHND,CID)) 
		if X'="" set IRNC=$P(X,"|",3) quit
		type RecordLNVRCHG pcbdicn2 = Db.getRecord("LNVRCHG","ICHND,CID",1)
		if pcbdicn2.getMode() set IRNC=pcbdicn2.nrate
		else  set IRNC=""
		}
	else  set IRNC=+ln.irn
	set INTOFF=ln.intoff
	set INTOFFCL=ln.intoffcl
	set INTOFFDT=$$INTOFFDT^LNCDI(ICHND,INTOFF,INTOFFCL)
 	if INTOFFDT>TJD,'IRNC set IRNC=+ln.irn

	// Interest Rate Not Changed, No P+I Recalculation
	if IRNC="" set ER=1,ET=$$^MSG("4018") do LOGERR quit
	
 	if ln.aruf set BAL=BAL-ln.udbal
 	if ln.stat set DONE=1 do END1(.ln) quit

	// Account Has Zero Balance
	if 'ln.revf,'BAL,SING S DONE=1 do END1(.ln) quit
 	if 'ln.revf,'BAL set DONE=1 do END1(.ln) set ER=1,ET=$$^MSG("4048") do LOGERR quit
 	do NM(.ln)
	quit

public EXTERN(RecordLN ln,CTL) // Calculate new P&I for one account. Defines SING=1 to indicate
	  // that only one account is to be processed.
	
	set CTL=$G(CTL)
	
	set SING=1
	set EJD=%SystemDate
	set (SVPT,SVPMT,DONE,ER)=0,ET=""
	
	set ln.cid=CID

	do PROC(.ln)

	quit

NM(RecordLN ln)	// Common point to both normal processing and modeling.
	
	type public Number BAL
	type Number CALBAL,CALTRM,CNTC,DIAADJ,INTADJ,PCND,PINC,PMNDIC,PRADJ,TAMT
	type String DIST1FRE,DIST1AF
	type Date DIST1ND,LBDD
	
	set IACM=ln.iacm
	set ICM=ln.icm
	set PMTORG=ln.pmtorg
	set AMBAS=ln.ambas
	set ACR=ln.acr
	set BALLAMT=ln.ballamt

	// Zero Interest Rate, No Recalculation
	set IRN=+ln.irn if 'IRN set ER=1,ET=$$^MSG("4021") do LOGERR quit
	set ICPF=ln.icpf
	set IACF=ln.iacf
	
	set DIMXB=ln.dimxb
	set SCHND=+ln.schnd
	set SCHNUM=ln.schnum
 	set SCHLD=+ln.schld
 	set SCHSEQ=ln.schseq
 	set APCND=ln.apcnd
	set PCHLD=ln.pchld

	if '$D(%RAOFF) do {
		set PRCB=ln.prcb
		set TRMMX=ln.trmmx
		set INTFRE=ln.intfre
		set PMXDIC=ln.pmxdic
		set PMXDIL=ln.pmxdil
		set PMXDDC=ln.pmxddc
		set PMXDDL=ln.pmxddl
		set PMXPIC=ln.pmxpic
		set PMXPIL=ln.pmxpil
		set PMXPDC=ln.pmxpdc
		set PMXPDL=ln.pmxpdl
		set PMXDIY=ln.pmxdiy
		set PMXDDY=ln.pmxddy
		set PMXPIY=ln.pmxpiy
		set PMXPDY=ln.pmxpdy
		set PPINC=ln.ppinc
		set NUMCH=ln.numch
		set PCHM=ln.pchm
		set ANPTO=ln.anpto
		set CNTC=ln.cntc
		set PMNDIC=ln.pmndic
		set PMNDDC=ln.pmnddc
		}
	else  do {
		set (PRCB,TRMMX,INTFRE,PMXDIC,PMXDIL,PMXDDC)=""
		set (PMXDDL,PMXPIC,PMXPIL,PMXPDC,PMXPDL,PMXDIY,PMXDDY)=""
		set (PMXPIY,PMXPDY,PPINC,NUMCH,PCHM,ANPTO,CNTC,PMNDIC,PMNDDC)=""
		}

	set DIST1ND=ln.dist1nd
	set DIST1FRE=ln.dist1fre
	set DIST1AF=+ln.dist1af
	set LBDD=+ln.lbdd if 'LBDD set LBDD=SCHLD
	
	// Capitalize deferred interest?
	set TAMT=ln.diu
	if TAMT,ln.namxb'="",BAL+TAMT>ln.namxb set TAMT=ln.namxb-BAL set:TAMT<0 TAMT=0
	set (CALBAL,BAL)=BAL+TAMT
	//if BALLAMT set CALBAL=CALBAL-BALLAMT
	set CALTRM=""
	
	// Calculate balance to be used for recalculation 

	set (PINC,INTADJ,DIAADJ,PRADJ)=0
	if PRCB=1 do TRM(.ln) quit
	
	if $d(%RAOFF) set PCND=ln.rand
	else  set PCND=ln.pchnd
	set SVPMTPI=ln.pmtpi
	
	// If loan determines interest at payment determine amount remaining.
	if ln.idp do BL1(.ln) quit
	
	// IDP = 0 loans
	if LBDD'=SCHND set X=0 do CALBAL(.ln) quit
	set schedseq=SCHSEQ+1
	type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID,schedseq")
	set X=$$AMTDUE^BILFUNCS(.lnbil1,"P")
	do CALBAL(.ln)
	quit


CALBAL(RecordLN ln)	//

	//If cupr is negative don't include it in the calculation
	set PRADJ=ln.cupr+ln.unpr+X I ln.cupr<0 set PRADJ=PRADJ-ln.cupr
	set CALBAL=BAL-PRADJ
	set JD=LBDD I LBDD'<SCHND set SCHNUM=SCHNUM+1
	if 'ICM,(LBDD'<ICHND!(LBDD'<PCHND)) set SCHNUM=ln.dseq-1 do DIA(.ln) quit	// DJH 01/24/01

	new GETOUT
	set GETOUT=0
	for  do { QUIT:ER!(GETOUT)
		set NJD=$$NJD^UFRE(JD,DIST1FRE) if ER do LOGERR quit
		set NDD=NJD
	
		if ICHND'="",NDD>ICHND,IRNC set IRN=IRNC
		// Interest Rate Not Changed, No P+I Recalculation
		if ICHND'="",NDD>ICHND,'IRNC set ER=1,ET=$$^MSG("4018") do LOGERR quit
	
		
		/*
		 If the loan is interest in advance, and we have reached
		 (but not considered) the due date associated with the 
		 payment change, stop because the next payment will be 
		 the new one.
		*/
		if ICM,(NDD>ICHND!(NDD>PCHND)) set GETOUT=1 quit
	
		set %LD=JD,%ND=NJD-1,%BAL=CALBAL	;ACM 37051:02
		set %INT=$$^UIC(%BAL,%LD,%ND,IACM,IRN,1,DIST1AF,DIST1FRE,ICPF,SCHND,SCHLD)
		if %INT'=(%INT\1) set %INT=$$^SCARND(%INT,0,$G(CID),"","","+")
	
		set INTADJ=INTADJ+%INT
		set PR=ln.pmtpi-%INT if PR<0 set PR=0
		if PR'<CALBAL set CALBAL=PR
		set CALBAL=CALBAL-PR,PRADJ=PRADJ+PR
		set SCHNUM=SCHNUM+1
		/*
		 If the loan is not interest in advance, and we have 
		 considered the due date associated with the payment 
		 change, stop because the next payment (the one after
		 the change date) will be the new one.
		*/
		if 'ICM,(NDD'<ICHND!(NDD'<PCHND)) set GETOUT=1 quit
	
		do UD(.ln) if ER quit
		set JD=NDD
		}
	if GETOUT do DIA(.ln)
	quit	
	
UD(RecordLN ln)	// Update IRN for new rates and P+I for new payment amounts
	
	set ER=0
	if PINC,ICM,NDD>PCND set ln.pmtpi=PINC
	if PINC,'ICM,NDD'<PCND set ln.pmtpi=PINC
	
 	if PCND=NDD do {
		set PCND=$$NJD^UFRE(PCND,ln.pcfre) do:ER LOGERR quit:ER
		set X=$G(PCBD(CID,"PCHND",PCND,CID))
		if X'="" set PINC=$P(X,"|",3) quit
		type RecordLNPTCHG pcbpchnd=Db.getRecord("LNPTCHG","PCHND,CID",1)
		if pcbpchnd.getMode() set PINC=pcbpchnd.npmt
		else  set PINC="" 
		}

 	if ICHND<PCHND,ICHND=NDD do {
		set ICHND=$$NJD^UFRE(ICHND,INTFRE) do:ER LOGERR quit:ER
		set X=$G(PCBD(CID,"ICHND",ICHND,CID)) 
		if X'="" set IRNC=$P(X,"|",3) quit
		
		type RecordLNVRCHG pcbdicn2=Db.getRecord("LNVRCHG","ICHND,CID",1)
		if pcbdicn2.getMode() set IRNC=pcbdicn2.nrate
		else  set IRNC=""
		}
	quit
	
	
	// Determine principal amount remaining in bill file.
	
BL1(RecordLN ln)	//

	set PR=1
	type DbSet ds=Db.selectDbSet("LNBIL1","CID=:CID","SCHSEQ DESC")
	while ds.next() do { quit:SEQ=1!('PR)

		type RecordLNBIL1 lnbilrec=ds.getRecord("LNBIL1")
		
		if lnbilrec.cdpd>SCHND,lnbilrec.cdpd'>PCHND set SCHNUM=SCHNUM+1

		// If the bill is in the future, we don't want 
		// to include it's principal.
		if lnbilrec.cdpd>PCHND quit

		// Once we hit zero due, go on.
		set PR=lnbilrec.cirn I 'PR quit
		set PRADJ=PRADJ+PR
		}
	do ACR(.ln)
	quit
	
	
ACR(RecordLN ln)	// Calculate interest using current accrual balance
	
	
	set INTADJ=0,JD=SCHND
	set %LD=TJD,%ND=JD-1,%BAL=ln.balint
	set %INT=$$^UIC(%BAL,%LD,%ND,IACM,IRN,0,DIST1AF,DIST1FRE,ICPF,SCHND,SCHLD)
	if %INT'=(%INT\1) set %INT=$$^SCARND(%INT,0,$G(CID),"","","+")
	set P=$$^SCARND(ACR,0,$G(CID))+%INT
	set JD=LBDD,SCHNUM=SCHNUM+1
	if LBDD<SCHND set P=P-ln.pmtpi,JD=SCHND
	set CALBAL=BAL-PRADJ+P
	set PRADJ=PRADJ+P,INTADJ=%INT
	 
	set FRE=DIST1FRE 
	for  set NJD=$$NJD^UFRE(JD,FRE) do:ER LOGERR quit:NJD>PCHND!(ER)  do { if ER quit
		set NDD=NJD
	
		if ICHND'="",NDD>ICHND,IRNC set IRN=IRNC
		//Interest Rate Not Changed, No P+I Recalculation
		if ICHND'="",NDD>ICHND,'IRNC set ER=1,ET=$$^MSG("4018") do LOGERR quit
	
		// Paid in advance
		if DIST1ND>NJD set JD=NJD quit
		set %LD=JD,%ND=NJD-1,%BAL=CALBAL
		set %INT=$$^UIC(%BAL,%LD,%ND,IACM,IRN,0,DIST1AF,DIST1FRE,ICPF,SCHND,SCHLD)
		if %INT'=(%INT\1) set %INT=$$^SCARND(%INT,0,$G(CID),"","","+")
		set CALBAL=CALBAL+%INT-ln.pmtpi
		set PRADJ=PRADJ+ln.pmtpi-%INT,INTADJ=INTADJ+%INT
		set SCHNUM=SCHNUM+1

		do UD(.ln) if ER quit
	
		set JD=NDD
		}
	if ER quit
	do DIA(.ln)
	quit
	
	
DIA(RecordLN ln)	// Multiply DIA in current bill by # of bills to next change date
	
	new N
	set N=0
	set ln.pmtpi=SVPMTPI
	set JD=TJD,FRE=DIST1FRE
	for  set NJD=$$NJD^UFRE(JD,FRE),N=N+1 do:ER LOGERR quit:NJD'<PCHND!(ER)  set JD=NJD
	type RecordLNBIL1 bilrec=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:ln.bseq",1)
	set DIA=bilrec.cdib	
	set DIAADJ=N*DIA
	set CALBAL=CALBAL+DIAADJ
	do TRM(.ln)
	quit
	
TRM(RecordLN ln)	// Calculate remaining term - pre term adjustment
	
	set REMTRM=AMBAS-SCHNUM
	// Calculated Remaining Term Equals Zero
	if REMTRM<0 set ER=1,ET=$$^MSG("4212") do LOGERR quit
	
	// Calculate interim P+I
	
	// GEM and IEM loans
	if PCHM=2!(PCHM=3) set PPINC=PPINC/100,NPMT=$$^SCARND((1+PPINC)*ln.pmtpi,0,$G(CID)),SVPT=NPMT do ITRM(.ln) quit
	
	/*
	 When PCHM=4, a new P&I payment is only calculated if the interest
	 rate has changed since the payment change last date.  To get the
	 interest rate associated with the payment change last date, go to
	 global PCBD("PCHND",PCHLD,CID).  This may or may not be defined.  This
	 depends how far back the PCHLD is and how often the client purges
	 its PCBD global.  If global PCBD("PCHND",PCHLD,CID) is there, get its
	 interest rate and compare it to the current interest rate.  If the
	 rates are different, then calculate a new P&I payment.
	 If global PCBD("PCHND",PCHLD,CID) is not there, then check if PCHLD is
	 equal to ODD (original disbursement date).  If it is then compare
	 IRO (original interest rate) to the current interest rate.  If the
	 rates are different, then calculate a new P&I payment.
 	 If globalPCBD("PCHND",PCHLD,CID) is not there and PCHLD'=ODD, then 
	 there really is no way to determine if the interest rate has changed
	 since the payment change last date.  Therefore a new P&I payment has to
	 be calculated.
	*/
	
	set HIT=""
        I PCHM=4 do {
		if PCHLD="" set PCHLD=ln.odd
		type RecordLNPTCHG pcbpchn3=Db.getRecord("LNPTCHG","PCHLD,CID",1)
		if pcbpchn3.getMode()=0 set PDAT="" quit
		if pcbpchn3.irn-IRNC'=0 set HIT=1

		if HIT quit
		if PDAT="" do {
			if PCHLD=ln.odd,ln.iro-IRNC=0 quit
			set HIT=1
			}
		}
	
	if PCHM=4,'HIT set (SVPT,NPMT)=ln.pmtpi do RESET(.ln) quit
	
	// Use standard P&I calculation utility
	set PIACM=ln.piacm
		
	set LD=$G(JD),ND=$G(NJD)-1
	if LD="" set LD=SCHLD		// 40100
	if 'ND set ND=SCHND

	if 'PIACM set P=$$PMT^UFINC(CALBAL,IRNC,REMTRM,DIST1AF)
	else  set P=$$PI^UFINC(CALBAL,IRNC,REMTRM,0,PCHND,IACM,DIST1FRE,"",DIST1AF)	// JMH - 05/18/01
	
	if BALLAMT do {
		set P=P+$$^UIC(BALLAMT,LD,ND,"00",IRNC,1,DIST1AF,DIST1FRE,ICPF,SCHND,SCHLD)
		if P<0 set P=BAL+BALLAMT set (BAL,CALBAL)=0
		}
	set PMT=$$^SCARND(P,0,$G(CID)),SVPT=PMT
	if (MDT=LD)&(BALLAMT'="") set PMT=PMT+BALLAMT	// JMH - 10/25/00

	do N1(.ln)
	quit
	
	
NEW(RecordLN ln)	//

	/*
	 Entry point for cash flow calculations.  The cash flow builder is
	 responsible for determining P&I amounts, however these amounts must
	 be validated against limits.  The cash flow builder has performed all
	 inits.
	*/

	new NEW 
	set NEW=1
	do N1(.ln)
	quit
	
N1(RecordLN ln)	

	set (NP1,NP2,NP3,NP4,NP5,NP6)=0
	set CALTRM="*"
	if PMT>ln.pmtpi do IP(.ln) quit
	
	// Check payment decrease limits
	
	if 'PMXDDC,PMXDDC'="" set NP1=+ln.pmtpi
	else  do {
		if PMXDDC,PMT<(ln.pmtpi-PMXDDC) set NP1=+ln.pmtpi-PMXDDC
		else  set NP1=+PMT
		}
	set X(NP1)=""


	if 'PMXDDL,PMXDDL'="" set NP2=+ln.pmtpi
	else  do {
		if PMXDDL,PMT<(PMTORG-PMXDDL) set NP2=+PMTORG-PMXDDL
		else  set NP2=+PMT
		}
	set X(NP2)=""


	if 'PMXPDC,PMXPDC'="" set NP3=+ln.pmtpi
	else  do {
		if PMXPDC,ln.pmtpi,(1-(PMT/ln.pmtpi))>(PMXPDC/100) set NP3=+$$^SCARND(ln.pmtpi*(1-(PMXPDC/100)),0,$G(CID))
		else  set NP3=+PMT
		}
	set X(NP3)=""


	if 'PMXPDL,PMXPDL'="" set NP4=+ln.pmtpi
 	else  do {
		if PMXPDL,PMTORG,(1-(PMT/PMTORG))>(PMXPDL/100) set NP4=+$$^SCARND(PMTORG*(1-(PMXPDL/100)),0,$G(CID))
		else  set NP4=+PMT
		}
	set X(NP4)=""

	if 'PMXPDY,PMXPDY'="" set NP5=+ln.pmtpi
	else  do {
		if PMXPDY,ANPTO,(1-(PMT/ANPTO))>(PMXPDY/100) set NP5=+$$^SCARND(ANPTO*(1-(PMXPDY/100)),0,$G(CID))
		else  set NP5=+PMT
		}
	set X(NP5)=""


	if 'PMXDDY,PMXDDY'="" set NP6=+ln.pmtpi
	else  do {
		if PMXDDY,PMT<(ANPTO-PMXDDY) set NP6=+ANPTO-PMXDDY
		else  set NP6=+PMT
		}
	set X(NP6)=""

	set NP=$O(X(""),-1)
	kill X
	if 'NP set NPMT=PMT
	else  set NPMT=NP
	
	// Check minimum payment decrease
	if NPMT>(ln.pmtpi-PMNDDC) set NPMT=ln.pmtpi quit:NEW.get()  do RESET(.ln) quit
	if NEW.get() quit
	do ITRM(.ln) 
	quit
	
IP(RecordLN ln)	// Check payment increase limits
	
	if 'PMXDIC,PMXDIC'="" set NP1=+ln.pmtpi
	else  do {
		if PMXDIC,PMT>(ln.pmtpi+PMXDIC) set NP1=+ln.pmtpi+PMXDIC
		else  set NP1=+PMT
		}
	set X(NP1)=""

	if 'PMXDIL,PMXDIL'="" set NP2=+ln.pmtpi
	else  do {
		if PMXDIL,PMT>(PMTORG+PMXDIL) set NP2=+PMTORG+PMXDIL
		else  set NP2=+PMT
		}
	set X(NP2)=""

	if 'PMXPIC,PMXPIC'="" set NP3=+ln.pmtpi
	else  do {
		if PMXPIC,ln.pmtpi,((PMT/ln.pmtpi)-1)>(PMXPIC/100) set NP3=+$$^SCARND(ln.pmtpi*(1+(PMXPIC/100)),0,$G(CID))
		else  set NP3=+PMT
		}
	set X(NP3)=""

	if 'PMXPIL,PMXPIL'="" set NP4=+ln.pmtpi
	else  do {
		if PMXPIL,PMTORG,((PMT/PMTORG)-1)>(PMXPIL/100) set NP4=+$$^SCARND(PMTORG*(1+(PMXPIL/100)),0,$G(CID))
		else  set NP4=+PMT
		}
	set X(NP4)=""

	if 'PMXDIY,PMXDIY'="" set NP5=+ANPTO
	else  do {
		if PMXDIY,PMT>(ANPTO+PMXDIY) set NP5=+ln.pmtpi+PMXDIY
		else  set NP5=+PMT
		}
	set X(NP5)=""

	if 'PMXPIY,PMXPIY'="" set NP6=+ANPTO
	else  do {
		if PMXPIY,ANPTO,((PMT/ANPTO)-1)>(PMXPIY/100) set NP6=+$$^SCARND(ANPTO*(1+(PMXPIY/100)),0,$G(CID))
		else  set NP6=+PMT
		}
	set X(NP6)=""

	set NP=$O(X(0))
	kill X
	if 'NP set NPMT=PMT
	else  set NPMT=NP
	
	// Check minimum increase
	if NPMT<(ln.pmtpi+PMNDIC) set NPMT=ln.pmtpi quit:NEW.get()  do RESET(.ln) quit
	
	// Cash flow exit point.
	if NEW.get()  quit
	do ITRM(.ln)
	
	quit
	
ITRM(RecordLN ln)	// Check new rate and new P+I against maximum term
	
	set MXMDT=0
	new AF set AF=$S(ICPF'="":ICPF,1:DIST1AF),%LD=SCHLD,%ND=SCHND-1
	set X=NPMT-$$^UIC(CALBAL,%LD,%ND,IACM,IRNC,1,AF,DIST1FRE,ICPF,SCHND,SCHLD)

	/*
	 If the max def int per bill is zero and we have negam (exclude GPM
	 and IEM loans which must always have unlimited negam per bill).
	 Negative Amortization Not Allowed
	*/

	if DIMXB'="",+DIMXB=0,X<0,'(PCHM=2!(PCHM=3)) set ER=1,ET=$$^MSG("4215") do LOGERR quit
	
	// If there is any max term and we have negam (also exclude GPM, IEM).
	// Negative Amortization Not Allowed
	if TRMMX'="",X<0,'(PCHM=2!(PCHM=3)) set ER=1,ET=$$^MSG("4215") do LOGERR quit
	
	// If the neg amount exceeds DIMXB (exclude GPM, IEM).
	// Negative Amortization Exceeds Maximum Per Payment
	if DIMXB'="",X<-DIMXB,'(PCHM=2!(PCHM=3)) set ER=1,ET=$$^MSG("4214") do LOGERR quit
	
	if X'>0 do RESET(.ln) quit
	
	if 'PIACM set N=$$NP^UFINC(CALBAL,IRNC,NPMT,0,DIST1AF)
	else  set N=$$NPI^UFINC(NPMT,IRNC,CALBAL,0,PCHND,IACM,DIST1FRE,"",DIST1AF)
	set CALTRM=$$^SCARND(N,0,"","",0)

	// Determine whether loan's term will exceed maximum
	if TRMMX'="" do { I ER,ET'="" do LOGERR quit
		set (ER,ET)=""
		set ODT=ln.amodt,TRM=TRMMX do ^UMDT set MXMDT=MDT quit:ER  if 'MDT quit
		set JD=EJD
		for I=1:1:CALTRM set NJD=$$NJD^UFRE(JD,DIST1FRE) do:ER LOGERR quit:ER  set JD=NJD
		// Recalculated Term Exceeds Maximum
		if JD>MXMDT set ER=1,ET=$$^MSG("4216")
		}

	do RESET(.ln)

	quit
	
RESET(RecordLN ln)	// set new P+I in account
	
	/*
	 Consider that loans with FASB91 fees may require a recomputation of
	 their net investment yields.
	*/

	new PLANID
	if 'ln.ptsp do R1(.ln) quit

	type RecordLNCYCPTS lncycpts=Db.getRecord("LNCYCPTS","CID=:CID,TYP=""PTS""")
	
	// Does the IRR get recalculated at payment change? 
 	set PLANID=lncycpts.plan
	if PLANID="" do R1(.ln) quit
	
 	if '$D(PLAN(PLANID)) do {

		new PAYEE
		set PAYEE=lncycpts.payee
		type RecordAOAMO aoamo=Db.getRecord("AOAMO","""PTS"",PAYEE,PLANID")
		set PLAN(PLANID)=aoamo.rypc  
		}
	if 'PLAN(PLANID) do R1(.ln) quit
	
	/*
	 Build updated CF array
	 Kill old array and controlling variables
	*/

	kill CF,KEEPCF,KILLCF

	set (OIR,IRN,URATE,RATE)=IRNC
	set ONP=ln.onp-(AMBAS-CALTRM),(AMBAS,NUMPT)=CALTRM
	
	/*
	 Call the cash flow builder to construct the CF array of anticipated
	 payments and balances.  Note that routine LNCFBLD calls routine 
	 LNPTCHG at the NEW linetag. 
	*/

	set (ROP,SVNPMT,PMT,OPMT)=NPMT
	set ln.pmtpi=NPMT
	set (SCALBAL,BASE)=CALBAL
	set EFD=EJD

	// Unable to Recalculate Net Investment Yield
	do PCH^LNCFBLD(.ln,EFD) I ER set ET=$$^MSG("4020") do LOGERR do R0(.ln) quit
	
	// Calculate new net investment yield.
	set CALBAL=SCALBAL
 	set CF(0)="-"_(CALBAL-($P(LNP,"|",7)-LNP))
	set IRR=$$^UIRR(.CF,DIST1FRE,PIACM,IACM,PCHND)
	// Unable to Recalculate Net Investment Yield
	if ER set ET=$$^MSG("4020") do LOGERR do R0(.ln) quit
	
 	if SING'=2 do {
		set lncycpts.nyld=IRR
		do lncycpts.bypassSave()
		}

	do R0(.ln)

	quit

R0(RecordLN ln)	//

	set NPMT=SVNPMT
	set IRN=+ln.irn,BAL=+ln.bal
	if ln.aruf set BAL=BAL-ln.udbal
	do R1(.ln)

	quit
	
R1(RecordLN ln)	//


	type Number DONE
	
	type public String CALTRM
	
	set DONE=1
	
	if CALTRM="" set CALTRM=$G(REMTRM)		
	set PCHDATA=+CALBAL_"|"_CALTRM_"|"_+NPMT_"|"_+SVPT_"|"_+ln.pmtpi_"|"_+IRN_"|"_+BAL_"|"_SCHNUM_"|"_+PRADJ_"|"_+INTADJ_"|"_+DIAADJ_"|"_(SCHNUM-ln.schnum)_"|"_+ACR
	
	if SING=2 set LNPT=PCHDATA quit
	
	new APCNDDAT

	type RecordLNAPCHG lnapchg=Class.new("RecordLNAPCHG","PCHND,CID")

	set APCNDDAT=$G(PCBD(CID,"APCND",ICHND,CID))

	if (APCNDDAT.isNull()),Db.isDefined("LNAPCHG","PCHND,CID") set lnapchg=Db.getRecord("LNAPCHG","PCHND,CID")
		
	// Check escrow analysis for rounding options
	set NTRS=ln.pmttrs
	
	if ln.ropt do R4(.ln,.lnapchg) quit     // ROPT=1 esc only is rounded: do nothing.
				   		// 2=No round. 3=Round principal.
	if ln.rnd="" do R4(.ln,.lnapchg) quit   // No escrow to round
	if 'ln.pmttrs do R4(.ln,.lnapchg) quit  // No escrow payment
	
	// If there's no analysis, round existing payment
	if APCND="" do R3(.ln,.lnapchg) quit

	type RecordLNAPCHG lnapchg2=Class.new("RecordLNAPCHG")

 	if APCND=PCHND set lnapchg2=lnapchg.copy()
	else  set lnapchg2=Db.getRecord("LNAPCHG","APCND,CID")
	
	/*
	 If there's no analysis outstanding, round existing payment.  Note that
	 the first 25 pieces of PCB relate to escrow analysis, but that piece
	 1 contains the new (next) payment amount, regardless of whether the
	 loan has escrow analysis or not.  The other routines (LNPTCHG,
	 LNVRCHG) both file this for notice/coupon book production.
	*/

	if $$chkallnl(.lnapchg2) do R3(.ln,.lnapchg) quit
	
	new P,T
	set (R,NTRS)=0 K EC,PC,E
	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID")
	if lnbil0.pe01da set I=2 do escvars(.ln,lnbil0.pe01da,lnbil0.pe01ea)
	if lnbil0.pe02da set I=3 do escvars(.ln,lnbil0.pe02da,lnbil0.pe02ea)
	if lnbil0.pe03da set I=4 do escvars(.ln,lnbil0.pe03da,lnbil0.pe03ea)
	if lnbil0.pe04da set I=5 do escvars(.ln,lnbil0.pe04da,lnbil0.pe04ea)
	if lnbil0.pe05da set I=6 do escvars(.ln,lnbil0.pe05da,lnbil0.pe05ea)
	if lnbil0.pe06da set I=7 do escvars(.ln,lnbil0.pe06da,lnbil0.pe06ea)
	if lnbil0.pe07da set I=8 do escvars(.ln,lnbil0.pe07da,lnbil0.pe07ea)
	if lnbil0.pe08da set I=9 do escvars(.ln,lnbil0.pe08da,lnbil0.pe08ea)
	if lnbil0.pe09da set I=10 do escvars(.ln,lnbil0.pe09da,lnbil0.pe09ea)
	if lnbil0.pe10da set I=11 do escvars(.ln,lnbil0.pe10da,lnbil0.pe10ea)
	if lnbil0.pe11da set I=12 do escvars(.ln,lnbil0.pe11da,lnbil0.pe11ea)
	if lnbil0.pe12da set I=13 do escvars(.ln,lnbil0.pe12da,lnbil0.pe12ea)
	if lnbil0.pe13da set I=14 do escvars(.ln,lnbil0.pe13da,lnbil0.pe13ea)
	if lnbil0.pe14da set I=15 do escvars(.ln,lnbil0.pe14da,lnbil0.pe14ea)
	if lnbil0.pe15da set I=16 do escvars(.ln,lnbil0.pe15da,lnbil0.pe15ea)
	if lnbil0.pe16da set I=17 do escvars(.ln,lnbil0.pe16da,lnbil0.pe16ea)
	if lnbil0.pe17da set I=18 do escvars(.ln,lnbil0.pe17da,lnbil0.pe17ea)
	if lnbil0.pe18da set I=19 do escvars(.ln,lnbil0.pe18da,lnbil0.pe18ea)
	if lnbil0.pe19da set I=20 do escvars(.ln,lnbil0.pe19da,lnbil0.pe19ea)
	if lnbil0.pe20da set I=21 do escvars(.ln,lnbil0.pe20da,lnbil0.pe20ea)
	
	if '$D(EC) do R4(.ln,.lnapchg) quit             // Account has no escrow
	
	// APCND preceeds PCHND, do not process
 	if (APCND<PCHND),lnapchg2.ntrs set NTRS=lnapchg2.ntrs-lnapchg2.rnda do R3(.ln,.lnapchg) quit
	
	if '$D(E) do R4(.ln,.lnapchg) quit
	
 	set N=lnapchg2.ntrs-lnapchg2.rnda
	set R=NPMT+N,R=(1-(R-(R\1)))#1
	set Y=N+R
	
 	set lnapchg2.ntrs=N+R
 	set lnapchg2.cpi=NPMT
 	set lnapchg2.rnda=R
	
	set EAB=$G(PCBD(CID,"APCND",APCND,CID,E))
	type RecordLNAPCHGE lnapchge=Db.getRecord("LNAPCHGE","APCND=:APCND,CID=:CID,ECID=:E",1)
	set lnapchge.epmt=lnapchge.epmt-lnapchge.opmt+R
	set lnapchge.rnda=R
	do lnapchge.bypassSave()

	if ln.eacip do {
		type RecordDEP depchg=Db.getRecord("DEP","CID=:CID")
		set depchg.recamt=lnapchge.epmt
		do depchg.bypassSave()
		}

	if APCND'=PCHND do { quit
		set lnapchg2.apcnd=APNCD
		set lnapchg2.cid=CID
		do lnapchg2.bypassSave()
		set lnapchg.ntrs=lnapchg2.ntrs
		do R4(.ln,.lnapchg)
		}

	do R4(.ln,.lnapchg2)

	quit


escvars(RecordLN ln,CID,T)	// 

	// Retrieve the ESCROW deposits  curramt and add it to the total payment

	new RND
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	set NTRS=NTRS+dep.curramt
	if T=ln.rnd set EC=P,PC=I,E=$P(EC,"#",2)
	quit
	
R3(RecordLN ln,RecordLNAPCHG lnapchg)	// Round escrow payments which are not subject to analysis, place in PCB.
	
	type public String NPMT,NTRS,R
	set R=NPMT+NTRS,R=(1-(R-(R\1)))#1
 	set lnapchg.ntrs=NTRS+R
	do R4(.ln,.lnapchg)
	quit
	
R4(RecordLN ln,RecordLNAPCHG lnapchg)	// File PMTTRS for other loans	

	type public Date PCHND
	type public Number BAL,CID,CALBAL,DIAADJ,INTADJ,IRN,NPMT,PRADJ,SCHNUM
	type public String CALTRM,SVPT	
	
	// Update LNPTCHG table with the changes
	type RecordLNPTCHG pcbpchg=Class.new("RecordLNPTCHG")
	set pcbpchg.pchnd=PCHND
	set pcbpchg.cid=CID
	set pcbpchg.calbal=+CALBAL
	set pcbpchg.caltrm=CALTRM
	set pcbpchg.npmt=+NPMT
	set pcbpchg.upmt=+SVPT
	set pcbpchg.pmtpi=+ln.pmtpi
	set pcbpchg.irn=+IRN
	set pcbpchg.bal=+BAL
	set pcbpchg.schnum=SCHNUM
	set pcbpchg.pradj=+PRADJ
	set pcbpchg.intadj=+INTADJ
	set pcbpchg.diaadj=+DIAADJ
	set pcbpchg.numadj=(SCHNUM-ln.schnum)
	set pcbpchg.acr=+ACR
	do pcbpchg.bypassSave()

	// Set up coupon production files

	do LNNOT(.ln)
	
 	if ln.cbmet'=2 do END(.ln) quit
	set CDAT=PCHND

	// bump by DIST1FRE if ICM=0 (arrears)
	if 'ln.icm set CDAT=+$$NJD^UFRE(CDAT,ln.dist1fre) do:ER LOGERR quit:ER
	set TDAT=CDAT-ln.cboff
	type RecordLNCPN dayedcpn=Class.new("RecordLNCPN")
	set dayedcpn.pnd=TDAT	//ACM 37051:01
	set dayedcpn.cid=CID
	set dayedcpn.pcb=CDAT
	set dayedcpn.ncn=1
	set dayedcpn.ndd=PCHND
	set dayedcpn.tpt=NPMT+lnapchg.ntrs
	set dayedcpn.pmtpi=NPMT
	set dayedcpn.pmttrs=lnapchg.ntrs
	set dayedcpn.pmet=2
	do dayedcpn.bypassSave()

	set ln.cbond=ln.cbpnd
	set ln.cbpld=ln.cbpnd
	set ln.cbpnd=TDAT
	
	do ln.bypassSave()
	do END(.ln)
	quit

chkallnl(RecordLNAPCHG lnapchg2)	

	/*
	 Check the data items in pieces 2-25 of file LNAPCHG
	 if any one of them contains a value other then null
	 the processing will be changed.
	*/

	if lnapchg2.lnd'="" quit 1
	if lnapchg2.lfre'="" quit 1
	if lnapchg2.laf'="" quit 1
	if lnapchg2.otrs'="" quit 1
	if lnapchg2.olbal'="" quit 1
	if lnapchg2.oebal'="" quit 1
	if lnapchg2.cebal'="" quit 1
	if lnapchg2.aebal'="" quit 1
	if lnapchg2.tdis'="" quit 1
	if lnapchg2.povsh'="" quit 1
	if lnapchg2.esreq'="" quit 1
	if lnapchg2.coll'="" quit 1
	if lnapchg2.lrbas'="" quit 1
	if lnapchg2.rndi'="" quit 1
	if lnapchg2.cpi'="" quit 1
	if lnapchg2.probas'="" quit 1
	if lnapchg2.odm'="" quit 1
	if lnapchg2.rnda'="" quit 1
	if lnapchg2.aeaf'="" quit 1
	if lnapchg2.aelap'="" quit 1
	if lnapchg2.tamtd'="" quit 1
	if lnapchg2.tamtb'="" quit 1
	if lnapchg2.tamtl'="" quit 1
	if lnapchg2.tamts'="" quit 1
	quit 0

	
END(RecordLN ln)	

	if 'DONE quit
	do END1(.ln)
	quit
	
END1(RecordLN ln)	

	type public String %RAOFF
	type public Date EJD
	type public Number DONE
		
	if SING=2 quit
 	if $D(%RAOFF) set DAYEND(CID,EJD,"RAOFF",CID)=1
	if DONE=3 do { quit
		set D=$$NXDT(EJD,EJD+P,ln.pcfre,ln.pcoff) 
		I 'D quit
		}

	if DONE'=1 quit
	set D=$$NXDT(EJD,PCHND,ln.pcfre,PCOFF)

 	if D set ln.pcoffdt=D

	if '$D(%RAOFF) quit
 	set NJD=$$NJD^UFRE(EJD,ln.rafre) do:ER LOGERR quit:ER

 	if NJD>0 set ln.randoff=NJD
 	
	quit
	
public NXDT(DT,NJD,FRE,OFF,C)	// Determine next offset date. 
				// Identical to code in BCHLNVRCHG.
	
	/*
	                 DT = Limit date, such as TJD
	                NJD = Next change date
	                FRE = Change frequency
	                OFF = Change offset
	                  C = Control: 0 = Offset date is greater than TJD
	                               1 = Offset date is the last date (upto
	                                   and including TJD
	*/
	type public Date JD
	type Date I
	
	set C=+$G(C)
	if $D(COFF(DT,FRE,OFF,C)) quit COFF(DT,FRE,OFF,C)
	set ER=0
	set I=NJD-OFF
	if I>DT set COFF(DT,FRE,OFF,C)=I quit I
	set JD=NJD

	for  set NJD=$$NJD^UFRE(JD,FRE) do:ER LOGERR quit:ER  do { Q:ER!(I>DT)
		if ER quit
		if 'C do {
			set I=NJD-OFF
			if I>DT set COFF(DT,FRE,OFF,C)=I quit
			set JD=NJD
			}
		else  do {
			set I=NJD-OFF
			if I>DT set I=JD-OFF,COFF(DT,FRE,OFF,C)=I quit
			set JD=NJD
			}
		}

	if ER quit 0
	quit I
	
LOGERR	// Log error in exception file
	
	type public String ET,RM,SING
	if $G(SING) set RM=$G(ET) quit

	// Loan Payment Change Offset Processing
	do LOG^UTLEXC($T(+0),"*",$$^MSG("4213"),$G(CID),$G(%ZTSEQ),$G(ET),+$G(BAL))
	kill ET,%ZTSEQ
	quit

LNNOT(RecordLN ln)	

	/* 
	ARQ 40359
	Set entry into DAYENDLNNOT table to signal the system to produce
        the Rate/Payment Adjustment Notice or/and Projected Activity Report.
	Before setting level 3 of the DAYENDLNNOT, verify if there were
	scheduled interest rate change dates since the last scheduled payment
	change date. If yes - save rate changes in the DAYENDLNNOT1.
	*/
	
	type public String CID,NPMT

	new PRATE,NRATE,FL,JD,ICHND,PCHLD,PCHND
	
	set FL=0          // "rate change within pmt change period" flag	
	set ICHND=ln.ichnd
	set JD=ICHND
	set PCHLD=ln.pchld
	set PCHND=ln.pchnd

	if INTFRE'="" do {
		for  set ICHLD=$$NJD^UFRE(JD,INTFRE,,1) quit:ER  set JD=ICHLD quit:ICHLD'>PCHLD  do {
			if ICHLD>PCHND quit
			set FL=1
			
			set (NRATE,PRATE)=0
			
			type ResultSet rs=Db.select("NRATE,IRN","LNVRCHG","ICHND=:ICHLD AND CID=:CID")
			if rs.next() do {
				set NRATE=rs.getCol("NRATE")
				set PRATE=rs.getCol("IRN")
				}
			if ('NRATE),('PRATE) quit
			type RecordDAYENDLNNOT1 lnnot1=Db.getRecord("DAYENDLNNOT1","DT=:%SystemDate,CID=:CID,ID=3,ICDT=:ICHLD",1)
			set lnnot1.oldrate=PRATE
			set lnnot1.newrate=NRATE
			do lnnot1.bypassSave()
			}
		}

	if ln.genprjrep=1 do {

		type RecordDAYENDLNNOT lnnot4=Db.getRecord("DAYENDLNNOT","DT=:%SystemDate,CID=:CID,ID=4",1)
		if 'lnnot4.getMode() do lnnot4.bypassSave()
		}

	if FL=1 do {

		type RecordDAYENDLNNOT lnnot3=Db.getRecord("DAYENDLNNOT","DT=:%SystemDate,CID=:CID,ID=3",1)
		set lnnot3.oldpmt=ln.pmtpi
		set lnnot3.newpmt=$G(NPMT)
		do lnnot3.bypassSave()
		}

	type RecordDAYENDLNNOT lnnot2=Db.getRecord("DAYENDLNNOT","DT=:%SystemDate,CID=:CID,ID=2",1)
	set lnnot2.oldpmt=ln.pmtpi
	set lnnot2.newpmt=$G(NPMT)
	do lnnot2.bypassSave()
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60611^25706^Sunitha Santhumayor^27179"	// Signature - LTD^TIME^USER^SIZE
