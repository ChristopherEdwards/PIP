V01S333(%ProcessMode,RecordTTX fT)   // -  - SID= <ITFCV> Foreign Currency Voucher Entry
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 11:55 - shetyes
 // This transaction entry screen permits the user to enter a balanced,
 // multiple-posting debit & credit voucher in one currency.  These
 // vouchers are unique from other PROFILE accounting transactions
 // in that they are generalized and may post to a wide variety of
 // customer and general ledger accounts, and they may be forward-
 // valued; i.e., have effective posting dates in the future.  Ledger and
 // available balances will not be updated until the effective date of the
 // voucher is reached in the PROFILE Day-Begin process.  Used in
 // conjunction with the projected nostro screens and reports, these
 // vouchers are the primary tools to reflect the transfer of funds
 // between nostro accounts of like currency.  It is presumed in such
 // cases that payment orders have been transmitted.  These vouchers
 // will also post to certain PROFILE ACNs and FMS General Ledger
 // accounts as well as update projected nostro balances on-line.
  /*
ORIG: CHENARDP - 03/03/2003
DESC: PSL Screen Compiler Template

---- Comments --------------------------------------------------------
	This procedure is used as the base template for the PSL screen compiler.
	It is referenced by the PSL screen compiler - procedure DBS2PSL4
	
	
---- Revision History ------------------------------------------------
	02/23/06 - Pete Chenard - CR19551
		   Fixed routine label.
		   
	05/19/05 - Pete Chenard - CR 14146
		   Modified to type variables.
		   
	12/1/03 - Spier -cr7178
	   	     Modifications to correct dead code warnings and
	   	     other issues that occurred during mass compile of screens.

	09/24/03 - Pete Chenard - 45497
		       Created screen template for compiler.
----------------------------------------------------------------------

 */

 #WARN SCOPE OFF
	type Public String %MODS,%PAGE,%PG,%REPEAT,ER,RM
	type String KEYS(),KVAR,VFSN(),VO,VODFT,VPGM,vPSL,VSID,VSNAME

	// %O (0-Create  1-Modify  2-Inquiry  3-Delete  4-Print  5-Blank screen)

	set:'$D(%ProcessMode) %ProcessMode=5
 set KVAR="kill %TAB,VFSN,VO,VPTBL,vtab,DEALID,ACNGL,ACNPST,DRCR,STAT,CNTRY,HLDSQ",VSID="ITFCV",VPGM=$T(+0),VSNAME="Foreign Currency Voucher Entry"
 set VFSN("ITSHLP")="zfITSHLP",VFSN("TTX")="zfT"
 set vPSL=1
 set KEYS(1)=fT.TJD
 set KEYS(2)=fT.BRCD
 set KEYS(3)=fT.UID
 set KEYS(4)=fT.TSEQ
 //
	// ==================== Display blank screen         (%O=5)

 if %ProcessMode=5 set %MODS=1,%REPEAT=11 do VPR(.fT),VDA1(.fT),V5^DBSPNT quit

 if '%ProcessMode do VNEW(.fT),VPR(.fT),VDA1(.fT)
 if %ProcessMode do VLOD(.fT) quit:$G(ER)  do VPR(.fT),VDA1(.fT)

	// ====================  Display Form
	do ^DBSPNT()
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	if %ProcessMode=2!(%ProcessMode=3) do ^DBSCRT8A X:'$D(%PAGE) KVAR quit  // Inquiry/Delete
	// ====================  Set up data entry control table


 if %ProcessMode<2 do VTAB(.fT)
	quit


VNEW(RecordTTX fT) // Initialize arrays if %O=0
 
 do VDEF(.fT)
 do VLOD(.fT)
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
	
VDEF(RecordTTX fT)
 if fT.CDT="" set fT.CDT=+$H
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
 ;
VLOD(RecordTTX fT) // Load data from disc - %O = (1-5)
 if '$D(%REPEAT) set %REPEAT=11
 if '$D(%MODS) set %MODS=1
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


	type Public String %MODS,%REPEAT
	quit
	

VPR(RecordTTX fT) // Display screen prompts
 set VO="9||13|"
 set VO(0)="|0"
 set VO(1)=$C(2,59,7,0,0,0,0,0,0,0)_"01TTeller:"
 set VO(2)=$C(3,28,14,0,0,0,0,0,0,0)_"01T Posting Date:"
 set VO(3)=$C(4,26,16,0,0,0,0,0,0,0)_"01T Effective Date:"
 set VO(4)=$C(5,32,10,1,0,0,0,0,0,0)_"01T Currency:"
 set VO(5)=$C(6,4,15,1,0,0,0,0,0,0)_"01T Operations ID:"
 set VO(6)=$C(7,7,12,0,0,0,0,0,0,0)_"01TTran Number:"
 set VO(7)=$C(8,1,18,1,0,0,0,0,0,0)_"01T Orig Cost Center:"
 set VO(8)=$C(10,1,83,2,0,0,0,0,0,0)_"01TGL  Account                     DR Stat Cty Hold                                   "
 set VO(9)=$C(11,1,78,2,0,0,0,0,0,0)_"01TACN ID                   Amount CR Code  CD  SEQ Narrative                    "
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VDA1(RecordTTX fT)  // Display screen data
 new V
 s %UID=$G(%UID)
 s ACNGL=$G(ACNGL)
 s ACNPST=$G(ACNPST)
 s CNTRY=$G(CNTRY)
 s DEALID=$G(DEALID)
 s DRCR=$G(DRCR)
 s EFD=$G(EFD)
 s HLDSQ=$G(HLDSQ)
 s PDATE=$G(PDATE)
 s STAT=$G(STAT)
 s TOPLINE=$G(TOPLINE)
 s TSEQ=$G(TSEQ)
 //
 set VO="17|10|13|"
 set VO(10)=$C(1,1,80,2,0,0,0,0,0,0)_"01T"_$G(TOPLINE)
 set VO(11)=$C(2,67,12,2,0,0,0,0,0,0)_"01T"_$G(%UID)
 set VO(12)=$C(3,43,10,2,0,0,0,0,0,0)_"01D"_$$DAT^%ZM($G(PDATE))
 set VO(13)=$C(4,43,10,2,0,0,0,0,0,0)_"01D"_$$DAT^%ZM($G(EFD))
 set VO(14)=$C(5,43,3,2,0,0,0,0,0,0)_"00T"_$E(fT.CRCD,1,3)
 set VO(15)=$C(6,20,10,2,0,0,0,0,0,0)_"00T"_$G(DEALID)
 set VO(16)=$C(7,20,12,2,0,0,0,0,0,0)_"01T"_$G(TSEQ)
 set VO(17)=$C(8,20,6,2,0,0,0,0,0,0)_"00N"_fT.CC
  
 set:'$D(%MODS) %MODS=1 set VX=$P(VO,"|",2)+7,DY=12 for I=%MODS:1:%REPEAT+%MODS-1 do VRDA(.fT)
 set $piece(VO,"|",1)=VX quit  // EOD pointer
 
VRDA(RecordTTX fT)  // Display data %REPEAT times
 //instantiate new object if necessary
 if %ProcessMode=5 new v1,v2,v5,v3,v6,v4
 if  set (v1,v2,v5,v3,v6,v4)=""
 else  new v1,v2,v5,v3,v6,v4
 else  set (v1,ACNGL(I))=$G(ACNGL(I)),(v2,ACNPST(I))=$G(ACNPST(I)),(v5,CNTRY(I))=$G(CNTRY(I)),(v3,DRCR(I))=$G(DRCR(I)),(v6,HLDSQ(I))=$G(HLDSQ(I)),(v4,STAT(I))=$G(STAT(I))
 
 set VO(VX+1)=$C(DY,1,1,0,0,0,0,0,0,0)_"00T"_v1
 set VO(VX+2)=$C(DY,5,12,0,0,0,0,0,0,0)_"00N"_$P(v2,"|",1)
 set V=$P(v2,"|",4) set VO(VX+3)=$C(DY,18,14,0,0,0,0,0,0,0)_"00$"_$S(V="":"",1:$J(V,0,2))
 set VO(VX+4)=$C(DY,33,2,0,0,0,0,0,0,0)_"00U"_v3
 set VO(VX+5)=$C(DY,36,5,0,0,0,0,0,0,0)_"00N"_v4
 set VO(VX+6)=$C(DY,42,2,0,0,0,0,0,0,0)_"00T"_v5
 set VO(VX+7)=$C(DY,46,3,0,0,0,0,0,0,0)_"00T"_v6
 set VO(VX+8)=$C(DY,50,30,0,0,0,0,0,0,0)_"00T"_$P(v2,"|",8)
 set DY=DY+1,VX=VX+8
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
	
	
VTAB(RecordTTX fT)
 
 kill VSCRPP,REQ,%TAB,%MOD,%MODOFF,%MODGRP,%REPREQ,vtab set %REPREQ=24 set %MODGRP=1
 set %MODOFF=8,%MOD=8,%MAX=(%MOD*%REPEAT)+%MODOFF,VPT=1,VPB=11+%REPEAT,BLKSIZ=(69*%REPEAT)+143,PGM=$T(+0),DLIB="SYSDEV",DFID="TTX",VSCRPP=1,VSCRPP=1
 set OLNTB=VPB*1000
 
 set VFSN("ITSHLP")="zfITSHLP",VFSN("TTX")="zfT"
 //
 for I=17:1:%MAX set %TAB(I)=""
	
	
 set %TAB(1)=$C(0,0,80)_"20T|*TOPLINE|[*]@TOPLINE"
 set %TAB(2)=$C(1,66,12)_"20T|*%UID|[*]@ooe3"
 set %TAB(3)=$C(2,42,10)_"21D|*PDATE|[*]@PDATE"
 set %TAB(4)=$C(3,42,10)_"20D|*EFD|[*]@[TTX]EFD"
 set %TAB(5)=$C(4,42,3)_"01T12417||[TTX]CRCD|[CRCD]:QU ""[CRCD]CO=<<%CO>>,[CRCD]RETAIL=1""|||do VP1^V01S333(.fT)"
 set %TAB(6)=$C(5,19,10)_"01T|*DEALID|[*]@DEALID"
 set %TAB(7)=$C(6,19,12)_"20T|*TSEQ|[*]@TSEQ"
 set %TAB(8)=$C(7,19,6)_"01N12420||[TTX]CC|[UTBLCCNTR]"
 set %TAB(9)=$C(11,0,1)_"00T|*ACNGL(1)|[*]@[ITSHLP]ACNGL|||do VP2^V01S333(.fT)"
 set %TAB(10)=$C(11,4,12)_"00N12401|*ACNPST(1)|[*]@[ITSHLP]ACNPS|||do VP3^V01S333(.fT)||0"
 set %TAB(11)=$C(11,17,14)_"00$12404|*ACNPST(1)|[*]@[ITSHLP]ACNP|||do VP4^V01S333(.fT)||||2"
 set %TAB(12)=$C(11,32,2)_"00U|*DRCR(1)|[*]@[ITSHLP]DRCR|||do VP5^V01S333(.fT)"
 set %TAB(13)=$C(11,35,5)_"00N|*STAT(1)|[*]@[ITSHLP]ESTAD|[UTBLESTAD]"
 set %TAB(14)=$C(11,41,2)_"00T|*CNTRY(1)|[*]@[ITSHLP]CTRY|[STBLCNTRY]"
 set %TAB(15)=$C(11,45,3)_"00T|*HLDSQ(1)|[*]@HLDSQ|[PHLD]:QU ""CID=<<CID>>""||do VP6^V01S333(.fT)"
 set %TAB(16)=$C(11,49,30)_"00T12408|*ACNPST(1)|[*]@[ITSHLP]NARR|||do VP7^V01S333(.fT)"
 do VTBL(.fT)
	do ^DBSCRT8 	// data entry
	quit


VREQ   // Create REQ() array
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VTBL(RecordTTX fT) //Create %TAB(array)
 	// 1 2 3  4 5   6   7-9 10-11
 	// DY,DX,SZ PT REQ TYPE DEL POS |NODE|ITEM NAME|TBL|FMT|PP|PRE|MIN|MAX|DEC

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VSPP   // screen post proc
 type Public RecordTTX fT
 do VSPP1(.fT)
 #ACCEPT Date=11/05/03; pgm=Screen Compilerxxx
 quit
VSPP1(RecordTTX fT)
	type public Boolean ER
	type public String ACNGL(), ACNPST(), DRCR(), RM
	type Number CRTTL, DRTTL, N
	set (CRTTL, DRTTL) = 0
	for N = 1:1:11 do {
	
		quit:ACNGL(N).isNull()
		quit:ACNPST(N).piece("|", 4).isNull()	// amount
		quit:ACNPST(N).piece("|", 1).isNull()	// CID
		quit:DRCR(N).isNull()			// DR/CR
	
		if (DRCR(N) = "CR") set CRTTL = CRTTL + ACNPST(N).piece("|", 4)
		else  set DRTTL = DRTTL + ACNPST(N).piece("|", 4)
	}
	if (CRTTL - DRTTL <> 0) do {
	
		set ER = 1
		// Debits do not match Credits. Debits:~p1  Credits:~p2
		set RM = $$^MSG(6100, DRTTL, CRTTL)
	}
	else  if ((CRTTL = 0) & (DRTTL = 0)) do {
	
		set ER = 1
		// No account information entered
		set RM = $$^MSG(1885)
	}
	quit
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


  //user-defined post procs
 //
VP1(RecordTTX fT) //
	set fT.efd = EFD
	if fT.crcd.isNull() set fT.crcd = %SystemCurrency

	if (%ProcessMode = 1) do PROTECT^DBSMACRO("@DEALID")

	quit
VP2(RecordTTX fT) //
	type public String X
	type public Number z1

	quit:(X.isNull() & (z1 <> 1))

	// Enter 'G' for General Ledger account or 'A' for IBS account
	if '((X = "G") ! (X = "A")) do Runtime.setErrMSG("TTX",6101)

	quit
VP3(RecordTTX fT) //
	type public Boolean ER
	type public Number z1
	type public String RM, X

	type Boolean FCVMEMO

	quit:X.isNull()

	set FCVMEMO = CUVAR.FCVMEMO

	if (ACNGL(z1) = "G") do {

		type RecordGLAD glad = Db.getRecord("GLAD", "ACN=:X", 1)

		if (glad.getMode() = 0) do { quit

			set ER = 1
			// Invalid G/L account ~p1
			set RM = $$^MSG(1364, X)
		}
		if FCVMEMO, (glad.type '= "M") do { quit

			set ER = 1
			// Account must be a G/L Memo Account
			set RM = $$^MSG(1808)
		}
		if glad.bonly, (fT.crcd '= %SystemCurrency) do { quit

			set ER = 1
			// This G/L account can only accept base currency transactions
			set RM = $$^MSG(6103)
		}

		set RM = glad.desc1
	}

	else  do {

		if FCVMEMO do { quit

			set ER = 1
			// Invalid G/L account ~p1
			set RM = $$^MSG(1364)
		}

		do CID^UACN1
		if X.isNull() do { quit

			set ER = 1
			// No account selected.
			set RM = $$^MSG(1364)
		}

		type RecordACN acn = Db.getRecord("ACN", "CID=:X", 1)

		if (acn.getMode() = 0) do { quit

			set ER = 1
			// Invalid IBS account.
			set RM = $$^MSG(6105)
		}

		if (acn.cls = "L") do { quit

			set ER = 1
			// Processing currently enabled for Deposit Accounts only
			set RM = $$^MSG(8251)
		}

		// Check to make sure this account is in correct currency

		if (acn.crcd '= fT.crcd) do { quit

			set ER = 1
			// Account Defined as a ~p1 account
			set RM = $$^MSG(6106, acn.crcd)
		}

		if (acn.stat = 4) do { quit

			set ER = 1
			// Account ~p1 closed
			set RM = $$^MSG(55)
		}			

		if 'acn.mdt.isNull(), (acn.mdt < fT.efd) do {

			type Date MDT

			set MDT = acn.mdt

			set ER = 1
			// This account is scheduled to close on ~p1
			set RM = $$^MSG(6108, MDT.toString())
		}

		set RM = acn.title1
	}

	quit
VP4(RecordTTX fT) //
	type public Number X

	// ENTER A POSITIVE NUMBER
	if 'X.isNull(), (X '> 0) do Runtime.setErrMSG("TTX", 6109)
 
	quit
VP5(RecordTTX fT) //
	type public String X

	if 'X.isNull(), '((X = "CR") ! (X = "DR")) do {

		set ER = 1
		// Enter DR (Debit) or CR (Credit)
		set RM = $$^MSG(6110)
	}

	quit
VP6(RecordTTX fT) //
	type public Boolean ER
	type public Date EFD
	type public String ACNGL(), ACNPST(), DRCR(), RM, X

	type Number CID

	quit:X.isNull()

	if (ACNGL(z1).get() '= "A") do { quit

		set ER = 1
		// Holds can only be linked to IBS accounts
		set RM = $$^MSG(8250)
	}

	set CID = ACNPST(z1).piece("|", 1)

	type RecordDEP dep = Db.getRecord("DEP", "CID=:CID", 1)

	if (dep.getMode() = 0) do {

		set ER = 1
		// Invalid account ~p1
		set RM = $$^MSG(1259, X)
	}

	if (dep.grp = "DBD") do { quit

		set ER = 1
		// Holds are not valid for DBD accounts
		set RM = $$^MSG(8252)
	}

	if (DRCR(z1) '= "DR") do { quit

		set ER = 1
		// Processing currently not enabled for deposits
		set RM = $$^MSG(8253)
	}

	type RecordPHLD phld = Db.getRecord("PHLD", "CID=:CID,SEQ=:X", 1)

	if (phld.getMode() = 0) do { quit

		set ER = 1
		// Not a valid hold sequence for this account
		set RM = $$^MSG(8254)
	}

	if (EFD	 < phld.stdt) do { quit

		set ER = 1
		// That hold doesn't begin until after this transaction starts
		set RM = $$^MSG(8256)
	}

	if (EFD > phld.expdt) do { quit

		set ER = 1
		// That hold terminates before this transaction begins
		set RM = $$^MSG(8257)
	}

	// Hold will be removed upon posting
	set RM = $$^MSG(8258)

	quit
VP7(RecordTTX fT) //
	type public String ACNGL(), ACNPST(), DRCR(), RM

	type Number CRTTL, DRTTL, N

	set (CRTTL, DRTTL) = 0
	for N = 1:1:11 do {
	
		quit:ACNGL(N).isNull()
		quit:ACNPST(N).piece("|", 4).isNull()	// amount
		quit:ACNPST(N).piece("|", 1).isNull()	// CID
		quit:DRCR(N).isNull()			// DR/CR
	
		if (DRCR(N) = "CR") set CRTTL = CRTTL + ACNPST(N).piece("|", 4)
		else  set DRTTL = DRTTL + ACNPST(N).piece("|", 4)
	}

	//  TOTAL DEBITS: ~p1  TOTAL CREDITS: ~p2
	set RM = $$^MSG(6111, DRTTL, CRTTL)

	// ~p1 (BALANCED)
	if (CRTTL - DRTTL = 0) set RM = $$^MSG(6112, RM)

	quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit								// User defined post processor's


VRV(V,L) quit V_$J("",L-$L(V))
VREPRNT
 type Public RecordTTX fT
 do VPR(.fT)
 do VDA1(.fT)
 do ^DBSPNT()
 quit

VW(RecordTTX fT)
 do VDA1(.fT)
 do ^DBSPNT(10)
 quit

VDAPNT(RecordTTX fT)
 do VDA1(.fT)
 do ^DBSPNT(0,2)
 quit

VDA
 type Public RecordTTX fT
 do VDA1(.fT)
 quit

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
 
vSET(sn,di,X)
 type Public RecordTTX fT
 if sn="TTX" do vSET1(.fT,di,X)
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
vSET1(RecordTTX fT,di,X)
 do fT.setAuditFlag(1)
 set fT.@di=X
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
vREAD(fid,di)
 type Public RecordTTX fT
 if fid="TTX" quit $$vREAD1(.fT,di)
 quit ""
vREAD1(RecordTTX fT,di)
 quit fT.@di
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
