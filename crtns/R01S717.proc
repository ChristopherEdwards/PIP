R01S717	// YER450 - T4RSP Year-End Magnetic Tape Reporting
	// Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 12:55 - shetyes

	type public Number ER=0
	type public Number vbatchq
	type public String IO,RM,VRWOPT()
	type String IRATAB(),TAPETBL()
	type Number OLNTB
	type String %READ,RID,RN,%TAB,VFMQ
	type Number TAPETYPE

	set RID="YER450"
	set RN="T4RSP Year-End Magnetic Tape Reporting"
	if IO.get()="" set IO=$I

	do INIT^%ZM()

	do VPREBQ quit:VFMQ.get()			// Pre-processor (before query)

	set %TAB("IO")=$$IO^SCATAB
	set %TAB("TAPETYPE")="|1|||TAPETBL(||||N|Tape Type|||||"

	set %READ="IO/REQ,TAPETYPE#1,"

	// Skip device prompt option
	if VRWOPT("NOOPEN").get() set %READ=%READ.piece(",",2,99)

	set VFMQ=""
	if %READ'="" do { quit:VFMQ.get()="Q"
		set OLNTB=30
		set %READ="@RN/CEN#1,,"_%READ
		do ^UTLREAD
		}

	if 'vbatchq.get() do V0
	quit

V0	// External report entry point

	type public Number AUXPTR,ER,VTBLNAM
	type public String IO,IOPAR,IOSL,IOTYP,%MSKD,RM,VDISTKEY,VRWOPT()
	type public String IRATAB(),TAPETBL()
	type public Number TAPETYPE
	type Number vcrt,VD(),VFMQ,vh(),vI,vlc,VLC,VNEWHDR,VOFFLG,VPN,VR,VRG,vs(),VSEQ,VT()
	type String VWHERE
	type Literal String VSELECT
	type String %TIM,ACN,BENACN,CAC,CAD1,CAD2,CCITY,CCODE,CNAME,CONAM,CONTACT,CSTATE,CTELE,CZIP,DODD,DRDTH,FTD,IAD1,IAD2,ICITY,INAME,INAME2,IRATAB,ISTATE,IZIP,LLP,N,NODOD,NOFORM,NRESDIS,OI,OII,OIN,PCODE,PLANID,REA,RESDIS,RESSTDIS,RID,RN,RPASEQ,RPS,SBI,SPI,SPOUSAL,SPSIN,STD,SUMCNT,T4RSPTRN,TCC,TD,VL,VLOF,VRF(),VSTATS(),WCP,YEAR,vCOL,vHDG,vc1,vc10,vc11,vc12,vc13,vc14,vc15,vc16,vc17,vc18,vc19,vc2,vc20,vc21,vc22,vc23,vc24,vc25,vc3,vc4,vc5,vc6,vc7,vc8,vc9,vovc1,vovc2,vovc3,vovc4,vovc5,vovc6,vrundate,vsysdate

	set CONAM=CUVAR.conam
	set ER=0,RID="YER450",RN="T4RSP Year-End Magnetic Tape Reporting"
	set VL=""

	use 0 if 'VRWOPT("NOOPEN").get() do { quit:ER
		if 'VRWOPT("IOPAR").get().isNull() set IOPAR = VRWOPT("IOPAR")
		else  if ((IOTYP.get()="RMS")!(IOTYP.get()="PNTQ")),('IOPAR.get().isLike("%/OCHSET=%")),$$VALID^%ZRTNS("UCIOENCD") do {
			// Accept warning if ^UCIOENCD does not exist
			#ACCEPT Date=07/26/06; Pgm=RussellDS; CR=22121; Group=MISMATCH
			type String CHRSET=$$^UCIOENCD("Report","YER450","V0","*")
			if 'CHRSET.isNull() set IOPAR = IOPAR_"/OCHSET="_CHRSET
		}
		do OPEN^SCAIO
	}
	set vcrt=(IOTYP="TRM")
	if 'vcrt set IOSL=99999999			// Non-interactive
	else  do {					// Interactive
		do TERM^%ZUSE(IO,"WIDTH=393")
		write $$CLEARXY^%TRMVT
		write $$SCR132^%TRMVT			// Switch to 132 col mode
		}

	do INIT^%ZM()

	set vCOL="[CIF]LNM#4#20,[CIF]NAM#24#12,[CIF]MAD1#37#30,[CIF]MAD2#67#30,[CIF]MCITY#97#28,[CIF]MSTATE#125#2,[CIF]MZIP#130#10,[CIF]TAXID#140#9,[T4RSPINF]RPS#185#9,[T4RSPINF]REA#194#9,[T4RSPINF]WCP#203#9,[T4RSPINF]OI#222#9,[T4RSPINF]TD#232#9,[T4RSPINF]DRDTH#241#9,[CIF]SPOUSE#250#20,[CIF]SPOUSE#270#12,[T4RSPINF]LLP#300#9"

	// Initialize variables
	set (vc1,vc2,vc3,vc4,vc5,vc6,vc7,vc8,vc9,vc10,vc11,vc12,vc13,vc14,vc15,vc16,vc17,vc18,vc19,vc20,vc21,vc22,vc23,vc24,vc25)=""
	set (VFMQ,vlc,VLC,VOFFLG,VPN,VRG)=0
	set VNEWHDR=1
	set VLOF=""
	set %TIM=$$TIM^%ZM
	set vrundate=%CurrentDate.toString(),vsysdate=%SystemDate.toString()

	do {
		type Number I,J,K
		for I=0:1:7 do {
			set (vh(I),VD(I))=0,vs(I)=1	// Group break flags
			set VT(I)=0			// Group count
			for J=1:1:7 do {
				for K=1:1:3 set VT(I,J,K)=""	// Initialize function stats
				}
			}
		}

	do Db.delete("TMPRPTBR","JOBNO=:%ProcessID")	// Report browser data
	if VDISTKEY.get()="" do { quit:VFMQ		// Report Pre-processor (after query)
		do VPREAQ
		if VFMQ set vh(0)=1 do VEXIT(0)
		}

	set vh(0)=0

	// Run report directly
	do VINILAST
	type ResultSet rwrs=Db.select("T4RSPINF.PID,T4RSPINF.BOO,T4RSPINF.ACN,T4RSPINF.RPASEQ,T4RSPINF.PLANID,T4RSPINF.FORMSEQ,T4RSPINF.RPS,T4RSPINF.REA,T4RSPINF.WCP,T4RSPINF.OI,T4RSPINF.TD,T4RSPINF.DRDTH,T4RSPINF.LLP,CIF.LNM,CIF.NAM,CIF.MAD1,CIF.MAD2,CIF.MCITY,CIF.MSTATE,CIF.MZIP,CIF.TAXID,CIF.SPOUSE,CIF.PERS,CIF.MCNTRY,CIF.DOB","T4RSPINF,CIF","","T4RSPINF.PID,T4RSPINF.BOO,T4RSPINF.ACN,T4RSPINF.RPASEQ,T4RSPINF.PLANID,T4RSPINF.FORMSEQ","","DQMODE=1")
	if ER.get() use 0 write $$MSG^%TRMVT(RM.get(),"",1)	// Debug Mode
	if rwrs.isEmpty() do VEXIT(1) quit
	while rwrs.next() do { quit:VFMQ
		type String V,VI
		set V=rwrs.getRow().toString()
		set VI=""
		do VGETDATA(V,VI)
		do VPRINT quit:VFMQ
		do VSAVLAST
		}
	do VEXIT(0)

	quit


VINILAST	// Initialize last access key values
	type Public String vovc1,vovc2,vovc3,vovc4,vovc5,vovc6
	set vovc1="",vovc2="",vovc3="",vovc4="",vovc5="",vovc6=""
	quit

VSAVLAST	// Save last access keys values
	type Public String vovc1,vc1,vovc2,vc2,vovc3,vc3,vovc4,vc4,vovc5,vc5,vovc6,vc6
	set vovc1=vc1,vovc2=vc2,vovc3=vc3,vovc4=vc4,vovc5=vc5,vovc6=vc6
	quit


VGETDATA(String V,String VI)	//
	type Public String vc1,vc2,vc3,vc4,vc5,vc6,vc7,vc8,vc9,vc10,vc11,vc12,vc13,vc14,vc15,vc16,vc17,vc18,vc19,vc20,vc21,vc22,vc23,vc24,vc25
	set vc1=V.piece($C(9),1)			// T4RSPINF.PID
	set vc2=V.piece($C(9),2)			// T4RSPINF.BOO
	set vc3=V.piece($C(9),3)			// T4RSPINF.ACN
	set vc4=V.piece($C(9),4)			// T4RSPINF.RPASEQ
	set vc5=V.piece($C(9),5)			// T4RSPINF.PLANID
	set vc6=V.piece($C(9),6)			// T4RSPINF.FORMSEQ
	set vc7=V.piece($C(9),7)			// T4RSPINF.RPS
	set vc8=V.piece($C(9),8)			// T4RSPINF.REA
	set vc9=V.piece($C(9),9)			// T4RSPINF.WCP
	set vc10=V.piece($C(9),10)			// T4RSPINF.OI
	set vc11=V.piece($C(9),11)			// T4RSPINF.TD
	set vc12=V.piece($C(9),12)			// T4RSPINF.DRDTH
	set vc13=V.piece($C(9),13)			// T4RSPINF.LLP
	set vc14=V.piece($C(9),14)			// CIF.LNM
	set vc15=V.piece($C(9),15)			// CIF.NAM
	set vc16=V.piece($C(9),16)			// CIF.MAD1
	set vc17=V.piece($C(9),17)			// CIF.MAD2
	set vc18=V.piece($C(9),18)			// CIF.MCITY
	set vc19=V.piece($C(9),19)			// CIF.MSTATE
	set vc20=V.piece($C(9),20)			// CIF.MZIP
	set vc21=V.piece($C(9),21)			// CIF.TAXID
	set vc22=V.piece($C(9),22)			// CIF.SPOUSE
	set vc23=V.piece($C(9),23)			// CIF.PERS
	set vc24=V.piece($C(9),24)			// CIF.MCNTRY
	set vc25=V.piece($C(9),25)			// CIF.DOB
	quit

	// User-defined pre/post-processor code

VPREAQ	// Pre-processor (after query)

 type public Number ACN,RPASEQ,SUMCNT,YEAR
 type public String IRATAB,PLANID
 type Number BOO,BENACN,DRDTH,OI,RPS,REA,SPI,STOP,TD,WCP
 type Boolean DODD,NOFORM
 set SUMCNT=0
 set YEAR=$$YEAR^SCADAT(%SystemDate)-1


 set STOP=10000000000000000000
 
 type ResultSet rs=Db.select("DISTINCT ACN","IRATYPE")
 while rs.next() do {
 	set ACN=rs.getCol("ACN")
 	type ResultSet rs1=Db.select("RPASEQ,IRATYP,YEFLG,PLANID","IRATYPE","ACN=:ACN AND (RPASEQ<:STOP or RPASEQ=:STOP)","RPASEQ")
 	while rs1.next() do {
 		set RPASEQ=rs1.getCol("RPASEQ")
 		set PLANID=rs1.getCol("PLANID")
 		if 'IRATAB(rs1.getCol("IRATYP")).exists() quit
 		// If tax reporting option is set to 'N' skip this RPASEQ.
 		if 'rs1.getCol("YEFLG") quit
		set (RPS,REA,OI,TD,DRDTH,WCP,BENACN,SPI)=""
		type RecordIRA ira=Db.getRecord("IRA","ACN=:ACN,RPASEQ=:RPASEQ,TAXYR=:YEAR")
	 	type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN")
 		// Set the Date of Death Distributions variable.
		set DODD=0
		// If the plan owner is living, unset the Death Distributions variable.
		if (ira.d6>0)!(ira.d26>0)!(ira.d27>0) set DODD=1
		// Determine if a form should be generated for this plan.
		set NOFORM=$$SYSDEVCEFRM(ira)
		if NOFORM=0 set NOFORM=1
		else  set NOFORM=0
		set BOO=cif.boo
		type RecordT4RSPINF t4rspinf()
		set t4rspinf(1)=Db.getRecord("T4RSPINF","PID=:%ProcessID,BOO=:BOO,ACN=:ACN,RPASEQ=:RPASEQ,PLANID=:PLANID,FORMSEQ=1",1)
		set t4rspinf(2)=Db.getRecord("T4RSPINF","PID=:%ProcessID,BOO=:BOO,ACN=:ACN,RPASEQ=:RPASEQ,PLANID=:PLANID,FORMSEQ=2",1)
		do START(ira,cif,.t4rspinf())
		do SET(.t4rspinf())			
 		}
 	}
 quit
START(RecordIRA ira,RecordCIF cif,RecordT4RSPINF t4rspinf())  // Check for date of death and set up forms
	
 /*Member not deceased(if there is no value in any of the Death payout buckets.)
 Only 1 form generated.*/
 
 type public Number ACN,BENACN,DRDTH,FTD,LLP,N,NODOD,OI,RPS,REA,RPASEQ,SPI,STD,SUMCNT,TD,WCP
 type public Boolean DODD,NOFORM
 type String BENREL
 type Number BOO
 set BOO=cif.boo
 
 if 'DODD do {  quit
 	set REA=ira.d18-ira.nrd18   // Refund of Excess Contrib Curr Yr (Reportable)
 	set WCP=ira.d1-ira.nrd1	    // Normal Distribution, Withdrawal and Commutat.
 	set (STD,FTD)=0
 	if (ira.sw1)!(ira.sw18) set STD=ira.sw1+ira.sw18
 	set FTD=((ira.w1+ira.w18)-(ira.nrw1+ira.nrw18))*100   // Tax deducted For This Accountira
 	set TD=STD+FTD
 	set LLP=ira.d47
 	set t4rspinf(1).rea=REA
 	set t4rspinf(1).td=TD
 	set t4rspinf(1).wcp=WCP
 	set t4rspinf(1).llp=LLP
 	if (REA<0)!(TD<0) set t4rspinf(1).negamt=1
 	set t4rspinf(1).noform=NOFORM
 	if (REA<.01),(WCP<.01),(TD<.01),(NOFORM=1) set t4rspinf(1).nodetail=1
 	}
  
 /*Determine if there is a beneficiary and its relationship. If there are
 multiple beneficiaries then no second form will be generated.*/

 set N=0
 type ResultSet rs2=Db.select("BENACN,BENREL","IRABEN")
 while rs2.next() do {
 	set BENACN=rs2.getCol("BENACN")
 	set BENREL=rs2.getCol("BENREL")    // Beneficiary Relationship.
 	type RecordUTBLBENREL utblrel=Db.getRecord("UTBLBENREL","BENREL=:BENREL")
 	if utblrel.spi set SPI=1
 	set N=N+1  // Keep track of the number of Beneficiaries for this RSP.
 	}
 // If there is death disburstments but no date of death, set the NODOD flag.
 if cif.dod'>0 set NODOD=1
 else  set NODOD=""
 
 /* Member deceased, spousal beneficiary and the deceased [CIF]DOD is null
 or invalid.  Suppress form sequence #1 and form sequence #2.*/
 if DODD,NODOD do {  quit
 	set t4rspinf(1).nodod=1
 	set t4rspinf(1).noform=1
 	set t4rspinf(2).nodod=1
 	set t4rspinf(2).noform=1
 	}

 /*Member deceased, no beneficiary. 2 forms generated to estate.  We check
 if member is deceased by determining if there is a value in any of the
 death payout buckets.*/
 if DODD,'BENACN do {  quit
 	set REA=(ira.d18-ira.nrd13)*100 	// Refund of Excess Contrib Curr Yr (Reportable)
    	set WCP=(ira.d1-ira.nrd1)*100		// Normal Distribution, Withdrawal and Commutat.
    	set LLP=(ira.d47)*100			// Lifelong Learning Plan
 	set OI=(ira.d27-ira.nrd27)*100 		// Other Income
    	set TD=($$TDBAL(ira))*100   // Tax deducted for this account.
 
 	// Set the Deemed Receipt on Death Value to the fair market value.
	set DRDTH=$$DFMV()

 	// The first form will report information up to the time of death.
   	set t4rspinf(1).rea=REA
   	set t4rspinf(1).td=TD
   	set t4rspinf(1).drdth=DRDTH
   	set t4rspinf(1).addr=1
   	set t4rspinf(1).wcp=WCP
   	set t4rspinf(1).nodod=NODOD
   	set t4rspinf(1).llp=LLP

    	/* The second form will report information after the date of death and up
 	    to the payout of the plan to the estate.*/
   	set t4rspinf(2).oi=OI
   	set t4rspinf(2).addr=1
   	
	/* For form sequence 2, if all amounts are equal to 0, do not produce a
	   tax form but display it on the detail report.*/
 	if 'OI set t4rspinf(2).noform=1

	/*If a negative amount is going to be displayed in any field on the report,
	then do not produce the tax forms.*/
	
    	if (REA<0)!(TD<0)!(WCP<0)!(OI<0)!(LLP<0) do {
    		set t4rspinf(1).negamt=1
    		set t4rspinf(2).negamt=1
 		}
 	if t4rspinf(1).noform="" do {
 		set t4rspinf(1).noform=NOFORM
 		}
 	if (t4rspinf(2).noform=""),(t4rspinf(2).oi!t4rspinf(2).rps!t4rspinf(2).addr) do {
 		set t4rspinf(2).noform=NOFORM
 		}
    	
    	/* If there is any positive amounts in the REA,IO,TD,
	DRDTH, or WCP, then Form Sequence 1 should always be generated
	no matter what other condition exists.*/
    	if (REA>0)!(OI>0)!(TD>0)!(DRDTH>0)!(WCP>0)!(LLP>0) set t4rspinf(1).noform=""
    	}
 /* Member deceased, spousal beneficiary. 2 forms-1 to estate,1 to spouse
 unless multiple benifs than only 1 form.  We check if a member is deceased
 by determining if there is a value in any of the death payout buckets.*/
 
 if DODD,SPI do {  quit
 	//Refund of Premium to Spouse
 	set RPS=((ira.d26-ira.nrd26)+(ira.d27-ira.nrd27))*100
    	set REA=(ira.d18-ira.nrd18)*100          // Refund of Excess Contrib Curr Yr (Reportable)
   	set LLP=(ira.d47)*100
    	set TD=($$TDBAL(ira))*100      // Tax deducted
    	set WCP=(ira.d1-ira.nrd1)*100
 	
 	// Deemed Receipt on Death is retrieved from the fair market value.
   	set DRDTH=($$DFMV()-ira.d6)*100
	
	set t4rspinf(1).rea=REA
   	set t4rspinf(1).td=TD
   	set t4rspinf(1).drdth=DRDTH
   	set t4rspinf(1).addr=1
   	set t4rspinf(1).wcp=WCP
   	set t4rspinf(1).rps=(ira.d26-ira.nrd13)+(ira.d27-ira.nrd27)
   	set t4rspinf(1).nodod=NODOD
   	set t4rspinf(1).llp=LLP
   	
   	/*The second form will carry the name and address of the beneficiary
 	spouse, and will report the refund of premiums to the spouse as of the
  	date of the payout of the plan.*/
  	
   	if N'>1 do {
   		set t4rspinf(2).rps=RPS
   		set t4rspinf(2).benacn=BENACN
 		}
   	
	 // If more than 1 beneficiary no form will be generated.

 	if N>1 do {
 		set t4rspinf(2).multiben=1
 		set t4rspinf(2).noform=1
 		}

	/*For form sequence 2, if all the amounts equal 0, then do not produce a
  	  tax form but display this form on the detail report with all 0 values.*/
  	  if 'RPS do {
  	  	set t4rspinf(2).noform=1
  	  	}

	/*If a negative amount is going to be displayed in any field on the report,
	  then do not produce the tax forms.*/
	if (REA<0)!(TD<0)!(DRDTH<0)!(WCP<0)!(RPS<0) do {
   		set t4rspinf(1).negamt=1
		}
	
	if N'>1 do {
	  	set t4rspinf(2).negamt=1
	    	}
 	
 	/*In the following line, added the flag for multiple
 	  beneficiaries and removed the flag for negative processing because
	  the multiple benificiary message takes precedence over the neg. msg.*/
	  
	  if N>1 do {
	  	set t4rspinf(1).multiben=1
		set t4rspinf(1).noform=1
	  	}
	  if t4rspinf(1).noform="" do {
	  	set t4rspinf(1).noform=NOFORM
	  	}
	  if (t4rspinf(2).noform=""),(t4rspinf(2).oi!t4rspinf(2).rps!t4rspinf(2).addr) do {
	  	set t4rspinf(2).noform=NOFORM
	  	}

	/*If there is any positive amounts in the REA,RPS,TD,
	  DRDTH, or WCP, then Form Sequence 1 should always be generated
 	  no matter what other condition exists. */
 	if (REA>0)!(RPS>0)!(TD>0)!(DRDTH>0)!(WCP>0) set t4rspinf(1).noform=""
 	}
 	
 /*Member deceased, nonspousal beneficiary. 2 forms-1 to estate,1 to
   beneficiary. If multiple beneficiaries then generate only 1 form to estate.
   Client will manually calculate beneficiaries percentages and type up forms.
   Detail report will show that there were multiple beneficiaries.  We check
   if a member is deceased by determining if there is a value in any of the
   death payout buckets.*/
   
 if DODD,'SPI do {  quit
 	set REA=(ira.d18-ira.nrd18)*100     // Refund of Excess Contrib Curr Yr (Reportable)
 	set WCP=(ira.d1-ira.nrd1)*100	    // Normal Distribution, Withdrawal and Commutat.	
 	set LLP=(ira.d47)*100		    // lifelong learning plan
 	// Refund of Premium to Spouse
 	set RPS=((ira.d26-ira.nrd13)+(ira.d27-ira.nrd27))*100
 	set TD=($$TDBAL(ira))*100
 	set OI=(ira.d27-ira.nrd27)*100    // other income
 	// Deemed receipt of death is received from the Fair Market Value.
 	set DRDTH=$$DFMV()*100
 	
 	/*The first form will carry the address to the Estate, and will report
	  information up to the time of death */
 	set t4rspinf(1).rea=REA
	set t4rspinf(1).td=TD
   	set t4rspinf(1).drdth=DRDTH
	set t4rspinf(1).addr=1
 	set t4rspinf(1).wcp=WCP
   	set t4rspinf(1).nodod=NODOD
 	set t4rspinf(1).llp=LLP
 	
 	/*The second form will carry the address of the beneficiary, and will
  	  report the amount of interest income earned after the date of death */
	if N'>1 do {
 		set t4rspinf(2).oi=OI
 		set t4rspinf(2).benacn=BENACN
 		}
 		
 	// If more than 1 beneficiary no form will be generated.
 	if N>1 do {
 		set t4rspinf(2).multiben=1
 		set t4rspinf(2).noform=1
 		}
 		
 	/*For form sequence 2, if all the amounts equal 0, then do not produce a
 	tax form but display this form on the detail report with all 0 values.*/
 	if 'OI do {
 		if N'>1 do {
 			set t4rspinf(2).noform=1
 			}
 		if N>1 do {
 			set t4rspinf(2).multiben=1 
			set t4rspinf(2).noform=1
 			}
 		}
 		
 	/*If a negative amount is going to be displayed in any field on the report,
  	  then do not produce the tax forms.*/
 	if (LLP<0)!(REA<0)!(TD<0)!(DRDTH<0)!(WCP<0)!(OI<0) do {
 	   	set t4rspinf(1).negamt=1
 		if N'>1 do {
 			set t4rspinf(2).negamt=1
 			}
 		/*Removed the negative processing flag since the
 		  multiple benificiary flag takes precedence.*/
 		if N>1 do {
 			set t4rspinf(2).multiben=1
 			set t4rspinf(2).noform=1
 			}
 		if t4rspinf(1).noform="" do {
 			set t4rspinf(1).noform=NOFORM
 			}
 		if (t4rspinf(2).noform=""),(t4rspinf(2).oi!t4rspinf(2).rps!t4rspinf(2).addr) do {
 			set t4rspinf(2).noform=NOFORM
 			}
 		
 		/*If there is any positive amounts in the REA,IO,TD,
		  DRDTH, or WCP, then Form Sequence 1 should always be generated
 		  no matter what other condition exists.*/
 		if (LLP>0)!(REA>0)!(OI>0)!(TD>0)!(DRDTH>0)!(WCP>0) set t4rspinf(1).noform="" 
 		
 		}
 	}
 if REA+WCP+TD+DRDTH+LLP=0 set t4rspinf(1).noform=1
 do t4rspinf(1).bypassSave()
 if 't4rspinf(1).noform set SUMCNT=SUMCNT+1
 if (t4rspinf(2).noform=""),(t4rspinf(2).noform!t4rspinf(2).multiben) do {       
 	do t4rspinf(2).bypassSave()       
 	set SUMCNT=SUMCNT+1       
 	}
 quit	

SET(RecordT4RSPINF t4rspinf()) // Set up TMP file for forms and detail report
 type public Number DRDTH,LLP,REA,TD,WCP
 if REA+WCP+TD+DRDTH+LLP=0 set t4rspinf(1).noform=1
 do t4rspinf(1).save()
 if (t4rspinf(2).noform=""),(t4rspinf(2).noform!t4rspinf(2).multiben) do {
          do t4rspinf(2).save()
          }
 quit
 	
TDBAL(RecordIRA ira) // Calculate the Tax Deducted for this account.
 type public Number RESDIS,RESSTDIS,NRESDIS
 set RESSTDIS=0
 set RESDIS=RESDIS.get()+(ira.w1+ira.w6+ira.w18+ira.w26+ira.w27)
 set RESSTDIS=RESSTDIS.get()+(ira.sw1+ira.sw6+ira.sw18+ira.sw26+ira.sw27)
 set NRESDIS=NRESDIS.get()+(ira.nrw1+ira.nrw6+ira.nrw18+ira.nrw26+ira.nrw27)
 quit (RESDIS+RESSTDIS-NRESDIS) 

DFMV() // Calculate the Deemed Receipt on Death value from the Fair Market value
 type Number DFMV,CID
 type public Number ACN
 set (DFMV,CID)=""
 type ResultSet rs3=Db.select("CID","DEP","RPASEQ>0")
 while rs3.next() do {
 	set CID=rs3.getCol("CID")
 	type RecordRELCIF relcif=Db.getRecord("RELCIF","ACN=:ACN,CID=:CID")
 	set DFMV=relcif.dfmv
 quit DFMV

SYSDEVCEFRM(RecordIRA ira) // Determine if a form should be produced for this plan.
 
 type public Number NOFORM,DODD
 
 /*If the Plan Owner is deceased.  A form will be generated if there is any
   positive amount in either the Trustee Transfer bucket, Death Transfer to
   Spouse's IRA bucket or Direct Transfer to Qualified Plan bucket.*/
 if DODD do {
 	set NOFORM=((ira.d6-ira.nrd6)>0)!((ira.d26-ira.nrd26)>0)!((ira.d27-ira.nrd27)>0)
 	}
 if DODD quit NOFORM
 
 /* If the Plan Owner is living, produce a form if one of the following
  conditions are met*/
 if (ira.d1-ira.nrd1)>0 quit 1
 if (ira.d18-ira.nrd18)>0 quit 1
 if (ira.w1-ira.nrw1)>0 quit 1
 if (ira.w18-ira.nrw18)>0 quit 1
 if ira.sw1>0 quit 1
 if ira.sw18>0 quit 1
 quit 0
	quit

VPREBQ	// Pre-processor (before query)

 type Number I
 type public String IRATAB(),TAPETBL()

 set TAPETBL(1)="Original Run"
 set TAPETBL(2)="Test Run"
 set TAPETBL(3)="Replacement Run"

 for I=5:1:8 do {
	type RecordSTBLIRA stblira=Db.getRecord("STBLIRA","IRA=:I",1)
	if stblira.getMode() set IRATAB(I)=stblira.desc
	} 
 set IRATAB("ALL")="5,8"




	quit

VBRSAVE(Number LINE,String DATA)	// Save for report browser
	type RecordTMPRPTBR tmprptbr=Class.new("RecordTMPRPTBR")
	set tmprptbr.jobno=%ProcessID
	set tmprptbr.lineno=LINE
	set tmprptbr.pageno=0
	set tmprptbr.seq=0
	set tmprptbr.data=DATA
	do tmprptbr.bypassSave()
	quit

VEXIT(NOINFO)	// Exit from report
	type Public Number IOSL,vcrt,VFMQ,vh(),VLC,VPN,VRWOPT,VSTATS()
	type Public String IO,VTBLNAM
	type Number I,PN,vs(),z
	type String VL=""
	set vs(1)=0,vs(2)=0,vs(3)=0,vs(4)=0,vs(5)=0,vs(6)=0,vs(7)=0
	if 'VFMQ do VSUM
	if 'VFMQ do VRSUM
	if 'VFMQ do {
		// No information available to display
		if NOINFO=1 set VL=$$^MSG(4655) do VOM
		if vcrt set VL="" for z=VLC+1:1:IOSL do VOM

		if 'VTBLNAM.exists() do {
			set vs(2)=0
			}
		}

	if 'VFMQ,vcrt set PN=-1 do ^DBSRWBR(2)
	if 'VRWOPT("NOCLOSE").get() do CLOSE^SCAIO
	do Db.delete("TMPRPTBR","JOBNO=:%ProcessID")	// Report browser data

	quit

VPRINT	// Print section
	type Public Number VD(),VFMQ,VH0,vh(),VNEWHDR,VR,VRG,VRWOPT,VSEQ
	type Number vskp()

	if VRWOPT("NODTL").get() set vskp(2)=1,vskp(3)=1,vskp(4)=1,vskp(5)=1,vskp(6)=1,vskp(7)=1	// Skip detail
	do VBREAK
	do VSUM quit:VFMQ

	if VH0.get() set vh(0)=0,VNEWHDR=1 kill VH0	// Page Break
	if 'vh(0) do VHDG0 quit:VFMQ
	if 'vskp(7).get() do VDTL7 quit:VFMQ
	do VSTAT
	quit

VBREAK	//
	type Public Number VD(),vh(),VH0,vs(),VT()
	quit:'VT(7)
	type Public String vc1,vovc1,vc2,vovc2,vc3,vovc3,vc4,vovc4,vc5,vovc5,vc6,vovc6
	type Number vb1,vb2,vb3,vb4,vb5,vb6,vb7
	set (vb1,vb2,vb3,vb4,vb5,vb6,vb7)=0
	if vb1!(+vovc1'=+vc1) set vs(3)=0,vh(3)=0,VD(1)=0,vb2=1,vb3=1,vb4=1,vb5=1,vb6=1,vb7=1
	if vb3!(+vovc2'=+vc2) set vs(4)=0,vh(4)=0,VD(3)=0,vb4=1,vb5=1,vb6=1,vb7=1
	if vb4!(+vovc3'=+vc3) set vs(5)=0,vh(5)=0,VD(4)=0,vb5=1,vb6=1,vb7=1
	if vb5!(+vovc4'=+vc4) set vs(6)=0,vh(6)=0,VD(5)=0,vb6=1,vb7=1
	if vb6!(vovc5'=vc5) set vs(7)=0,vh(7)=0,VD(6)=0,vb7=1
	quit

VSUM	// Report Group Summary
	type Public Number VFMQ,vs()
	if 'vs(7) set vs(7)=1 do stat^DBSRWUTL(7)
	if 'vs(6) set vs(6)=1 do stat^DBSRWUTL(6)
	if 'vs(5) set vs(5)=1 do stat^DBSRWUTL(5)
	if 'vs(4) set vs(4)=1 do stat^DBSRWUTL(4)
	if 'vs(3) set vs(3)=1 do stat^DBSRWUTL(3)
	if 'vs(2) set vs(2)=1 do stat^DBSRWUTL(2)
	quit

VSTAT	// Data field statistics
	type Public Number VRWOPT(),VT(),vc12,vc13,vc10,vc8,vc7,vc11,vc9
	type Public String VSTATS

	set VT(7)=VT(7)+1
	set VT(7,1,1)=VT(7,1,1)+vc12			// @TOT([T4RSPINF]DRDTH)
	set VT(7,2,1)=VT(7,2,1)+vc13			// @TOT([T4RSPINF]LLP)
	set VT(7,3,1)=VT(7,3,1)+vc10			// @TOT([T4RSPINF]OI)
	set VT(7,4,1)=VT(7,4,1)+vc8			// @TOT([T4RSPINF]REA)
	set VT(7,5,1)=VT(7,5,1)+vc7			// @TOT([T4RSPINF]RPS)
	set VT(7,6,1)=VT(7,6,1)+vc11			// @TOT([T4RSPINF]TD)
	set VT(7,7,1)=VT(7,7,1)+vc9			// @TOT([T4RSPINF]WCP)
	quit

VDTL7	// Detail
	type public String ACN,BENACN,CAC,CAD1,CAD2,CCITY,CCODE,CNAME,CONTACT,CSTATE,CTELE,CZIP,DODD,DRDTH,FTD,IAD1,IAD2,ICITY,INAME,INAME2,IOSL,IRATAB,IRATAB(),ISTATE,IZIP,LLP,N,NODOD,NOFORM,NRESDIS,OI,OII,OIN,PCODE,PLANID,REA,RESDIS,RESSTDIS,RPASEQ,RPS,SBI,SPI,SPOUSAL,SPSIN,STD,SUMCNT,T4RSPTRN,TAPETBL(),TAPETYPE,TCC,TD,V,VD(),VFMQ,VL,VLC,VO,VOFFLG,VRG,VT(),WCP,YEAR,vc1,vc10,vc11,vc12,vc13,vc14,vc15,vc16,vc17,vc18,vc19,vc2,vc20,vc21,vc22,vc23,vc24,vc25,vc3,vc4,vc5,vc6,vc7,vc8,vc9,verror,vh(),vovc1,vovc2,vovc3,vovc4,vovc5,vovc6

	if VLC+1>IOSL do VHDG0 quit:VFMQ

	set VL="120"
	set V=vc14,VO=V do VP1 quit:VFMQ!verror.get()  set V=$E(V,1,20)
	set VL=VL_$J("",3-VL.length())_V		// [SYSDEV,CIF]LNM
	set V=vc15,VO=V do VP2 quit:VFMQ!verror.get()  set V=$E(V,1,12)
	set VL=VL_$J("",23-VL.length())_V		// [SYSDEV,CIF]NAM
	set VL=VL_$J("",36-VL.length())_$E(vc16,1,30)
	set VL=VL_$J("",66-VL.length())_$E(vc17,1,30)
	set VL=VL_$J("",96-VL.length())_$E(vc18,1,28)
	set VL=VL_$J("",124-VL.length())_$E(vc19,1,2)
	do VP3 quit:VFMQ!verror.get()  set V=$E(CCODE,1,3)
	set VL=VL_$J("",126-VL.length())_V
	set VL=VL_$J("",129-VL.length())_$E(vc20,1,10)
	set VL=VL_$J("",139-VL.length())_$E(vc21,1,9)
	set V=vc5,VO=V do VP4 quit:VFMQ!verror.get()  set V=$E(V,1,12)
	set VL=VL_$J("",148-VL.length())_V
	do VP5 quit:VFMQ!verror.get()  set V=$E(T4RSPTRN,1,15)
	set VL=VL_$J("",160-VL.length())_V
	set VL=VL_$J("",175-VL.length())_$E(10E30_0,24+$L(0),99)
	set VL=VL_$J("",184-VL.length())_$E(10E30_vc7,24+$L(vc7),99)
	set VL=VL_$J("",193-VL.length())_$E(10E30_vc8,24+$L(vc8),99)
	set VL=VL_$J("",202-VL.length())_$E(10E30_vc9,24+$L(vc9),99)
	do VP6 quit:VFMQ!verror.get()  set V=$J(SPOUSAL,1)
	set VL=VL_$J("",211-VL.length())_V
	set VL=VL_$J("",212-VL.length())_$E(10E30_0,24+$L(0),99)
	set VL=VL_$J("",221-VL.length())_$E(10E30_vc10,24+$L(vc10),99)
	do VP7 quit:VFMQ!verror.get()  set V=$J(OII,1)
	set VL=VL_$J("",230-VL.length())_V
	set VL=VL_$J("",231-VL.length())_$E(10E30_vc11,24+$L(vc11),99)
	set VL=VL_$J("",240-VL.length())_$E(10E30_vc12,24+$L(vc12),99)
	set V=vc22,VO=V do VP8 quit:VFMQ!verror.get()  set V=$E(V,1,20)
	set VL=VL_$J("",249-VL.length())_V		// [SYSDEV,CIF]SPOUSE
	set V=vc22,VO=V do VP9 quit:VFMQ!verror.get()  set V=$E(V,1,12)
	set VL=VL_$J("",269-VL.length())_V		// [SYSDEV,CIF]SPOUSE
	do VP10 quit:VFMQ!verror.get()  set V=$E(10E30_SPSIN,24+$L(SPSIN),99)
	set VL=VL_$J("",281-VL.length())_V
	set VL=VL_$J("",290-VL.length())_$E(10E30_0,24+$L(0),99)
	set VL=VL_$J("",299-VL.length())_$E(10E30_vc13,24+$L(vc13),99)
	do VOM
	quit


VHDG0	// Page Header
	type Public Number ER,IOSL,vcrt,verror,VFMQ,vh(),VLC,VNEWHDR,VPN,VRG,VRWOPT()
	type public String %MSKD,%TIM,ACN,BENACN,CAC,CAD1,CAD2,CCITY,CCODE,CNAME,CONAM,CONTACT,CSTATE,CTELE,CZIP,DODD,DRDTH,FTD,IAD1,IAD2,ICITY,INAME,INAME2,IRATAB,IRATAB(),ISTATE,IZIP,LLP,N,NODOD,NOFORM,NRESDIS,OI,OII,OIN,PCODE,PLANID,REA,RESDIS,RESSTDIS,RID,RN,RPASEQ,RPS,SBI,SPI,SPOUSAL,SPSIN,STD,SUMCNT,T4RSPTRN,TAPETBL(),TAPETYPE,TCC,TD,VL,WCP,YEAR,vc1,vc10,vc11,vc12,vc13,vc14,vc15,vc16,vc17,vc18,vc19,vc2,vc20,vc21,vc22,vc23,vc24,vc25,vc3,vc4,vc5,vc6,vc7,vc8,vc9,vovc1,vovc2,vovc3,vovc4,vovc5,vovc6,vrundate,vsysdate
	type Number PN,V,VO
	if VRWOPT("NOHDR").get() quit			// Skip page header
	set vh(0)=1,VRG=0
	if VL'="" do VOM
	if vcrt,VPN>0 do { quit:VFMQ!'VNEWHDR
		type Number PN,X
		set VL=""
		for X=VLC+1:1:IOSL do VOM
		set PN=VPN
		do ^DBSRWBR(2)
		set VLC=0
		quit:VFMQ
		if VNEWHDR write $$CLEARXY^%TRMVT
		else  set VLC=VLC+1,VPN=VPN+1
		}

	set ER=0,VPN=VPN+1,VLC=0

	set VL="906"
	set VL=VL_$J("",3-VL.length())_$E(10E30_TAPETYPE,32+$L(TAPETYPE),99)
	do VP11 quit:VFMQ!verror.get()  set V=$E(TCC,1,8)
	set VL=VL_$J("",4-VL.length())_V
	do VP12 quit:VFMQ!verror.get()  set V=$J(SBI,1)
	set VL=VL_$J("",12-VL.length())_V
	set VL=VL_$J("",13-VL.length())_$E(10E30_SUMCNT,27+$L(SUMCNT),99)
	do VP13 quit:VFMQ!verror.get()  set V=$E(INAME,1,30)
	set VL=VL_$J("",19-VL.length())_V
	do VP14 quit:VFMQ!verror.get()  set V=$E(INAME2,1,30)
	set VL=VL_$J("",49-VL.length())_V
	do VP15 quit:VFMQ!verror.get()  set V=$E(IAD1,1,30)
	set VL=VL_$J("",79-VL.length())_V
	do VP16 quit:VFMQ!verror.get()  set V=$E(IAD2,1,30)
	set VL=VL_$J("",109-VL.length())_V
	do VP17 quit:VFMQ!verror.get()  set V=$E(ICITY,1,28)
	set VL=VL_$J("",139-VL.length())_V
	do VP18 quit:VFMQ!verror.get()  set V=$E(ISTATE,1,2)
	set VL=VL_$J("",167-VL.length())_V
	do VP19 quit:VFMQ!verror.get()  set V=$E(CCODE,1,3)
	set VL=VL_$J("",169-VL.length())_V
	do VP20 quit:VFMQ!verror.get()  set V=$E(IZIP,1,10)
	set VL=VL_$J("",172-VL.length())_V
	do VP21 quit:VFMQ!verror.get()  set V=$E(CONTACT,1,22)
	set VL=VL_$J("",182-VL.length())_V
	do VP22 quit:VFMQ!verror.get()  set V=$E(10E30_CAC,30+$L(CAC),99)
	set VL=VL_$J("",204-VL.length())_V
	do VP23 quit:VFMQ!verror.get()  set V=$E(10E30_CTELE,26+$L(CTELE),99)
	set VL=VL_$J("",207-VL.length())_V
	set VL=VL_$J("",214-VL.length())_$E("E",1,1)
	do VOM

	set VNEWHDR=0
	if vcrt set PN=VPN do ^DBSRWBR(2,1)		// Lock report page heading

	quit


VRSUM	// Report Summary
	type Public Number IOSL,verror,VFMQ,vh,VLC,VT(),VX()
	type Public String ACN,BENACN,CAC,CAD1,CAD2,CCITY,CCODE,CNAME,CONTACT,CSTATE,CTELE,CZIP,DODD,DRDTH,FTD,IAD1,IAD2,ICITY,INAME,INAME2,IRATAB,ISTATE,IZIP,LLP,N,NODOD,NOFORM,NRESDIS,OI,OII,OIN,PCODE,PLANID,REA,RESDIS,RESSTDIS,RPASEQ,RPS,SBI,SPI,SPOUSAL,SPSIN,STD,SUMCNT,T4RSPTRN,TAPETYPE,TCC,TD,WCP,YEAR,vc5,vovc1,vovc2,vovc3,vovc4,vovc5,vovc6
	type Number I
	type String V,VL

	set VL=""
	if 'vh(0) do VHDG0 quit:VFMQ
	if VLC+1>IOSL do VHDG0 quit:VFMQ

	set VL="321"
	do VP24 quit:VFMQ!verror.get()  set V=$E(T4RSPTRN,1,15)
	set VL=VL_$J("",3-VL.length())_V
	do VP25 quit:VFMQ!verror.get()  set V=$E(CNAME,1,30)
	set VL=VL_$J("",18-VL.length())_V
	do VP26 quit:VFMQ!verror.get()  set V=$E(CAD1,1,30)
	set VL=VL_$J("",108-VL.length())_V
	do VP27 quit:VFMQ!verror.get()  set V=$E(CAD2,1,30)
	set VL=VL_$J("",138-VL.length())_V
	do VP28 quit:VFMQ!verror.get()  set V=$E(CCITY,1,28)
	set VL=VL_$J("",168-VL.length())_V
	do VP29 quit:VFMQ!verror.get()  set V=$E(CSTATE,1,2)
	set VL=VL_$J("",196-VL.length())_V
	do VP30 quit:VFMQ!verror.get()  set V=$E(PCODE,1,3)
	set VL=VL_$J("",198-VL.length())_V
	do VP31 quit:VFMQ!verror.get()  set V=$E(CZIP,1,10)
	set VL=VL_$J("",201-VL.length())_V
	set VL=VL_$J("",233-VL.length())_$E(10E30_0,30+$L(0),99)
	set VL=VL_$J("",236-VL.length())_$E(10E30_0,26+$L(0),99)
	set VL=VL_$J("",243-VL.length())_$J(YEAR,4)
	set V=(VT(0)+VT(1)+VT(2)+VT(3)+VT(4)+VT(5)+VT(6)+VT(7))	// @CNT(0,IN,7)
	set VL=VL_$J("",247-VL.length())_$E(10E30_V,26+$L(V),99)
	set VL=VL_$J("",254-VL.length())_$E(10E30_0,20+$L(0),99)
	set V=0						// @TOT([T4RSPINF]RPS,0)
	for I=0:1:7 set V=V+VT(I,5,1)
	set VL=VL_$J("",267-VL.length())_$E(10E30_V,20+$L(V),99)
	set V=0						// @TOT([T4RSPINF]REA,0)
	for I=0:1:7 set V=V+VT(I,4,1)
	set VL=VL_$J("",280-VL.length())_$E(10E30_V,20+$L(V),99)
	set V=0						// @TOT([T4RSPINF]WCP,0)
	for I=0:1:7 set V=V+VT(I,7,1)
	set VL=VL_$J("",293-VL.length())_$E(10E30_V,20+$L(V),99)
	set VL=VL_$J("",306-VL.length())_$E(10E30_0,20+$L(0),99)
	set V=0						// @TOT([T4RSPINF]OI,0)
	for I=0:1:7 set V=V+VT(I,3,1)
	set V=$E(10E30_V,20+$L(V),99) do VP32 quit:VFMQ!verror.get()
	set VL=VL_$J("",319-VL.length())_V		// @TOT([T4RSPINF]OI,0)
	do VP33 quit:VFMQ!verror.get()  set V=$E(10E30_OIN,32+$L(OIN),99)
	set VL=VL_$J("",332-VL.length())_V
	set V=0						// @TOT([T4RSPINF]TD,0)
	for I=0:1:7 set V=V+VT(I,6,1)
	set VL=VL_$J("",333-VL.length())_$E(10E30_V,20+$L(V),99)
	set V=0						// @TOT([T4RSPINF]DRDTH,0)
	for I=0:1:7 set V=V+VT(I,1,1)
	set VL=VL_$J("",346-VL.length())_$E(10E30_V,20+$L(V),99)
	set VL=VL_$J("",359-VL.length())_$E(10E30_0,20+$L(0),99)
	set V=0						// @TOT([T4RSPINF]LLP,0)
	for I=0:1:7 set V=V+VT(I,2,1)
	set VL=VL_$J("",372-VL.length())_$E(10E30_V,20+$L(V),99)
	do VOM
	quit

VOM	// Output print line
	type Public Number VLC
	type Public String IO,VL

	use IO
	write VL_$J("",392-VL.length()),!
	set VL="",VLC=VLC+1
	quit

	// Pre/post-processors

VP1	// Column pre-processor - [SYSDEV,CIF]LNM

	type public String vc23

 type public String V

 if vc23=1 set V=""
	quit

VP2	// Column pre-processor - [SYSDEV,CIF]NAM

	type public String vc23
 type Number B,E 
 type public String X,V

 if vc23=1 set V=""
 set X=V,V=""
 for B=1:1:X.length() quit:(X.extract(B))'=""
 for E=B:1:X.length() quit:(X.extract(E))'=""
 set V=X.extract(B,E-1)
	quit

VP3	// Column pre-processor - Variable: CCODE

	type public String vc24
 type public String CCODE
 type String MCNTRY

 set CCODE="   "
 set MCNTRY=vc24
 if vc24'="" do {
	type RecordSTBLCNTRY stblcntry=Db.getRecord("STBLCNTRY","CNTRY=:MCNTRY")
	set CCODE=stblcntry.isoc
	}
	quit

VP4	// Column pre-processor - Variable: PLANID

 type public Number ACN,RPASEQ
 type public String PLANID

 type RecordIRATYPE itype=Db.getRecord("IRATYPE","ACN=:ACN,RPASEQ=:RPASEQ") 
 set PLANID=itype.planid
 
	quit

VP5	// Column pre-processor - Variable: T4RSPTRN

 type public String T4RSPTRN
 set T4RSPTRN=CUVAR.T4RSPTRN
	quit

VP6	// Column pre-processor - Variable: SPOUSAL

	type public String vc25,vc9,vc8
 type public Number ACN,RPASEQ,RSPAGE,SPOUSAL
 type Number BEGYR,X

 set BEGYR=$$BOTY^SCADAT($$BOTY^SCADAT(%SystemDate,1)-1,1) //beginning previous of tax yr
 set X=$$EOTY^SCADAT(BEGYR,1)                       // end of previous tax year
 set RSPAGE=$$NOY^SCADAT(X,vc25)
 set SPOUSAL=1
 type RecordIRATYPE iratype=Db.getRecord("IRATYPE","ACN=:ACN,RPASEQ=:RPASEQ")
 if (iratype.spouseid),(RSPAGE<74),((vc9>0)!(vc8>0)) set SPOUSAL=2
	quit

VP7	// Column pre-processor - Variable: OII

	type public String vc10
 type public Number OII

 set OII=0
 if vc10>0 set OII=1
 if vc10<0 set OII=2
	quit

VP8	// Column pre-processor - [SYSDEV,CIF]SPOUSE

  type public String X,V
  type public Number B,E,L,I,SPOUSAL

  if SPOUSAL=1 quit
  // Set V to first name only. Find 1st non blank character then find 1st blank
  // character. set V to everything from 1st non-blank to 1st blank after - 1.
  set X=V,V=""
  for B=1:1:X.length() quit:(X.extract(B))'=""
  for E=B:1:X.length() quit:(X.extract(E))="" 
  for L=E:1:X.length() quit:(X.extract(L))=""
  set V=X.extract(E,L-1)

	quit

VP9	// Column pre-processor - [SYSDEV,CIF]SPOUSE

 type public String X,V,SPNAME
 type public Number B,E,I,L,SPOUSAL

 set SPNAME=""
 if SPOUSAL=1 quit

 set X=V,V=""                 
 for B=1:1:X.length() quit:(X.extract(B))'=""
 for E=B:1:X.length() quit:(X.extract(E))=""    
 for L=E:1:X.length() quit:(X.extract(L))="" 
 set V=X.extract(B,E-1)                         
	quit

VP10	// Column pre-processor - Variable: SPSIN

 type public Number ACN,RPASEQ,SPSIN,SPOUSAL
 type String X
 
 set SPSIN=0
 if SPOUSAL=1 Q
 /*
 if there is a spouse benificiary, then retrieve the CIF # of spouse
 contributor and the spouses social insurance number.
 */
 type RecordIRATYPE irtype=Db.getRecord("IRATYPE","ACN=:ACN,RPASEQ=:RPASEQ",1)
 set X=irtype.spouseid
 if X do {
	type RecordCIF cif=Db.getRecord("CIF","ACN=:X")
	set SPSIN=cif.taxid
	}
	quit

VP11	// Column pre-processor - Variable: TCC


 // TCC must pattern to 2A4N the A may be blank.

 type public Number G
 type public String TCC,X1,X2,V

 set TCC=CUVAR.TCC
 if 'V.get() quit
 if (V.length())>7 quit
 set X1="",X2=""
 for G=1:1:V.length() quit:(V.extract(G)="")  quit:(V.extract(G))?1N  set X1=X1
 set X2=V.extract(G,99)
 set X1=X1.extract(1,2-(X1.length()))_X1_V.extract(G)
 if X1.length()>2 set X1=X1.extract((X1.length())-1,(X1.length()))
 set X2=("000000").extract(1,6-(X2.length()))_X2
 if (X2.length())>6 set X2=X2.extract((X2.length())-5,(X2.length()))
 set V=X1_X2
	quit

VP12	// Column pre-processor - Variable: SBI

 type public Number SBI

 set SBI=CUVAR.SBI
	quit

VP13	// Column pre-processor - Variable: INAME

 type public String INAME
 set INAME=CUVAR.INAME
	quit

VP14	// Column pre-processor - Variable: INAME2

 type public String INAME2
 set INAME2=CUVAR.INAME2
	quit

VP15	// Column pre-processor - Variable: IAD1

 type public String IAD1
 set IAD1=CUVAR.IAD1
	quit

VP16	// Column pre-processor - Variable: IAD2

 type public String IAD2
 set IAD2=CUVAR.IAD2
	quit

VP17	// Column pre-processor - Variable: ICITY

 type public String ICITY
 set ICITY=CUVAR.ICITY
	quit

VP18	// Column pre-processor - Variable: ISTATE

 type public String ISTATE
 set ISTATE=CUVAR.ISTATE
	quit

VP19	// Column pre-processor - Variable: CCODE

 type public String CCODE
 type String ICNTRY

 set CCODE="   "
 set ICNTRY=CUVAR.ICNTRY
 if ICNTRY'="" do {
 	type RecordSTBLCNTRY stblcntry=Db.getRecord("STBLCNTRY","CNTRY=:ICNTRY")
 	set CCODE=stblcntry.ISOC
	}

	quit

VP20	// Column pre-processor - Variable: IZIP

 type public String IZIP
 set IZIP=CUVAR.IZIP
	quit

VP21	// Column pre-processor - Variable: CONTACT

 type public String CONTACT
 set CONTACT=CUVAR.CONTACT
	quit

VP22	// Column pre-processor - Variable: CAC

 type public Number CAC
 set CAC=CUVAR.CAC
	quit

VP23	// Column pre-processor - Variable: CTELE

 type public Number CTELE
 set CTELE=CUVAR.CTELE
	quit

VP24	// Column pre-processor - Variable: T4RSPTRN

 type public String T4RSPTRN
 set T4RSPTRN=CUVAR.T4RSPTRN
	quit

VP25	// Column pre-processor - Variable: CNAME

 type public String CNAME
 set CNAME=CUVAR.CNAME
	quit

VP26	// Column pre-processor - Variable: CAD1

 type public String CAD1
 set CAD1=CUVAR.CAD1
	quit

VP27	// Column pre-processor - Variable: CAD2

 type public String CAD2
 set CAD2=CUVAR.CAD2
	quit

VP28	// Column pre-processor - Variable: CCITY

 type public String CCITY
 set CCITY=CUVAR.CCITY
	quit

VP29	// Column pre-processor - Variable: CSTATE

 type public String CSTATE
 set CSTATE=CUVAR.CSTATE
	quit

VP30	// Column pre-processor - Variable: PCODE

 type public String PCODE
 type String ccntry
 set PCODE="   "
 set ccntry=CUVAR.CCNTRY
 if ccntry'="" do {
	type RecordSTBLCNTRY stblctry=Db.getRecord("STBLCNTRY","CNTRY=:ccntry")
	set PCODE=stblctry.isoc
	}
	quit

VP31	// Column pre-processor - Variable: CZIP

 type public String CZIP
 set CZIP=CUVAR.CZIP
	quit

VP32	// Column post-processor - @TOT([T4RSPINF]OI,0,IN,13)

 type public Number OIND,V
 set OIND=V
	quit

VP33	// Column pre-processor - Variable: OIN

 type public Number OIND,OIN

 if OIND=0 set OIN=0
 if OIND>0 set OIN=1
 else  set OIN=2
	quit
