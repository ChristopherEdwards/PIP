NOSTTRF	// Nostro Transfer Record Creation & Maintenance
	/*
	   Origin: Matt Lessig - 07/01/94
	   Description: Nostro Transfer Record Creation & Maintenance
	   This routine supports the creation and maintenance
	   of nostro transfer records.  It also generates all
	   transactions necessary to complete the transfer,
	   including reversals.  Transactions are created after
	   the transfer has been authorized or reversed.
	   Inputs:
	         . System        %FN,%LIBS,%UID

	   Returns:
	         . ER    Error indicator         /TYPE=T
	                 Returns ER=1 if an error, otherwise ER="W"

	         . RM    Return message          /TYPE=T
	                 Returns error message if ER=1, otherwise
	                 completion message

	  ---- Revision History -------------------------------------------------

	   07/31/06 - KELLYP - CR 22048
		      Modified END section to eliminate PRECEDENCE warning and 
		      modified REVERSE section to eliminate GTM compilation error.

	   01/30/06 - Radhika - CR 17423
		      Eliminated PSL deprecated features. 

	   10/27/05 - KELLYP - CR 11381
	   	      Modified GETETC section to properly define the ETC based
	   	      on TRB and ITC.  Code was previously returning the wrong
	   	      product-level general purpose transaction codes for DBD
	   	      accounts.

	   10/10/05 - KELLYP - CR 17050
	   	      Modified entire procedure to conform to current PSL 
	   	      standards and to fix several logic errors from previous
	   	      conversion.  Also removed pre-2003 revision history.

	   12/16/03 - CARROLLJ - CR7239
		      Removed call to DATECONV^SWIFTGEN.

	*/

	quit

NEW	// Create a new Nostro Transfer

	do INIT(0)
	
	quit


UPD	// Update an existing Nostro Transfer

	type String NOSQRY

	set NOSQRY="[NOSTTRF]STATUS=1" 

	do INIT(1)

	quit


DIS	// Display an existing Nostro Transfer

	do INIT(2)
	
	quit


AUTH	// Authorize a Nostro Transfer

	type Boolean AUTHFLG
	type String NOSQRY

	// Authorization flag
	set AUTHFLG=1 
	set NOSQRY="[NOSTTRF]STATUS=1"

	do INIT(2)
	
	quit


DEL	// Delete a Nostro Transfer

	type Boolean DELFLG
	type String NOSQRY

	// Deletion flag
	set DELFLG=1 
	set NOSQRY="[NOSTTRF]STATUS=1"
	
	do INIT(3)
	
	quit


REV	// Reverse a Nostro Transfer

	type Boolean REVFLG
	type String NOSQRY

	// reversal flag
	set REVFLG=1 
	set NOSQRY="[NOSTTRF]STATUS=6"

	do INIT(2)
	
	quit


INIT(Number %ProcessMode)	// Initialize

	type public Boolean ER

	type String IO,TRREFNO,VFMQ
	type RecordNOSTTRF fNOSTTRF

	// Query screen
	do VPG00(.fNOSTTRF) if ER!("Q"[VFMQ) quit

	do VPG01(.fNOSTTRF)
	  
	// Process completed/aborted
	do VER(.fNOSTTRF)

	quit


VPG00(RecordNOSTTRF fNOSTTRF)	// Set up

	type public String IO,VFMQ

	type String %READ,%TAB()

	if %ProcessMode=0 set %TAB("TRREFNO")="[NOSTTRF]TRREFNO/XPP=do REFNO0^NOSTTRF"
	else  set %TAB("TRREFNO")="[NOSTTRF]TRREFNO/TBL=[NOSTTRF]TRREFNO,EDT,VDT,AMT,CRCD,STATUS:QU NOSQRY/XPP=do REFNO1^NOSTTRF"

	set %TAB("IO")=$$IO^SCATAB($I)

	set %READ="@@%FN,,,TRREFNO#1"
	if %ProcessMode=2 set %READ=%READ_",,IO#1"

	do ^UTLREAD 

	if "Q"[VFMQ quit

	if %ProcessMode=2,IO'=$I do OPEN^SCAIO

	quit


VPG01(RecordNOSTTRF fNOSTTRF)	// Screen

	type public Boolean ER
	type public String NOSTTRF(),TRREFNO,VFMQ

	set fNOSTTRF=Db.getRecord("NOSTTRF","TRREFNO=:TRREFNO",1)

	// Record locked by another user
	lock +NOSTTRF(TRREFNO):3 else  set VFMQ="Q" do Runtime.setErrMSG("NOSTTRF","2333") quit:ER

	do DRV^USID(%ProcessMode,"NOSTTRF",.fNOSTTRF)

	quit


REFNO0	// TRREFNO Post-Processor (%O=0)

	type public Boolean ER
	type public String X

	// Record already exists 
        if Db.isDefined("NOSTTRF","TRREFNO=:X") do Runtime.setErrMSG("NOSTTRF","2327") quit:ER
          
	quit


REFNO1	// TRREFNO Post-Processor (%O=1)

	type public Boolean AUTHFLG,ER
	type public String X

	// Data Required
	if X.isNull() do Runtime.setErrMSG("NOSTTRF","741") quit:ER

	type RecordNOSTTRF nosttrf=Db.getRecord("NOSTTRF","TRREFNO=:X",1)

	// Record not found
	if 'nosttrf.getMode() do Runtime.setErrMSG("NOSTTRF","2335") quit:ER

	// User who created transfer cannot authorize it
	if AUTHFLG.exists(),nosttrf.uid=%UserID do Runtime.setErrMSG("NOSTTRF","7548") quit:ER

	quit


VER(RecordNOSTTRF fNOSTTRF)	//

	type public Boolean AUTHFLG,ER,REVFLG
	type public String VFMQ
	
	if ER quit

	set AUTHFLG=AUTHFLG.get()
	set REVFLG=REVFLG.get()

	if ((%ProcessMode=2)!(%ProcessMode=4))&(VFMQ="Q")&('AUTHFLG)&('REVFLG) do END quit

	do FILE(.fNOSTTRF)

	do END
	
	quit


FILE(RecordNOSTTRF fNOSTTRF)	// File data
	
	type public Boolean AUTHFLG,DELFLG,REVFLG
	type public String %fkey,TRREFNO,VFMQ
	
	type Number NEWSTAT,OPT
	type RecordTTX ttx()
	
	set AUTHFLG=AUTHFLG.get()
	set REVFLG=REVFLG.get()
	set DELFLG=DELFLG.get()

	// Quit conditions
	if (VFMQ="Q")&('TRREFNO.exists()) quit
	if (VFMQ="Q")&(%fkey="ESC") quit
	if (VFMQ="Q")&('AUTHFLG)&('REVFLG) quit

	// Prompt user to verify actions, then update status
	if (AUTHFLG)!(REVFLG) do { quit:OPT'=1
		if (AUTHFLG) set OPT=$$^DBSMBAR(147)
		if (REVFLG) set OPT=$$^DBSMBAR(148)
		if OPT'=1 set VFMQ="Q" quit
		if AUTHFLG set NEWSTAT=6
		if REVFLG set NEWSTAT=7
	
		// Status
		set fNOSTTRF.status=NEWSTAT
		set VFMQ="F"
		}

	do TRPOST(.fNOSTTRF)

	quit


TRPOST(RecordNOSTTRF fNOSTTRF)	// Build transactions/reversals and post via TTXP2

	type public Boolean AUTHFLG,DELFLG,ER,REVFLG
	type public Number BRCD,RATE
	type public String ET,RM,TRREFNO

	type Number CID,CNT,hseq,PTRC,TAMT,TOPTRC
	type String CRCD,ETC,TCMT,TSO,X()
	
	type RecordTTX ttx()
	
	if (AUTHFLG)!(REVFLG) do {

		// to nostro acct
		set CID=fNOSTTRF.tnostro

		// currency
		set CRCD=fNOSTTRF.crcd

		// ext tran code
		set ETC=$$GETETC(CID,0)

		//amount
		set TAMT=fNOSTTRF.amt

		// value date
		set %EffectiveDate=fNOSTTRF.vdt

		do ^UTLO

		set TSO=""
	
		// trans. ref. number
		set X("SPEC")=TRREFNO
			
		// DS1
		set X("ZARES")=fNOSTTRF.ds2

		// DS2
		set X("ZSTAT")=fNOSTTRF.ds1
	
		do IN^UTSO(.X,.TSO)

		set (TCMT,hseq)=""
		set BRCD=BRCD.get()
		set REVFLG=REVFLG.get()
		set RATE=RATE.get()

		if REVFLG do REVERSE(.fNOSTTRF,CID,hseq,.ETC,.TAMT,.TSO,.TCMT,EFD)

		if (REVFLG)&(EFD>%SystemDate) quit
		
		set CNT=1
		set ttx(CNT)=Class.new("RecordTTX")		
		
		do BLDTR(CID,ETC,TAMT,EFD,%UserStation,TSO,TCMT,CRCD,BRCD,REVFLG,RATE,.ttx(CNT))

		// from nostro acct
		set CID=fNOSTTRF.fnostro
		set ETC=$$GETETC(CID,1)

		// amount
		set TAMT=fNOSTTRF.amt

		set TSO=""

		kill X

		set X("SPEC")=TRREFNO
	
		// stat symbols
		set X("ZARES")=fNOSTTRF.ds2

		// DS1 Statistical Symbol
		set X("ZSTAT")=fNOSTTRF.ds1
	
		do IN^UTSO(.X,.TSO)

		set (TCMT,hseq)=""

		if REVFLG do REVERSE(.fNOSTTRF,CID,hseq,.ETC,.TAMT,.TSO,.TCMT,EFD)
		
		if REVFLG do SWSENT(.fNOSTTRF) quit:ER

		set CNT=CNT+1
                set ttx(CNT)=Class.new("RecordTTX")
		do BLDTR(CID,ETC,TAMT,EFD,%UserStation,TSO,TCMT,CRCD,BRCD,REVFLG,RATE,.ttx(CNT))

		if BRCD.isNull() do {
			type RecordSIGNON signon=Db.getRecord("SIGNON","UID=:%UserID",1)
			if signon.getMode() set BRCD=signon.brcd quit
			else  do { quit
				type RecordSCAU scau=Db.getRecord("SCAU","UID=:%UserID")
				set BRCD=scau.brcd
				}
			set BRCD=CUVAR.bobr
			}

		// Process transactions
		do POST(.ttx())

		if ER,RM.get().isNull() set RM=ET.get()

		if ER quit

		// store ^TTX keys (for reversals)
		if PTRC.exists() set TOPTRC=PTRC

		// Transaction Trace Number
		else  set TOPTRC=(ttx(CNT).trc-1)

		// Effective Dated Transactions (Keys)
		if '(REVFLG) set fNOSTTRF.efdkey=%EffectiveDate_","_BRCD_","_%UserID_","_TOPTRC

		//generate SWIFT messages
		if fNOSTTRF.mt200flg&('REVFLG) do SWFT200(.fNOSTTRF)

		// MT210 Flag
		if fNOSTTRF.mt210flg&('REVFLG) do SWFT210(.fNOSTTRF)
		}

	if ER quit

	// update rec
	if (AUTHFLG)!(REVFLG) set %ProcessMode=1

	if (REVFLG) do SWSENT(.fNOSTTRF)

	if ER quit

	if (DELFLG)!(%ProcessMode=3) do {

		set %ProcessMode=1 

		do fNOSTTRF.setAuditFlag(1)

		// Status
		set fNOSTTRF.status=8
		}

	if %ProcessMode=3 do Db.delete("NOSTTRF","TRREFNO=:TRREFNO")

	if %ProcessMode=0!( %ProcessMode=1) do fNOSTTRF.save()

	quit


BLDTR(Number CID,String ETC,Number TAMT,Date EFD,Number %UserStation,String TSO,String TCMT,String CRCD,Number BRCD,Boolean REVFLG,Number RATE,RecordTTX ttx)	//

	type Number BSEAMT
	type Date TPD

	// Builds transaction record (TTX)
	set TPD=%SystemDate
	set BSEAMT=TAMT 
	
	// Utility to build TTX
	do TTX^TTXEXT(.ttx) 	

	/*	
	 Set ITC if error correct or reversal
	 Internal Transaction Code
	*/

	if (REVFLG)&(EFD'>TPD) set ttx.itc=$$REVITC(.ttx,TPD)

	quit


GETETC(Number CID, Number ITC)  // Returns the nostro/loro account number's external tran code.

	type String TMPETC

	type RecordACN acn=Db.getRecord("ACN","CID=:CID")

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:acn.type")

	if ITC do {
		if acn.trb=0 set TMPETC=prodctl.crtrgp
		else  set TMPETC=prodctl.drtrgp
		}
	else  do {
		if acn.trb=0 set TMPETC=prodctl.drtrgp
		else  set TMPETC=prodctl.crtrgp
		}

	quit TMPETC


REVITC(RecordTTX ttx,Date TPD)  // Returns the error correct/reversal ITC.

	type String P

	// error corrects
	if ttx.efd=TPD set P=6

	// reversals
	if ttx.efd<TPD set P=12

	quit $$ITC^TTXEXT(ttx.itc,P,1)


REVERSE(RecordNOSTTRF fNOSTTRF,Number CID,Number hseq,String ETC,Number TAMT,String TSO,String TCMT,Date EFD)	//

	/*
	Molds transaction into error correct/reversal.  Calls FDKILL
	to destroy future-dated transactions.  Calls UTLHIST to find
	original history sequence number, and UHFETCH to return that
	history record.  Executes multiple edit/error checks.
	*/

	type public Boolean ER
	type public String P

	type Date SAVTJD
	type Number BRCD,I,tamt,TRC,TSEQ,Y
	type String etc,h(),TTXKEY,X()

	// Remove future-dated transactions
	if %EffectiveDate>%SystemDate do { quit
		set SAVTJD=%SystemDate

		// Effective Dated Transactions (Keys)
		set TTXKEY=fNOSTTRF.efdkey

		// Posting date
		#ACCEPT DATE=12/16/03;PGM=John Carroll
		set %SystemDate=TTXKEY.piece(",",1)

		// Branch
		set BRCD=TTXKEY.piece(",",2)

		// User
		set %UserID=TTXKEY.piece(",",3)

		// Sequence
		set TSEQ=TTXKEY.piece(",",4)

		if %ProcessMode=3 do Db.delete("TTXFDT","TJD=:%SystemDate AND BRCD=:BRCD AND UID=:UID AND TSEQ=:TSEQ")

		#ACCEPT DATE=12/16/03;PGM=John Carroll
		set %SystemDate=SAVTJD
		}

	set h(3)=ETC 
	set h(4)=TAMT 
	set h(5)=EFD 
	set h(7)=TSO

	set hseq=$$^UTLHIST(CID,.h()) if hseq.isNull() quit
	
	type RecordHIST fHIST=Db.getRecord("HIST","CID=:CID,TSEQ=:hseq",1)

	// Invalid History Sequence ~p1
	if fHIST.getMode()=0 do Runtime.setErrMSG("HIST","35332",hseq) quit:ER

	set %EffectiveDate=fHIST.tjd 
	set BRCD=fHIST.brcd 
	set %UserID=fHIST.uid
	set TRC=fHIST.trc
	set tamt=fHIST.tamt
	//for I=1:1:tamt.toString().length("#") set tamt.toString().piece("#",I)=-tamt.toString().piece("#",I)
	for I=1:1:tamt.length("#") set tamt.piece("#",I)=-tamt.piece("#",I)
	set etc=fHIST.etc

	// REVERSAL: Incorrect amount
	if TAMT+tamt do Runtime.setErrMSG("NOSTTRF","3540") quit:ER
	set TAMT=tamt

	// REVERSAL: Transaction previously error corrected
	if fHIST.itc.extract(6) do Runtime.setErrMSG("NOSTTRF","3542") quit:ER

	// REVERSAL:
	if fHIST.itc.extract(7) do Runtime.setErrMSG("NOSTTRF","3538") quit:ER

	// Transaction previously reversed
	if fHIST.itc.extract(12) do Runtime.setErrMSG("NOSTTRF","3544") quit:ER
	if fHIST.efd set EFD=fHIST.efd

	set Y=$$EC1(.fHIST)

	// Error correct
	if Y=1 do { quit
		// (EC) SEQ # ~p1
		set TCMT=$$^MSG(7651,fHIST.trc))
		set X("EC")=fHIST.trc do IN^UTSO(.X,.TSO)
		}

	// Reversal
	if Y=2 do { quit
		// REVERSE ~p1 ~p2
		set TCMT=$$^MSG(3543,$$DAT^%ZM(EFD),etc)
		set X("REV")=hseq do IN^UTSO(.X,.TSO)
		}

	set P=$S(%EffectiveDate.isNull():6,%EffectiveDate<%SystemDate:12,1:"")
	set TSO=""
	quit


EC1(RecordHIST fHIST)	// Error Correct or Reversal?

	type public Number BRCD

	if fHIST.tjd=%SystemDate,fHIST.brcd=BRCD,fHIST.uid=%UserID quit 1

	quit 2


SWFT200(RecordNOSTTRF fNOSTTRF)	// General Financial Institution Transfer for its Own Account

	type public String TRREFNO

	type Date DATE,EFD,VDT
	type Number AMT,MSG
	type String CCY,SWDIRECT
	
	set MSG=200

	// EFD is newed in this section & defined here so that the SWAUD and 
	// SWHIST journals are updated for non-EFD nostro transfers.
	if fNOSTTRF.vdt>%SystemDate set EFD=fNOSTTRF.vdt
	
	type RecordSWIFT fSWIFT=Class.new("RecordSWIFT","SWDIRECT='OUT',TRREFNO=:TRREFNO,MSG=:MSG")

	set DATE=%SystemDate 

	// sender
	set fSWIFT.sndr=CUVAR.swiftadd

	// receiver/pay from
	set fSWIFT.rcvr=fNOSTTRF.paidby

	// priority
	set fSWIFT.priority=fNOSTTRF.mt200pri

	// Transaction Reference Number
	set fSWIFT.trnofmt=TRREFNO

	// Value Date/Currency Code/Amount
	set VDT=fNOSTTRF.vdt

	// Currency Code
	set CCY=fNOSTTRF.crcd
	set AMT=$$AMTCONV^SWIFTGEN(fNOSTTRF.amt,CCY)

	set VDT=$$DAT^%ZM(fNOSTTRF.vdt,"YYMMDD")

	// Value Date/Currency/Amount (Sell)
	set fSWIFT.vcas2=VDT_CCY_AMT

	// Sender Correspondent/the account to be debited
	type ResultSet rs=Db.select("CORREACN","ACN","CID=:fNOSTTRF.fnostro")
	if rs.next()  do {

		// From Nostro Accountdo SCANXNOS
		if '$$SCANXNOS(fNOSTTRF.fnostro) quit

		// Sender's Correspondent Type
		set fSWIFT.sndrtype="B"

		// Account of Sender's Correspondent
		set fSWIFT.sndcracc="/"_rs.getCol("CORREACN")
		}

	// Intermediary
	if 'fNOSTTRF.inter.isNull() do {

		// Intermediary (Sell) Type
		set fSWIFT.intstype="A"

		// Intermediary
		set fSWIFT.ints=fNOSTTRF.inter
		}
	else  do {

		// Intermediary (Sell) Type
		set fSWIFT.intstype="D"

		// Intermediary Line 1
		set fSWIFT.ints1=fNOSTTRF.inter1

		// Intermediary Line 2
		set fSWIFT.ints2=fNOSTTRF.inter2

		// Intermediary Line 3
		set fSWIFT.ints3=fNOSTTRF.inter3

		// Intermediary Line 4
		set fSWIFT.ints4=fNOSTTRF.inter4
		}

	// Account w/Institution
	set fSWIFT.accbtype="A"

	// Pay To
	set fSWIFT.recv=fNOSTTRF.payto

	// Sender/Receiver Info
	set fSWIFT.by1=fNOSTTRF.sendrec1

	// Sender to Receiver Line 2
	set fSWIFT.by2=fNOSTTRF.sendrec2

	// Sender to Receiver Line 3
	set fSWIFT.by3=fNOSTTRF.sendrec3

	// Sender to Receiver Line 4
	set fSWIFT.by4=fNOSTTRF.sendrec4

	// Sender to Receiver Line 5
	set fSWIFT.by5=fNOSTTRF.sendrec5

	// Sender to Receiver Line 6
	set fSWIFT.by6=fNOSTTRF.sendrec6

	// Response Date
	set fSWIFT.date=DATE

	// Response Time
	set fSWIFT.time=%CurrentTime

	// Status
	set fSWIFT.status=0

	// Message Transfer Date
	set fSWIFT.swftdt=DATE
	set SWDIRECT="OUT"

	do DOTRANS^SWIFTGEN(.fSWIFT)

	do fSWIFT.save()

	// Create entry in ^SWIFTQ so message is sent to ST400

	// Receiver
	if 'fSWIFT.rcvr.isNull() do QUEUE^SWIFTGEN("RTT",DATE)
	else  do QUEUE^SWIFTGEN("TLX",DATE)

	quit


SWFT210(RecordNOSTTRF fNOSTTRF)	// Notice to Receive SWIFT Message - MT210

	type public String TRREFNO

	type Date DATE,EFD,VDT
	type Number AMT,MSG
	type String CCY,SWDIRECT

	set MSG=210
	
	// EFD is newed in this section & defined here so that the SWAUD and 
	// SWHIST journals are updated for non-EFD nostro transfers.
	if fNOSTTRF.vdt>%SystemDate set EFD=fNOSTTRF.vdt

	type RecordSWIFT fSWIFT=Class.new("RecordSWIFT","SWDIRECT='OUT',TRREFNO=:TRREFNO,MSG=:MSG")

	set DATE=%SystemDate 

	// sender
	set fSWIFT.sndr=CUVAR.swiftadd

	// Ordering Institution Type
	set fSWIFT.ordtype="A"

	// paid by
	set fSWIFT.ordinst=fNOSTTRF.paidby

	// receiver
	set fSWIFT.rcvr=fNOSTTRF.payto

	// priority
	set fSWIFT.priority=fNOSTTRF.mt210pri

	set fSWIFT.trnofmt=TRREFNO

	// related reference
	set fSWIFT.relref=fNOSTTRF.relref

        type ResultSet rs=Db.select("CORREACN","ACN","CID=:fNOSTTRF.tnostro")
        if rs.next()  do {
	
		// To Nostro Accountdo SCANXNOS
		if '$$SCANXNOS(fNOSTTRF.tnostro) quit

		// Account Identification
		set fSWIFT.acctid="/"_rs.getCol("CORREACN")
		}

	// Value Date/Currency Code/Amount
	set VDT=fNOSTTRF.vdt

	// Currency Code
	set CCY=fNOSTTRF.crcd
	set AMT=$$AMTCONV^SWIFTGEN(fNOSTTRF.amt,CCY)

	set VDT=$$DAT^%ZM(fNOSTTRF.vdt,"YYMMDD")

	// Trade Date
	set fSWIFT.tdt=VDT

	// Currency Code/Amount (Buy)
	set fSWIFT.crcdamtb=CCY_AMT

	// Intermediary
	if 'fNOSTTRF.inter.isNull() do {

		// Intermediary (opt)
		set fSWIFT.intbtype="A"

		// Intermediary
		set fSWIFT.intb1=fNOSTTRF.inter
		}

	else  if 'fNOSTTRF.inter1.isNull() do {

		// Intermediary (opt)
		set fSWIFT.intbtype="D"

		// Intermediary Line 1
		set fSWIFT.intb1=fNOSTTRF.inter1

		// Intermediary Line 2
		set fSWIFT.intb2=fNOSTTRF.inter2

		// Intermediary Line 3
		set fSWIFT.intb3=fNOSTTRF.inter3

		// Intermediary Line 4
		set fSWIFT.intb4=fNOSTTRF.inter4
		}

	// Status
	set fSWIFT.status=0

	// Message Transfer Date
	set fSWIFT.swftdt=DATE
	set SWDIRECT="OUT"

	do DOTRANS^SWIFTGEN(.fSWIFT)

	do fSWIFT.save()

	// Create entry in ^SWIFTQ so message is sent to ST400

	// Receiver
	if 'fSWIFT.rcvr.isNull() do QUEUE^SWIFTGEN("RTT",DATE)
	else  do QUEUE^SWIFTGEN("TLX",DATE)

	quit


SWSENT(RecordNOSTTRF fNOSTTRF)	// Determine if the SWIFT messages have been sent yet.

	type public Boolean ER
	type public String TRREFNO

	if fNOSTTRF.mt200flg do SWSENT2(.fNOSTTRF,TRREFNO,200) quit:ER
	if fNOSTTRF.mt210flg do SWSENT2(.fNOSTTRF,TRREFNO,210)

	quit


SWSENT2(RecordNOSTTRF fNOSTTRF, String TRREFNO, Number MSG)

	// Individually handle the deletion of those messages that 
	// have not been sent yet.

	type String SWDIRECT

	set SWDIRECT="OUT"

	type RecordSWIFT fSWIFT=Db.getRecord("SWIFT","SWDIRECT=:SWDIRECT,TRREFNO=:TRREFNO,MSG=:MSG",1)

	// Only delete if RTT or TLX
	if (fSWIFT.status'=0)&(fSWIFT.status'=7) quit

	do SWDEL(.fSWIFT)

	quit


SWACK(Date MTDT)

	// Check if all SWIFT messages have been successfully transmitted.

	if MTDT.get() quit 1

	quit 0


SWDEL(RecordSWIFT swift) // SWIFT Delete

	/*
	 Delete all SWIFT messages that were spawned from this now
	 reversed nostro transfer.  This will only delete SWIFT messages
	 that have not been sent yet.
	*/

	type public String TRREFNO

	type String TCMT

	do swift.setAuditFlag(1)

	// Status
	set swift.status=5

	// Message deleted
	set TCMT=$$^MSG(7652)

	if %ProcessMode=1 do swift.save()

	do SWQDEL(swift.status,TRREFNO,swift.msg,swift.swftdt)

	quit


SWQDEL(Number STAT,String REFNO,Number MSGTYP,Date DATE)

	type public String SWIFTQ(,)

	type Number QSEQ
	type String QTYP

	// Delete entry from ^SWIFTQ
	if (STAT=5)!(STAT=3) quit

	set QSEQ="" 
	set QTYP=$S(STAT=0:"RTT",STAT=4:"PRC",STAT=6:"REV",STAT=7:"TLX",1:"XXX")
	if QTYP="XXX" quit

	lock +SWIFTQ(QTYP,DATE):3 else  quit

	type RecordSWQCNTD qinfo=Db.getRecord("SWQCNTD","QUE=:QTYP,DT=:DATE",1)
	set qinfo.tot=qinfo.tot-1
	do qinfo.bypassSave()

	do Db.delete("SWIFTQ1","QUE=:QTYP AND DT=:DATE AND TRREFNO=:REFNO AND TYPE=:MSGTYP")

	lock -SWIFTQ(QTYP,DATE)
	quit


SCANXNOS(Number NOSTRO)

	/*
	 Scan ^XNOS for multiple nostros at same correspondent institution
	 in the same currency.
	*/

	type Boolean FLAG = 0

	type RecordDEP dep=Db.getRecord("DEP","CID=:NOSTRO",1)
	if dep.corre.isNull()!(dep.crcd.isNull()) quit FLAG
	
	type ResultSet rs=Db.select("CID","DEP","CORRE=:dep.corre AND CRCD=:dep.crcd")
	while rs.next() do {  quit:FLAG
		if rs.getCol("CID")'=NOSTRO set FLAG=1
		}

	quit FLAG


END	// End process

	type public Boolean AUTHFLG,DELFLG,ER,REVFLG
	type public String NOSTTRF(),RM,TRREFNO,VFMQ

	if TRREFNO.exists() lock -NOSTTRF(TRREFNO)

	if ER.exists()!(((%ProcessMode=2)!(%ProcessMode=4))&'AUTHFLG&'REVFLG) quit

	if VFMQ="Q" do {

		// Nostro transfer not created
		if %ProcessMode=0 set RM=$$^MSG(7689) quit

		// Nostro transfer not authorized
		if AUTHFLG set RM=$$^MSG(7688) quit

		// Nostro transfer not reversed
		if REVFLG set RM=$$^MSG(7692) quit

		// Nostro transfer not deleted
		if DELFLG set RM=$$^MSG(7690) quit

		// Nostro transfer not modified
		set RM=$$^MSG(7691)
		}
	else  do {

		// Nostro transfer created
		if %ProcessMode=0 set RM=$$^MSG(7685) quit

		// Nostro transfer authorized
		if AUTHFLG set RM=$$^MSG(7684) quit

		// Nostro transfer reversed
		if REVFLG set RM=$$^MSG(7693) quit

		// Nostro transfer deleted
		if DELFLG set RM=$$^MSG(7686) quit

		// Nostro transfer modified
		set RM=$$^MSG(7687)
		}
		
	set ER="W"
	
	quit


POST(RecordTTX ttx())	// Call ^TTXRPC to post the TR array

	type public Boolean ER
	type public Number BRCD
	type public String ET,RJ,RM

	type Number I

	do TRNSET^TRNDRV(.ttx(),%SystemDate,BRCD,2,,.RJ())

	/*
	If an error or if rejected because of overrides, log the exception
	Overrides required.  See Rejected Tansaction Report (@REP220)
	*/

	if (ER)!RJ.exists() do {
		set ER=1 
		set ET=$$^MSG(7696)
		}

	if ER do {
		if ET.get().isNull() set ET=RM.get()
		do EXC
		}
	quit


EXC	// Log error in exception file.
	
	type public Number CID,%ZTSEQ
	type public String ET
	
	type Number BAL = ""

	if CID.exists() do {
		type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
		set BAL=acn.bal
		}

	// Nostro transfer not authorized
	do LOG^UTLEXC($T(+0),"*",$$^MSG(7688),CID.get(),%ZTSEQ.get(),ET.get(),$S(CID.get():BAL,1:""))

	kill ET,%ZTSEQ

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60479^62681^Pat Kelly^19875"	// Signature - LTD^TIME^USER^SIZE
