public TTXODC(RecordDEP dep,RecordTTX ttx,RecordTRN trn)	// Transaction Overdraft Protection
	/*
	ORIG: Frank R. Sanchez (2497)
	DESC: This routine is called by the general deposit debit
	      transaction (withdrawal).  This will generate any necessary
	      overdraft transfer transactions and/or generate and
	      applicable service fee transactions.

	a) Init necessary variables
	b) Collate through node 100 accounts in hierarchy order
	c) Use node 100 accounts to "protect" the deposit account by using
	   their available funds to cover the deposit withdrawal.
	d) If available funds are transferred, set [DEP]ODSI flag.

	   INPUT:	dep - deposit account object
	   		ttx - transaction object

	   RETURNS:	ER - Processing error indicator
			0 = Post , 1 = No post

	   VARIABLES
	   ---------
	   AVLAMT  -   Available amount to transfer to overdraft account
	   REQAMT  -   Required amount to satify overdraft account
	   REQNET  -   Running net required amount left to be satisfied

	---- Revision History ------------------------------------------------
	
	12/27/06 - MBUIM - CR 24545
		   Retrofit CR 3110 from Profile01
		   Modified FEEDR section to check the FEETYP and return
		   the unique event related trans code - the DR Service
		   fee trans code (PRODCTL.DRTRSC) or the General Debit
		   Trans Code (PRODCTL.DRTRGP) by calling into
		   the procedure BCHFEEUTL. 
	
	07/18/06 - DESHPANDE S K - CR 20748
		   Replaced Transaction Variable %TRNMODE with Transaction 
		   Stored Value and changed the logic to indicate fake transaction
		   by using ISBYPASS flag instead of using %TRNMODE.
		   		
	06/22/06 - ratht - CR 21419
		   Modified the MC section to prevent UNDEFINED error
		   on %EffectiveDate.
		   
	05/19/06 - NATRAJAH - CR21346
		   In DELETE section, after setting override array
		   "OVR(dep.cid,"OVR","NTODPLM")" modified the return value to
		   "0" to avoid roll backing overdraft transaction.
		   
	05/15/06 - RussellDS - CR20909
		   Modified DISPOSE section to replace %ttxmode with %TRNMODE,
		   and remove REJMET reference.  Also, fix problem in HIST
		   section to replace SEQ with %TRNSEQ.
		   
		   Replace old, invalid reference to CRT with %TRNMODE.
		   
		   Remove invalid comments from DISPOSE section.
	
	05/09/06 - NATRAJAH - CR 20902
		   In File section, modified transaction mode 4 to 5 in
		   TRNSINGL^TRNDRV call. since this will avoid processing 
		   OVERRIDE^TRNDRV section while processing overdraft 
		   transactions. 

	04/25/06 - NATRAJAH - CR 20843
		   . In PROC section, removed the line of code which sets the
		     REQAMT value based on Incremental overdraft amount, since
		     This was handled in CHKAVL section.
		   . In INIT section, removed the line of code which set the
		     MINDRL,MINDRD,INCDRL,INCDRD value based on prodctl.odsmtr
		     and prodctl.odsitr, since precedence is based on overdraft
		     source account product level and this was handled in 
		     CHECKACN section. 

	03/28/06 - TELIV - CR 20379
		   Modified section INIT, added code to give precedence to 
		   PRODCTL values ODSITR, ODSMTR while computing overdraft
		   limits. Bypass History if the transaction is Fake.
		   Modified FEEAMT2 to set %EffectiveDate
		   
	
	03/24/06 - NATRAJAH CR 20022
		   In ODP section, added line of code to restore the dep object
		   to orignal state after executing the Rollback command.

	03/21/06 - TELIV - CR 20235
		   Modified section INIT to check for Null values from prodctl 
		   variables (INCDRD, INCDRL, MINDRD, MINDRL)
		   Modified section PROC to Check for the Incremental Overdraft
		   amount to avoid dived by zero error.

	03/20/06 - TELIV - CR 19898
		   Modified section PROC, added checks for Minimum and 
		   Incremental Overdraft amounts specified at product level.
	
	03/08/06 - KELLYP - CR 19758
		   Modified FILE section to pass a TRNMODE of "4" (sys-generated)
		   instead of "5" (secondary).  This corrects a problem where 
		   TRNDRV did not set ITC7 = 2 as is customary for overdraft
		   transactions in prior versions and prevents issues with 
		   system balancing.  
	
	02/28/06 - NATRAJAH - 19486
		   In TFRCR section, added line of code to set StoredValue of
		   EndBal to dep object.
		   
	08/25/05 - RussellDS - CR16911
		   Modify FILE section to call TRNSINGL^TRNDRV for
		   miscellaneous transactions as well as "D" and "L".
		   
		   Corrected minor PSL issues - scope warnins still exist.
		   
		   Modified FEECR section to account number used to load ACN.
		   
		   Removed old revision history.
	----------------------------------------------------------------------
	*/

	new ODPINQ,TAMT

	// Overdraft protection inquiry flag
	set ODPINQ=0
	set TAMT=ttx.tamt
	
	//Setting the third parameter to false indicates non fake transaction.
	type Boolean ISBYPASS = 0
	do START(.dep, .ttx, .trn, ISBYPASS)

	quit


START(RecordDEP dep, RecordTTX ttx, RecordTRN trn, Boolean ISBYPASS)

	new BBAL,BCRCD,BCUSTCD,HISTSEQ,INCDR,INCDRD,INCDRL,ITC7
	new MINDR,MINDRD,MINDRL,ORGTAMT,RC,SECSEQ,XFRSEQ

	do INIT(.dep, .ttx, ISBYPASS)
	if ER quit

	do PROC(.dep,.ttx,.trn)

	quit


INIT(RecordDEP dep, RecordTTX ttx, Boolean ISBYPASS)	// Initializations

	type Public Cache %CACHE()

	new CID,TYPE

	set CID=dep.cid
	set TYPE=dep.type

	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE")

	// O/D Protection Incr Tfr (LN)
	set INCDRL=prodctl.inctfrl
	if INCDRL.isNull() set INCDRL=0
	
	// O/D Protection Incr Tfr (DEP)
	set INCDRD=prodctl.inctfrd
	if INCDRD.isNull() set INCDRD=0
	
	// O/D Protection Min Tfr (LN)
	set MINDRL=prodctl.mintfrl
	if MINDRL.isNull() set MINDRL=0
	
	// O/D Protection Min Tfr (DEP)
	set MINDRD=prodctl.mintfrd
	if MINDRD.isNull() set MINDRD=0

	// Do not log history if this is a fake transaction
	if 'ISBYPASS do {
		set HISTSEQ=ttx.getStoredValue("HistSeq")
		set SECSEQ=Db.currVal("HISTDST","CID,HISTSEQ")+.01
	}
	
	set ORGTAMT=TAMT
	set ITC7=ttx.itc7
	set BBAL=+dep.bal

	// Screen base currency code - for $$MC
	set BCRCD=dep.crcd
	if BCRCD="" set BCRCD=%SystemCurrency

	// Screen base Customer code - for $$MC
	set BCUSTCD=dep.ccode

	// Not set up for return checks
	if '$G(%RET) set RC=0
	// Return Code - Inclearing
	else  set RC=+dep.rc

	quit


PROC(RecordDEP dep,RecordTTX ttx,RecordTRN trn)	// Process

	new %FEE,ETC,FEEAMT,FEECHK,INCRVAL,OFEEAMT,PCFD15,REQAMT,SBAL

	set ETC=ttx.etc
	set FEECHK=0
	set SBAL=$$ODBB(.dep)
	set REQAMT=TAMT-SBAL

	if dep.minbal,dep.bal-TAMT+REQAMT<dep.minbal set REQAMT=TAMT-dep.bal+dep.minbal

	/*
	If Service Charge Account Number not defined and TRN.PCFD10 (Consider
	Transaction Service Fee) set, add amount of the direct transaction
	fee charged to primary tran account to the required amount
	*/
	if dep.svcfeecid="",trn.pcfd10 set REQAMT=REQAMT+$$TRNFEE(.dep,TAMT,ETC)

	// Restrict Loan
	set PCFD15=trn.pcfd15
	set REQAMT=REQAMT-dep.nsflim

	if REQAMT>0 do ODP(.dep,.ttx)

	if CUVAR.SFEEOPT,'FEECHK do {
		set %FEE = ttx.getStoredValue("TranMode")
		do FEE(.dep, ttx.getStoredValue("TranMode"))
		}

	if 'ODPINQ,REQAMT>0 set dep.odld=%SystemDate

	quit


ODP(RecordDEP dep,RecordTTX ttx)	// Seek overdraft protection

	new DELETE,SAVPTR,TCMT

	type RecordDEP depsave
	if dep.exists() set depsave = dep.copy()
	// O/D protection option (1 and 3 allowed) - Load XFRSEQ array
	if dep.odo#2 do {
		// Source account number, priority
		new I,PRI,SCID

		type ResultSet rs=Db.select("ODACN,PRI","DEPODP","CID=:CID","PRI ASC")

		if rs.isEmpty() quit

		while rs.next() do {
			set SCID=rs.getCol(1)
			set PRI=+rs.getCol(2)

			type RecordACN acn=Db.getRecord("ACN","SCID")

			if acn.stat=4 quit

			if '$D(XFRSEQ(PRI)) set XFRSEQ(PRI)=SCID quit
			// Next sequence
			for I=PRI+.01:.01 if '$D(XFRSEQ(I)) set XFRSEQ(I)=SCID quit
			}
		}

	do Runtime.start("CS","","SAVPTR")

	// Do not transfer
	if '$D(XFRSEQ) set REQNET=REQAMT
	// Possible transfer
	else  do {
		set FEEAMT=0

		do FEEPOST(.dep,"ODT",1,.FEEAMT)

		set (REQAMT,REQNET)=REQAMT+FEEAMT

		do XFR(.dep,.ttx)
		}

	// No or not enough funds available to transfer
	set %FEE=1
	set DELETE=$$DELETE(.dep, REQNET, .%FEE, ttx.getStoredValue("TranMode"))

	if DELETE do { quit

		do Runtime.rollback("SAVPTR")
		
		if depsave.exists() set dep = depsave.copy()

		do DISPOSE(.dep,.ttx)
		}

	else  do Runtime.commit()

	if 'DELETE,REQNET>0,$D(XFRSEQ) do {

		new ODAVLF

		set ODAVLF=$$ODAVLF^DEPDI(CID)

		// Transaction exceeds total available for overdraft $<ODAVLF>
		set OVR(dep.cid,"OVR","ODAVLF")=$$^SCARND(ODAVLF,0,dep.cid)
		}

	if REQAMT=REQNET quit

	if 'ODPINQ do {

		new EC

		// Loan Error-Correct Data
		set EC=ttx.lnerc
		// Overdraft occured TTXODC
		set $P(EC,"#",5)=1
		// Loan Error-Correct Data
		set ttx.lnerc=EC
		}

	if '$D(XFRSEQ) quit

	do FEEPOST(.dep,"ODT",0,.FEEAMT)

	// Transaction will incur overdraft processing
	set OVR(dep.cid,"OVR","ODAMSG")=""

	quit


DELETE(RecordDEP dep, REQNET, %FEE, Number PTRNMOD)

	// Based upon Required, force neg, neg tamt limit do we need to delete tran or not.
	if 'REQNET quit 0

	set %FEE=$G(PTRNMOD)

	// Don't Allow Negative on Overdraft Failure
	if 'dep.fnbodp quit 1

	// Neg Tran Limit on ODP Failure
	if dep.ntodplm="" do { quit 0

		// Insufficient O/D Funds, Account will be forced negative
		if REQNET'>dep.ntodplm set OVR(dep.cid,"OVR","NTODPINV")=""
		}

	if REQNET'>dep.ntodplm quit 0

	// Amt Exceeds Neg Tran limit on Overdraft Protection
	set OVR(dep.cid,"OVR","NTODPLM")=""

	quit 0


XFR(RecordDEP dep,RecordTTX ttx)	// Collate through overdraft hierarchy to transfer funds

	new CID,CRCD,XREQNET

	set (ER,XFRSEQ)=""
	set XREQNET=REQAMT

	for  set XFRSEQ=$O(XFRSEQ(XFRSEQ)) quit:'REQNET!(XFRSEQ="")  do {

		/*
		  From here on dep will represent the original account the overdrafts are
		  trying to be generated for and acn2 will represent the accounts funds
		  are trying to be drawn from to cover the overdraw of dep.
		*/
		new SAVPTR

		do Runtime.start("CS","","SAVPTR")

		set CID=XFRSEQ(XFRSEQ)

		type RecordACN acn2=Db.getRecord("ACN","CID")

		set CRCD=acn2.crcd
		if CRCD="" set CRCD=%SystemCurrency

		do CHKAVL(.dep,.acn2,.ttx)

		// if ER rollback to previous attempt's REQNET and continue with next account
		if ER do {
			do Runtime.rollback("SAVPTR")

			set REQNET=XREQNET
			set ER=""
			}

		// if successful, commit this transfer and continue with next account
		else  do {
			set XREQNET=REQNET

			do acn2.bypassSave()
			do Runtime.commit()
			}
		}

	quit


CHKAVL(RecordDEP dep,RecordACN acn2,RecordTTX ttx)	// Check available funds and invoke overdraft protection

	new AVLAMT,ORIGAVL,TFRAMT

	set AVLAMT=$$CHECKACN(.acn2)
	set ORIGAVL=AVLAMT
	set AVLAMT=$$MC(.acn2,AVLAMT,1)

	// Adjust AVLAMT and TFRAMT to Incremental DR
	if INCDR do {
		set AVLAMT = (AVLAMT \ INCDR) * INCDR
		set TFRAMT = ((REQNET \ INCDR) * INCDR) + (INCDR * ((REQNET # INCDR) '= 0))
		}
	else  set TFRAMT=REQNET

	// Nothing available, quit
	if 'AVLAMT quit

	// Adjust TFRAMT to Minimum DR
	if MINDR,TFRAMT<MINDR set TFRAMT=MINDR

	// Compare TFRAMT to AVLAMT to find appropriate TAMT
	if AVLAMT<TFRAMT set TAMT=AVLAMT
	else  set TAMT=TFRAMT

	do INVOKE(.dep,.acn2,.ttx,TAMT)

	quit


INVOKE(RecordDEP dep,RecordACN acn2,RecordTTX ttx,TAMT)	// Invoke overdraft protection

	new BASEAMT

	set BASEAMT=""

	if %MCP,CRCD'=BCRCD do {
		// Calculate secondary currency exchange amount
		do EXC^CRCDUTL(BCRCD,CRCD,TAMT,1,1,"00",dep.ccode,%EffectiveDate,1,,%SystemCurrency)

		// Save TAMT for target account
		set BASEAMT=TAMT
		set TAMT=$$^SCARND(EXCAMT,0,dep.cid)
		}
	if ER quit

	// To avoid rounding differences
	if TAMT>ORIGAVL set TAMT=ORIGAVL
	if 'ODPINQ do TFRDR(.dep,.acn2,.ttx)
	if ER quit

	// Use base amount
	if BASEAMT'="" set TAMT=BASEAMT

	set REQNET=REQNET-TAMT

	if REQNET<0 set REQNET=0
	if 'ODPINQ do TFRCR(.dep,.acn2,.ttx)

	quit


TFRDR(RecordDEP dep,RecordACN acn2,RecordTTX ttx) // Debit source (protection) account

	new TSOTCMT

	set TCMT="TFR-"_dep.cid

	// Set TLO, put TCMT from original transaction into TSO's TCMT of secondary
	set %UserStation=ttx.tlo
	set TSOTCMT=$E(ttx.tcmt,1,80)
	// Remove special characters
	set TSOTCMT=$TR(TSOTCMT,"~#","  ")
	set TSO="TCMT#"_TSOTCMT

	// Load debit tran code
	do ODPDR(.acn2)
	do FILE(.acn2,"",dep.cid,dep.cc)

	quit


ODPDR(RecordACN acn2)	// Overdraft protection debit tran code

	type Public Cache %CACHE()

	new TYPE

	set TYPE=acn2.type

	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE")

	if acn2.cls="L" set ETC=prodctl.drtrgp

	else  do {
		set ETC=prodctl.drtrot
		if ETC="" set ETC=prodctl.drtrgp
		}

	quit


TFRCR(RecordDEP dep,RecordACN acn2,RecordTTX ttx)	// Credit target (overdraft) account

	new UTSO

	// Transfer debit account class
	set UTSO("TFR")=acn2.cid
	set UTSO("ODTO")=ORGTAMT
	set UTSO("ODTSB")=BBAL
	set UTSO("ODTBB")=SBAL
	set UTSO("ODTF")=FEEAMT

	do IN^UTSO(.UTSO,.TSO)

	// Overdraft protection
	set TCMT=$$^MSG(5159)

	// Load credit tran code
	do ODPCR(.dep,.acn2)
	do dep.setStoredValue("EndBal", dep.bal - ttx.tamt)	
	do FILE(.dep,"",dep.cid,dep.cc)

	quit


ODPCR(RecordDEP dep,RecordACN acn2)	// Overdraft protection credit tran code

	type Public Cache %CACHE()

	new TYPE

	set TYPE=dep.type

	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE")

	// CR Overdraft Transfer
	set ETC=prodctl.crtrot
	// CR General Purpose
	if ETC="" set ETC=prodctl.crtrgp

	/*
	 Set loan O/D Repayment Use Flag only if Loan O/D Repayment Flag is
	 set and transfer debit account is a loan
	*/
	if dep.odsf,acn2.cls="L" set dep.odsi=1

	quit


FILE(RecordACN acn,GL,ORIGCID,ORIGCC)	// File Data

	type public Cache %CACHE()

	type Boolean lnsysgen

	set lnsysgen=1

	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC")
	type RecordTTX ttx=Class.new("RecordTTX")

	if GL'="" set ttx.cid=GL
	else  set ttx.cid=acn.cid
	set ttx.itc=trn.itc
	set ttx.etc=ETC
	set ttx.tamt=TAMT
	set ttx.efd=%EffectiveDate
	set ttx.tlo=%UserStation
	set ttx.tso=TSO
	set ttx.tcmt=TCMT

	// Loan Error-Correct Data
	if $G(TR16)'="" set ttx.lnerc=TR16

	// Currency Code
	set ttx.crcd=acn.crcd
	if ttx.crcd="" set ttx.crcd=%SystemCurrency

	// Record as memo transaction
	if ttx.getStoredValue("isPrimary")'=1 set ttx.cdt=1

	// Cost Center
	if "DL"'[trn.cls do {
		set ttx.cc = ORIGCC
		do TRNSINGL^TRNDRV(.ttx,,TPD,BRCD,5)
		if ER,'$G(NOEXC) do LOG(.acn)
		}
	else  do {
		do TRNSINGL^TRNDRV(.ttx,.acn,TPD,BRCD,5)
		if ER,'$G(NOEXC) do LOG(.acn)
		}

	if $G(MCFEE) do {
		set TAMT=OFEEAMT
		set FEEAMT=OFEEAMT

		kill MCFEE,OFEEAMT,EXCAMT
		}

	type RecordHISTDST histdst=Class.new("RecordHISTDST")

	set histdst.cid=ORIGCID
	set histdst.tseq=HISTSEQ
	set histdst.dstseq=SECSEQ
	set histdst.acct=ttx.cid
	set histdst.itc=ttx.itc
	set histdst.etc=ttx.etc
	set histdst.tamt=ttx.tamt
	set histdst.tlo=ttx.tlo
	set histdst.tso=ttx.tso
	set histdst.tcmt=ttx.tcmt
	set histdst.crcd=ttx.crcd
	set histdst.cc=ttx.cc

	do histdst.bypassSave()

	set SECSEQ=SECSEQ+.01

	quit


Public CHECKACN(RecordACN acn)

	/*
	   Returns the Available Transfer Amount for the account.
	   Also defines local variables INCDR and MINDR to the Incremental and Minimum
	   Transfer Amounts

	   ARGUMENTS:
	   . acn	Deposit Account object		/TYP=RecordDEP

	   INPUTS:
	   . INCDRD		Incremental Transfer Amount (deposits)
	   . MINDRD		Minimum Transfer Amount (deposits)
	   . INCDRL		Incremental Transfer Amount (loans)
	   . MINDRL		Minimum Transfer Amount (loans)

	   RETURNS:
	   . $$ Amount

	   EXAMPLE:
	   set AVLAMT=$$CHECKACN(.acn)
	*/

	type Public Cache %CACHE()

	new AVLAMT,TYPE

	set AVLAMT=""
	set ER=0

	if acn.cls="D" do {

		do AVDEP(.acn)

		set INCDR=INCDRD
		set MINDR=MINDRD
		}

	if acn.cls="L",'PCFD15 do {

		do AVLN(.acn)

		set INCDR=INCDRL
		set MINDR=MINDRL
		}

	set TYPE=acn.type

	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE")

	// O/D Source - Incremental Tfr
	if prodctl.odsitr'="" set INCDR=$$MC(.acn,prodctl.odsitr,1)
	// O/D Source - Minimum Tfr
	if prodctl.odsmtr'="" set MINDR=$$MC(.acn,prodctl.odsmtr,1)

	if AVLAMT<0 set AVLAMT=0
	if acn.pcidstat=1 set AVLAMT=0

	quit AVLAMT


AVDEP(RecordDEP dep)	// Determine available amount to transfer from a deposit acccount

	set AVLAMT=$$AVLDEP^TTXEXT(.dep)

	quit


AVLN(RecordLN ln)	// Determine available amount to transfer from a loan account

	new AVLBAL

	do AVLBAL^LNCO(.ln)
	if ER quit

	set AVLAMT=AVLBAL

	quit


Public MC(RecordACN acn,AMT,BUY)
	/*
	   Returns the exchange amount if multicurrency should be used.  If
	   multicurrency is not needed, the original amount is returned.

	   KEYWORDS: Multicurrency, Calculation, Exchange

	   ARGUMENTS:
	   . AMT	Amount to be exchanged	/TYP=N/REQ/MECH=VAL
	     	Amount must be in the secondary currency
	   . BUY	Buy/sell flag		/TYP=N/NOREQ/MECH=VAL
	     0 = Debit, margin applies
	     1 = Credit, margin applies
	     2 = Cash value, no margins apply

	   INPUTS:
	   . %SystemDate	System base currency
	   . BCRCD		Base currency code
	   . BCUSTCD		Base customer code
	   . CRCD		Secondary currency code
	   . %EffectiveDate	Effective date

	   RETURNS:
	   . $$ Amount (exchanged or original)

	   EXAMPLE:
	   S AMT=$$MC(AMT,1)
	*/

	if $G(BCRCD)="" quit AMT

	if %MCP,CRCD'=BCRCD do {

		new TCUSTCD

		if $G(BCUSTCD)'="" set TCUSTCD=BCUSTCD
		else  set TCUSTCD=acn.ccode

		// Calculate exchange amount
		do EXC^CRCDUTL(BCRCD,CRCD,AMT,0,$G(BUY),"00",TCUSTCD,%EffectiveDate.get(),1,,%SystemCurrency)

		set AMT=$$^SCARND(EXCAMT,0,acn.cid)
		}

	quit AMT


DISPOSE(RecordDEP dep,RecordTTX ttx)	// Check disposition (RC=0 Do not return, RC=1 Return)

	if RC=1 set RETURNED=1

	/*
	  Only batch process should continue.
	*/
	if '((ttx.getStoredValue("TranMode") = 0) ! (ttx.getStoredValue("TranMode") = 3)) set ER = 0 quit
	else  set ER = 1

	if 'ODPINQ do HIST(.dep,.ttx)

	do FEE(.dep, ttx.getStoredValue("TranMode"))

	// Assess O/D fee, if applicable
	if 'RC set ER=0 quit

	do FEEPOST(.dep,"RET",0,.FEEAMT)

	set ER=2

	quit


HIST(RecordDEP dep,RecordTTX ttx) // Create NSF history entry

	new BALAVL

	// Non-sufficient Funds
	set RM=$$^MSG(2074)

	do AUT(.dep,.ttx)

	set BALAVL=$$AVLDEP^TTXEXT(.dep)

	// Tran $ ~p1 > avl
	set RJ(ttx.getStoredValue("TranSeq"),"HIST")=$$^MSG(5161,ttx.tamt,BALAVL)

	quit


FEE(RecordDEP dep, Number TNMODE) // Assess fee, if applicable

	new RETURNED

	// Not linked to a service fee plan
	if dep.feepln="" set FEEAMT=0 quit

	// Check that fee has been assesed
	set FEECHK=1

	if '$G(TNMODE),ER new ER set ER=0
	if '%FEE,dep.bal+dep.nsflim<TAMT do FEEPOST(.dep,"LIM",0,.FEEAMT) quit:FEEAMT
	if '%FEE,dep.bal<TAMT do FEEPOST(.dep,"LDG",0,.FEEAMT) quit:FEEAMT
	if '%FEE,dep.balcol<TAMT do FEEPOST(.dep,"UNC",0,.FEEAMT) quit:FEEAMT
	if dep.balavl<TAMT do FEEPOST(.dep,"AVL",0,.FEEAMT)

	quit


FEEPOST(RecordDEP dep,FEETYP,NOTFSN,FEEAMT)	// Post a fee ... call FEEAMT and FEEDR

	//  Protect RETURNED before calling TTXP2
	new RETURNED,TR16

	//  find fee amount
	do FEEAMT(.dep)

	//  No fee
	if 'FEEAMT quit

	//  Build Fee tran
	if 'ODPINQ do FEEDR(.dep)

	quit


FEEAMT(RecordDEP dep)	// Calculate fee amount

	if dep.uspl'="" do FEEAMT2(.dep,dep.uspl)
	if dep.feepln'="" do FEEAMT2(.dep,dep.feepln)

	// Not linked to a service fee plan or credit usage plan.
	if dep.feepln="" set FEEAMT=0

	// Protect against Undefined errors
	set FEEAMT=$G(FEEAMT)

	quit


FEEAMT2(RecordDEP dep,FEEPLN)

	new ER,PGM

	set ER=0
	set %EffectiveDate = %EffectiveDate.get()

	// Find correct posting program
	set PGM=$$FEEPGM^UFID(FEEPLN,$S(%EffectiveDate="":%SystemDate,1:%EffectiveDate))

	// Service fee program not compiled
	if PGM="" do Runtime.setErrMSG("DEP",2481,"FEEPLN") quit

	set PGM="^"_PGM_"(.dep,2,"""_FEETYP_""",1,"_NOTFSN_")"

	kill FEEAMT
	do @PGM
	set FEEAMT=$G(FEEAMT)

	quit


FEEDR(RecordDEP dep)	// Debit customer account

	type Public Cache %CACHE()

	new ETC,FILE,MCFEE,SVCMSG,TAMT,TYPE

	if 'FEEAMT quit
	if CHGOPT-1 set FEEAMT=0 quit
	if NOTFSN quit

	set FILE=0

	// Use Service Charge Account Number
	if dep.svcfeecid'="" do {

		new CID

		set CID=dep.svcfeecid

		type RecordACN acn2=Db.getRecord("ACN","CID")

		if $$SVCFEECID(.dep,.acn2) do {

			set TYPE=acn2.type

			type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE")

			set ETC=$$EVENTTRM^BCHFEEUT(,TYPE,FEETYP)

			set TAMT=FEEAMT
			set TSO=""
			set TCMT="FEE-"_FEETYP_": "_SVCMSG

			do FILE(.acn2,"",dep.cid,dep.cc)

			set FILE=1
			}
		}

	if 'FILE do {

		set TYPE=dep.type

		type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE")

		set ETC=$$EVENTTRM^BCHFEEUT(,TYPE,FEETYP)

		// Service Fees
		set SVCMSG=$$^MSG(3506)
		set TAMT=FEEAMT
		set TSO=""
		set TCMT="FEE-"_FEETYP_": "_SVCMSG

		do FILE(.dep,"",dep.cid,dep.cc)
		}

	if ER quit

	set TR16=""

	do FEECR(.dep)

	quit


FEECR(RecordDEP dep)

	type Public Cache %CACHE()

	new CID,ETC,TSO,TYPE

	set TYPE=dep.type

	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE")	

	if FEETYP="ODT" set ETC=prodctl.odtc2
	else  set ETC=prodctl.odtc1

	if ETC="" set ETC="MCR"

	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC")

	set CID=+trn.acn
	set TSO="TFR#"_dep.cid

	if 'CID do {
		if dep.glsc'="" do {

			new GLSC

			set GLSC=dep.glsc

			type RecordUTBLGLSC utblglsc=Db.getRecord("UTBLGLSC","GLSC")

			set CID=utblglsc.dglf
			}

		if CID="" do {

			set ETC="TSCR"
			// TSCRCID is defined in DEPPO.m
			set CID=TSCRCID
			}
		}

	type RecordACN acn2=Db.getRecord("ACN","CID=:dep.cid")

	do FILE(.acn2,CID,dep.cid,dep.cc)

	quit


SVCFEECID(RecordDEP dep,RecordACN acn2)	// Service Charge Account Number

	new AVLAMT,ER,FCRCD

	set FCRCD=CRCD

	new CRCD

	set CRCD=acn2.crcd
	if CRCD="" set CRCD=%SystemCurrency

	// Multi-currency fee flag
	set MCFEE=0

	if %MCP,CRCD'=FCRCD do {

		set MCFEE=1

		do EXC^CRCDUTL(CRCD,FCRCD,FEEAMT,0,0,"00")

		set EXCAMT=$$^SCARND(EXCAMT,0,acn2.cid)
		}

	if acn2.cls="D" do AVDEP(.acn2)
	if acn2.cls="L" do AVLN(.acn2)

	if AVLAMT<0 set AVLAMT=0

	if 'AVLAMT quit 0
	if 'MCFEE,FEEAMT>AVLAMT quit 0
	if MCFEE,EXCAMT>AVLAMT quit 0

	// Service fee for account ~p1
	set SVCMSG=$$^MSG(8435,dep.cid)

	if MCFEE do {
		set OFEEAMT=FEEAMT
		set FEEAMT=EXCAMT
		}

	quit 1


AUT(RecordDEP dep,RecordTTX ttx)		// Authorization Verification

	do AUT^UHLD(.dep,TAMT,ttx.itc,.OVR) quit:ER

	if dep.rflg do ^UFLG(.dep) quit:ER
	if dep.flg do FLG^UFLG(.dep,ttx.itc) quit:ER

	// New balance is less than minimum allowed of $<MINBAL>
	if dep.bal-TAMT<dep.minbal set OVR(dep.cid,"OVR","MINBAL")=$$^SCARND(dep.minbal,0,dep.cid)

	// Debit amount must be in increment of $<INCDR>
	if dep.incdr,TAMT#dep.incdr set OVR(dep.cid,"OVR","INCDR")=$$^SCARND(dep.incdr,0,dep.cid)

	// Withdrawal amount is less than minimum of $<MINDR>
	if TAMT<dep.mindr set OVR(dep.cid,"OVR","MINDR")=$$^SCARND(dep.mindr,0,dep.cid)

	// Withdrawal amount is greater than maximum of $<MAXDR>
	if dep.maxdr,TAMT>dep.maxdr set OVR(dep.cid,"OVR","MAXDR")=$$^SCARND(dep.maxdr,0,dep.cid)

	// New balance is less than minimum to accrue $<MINACR>
	if dep.minacr,dep.bal-TAMT<dep.minacr set OVR(dep.cid,"OVR","MINACR")=$$^SCARND(dep.minacr,0,dep.cid)

	// Transaction exceeds ledger balance of $<BAL>
	if TAMT>dep.bal set OVR(dep.cid,"OVR","BAL")=$$^SCARND(dep.bal,0,dep.cid)

	// Transaction exceeds collected balance of $<BALCOL>
	if TAMT>dep.balcol set OVR(dep.cid,"OVR","BALCOL")=$$^SCARND(dep.balcol,0,dep.cid)

	// Account Status
	if dep.stat set OVR(dep.cid,"OVR","STAT"_dep.stat)=""

	quit


LOG(RecordACN acn)	// Log exceptions

	// Overdraft processing error
	do LOG^UTLEXC($T(+0),"*",$$^MSG(5160),acn.cid,"",$G(RM))

	quit


Public TRNFEE(RecordDEP dep,TAMT,ETC)
	/*
	Amount of the direct transaction fee charged to primary tran account

	   ARGUMENTS:
	         . dep    Account object                 /TYP=N/REQ
	         . TAMT   Primary transaction amount     /TYP=$/REQ
	         . ETC    External transaction code      /TYP=T/REQ

	   RETURNS:
	         . FEEAMT Primary transaction fee amount
	*/

	type Public Cache %CACHE()

	new FEEAMT,FEEPLN,PGM,TRNGRP

	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC")

	if trn.feepln="" quit 0

	set FEEPLN=trn.feepln
	set TRNGRP=trn.feegrp
	if TRNGRP="" quit 0

	// Find correct posting program
	set PGM=$$FEEPGM^UFID(FEEPLN,$S(%EffectiveDate="":%SystemDate,1:%EffectiveDate))

	// Service fee program not compiled
	if PGM="" do Runtime.setErrMSG("DEP",2481,"FEEPLN") quit 0
	set PGM="^"_PGM_"(.dep,3,TRNGRP,"_"1,1,"_TAMT_")"

	do @PGM

	if ER quit 0
	if $G(FEEAMT)="*" quit 0
	if $G(FEEAMT)="" quit 0

	quit FEEAMT


ODBB(RecordDEP dep)

	// Pay Against Ledger Balance
	if +dep.odbb=0 quit +dep.bal

	// Pay Against Collected Balance
	if +dep.odbb=1 quit dep.balcol

	// Pay Against Avail Bal
	if +dep.odbb=2 quit dep.balavl

	quit 0


Public EXTINQ(RecordDEP dep,CID,TAMT)	// External interface for total available balance
	/*
	   External interface to determine the total available balance that
	   can be collected if overdraft processing were to be invoked.
	   Includes all linked overdraft accounts and considers such things as
	   overdraft limit, services fees, minimum amounts and incremental
	   amounts associated with overdraft processing.  The amount returned
	   will not exceed the amount requested.

	   ARGUMENTS:
	   . CID  Deposit account number	/TYP=N/REQ/MECH=VAL
	   . TAMT  Amount requested		/TYP=N/REQ/MECH=VAL
	     (in currency of passed CID)

	   INPUTS:
	   . ETC  Withdrawal tran code		/TYP=T/REQ/MECH=VAL

	   RETURNS:
	   $$  Total available amount		/TYP=N

	   EXAMPLE:
	   S TOTAMT=$$EXTINQ^TTXODC(CID,TAMT) Q:ER
	*/

	new ODPINQ,OVR,REQNET

	type RecordTRN trn=Db.getRecord("TRN","ETC")

	// pass fake ttx to START - is not actually used when called from here
	type RecordTTX ttx=Class.new("RecordTTX")

	// Overdraft protection inquiry flag
	set ODPINQ=1
	set REQNET=TAMT
	set ttx.etc=ETC

	//Set third parameter (BYPASS flag) to true to bypass fake transaction. 
	type Boolean ISBYPASS = 1
	do START(.dep,.ttx, .trn, ISBYPASS)

	quit TAMT-REQNET

vSIG()	quit "60627^46747^Marie Mbui^24814"	// Signature - LTD^TIME^USER^SIZE
