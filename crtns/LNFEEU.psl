LNFEEU	

	/*
	Loan Fee Programming Utilities

	---- Revision History ------------------------------------------------

	08/02/07 - PUTTASWH - CR 28540
		   Modified CALC section to pass the 6th piece of TAMT to
		   COLLECT section instead of TAMT.  This is because the 1st
		   piece of the TAMT that was passed earlier is the composite
		   value containing the multiple component amounts of a 
		   transaction, separated by pound sign.  As the code here deals
		   with Loan Fee only, the corresponding value is picked from
		   the 6th piece, thus posting only the loan fee amount. 
		   
	07/13/07 - PUTTASWH - CR 28128
		   Modified OFFST1 section to pass 'DRCR while invoking ETC1 
		   instead of DRCR. The change is necessary because the ETC1 
		   function expects DRCR to be the debit/credit indicator of 
		   the offsetting (MCR or MDR) tran code, not of the fee 
		   transaction code itself (so it should be the opposite 
		   debit/credit indicator of the fee transaction).
	
	06/11/07 - SENTHIL.J KUMAR - CR 27093
		   Modified the COLLECT section to correct the wrong transaction 
		   code that was being referenced (from PRODCTL.DRTACN2 to PRODCTL.DRTRPR)
		   to capitalize loan fees.

	06/05/07 - GIRIDHAL/SmithCD - CR 26692
		   Modified sections SETTR, OFFST0, OFFST1, OFFST2 to ensure the
		   offset information is stored as part of the TSO of the fee
		   transaction itself. Also modified section BASIS to pass in 
		   additional SECONDARY parameter. This is needed to denote misc 
		   fees calculated as payoff as SECONDARY.
		   Modified section BASIS to suppress fees when backdated loans
		   are created (UANTICTL is set in UANTICLN)

	04/11/07 - KinI - CR 26508
		   Modified VATCALC section to replace undefined FEEAMT 
		   variable with piece one of TAMT.

	04/04/07 - KinI - CR 24945
		   Introduced VATCALC section that performs VAT calculation
		   on loan fee. Modified CALC section to call VATCALC section 
		   for those fees that have lnfeep.subtovat flag set to "Y".
		   Modified OFFST0 and OFFST1 sections to generate VAT offsets. 
		   To consolidate identical logic, created ETC1 function to 
		   return G/L trancode. Modified OFFST0 and OFFST1 to call this 
		   function. 

	03/22/07 - GIRIDHAL - CR 26066
		   Modified FEEDUE section to pass in SECONDARY flag to denote
		   fee transactions as SECONDARY. Also modified CALC and SETTR
		   to pass in the SECONDARY flag as an optional parameter
		   
	02/12/07 - chhabris - CR24680
		   Modified ETC section to get the fee transaction code for
		   the new group (CC) added for Credit Card processing.

	04/18/06 - KELLYP - CR 20749
		   Modified CALC section to new EFD when EFD>TJD prior to 
		   calling the SETTR section.  This fixes an issue where 
		   billing-based fee types were not being assessed, and 
		   therefore weren't included in the payment record, during 
		   backdated account openings when the billing offset was 
		   greater than 1.
	
	04/13/06 - SmithCD - CR 20574
		   Made FINDFEE, GLACN, DDICHK sections public. Performed some 
		   minor cleanup.

	03/20/06 - TITOVE - CR 20087
		   Modified TBL1 and TBL3 to properly build TBL array. Added
		   the "P" and "I" literals to allow loan fee plans to
		   specify principal and interest as a basis for the fee.

	03/08/06 - TITOVE - CR 19832
		   Restored original logic in LOADLNK2 section, to prevent
		   infinite loop. Removed instantiation of TTX object from
		   CALC section. Added call to POST^LNTRB to OFFST1 section.
		   Removed unused QRY section. Brought up to standards.

	03/02/06 - TITOVE - CR 19733
		   Modified DDICHK to conditionally instantiate LNFEEP and
		   throughout the procedure to instantiate an LNFEEP object
		   with a "create-if-needed" qualifier. This was already done
		   once by CR 16252, but overwritten later by %CACHE methods.

	02/24/06 - chhabris - CR 19307
		   Modified COLLECT section to instantiate dep object if there
		   is a fee target account defined for the loan. This dep object
		   will be utilized in LNTRB for processing fees for loan with
		   target account (deposit).

	02/06/06 - KELLYP - CR 19417
		   Modified OFFST0 and OFFST1 sections not to call POST^LNTRB.
		   These sections are used solely for updating TSO on the 
		   assessment transaction.
	
	01/30/06 - SmithCD - CR 19343 (16890)
		   In OFFST2 section, removed reference to trn table, which is 
		   not needed, and modified to return an error if the tran 
		   code is not defined. Solves a null subscript error. Also 
		   cleaned up OFFST2 and OFFST1 sections.

	07/22/05 - CARROLLJ - CR16928
		   o Modified SETTR section to replace call to CREATE^LNTRB 
		     with call to POST^LNTRB and also removed call to 
		     LN4^LNPTS1
		   o Modified OFFST0 section to set OFFST array correct 
		     column in CUVAR(cuvar.feeidrtc).  Added select is get 
		     TSO from disk because TSO can change in LNTRB.  Removed 
		     call to LN4^LNPTS1 with call to POST^LNTRB.

	06/16/05 - KELLYP - CR 16321
		   Modified OFFST1 section to pass ttx.brcd instead of 
		   ttx.crcd as the fourth parameter to TRNSINGL^TRNDRV.

	06/10/05 - KinI - 16252
		   Modified  FEEDUE, BASIS, CALC, FEEREC, FEEINC and LATE 
		   sections to add the 3rd parameter to LNFEEP Db.getRecord 
		   method. Assess Misc Charge transaction can be generated 
		   during a payoff that would create "*" fee type on the loan 
		   that does not exist in the Loan Fee Plan file.

	05/26/05 - JERUCHIMC - CR13136
	           Modified sections OFFST0, OFFST1, OFFST2, and SETTR.
	  	   The previous code was wrong in not creating new 
	  	   transactions for OFFST1 and OFFST2 and also called
	  	   too many times to post transactions for OFFST0, resulting in
	  	   doubling of fees.  
	
	04/20/05 - GEORGES - CR13136
		   Modified function Collect to instantiate acn
		   object since target account could be deposit account
		   Also modified calls to OFFST0,OFFST1,TRNSINGL^TRNDRV
		   to pass acn instead of ln.
		   Modified section LNKBAS to fetch all the
		   records and verify if the ELEMNT has any 
		   linked fee attached.

	-----------------------------------------------------------------------
	*/

	quit


public FEEDUE(RecordLN ln,		// Loan account			/REF:R
	      RecordTTX ttx,		// Transaction			/REF:R
	      Number CID,		// Account number
	      Number CMPMTH,		// Fee computation method	/NOREQ
	      String CTL,		// Control parameters		/NOREQ
	      Date %EffectiveDate,	// Effective date		/NOREQ
	      String BIL,		// Payment file (bill)		/NOREQ
	      Number AMT,		// Transaction amount		/NOREQ
	      String ELMNT,		// Transaction element		/NOREQ
	      String TC,		// Transaction code		/NOREQ
	      Number AMTARRAY(),	// Fee amounts			/REF:W/NOREQ
	      Number FEEBSEQ)		// Bill sequence		/NOREQ

	/*
	Find fees-due-to-be-assessed
	
	Additional notes on ARGUMENTS:

	   . CMPMTH		If passed in, only fees matching this method
				will be calculated.

	   . CTL       Position 1 - Create TR array (0-no, 1-yes)
	                            If 0, the intent is to calculate all
	                            levels of fees, not just the next level
	                        2 - Post transactions (0-no, 1-yes)
	                        3 - Ignore fees collected from another acct
	                        4 - Called from EOD process
	                        5 - payment/disbursement (other than
	                            assessment) indicator . . . i.e. driving
	                            application is other than fee assessment
	                            transaction

	   . %EffectiveDate	Used for call to extrinsic functions within
				fee plan. This allows extrinsic calls to
				calculate amounts based on, say, a transaction
				effective date.

	   . BIL     		Used for passing into extrinsic functions.
				Allows extrinsic functions to calculate fees
				based upon information in a bill record being
				satisfied by a payment.

	   . AMT		Amount of disbursement, or payment element
				being satisfied. Allows extrinsic function
				to calculate fees based on this amount.

	   . ELMNT		Element that fees are based upon.

	   . TC			Transaction code being used by application.
				Used within tran code group interrogations.
				If TC is not within the tran code group, a fee
				is not calculated.

	   . AMTARRAY()		Array contains all calculated fee amounts.
				This process will accumulate this array. It
				is the responsibility of the calling routine
				to manage the cleanup of this array.
	*/

	type public Date BLDUE
	type public Number ER
	type public String ETC, OFFST(,,,,)
	type Boolean SECONDARY = 0	
	type String basis(), CRCD, GRP, FEE = "",FEESS(), SAVETC
 
	set CTL = CTL.get()
	set BIL = BIL.get()
	set BLDUE = BLDUE.get()
	set AMT = AMT.get() 
	set FEEBSEQ = FEEBSEQ.get()
	set ELMNT = ELMNT.get() 
	set TC = TC.get()

	set SAVETC = ETC.get()
	set GRP = ln.grp
	set CRCD = ln.crcd

	do LOADBAS(.basis(), CID)

	// Set-up the fees to process
	do SETFEES(.ttx, .FEESS())

	type ResultSet rs1 = Db.select("FEETYP","LNFEE","CID=:CID")
	
	if rs1.isEmpty() set ETC = SAVETC quit

	// Calculate top-level fees
	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0","CID = :CID", 1)
	
	for  set FEE = FEESS(FEE).order() quit:FEE.isNull()  do { quit:ER
		
		type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP = :FEE", 1)
		
		// Different computation method
		if ($$CMPMTH(FEE) - CMPMTH) quit
		
		if (CMPMTH = 2),'$$TRNGRP(.lnfeep, TC) quit
		
		if (CMPMTH = 3),$$ELECHK^BILFUNCS(ln.ppdcat1,FEE),'BLDUE.isNull(),'$$ELMNTDUE^LNBLDE(.ln,.lnbil0,FEE,BLDUE) quit

		if CTL.extract(3),lnfeep.cfwa,'$translate(ln.lnfeegl).isNull() quit

		if ELMNT.isNull(),lnfeep.basis.isNull() do CALC(.ln,.ttx,CID,FEE,.OFFST(,,,,),CTL.extract(1,2)_CTL.extract(4),.AMTARRAY()) quit

		if 'ELMNT.isNull(),(lnfeep.basis = ELMNT),(CTL.extract(5)-lnfeep.lfee) do { quit:ER
			set SECONDARY=1
			do CALC(.ln,.ttx,CID,FEE,.OFFST(,,,,),CTL.extract(1,2)_CTL.extract(4),.AMTARRAY(),SECONDARY) quit
			} 
		}

	set ETC = SAVETC

	quit


public BASIS(RecordLN ln,		// Loan account			/REF:R
	      RecordTTX ttx,		// Transaction			/REF:R
	      Number CID,		// Account number
	      Date %EffectiveDate,	// Effective date		/NOREQ
	      Number AMT,		// Transaction amount		/NOREQ
	      String ELMNT,		// Transaction element		/NOREQ
	      String CTL,		// Control parameters		/NOREQ
	      Number AMTARRAY(),	// Fee amounts			/REF:W/NOREQ
	      String BIL,		// Payment file (bill)		/NOREQ
	      Number CMPMTH,		// Fee computation method	/NOREQ
	      String TC,		// Transaction code		/NOREQ
	      Boolean SECONDARY)	// Secondary transaction	/NOREQ	    	      

	/*
	Find fees-due-to-be-assessed for basis fees only
	
	Additional notes on ARGUMENTS:

	   . %EffectiveDate	Used for call to extrinsic functions within
				fee plan. This allows extrinsic calls to
				calculate amounts based on, say, a transaction
				effective date.

	   . AMT		Amount of disbursement, or payment element
				being satisfied. Allows extrinsic function
				to calculate fees based on this amount.

	   . ELMNT		Element that fees are based upon.
	
	   . CTL       Position 1 - Create TR array (0-no, 1-yes)
	                            If 0, the intent is to calculate all
	                            levels of fees, not just the next level
	                        2 - Post transactions (0-no, 1-yes)
	                        3 - Ignore fees collected from another acct
	                        4 - Called from EOD process

	   . AMTARRAY()		Array contains all calculated fee amounts.
				This process will accumulate this array. It
				is the responsibility of the calling routine
					                            				
	   . BIL     		Used for passing into extrinsic functions.
				Allows extrinsic functions to calculate fees
				based upon information in a bill record being
				satisfied by a payment.

	   . CMPMTH		Method may be passed in and only those
				fees using this element as a basis, AND
				matching the computation method will be 
				assessed. This may only be necessary for 
				fees using "I" or "P" as a basis.
				
	   . TC			Transaction code being used by application.
				Used within tran code group interrogations.
				If TC is not within the tran code group, a fee
				is not calculated.
	*/

	type public Number ER
	type public String FEESS(), OFFST(,,,,), UANTICTL

	type String basis(), FEE = "", XCTL

	set CTL = CTL.get()
	set AMT = AMT.get() 
	set ELMNT = ELMNT.get() 
	set BIL = BIL.get() 
	set CMPMTH = CMPMTH.get()
	set TC = TC.get()

	do LOADBAS(.basis(), CID)

	if 'FEESS.exists() do SETFEES(.ttx, .FEESS())
	
	for  set FEE = basis(ELMNT,FEE).order() quit:FEE.isNull()  do { quit:ER

		type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP = :FEE", 1)
		
		if 'CMPMTH.isNull(),(CMPMTH-lnfeep.amth) quit
		
		if (ELMNT '= "I"),(ELMNT '= "P"),'lnfeep.lfee quit
		
		// Do not reaply
		if 'FEESS(FEE).exists() quit
		
		set XCTL = CTL.extract(1,2)_"00".extract(1,2-CTL.length())_+CTL.extract(4)
		
		do CALC(.ln,.ttx,CID,FEE,.OFFST(,,,,),XCTL,.AMTARRAY(),SECONDARY.get()) quit:ER
		}
	
	quit


public CALC(RecordLN ln,		// Loan account			/REF:R
	    RecordTTX ttx,		// Transaction			/REF:R/NOREQ
	    Number CID,			// Account number
	    String FEE,			// Fee type
	    String OFFST(,,,,),		// Offset transactions / amounts/REF:W/NOREQ
	    String CTL,			// Control parameters		/NOREQ
	    Number AMTARRAY(),		// Fee amount data		/REF:W/NOREQ
	    Boolean SECONDARY)		// Secondary transaction	/NOREQ	    

	/*
	Calculate fee amount

	Additional notes on ARGUMENTS:

	  . CTL        Position 1 - Calculate next fee level only (0-no, 1-yes)
	                            If 0, the intent is to calculate all
	                            levels of fees, not just the next level
				2 - Post transactions (0-no, 1-yes)
	                        3 - Called from EOD process
	                        
	   . AMTARRAY()		Array contains all calculated fee amounts.
				This process will accumulate this array. It
				is the responsibility of the calling routine
				to manage the cleanup of this array.	                        

	*/

	type public Number ER
	type public String ETC, UANTICTL
	
	type String TAMT
	type String CMPPGM
	
	// Misc Charge that is not in Fee Plan table (LNFEEP)
	if (FEE = "*") quit

	set CTL = CTL.get()
	
	// Suppress fees at backdated loan create.
	if UANTICTL.get().extract(1) quit	
	
	// Date available
	type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP = :FEE", 1)

	if lnfeep.dtst,(%SystemDate < lnfeep.dtst) quit

	#ACCEPT DATE=11/18/03;PGM=John Carroll;CR=43583
	set CMPPGM = "S TAMT=$$"_FEE_"^LNFEECMP(.ln)" xecute CMPPGM

	set AMTARRAY(FEE) = AMTARRAY(FEE).get()+TAMT
	
	set AMTARRAY = AMTARRAY.get()+TAMT
	
	set SECONDARY = SECONDARY.get()
		
	if (+TAMT = 0) quit

	if CTL.extract(2) do { quit:ER
		
		if %EffectiveDate.get()>%SystemDate do {  quit
			type Date %EffectiveDate
			set %EffectiveDate = %SystemDate

			if lnfeep.subtovat do VATCALC(.ln, .TAMT)												

			do SETTR(.ln,.ttx,.lnfeep,CID,CTL,.ETC,TAMT,FEE,0,%EffectiveDate,SECONDARY) quit:ER					
			
			set TAMT = TAMT.piece("#", 6)			
			if (+TAMT = 0) quit
			
			do COLLECT(.ln,.ttx,.lnfeep,CID,CTL,.ETC,TAMT,FEE,%EffectiveDate) quit:ER
			
			}		

		if lnfeep.subtovat do VATCALC(.ln, .TAMT)

		do SETTR(.ln,.ttx,.lnfeep,CID,CTL,.ETC,TAMT,FEE,0,%EffectiveDate.get(),SECONDARY) quit:ER		
		
		set TAMT = TAMT.piece("#", 6)			
		if (+TAMT = 0) quit
			
		do COLLECT(.ln,.ttx,.lnfeep,CID,CTL,.ETC,TAMT,FEE,%EffectiveDate.get()) quit:ER
		}

	quit

VATCALC(RecordLN ln,		// Loan Accout object
	String TAMT)		// Transaction array

	/*
	If Value Added Tax is applicable, increase the transaction amount by 
	it and store it in ttx.ttamt2. The posting program (LNPTS8) will use 
	it when posting the transaction.
	*/
	
	type Number VATAMT = 0
	
	type RecordUTBLBRCD utblbrcd = Db.getRecord("UTBLBRCD","BRCD=:ln.boo",1)
	
	if utblbrcd.vatpct.isNull() quit
	
	set VATAMT = (TAMT * (utblbrcd.vatpct / 100)).roundCur(ln.crcd)
	
	if 'VATAMT quit
						
	// Tran Detail: L:Val Tax Fee (ttx.ttamt2)
	set TAMT.piece("#", 16) = VATAMT
	
	// Save off fee position for the posting procedure
	set TAMT.piece("#", 6) = TAMT.piece("#", 1)
	
	// Total transaction amount
	set TAMT.piece("#", 1) = TAMT.piece("#", 1) + VATAMT
	 
	quit 	


public SETTR(RecordLN ln,		// Loan Account object
	     RecordTTX ttx,		// Transaction object  	NOREQ/MECH=REF
	     RecordLNFEEP lnfeep,	// Loan Fee Plan object
	     Number CID,		// Account Number
	     String CTL,		// Control parameters
	     String ETC,		// Trancode
	     String TAMT,		// Transaction array
	     String FEE,		// Fee Type
	     Boolean decr,		// Flag indicates decrease (call from LNPO2)
	     Date %EffectiveDate,	// Effective Date
	     Boolean SECONDARY)		// Secondary transaction  NOREQ	     
      
	// Post a fee assessment or decrease

	type public Number ER, FEEBSEQ
	type public String OFFST(,,,,)

	type Number ofsttyp
	type String CRCD, ITC, LTC, TCMT, TSO

	set CRCD = ln.crcd
	
	set decr = decr.get()

	set SECONDARY = SECONDARY.get()
	
	set TSO = "LNFEEIN#"_FEE_":"_+TAMT
	
	if FEEBSEQ.get() set TSO = TSO_":"_FEEBSEQ
	
	if CTL.extract(3) set TSO = TSO_"~DAYEND#1"

	set TCMT = lnfeep.hdesc
	
	set LTC = $$ETC(.ln, .lnfeep, decr)
	
	/*
	Now decide whether or not to accumulate offsets.  If
	[LNFEEP]GLTROP=Y, and this section is called from end-of-day
	fee assessments or billing, then accumulate.  If GLTROP=Y,
	and the calling application is not from end-of-day (I.e.
	MP generates online bills w/fees), do not accumulate.
	*/

	// Determine Offset type	
	if $$DEFER(.lnfeep, FEE, "") set ofsttyp = 2
	
	else  if CTL.extract(3),lnfeep.gltrop set ofsttyp = 0
	
	else  set ofsttyp = 1

	// Post fee transaction and accumulate offset
	if (ofsttyp = 0) do OFFST0(.ln, .lnfeep, .ttx, TAMT, CRCD, FEE, $select('ETC.get().isNull():ETC,1:LTC)) quit

	// Post fee transaction and offset assessment with income deferral 
	// transaction to same account	
	if (ofsttyp = 2) do OFFST2(.ln, .ttx, CID, TAMT, CTL, CRCD, TSO, TCMT) quit

       	// Post fee transaction and one-for-one offset for the fee	
	do OFFST1(.ln, .lnfeep, .ttx, TAMT, CRCD, FEE) quit:ER

	quit

	
OFFST0(RecordACN acn,		// Account
       RecordLNFEEP lnfeep,	// Fee Plan
       RecordTTX ttxpri,	// Primary transaction
       String TAMT,		// Transaction array
       String CRCD,		// Currency code
       String FEE,		// Fee type
       String ETC)		// Offset external trancode	
       
	// Post fee transaction and accumulate offset

	type public Cache %CACHE()
	type public String CTL, LTC, OFFST(,,,,), TCMT, TSO
	type public Boolean ER, SECONDARY
	type public Number CID
	
	type Number ACN, CC, FEEAMT
	type String REC, SAVOFFST, UTSO()
	type Boolean DRCR

	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC = :ETC")

	// Default Cost Center
	set CC = trn.dftcc
	if CC.isNull() set CC = acn.cc

	type RecordTRN trnltc = %CACHE("TRN").getRecord("TRN", "ETC = :LTC")
	set DRCR = trnltc.dc

	type RecordUTBLGLSC glsc = %CACHE("UTBLGLSC").getRecord("UTBLGLSC", "GLSC = :acn.glsc")
	
	set ACN = $$GLACN(.acn, .lnfeep, .glsc, FEE, "")

	if OFFST(CRCD,FEE,acn.glsc,CC).get().isNull() do {

		set REC = ACN_"||"_ACN
		
		// Debit tran code
		set REC.piece("|",2) = $$ETC1(.lnfeep, 0)

		// Credit tran code
		set REC.piece("|",4) = $$ETC1(.lnfeep, 1)	
		
		set OFFST(CRCD,FEE,acn.glsc,CC) = REC
		}

	set REC = OFFST(CRCD,FEE,acn.glsc,CC)
	
	set FEEAMT = +$select(TAMT.isLike("%#%"):TAMT.piece("#",6),1:TAMT)
	
	set OFFST(CRCD,FEE,acn.glsc,CC,'DRCR) = OFFST(CRCD,FEE,acn.glsc,CC,'DRCR).get() + FEEAMT

	if 'SECONDARY do {
		// Save fee offset info in assessment transaction for auto-reversals
		set SAVOFFST = $select(DRCR:REC.piece("|",2),1:REC.piece("|",4))_":"_ACN
		set TSO = $$FIELDIN^UTSO(TSO, "OFFST", SAVOFFST)
		}
		
	/* Accumulate offsets for the assessed VAT amount if any.
	   Use Feetype_VAT identifier as a second key to save VAT entry
	   in OFFST array to avoid overlaying the fee offset entry.
	    
	   For example,
	    	OFFST("USD","FREQ","500A",0)="41528|MDR|41529|MCR"
		OFFST("USD","FREQ","500A",0,1)=222.5	    	
	  	OFFST("USD","FREQ_VAT","500A",0)="10002|MDR|10003|MCR"
		OFFST("USD","FREQ_VAT","500A",0,1)=22.5
	*/
	if (TAMT.piece("#", 16)) do {

		if OFFST(CRCD,FEE_"_VAT",acn.glsc,CC).get().isNull() do {
			
			set REC = glsc.lglvatfeer_"||"_glsc.lglvatfeei
			
			// Debit tran code
			set REC.piece("|",2) = $$ETC1(.lnfeep, 0)			
			
			// Credit tran code
			set REC.piece("|",4) = $$ETC1(.lnfeep, 1)	
			
			set OFFST(CRCD,FEE_"_VAT",acn.glsc,CC) = REC
			}
			
		set REC = OFFST(CRCD,FEE_"_VAT",acn.glsc,CC)
		set OFFST(CRCD,FEE_"_VAT",acn.glsc,CC,'DRCR) = OFFST(CRCD,FEE_"_VAT",acn.glsc,CC,'DRCR).get() + TAMT.piece("#", 16)		
		
		if 'SECONDARY do {
			// Save VAT offset info in assessment transaction for auto-reversals.
			set SAVOFFST = $select(DRCR:REC.piece("|",2)_":"_glsc.lglvatfeer,1:REC.piece("|",4)_":"_glsc.lglvatfeei)
			// Pull out prior "OFFST" entry from TSO, concatenate VAT offset 
			// separated by comma, and re-insert into ttx.tso.
			do OUT^UTSO(.UTSO, TSO)
			if UTSO("OFFST").get().isNull() quit
			
			set UTSO("OFFST") = UTSO("OFFST")_","_SAVOFFST
			do IN^UTSO(.UTSO, .TSO)
			}
		}

	// Post fee transaction with "OFFST" pointer in TSO
	if CTL do POST^LNTRB(.ttxpri,CID,LTC,TAMT,%EffectiveDate,%UserStation,TSO,TCMT,CRCD,,,,,SECONDARY) quit:ER
		
	quit


OFFST1(RecordACN acn,			// Account object		/REF:R
       RecordLNFEEP lnfeep,		// Loan fee plan		/REF:R
       RecordTTX ttxpri,		// Primary transaction		/REF:R
       String TAMT,			// Transaction array
       String CRCD,			// Currency code
       String FEE)			// Fee type
       
       	// Post fee transaction and one-for-one offset for the fee
	
	type public Boolean DRCR, ER, SECONDARY
	type public Cache %CACHE()
	type public String CTL, LTC, TCMT, TSO
	type public Number CID

	type String ETC, OFFTCMT, UTSO(), VATTCMT, VATETC = ""
	type Number ACN, FEEAMT
	
	type RecordTRN trnltc = %CACHE("TRN").getRecord("TRN", "ETC = :LTC")
	set DRCR = trnltc.dc

	type RecordUTBLGLSC glsc = %CACHE("UTBLGLSC").getRecord("UTBLGLSC", "GLSC = :acn.glsc")
		 
	set ACN = $$GLACN(.acn, .lnfeep, .glsc, FEE, "")
	
	set ETC = $$ETC1(.lnfeep, 'DRCR)	

	set OFFTCMT = ACN_", "_FEE
	
	set FEEAMT = +$select(TAMT.isLike("%#%"):TAMT.piece("#",6),1:TAMT)

	// Save info in assessment transaction for auto-reversals
	if 'SECONDARY set TSO = $$FIELDIN^UTSO(TSO,"OFFST",ETC_":"_ACN)
	
      	// Post one-for-one offset fo VAT's G/Ls if applicable
      	if (TAMT.piece("#", 16)) do {
		
		// Credit VAT on Loan Fees Income G/L (debit to Receivable G/L will be 
		// generated by RGLSUM during G/L summary accumulation)
		
		set VATETC = $$ETC1(.lnfeep, 'DRCR)  // Fee Income Offset TranCode - Increase 
		
		set VATTCMT = glsc.lglvatfeei_", "_FEE
		
		// Save VAT assessment info in the transaction for auto-reversals
		if 'SECONDARY do {
			// Pull out prior "OFFST" entry from TSO, concatenate VAT offset 
			// separated by comma, and re-insert into ttx.tso.
			do OUT^UTSO(.UTSO, TSO)
			if UTSO("OFFST").get().isNull() quit
			
			set UTSO("OFFST") = UTSO("OFFST")_","_VATETC_":"_glsc.lglvatfeei
			do IN^UTSO(.UTSO, .TSO)
			}
		}
	
	// Post fee transaction with "OFFST" pointer in TSO
	if CTL do POST^LNTRB(.ttxpri,CID,LTC,TAMT,%EffectiveDate,%UserStation,TSO,TCMT,CRCD,,,,,SECONDARY) quit:ER

	// Post fee offset transaction
	do POST^LNTRB(.ttxpri,ACN,ETC,FEEAMT,%EffectiveDate,%UserStation,"",OFFTCMT,CRCD,,,,,SECONDARY) quit:ER
	
	// Post fee offset transaction, if applicable		
	if 'VATETC.isNull() do POST^LNTRB(.ttxpri, glsc.lglvatfeei, VATETC, TAMT.piece("#",16), %EffectiveDate, %UserStation, "", VATTCMT, CRCD,,,,,SECONDARY) quit:ER
	
	quit


OFFST2(RecordLN acn,		// Account object		/REF:R
       RecordTTX ttxpri,	// Primary transaction		/REF:R
       Number CID,		// Account Number
       String TAMT,		// Fee amount
       String CTL,		// Control parameters
       String CRCD,		// Currency code
       String TSO,		// Transaction source
       String TCMT)		// Transaction comment

	// Post fee transaction and offset assessment with income deferral 
	// transaction to same account
	
	type public Cache %CACHE()
	type public Boolean ER, SECONDARY
	type public String LTC
	
	type String ETC

	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE = :acn.type")

	// Post fee transaction with "OFFST" pointer in TSO
	if CTL do POST^LNTRB(.ttxpri,CID,LTC,TAMT,%EffectiveDate,%UserStation,TSO,TCMT,CRCD,,,,,SECONDARY) quit:ER

	// Product ~p1 missing transaction code - ~p2	
	set ETC = prodctl.crtrdi
	if ETC.isNull() do ETCERR^TTXEXT(acn.type, "CRTRDI") quit

	// CR Deferred Fee (Offset Assessment) Code
	do POST^LNTRB(.ttxpri,CID,ETC,+TAMT,%EffectiveDate,%UserStation,TSO,TCMT,CRCD,,,,,SECONDARY.get()) quit:ER

	quit


COLLECT(RecordLN ln,
	RecordTTX ttx,
	RecordLNFEEP lnfeep,
	Number CID,
	String CTL,
	String ETC,
	Number TAMT,
	String FEE,
	Date %EffectiveDate)

	// Collect fee with assessment
	
	type public Cache %CACHE()
	type public Number ER
	type public String TC
	type public Boolean SECONDARY

	type Number TA, TRB
	type String CRCD, FEETC, ITC, TACRCD, TCMT, TSO

	// Ignore Future date
	if (%EffectiveDate > %SystemDate) set %EffectiveDate = ""

	set TCMT = ""
	set TRB = ln.trb

	type RecordLNFEE lnfee = Db.getRecord("LNFEE", "CID = :ln.cid, FEETYP = :FEE", 1)
	
	// Collect Fee With Assessment flag
	if 'lnfeep.cfwa quit

	// Linked tran code should collect this fee
	if 'TC.get().isNull(),$$TRNLNK(.ln, TC) quit	

	set TSO = "LNFEEIN#"_FEE_":"_TAMT

	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE = :ln.type")

	set FEETC = prodctl.crtrmi
	
	// Update TSO entry for this transaction	
	if 'ln.lnfeeta.isNull() do {
	
		type RecordACN acn1 = Db.getRecord("ACN", "CID = :ln.lnfeeta", 1)
		
		if 'acn1.getMode() quit
		
		type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE = :acn1.type")
		
		set TSO = $$FIELDIN^UTSO(TSO,"OFFST",prodctl.drtrgp_":"_ln.lnfeeta)
		}
		
	else  if 'ln.lnfeegl.isNull() set TSO = $$FIELDIN^UTSO(TSO,"OFFST",$select(TRB:"MDR",1:"MCR")_":"_ln.lnfeegl)
	
	// CR Miscellaneous Income Tran Code
	do POST^LNTRB(.ttx,CID,FEETC,TAMT,%EffectiveDate,%UserStation,TSO,"",ln.crcd,,,,,SECONDARY.get()) quit:ER

	// Reset TSO for next transaction
	set TSO = "LNFEEIN#"_FEE_":"_TAMT

	set TA = 0
	
	// Fee has to be collected from another account
	if 'ln.lnfeeta.isNull() do {
		
		// Loan fee for account ~p1
		set TCMT = $$^MSG(332,CID)
		
		set TA = ln.lnfeeta 

		set TSO = $$FIELDIN^UTSO(TSO,"FCID",TA)
		
		type RecordACN acn1 = Db.getRecord("ACN", "CID = :TA", 1)
		
		if 'acn1.getMode() quit
		
		type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE = :acn1.type")
		
		set FEETC = prodctl.drtrgp

		/*
		if the fee collected from another IBS account or target
		account is in a currency other than the currency of the loan,
		then call the conversion routine.
		*/

		// Currency code of target account
		set TACRCD = acn1.crcd
		
		if (TACRCD '= ln.crcd) do {
		
			type Number EXCAMT
			
			if '$$DEFER(.lnfeep, FEE, ""),CTL.extract(3),lnfeep.gltrop do {
			
				do OFFST0(.acn1, .lnfeep, .ttx, TAMT, CRCD, FEE, $select('ETC.get().isNull():ETC,1:FEETC))
				
				do OFFST1(.acn1,.lnfeep,.ttx)
				}
				
			// Find exchange G/L account
			type RecordCRCD crcd = Db.getRecord("CRCD", "CO = :CUVAR.co,CRCD = :TACRCD")
			
			do EXC^CRCDUTL(ln.crcd,TACRCD,TAMT,1,1,00,ln.ccode,,1,CUVAR.co,%SystemCurrency,crcd.curdec) quit:ER
			
			set TAMT = EXCAMT.roundCur()
			
			set CRCD = TACRCD
			}
		}

	// From a G/L account
	if 'TA,'ln.lnfeegl.isNull() do {
	
		set TA = ln.lnfeegl
		
		set FEETC = $select(TRB:"MDR",1:"MCR")

		// Loan fee for account ~p1
		set TCMT = $$^MSG(332,CID)
		}

	if 'TA do {
	
		set TA = CID
		
		/* 
		  The transaction code the system uses to post a debit transaction 
		  for principal only payments.
		*/
		
		set FEETC = prodctl.drtrpr
		}

	if TACRCD.get().isNull() set TACRCD = ln.crcd

        if TA do {
        	
                type ResultSet rs1 = Db.select("CID","DEP","CID=:TA")
                
                if rs1.next() do {
                	
                	// POST^LNTRB will use this object, if it exists
                        type public RecordDEP dep = Db.getRecord("DEP", "CID = :TA")
                        }
                }

	do POST^LNTRB(.ttx,TA,FEETC,TAMT,%EffectiveDate,%UserStation,TSO,TCMT,TACRCD,,,,,SECONDARY.get())

	quit


CMPMTH(String FEE)	// Computation method

	type String AMTH = ""

	type ResultSet rs = Db.select("AMTH","LNFEEP","FEETYP=:FEE")

	if rs.next() set AMTH = rs.getCol("AMTH")

	quit AMTH


public TBL1(String TBL())	// Create element table lookup

	type ResultSet rs = Db.select("TRTYPE,TRDES","LNTRS")

	while rs.next() set TBL(rs.getCol("TRTYPE")) = rs.getCol("TRDES")

	type ResultSet rs1 = Db.select("FEETYP,DESC","LNFEEP")
	
	while rs1.next() set TBL(rs1.getCol("FEETYP")) = rs1.getCol("DESC")

	set TBL("P")=$$^MSG(5695)	// Principal
	set TBL("I")=$$^MSG(5353)	// Interest

	quit


public TBL2(String TBL())	// Create element table lookup for top-level fees

	// Used on screen LNFEEGRP
	
	type ResultSet rs = Db.select("FEETYP,DESC,LFEE","LNFEEP","LFEE=0")
	
	while rs.next() set TBL(rs.getCol("FEETYP")) = rs.getCol("DESC")

	quit


public TBL3(String TBL())

	// Create table lookup for string elements including top-level fees

	type ResultSet rs = Db.select("TRTYPE,TRDES","LNTRS")
	
	while rs.next() set TBL(rs.getCol("TRTYPE")) = rs.getCol("TRDES")

	type ResultSet rs1 = Db.select("FEETYP,DESC","LNFEEP","LFEE=0")
	
	while rs1.next() set TBL(rs1.getCol("FEETYP")) = rs1.getCol("DESC")

	set TBL("P")=$$^MSG(5695)	// Principal
	set TBL("I")=$$^MSG(5353)	// Interest

	quit


ETC(RecordLN ln,
    RecordLNFEEP lnfeep,
    Boolean DECR)		// Flag indicates "decrease" tran code is needed
    
    	// Get fee transaction code

	type String ETC

	if (ln.grp = "COM") set ETC = $select('DECR:lnfeep.comfdt,1:lnfeep.comfct)
	else  if (ln.grp = "MTG") set ETC = $select('DECR:lnfeep.mtgfdt,1:lnfeep.mtgfct)
	else  if (ln.grp = "LN") set ETC = $select('DECR:lnfeep.lnfdt,1:lnfeep.lnfct)
	else  if (ln.grp = "CBL") set ETC = $select('DECR:lnfeep.cblfdt,1:lnfeep.cblfct)
	else  if (ln.grp = "RC") set ETC = $select('DECR:lnfeep.rcfdt,1:lnfeep.rcfct)
	else  if (ln.grp = "DM") set ETC = $select('DECR:lnfeep.dmfdt,1:lnfeep.dmfct)
	else  if (ln.grp = "CC") set ETC = $select('DECR:lnfeep.ccfdt,1:lnfeep.ccfct)

	if ETC.isNull() do {
		
		type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE = :ln.type")

		// DR Miscellaneous Income Tran Code		
		if 'DECR set ETC = prodctl.drtrmi

		// CR Misc Fee Reduction Adj Tran Code
		if DECR set ETC = prodctl.crtrmfr
		}
	
	quit ETC

ETC1(RecordLNFEEP lnfeep,	// Loan Fee Plan object
     Number DC)			// Debit/Credit Indicator (0-Debit, 1-Credit)
		
	// Return trancode for G/L offsets

	type String ETC
	
	if DC do {
		// Fee Income Offset Code - Increase
		set ETC = lnfeep.feeicrtc
		if ETC.isNull() set ETC = CUVAR.FEEICRTC
		if ETC.isNull() set ETC = "MCR"	
		
		}
	else  do {
		// Fee Income Offset Code - Decrease
		set ETC = lnfeep.feeidrtc
		if ETC.isNull() set ETC = CUVAR.FEEIDRTC
		if ETC.isNull() set ETC = "MDR"
		
		}
		
	quit ETC
	
	
TRNGRP(RecordLNFEEP lnfeep,
       String TC)

	if lnfeep.trgrp.isNull() quit 1
	
	type RecordUTBLTRNGRPL grpl = Db.getRecord("UTBLTRNGRPL", "TRNGRP = :lnfeep.trgrp,TRNCD = :TC", 1)
	
	if (grpl.getMode() = 1) quit 1
	
	quit 0


LOGMAX(Number feemax(,,,))	// Log errors for max fee amount

	type public String %FN
	
	type Number CID, SEQ
	type String FEE, RM

	set (CID,FEE,SEQ) = ""
	
	if %FN.get().isNull() set %FN = $T(+0)
	
	for  set CID = feemax(CID).order() quit:CID.isNull()  do {
		
		for  set FEE = feemax(CID,FEE).order() quit:FEE.isNull()  do {
			
			for  set SEQ = feemax(CID,FEE,SEQ).order() quit:SEQ.isNull()  do {
				
				// Calculated fee ~p1 of ~p2 exceeds maximum amount of ~p3
				set RM = $$^MSG("401",FEE,+feemax(CID,FEE,SEQ),feemax(CID,FEE,SEQ).piece("|",2))
				
				// Loan Fees
				do LOG^UTLEXC(%FN,"*",$$^MSG("4099"),CID,,RM)
				}
			}
		}

	quit


public	FINDFEE(Number CID,		// Account number
		String FEE,		// Account fee type
		Boolean STR,		// String flag			/REF:W
		Number POS)		// Position			/REF:W

	/*
	Find fee in Internal Bill Control

	   Additional notes on ARGUMENTS:

		. STR
			yes/no indicates whether or not this fee is in
			the string

		. POS
			If STR=1, this will be the piece in the string
			If STR=0, POS will be null

	*/

	type String BIL0

	set STR = 0
	
	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0", "CID = :CID", 1)
	
	set BIL0 = $$BIL0ELE^BILFUNCS(.lnbil0)
	
	for POS = 1:1:20 quit:BIL0.piece($C(9),POS).isNull()  do { quit:STR
		
		if BIL0.piece($C(9),POS).piece("#",1) = FEE set STR = 1 quit
		}
		
	if STR quit
	
	set POS = ""
	
	quit


public DEFTOT(Number CID)	// Calculate Total Deferred Fee for an Account

	/*

	   Calculates the total outstanding deferred fees for an account by
	   collating through each FEETYP on the account and summing the
	   deferred fees

	*/

	type Number DEFT = 0

	type ResultSet rs = Db.select("DEFTOT","LNFEE","CID=:CID")
	
	while rs.next() set DEFT = DEFT + rs.getCol("DEFTOT")
	
	// Return Total Deferred Fees
	quit DEFT


public FEEREC(Number CID,
	      String FEETYP,
	      String GLSC)	// Determine Fee Receivable G/L Number

	// The fee receivable G/L is determined either from the fee plan or
	// from the G/L Set Code of the account

	type public Cache %CACHE()

	type Number ACCT

	set GLSC = GLSC.get()

	type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP = :FEETYP", 1)
	
	set ACCT = lnfeep.glfr

	if ACCT.isNull() do {
		
		type RecordUTBLGLSC glsc = %CACHE("GLSC").getRecord("UTBLGLSC", "GLSC = :GLSC")
		
		set ACCT = glsc.lgl5
		}

	quit ACCT


public FEEINC(Number CID,
	      String FEETYP,
	      String GLSC)	// Determine Fee Income G/L Number

	// The fee income G/L is determined either from the fee plan or
	// from the G/L Set Code of the account

	type public Cache %CACHE()

	type Number ACCT

	set GLSC = GLSC.get()

	type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP = :FEETYP", 1)
	
	set ACCT = lnfeep.glfi

	if ACCT.isNull() do {
		
		type RecordUTBLGLSC glsc = %CACHE("GLSC").getRecord("UTBLGLSC", "GLSC = :GLSC")
		
		set ACCT = glsc.lglf
		}
		
	quit ACCT


LOADBAS(String basis(),
	Number CID)		// Build basis array

	type String FEE

	type ResultSet rs = Db.select("FEETYP","LNFEE","CID=:CID AND FEETYP<>'*'")
	
	while rs.next() do {
		
		set FEE = rs.getCol("FEETYP")
		
		type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP = :FEE", 1)
		
		if 'lnfeep.basis.isNull() set basis(lnfeep.basis,FEE) = ""

		}
	quit


public LOADLNK(Number CID,
	       String array(,))	// Build linked fee array for bill record

	type Number PC
	type String ELMNT, ROW
	
	// Build lnkfee array
	do LNKFEE^LNBLDE(CID)

	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0", "CID = :CID", 1)
	
	set ROW = $$ELEMENT^BILFUNCS(.lnbil0)
	
	for PC = 1:1:20 quit:ROW.piece($C(9),PC).isNull()  do {
		
		set ELMNT = ROW.piece($C(9),PC).piece("#",1)
		
		if 'ELMNT.isNull() do LOADLNK2(ELMNT, CID)
		}
	quit


LOADLNK2(String LFEE,
	 Number CID)

	type public String array(,,), lnkfee(,), ELMNT
	
	type String FEE = ""

	for  set FEE = lnkfee(LFEE,FEE).order() quit:FEE.isNull()  do {
		
		set array(CID,ELMNT,FEE) = ""
		
		do LOADLNK2(FEE, CID)
		}

	quit


TRNLNK(RecordLN ln,
       String TC)
       
	// Check to see if a linked tran code should collect this fee

	// Fee Target Account
	if ln.lnfeeta quit 0

	// Fee G/L Account
	if ln.lnfeegl quit 0

	// Linked Tran Code
	type RecordTRN trn = Db.getRecord("TRN", "ETC = :TC")
	
	if trn.lnketc.isNull() quit 0
	
	quit 1


public	GLACN(RecordLN ln,		// Loan account			/REF:R
      	      RecordLNFEEP lnfeep,	// Loan fee plan		/REF:R
      	      RecordUTBLGLSC glsc,	// G/L set code object		/REF:R
	      String FEE,		// Fee type
	      Date DUEDT)		// Payment due date

	// Returns G/L account used for assessment offsets

	type Number ACN

	// Return receivable account
	if $$DDICHK(FEE, DUEDT, .lnfeep) do {
		
		set ACN = lnfeep.glfr	
		if ACN.isNull() set ACN = glsc.lgl5
		}
		
	// Return income account
	else  do {
		
		set ACN = lnfeep.glfi
		if ACN.isNull() set ACN = glsc.lglf
		}

	quit ACN


public	DDICHK(String FEE,		// Fee type
       	       Date DUEDT,		// Payment due date		/NOREQ
	       RecordLNFEEP lnfeep)	// Loan fee plan		/REF:R
	       
	// Due date income recognition check

	set DUEDT = DUEDT.get()
	
	/*
	Under some conditions, the offset to assessment transaction will
	be the receivable account and not the income account.  Those
	conditions are:

	1. Field [LNFEEP]RIDD is turned on.  This flag indicates whether
	   or not system should recognize income on assessment (billing)
	   or due date.
	*/
	
	if 'lnfeep.exists() set lnfeep = Db.getRecord("LNFEEP", "FEETYP = :FEE", 1)
	
	if 'lnfeep.ridd quit 0


	/*
	2. Fee is based upon billing.  If not, there is no due date
	   associated with the amount.  Or, if there is a due date, it
	   is considered due as soon as it is assessed.
	*/
	if (lnfeep.amth '= 3) quit 0


	/*
	3. If fee amount is associated with a due date, credit receivable
	   account instead of income account if due date is less than or
	   equal to due date.  This is
	   because the system debits the receivable and credits income (or
	   deferred income) on the due date.  If DUEDT is passed, call is
	   from bill record maintenance process and we will do this check.
	   If due date is not passed, call is from billing process and
	   therefore due date is always in future.  We would therefore
	   not want to do the due date check and let the system debit and
	   credit the receivable account.
	*/
	if 'DUEDT.isNull(),(DUEDT '> %SystemDate) quit 0


	/*
	We do not need to worry about any other conditions.

	1. If billing based fee is assessed manually over teller line as
	   primary transaction, user enters offset.  We therefore don't
	   need to be concerned with these assessments in this section of
	   code.

	2. The only time that the system generates these assessments
	   is as the result of a payoff transaction.  When the payoff
	   routine ^LNPO2 calls into this routine, it does so with
	   CTL="001".  We will therefore not be creating transactions
	   within this routine.  This section will not be accessed.
	*/

	quit 1


public DEFER(RecordLNFEEP lnfeep,
	     String FEE,
	     Date DUEDT)	// Determines whether income is deferred

	/*

	. lnfeep	lnfeep object				/TYP=RecordLNFEEP/REQ/MECH=REF
	. FEE		Fee Type (Required)			/TYP=T/REQ
	. DUEDT		Payment Due Date (when called by LNBIL)	/TYP=D/NOREQ

	*/

	// We will not affect deferral fields if deferral flag is turned off.
	if 'lnfeep.definc quit 0

	/*
	We will not affect deferral fields if the fee is coded to recognize
	income (or deferral) on the scheduled due date rather than the
	assesment date, and the date of the bill is in the future.
	*/
	if $$DDICHK(FEE, DUEDT, .lnfeep) quit 0

	quit 1


public LNKBAS(String ELEMNT)

	/*
	  Function to loop through all loan fees and return an array of all
	  linked loan fees with the given as the basis.

	   ARGUMENTS:
	   . ELEMNT   Loan fee which will be the basis fee that all linked
	              fees are compared to before being added to the array.

	   RETURN:   Array LNKFEE will contain all loan fees linked to the
	    	     basis.

	   EXAMPLE:  This function is called from the AFTER_INSERT
	    	     trigger in the LNFEE filer.

	    D LNFEEU^LNKBAS(LNFEE.FEETYP)

	*/
	type public String LNKFEE()
	
	if 'ELEMNT.exists() quit

	type ResultSet rs = Db.select("FEETYP,BASIS","LNFEEP","LFEE=1")

	while rs.next() if (rs.getCol("BASIS") = ELEMNT) set LNKFEE(rs.getCol("FEETYP")) = ""

	quit


public LATE(RecordLN ln,
	    Number CID,
	    Date %EffectiveDate)

	/*
	  Extrinsic function to check if there is a late fee to be charged.
	  If there is a fee, adding the amount due to the total.

	   ARGUMENTS:
	   . ln    Loan object             		/TYP=RecordLN/REQ/MECH=REF

	   . CID   Account number which the late fee will be debit from.

	   . EFD   The effective date of transaction. If EFD is not passed
	           in, we assume that EFD=TJD

	   RETURN: The amount of the late charge fee.

	   EXAMPLE: This extrinsic function is called from BCHLNLATE.  
	    	    
	    	    set DUE=DUE+$$LATE^LNFEEU(.ln,CID,JD)
	*/
	
	type Date TRDATE
	type Number DC, FEEREM, IDX, TOTAL, TOTALX
	type String FEEPLAN, PAMT, TSO, X()

	set (TOTAL,TOTALX) = 0

	if %EffectiveDate.isNull() set %EffectiveDate = %SystemDate
	
	set FEEPLAN = ""
	
	if (%EffectiveDate = %SystemDate) do { quit TOTAL
		
		// Get Fee Plan
		type ResultSet rs = Db.select("FEETYP,FEEREM","LNFEE","CID=:CID")
		
		while rs.next() do {
			
			set FEEPLAN = rs.getCol("FEETYP")
			set FEEREM = rs.getCol("FEEREM")
			
			type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP=:FEEPLAN", 1)
			
			if 'lnfeep.getMode() quit
			
			// Late Charge Fee Flag
			if lnfeep.late set TOTAL = TOTAL + FEEREM
			}
		}
	/*
	If it is effective-dated, then ^HIST(CID,SEQ) must be scanned
	trdate(Transaction Date);seq,tso,pamt(FeeplanAmt),crcd(CR,DR indicator),totalx(1 tran late fee)
	*/
	type ResultSet histrs = Db.select("TJD,TSO,ITC,TSEQ","HIST","TSEQ=:SEQ and TJD>:%EffectiveDate","TSEQ DESC")
	
	while histrs.next() do {
		
		// Initialize one transaction late fee
		set TOTALX = 0
		set TRDATE = histrs.getCol("TJD")
		set TSO = histrs.getCol("TSO")

		// Generate X("LNFEE")="LNFEE#OPCHG:20,FEE1:50"
		do OUT^UTSO(.X,TSO)
		
		if 'X("LNFEE").exists() quit
		
		// PAMT is the string "FeeplanAmt"
		for IDX = 1:1:X("LNFEE").length(",") do {
			
			// OPCHG:20,FEE1:50
			set PAMT = TSO.piece(",",IDX)
			
			// Late fee for one transaction
			set TOTALX = TOTALX + PAMT.piece(":",2)
			}
			
		// Piece 2, the first digit;1=CR,0=DR
		set DC = histrs.getCol("ITC").extract()
		
		if (ln.trb - DC) set TOTAL = TOTAL - TOTALX		
		else  set TOTAL = TOTAL + TOTALX
		}
		
	quit TOTAL


SETFEES(RecordTTX ttx,
	String FEESS())	// Establish the fee being reversed

	/*
	   Do not reapply the fee if this fee is being reversed
	   if this is a primary fee in the linked fee list
	   do not reaply the linked fee
	   Conditions:
	         1) We are in the reverse and reaply situation
	         2) Primary Transaction is either reversal or error/correct...
	            In this situation it would most probably be reversal
	            because you cannot error correct system generated transactions...
	         3) Effective date passed in is the Effective date of the primary
	            transaction 
	         4) If this fee is linked to the other - reaply primary fee
	         5) if this is a primary fee in the lnkfee() then don't do anything for it
	            or the linked fee.
	   So to further facilitate this - we will set up an array of fees that must be
	   charged to the account - but will exclude those that are being reversed based
	   on the conditions specified above.

	*/
	type public Boolean LNPTSRV
	type public String basis(,), lnkfee(,)

	type String FEE = "", REVFEE = ""

	if 'LNPTSRV.get().isNull() do {
	
		// Not a reversal or error-correct
		if (ttx.itc6 + ttx.itc12) = 0 quit
		
		// Transaction Effective Dates do not match
		if (%EffectiveDate '= ttx.efd) quit
		
		// Fee reversal indicator		
		set REVFEE = $$FIELD^UTSO(ttx.tso,"LNFEEIN").piece(":",1)
		}

	type ResultSet rs1 = Db.select("FEETYP","LNFEE","CID=:CID")
	
	while rs1.next() set FEESS(rs1.getCol("FEETYP")) = ""

	// Find and delete fees that do not need to be reaplied
	for  set FEE = FEESS(FEE).order() quit:FEE.isNull()  do {
		
		if (FEE = REVFEE) kill FEESS(FEE) quit
		
		if lnkfee(FEE,REVFEE).exists() ! basis(FEE,REVFEE).exists() kill FEESS(REVFEE) quit
		}

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60844^9915^Hema Puttaswamy^42472"	// Signature - LTD^TIME^USER^SIZE
