public LNOTSSC1
  /*		
	ORIG: ZWITKOWITSM - 10/30/2000
	DESC: Extract program for CF and VA regulatory reports.

	---- Comments --------------------------------------------------------

	This procedure is responsible for generating extracts for regulatory
	reports of type CF### and VA###.  This must be run after the extracts
	for SC### are run since these extracts are dependent on those results.

	---- Revision History ------------------------------------------------
	
	04/18/07 - RussellDS - CR26387
		   Eliminated use of UHFETCH.

	07/31/06 - KELLYP - CR 22048
		   Modified FRMDT section to eliminate PRECEDENCE warning.
	
 	08/24/05 - SWARNALATHAP - CR16708
		   . Corrected the syntax of Db.select in SCAN section by 
		     removing the word "ORDER BY" during the fetch of the 
		     record in LNLS6 table.
            	   . Retrofitted the following changes made in profile 01
	    	     for the project "OTS TFR March 2004 Reporting"
			Modified START,SCAN sections and removed INIT360 
			section.  Added code for new cells CF225 and 
			CF245 in START section.
	 ----------------------------------------------------------------------
 */

	do START
	
	quit

START
	// Initialize some variables

	new TJD,TD,FD,CF,NUM,PCFL4,TMPCF
	set TJD=Db.getOneRow("TJD","CUVAR")
	set TD=TJD
	set FD=$$FRMDT(TJD)


	// Do the CF### extracts

	do HISTM(1,"SC230","","CF190")				// CF190 extract

	do HISTM(1,"SC235","","CF200")				// CF200 extract

	do HISTM(1,"SC240","","CF210")				// CF210 extract

	do HISTM(1,"SC260","","CF260")				// CF260 extract

	do HISTM(1,"SC265","","CF270")				// CF270 extract
	
	do HISTM(1,"SC256","","CF245")				// CF245 extract
	
	do HISTM(1,"SC251","","CF225")				// CF225 extract

	do HISTM(1,"SC254","","CF225")				// CF225 extract

	do HISTM(1,"SC255","","CF225")				// CF225 extract

	for NUM=230 do SCAN(1,"SC"_NUM,"CF280")			// CF280 extract

	for NUM=235,256 do SCAN(1,"SC"_NUM,"CF290")		// CF290 extract

	for NUM=240,260,265 do SCAN(1,"SC"_NUM,"CF300")		// CF300 extract

	for NUM=230 do SCAN(2,"SC"_NUM,"CF310")			// CF310 extract

	for NUM=235,256 do SCAN(2,"SC"_NUM,"CF320")		// CF320 extract

	for NUM=240,260,265 do SCAN(2,"SC"_NUM,"CF330")		// CF330 extract

	for NUM=310:1:330 do SCAN(4,"SC"_NUM,"CF400")		// CF400 extract
	
	for NUM=300,303 do SCAN(4,"SC"_NUM,"CF390")		// CF390 extract

	/*
	*** IMPORTANT ***
	We are not currently supporting CF340 through CF390 and all VA###'s.
	The following calls will not extract anything.  The only important call
	in the rest of this section is the call to SAVTMPCF to save off the
	extracts that were processed above.  The following calls can be
	uncommented and modified at a later date to process the extracts.  The
	"core" processing for them is already in place.
	*/

	/*  the following are not supported yet
	for NUM=230:1:265 do HISTM(2,"SC"_NUM,"","CF340")	// CF340 extract

	for NUM=230:1:265 do HISTM(3,"SC"_NUM,"","CF350")	// CF350 extract
	
	*/

	if $D(TMPCF) do SAVTMPCF			// Save off CF extracts

	/*
	Do the VA### extracts
	VA940, VA960, VA965, VA970, VA975 are all provided by a G/L system
	such as FMS.  Do not process them here.
	*/

	/*  the following are not supported yet
	for NUM=230:1:240,450:1:470 do SCAN(5,"SC"_NUM,"VA951")  //VA951 extract

	for NUM=250,253 do SCAN(5,"SC"_NUM,"VA952")		// VA952 extract

	do SCAN(5,"SC256","VA953")				// VA953 extract

	do SCAN(5,"SC260","VA954")				// VA954 extract

	do SCAN(5,"SC265","VA955")				// VA955 extract

	do SUM("VA",951,955,"VA95")				// VA95 extract

	if $D(TMPCF) do SAVTMPCF			// Save off VA extracts
	*/

	quit


HISTM(TYPE,SC,TAG,CF1,CF2)	// CF extracts on HIST - can add CF3.. If needed
	/*
	TYPE 	= Type of history entries looking for
		1 = DISBURSMENTS ON LOANS
		2 = CASH REPAYMENTS OF PRINCIPLE
		3 = NON-CASH REPAYMENTS OF PRINCIPLE
	SC	= SC### extract being used
	TAG	= Which query tag needs executing for "sub"extracts (optional)
	CF1	= CF### extract being created
	CF2	= CF### extract being created #2 (in case of TAG being used)
	*/

	new AMT,CF,CFT,CID,ETC,FLG,ITC,JD,Q,TRB,VALID,X,exe,vsql
	set TAG=$G(TAG)
	set CID=""

	type ResultSet rs=Db.select("CID","LNOTSSC1","SCDT=:TD AND SCLN=:SC")
        if rs.isEmpty() quit
        while rs.next() do {
                set CID=rs.getCol(1)

		// Determine which extract this account belongs in (CF1 or CF2)
		if TAG'="" set CFT=$$@TAG
		else  set CFT=1
		if CFT=1 set CF=CF1
		if CFT=2 set CF=CF2
		// Add more lines like above here for CF3... (in case TAG can
		// return more than 2 "sub"extracts
		
		// account already added in to extract, don't re-process
		if Db.isDefined("LNOTSSC1","TJD,CF,CID") quit
		if $D(TMPCF(TJD,CF,CID)) quit

		set JD=TJD
		set FLG=1
		set VALID=1

		type RecordLN ln=Db.getRecord("LN","CID")

		if TYPE=1 do {

			//Date of last transaction not in current quarter
			if ln.tld<FD set VALID=0
			/*
			CF400: exclude accounts where collateral type is 10 
			(Real Estate).
			*/

			if CF1="CF400" do {
				new COLCD,COLTYP,GRP,utblcolcd
				set GRP=ln.grp
				set COLCD=ln.colcd
				quit:$G(COLCD)=""

				type RecordUTBLCOLCD utblcolcd
				set utblcolcd=Db.getRecord("UTBLCOLCD","GRP=:GRP,KEY=:COLCD")
				set COLTYPE=utblcolcd.type
				if $G(COLTYPE)=10 set VALID=0
				}
			}
		if TYPE=2 do {
			// not yet supported.
			set VALID=0
			}
		if TYPE=3 do {
			// not yet supported.
			set VALID=0
			}

		quit:'VALID

		set TRB=ln.trb

		type DbSet ds = Db.selectDbSet("HIST", "CID=:CID AND TJD>=:FD", "TSEQ DESC")
		
		while ds.next() do {
			
			type RecordHIST hist = ds.getRecord("HIST")
			
			set VALID=1

			set ITC = hist.itc1
			set ETC = hist.etc
			set AMT = +hist.tamt

			if TYPE=1 do {
				// transaction is considered a disbursement
				// if PCF4=1 and the transaction is an
				// "increase" transaction.
				if '$D(PCFL4(ETC)) do {
					type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC")
					set PCFL4(ETC)=trn.pcfl4
					}
				if 'PCFL4(ETC) set VALID=0 quit	// determine if HIST
				if TRB=ITC set VALID=0 quit	// is a disbursement
				}
			if TYPE=2 do {
				// not yet supported.
				set VALID=0 quit	// determine if HIST
				}			// is a cash payment
			if TYPE=3 do {
				// not yet supported.
				set VALID=0 quit	// determine if HIST
				}			// is a non-cash payment

			quit:'VALID

			set TMPCF(TJD,CF,CID)=AMT+$G(TMPCF(TJD,CF,CID))
			set $P(TMPCF(TJD,CF),"|",1)=AMT+$P($G(TMPCF(TJD,CF)),"|",1)
			if FLG set $P(TMPCF(TJD,CF),"|",2)=$P($G(TMPCF(TJD,CF)),"|",2)+1
			set FLG=0
			}
		}

	quit


NEWORPREV()	// Which extract - return 1 for CF1, 2 for CF2

	type RecordLN ln=Db.getRecord("LN","CID")

	new ext
	set ext=ln.rescls	// 1 - Newly Built, 2 - Previously Occupied
	if ext="" set ext=1	// if none, default "Newly Built"
	quit ext


SCAN(TYPE,SC,EX)	// Scan through SC### extract
	/*
	TYPE 	= Type of accounts looking for
		1 = LOAN AND PARTICIPATIONS PURCHASED
		2 = LOAN AND PARTICIPATIONS SOLD
		3 = REFINANCED LOANS
		4 = CLOSED OR PURCHASED LOANS
		5 = FORECLOSURES
	SC	= SC### extract being used
	EX	= Extract being created
	*/

	new AMT,CID,HISTMFLG
	set HISTMFLG=0
	set CID=""

	type ResultSet rs=Db.select("CID","LNOTSSC1","SCDT=:TD AND SCLN=:SC")
        if rs.isEmpty() quit

	/* Quit processing list of accounts in result set rs if HISTM is called
	   from within SCAN when first account is processed. HISTM will
	   generate all the data for every account in the SC extract during 
	   this first call. Failure to quit after the first call to HISTM
	   will signficantly impact performance by a factor of the square of
	   the number of accounts being processed.
	*/

        while rs.next() do { quit:HISTMFLG		
                set CID=rs.getCol(1)

		// account already added in to extract, don't re-process
		if Db.isDefined("LNOTSSC1","TJD,EX,CID") quit
		if $D(TMPCF(TJD,EX,CID)) quit
		
		set AMT=0

		type RecordLN ln=Db.getRecord("LN","CID")

		if TYPE=1 do {
			if 'Db.isDefined("LNPP6","CID") quit
			type RecordLNPP6 lnpp6=Db.getRecord("LNPP6","CID")
			if lnpp6.sdat<FD quit
			set AMT=lnpp6.bbal
			}
		if TYPE=2 do {
			new done
			set done=0
			type ResultSet rs1=Db.select("SDAT,BALS","LNLS6","CID=:CID","PSEQ DESC")
			if rs1.isEmpty() quit
			while rs1.next() do { quit:done
				set SDAT=rs1.getCol(1)
				if SDAT<FD set done=1 quit
				set AMT=AMT+rs1.getCol(2)
				}
			}
		if TYPE=3 do {
			// not yet supported.
			// Allow refinanced loans to set AMT.  We want to
			// report the "gross" or "full" amount of loan.
			//if "REFINANCED" set AMT="GROSS AMOUNT OF LOAN"
			}
		if TYPE=4 do {
			/*
			   CF390 and CF400: Do not set AMT. TMPCF array will be built by
			   HISTM.
			*/

			if (EX="CF390")!(EX="CF400") do { quit
				do HISTM(1,SC,"",EX)

				/*
				   Do not process remainder of accounts in rs.
				   HISTM has already processed them.
				*/
				set HISTMFLG=1
				}
			}
		if TYPE=5 do {
			// not yet supported, but next line is probably all
			// that is needed.
			//if ln.fcld'<FD set AMT=ln.bal
			}

		quit:'AMT

		set TMPCF(TJD,EX,CID)=AMT
		set $P(TMPCF(TJD,EX),"|",1)=AMT+$P($G(TMPCF(TJD,EX)),"|",1)
		set $P(TMPCF(TJD,EX),"|",2)=$P($G(TMPCF(TJD,EX)),"|",2)+1
		}

	quit


SUM(ext,num1,num2,extnum)	// Summation extracts
	/*
	Sum the results of extracts ext_num1 through ext_num2 to generate
	extnum extract.

	-*** Important ***- This section needs the extracts being summed
	together to be stored locally in variable TMPCF.  If they have been
	saved to disk by calling SAVTMPCF, this section will not work!

	ext	= Extract initials being summed (ex. VA)
	num1	= Starting extract number of the summation (ex. 951)
	num2	= Ending extract number of the summation (ex. 955)
	extnum	= Summation extract being generated (ex. VA95)
	*/

	new num,tot
	set tot=0
	for num=num1:1:num2 do {
		if '$D(TMPCF(TJD,ext_num)) quit
		set tot=tot+$P(TMPCF(TJD,ext_num),"|",1)
		}
	if tot set $P(TMPCF(TJD,extnum),"|",1)=tot

	quit



SAVTMPCF	// Save off TMPCF to LNOTSSC and LNOTSSC1
	new CF,CID
	set CF=""
	set CID=""
	for  set CF=$O(TMPCF(TJD,CF)) quit:CF=""  do {
		new lnsc
		type RecordLNOTSSC lnsc=Class.new("RecordLNOTSSC")
		set lnsc.scdt=TJD
		set lnsc.scln=CF
		set lnsc.tot=$P(TMPCF(TJD,CF),"|",1)
		set lnsc.numcnt=$P(TMPCF(TJD,CF),"|",2)
		do lnsc.save()
		for  set CID=$O(TMPCF(TJD,CF,CID)) quit:CID=""  do {
			new lnsc1
			type RecordLNOTSSC1 lnsc1=Class.new("RecordLNOTSSC1")
			set lnsc1.scdt=TJD
			set lnsc1.scln=CF
			set lnsc1.cid=CID
			set lnsc1.amt=TMPCF(TJD,CF,CID)
			do lnsc1.save()
			}
		}
	kill TMPCF(TJD)
	quit



FRMDT(TD)	// Calculate the beginning of the quarter
		// Copied from procedure LNOTSSC
	new dt,mnth,td,%DS,%JD

	set dt=$$DAT^%ZM(TD,"MM/DD/YEAR")

	/*
	if today is the first day of the new quarter set it to the last day
	of the old quarter for conversion
	*/

	if "01/01,04/01,07/01,10/01"[$P(dt,"/",1,2) do {
		new td
		set td=TD-1
		set dt=$$DAT^%ZM(td,"MM/DD/YEAR")
		}

	set mnth=($P(dt,"/",1)-1)\3*3+1
	set mnth=$E("00",1,2-$L(mnth))_mnth
	set %DS=mnth_"/01/"_$P(dt,"/",3)
	set %JD=$$^SCAJD(%DS,"MM/DD/YEAR")
	quit %JD
 #OPTION ResultClass ON
Public String vSIG()	quit "60757^71043^Dan Russell^10581"	// Signature - LTD^TIME^USER^SIZE
