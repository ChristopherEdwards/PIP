DDPACN //Batch DDPACN - Update Front-End Strip File
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 12:47 - shetyes
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - DDPACN Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit quit
 do JOBMGR^BCHUTL(%FN,"DDPACN",.vINPUT)
 do ^JOBMGR(.vINPUT)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(CID) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("DDPACN","*","",CID.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,CID)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("DDPACN","*","",CID.get(),"",et)
 }
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,CID) //
	// tp can not be allowed to make duplicate records in file
	do Runtime.rollback()
	type Public Boolean FULL
	type Public Number ER=0
	type Public Number IO1CNT,IO2CNT
	type Public String IO1,IO2
	type Public String RM
	type Boolean ddpmode
	type Boolean NV
	type String drec
	type String XFRREC=""

	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	
	// Undefined Host Variable ~p1
	if acn.getMode()=0 set ER=1 set RM=$$^MSG(8592,"CID") quit

	type RecordDDPACND ddpacnd,acndcopy
	type RecordDDPACNL ddpacnl,acnlcopy
	if acn.cls="D" do {

		set ddpacnd=Db.getRecord("DDPACND","CID=:CID",1)
		set ddpmode=ddpacnd.getMode()
		set acndcopy=ddpacnd.copy()

		// 13664 - Removed #BYPASS Command
		set NV=$$DEP^XFRPGM(.acn,.ddpacnd,.XFRREC)

		#if 'CUVAR.FEPXALL
		if 'FULL do BLDTMP(acndcopy.boo,ddpacnd.boo,acn.cid,acn.cls)
		#endif

		// If no change then do not touch DB		
		if 'NV,'FULL quit
		
		do ddpacnd.bypassSave()
		}
	else  do {
		
		set ddpacnl=Db.getRecord("DDPACNL","CID=:CID",1)
		set ddpmode=ddpacnl.getMode()
		set acnlcopy=ddpacnl.copy()

		// 13664 - Removed #BYPASS Command
		set NV=$$LN^XFRPGM(.acn,.ddpacnl,.XFRREC)

		#if 'CUVAR.FEPXALL
		if 'FULL do BLDTMP(acnlcopy.boo,ddpacnl.boo,acn.cid,acn.cls)
		#endif

		// If no change then do not touch DB
		if 'NV,'FULL quit
		
		do ddpacnl.bypassSave()
		}

	/*
	 review high volume account and update with new balance since
	 the strip file is updating it on the client side. We do not need
	 to send a 2nd update when the auto sync batch process runs.
	*/

	type RecordSFUPD sfupd=Db.getRecord("SFUPD","CID=:CID",1)
	if sfupd.getMode() do {
		if sfupd.lastbal=acn.bal quit
		set sfupd.lastbal=acn.bal
		do sfupd.save() 
		}

	/*
	 if no changes and this is not a full transfer stop processing and 
	 get next account.
	*/

	if 'NV,'FULL quit

	// --- Update mode for partial transfer of existing records only
	if 'FULL,ddpmode set drec="D,U,"_XFRREC
	else  set drec="D,I,"_XFRREC

	if acn.cls="D" use IO1 set IO1CNT=1
	else  use IO2 set IO2CNT=1
	write drec,!

	quit


BLDTMP(String OLD, String NEW, Number CID, String CLS)

	/*
	 Create an entry in ^TMP if the branch of ownership has been
	 file maintained.  The temporary file will be used to delete
	 the record in ^DDPACN on the original branch of ownership.
	 Not necessary if transferring all accounts to all branches.
	*/

	type public String cache(,)

	if (OLD.isNull() ! (OLD = NEW)) quit

	if cache("DDPACN", OLD).get().isNull() do {
		
		type RecordUTBLBRCD brcd1=Db.getRecord("UTBLBRCD","BRCD=:OLD")
		set cache("DDPACN", OLD) = brcd1.fepdir
	}
	if cache("DDPACN", NEW).get().isNull() do {
		
		type RecordUTBLBRCD brcd2=Db.getRecord("UTBLBRCD","BRCD=:NEW")
		set cache("DDPACN", NEW) = brcd2.fepdir
	}

	if (cache("DDPACN", OLD) '= cache("DDPACN", NEW)) do {
	
		type RecordTMPRPT2 tmp=Class.new("RecordTMPRPT2","PID=:%ProcessID,KEY1=:OLD,KEY2=:CID")
		set tmp.data=CLS
		do tmp.bypassSave()
	}

	quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
	/*
	   Determine all accounts which have changed since last update to
	   DDPACN and builds a file of the updates.
 
	   KEYWORDS: DDP
 
	   ARGUMENTS:
	       . vINPUT  Next block of accounts /TYP=T/REQ/MECH=REF
	       . msgout  Not currently used
 
	   INPUTS:
	       . System
 
	       . FEPXALL
	       . FULL  Full refresh option /TYP=L
 
	   RELATED:
	 
	----------------------------------------------------------------------

	 If the option to transfer all accounts to all branches is selected,
	 a single transfer file per file definition will be created for all
	 accounts processed by this thread.
 	*/

	type Public Number ER=0,IO1CNT=0,IO2CNT=0,IOQN1,IOQN2
	type Public String IO1,IO2
	type Public String DDPDIR
	type Public String GLOFILE1,GLOFILE2
	type Public Boolean FULL
	type String XBRCD,vRECORD
	type Public String trec(),frec(),srec()
	type String DUMMY
	if vINPUT.piece("|",2)="" quit

	do GETQUE(.IO1,.GLOFILE1,.IOQN1) quit:ER
	do GETQUE(.IO2,.GLOFILE2,.IOQN2) quit:ER
 
	// Delete client side branch acn records
	if 'FULL use IO1 write "T,"_%CurrentDate_","_%CurrentTime_",BRACN,1,N,G",!,"F,CID",!,"D,T,*",!
 
	use IO1 write trec("D"),!,frec("D"),!,srec("D"),!
	use IO2 write trec("L"),!,frec("L"),!,srec("L"),!	
	set XBRCD=vINPUT.piece("|",1)
	set vINPUT=vINPUT.extract(XBRCD.length()+2,99999)
	for  set vRECORD=vINPUT.piece("|",1) set vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD=""  do vPROC(vRECORD)
 
	/*
	  Close the strip file and initiate the transfer to the FEPs.
	  The calls to XFR, will pass null for branch code when the files should be sent
	  to all clients. Only when the file should be sent to a specific client
	  will that branch be sent to XFR. This is controlled at compile time by 
	  use of #if
	*/
	close IO1,IO2
 
	#if CUVAR.FEPXALL
	if 'IO1CNT set DUMMY=$$DELETE^%OSSCRPT(GLOFILE1,DDPDIR)
	else  do XFR("",IO1,"",IOQN1,GLOFILE1)
	if 'IO2CNT set DUMMY=$$DELETE^%OSSCRPT(GLOFILE2,DDPDIR)
	else  do XFR("",IO2,"",IOQN2,GLOFILE2)
 
	#else
	if 'IO1CNT set DUMMY=$$DELETE^%OSSCRPT(GLOFILE1,DDPDIR)
	else  do XFR(XBRCD,IO1,"",IOQN1,GLOFILE1)
 
	if 'IO2CNT set DUMMY=$$DELETE^%OSSCRPT(GLOFILE2,DDPDIR)
	else  do XFR(XBRCD,IO2,"",IOQN2,GLOFILE2)
	#endif
	quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
	/*

	   This section constructs the message buffers containing blocks of
	   accounts to send to the threads for processing.

	   KEYWORDS: DDP

	   ARGUMENTS:
	   . vINPUT Last message buffer
	   . msgout Not currently used

	   RELATED:
	  ----------------------------------------------------------------------

	   If the option to transfer all accounts to all branches is selected,
	   the account numbers placed into each message are retrieved by
	   collating through the ACN table.

	   The branch code is the first piece of each message followed by all
	   of the accounts to process.  It is needed by each of the threads
	   when initiating the transfer of the strip files to each of the FEPs.

	   Null is a valid value for the branch code when transferring all
	   accounts to all branches. The branch code is first defined in
	   OPEN and when NOT transferring all accounts to all branches,
	   is redefined after all accounts for a given branch have been
	   processed.

	*/

	type Public String BRCD,PRIO(),SEQ,vBUFOVFL
	type Public Boolean done
	type Boolean quit=0
	type Number vlen=0

	set vINPUT=vBUFOVFL.get()
 
	if done,vINPUT="" quit
	if vINPUT="" set vINPUT=BRCD_"|"
	set vBUFOVFL=""

	
	#if 'CUVAR.FEPXALL 
	
	// Exit from processing
	if SEQ="" set done=1

	type Public ResultSet vResult1
	if BRCD="" do {
		set SEQ=PRIO("").order()
		set BRCD=PRIO(SEQ)
		set vINPUT=BRCD_"|"
		do getrs(BRCD)
		}
	while vResult1.next() do process(vResult1.getCol(1),vResult1.getCol(2),.quit,.vlen) quit:quit
	if 'quit do {
		set SEQ=PRIO(SEQ).order()
		quit:SEQ=""
		set BRCD=PRIO(SEQ)
		do getrs(BRCD)
		}
	quit


getrs(String BRCD)
	type Public ResultSet vResult1
	set vResult1=Db.select("CID,BOO","ACN","BOO=:BRCD")
	quit


	#else
		type Public ResultSet vvResult
		while vvResult.next() do process(vvResult.getCol(1),vvResult.getCol(2),.quit,.vlen) quit:quit
		if quit=0 set done=1
	quit
	#endif


process(String vcur,
	String BOO,
	Boolean quit,
	Number vlen)		// Build vINPUT with the account just selected

	type Public String vBUFOVFL,vINPUT
	type String vrow

	if vINPUT="|" set vINPUT=BOO_"|"
	set vrow=vcur_"|" 
	set vlen=vlen+vrow.length()
	if vlen+26'<32000 set vBUFOVFL=BOO_"|"_vrow set quit=1 quit
	set vINPUT=vINPUT_vrow
	quit


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	type Literal String FEPXALL=CUVAR.FEPXALL
	type Public Boolean done,FULL
	type Public String BRCD="",ER,RM,SEQ
	type Public String FEP(),PRIO(),frec(),trec(),srec()
	type String drec,%READ,%TAB(),VFMQ

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

	// Batch requires compilation
	if cuvar.fepxall'=FEPXALL set %BatchExit=1,ER="W",RM=$$^MSG(5296) quit
 	
 	do INIT
	
	#if 'CUVAR.FEPXALL
	if 'FEP.data() set %BatchExit=1 quit
	#endif
	

	set %TAB("FULL")=".OPT10"
	
	set %READ="@@%FN,,,FULL/REQ"
	do ^UTLREAD if VFMQ="Q" set %BatchExit=1 quit

	#if CUVAR.FEPXALL
	type Public ResultSet vvResult=Db.select("CID,BOO","ACN")
	if vvResult.isEmpty() set %BatchExit=1 quit
 	#else
	set SEQ=PRIO("").order()
	if SEQ="" set %BatchExit=1 quit
	set BRCD=PRIO(SEQ)
	type Public ResultSet vResult1=Db.select("CID,BOO","ACN","BOO=:BRCD")
	#endif
	do BLDXFR

	/*
	 If the transfer is a full refresh and the option to transfer all
	 accounts to all branches is selected, create a single transfer
	 file that will delete the strip file on each of the front-ends.
	 This step is performed in the scheduler init because otherwise,
	 each thread would kill the strip file created by the other
	 threads.
	*/

	if FULL do {
		type String GLOFILE,RM
		type Number ER=0
		type Public Number %QN
		type Public String IO
		do GETQUE(.IO,.GLOFILE,.%QN) quit:ER

		use IO
		write trec("D"),!,"F,CID",!,"D,T,*",!
		write trec("L"),!,"F,CID",!,"D,T,*",!
		write "T,"_%CurrentDate_","_%CurrentTime_",BRACN,1,N,G",!,"F,CID",!,"D,T,*",!
		close IO

		// Transfer to all FEPs
		do XFR("",GLOFILE,"",%QN,.GLOFILE)
		}


	set done=0

 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("CID","ACN","")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	do INIT
	quit


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
	quit


FEPSETUP(String FEP(),
	 String HOSTDIR)

	/*
	The array FEP must contain the priority order when the data is being sent
	by the branch order. It is not needed when all accounts are being sent to all
	clients.
	
	The key into the FEP array must reflect the actual branch number when the accounts
	are being sent by branch, this is then used to match accounts to their front end.
	If all accounts are being sent to all branches then the branch number does not manner.

	*/

	#if 'CUVAR.FEPXALL
	type ResultSet rs=Db.select("BRCD,FEPDIR,STP","UTBLBRCD","FEPDIR is not NULL")
	while rs.next() if rs.getCol("FEPDIR").length()>0 set FEP(rs.getCol("BRCD"))=rs.getCol("FEPDIR")_"|"_(+rs.getCol("STP"))
	#else
	type ResultSet rs=Db.select("FEPDIR","DDPHOST","HOSTDIR=:HOSTDIR")
	while rs.next() set FEP(rs.getCol("FEPDIR"))=rs.getCol("FEPDIR")
	#endif
	quit


INIT	// Initialization

	/*
	   This label is called by both the scheduler and thread processes to setup variables 
	   needed for processing
	*/
	type Public String trec(),frec(),srec(),FEP(),PRIO()
	type Public Number DDPDIR,ER
	type Public String FEPXALL,HOSTDIR
	type String q,X

	set ER=0
	
	set DDPDIR=$$SCAU^%TRNLNM("DDP")
	set HOSTDIR=$$SCAU^%TRNLNM("DDPLOG")
	if DDPDIR="" set DDPDIR=$$DDPDIR^DDPUTL(HOSTDIR)

	do FEPSETUP(.FEP,HOSTDIR)

	set q=$C(34)
	do DEPINI(.trec,.frec,.srec)
	do LNINI(.trec,.frec,.srec)

	// Create an array of branches, in priority order, if the option
	// to transfer all accounts to all branches was not selected.


	type String N=""
	for  set N=FEP(N).order() quit:N=""  do {
		set X=FEP(N).piece("|",2)
		set X=PRIO(X+1).order(-1)+.0001 set PRIO(X)=N
		}
	quit


GETQUE(String IO,
       String GLOFILE,
       Number %QN)	//Private Get next DDP queue number

	//get next sequence number and create a transfer file name and open it.
	type Public String DDPDIR
	type String X
	set %QN=$$GETQUE^DDPXFR1()
	set IO=$$FILE^%TRNLNM("F"_%QN_".FEP",DDPDIR)
	set GLOFILE="F"_%QN_".FEP"
	set X=$$FILE^%ZOPEN(IO,"WRITE/NEWV",,5600)
	quit


	// Set up to transfer
XFR(String BRCD,			// Branch Code   	    /TYP=T/REQ
	String IO,			// File name of strip file  /TYP=T/REQ
	String IOKIL,			// File name of kill file   /TYP=T/REQ
	Number %QN,			// Queue number   	    /TYP=N/REQ
	String GLOFILE)			// OS file name		    /TYP=T/NOREQ

	/*
	     Build appropiate entries in tables DDPTQUE and DDPTQUE1 for the
	     files that will be sent to the clients.
	     
	     A Null branch code indicates transfer the file to all 
	     FEPs listed in FEP
	  ----------------------------------------------------------------------
	*/

	type String FEPDIR,HOSTDIR,QINFO
	type Public String DDPDIR,FEP()
	set HOSTDIR=$$DIR^DDPUTL
	if GLOFILE.get()="" quit

	type RecordDDPTQUE ddptque=Class.new("RecordDDPTQUE","%QN=:%QN")
	set ddptque.date=%CurrentDate
	set ddptque.time=%CurrentTime
	set ddptque.tblrms=GLOFILE
	set ddptque.dirnam=DDPDIR
	do ddptque.bypassSave()

	type RecordDDPTQUE1 ddptque1=Class.new("RecordDDPTQUE1")
	set ddptque1.%qn=%QN
	set ddptque1.hostdir=HOSTDIR
	set BRCD=BRCD.get()
	if BRCD="" do {
		type String N=""
		for  set N=FEP(N).order() quit:N=""  do {
			set ddptque1.fepdir=FEP(N).piece("|",1)
			do ddptque1.bypassSave()
			}
		}
	else  do {
		set ddptque1.fepdir=FEP(BRCD).piece("|",1)
		do ddptque1.bypassSave()
		}
	quit


DEPINI(String trec(),
       String frec(),
       String srec())	//Deposit init

	/*
	 Use literal ResultSet to populate static frec,srec lines 
	*/	 

	set trec("D")="T,"_%CurrentDate_","_%CurrentTime_",""DDPACND"",1,N,B"
	set frec("D")="F,CID"
	set srec("D")="S,N"

	type literal ResultSet rs=Db.select("DI,TYP","DBTBL1D","%LIBS='SYSDEV' AND FID='DDPACND' and DI <>'CID' and CMP is null and DI not like '""%'") 
	#while rs.next()
	xecute "set frec(""D"")=frec(""D"")_"",""_rs.getCol(1)"
	xecute "set srec(""D"")=srec(""D"")_"",""_rs.getCol(2)"
	#end
	quit


LNINI(String trec(),
      String frec(),
      String srec())	//Loan init
	/*
	 Use literal ResultSet to populate static frec,srec lines 
	*/	 
	set trec("L")="T,"_%CurrentDate_","_%CurrentTime_",""DDPACNL"",1,N,B"
	set frec("L")="F,CID"
	set srec("L")="S,N"
	type literal ResultSet rs=Db.select("DI,TYP","DBTBL1D","%LIBS='SYSDEV' and FID='DDPACNL' and DI <>'CID' and CMP is null and DI not like '""%'")
 
	#while rs.next()
	xecute "set frec(""L"")=frec(""L"")_"",""_rs.getCol(1)"
	xecute "set srec(""L"")=srec(""L"")_"",""_rs.getCol(2)"
	#end
	quit


BLDXFR	//
	/*
	This label is called from the scheduler init at runtime. It is used to
	compile a new program that reflects the most up to date columns in the tables
	DDPACNL and DDPACND. The new program is called from the thread exec section 
	of the batch to check and build the data that will be transferred to the client.
	It also builds the object that will be saved back into DDPACND or DDPACNL 
	as part of the processing.
	*/ 

	type String ARRAY()
	type String CMPERR,column,TYPE

	do ADD(.ARRAY,"XFRPGM")
	do ADD(.ARRAY, " // Built during execution of batch DDPACN")
	do ADD(.ARRAY," quit")
	do ADD(.ARRAY,"Public DEP(RecordDEP dep,RecordDDPACND ddpacnd,String XFRREC) //Deposits")
	do ADD(.ARRAY," set XFRREC=dep.cid")
	do ADD(.ARRAY," type Boolean change=0")

	// Deposits

	type ResultSet rs=Db.select("DI,TYP,CMP","DBTBL1D","%LIBS='SYSDEV' and FID='DDPACND' and CMP is NULL and DI <>'CID' and DI not like '""%'") 
	while rs.next() do {
		set column=rs.getCol("DI")
		set column=column.lowerCase()
		set TYPE=rs.getCol("TYP")
		if "N$DCL"[TYPE do ADD(.ARRAY," set XFRREC=XFRREC_"",""_dep."_column) if 1
		else  do ADDQ("dep",column,.ARRAY)
		do ADD(.ARRAY," if dep."_column_"'=ddpacnd."_column_" set ddpacnd."_column_"=dep."_column_",change=1")
		}
	do ADD(.ARRAY," quit change")

	// Loans
	
	do ADD(.ARRAY,"Public LN(RecordLN ln,RecordDDPACNL ddpacnl,String XFRREC) //Loans")
	do ADD(.ARRAY," set XFRREC=ln.cid")
	do ADD(.ARRAY," type Boolean change=0")
	
	type ResultSet rs2=Db.select("DI,TYP","DBTBL1D","%LIBS='SYSDEV' and FID='DDPACNL' and CMP is NULL and DI <>'CID' and DI not like '""%'") 
	while rs2.next() do {
     
		set column=rs2.getCol("DI")
		set column=column.lowerCase()
		set TYPE=rs2.getCol("TYP")
		if "N$DCL"[TYPE do ADD(.ARRAY," set XFRREC=XFRREC_"",""_ln."_column) I 1
		else  do ADDQ("ln",column,.ARRAY)
		do ADD(.ARRAY," if ln."_column_"'=ddpacnl."_column_" set ddpacnl."_column_"=ln."_column_",change=1")
		}
	do ADD(.ARRAY," quit change")
	D BUILDRTN^UCGM(.ARRAY,"XFRPGM",.CMPERR)
	quit


ADDQ(String table,String column,String ARRAY())	// Add quotes around a field that already has $c(44) or $c(34) in it. 

	new code
	set code="$S("_table_"."_column_"'[$C(34)&("_table_"."_column_"'[$C(44)):"_table_"."_column
	set code=code_",1:$C(34)_$$QUOTE^DBSTLOAD("_table_"."_column_")_$C(34))"
	do ADD(.ARRAY," set XFRREC=XFRREC_"",""_"_code)
	quit


ADD(String ARRAY(),
    String code)
	type Number i
	set i=ARRAY("").order(-1)+1
	set ARRAY(i)=code
	quit
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
	/*
	   Create "kill" files for accounts which have changed branch of
	   ownership.  Note that ^TMP(JOB) will only exist if the option
	   to transfer all accounts to all branches was NOT selected and
	   it is not a full refresh.
	*/

	type String cls,BRCD,GLOFILE,IO
	type Public Number %QN,ER,JOB=%ProcessID
	type Public String RM,trec()
	
	type DbSet ds=Db.selectDbSet("TMPRPT2","PID=:JOB")
	if 'ds.isEmpty() do {
		do GETQUE(.IO,.GLOFILE,.%QN) quit:ER	
		while ds.next() do {
			type RecordTMPRPT2 ddpacn=ds.getRecord()
			if BRCD'=ddpacn.key1 do {
				if 'IO.get().isNull() do {
					close IO	
					do XFR(BRCD,IO,"",%QN,.GLOFILE)
					set BRCD=ddpacn.key1
					}
				do GETQUE(.IO,.GLOFILE,.%QN) quit:ER
				use IO
				}

			if ddpacn.data'=cls do {
				if ddpacn.data="D" write trec("D")
				else  write trec("L")
				write !,"F,CID"
				set cls=ddpacn.data
				}
			write !,"D,T,",ddpacn.key2,!
			}
		if IO.get()'="" do {
			close IO
			do XFR(BRCD,IO,"",%QN,GLOFILE)
			}

		}
	// Clean up temp file
	do Db.delete("TMPRPT2","PID=:JOB")

	quit


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
