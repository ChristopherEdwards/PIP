LNEA		/*
	   DESC: escrow analysis

	---- Revision History -------------------------------------------------
	
	11/03/06 - SmithCD - CR 23917
		   Removed the initialization of STBL() from the INITREM 
		   section. Modified NEXTREM to use %CACHE() instead of STBL() 
		   only when RBMET is defined. Prevents record not found PSL 
		   error on stblrbmet. Modified INIT0 section to handle account
		   number not present in lnbil0, and LNTRS1 section to handle 
		   LNTRS1 record not present. Performed some minor cleanup.
	
	03/30/06 - Srinivar - CR 20188
		   .Modified the NEXTREM section to pass correct subscript
		    TYP instead of TRTYPE in the RAMT() array. This change
		    will update the TOTREM variable which is used for 
		    calculating escrow payment. Also modified to accept 
		    ECID as a parameter for the where clause 
		    instead of CID while selecting TYP from TRTYPE.
		   .Modified the INITREM section to replace the deprecated 
		    method Db.currval with Db.select using order by DESC clause
		    to prevent the Undefined Error JD.
		  	
	02/09/06 - SWARNALP - 18338
		   Modified EXEC section to load the data into the temporary 
		   table LNEAM whenever LNEAM array gets updated.  This will 
		   make the data available to reports and screens which uses 
		   the temporary table LNEAM.  Also declared variable BEGBAL 
		   as public to make the variable available in the procedure 
		   LNEASTM to use it in reports.
		   Modified the section INIT0 to accept ECID as a parameter
		   for the where clause instead of CID while selecting REMAMT 
                   from RAMT table.
		   
	
	11/25/05 - Srinivar - CR 16890
	           Modified the sections EXEC,EXEC1 to accept 
	           RecordLNAPCHGE as a parameter inorder to set the
	           value of lnapchge.ereq to ESCPMT variable.
	           Modified the NEXTREM,INITREM section to pass TYP 
		   instead of TRTYPE.
		   Modified the section LNTRS1 to quit with an
		   argument LNTRS1(TT,PAYID).
		   Moved line of code in PMT section, that quit if
		   the bill record did not contain an escrow account,
		   to the beginning of the for loop to prevent an 
		   undefined error.
	           Removed the conditional instantiation of LNBIL0 in
		   EXEC section. 
		   Modified the label PMT,VAL,EXEC as public.
		   Removed the public in section INTERIM.

	*/

	quit


public EXEC(RecordLN ln,RecordLNAPCHGE lnapchge,CID,ARRAY,ESC,FD,TD,CTL,DATA)

	/*
	Project/analyze one escrow account
	
	   ARGUMENTS:

	       . ln	Loan Object				/TYP=RecordLN/REQ/REF:RW				

	       . CID Loan account number			/TYP=N/REQ

	       . ARRAY   Array with analysis projection		/TYP=REFARRAY/NOREQ
	       . "ESC Payment|ESC Due|Running Balance|Desc"

	       . ESC     Escrow account (ESC1, ESC2...)		/TYP=T/NOREQ

	       . FD  From date					/TYP=D/REQ

	       . TD Thru date					/TYP=D/NOREQ

	       . CTL control variable				/TYP=N/NOREQ
	                 Position 1 - 0 - existing acct
	                              2 - modeling
	                          2 - 0 - calculate payment amount
	                              1 - use existing payment amount from LNBIL0
	                              2 - use payment amount from analysis

	       . DATA    escrow payment				/TYP=T/NOREQ

	*/
	
	type public Number BEGBAL
	type public RecordLNEAM lneam()

	type Boolean %NOLOCK
	type RecordLNBIL0 lnbil0
	
	set %NOLOCK=1
	set CTL=$G(CTL)
	if '$G(FD) set FD=%SystemDate
	if $G(CID)'="" do {
		set lnbil0=Db.getRecord("LNBIL0","CID=:CID",1)
		}
	set ELENUM=0
	if $G(CID),$G(ESC)="" for  set BIL0=$$ESCACT^BILFUNCS(.lnbil0,.ELENUM) quit:BIL0=""  do { quit
		new EA,ELE,PC
		do Db.delete("LNEAM")
		kill ARRAY,DATA
		set DATA="|||9999999999999"
		set ELE=$P(BIL0,$C(9),2)
		if $$TT^LNU(ELE)="ESC" do EXEC1(.ln,.lnapchge,.lnbil0)
		}
	do EXEC1(.ln,.lnapchge,.lnbil0)
	
	set LOOP=1
	set AJD=""
	
	for  set AJD=LNEAM(AJD).order() quit:AJD.isNull()  do {
		set lneam(LOOP)=Db.getRecord("LNEAM","JD=:AJD",1)
		set lneam(LOOP).pmt=LNEAM(AJD).piece("|",1)
		set lneam(LOOP).ramt=LNEAM(AJD).piece("|",2)
		set lneam(LOOP).bal=LNEAM(AJD).piece("|",3)
		set lneam(LOOP).desc=LNEAM(AJD).piece("|",4)
		do lneam(LOOP).save()
		set LOOP=LOOP+1
		}
		
	quit


EXEC1(RecordLN ln,RecordLNAPCHGE lnapchge,RecordLNBIL0 lnbil0)

	type public Number escpmt,CID
	type public String ESC
	type public Date DUEDATE
	type public Boolean ER
	
	if $G(ESC)="" set ESC="ESC1"

	new TOTREM 
	set TOTREM=0

	// existing account
	if '$E(CTL) do INIT0(.ln,.lnbil0)

	// modeling
	if $E(CTL)=2 do INIT2 if ER quit

	if '$E(CTL,2) set ESCPMT=$$^SCARND(TOTREM*ANAF/ESCAF,0,CID)
	if $E(CTL,2)=1 set ESCPMT=$P($$ELEFRE^LNU(CID,ESC),"|",4)
	if $E(CTL,2)=2 set ESCPMT=lnapchge.ereq

	if $G(%EXT)=2 do {
		set ESCPMT=PMT1
		set (EPMTDIF,EPMTNXT)=0
		type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
		if dep.recamt do {
			set EPMTDIF=PMT1-dep.curramt
			set EPMTNXT=EPMTDIF+dep.recamt
			}
		}

	set BEGBAL=BAL

	// set payment amounts into ARRAY

	set NJD=DUEDATE
	for  quit:NJD>TD  do { quit:ER
		if NJD'<FD set $P(ARRAY(NJD),"|",1)=$P($G(ARRAY(NJD)),"|",1)+ESCPMT
		set NJD=$$NJD^UFRE(NJD,FRE) quit:ER
		}

	// Calculate each month's balance and find lowest balance

	set (LBAL,JD,LOWBAL)=""
	for  set JD=$O(ARRAY(JD)) quit:JD=""  do {
		set LBAL=LBAL+ARRAY(JD)-$P(ARRAY(JD),"|",2)
		set $P(ARRAY(JD),"|",3)=LBAL
		if LBAL<LOWBAL set LOWBAL=LBAL
		}
	set AMT=$S(LOWBAL<0:-LOWBAL,1:0)

	// Find what the beginning balance should be

	set CALCBB=AMT+CUSH
	// actual low balance
	set LOWBAL=LOWBAL+BEGBAL

	// Find difference between real beginning balance and calculated beg bal

	set DIFF=BEGBAL-CALCBB
	set JD="" 
	set BAL=CALCBB
	for  set JD=$O(ARRAY(JD)) quit:JD=""  do {
		set BAL=BAL+ARRAY(JD)-$P(ARRAY(JD),"|",2)
		set $P(ARRAY(JD),"|",3)=BAL
		}
	set DATA=$G(DATA)
	set $P(DATA,"|",1)=$P(DATA,"|",1)+ESCPMT
	set $P(DATA,"|",2)=$P(DATA,"|",2)+CALCBB
	set $P(DATA,"|",3)=$P(DATA,"|",3)+BEGBAL
	set $P(DATA,"|",4)=LOWBAL
	// ending balance
	set $P(DATA,"|",5)=BAL
	set $P(DATA,"|",6)=$P(DATA,"|",6)+TOTREM
	set $P(DATA,"|",7)=$P(DATA,"|",7)+$G(CUSH)
	if $G(%EXT)=2 set $P(DATA,"|",8)=EPMTNXT
	else  set $P(DATA,"|",8)=0

	quit


INIT0(RecordLN ln,RecordLNBIL0 lnbil0)

	// Initialization for existing account

	type public String ESC
	type public Number CID
	type public Date DUEDATE
	type public Boolean ER

	new ANFRE,APCLD,APCND,I,RAMT

	// Escrow Analysis Pmt Change Next Date
	set APCND=ln.apcnd
	
	// Analysis Frequency
	set ANFRE=ln.anfre 
	if ANFRE="" set ANFRE="1YA"
		
	// Analysis Payment Change Last Date
	set APCLD=ln.apcld

	set ELENUM=0
	for  set EA=$$ESCACT^BILFUNCS(.lnbil0,.ELENUM) quit:EA=""  do {
		set ECID=$P(EA,$C(9),1)
		if ECID.isNull() quit

		type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
		if dep.stat=4 do Runtime.setErrMSG("LN",1003,"ESC")
		set BAL=dep.bal
		// If no deposits have been made, use initial deposit amount
		if 'BAL,'dep.tld set BAL=dep.clamo
		set AREF=dep.aref
		set ESCGRP=dep.esc

		if '$G(TD) set NJD=$$NJD^UFRE(FD,ANFRE) quit:ER  set TD=NJD-1
		// get annual factor
		if $$NJD^UFRE(%SystemDate,ANFRE,.ANAF) quit:ER
		set LOWAF=$$LOWREM(CID)


		// Must cover at least 1 year

		if $$NJD^UFRE(FD,"1YA")-1>TD quit:ER  set TD=$$NJD^UFRE(FD,"1YA")-1 quit:ER

		/*
		If lowest remittance annual factor is less than analysis annual
		factor, extend the analysis thru date to cover that remittance.
		Plus redefine analysis annual factor to the lowest remittance annual
		factor.
		*/

		if LOWAF<ANAF do {
			new FRE,HIT,N
			set FRE=ANFRE
			for I=1,2,3,4,5,6 if ANAF=I set FRE=(12/I)_"MA"
			if FRE="" do Runtime.setErrMSG("LN",1353)
			set N=$$^SCARND(ANAF/LOWAF,0,"","",0)
			set TD=FD 
			set ANAF=LOWAF
			for I=1:1:N set TD=$$NJD^UFRE(TD,FRE) quit:ER
			set TD=TD-1
			}

		// include interim payments
		set BAL=BAL+$$INTERIM(.lnbil0)

		// Load ARRAY with remittance amounts/dates
		type ResultSet rs=Db.select("DISTINCT TYP,SPF,SAF,REMND,CREMFRE,PAYID,RBMET","TRTYPE","CID=:ECID AND SPF=0 AND SAF=0")
		if rs.isEmpty() quit
		while rs.next() do {
			set TRTYPE=rs.getCol("TYP")
			// Reset JD if we'll miss a remittance
			new REMND
			set REMND=rs.getCol("REMND")
			set JD=%SystemDate-1
			if JD'<REMND set JD=REMND-1

			/*
			An interim remittance is a remittance amount that should
			have been made by the financial institution but for some
			reason has not been, whose next remittance date (REMND)
			is prior to projected escrow analysis starting date (FD).
			The balance (BAL) must be adjusted by subtracting out
			one interim remittance or multiple interim remittances.

			If remittance not defined for REMND and it's
			an interim remittance, adjust the balance by
			the previous amount.

			If remitttance is defined for REMND and it's
			an interim remittance, adjust the balance by
			that remittance amount.
			*/

			if JD<REMND,REMND<FD do {
				type public Number AMT
				new REMND1

				type ResultSet rs1=Db.select("REMAMT","RAMT","CID=:ECID and TYP=:TRTYPE and REMDT<=:REMND","REMDT DESC")
				while rs1.next() do {
					set AMT=""
					set AMT=rs1.getCol("REMAMT")
					set BAL=BAL-AMT
					}
	
				/*
				Check is done for multiple interim remittances
				and the balance (BAL) is adjusted accordingly.
				Determine the remittance frequency
				*/

				set RMTFRE=rs.getCol("CREMFRE")
				// PAYID
				set REC=rs.getCol("PAYID")
				if RMTFRE="" set RMTFRE=$P($$LNTRS1(REC,TRTYPE),"|",1)
				/*
				Determine next interim remittance date (REMND1)
				and adjust the balance (BAL).  Keep going until
				next interim remittance date has gone beyond the
				projected escrow analysis starting date (FD).
				If there is a new remittance amount defined for
				REMND1 in ^RAMT then reset AMT to the new amount.
				*/

				set REMND1=REMND
				for  set REMND1=$$NJD^UFRE(REMND1,RMTFRE) quit:ER!(REMND1'<FD)  do {
					if Db.isDefined("RAMT","CID=:ECID,TYP=:TRTYPE,REMDT=:REMND1") set AMT=rs1.getCol("REMAMT")
					set BAL=BAL-AMT
					}
				}

		type ResultSet rs2=Db.select("REMDT,REMAMT,ESTFLG","RAMT","CID=:ECID and TYP=:TRTYPE and REMDT>=:FD and REMDT<=:TD")
		while rs2.next() do {
				// Ignore date if it is before starting date (FD) or after ending date (TD)
				set JD=rs2.getCol("REMDT")
	
				// If this TRTYPE has a RBMET don't use current amount
				if rs.getCol("RBMET"),Db.prevKey("RAMT","CID=:ECID,TYP=:TRTYPE,REMDT=:JD") quit
				if rs2.getCol("ESTFLG")="E",Db.prevKey("RAMT","CID=:ECID,TYP=:TRTYPE,REMDT=:JD") quit
				set AMT=rs2.getCol("REMAMT")
				set TOTREM=TOTREM+AMT
				set DT=JD 
				if $P($G(ARRAY(JD)),"|",2) for DT=DT:.01 quit:'$P($G(ARRAY(DT)),"|",2)

				set $P(ARRAY(DT),"|",2)=$P($G(ARRAY(DT)),"|",2)+AMT
				set $P(ARRAY(DT),"|",4)=$$DESC(TRTYPE)
				set $P(ARRAY(DT),"|",5)=TRTYPE
				}
			}

		do NEXTREM(.dep)
	
		set (JD,TRTYPE)=""
		for  set TRTYPE=$O(RAMT(ECID,TRTYPE)) quit:TRTYPE=""  do {
			for  set JD=$O(RAMT(ECID,TRTYPE,JD)) quit:JD=""  do {
				// Ignore date if it is before starting date (FD) or after ending date (TD)
				if (JD<FD)!(JD>TD) quit
				set AMT=+RAMT(ECID,TRTYPE,JD)
				set TOTREM=TOTREM+AMT
				set DT=JD if $P($G(ARRAY(JD)),"|",2) do {
					for DT=DT:.01 quit:'$P($G(ARRAY(DT)),"|",2)
					}
				set $P(ARRAY(DT),"|",2)=$P($G(ARRAY(DT)),"|",2)+AMT
				set $P(ARRAY(DT),"|",4)=$$DESC(TRTYPE)
				set $P(ARRAY(DT),"|",5)=TRTYPE
				
				}
			}


		// Find payment frequency, due date and current payment amount
		set X=$$ELEFRE^LNU(AREF,ESCGRP)
		set FRE=$P(X,"|",1) 
		set DUEDATE=$P(X,"|",2)

		// Get annual factor of escrow payment
		set NJD=$$NJD^UFRE(%SystemDate,FRE,.ESCAF) quit:ER
		set LOWBAL=BAL

		// cushion amount
		set CUSH=""
				
		// cushion option
		set CUSH0=$$VAL(dep.cusho,ln.cusho)

		// option=0 - cushion is percentage of total annual remittance
		if 'CUSH0 set CUSH=$$^SCARND($$VAL(dep.cushf,ln.cushf)*TOTREM,0,CID)
	
		// option=1 - cushion is flat amount
		if CUSH0=1 set CUSH=$$VAL(dep.cusha,ln.cusha)
		}
	quit


INIT2	// Initialization for Modeling a Product type or Account
	
        type public Date DUEDATE	
	type public Boolean ER
	
	new SEQ

  	set ANAF=1
	set (LOWBAL,SEQ,TOTREM)=""

	// Clear out previously built entries

	set N=""
	for  set N=$O(LINE(N)) quit:N=""  if N#1 kill LINE(N)

	/*
	Populate LINE array with multiple entries using frequency
	LINE is the ESC Information.
	LINE="Amount|Date|Desc|Fre"
	*/

	set N=""
	for  set N=$O(LINE(N)) quit:N=""  do {
		if $P(LINE(N),"|",4)="" quit
		set NJD=$P(LINE(N),"|",2) 
		set FRE=$P(LINE(N),"|",4)
		for I=.0001:.0001 set NJD=$$NJD^UFRE(NJD,FRE) quit:ER  quit:NJD>TD  do {
			set LINE(N+I)=LINE(N) 
			set $P(LINE(N+I),"|",4)=""
			set $P(LINE(N+I),"|",2)=NJD
			}
		}

	for  set SEQ=$O(LINE(SEQ)) quit:SEQ=""  do {
		set X=LINE(SEQ)
		set JD=$P(X,"|",2) 
		if JD'<FD,JD'>TD do {
			set DT=JD
			if $P($G(ARRAY(JD)),"|",2) for DT=DT:.01 quit:'$P($G(ARRAY(DT)),"|",2)

			set $P(ARRAY(DT),"|",2)=$P($G(ARRAY(DT)),"|",2)+LINE(SEQ)
			set $P(ARRAY(DT),"|",4)=$P(LINE(SEQ),"|",3)
			set TOTREM=TOTREM+LINE(SEQ)
			}
		}

	/*
	Set DUEDATE:
	to NEXT payment date if using an account
	or to next date after FD if using a product type
	*/
	set FRE=ESCFRE
	if CID'="" do {
		new X
		set X=$$ELEFRE^LNU(CID,ESC)
		set DUEDATE=$P(X,"|",2)
		set AF=$P(X,"|",3)
		}
	if CID="" set DUEDATE=$$NJD^UFRE(FD-1,FRE,.AF) quit:ER
	set ESCAF=AF
	set BAL=0
	if CUSHF'="" set CUSH=$$^SCARND(TOTREM*CUSHF,0,CID)
	quit


public PMT(RecordLNBIL0 lnbil0,ESCGRP)

	type public Number AMT

	new ACT,ESCDATA

	set ELENUM=0
	for  set ESCDATA=$$ESCACT^BILFUNCS(.lnbil0,.ELENUM) quit:ESCDATA=""  do {
		set ACT=$P(ESCDATA,$C(9),1)
		type RecordDEP dep=Db.getRecord("DEP","CID=:ACT")
		set AMT=dep.curramt
		
		if $P(ESCDATA,$C(9),1)'=ESCGRP quit
		}
		
	quit AMT


public VAL(DEPVAL,LNVAL)	// return value from escrow account or loan

	/*
	INPUTS:
	 . DEPVAL	Deposit Column
	 . LNVAL	Loan Column   

	*/

	quit $S(DEPVAL'=0:DEPVAL,1:LNVAL)


INTERIM(RecordLNBIL0 lnbil0)	// interim payment amounts
	
	type public String ESC
	type public Boolean ER

	new AF,CNT,FRE,JD,NJD,PMTAMT,X
	
	set CNT=0
	set X=$$ELEFRE^LNU(AREF,ESC)
	set FRE=$P(X,"|",1) 
	set JD=$P(X,"|",2)
	for  quit:JD'<FD  set NJD=$$NJD^UFRE(JD,FRE) quit:ER  set CNT=CNT+1 set JD=NJD
	set PMTAMT=$$PMT(.lnbil0,ESC)
	
	quit CNT*PMTAMT



NEXTREM(RecordDEP dep)

	// Find next remittance for escrow types within analysis period

	if $E(CTL) quit
	
	type public Cache %CACHE()
	type public Boolean ER

	set TRTYPE=""

	type ResultSet rs=Db.select("TYP","TRTYPE","CID=:dep.cid")
	while rs.next() do {
		set TYP=rs.getCol("TYP")
		do INITREM(.dep)
		if SPF quit
		// remittance stopped
		if SAF quit
		// consider 1 remittance at a time
		set RAF=1
		set JD=LASTDT
		if JD>REMND set JD=REMND

		/*
		This will skip a remittance date for REMND if it has already been
		considered.
		*/
		if JD<REMND,REMND<FD,'Db.isDefined("RAMT","CID=:CID,TYP=:TYP,REMDT=:REMND") do { quit:ER
			set NJD=$$NJD^UFRE(JD,RMTFRE) quit:ER  
			set (JD,LASTDT)=NJD
			}
		new CTR,NEWRMT,SVREMND
		set CTR=0 
		set NEWRMT="" 
		set SVREMND=REMND
		for  set NJD=$$NJD^UFRE(JD,RMTFRE) quit:ER  quit:NJD>TD  do {
			set JD=NJD	 
			set REMND=NJD
			set CTR=CTR+1
			if CTR=1,REMND'=SVREMND set (REMND,NJD)=SVREMND
			if REMND<FD quit
			set RBAS=RAMTL
			if RBMET do {
				type RecordSTBLRBMET stblrbmet=%CACHE("STBLRBMET").getRecord("STBLRBMET","RBMET=:RBMET")
				#ACCEPT DATE=12/09/03;PGM=John Carroll
				xecute stblrbmet.remcalc
				set RBAS=$$^SCARND(RBAS,0,CID)
				if RBAS=0 set RBAS=RAMTL
				}
			set RAMTPR=RAMTL 
			set RAMTL=RBAS
			/*
			If ARRAY array is already defined for REMND, do not
			change it.  It holds new remittance amount (NEWRMT).
			This new remittance amount (NEWRMT) is then set into
			RAMT array for all remittance dates after that REMND.
			If NEWRMT is null, RBAS is used for the amount.
			*/
			if $D(ARRAY(REMND)),$P(ARRAY(REMND),"|",5)=TRTYPE set NEWRMT=$P(ARRAY(REMND),"|",2)
			else  set RAMT(ECID,TYP,REMND)=$S(NEWRMT:NEWRMT,1:RBAS)
			
			
			}
		
		}

	quit


INITREM(RecordDEP dep)

	// Initializion to calculate RBAS
	
	type public Boolean ER

	new JD,LNTRS1

	type RecordTRTYPE trtype=Db.getRecord("TRTYPE","CID=:ECID,TYP=:TYP")
	set ASMT=trtype.asmt
	set REC=trtype.payid

	set LNTRS1=$$LNTRS1(REC,TYP) 
	set RMTFRE=$S(trtype.cremfre:trtype.cremfre,1:$P(LNTRS1,"|",1))
	set MILL=$P(LNTRS1,"|",2)
	// % increase
	set RAMTP=trtype.ramtp
	// $ increase
	set RAMTD=trtype.ramtd
	set RBMET=trtype.rbmet
	set REMND=trtype.remnd
	set REMLD=trtype.remld
	set SPF=trtype.spf
	set SAF=trtype.saf
	
	set (RAMTL,RAMTPR)=""
	set (JD,PJD,PREC)=""

	type ResultSet rs=Db.select("REMDT,REMAMT","RAMT","CID=:ECID and TYP=:TYP and REMDT<=:FD","REMDT DESC")
	while rs.next() do { quit:RAMTL
		set RAMTL=rs.getCol("REMAMT")
		set LASTDT=rs.getCol("REMDT")
		if rs.getCol(1)=REMLD do {
			set PJD=Db.prevKey("RAMT","CID,TRTYPE,LASTDT")
			if PJD="" quit
			type RecordRAMT ramt=Db.getRecord("RAMT","CID=ECID,TYP=:TYP,REMDT=:PJD")
			set RAMTPR=ramt.remamt
			}
		}

	if 'RAMTL do {
	
		type ResultSet rs=Db.select("REMDT,REMAMT","RAMT","CID=:ECID AND TYP=:TYP","REMDT DESC")
		
		if rs.next() set JD=rs.getCol("REMDT")
		
		if JD do {
			type RecordRAMT ramt=Db.getRecord("RAMT","CID=ECID,TYP=:TYP,REMDT=:JD")
			set RAMTL=ramt.remamt
			set LASTDT=JD
			}
		}
	if 'RAMTPR set RAMTPR=RAMTL
	set NJD=$$NJD^UFRE(%SystemDate,RMTFRE,.RAF) quit:ER

	quit


DESC(TRTYPE)

	type String TT=$$TT^LNU(TRTYPE)

	type RecordLNTRS lntrs=Db.getRecord("LNTRS","TRTYPE=:TT")

	quit lntrs.trdes


LNTRS1(PAYID,TRTYPE)

	/*
	   Returns information from the payee level for an escrow transfer type.

	   Before calling LNTRS1 extrinsic, RMTFRE is set to TRTYPE.CREMFRE
	   (Borrower Remittance Frequency).  If RMTFRE is null, then RMTFRE has
	   to be set from LNTRS1.REMFRE (Remittance Frequency (Bank)).   MILL is
	   used in Remittance Basis Calc Method (RBMET) Processing for Method 1
	   (Base and Rate), which are found in system table RBMET.  MILL is set
	   from LNTRS1.MILL (Calculation Factor).    S RBAS=ASMT*MILL/1000*RAF

	*/

	type String TT=$$TT^LNU(TRTYPE)
	
	type RecordLNTRS1 lntrs1=Db.getRecord("LNTRS1","TRTYPE=:TT,PAYID=:PAYID",1)
	set LNTRS1(TT,PAYID)=lntrs1.remfre_"|"_lntrs1.mill
	
	quit LNTRS1(TT,PAYID)


LOWREM(LCID)

	// Return lowest annual factor of all escrow types for 1 mtg acct
	
	type public Boolean ER

	new AF,ECID,REC,RMTFRE,TRTYPE

	set AF=999
	set (ECID,TRTYPE)=""
	for  set ECID=$$NEXTECID^LNU(LCID,ECID) quit:ECID=""  do {
		type ResultSet rs=Db.select("SPF,SAF,CREMFRE,TYP,PAYID","TRTYPE","CID=:ECID")
		while rs.next() do {
			// self pay
			if rs.getCol(1) quit
			// stop analysis
			if rs.getCol(2) quit
			set RMTFRE=rs.getCol(3)
			set TRTYPE=rs.getCol(4)
			set REC=rs.getCol(5)			
			if RMTFRE="" set RMTFRE=$P($$LNTRS1(REC,TRTYPE),"|",1)
			if $$NJD^UFRE(%SystemDate,RMTFRE,.REMAF) quit:ER
			if REMAF<AF set AF=REMAF
			}
		}

	quit AF
 #OPTION ResultClass ON
Public String vSIG()	quit "60583^55495^Chad Smith^18181"	// Signature - LTD^TIME^USER^SIZE
