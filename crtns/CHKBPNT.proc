CHKBPNT	//;Batch Check Print Driver
	/*

	   INPUT:   Variable MULTINST defined indicates multiple institutions
	            and affects END section.  If multiple institutions, must
	            call CLOSE at end of run.

	   *NOTE* - The variable RF is being passed to the custom print routine.
	            This is used for repeating fields (2-up, 3-up, etc...).
	            When the custom print routine is called, it will have to
	            properly manage RF by incrementing by 1 for each check that
	            is set up, and setting RF to 0 after the checks are printed.

	  ---- Revision History -------------------------------------------------
	   
	   08/14/06 - KinI - 22447
	   	      Modified DTL, CID1, and PEND sections to remove SS 
	   	      variable from the processing.
	   
	   04/17/06 - PUTTASWH - CR19981
	   	      Modified EXT, EXEC and FIND sections to incorporate
	   	      the logic present in old M code to print check numbers.
	   	      Modified the entire procedure to handle check print for
	   	      the input date instead of System Date only.
	   		
	   11/04/05 - PUTTASWH - CR17011
	   	      Deleted the references to XCHKREG and XCHKEGSEQ tables
	   	      in the SETREG and FILE sections respectively.   	      
	
	The check print flow is as follows:

	1) After running @CHKBPNT function proving generic input info, the 
	system then prompts a user: “Are checks lined up?” with “Yes/No/Quit” 
	options (via TEST^CHKPTINI).

	2) If a user selects “No”, the system invokes the test check print 
	logic printing out the TEST check first (via indirect call to @CHKFMT
	in TEST^CHKPTINI).

	Here the values for the check are dummy and set in TEST^CHKPTINI 
	section. 

	3) After the test print, a user is prompted with “Are checks lined up?” 
	again and if selecting “Yes” this time, the actual check print is 
	executed (via PRINT^CHKBPNT logic). 
	
	Here the values for the check are set in CHKBPNT procedure.	
	*/

	new x
	do ^CHKPTINI

	if VFMQ="Q"!ER do CLOSE quit

EXT	// External entry point used if doing own init (e.g., FAS)
	
	type public Date PJD
	type public Number CID	

	if OFFSPNT.get().isNull() use IO

	type ResultSet rs=Db.select("CHKTYP,MF,SKEY,CKEY,SEQ","CHKSRT","TJD=:PJD AND CHKTYP=:CKTYP")
	if 'rs.isEmpty(),CID'="" do FIND(.rs) quit
	else  do SORT		// SORT section will build CHKSRT info  SPG
	do A1(.rs)
	quit
	
A1(ResultSet chkrs)	//	
	
	if chkrs.isEmpty() do END quit	
	do EXEC(.chkrs)		
	quit
	
EXEC(ResultSet rs)	//

	type public Date PJD
	type Boolean MFKEY,OMFKEY,PFLG
	type Number WH
	type String CKEY,OCKEY,OSKEY,SKEY
	new FOUND
	
	set PFLG=0	// Print Flag - Indicator for conditional check print 
	set (OCKEY,OSKEY,OMFKEY)=""
	
	while rs.next() do {
		set MFKEY=rs.getCol("MF")
		set SKEY=rs.getCol("SKEY")
		set CKEY=rs.getCol("CKEY")		
		set SEQ=rs.getCol("SEQ")				
		
		// Check for changes in the unique key combination for a particular 
		// SEQ. If the same changes, then print the check for the set of SEQ.
		if ((PFLG=1)&(OCKEY'=CKEY))!((PFLG=1)&(OCKEY=CKEY)&(OSKEY'=SKEY))!((PFLG=1)&(OCKEY=CKEY)&(OSKEY=SKEY)&(OMFKEY'=MFKEY)) do {
			kill VOID
			do DTL
			do PRINT			
			} 
	
		set PFLG=1	
		set OCKEY=CKEY
		set OSKEY=SKEY
		set OMFKEY=MFKEY
		
		kill TAMT,XPDO
        	set STAMT=0 
		for I=1:1:5 set AMT(I)=""
	
		type RecordXPDO xpdo=Db.getRecord("XPDO","TJD=:PJD,CKTYP=:CKTYP,CKSEQ=:SEQ")
	
		set BRCD=xpdo.brcd
		set UID=xpdo.uid
		set TRC=xpdo.trc
		set CID=xpdo.cid
		set SSEQ=SEQ
		set %EffectiveDate=xpdo.efd
		set:%EffectiveDate="" %EffectiveDate=%SystemDate
		set ADDR=xpdo.addr
		set CKNUM=CKNO

		set TAMT(SEQ)=xpdo.tamt
		set XPDO(SEQ)=""

		set STAMT=STAMT+TAMT(SEQ)
		for I=1:1:4 set AMT(I)=AMT(I)+TAMT(SEQ).piece("#",I)
	
		if (UID="")!(BRCD="")!(TRC="") quit

		set WH=0	
		
		type RecordTTX ttx=Db.getRecord("TTX","TJD=:PJD,BRCD=:BRCD,UID=:UID,TSEQ=:TRC-1",1)
		// Withholding
		if ttx.getMode() set WH=+(ttx.tamt.piece("#",5))			

		//Withholding
		set AMT(5)=AMT(5)+WH			
		}		
		
		// If only one unique key combination exists for the SEQ value, the same
		// will not be printed in the while loop hence it has to be printed next. 
		if (PFLG=1) do {		
			kill VOID
			do DTL
			do PRINT					
			} 
	do END
	
	quit


PRINT	//
	type public Date PJD
	type public Number GL
	
	set FOUND=0
	
	set CKAMT1=$$^SCARND(STAMT,0,CID,,,,1)
		
	for  do {  quit:FOUND=0
		
		set CKNO=CKNO+1
		set %CKNO=CKNO 
		set CKNUM=CKNO
		
		type RecordCHKREG1 chkreg1=Db.getRecord("CHKREG1","CO=:CO,GL=:GL,CKNO=:CKNO",1)
		if chkreg1.getMode() set FOUND=1	
		}	
	
	set N="" 
	for  set N=XPDO(N).order() quit:N=""  do {
		type RecordXPDO xpdo=Db.getRecord("XPDO","TJD=:PJD,CKTYP=:CKTYP,CKSEQ=:N",1)
		set xpdo.ckno=CKNO
		do xpdo.bypassSave()
		}
	
	//I18N=OFF
	if AUXPTR.exists(),AUXPTR write *27,"[5i"
	if '$G(OFFSPNT) do @CHKFMT if AUXPTR.exists(),AUXPTR write $C(27)_"[4i"_$C(17)
	//I18N=ON

	set TOTWHD=TOTWHD+AMT(5)
	set TOT=TOT+CKAMT1
	do FILE

	set CKNO=%ZCKNO
	set CKSTS=0
	quit


DTL	// If there is a name and address entered, use that.

	//Check if there is a name
	if ADDR.piece("^",3)'="" do CID1

	if 'CID quit

	type RecordACN acn=Db.getRecord("ACN","CID=:CID")
	set IYTD=acn.iytd
	set ACN=acn.acn

	if ADDR.piece("^",3)'="" quit

	if IRA do IRA quit

	set FOUND=0
	
	if PDO do { if FOUND do PDO quit
		if Db.isDefined("PDO","CID=:CID") set FOUND=1
		}

	do ^UTLADDR(,"NM",7,3,"ACN",CID)

	quit


CID1	// Put the alternate name and address on the check

	type Number I, X, Y
	type String XNM()

	// Get address information excluding Check memo field
	for I=1:1:6 set XNM(I)=ADDR.piece("^",I+2)

	// Initialize NM array
	for I=1:1:7 set NM(I)=""
	set X="" 
	set Y=1
	for  set X=XNM(X).order() quit:X=""  if XNM(X)'="" set NM(Y)=XNM(X),Y=Y+1

	quit


IRA	// IRA plan name and address

	new X,Y,Z
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	
	set Y=dep.rpaseq
	set X=dep.acn
	set Z=0

	type RecordIRATYPE iratype=Db.getRecord("IRATYPE","ACN=:X,RPASEQ=:Y")
	
	set X=iratype.name1_$C(9)_iratype.name2_$C(9)_iratype.ad1
	set X=X_$C(9)_iratype.ad2_$C(9)_iratype.ad3

	for I=1:1:5 do {
		set Y=X.piece($C(9),I) 
		if $L(Y) do {
 			set Z=Z+1 
			set NM(Z)=Y
			}
		}
	
	set Z=Z+1 
	set NM(Z)=iratype.city_", "_iratype.state_"  "_iratype.mzip_"  "_iratype.cntry

	set Z=Z+1 
	for I=Z:1:7 set NM(I)=""

	quit


PDO	// Third party name/address

	type RecordPDO pdo=Db.getRecord("PDO","CID=:CID")

	set AD=pdo.name_$C(9)_pdo.addr1_$C(9)_pdo.addr2_$C(9)_pdo.addr3

	set I=0 
	for J=1:1:4 do {
		if AD.piece($C(9),J)'="" do {
			set I=I+1 
			set NM(I)=AD.piece($C(9),J)
			}
		}
	
	set NM(I+1)=pdo.city_", "_pdo.state_"   "_pdo.mzip_"  "_pdo.cntry
	
	for J=I+2:1:7 set NM(J)=""

	quit


AECSET	//
	type public Date PJD
	
	for  set N=XPDO(N).order() quit:N=""  do {
		type RecordXPDO xpdo=Db.getRecord("XPDO","TJD=:PJD,CKTYP=:CKTYP,CKSEQ=:N")
		set CID=+xpdo.cid
		if 'CID quit

		type RecordACN acn=Db.getRecord("ACN","CID=:CID")
		set CLS=acn.cls

		if CLS="D" do {
			type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
			set dep.intchk=CKNO
			do dep.bypassSave()
			}
	
		/*  
		The original code was updating INTCHK for the LN file in the
		following section.  That column name does not exist in LN.  
		Changed the column being updated to DISBCHK.	    SPG
		*/
	
		if CLS="L" do {
			type RecordLN ln=Db.getRecord("LN","CID=:CID")
			set ln.disbchk=CKNO
			do ln.bypassSave()
			}
		}
	quit


END	//

	type public Number GL
	new FOUND
	set (CKSTS,STS)=2 	
	set TOTALS=1
	set %EffectiveDate=%SystemDate 
	set (BRCD,TRC,UID)=""
	
	for  do {  quit:FOUND=0
			
		set FOUND=0
		// Void remaining checks across (if any)
		if RF do {  
			set %CKNO=CKNO
			do @CHKFMT	
				
			type RecordCHKREG1 chkreg1=Db.getRecord("CHKREG1","CO=:CO,GL=:GL,CKNO=:CKNO",1)
			if chkreg1.getMode() do {
				set FOUND=1
				set (CKNO,CKNUM)=CKNO+1
				}
			
			}
		}
		
	if RF set END=CKNO for CKNO=%CKNO+1:1:END do SETREG		
	
	do PEND 
	
	quit	

PEND	// Print totals

	type public Date PJD
	type public Number GL
	
	type Number N
	type Boolean FOUND

	set STS=3 	
	
	for  do {  quit:FOUND=0
		
		set CKNO=CKNO+1		
		set %CKNO=CKNO 
		set CKNUM=CKNO
		set FOUND=0
	
		type RecordCHKREG1 chkreg1=Db.getRecord("CHKREG1","CO=:CO,GL=:GL,CKNO=:CKNO",1)
		if chkreg1.getMode() do {
			set FOUND=1
			set (CKNO,CKNUM)=CKNO+1
			}		
			
		}

	// I18N=OFF: Excluded from I18N Standards

	set (LNM,NM(1))="* * * T O T A L S * * *"
	for I=2:1:7 set NM(I)="* * * * * V O I D * * * * * "

	set (AMT,TAMT)=TOT
	set CKAMT1=TAMT.roundDec("","",0)
	set (CID,CKAMT,IYTD)=""

	//Total withholding amount
	set AMT(5)=TOTWHD
	if '(AUXPTR.get().isNull()),AUXPTR write *27,"[5i"
	if OFFSPNT.get().isNull() do @CHKFMT

	if '(AUXPTR.get().isNull()),AUXPTR write $C(27)_"[4i"_$C(17)

	// I18N=ON: Included to I18N Standards

	set END=CKNO for CKNO=%CKNO:1:END do SETREG

	// Print completion indicator
	
	type RecordXPDO1 xpdo1=Db.getRecord("XPDO1","TJD=:PJD,CKTYP=:CKTYP",1)
	set xpdo1.pntflg="***|"
	do xpdo1.bypassSave()

	// Don't continue if multiple institution printing
	quit:MULTINST.exists()
	
	do CLOSE
	
	quit


CLOSE	// Entry line tag for multiple institution printing to close device

	/*	  
	***If offsite printing, only update check number in UTBLCHKS, don't
	***process the rest of this section
	*/
	if OFFSPNT.get() do { quit
		type RecordUTBLCHKS utblchks=Db.getRecord("UTBLCHKS","CHKS=:CKTYP")
		set utblchks.nchkpnum=CKNO+1
		do utblchks.bypassSave() quit

		// Warning - checks printed past check load range
		if ER="W" set RM=$$^MSG(2958)
		}

	new ENDNUM
	if IO.get()="" quit
	
	type RecordCHKDEVP chkdevp=Db.getRecord("CHKDEVP","DEVICE=:IO")
	set chkdevp.begnum=CKNO+1
	do chkdevp.bypassSave()

	if CKNO>chkdevp.endnum set ER="W"

	// Warning - checks printed past check load range
	if ER="W" set RM=$$^MSG(2958)
	
	do CLOSE^SCAIO
	quit


ERR	// Log error in exception file

	if %TJD.get().isNull() set %TJD=%SystemDate
	
	type RecordDAYENDEXCR dayendexcr=Db.getRecord("DAYENDEXCR","TJD=:%TJD,RTN=:%RoutineName",1)
	if 'dayendexcr.getMode() do {
		set dayendexcr.tjd=%TJD
		set dayendexcr.rtn=%RoutineName
		// Anticipated Earnings Checks
		set dayendexcr.desc=$$^MSG(6842)
		do dayendexcr.bypassSave()
		}
	
	
	set N=Db.nextVal("DAYENDEXC","TJD=%TJD,RTN=:%RoutineName,SORT='*'")
	
	type RecordDAYENDEXC deexc=Db.getRecord("DAYENDEXC","TJD=%TJD,RTN=:%RoutineName,SORT='*',SEQ=:N",1)
	if 'deexc.getMode() do {
		set deexc.tjd=%TJD
		set deexc.rtn=%RoutineName
		set deexc.sort="*"
		set deexc.seq=N
		set deexc.recid=CID
		set deexc.et="RECLOC"
		// Account Not Processed
		set deexc.misc=$$^MSG(4116)
		set deexc.time=%CurrentTime
		do deexc.bypassSave()
		}

	use 0 set ER=1 set ET="CHKLOC" do DSPBP^UTLERR
	set ER=0 if 'OFFSITE use IO
	quit


SORT	// Create check sort file

	type public Date PJD
	new BRCD1,N,XPDO,XTJD
	set XTJD=PJD

	do Db.delete("CHKSRT","TJD=:XTJD AND CHKTYP=:CKTYP")

	// If PNTFLG is set then Anticipated check do no print

	type ResultSet rs=Db.select("BRCD,UID,TRC,CID,PNTFLG,CKSEQ","XPDO","TJD=:PJD AND CKTYP=:CKTYP AND (PNTFLG=0 OR PNTFLG IS NULL)")	
	while rs.next()  do {
		set XPDO=rs.getCol(1)_$C(9)_rs.getCol(2)_$C(9)_rs.getCol(3)
		set XPDO=XPDO_$C(9)_rs.getCol(4)_$C(9)_rs.getCol(5)
		set N=rs.getCol(6)		
		
		set CID=+rs.getCol(4)
	
		if 'CID set UID=XPDO.piece($C(9),2) do {
			set TSEQ=XPDO.piece($C(9),3)  
			set BRCD1=+XPDO
			type RecordTTX ttx=Db.getRecord("TTX","TJD=:PJD,BRCD=:BRCD1,UID=:UID,TSEQ=:TSEQ")
			set CID=ttx.cid
			}
	
		// Invalid or misc account
		if 'Db.isDefined("ACN","CID=:CID") do { quit
			set SKEY=1 
			set CKEY=N
			set MFKEY=1
			do NEWSRT
			}

		type RecordACN acn=Db.getRecord("ACN","CID=:CID")
		set CLS=acn.cls
	
		set MFKEY=CID_$C(9)_acn.mf

		set MFKEY=MFKEY.piece($C(9),2)
		set:MFKEY="" MFKEY=1

		// Not sorted or consolidated
		if 'SRTOPT,'CONCHK
	
		// Put primary CIF first, followed by other CIFs
		else  do {
			set RC=acn.acnrelc
			set PCIF=acn.acn
			set CKEY=PCIF_"*"
			type ResultSet rs=Db.select("ACN","RELCIF","CID=:CID AND (ACN>:PCIF OR ACN<:PCIF)")
			if 'rs.isEmpty() while rs.next() do {
				set RELACN=rs.getCol(1)
				set CKEY=CKEY_RELACN_"*"
				}
			}
		// Not sorted
		if 'SRTOPT set SKEY=1

		if CONCHK!(SRTOPT=2)

		if SRTOPT=2 do { quit
			type RecordACNADDR acnaddr=Db.getRecord("ACNADDR","CID=:CID")
			set SKEY=acnaddr.mzip
			set SKEY=SKEY.extract(1,5)
			do SETCKEY
			}

		if 'SRTOPT do SETCKEY quit
	
		set SKEY=PCIF if SRTOPT=3 do SETCKEY quit

		type RecordCIF cif=Db.getRecord("CIF","ACN=:SKEY")
		set SKEY=cif.lnm
		if SKEY="" set SKEY=" "
		do SETCKEY
				
		}
	quit

SETCKEY		//
	new RPASEQ

	// Not consolidated
	if 'CONCHK set CKEY=N do NEWSRT quit

	set CKEY=CKEY_RC
	
	if IRA do {
		type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
		set RPASEQ=dep.rpaseq
		set CKEY=CKEY_"*"_RPASEQ
		}

	do NEWSRT 
	quit

NEWSRT	 	//
	type public Date PJD
	
	type RecordCHKSRT chksrt=Db.getRecord("CHKSRT","TJD=:PJD,CHKTYP=:CKTYP,MF=:MFKEY,SKEY=:SKEY,CKEY=:CKEY,SEQ=:N",1)
	if 'chksrt.getMode() do {
		set chksrt.tjd=PJD
		set chksrt.chktyp=CKTYP
		set chksrt.mf=MFKEY
		set chksrt.skey=SKEY
		set chksrt.ckey=CKEY
		set chksrt.seq=N

		do chksrt.bypassSave()
		}
	quit

FIND(ResultSet rs)	// Locate start for process via CID number

	type public Date PJD
	type public Number CID
	new FOUND,SAVCKEY
	set FOUND=0
	set SAVCKEY=""

	// Account does not exist
	if rs.isEmpty() set ER=1 set RM=$$^MSG(57) quit
	
	while rs.next() do { quit:FOUND
		set MFKEY=rs.getCol("MF")
		set SKEY=rs.getCol("SKEY")
		set CKEY=rs.getCol("CKEY")
		set SEQ=rs.getCol("SEQ")
	
		type RecordXPDO xpdo=Db.getRecord("XPDO","TJD=:PJD,CKTYP=:CKTYP,CKSEQ=:SEQ")
		if CID=xpdo.cid do {		
			set FOUND=1
			set SAVCKEY=CKEY
			}			
		}

	if SAVCKEY'="" do {		
		type ResultSet chkrs=Db.select("MF,SKEY,CKEY,SEQ","CHKSRT","TJD=:PJD AND CHKTYP=:CKTYP AND MF=:MFKEY AND SKEY=:SKEY AND CKEY>=:SAVCKEY")
		if chkrs.isEmpty() quit
		do EXEC(.chkrs)
		}
	
	quit

FILE	// Original filing section moved to new line tag to support REPOST

	type public Date PJD
	new CMB
	set CMB=""
	if AEC set N="" do AECSET

	set N="" for  set N=XPDO(N).order() quit:N=""  set CMB=CMB+1
	set CMB=$S(CMB>1:1,1:"")

	type RecordXPDO1 xpdo1=Db.getRecord("XPDO1","TJD=:PJD,CKTYP=:CKTYP",1)
	if 'xpdo1.getMode() do {
		set xpdo1.tjd=PJD
		set xpdo1.cktyp=CKTYP
		set xpdo1.skey=SKEY
		set xpdo1.ckey=CKEY
		set xpdo1.pntflg=SSEQ
		set xpdo1.cid=CID.get()
		do xpdo1.bypassSave()
		}
	
	set %ZCKNO=CKNO set CKNO=%CKNO do SETREG	

	if CLS="L" do {
		type RecordLN ln=Db.getRecord("LN","CID=:CID")
		set ln.disbchk=CKNO
		do ln.bypassSave()
		if ER do ERR
		}

	if %ZCKNO=%CKNO quit

	for CKNO=%CKNO+1:1:%ZCKNO set CKSTS=$S($D(VOID(CKNO)):2,1:0) do SETREG

	quit


SETREG	// Update check register files

	type public Date PJD
	type public Number GL
	
	set CMB=CMB.get()
		
	type RecordCHKREG1 chkreg1=Db.getRecord("CHKREG1","CO=:CO,GL=:GL,CKNO=:CKNO",1)
	if 'chkreg1.getMode() do {
		set chkreg1.co=CO
		set chkreg1.gl=GL
		set chkreg1.ckno=CKNO
		set chkreg1.tjd=PJD
		set chkreg1.efd=%EffectiveDate
		set chkreg1.uid=UID
		set chkreg1.brcd=BRCD
		set chkreg1.trc=TRC
		set chkreg1.tamt=CKAMT1
		set chkreg1.cid=CID
		set chkreg1.payee=NM(1)
		set chkreg1.ctype=CKTYP
		set chkreg1.status=CKSTS
		set chkreg1.combined=CMB
		do chkreg1.bypassSave()
		}	

	quit

OFFSITE(Date %SystemDate,	// System Date	
	String CKTYP,		// Check Type
	Number CKNO,		// Check Number
	Number CID,		// Account Number
	Number GL,		// GL Account Number
	String CO,		// Company Name
	Number TAMT)		// Transaction amount
	
	new AEC,CKSTS,CONCHK,RF,SRTOPT,TOT,TOTWHD
	set CKSTS=0
	set AEC=0
	set TOTWHD=0
	set TOT=0
	set RF=0
	set SRTOPT=0
	set CONCHK=0
	do EXT

	quit

vSIG()	quit "60492^53213^Irina Kin^14929"	// Signature - LTD^TIME^USER^SIZE
