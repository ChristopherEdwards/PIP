LNAPFILE(RecordLNAP1 lnap1, String vpar, Boolean vparNorm) // LNAP1 - Loan Application File Filer
	// Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/30/2007 14:17 - joynerd
	// Generated from DATA-QWIK schema in: /profile/v72qa_gtmlx  by: /v72qa_gtmlx/crtns/DBSFILB.obj

	// Data Dictionary Data Items (47)             11/22/2003
	// Trigger Definition (9)                      12/17/2004
	// Journal File Definition (3)                 12/17/2004
	/*
		vpar      Runtime qualifiers:      /NOREQ/MECH=REFARR:R

		/[NO]CASDEL   - Cascade delete
		/[NO]FRMFILER - Called from another filer
		/[NO]INDEX    - Update Indexes
		/[NO]JOURNAL  - Journal update
		/[NO]TRIGAFT  - After update triggers
		/[NO]TRIGBEF  - Before update triggers
		/[NO]UPDATE   - Update primary table
		/[NO]VALDD    - Validate column values
		/[NO]VALFK    - Validate foreign keys
		/[NO]VALREQ   - Validate not null values
		/[NO]VALRI    - Validate transaction integrity
		/[NO]VALST    - Validate database state
	*/

	type public String verrors()

	type String vx(), vxins()                              // audit column array
	type Number %O = lnap1.getMode()                       // Processing mode
	set vpar = vpar.get()                                  // Initialize vpar

	if %O = 0 do AUDIT^UCUTILN(lnap1,.vxins(),10,"|")
	if %O = 1 quit:'lnap1.isChanged()  do AUDIT^UCUTILN(lnap1,.vx(),10,"|")

	if 'vparNorm.get() set vpar = $$initPar^UCUTILN(vpar)  // Run-time qualifiers

	// Define local variables for access keys for legacy triggers
	type String ACN = lnap1.acn
	type String APPS = lnap1.apps

	if %O = 0 do { quit                                    // Create record control block
		do vinit                                              // Initialize column values
		if vpar["/TRIGBEF/" do VBI                            // Before insert triggers
		if vpar["/VALREQ/" do vreqn                           // Check required
		if vpar["/VALDD/" do vddver                           // Check values
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 1 do { quit                                    // Update record control block
		if vx("ACN").exists()!vx("APPS").exists() do vkchged quit // Primary key changed
		if vpar["/TRIGBEF/" do VBU                            // Before update triggers
		if vpar["/VALREQ/" do vrequ                           // Check required
		if vpar["/VALDD/" do VDDUX^DBSFILER("LNAP1",.vx)
		set %O = 1 do vexec
		if vpar["/TRIGAFT/" do VAU                            // After update triggers
	}

	if %O = 2 do { quit                                    // Verify record control block
		if vpar["/VALREQ/" do vreqn                           // Check required
		set vpar = $$setPar^UCUTILN(vpar,"NOJOURNAL/NOUPDATE")
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 3 do { quit                                    // Delete record control block
		quit:'Db.isDefined("LNAP1","ACN = :lnap1.acn and APPS = :lnap1.apps") // No record exists
		do vdelete(0)
	}

	quit

vlegacy(Number %ProcessMode,String vpar) // Legacy interface (^DBSDF9 for %O=0, EXT^DBSFILER for %O = 2)

	type public String ACN
	type public String APPS

	type RecordLNAP1 lnap1 = Db.getRecord("LNAP1","ACN=:ACN,APPS=:APPS")
	if (%ProcessMode = 2) do {
		do lnap1.setMode(2)

		do LNAPFILE(lnap1,vpar)
	}

	quit

vLITCHK() quit 0 // Table does not have columns involved in literals


vexec // Execute transaction

	type public Number %O
	type public String vpar,vobj(),vx(),vxins()

	type public RecordLNAP1 lnap1

	type String vERRMSG

	if vpar["/VALST/" if '(''Db.isDefined("LNAP1","ACN = :lnap1.acn and APPS = :lnap1.apps") = ''%O) set vERRMSG = $$^MSG($select(%O:7932,1:2327)) throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	if vpar["/VALFK/" do CHKFKS                            // Check foreign keys
	if vpar["/VALRI/" do VFKEYS                            // Foreign key definition

	if vpar'["/NOUPDATE/" do {

		set lnap1.UID = %UserID
		if %O = 0  set lnap1.DTEN = %SystemDate
		if %O = 1  set lnap1.LUD = %SystemDate
		type String n = -1
		type String x

		if %O = 0 for  set n = vobj(lnap1,n).order() quit:n.isNull()  do {
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^LNAP(vobj(lnap1,-3),vobj(lnap1,-4),n)=vobj(lnap1,n)
			#ENDBYPASS
		}

		else  for  set n = vobj(lnap1,-100,n).order() quit:n.isNull()  do {
			quit:'$D(vobj(lnap1,n))
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^LNAP(vobj(lnap1,-3),vobj(lnap1,-4),n)=vobj(lnap1,n)
			#ENDBYPASS
		}


		if vpar["/JOURNAL/" do VJOURNAL(.lnap1)               // Create journal files
	}

	quit

vload // Record Load - force loading of unloaded data

	type public RecordLNAP1 lnap1
	type String n = ""

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	for  set n=$order(^LNAP(vobj(lnap1,-3),vobj(lnap1,-4),n)) quit:n=""  if '$D(vobj(lnap1,n)),$D(^LNAP(vobj(lnap1,-3),vobj(lnap1,-4),n))#2 set vobj(lnap1,n)=^(n)
	#ENDBYPASS
	quit

vdelete(Boolean vkeychg) // Record Delete

	type public String vobj(),vpar
	type public RecordLNAP1 lnap1

	if 'vkeychg.get(),lnap1.isChanged() throw Class.new("Error","%PSL-E-DBFILER,Deleted object cannot be modified")

	if vpar["/JOURNAL/" do VJOURNAL(.lnap1)                // Create journal entries

	// Allow global reference - Delete record
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^LNAP(vobj(lnap1,-3),vobj(lnap1,-4))
	#ENDBYPASS
	quit


vinit // Initialize default values

	type public RecordLNAP1 lnap1

	// Type local variables for access keys for defaults
	type public String ACN
	type public String APPS

	if lnap1.apprvd.isNull() set lnap1.apprvd = 0          // apprvd
	if lnap1.crted.isNull() set lnap1.crted = 0            // crted
	if lnap1.refflg.isNull() set lnap1.refflg = 0          // refflg
	if lnap1.rpiflg.isNull() set lnap1.rpiflg = 0          // rpiflg
	quit


vreqn // Validate required data items

	type public RecordLNAP1 lnap1

	if lnap1.applrelc.isNull() do vreqerr("APPLRELC") quit
	if lnap1.appnum.isNull() do vreqerr("APPNUM") quit
	if lnap1.apprlv.isNull() do vreqerr("APPRLV") quit
	if lnap1.apprvd.isNull() do vreqerr("APPRVD") quit
	if lnap1.boo.isNull() do vreqerr("BOO") quit
	if lnap1.crted.isNull() do vreqerr("CRTED") quit
	if lnap1.dtap.isNull() do vreqerr("DTAP") quit
	if lnap1.grp.isNull() do vreqerr("GRP") quit
	if lnap1.pfre.isNull() do vreqerr("PFRE") quit
	if lnap1.ptrm.isNull() do vreqerr("PTRM") quit
	if lnap1.refflg.isNull() do vreqerr("REFFLG") quit
	if lnap1.rpiflg.isNull() do vreqerr("RPIFLG") quit
	if lnap1.sts.isNull() do vreqerr("STS") quit
	if lnap1.type.isNull() do vreqerr("TYPE") quit
	quit

vrequ // Valid required columns on update


	type public String vx()
	type public RecordLNAP1 lnap1

	if lnap1.acn.isNull() do vreqerr("ACN") quit
	if lnap1.apps.isNull() do vreqerr("APPS") quit

	if 'vobj(lnap1,-100,1,"").order().isNull() do {
		if vx("DTAP").exists(),lnap1.dtap.isNull() do vreqerr("DTAP") quit
		if vx("STS").exists(),lnap1.sts.isNull() do vreqerr("STS") quit
		if vx("TYPE").exists(),lnap1.type.isNull() do vreqerr("TYPE") quit
	}
	if 'vobj(lnap1,-100,3,"").order().isNull() do {
		if vx("APPNUM").exists(),lnap1.appnum.isNull() do vreqerr("APPNUM") quit
		if vx("PTRM").exists(),lnap1.ptrm.isNull() do vreqerr("PTRM") quit
		if vx("PFRE").exists(),lnap1.pfre.isNull() do vreqerr("PFRE") quit
		if vx("REFFLG").exists(),lnap1.refflg.isNull() do vreqerr("REFFLG") quit
		if vx("APPRLV").exists(),lnap1.apprlv.isNull() do vreqerr("APPRLV") quit
		if vx("RPIFLG").exists(),lnap1.rpiflg.isNull() do vreqerr("RPIFLG") quit
		if vx("APPRVD").exists(),lnap1.apprvd.isNull() do vreqerr("APPRVD") quit
		if vx("CRTED").exists(),lnap1.crted.isNull() do vreqerr("CRTED") quit
		if vx("GRP").exists(),lnap1.grp.isNull() do vreqerr("GRP") quit
		if vx("APPLRELC").exists(),lnap1.applrelc.isNull() do vreqerr("APPLRELC") quit
		if vx("BOO").exists(),lnap1.boo.isNull() do vreqerr("BOO") quit
	}
		if vx("APPLRELC").exists(),lnap1.applrelc.isNull() do vreqerr("APPLRELC") quit
		if vx("APPNUM").exists(),lnap1.appnum.isNull() do vreqerr("APPNUM") quit
		if vx("APPRLV").exists(),lnap1.apprlv.isNull() do vreqerr("APPRLV") quit
		if vx("APPRVD").exists(),lnap1.apprvd.isNull() do vreqerr("APPRVD") quit
		if vx("BOO").exists(),lnap1.boo.isNull() do vreqerr("BOO") quit
		if vx("CRTED").exists(),lnap1.crted.isNull() do vreqerr("CRTED") quit
		if vx("DTAP").exists(),lnap1.dtap.isNull() do vreqerr("DTAP") quit
		if vx("GRP").exists(),lnap1.grp.isNull() do vreqerr("GRP") quit
		if vx("PFRE").exists(),lnap1.pfre.isNull() do vreqerr("PFRE") quit
		if vx("PTRM").exists(),lnap1.ptrm.isNull() do vreqerr("PTRM") quit
		if vx("REFFLG").exists(),lnap1.refflg.isNull() do vreqerr("REFFLG") quit
		if vx("RPIFLG").exists(),lnap1.rpiflg.isNull() do vreqerr("RPIFLG") quit
		if vx("STS").exists(),lnap1.sts.isNull() do vreqerr("STS") quit
		if vx("TYPE").exists(),lnap1.type.isNull() do vreqerr("TYPE") quit
	quit

vreqerr(di) // Required error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("LNAP1","MSG",1767,"LNAP1."_di)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit


VFKEYS // Foreign keys

	type public String vfkey(),vpar

	type public RecordLNAP1 lnap1
	if 'lnap1.acn.isNull() set vfkey("^CIF("_""""_lnap1.acn_""""_","_1_")")="LNAP1(ACN) -> CIF"
	quit

CHKFKS   // Check foreign keys when not under buffer


	type public RecordLNAP1 lnap1
	type public Number %O
	type String vERRMSG

	if 'Db.isDefined("CIF",":lnap1.acn") set vERRMSG = $$^MSG(8563,"LNAP1(ACN) -> CIF") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	quit


VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	if vx("").order().isNull() quit
	if vx("APPRLV").exists() do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DISBAMT").exists()!vx("APPRAMT").exists() do vau2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STS").exists() do vau3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordLNAP1 lnap1
	if vx("").order().isNull() do AUDIT^UCUTILN(lnap1,.vx(),10,"|") quit
	if vx("APPRAMT").exists() do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("APPRLV").exists() do vbu2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RPIRATE").exists()!vx("RCALCM").exists()!vx("PTRM").exists()!vx("PFRE").exists()!vx("AREQ").exists()!vx("TYPE").exists()!vx("REFCID").exists()!vx("REFFLG").exists()!vx("FPA").exists() do vbu3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STS").exists() do vbu4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(lnap1,.vx(),10,"|")
	quit


vai1 // Trigger AFTER_INSERT - After Insert Trigger

	type public RecordLNAP1 lnap1
	/* ******** LNAP1 --- AFTER_INSERT
	---- Revision History----------------------------------------------
	 07/17/00 - SKLYUTD - 40395
		    Added a check for the restricted product type.

	 04/18/00 - KESTELMANN - 38082
		 Rolled forward from v6.2           
	
	 11/29/99 - SKLYUTD - 33756
	-------------------------------------------------------------------
	*/
	new xr,XBOO,XTYPE
	set XBOO=lnap1.boo
	set XTYPE=lnap1.type
	if Db.isDefined("UTBLPRODAUTH","XBOO,XTYPE") do Runtime.setErrMSG("LN",2773,XTYPE) quit:ER

	new XAPPS,XACN,X
	set XAPPS=lnap1.apps
	set XACN=lnap1.acn
	do Db.update("CIF","APPS=:XAPPS","ACN=:XACN")
	quit

vau1 // Trigger AU_APPRLV - After Update of Required Approval Level

	type public RecordLNAP1 lnap1
	/* ---- Revision History------------------------------------------------
 	06/19/00 - SKLYUTD - 40658
		Created.  Do not allow change of APPRLV if approval flag is
		set on a status.
				----------------------------------------------------------------------*/

	new apprln,XSTS
	set XSTS=lnap1.sts.oldVal
	set apprln=Db.getOneRow("APPRLN","UTBLASTS","XSTS")
	//Change to column ~p1 not allowed
	if apprln=1 do Runtime.setErrMSG("LN",412,"LNAP1.APPRLV") quit:ER
	quit

vau2 // Trigger AU_DISB - After update DISBAMT,APPRAMT

	type public RecordLNAP1 lnap1
	/*-----------------Revision History--------------------------------
	05/04/04 - RussellDS - CR9172
		   Added parenthesis in TRN section to avoid PSL precedence
		   warning errors.
		   
	06/19/03 - CARROLLJ - 51349
		   Modified the TRN section to remove the use of the TR
		   array.
	
	-------------------------------------------------------------------
	*/

	// Verify that approved amount is at least = to refinanced balance.
	if lnap1.refbal>lnap1.appramt do Runtime.setErrMSG("LNAP1",4335) quit:ER
	
	new XSTS,XAPPRLV,ofldata,USER,XGRP,stsdata,XAPPNUM,XACN,XAPPS,apramt
	set XAPPRLV=lnap1.apprlv set XGRP=lnap1.grp set XAPPNUM=lnap1.appnum set XACN=lnap1.acn
	set USER=%UserID set XSTS=lnap1.sts set XAPPS=lnap1.apps set XERR=0

	// First verify that the user has enough authority to modify the status.
	set ofldata=Db.getOneRow("APPRLV,LNDLIM,UNSLIM,OVRLIMU,SECLIM,OVRLIMS,BALPLUS","UTBLOFILIM","USER,XGRP") quit:ER

	// Oficer Approval level
	set OFLV=$P(ofldata,$C(9),1) 
	set stsdata=Db.getOneRow("APPRLV,APPRLN,CRTLN","UTBLASTS","XSTS") quit:ER

	// Status approval level
	set STSLV=$P(stsdata,$C(9),1)
	
	// Not authorized.  Requires approval level of ~p1 or above.
	if OFLV<STSLV do Runtime.setErrMSG("LNAP1",4095,STSLV) quit:ER

	// Now that the approval level for the status is meet,
	// check to see if this staus is an 'approve' or 'approve and create'.
	new APPRLN,CRTLN
	set APPRLN=$P(stsdata,$C(9),2) set CRTLN=$P(stsdata,$C(9),3)
	if APPRLN="" set APPRLN=0
	if CRTLN="" set CRTLN=0
	set apramt=lnap1.appramt
	if (APPRLN)&(lnap1.disbamt>lnap1.appramt) do Runtime.setErrMSG("LNAP1",4337) quit:ER

	
	// All of the 'approval level' checks are in the past. Check the lending limits
	// for the user.
	new LNDLIM,UNSLIM,OVRLIMU,SECLIM,OVRLIMS,BALPLUS
	set LNDLIM=$P(ofldata,$C(9),2)

	// Lending limit - based on the entries in UTBLNDLIM
	// 1 - Between officer's lower and upper limits
	if LNDLIM=1 do { quit:ER

		// Unsecured lending limit
		set UNSLIM=$P(ofldata,$C(9),3)
		// Unsecured Override Limit
		set OVRLIMU=$P(ofldata,$C(9),4)
		// Secured lending limit
		set SECLIM=$P(ofldata,$C(9),5)
		// Secured Override limit
		set OVRLIMS=$P(ofldata,$C(9),6)
		// Check for the collateral on this applicaton
		// need to figure out with of the above values to use.
		new col
	
		do { quit:ER

			new rs
			type ResultSet rs=Db.select("COLL","LNAP1COL","ACN=:XACN AND APPS=:XAPPS AND APPNUM=:XAPPNUM")
			set col="" if 'rs.next()  quit
			set col=rs.getRow()
			}     
	
		// Yep, we do have collateral.  This is a secured loan.
		if col do { quit:ER

			// Amount requested is above officer's lending limit.
			if (apramt>SECLIM)&(apramt'>OVRLIMS) do Runtime.setErrXBAD("LNAP1","LNDLIM") quit:ER
			// Amount requested is above officer's override lending limit.
			if apramt>OVRLIMS do Runtime.setErrMSG("LNAP1",4100) quit:ER
			}
		// We got ourselfs an unsecured loan
		else  do { quit:ER

			// Amount requested is above officer's lending limit.
			if (apramt>UNSLIM)&(apramt'>OVRLIMU) do Runtime.setErrXBAD("LNAP1","LNDLIM") quit:ER
			// Amount requested is above officer's override lending limit.
			if apramt>OVRLIMU do Runtime.setErrMSG("LNAP1",4100) quit:ER
			}
		// Good so far
		}

	// Member's deposits balance + officer's allowance
	if LNDLIM=2 do { quit:ER

		set BALPLUS=$P(ofldata,$C(9),7)
		new cifbal,data,vcnt
		set cifbal=0
		new rs
		type ResultSet rs=Db.select("BAL","DEP","ACN=:XACN") quit:ER

		if 'rs.isEmpty() while rs.next() set data=rs.getRow()  do {
			set cifbal=cifbal+$P(data,$C(9),1)
			}
	
		set cifbal=cifbal+BALPLUS
		// Amount requested is above officer's lending limit
		if apramt>cifbal do Runtime.setErrMSG("LNAP1",4379) quit:ER
		}

	// Good so far.
	// Member's historical largest loan balance
	if LNDLIM=3 do { quit:ER

		new maxbval
		set maxbal=Db.getOneRow("PMAXBAL","CIF","XACN") quit:ER
		// Amount requested is above officer's lending limit.
		if apramt>maxbal do Runtime.setErrMSG("LNAP1",4379) quit:ER
		}
	
	// Adjust GL entries if approved ammount changes after the initial approval.
	if (lnap1.appramt.oldVal'=lnap1.appramt)&(lnap1.apprvd=1) D TRN(.lnap1) Q:ER
	quit
	//----------------------------------------------------------------------
TRN(RecordLNAP1 lnap1)
	//----------------------------------------------------------------------

	type Public Cache %CACHE()

	new CC,TAMT,TCMT,TR,CRCD,SEQ,BCRCD,AMT
	new ITC,TSO,BRCD,LGPUB,LGPLB,par,GLSC,TYPE,par
	set TYPE=lnap1.type
	set GLSC=Db.getOneRow("GLSC","PRODDFTL","TYPE")
	set CC=Db.getOneRow("CC","CIF","XACN")
	type RecordTTX ttx=Class.new("RecordTTX")

	set gl=Db.getOneRow("LGPUB,LGPLB","UTBLGLSC","GLSC")
	set LGPUB=$P(gl,$C(9),1)
	set LGPLB=$P(gl,$C(9),2)
	set TSO=""
	set TCMT=""
	set BRCD=lnap1.boo
	if lnap1.appramt.oldVal="" set TAMT=lnap1.appramt-lnap1.areq
	else  set TAMT=lnap1.appramt-lnap1.appramt.oldVal
	if 'TAMT Q
	if TAMT<0 set ETC1="MDR",ETC2="MCR"
	else  set ETC1="MCR",ETC2="MDR"
	// Primary --------------------------
	if TAMT<0 set TAMT=TAMT*(-1)
	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC1")
	set ITC=trn.itc
	set ttx.cid=LGPUB
	set ttx.itc=ITC
	set ttx.etc=ETC1
	set ttx.tamt=TAMT
	set ttx.tlo=%UserStation
	set ttx.tso=TSO
	set ttx.tcmt=TCMT
	set ttx.cdt=%CurrentDate
	set ttx.tim=%CurrentTime
	set ttx.crcd=lnap1.crcd
	set ttx.uidt=%UserID
	set ttx.cc=CC
	do TRNSINGL^TRNDRV(.ttx,,%SystemDate,BRCD,4)

	//  Offset ---------------------------
	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC2")
	set ITC=trn.itc
	set ttx.cid=LGPLB
	set ttx.etc=ETC2
	set ttx.itc=ITC
	do TRNSINGL^TRNDRV(.ttx,,%SystemDate,BRCD,4)

	quit

vau3 // Trigger AU_STS - After Update of Application Status

	type public RecordLNAP1 lnap1
	/*---- Revision History-----------------------------------------------
	   06/19/03 - CARROLLJ - 51349
		      Modified the BUILDTR section to remove the use of the TR
		      array.
	
	 --------------------------------------------------------------------
	*/

	// First verify that the user has enough authority to modify the status.
	new XSTS,XAPPRLV,ofldata,USER,XGRP,stsdata,XAPPNUM,XACN,XAPPS,apramt,XERR
	set XAPPRLV=lnap1.apprlv set XGRP=lnap1.grp set XAPPNUM=lnap1.appnum set XACN=lnap1.acn
	set USER=%UserID set XSTS=lnap1.sts set XAPPS=lnap1.apps set XERR=0 
	set ofldata=Db.getOneRow("APPRLV,LNDLIM,UNSLIM,OVRLIMU,SECLIM,OVRLIMS,BALPLUS","UTBLOFILIM","USER,XGRP") quit:ER

	// Oficer Approval level
	set OFLV=$P(ofldata,$C(9),1) 
	set stsdata=Db.getOneRow("APPRLV,APPRLN,CRTLN","UTBLASTS","XSTS") quit:ER

	// Status approval level
	set STSLV=$P(stsdata,$C(9),1)
	
	// Not authorized.  Requires approval level of ~p1 or above.
	if OFLV<STSLV do Runtime.setErrMSG("LNAP1",4095,STSLV) quit:ER
	// Now that the approval level for the status is meet,
	// check to see if this staus is an 'approve' or 'approve and create'.
	new APPRLN,CRTLN,xboo
	set APPRLN=$P(stsdata,$C(9),2) set CRTLN=$P(stsdata,$C(9),3)
	if APPRLN="" set APPRLN=0
	if CRTLN="" set CRTLN=0
	set apramt=lnap1.appramt
	set xboo=lnap1.boo
	// The status is for tha aproval - but the users approval level is less than
	// a required approval level for te application.
	// Not authorized.  Requires approval level of ~p1 or above.
	if (APPRLN=1)&(XAPPRLV>OFLV) do Runtime.setErrMSG("LNAP1",4095,XAPPRLV) quit:ER        // DS 12/21/99
	
	// All of the 'approval level' checks are in the past. Check the lending limits
	// for the user.  Only do this if approval flag is set on the status and the
	// application is not approved as of yet.
	if APPRLN=1,lnap1.apprvd'=1 do { quit:ER

		new LNDLIM,UNSLIM,OVRLIMU,SECLIM,OVRLIMS,BALPLUS
 		set LNDLIM=$P(ofldata,$C(9),2)
		// Lending limit - based on the entries in UTBLNDLIM
		// 1 - Between officer's lower and upper limits
		if LNDLIM=1 do { quit:ER

			// Unsecured lending limit
			set UNSLIM=$P(ofldata,$C(9),3)
			// Unsecured Override Limit
			set OVRLIMU=$P(ofldata,$C(9),4)
			// Secured lending limit
			set SECLIM=$P(ofldata,$C(9),5)
			// Secured Override limit
			set OVRLIMS=$P(ofldata,$C(9),6)
			// Check for the collateral on this applicaton
			// need to figure out with of the above values to use.
			new col

			do { quit:ER

				new rs
				type ResultSet rs=Db.select("COLL","LNAP1COL","ACN=:XACN AND APPS=:XAPPS AND APPNUM=:XAPPNUM")
				set col="" if 'rs.next()  quit
				set col=rs.getRow()
				}
	
			// Yep, we do have collateral.  This is a secured loan.
			if col do { quit:ER

				// Amount requested is above officer's lending limit.
				if (apramt>SECLIM)&(apramt'>OVRLIMS) do {

					set XERR=1
					do Runtime.setErrXBAD("LNAP1","LNDLIM") quit:ER
					}

				// Amount requested is above officer's override lending limit.
				if apramt>OVRLIMS do Runtime.setErrMSG("LNAP1",4100) quit:ER
				}

			// We got ourselfs an unsecured loan
			else  do { quit:ER

				// Amount requested is above officer's lending limit.
				if (apramt>UNSLIM)&(apramt'>OVRLIMU) do {

					set XERR=1
					do Runtime.setErrXBAD("LNAP1","LNDLIM") quit:ER
					}
				// Amount requested is above officer's override lending limit.
				if apramt>OVRLIMU do Runtime.setErrMSG("LNAP1",4100) quit:ER
				}
			// Good so far
			}

		// Member's deposits balance + officer's allowance
		if LNDLIM=2 do { quit:ER

			set BALPLUS=$P(ofldata,$C(9),7)
			new cifbal,data,vcnt
			set cifbal=0
			new rs
			type ResultSet rs=Db.select("BAL","DEP","ACN=:XACN") quit:ER

			if 'rs.isEmpty() while rs.next() set data=rs.getRow()  do {
				set cifbal=cifbal+$P(data,$C(9),1)
				}
			set cifbal=cifbal+BALPLUS

			// Amount requested is above officer's override lending limit
			if apramt>cifbal do Runtime.setErrMSG("LNAP1",4100) quit:ER
			}

		// Good so far.
		// Member's historical largest loan balance
		if LNDLIM=3 do { quit:ER

			new maxbval
			set maxbal=Db.getOneRow("PMAXBAL","CIF","XACN") quit:ER
			// Amount requested is above officer's override lending limit.
			if apramt>maxbal do Runtime.setErrMSG("LNAP1",4100) quit:ER
			}
		}

	// Done checking the lending limits.  Lets get on with our life
	// Update contingent/pending liability GLs.
	// First lets get g/l set code for the product.
	new XTYPE,GLSC,LGPUB,LGPLB,XIAM
	set XTYPE=lnap1.type
	new XDATA,XARUF
	set XDATA=Db.getOneRow("GLSC,ARUF,IAM","PRODDFTL","XTYPE") quit:ER
	set GLSC=$P(XDATA,$C(9),1) set XARUF=$P(XDATA,$C(9),2) set XIAM=$P(XDATA,$C(9),3)
	// Now lets get the account numbers.
	new gl,mode
	set mode=3
	set gl=Db.getOneRow("LGPUB,LGPLB","UTBLGLSC","GLSC") quit:ER
	set LGPUB=$P(gl,$C(9),1) set LGPLB=$P(gl,$C(9),2)
	// G/Ls are not set get out.
	if (LGPUB="")!(LGPLB="") do Runtime.setErrMSG("LNAP1",1364) quit:ER
	
	// Now we have to figure out what we are doing
	// 1 - Approval:
	//      Credit to LGPUB (pending undisbursed)
	//      Debit to LGPLB (pending Ledger)
	// 2 - Rejection of already approved application:
	//      Debit to LGPUB (pending undisbursed)
	//      Credit to LGPLB (pending Ledger)
	// 3 - Just a status change that carries none of the
	//     above mentioned caracteristics:
	//       (No need to post any transactions)
	
	if lnap1.apprvd'=1,APPRLN=1 set mode=1
	if lnap1.apprvd=1,APPRLN=0 set mode=2
	
	if mode'=3 do BUILDTR(mode,.lnap1) quit:ER
	// Set the approved flag
	set ER=0 do Db.update("LNAP1","APPRVD=:APPRLN","ACN=:XACN AND APPS=:XAPPS") quit:ER
	
	// Check if the create flag is set.  To create the loan both approved and
	// create flags must be set.
	if lnap1.crted=1 quit                  // already created - avoid double dipping

	if (APPRLN=1)&(CRTLN=1) do { quit:ER
		new cmode,data,errmess
		// New loan

		if lnap1.refcid="" do { quit:ER

			new TYPE set TYPE=XTYPE
			// Get account number
			do ^UCIDSCA quit:ER
			set cmode=0
			}

		// Refinnance an existing one.
		else  set cmode=1 set CID=lnap1.refcid

		//The following values must be defined
		set data("TYPE")=lnap1.type
		set data("ACN")=lnap1.acn
		set data("BOO")=lnap1.boo
		set data("CRCD")=lnap1.crcd
		set data("TRM")=lnap1.ptrm
		set data("CID")=CID
		set (data("AMTREQ"),data("CRLMT"))=lnap1.appramt-lnap1.rpireb
		if lnap1.refflg=1 do {
			new lndata,change
			set lndata=Db.getOneRow("AMTREQ,CRLMT","LN","CID")
			set change=lnap1.appramt-(lnap1.refbal+lnap1.rpireb)
			set data("AMTREQ")=$p(lndata,$C(9),1)+change
			set data("CRLMT")=$p(lndata,$C(9),2)+change
		}
		set data("DIST1FRE")=lnap1.pfre

		if lnap1.rpiflg=1 do {
			new XPCMVAL
	
			do { quit:ER

				new rs
				type ResultSet rs=Db.select("PCMP","STBLPCM,LN","LN.PCM=STBLPCM.KEY AND LN.CID=:CID")
				if cmode=1 set XPCMVAL="" if 'rs.next()  quit
				if cmode=1 set XPCMVAL=rs.getRow()
				}
	 
			do { quit:ER

				new rs
				type ResultSet rs=Db.select("PCMP","STBLPCM,PRODDFTL","PRODDFTL.PCM=STBLPCM.KEY AND PRODDFTL.TYPE=:XTYPE")
				if cmode=0 set XPCMVAL="" if 'rs.next()  quit
				if cmode=0 set XPCMVAL=rs.getRow()
				}
	
			// Customer chose RPI - fixed principal amount should reflect this.
			if $E(XPCMVAL,3)=3 set data("FPA")=lnap1.paywrpi
			set (data("PMTPI"),data("PMT"))=lnap1.paywrpi
			}   

		else  set (data("PMTPI"),data("PMT"))=lnap1.payworpi set data("FPA")=lnap1.fpa

		set errmess=""                       // ds 37740
		do start^APPLDEF(XACN,XAPPS,XAPPNUM,CID,.data,cmode)
		if ER do Runtime.setErrMSG("LNAP1",3333,errmess) quit:ER

		do BUILDTR(2,.lnap1) quit:ER

		// Get the promisory number from UTBLNCID (top level only)
		new PERNO,APRAMT,XAPPNUM
		set XAPPNUM=lnap1.appnum

		// Set Created Flag too
		set PERNO=Db.getOneRow("NNUM","UTBLNCIDT","'PRN'") quit:ER
		set ER=0 do Db.update("LNAP1","PERNO=:PERNO,CRTED=1","ACN=:ACN AND APPS=:XAPPS") quit:ER
		if cmode=1 set ER=0 do Db.update("LN","REFFLG=1,PERNO=:PERNO","CID=:CID") quit:ER
		else  set ER=0 do Db.update("LN","PERNO=:PERNO","CID=:CID") quit:ER
		set PERNO=PERNO+1
		set ER=0 do Db.update("UTBLNCIDT","NNUM=:PERNO","TYPE='PRN'") quit:ER
		if XERR=1 do Runtime.setErrXBAD("LNAP1","LNDLIM") quit:ER
		}	// end of the if (APPRLN=1)&(CRTLN=1)
	
	quit

	//-------------------------------------------------------------
BUILDTR(mode,RecordLNAP1 lnap1)   //
	/*
																This section will be used to build and post the transaction.
										-------------------------------------------------------------
											Based on the mode (see explanation above. Search for mode) post a
											transaction to 'pending liability' Gls
	*/
	
	type Public Cache %CACHE()

	new CC,TAMT,TCMT,TR,CRCD,SEQ,BCRCD,AMT,ITC,TSO,BRCD,ETC1,ETC2,par
	set CC=Db.getOneRow("CC","CIF","XACN")
	type RecordTTX ttx=Class.new("RecordTTX")
	set TSO="" set TCMT="" set BRCD=xboo set TAMT=apramt
	if lnap1.refflg=1 set TAMT=lnap1.addamt
	if mode=1 set ETC1="MCR" set ETC2="MDR"
	if mode=2 set ETC1="MDR" set ETC2="MCR"

	// Primary --------------------------
	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC1")
	set ITC=trn.itc
	set ttx.cid=LGPUB
	set ttx.itc=ITC
	set ttx.etc=ETC
	set ttx.tamt=TAMT
	set ttx.efd=""
	set ttx.tlo=%UserStation
	set ttx.tso=TSO
	set ttx.tcmt=TCMT
	set ttx.CDT=%CurrentDate
	set ttx.tim=%CurrentTime
	set ttx.crcd=lnap1.crcd
	set ttx.uidt=%UserID
	set ttx.cc=CC
	do TRNSINGL^TRNDRV(.ttx,,%SystemDate,BRCD,4)

	//  Offset ---------------------------
	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC2")
	set ITC=trn.itc
	set ttx.cid=LGPLB
	set ttx.itc=ITC
	set ttx.etc=ETC2
	do TRNSINGL^TRNDRV(.ttx,,%SystemDate,BRCD,4)
	
	quit

vbi1 // Trigger BEFORE_INSERT - Before Insert Trigger

	type public RecordLNAP1 lnap1
	/* ---- RevisionHistory--------------------------------------------------------
	   12/30/03 - CARROLLJ - CR7658
		      Added #ACCEPT prior to xecute command.

	   05/19/00 - SKLYUTD - 40029
			Added defaulting of User Id into OFAC field.

	   05/06/00 - SKLYUTD - 39559
			Added rounding of the LNAP1.FPA.  Without the rounding
			user was getting "...field length exceeded" error.

	// 04/18/00 - KESTELMANN - 38082
	//       Rolled forward from v6.2

	// 04/06/00 - SKLYUTD - 36841:015
	//       Subtract RPIREB from AMTREQ to properly calculate payment amounts
	//       for refinanced loans.
	
	// 03/29/00 - KESTELMANN - 37771
	//	Add new restriction, if frequency combination does not
	//	exist in the UTBLINSPC.
	
	// 03/02/00 - SKLYUTD - 36841:04
	//	Changed code to calculate payment amounts.
	
	// 02/04/00 - KESTELMANN - 33756:33
	//	Modified setting of the BASE.  It should be equal LNAP1.AREQ.
	//	(Before it was LNAP1.AREQ+LNAP1.ADDAMT.)
	
	// 12/13/99 - SKLYUTD - 33756:05
	//       Modified seting of XDIST1FRE variable.  Must be equal to
	//       LNAP1.PFRE for PAYWRPI calculation.
	//       Fixed tabing problems...

	// 11/29/99 - SKLYUTD - 33756
	//---------------------------------------------------------------------
	*/
	// Default SystemCurrency if not defined.
	if lnap1.crcd="" set lnap1.crcd=%SystemCurrency
	// In this trigger:
	// 1) Check the status.
	// First Check the status. Must not be approved/create
	new XSTS,datasts
	set XSTS=lnap1.sts
	set datasts=Db.getOneRow("APPRLN","UTBLASTS","XSTS") quit:ER
	if datasts=1 do Runtime.setErrMSG("LNAP1",1471) quit:ER

	set lnap1.ofac=%UserID		// ds 05/19/00
 	
	// Second - bunch of stuff:
	// 1) Check the REFFLG (Refinnace flag)
	//      If set, check that the REFCID and REFBAL are defined.
	//      Grab RPIPREM of the LN for REFCID.
	//      Calculate the rebate on that premium.
	// 2) Calculate RPIPREM for the applicaton (AREQ as a basis).
	//      If the RPIRATE is not defined - grab it of the UTBLINSPC
	//      Based on PCM (product OR loan if REFLG is set), TERM and PFRE.
	// 3) Calculate Payment amounts with and without RPI.
	
	new BASE,DATA,LNDATA,XAOPT,XIAM,XCNTCR,XREFBAL,XREFCID,XRPIPREM,XRPIREB,XRPIRATE,XPTRM
	new XPFRE,XCRCD,XDFP,XPCMVAL,XDIST1FRE,XBUSOPT,XNBDC,XONP,XAMODT
	
	if lnap1.refflg=1 do { quit:ER

		if lnap1.refcid="" do Runtime.setErrMSG("LNAP1",1767,"LNAP1.REFCID") quit:ER          // Column can not be null
		if lnap1.refbal="" do Runtime.setErrMSG("LNAP1",1767,"LNAP1.REFBAL") quit:ER          // Column can not be null
		set XREFCID=lnap1.refcid
		set DATA=Db.getOneRow("CID,BAL,RPIPREM,ONP,CNTCR,RPIRATE,DIST1FRE,PCM,PTRM,TRM","LN","XREFCID")
		if DATA="" do Runtime.setErrMSG("LNAP1",1259,XREFCID) quit:ER         // Invalid account
		set XREFBAL=$P(DATA,$C(9),2)
		set XRPIPREM=$P(DATA,$C(9),3) set XONP=$P(DATA,$C(9),4)
		set XCNTCR=$P(DATA,$C(9),5) set XRPIRATE=$P(DATA,$C(9),6)
		set XPFRE=$P(DATA,$C(9),7) set XPTRM=$P(DATA,$C(9),9)
		if XPTRM="" set XPTRM=$P(DATA,$C(9),10)

		// If rate does not exist, get RPIRATE from UTBLINSPC
		if XRPIRATE="" do { quit:ER

			new XPCM set XPCM=$P(DATA,$C(9),8)
			set XRPIRATE=Db.getOneRow("INRATE","UTBLINSPC","XPCM,XPTRM,XPFRE") quit:ER
			// ARQ 37771 
			//  RPI rate is not defined for PCM, Term and Payment Frequency
			if XRPIRATE="" do Runtime.setErrXBAD("LNAP1","INVRPIRT") quit:ER
			}

		// Get premium from the LN, if does not exist, quit.
		// Recalculate rebate for this premium
		// Reset all fields for calculation rebate
		new AOB,AOC,AOT,AOTD,AO,AOI,CID,CALC,AF,FRE,NEG,NJD,MET,LT
		set CID=XREFCID set AOI=XRPIRATE set CALC=1 set NEG=0
		set AOC=XCNTCR set AOT=XONP set AOTD=0 set AO=XRPIPREM
		set AOB=AO-AOTD set FRE=XPFRE
		if AO<0 set NEG=1 set AO=-AO
		set NJD=$$NJD^UFRE(%SystemDate,XPFRE,.AF) quit:ER
		set MET=lnap1.rcalcm
		if MET="" do Runtime.setErrMSG("LNAP1",1767,"LNAP1.RCALCM") quit:ER   // Invalid calc method
	
		new PGM,X,XECUTE
		set PGM=$$GET^UBCHID("BCHLNAMOAO") if PGM="" quit
		set X="^"_PGM_""
		set X=""""_X_""""
		set XECUTE="S LT=MET_"_X_""
		#ACCEPT DATE=12/30/03;PGM=John Carroll
		xecute XECUTE
		if AOC>AOT set AOC=AOT
		do @LT quit:ER
		set XRPIREB=%AMT                      // Rebate amount
		set lnap1.rpireb=XRPIREB
		}

	// If REFFLG is "N" verify that REFCID,REFBAL,ADDAMT fields are nulled out
	else  set lnap1.refcid="" set lnap1.refbal=""
	
	// Calculate RPIPREM and payment amounts.
	new DATA,XPCM,XIAM,XPFRE,XBUSOPT,XNBDC,XTYPE,XPTRM,XRPIRATE,XRPIPREM,XIRN
	new XRFLFLG,LNREF,XREFCID,XDFP,XPCMVAL,XCRCD,XDFP,X1STPTDT,XMDT
	set XTYPE=lnap1.type set XPTRM=lnap1.ptrm set XPFRE=lnap1.pfre
	set XREFFLG=lnap1.refflg set XREFCID=lnap1.refcid

	// Calculate RPI premium
	set XRPIRATE=lnap1.rpirate
	
	if XREFCID'="" set XPCM=Db.getOneRow("PCM","LN","XREFCID") quit:ER
	else  set XPCM=Db.getOneRow("PCM","PRODDFTL","XTYPE") quit:ER
	
	// If RPI rate is not defined on the application
	// get it from UTBLINSPC table
	if XRPIRATE="" do { quit:ER

		set XRPIRATE=Db.getOneRow("INRATE","UTBLINSPC","XPCM,XPTRM,XPFRE")
		// ARQ 37771
		//  RPI rate is not defined for PCM, Term and Payment Frequency
		if XRPIRATE="" do Runtime.setErrXBAD("LNAP1","INVRPIRT") quit:ER
		}

	// RPI premium
	set XRPIPREM=$$^SCARND((((lnap1.areq-lnap1.rpireb)*XRPIRATE)/100),0,,,2) set lnap1.rpiprem=XRPIPREM
	
	// Calculate Payment Amounts.
	new ln,defualts,idix,dft,stop
	set stop=0

	// Need two goes at it: 1 for paywrpi other for payworpi.
	for idix=1:1:2 do { quit:(ER)!(stop=1)

		new ln
		set ln("TYPE")=lnap1.type
		set ln("ACN")=lnap1.acn
		set ln("DIST1FRE")=lnap1.pfre
		set ln("TRM")=lnap1.ptrm
		if idix=1 set (ln("AMTREQ"),ln("CRLMT"))=lnap1.areq-lnap1.rpireb
		if idix=2 set (ln("AMTREQ"),ln("CRLMT"))=(lnap1.areq-lnap1.rpireb)+lnap1.rpiprem
		set ln("BOO")=lnap1.boo
		set ln("CRCD")=lnap1.crcd
		if 'lnap1.refflg set ln("CID")=9999999999     // Treat as a loan modeler.
		else  set ln("CID")=lnap1.refcid
		set ln("FPA")=lnap1.fpa
		do calc^APPLDEF(.ln,3) quit:ER        // Get initial Default values
		if idix=2 set lnap1.paywrpi=ln("PMTPI")
		if idix=1 set lnap1.payworpi=ln("PMTPI")

		// If this products is a fixed principal only payment and FPA is set
		// calculate payment amounts in a different manner.
		new XPCMVAL,XPCM
		set XPCM=ln("PCM") set XPCMVAL=Db.getOneRow("PCMP","STBLPCM","XPCM") quit:ER
		if (lnap1.fpa)&($E(XPCMVAL,3)=3) do {

			set stop=1
			set lnap1.payworpi=lnap1.fpa
			set lnap1.paywrpi=$$^SCARND(lnap1.fpa+(lnap1.rpiprem/ln("ONP")),0,,,2)
			}
		}

	quit
	/* References to other routines
	
											APPLDEF    (calc)         - Procedure APPLNDEF - Loan Application to New Loan Defaults
											SCARND                    - Standard SCA rounding utility
											UBCHID     (GET)          -  Program name/Batch id linkage utility
											UFRE       (NJD)          - Frequency Utility
	*/
	quit

vbu1 // Trigger BU_APPRAMT - Before Update APPRAMT

	type public RecordLNAP1 lnap1
	do lnap1.setAuditFlag(1)
	/* ------Rivision History--------------------------------------
											05/06/00 - SKLYUTD - 39559
		Added rounding of the LNAP1.FPA.  Without the rounding
		user was getting "...field length exceeded" error.
	//
	// 04/18/00 - KESTELMANN - 38082	
	//       Rolled forward from v6.2
	
	// 04/06/00 - SKLYUTD - 36841:015
	//       Subtract RPIREB from APPRAMT to properly calculate payment amounts
	//       for refinanced loans.
	
	// 03/08/00 - SKLYUTD - 36841:004
	//  Recalculate Payment amounts if approval amount is different
	//  from amount requested.
	//------------------------------------------------------------
	*/
	// Only do this if status is approved.
	new XSTS,datasts
	set XSTS=lnap1.sts
	set datasts=Db.getOneRow("APPRLN,CRTLN","UTBLASTS","XSTS") quit:ER
	if $P(datasts,$C(9),1)'=1 quit
	
	// Calculate RPIPREM and payment amounts.
	new DATA,XPCM,XIAM,XPFRE,XBUSOPT,XNBDC,XTYPE,XPTRM,XRPIRATE,XRPIPREM,XIRN
	new XRFLFLG,LNREF,XREFCID,XDFP,XPCMVAL,XCRCD,XDFP,X1STPTDT,XMDT
	set XTYPE=lnap1.type set XPTRM=lnap1.ptrm set XPFRE=lnap1.pfre
	set XREFFLG=lnap1.refflg set XREFCID=lnap1.refcid

	// Calculate RPI preMIUM
	set XRPIRATE=lnap1.rpirate

	// If RPI rate is not defined on the application
	// get it from UTBLINSPC table
	if XRPIRATE="" do { quit:ER

		if XREFCID'="" set XPCM=Db.getOneRow("PCM","LN","XREFCID") quit:ER
		else  set XPCM=Db.getOneRow("PCM","PRODDFTL","XTYPE") quit:ER
		set XRPIRATE=Db.getOneRow("INRATE","UTBLINSPC","XPCM,XPTRM,XPFRE")
		}
	
	new BASE                               // Calculation Base
	set BASE=lnap1.appramt-lnap1.rpireb

	// RPI premium
	set XRPIPREM=$$^SCARND(((BASE*XRPIRATE)/100),0,,,2) set lnap1.rpiprem=XRPIPREM
	new ln,defualts,idix,dft,stop
	set stop=0

	// Need two goes at it: 1 for paywrpi other for payworpi.
	for idix=1:1:2 do { quit:(ER)!(stop=1)

		new ln
		set ln("TYPE")=lnap1.type
		set ln("ACN")=lnap1.acn
		set ln("DIST1FRE")=lnap1.pfre
		set ln("TRM")=lnap1.ptrm
		set ln("FPA")=lnap1.fpa
		if idix=1 set (ln("AMTREQ"),ln("CRLMT"))=lnap1.appramt-lnap1.rpireb
		if idix=2 set (ln("AMTREQ"),ln("CRLMT"))=(lnap1.appramt-lnap1.rpireb)+lnap1.rpiprem
		set ln("BOO")=lnap1.boo
		set ln("CRCD")=lnap1.crcd
		if 'lnap1.refflg set ln("CID")=9999999999     // Treat as a loan modeler.
		else  set ln("CID")=lnap1.refcid
		do calc^APPLDEF(.ln,3) quit:ER        // Get initial Default values
		if idix=2 set lnap1.paywrpi=ln("PMTPI")
		if idix=1 set lnap1.payworpi=ln("PMTPI")

		// If this products is a fixed principal only payment and FPA is set
		// calculate payment amounts in a different manner.
		new XPCMVAL,XPCM
		set XPCM=ln("PCM") set XPCMVAL=Db.getOneRow("PCMP","STBLPCM","XPCM") quit:ER
		if lnap1.fpa,$E(XPCMVAL,3)=3 do {

			set stop=1
			set lnap1.payworpi=lnap1.fpa
			set lnap1.paywrpi=$$^SCARND(lnap1.fpa+(lnap1.rpiprem/ln("ONP")),0,,,2)
			}
		}

	quit
	/* References to other routines
	
											APPLDEF    (calc)         - Procedure APPLNDEF - Loan Application to New Loan Defaults
											SCARND                    - Standard SCA rounding utility
	*/
	quit

vbu2 // Trigger BU_APPRLV - Before Update - Required Approval Level

	type public RecordLNAP1 lnap1
	do lnap1.setAuditFlag(1)
	//---- Revision History------------------------------------------------
	//

	// 04/18/00 - KESTELMANN - 39082 (as per ARQ 39367.)
	//	This trigger was commented according to the client request.
	//	Approval level on the application should not be protected.
	//	It should be manage manually.

	// 04/18/00 - KESTELMANN - 38082
	//	Rolled forward from v6.2.

	// 11/29/99 - SKLYUTD - 33756
	//---------------------------------------------------------------------
	// No change to LNAP1.APPRLV can be made once it is set.
	// Change to column ~p1 not allowed
	// do Runtime.setErrMSG("LNAP1",412,"LNAP1.APPRLV") quit:ER
	// quit
	quit

vbu3 // Trigger BU_REFFLG - Before Update of term,freq,amount,rate

	type public RecordLNAP1 lnap1
	do lnap1.setAuditFlag(1)
	/* ---- Revision History-----------------------------------------------

	01/06/04 - CARROLLJ - CR7658
		   Added #ACCEPT prior to xecute command.

	07/17/00 - SKLYUTD - 40395
		   Added a check for restricted product type

	05/15/00 - SKLYUTD - 39995
		Modifications made to properly select the base for calculating
		RPI premium and payment amounts.  RPI premium/payment amounts 
		should use AREQ as a base for pending loan application, 
		and APPRAMT for approved once.

	05/06/00 - SKLYUTD - 39559
		Added rounding of the LNAP1.FPA.  Without the rounding
		user was getting "...field length exceeded" error.  Also added
		FPA to the list of update columns.

	04/18/00 - KESTELMANN - 38082
	       Rolled forward from v6.2

	04/06/00 - SKLYUTD - 36841:015
	       Subtract RPIREB from AMTREQ to properly calculate payment and
	       insurance premium amounts for refinanced loans.

	03/29/00 - KESTELMANN - 37771
		Add new restriction, if frequency combination does not
		exist in the UTBLINSPC.
	
	03/08/00 - SKLYUTD - 36841:004
		Modifications to properly recalculate payment, rpiprem and
		rpirebate amounts.
	
	02/04/00 - KESTELMANN - 36841
		Modified setting of the BASE.  It should be equal LNAP1.AREQ.
		(Before it was LNAP1.AREQ+LNAP1.ADDAMT.)
	
	11/29/99 - KESTELMANN - 33756
	--------------------------------------------------------------
	*/
	// Restricted Product Type Check
	new xr,XBOO,XTYPE
	set XBOO=lnap1.boo
	set XTYPE=lnap1.type
	// Type ~p1 restricted
	if Db.isDefined("UTBLPRODAUTH","XBOO,XTYPE") do Runtime.setErrMSG("LN",2773,XTYPE) quit:ER

	// Recalculate RPI rebate if there was a change to:
	// 1) RPICALCM and 2) REFCID
	if (lnap1.refflg=1)&(((lnap1.rcalcm.oldVal'=lnap1.rcalcm))!((lnap1.refcid.oldVal'=lnap1.refcid))) do { quit:ER

		if lnap1.refcid="" do Runtime.setErrMSG("LNAP1",1767,"LNAP1.REFCID") quit:ER          // Column can not be null
		if lnap1.refbal="" do Runtime.setErrMSG("LNAP1",1767,"LNAP1.REFBAL") quit:ER          // Column can not be null
		set XREFCID=lnap1.refcid
		set DATA=Db.getOneRow("CID,BAL,RPIPREM,ONP,CNTCR,RPIRATE,DIST1FRE,PCM,PTRM","LN","XREFCID")
		if DATA="" do Runtime.setErrMSG("LNAP1",1259,XREFCID) quit:ER         // Invalid account 
		set XRPIPREM=$P(DATA,$C(9),3) set XONP=$P(DATA,$C(9),4)
		set XCNTCR=$P(DATA,$C(9),5) set XRPIRATE=$P(DATA,$C(9),6)
		set XPFRE=$P(DATA,$C(9),7) set XPTRM=$P(DATA,$C(9),9)
		set XBAL=$P(DATA,$C(9),2)

		// If rate does not exist, get RPIRATE from UTBLINSPC
		if XRPIRATE="" do { quit:ER

			new XPCM set XPCM=$P(DATA,$C(9),8)
			set XRPIRATE=Db.getOneRow("INRATE","UTBLINSPC","XPCM,XPTRM,XPFRE") quit:ER
			// ARQ 37771
			//  RPI rate is not defined for PCM, Term and Payment Frequency
			if XRPIRATE="" do Runtime.setErrXBAD("LNAP1","INVRPIRT") quit:ER
			}
		// Get premium from the LN, if does not exist, quit.
		// Recalculate rebate for this premium
		new AOB,AOC,AOT,AOTD,AO,AOI,CID,CALC,AF,FRE,NEG,NJD,MET,LT
		set CID=XREFCID set AOI=XRPIRATE set CALC=1 set NEG=0
		set AOC=XCNTCR set AOT=XONP set AOTD=0 set AO=XRPIPREM
		set AOB=AO-AOTD set FRE=XPFRE
		if AO<0 set NEG=1 set AO=-AO
		set NJD=$$NJD^UFRE(%SystemDate,XPFRE,.AF) quit:ER
		set MET=lnap1.rcalcm
		if MET="" do Runtime.setErrMSG("LNAP1",1767,"LNAP1.RCALCM") quit:ER   // Invalid calc method
	
		new PGM,X,XECUTE
		set PGM=$$GET^UBCHID("BCHLNAMOAO") if PGM="" quit
		set X="^"_PGM_""
		set X=""""_X_""""
		set XECUTE="S LT=MET_"_X_""
		#ACCEPT DATE=12/30/03;PGM=John Carroll
		xecute XECUTE
		if AOC>AOT set AOC=AOT
		do @LT quit:ER
		set XRPIREB=%AMT                      // Rebate amount
		set lnap1.rpireb=XRPIREB
		}
	// Recalculate RPI premium amount.
	new XPCM,XPFRE,XTYPE,XPTRM,XRPIRATE,XRFLFLG,XREFCID
	set XTYPE=lnap1.type set XPTRM=lnap1.ptrm set XPFRE=lnap1.pfre
	set XREFFLG=lnap1.refflg set XREFCID=lnap1.refcid

	// Calculate RPI premium
	set XRPIRATE=lnap1.rpirate

	// If RPI rate is not defined on the application
	// get it from UTBLINSPC table
	if XRPIRATE="" do { quit:ER

		if XREFCID'="" set XPCM=Db.getOneRow("PCM","LN","XREFCID") quit:ER
		else  set XPCM=Db.getOneRow("PCM","PRODDFTL","XTYPE") quit:ER
		set XRPIRATE=Db.getOneRow("INRATE","UTBLINSPC","XPCM,XPTRM,XPFRE") quit:ER
		// ARQ 37771
		//  RPI rate is not defined for PCM, Term and Payment Frequency.
		if XRPIRATE="" do Runtime.setErrXBAD("LNAP1","INVRPIRT") quit:ER
		if XRPIRATE="" set XRPIRATE=0
		}

	new apprvd,XSTS,BASE,XRPIPREM
	set XSTS=lnap1.sts
	set apprvd=Db.getOneRow("APPRLN","UTBLASTS","XSTS")
	if (lnap1.apprvd)!(apprvd) set BASE=lnap1.appramt
	else  set BASE=lnap1.areq
	set BASE=BASE-lnap1.rpireb
	set XRPIPREM=$$^SCARND(((BASE*XRPIRATE)/100),0,,,2) if XRPIPREM'=lnap1.rpiprem set lnap1.rpiprem=XRPIPREM

	// Recalculate Payment Amounts
	new ln,defualts,idix,dft,stop

	// Need two goes at it: 1 for paywrpi other for payworpi.
	set stop=0
	for idix=1:1:2 do { quit:(ER)!(stop=1)

		new ln
		set ln("TYPE")=lnap1.type
		set ln("ACN")=lnap1.acn
		set ln("DIST1FRE")=lnap1.pfre
		set ln("TRM")=lnap1.ptrm
		set ln("FPA")=lnap1.fpa
		if idix=1 set (ln("AMTREQ"),ln("CRLMT"))=BASE
		if idix=2 set (ln("AMTREQ"),ln("CRLMT"))=BASE+lnap1.rpiprem
		set ln("BOO")=lnap1.boo
		set ln("CRCD")=lnap1.crcd
		if lnap1.refflg=0 set ln("CID")=9999999999    // Treat as a loan modeler.
		else  set ln("CID")=lnap1.refcid
		do calc^APPLDEF(.ln,3) quit:ER        // Get initial Default values
		if idix=2 set lnap1.paywrpi=ln("PMTPI")
		if idix=1 set lnap1.payworpi=ln("PMTPI")

		// If this products is a fixed principal only payment and FPA is set
		// calculate payment amounts in a different manner.
		new XPCMVAL,XPCM
		set XPCM=ln("PCM") set XPCMVAL=Db.getOneRow("PCMP","STBLPCM","XPCM") quit:ER

		if lnap1.fpa,$E(XPCMVAL,3)=3 do {

			set stop=1
			set lnap1.payworpi=lnap1.fpa
			set lnap1.paywrpi=$$^SCARND(lnap1.fpa+(lnap1.rpiprem/ln("ONP")),0,,,2)
			}
		}
	
	quit
	/* References to other routines
	
											APPLDEF    (calc)         - Procedure APPLNDEF - Loan Application to New Loan Defaults
											SCARND                    - Standard SCA rounding utility
											UBCHID     (GET)          -  Program name/Batch id linkage utility
											UFRE       (NJD)          - Frequency Utility
	*/
	quit

vbu4 // Trigger BU_STS - Before Update Loan Application Status

	type public RecordLNAP1 lnap1
	do lnap1.setAuditFlag(1)
	/* ---- Revision History----------------------------------------------
	07/11/00 - SKLYUTD - 41011
		   Modified a statuses check to be logical 'or' not logical 'and'.
		   Fixes a problem where disbursement amount was considered
		   for status that are not "create".

	   05/19/00 - SKLYUTD - 40029
			Added defaulting of UserId into OFAC field.
	// 04/18/00 - KESTELMANN - 38082
	//       Rolled forward from v6.2

	// 03/09/00 - SKLYUTD - 36841:004
	//       Rewrote the trigger to only calculate RPIPREM in case when
	//       disbursement amount is different from approved amount.
	
	// 02/04/00 - KESTELMANN - 36841
	//            Modified setting of the BASE.  It should be equal LNAP1.AREQ.
	//            (Before it was LNAP1.AREQ+LNAP1.ADDAMT.)

	// 11/29/99 - SKLYUTD - 33756
	
	// This trigger will be used to recalculate the RPIPREM in case where
	// amount approved (APPRAMT) <> disbursement amount (DISBAMT)
 	//-------------------------------------------------------------------
 	*/
	set lnap1.ofac=%UserID
	// This calculation is only done when status is aproved/create and
	// disbursement amount is different from approved amount.
	if (lnap1.disbamt)&(lnap1.disbamt'=lnap1.appramt) do { quit:ER

		// Check the status.
		new stsdata,XSTS
		set XSTS=lnap1.sts
		set stsdata=Db.getOneRow("APPRLV,APPRLN,CRTLN","UTBLASTS","XSTS") quit:ER
		if ('$P(stsdata,$C(9),2))!('$P(stsdata,$C(9),3)) quit	// DS 07/11/00
	
		new XPCM,XPFRE,XTYPE,XPTRM,XRPIRATE,XRFLFLG,XREFCID
		set XTYPE=lnap1.type set XPTRM=lnap1.ptrm set XPFRE=lnap1.pfre
		set XREFFLG=lnap1.refflg set XREFCID=lnap1.refcid

		// Calculate RPI premium
		set XRPIRATE=lnap1.rpirate

		// If RPI rate is not defined on the application
		// get it from UTBLINSPC table
		if XRPIRATE="" do { quit:ER

			if XREFCID'="" set XPCM=Db.getOneRow("PCM","LN","XREFCID") quit:ER
			else  set XPCM=Db.getOneRow("PCM","PRODDFTL","XTYPE") quit:ER
			set XRPIRATE=Db.getOneRow("INRATE","UTBLINSPC","XPCM,XPTRM,XPFRE") quit:ER
			}

		new BASE                              // Calculation Base
		set BASE=lnap1.disbamt
		set lnap1.rpiprem=$$^SCARND(((BASE*XRPIRATE)/100),0,,,2)
		}

	quit
	/* References to other routines
	
											SCARND                    - Standard SCA rounding utility
	*/
	quit


vddver // Validate data dictionary attributes

	type public Number %O
	type public String vpar,vx()

	type String vRM,X
	type public RecordLNAP1 lnap1

	if (%O = 2) do vload

	if vobj(lnap1,1).exists() do {

		set X = lnap1.aacdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("AACDT", vRM) quit
		set X = lnap1.areq if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.AREQ"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = lnap1.dtap if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DTAP", vRM) quit
		set X = lnap1.dten if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DTEN", vRM) quit
		set X = lnap1.eacdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EACDT", vRM) quit
		set X = lnap1.floc if 'X.isNull(),'Db.isDefined("SCAU","X") set vRM = $$^MSG(1485,X) do vdderr("FLOC", vRM) quit
		set X = lnap1.lud if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LUD", vRM) quit
		set X = lnap1.ofac if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("OFAC", vRM) quit
		set X = lnap1.off if 'X.isNull(),'Db.isDefined("UTBLOFF","X") set vRM = $$^MSG(1485,X) do vdderr("OFF", vRM) quit
		set X = lnap1.sts if 'X.isNull(),'Db.isDefined("UTBLASTS","X") set vRM = $$^MSG(1485,X) do vdderr("STS", vRM) quit
		set X = lnap1.type if 'X.isNull(),'Db.isDefined("PRODCTL","X") set vRM = $$^MSG(1485,X) do vdderr("TYPE", vRM) quit
		set X = lnap1.uid if 'X.isNull(),'Db.isDefined("SCAU","X") set vRM = $$^MSG(1485,X) do vdderr("UID", vRM) quit
	}

	if vobj(lnap1,2).exists() do {

		if lnap1.txt1.length()>40 set vRM = $$^MSG(1076,40) do vdderr("TXT1", vRM) quit
		if lnap1.txt2.length()>40 set vRM = $$^MSG(1076,40) do vdderr("TXT2", vRM) quit
		if lnap1.txt3.length()>40 set vRM = $$^MSG(1076,40) do vdderr("TXT3", vRM) quit
		if lnap1.txt4.length()>40 set vRM = $$^MSG(1076,40) do vdderr("TXT4", vRM) quit
	}

	if vobj(lnap1,3).exists() do {

		set X = lnap1.addamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.ADDAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if lnap1.applrelc.length()>2 set vRM = $$^MSG(1076,2) do vdderr("APPLRELC", vRM) quit
		set X = lnap1.appnum if 'X.isNull(),X'?1.18N,X'?1"-"1.17N set vRM=$$^MSG(742,"N") do vdderr("APPNUM", vRM) quit
		set X = lnap1.appramt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.APPRAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = lnap1.apprlv if 'X.isNull(),'Db.isDefined("UTBLASTSLV","X") set vRM = $$^MSG(1485,X) do vdderr("APPRLV", vRM) quit
		if '("01"[lnap1.APPRVD) set vRM=$$^MSG(742,"L") do vdderr("APPRVD", vRM) quit
		set X = lnap1.boo if 'X.isNull(),'Db.isDefined("UTBLBRCD","X") set vRM = $$^MSG(1485,X) do vdderr("BOO", vRM) quit
		set X = lnap1.cdpamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.CDPAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if lnap1.colcd.length()>6 set vRM = $$^MSG(1076,6) do vdderr("COLCD", vRM) quit
		if lnap1.crcd.length()>3 set vRM = $$^MSG(1076,3) do vdderr("CRCD", vRM) quit
		if '("01"[lnap1.CRTED) set vRM=$$^MSG(742,"L") do vdderr("CRTED", vRM) quit
		set X = lnap1.disbamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.DISBAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = lnap1.fpa if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.FPA"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if lnap1.grp.length()>4 set vRM = $$^MSG(1076,4) do vdderr("GRP", vRM) quit
		set X = lnap1.lnsa if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("LNSA", vRM) quit
		set X = lnap1.payworpi if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.PAYWORPI"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = lnap1.paywrpi if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.PAYWRPI"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = lnap1.perno if 'X.isNull(),X'?1.18N,X'?1"-"1.17N set vRM=$$^MSG(742,"N") do vdderr("PERNO", vRM) quit
		set X = lnap1.pfre if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[LNAP1]PFRE",0) if 'vRM.get().isNull() do vdderr("PFRE", vRM) quit
		if lnap1.ptrm.length()>8 set vRM = $$^MSG(1076,8) do vdderr("PTRM", vRM) quit
		if lnap1.purcd.length()>6 set vRM = $$^MSG(1076,6) do vdderr("PURCD", vRM) quit
		set X = lnap1.rcalcm if 'X.isNull(),'Db.isDefined("STBLAOAMO","X") set vRM = $$^MSG(1485,X) do vdderr("RCALCM", vRM) quit
		set X = lnap1.refbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.REFBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = lnap1.refcid if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("REFCID", vRM) quit
		if '("01"[lnap1.REFFLG) set vRM=$$^MSG(742,"L") do vdderr("REFFLG", vRM) quit
		if '("01"[lnap1.RPIFLG) set vRM=$$^MSG(742,"L") do vdderr("RPIFLG", vRM) quit
		set X = lnap1.rpiprem if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.RPIPREM"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = lnap1.rpirate if 'X.isNull() set vRM = $$VAL^DBSVER("N",8,0,,,,,5) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.RPIRATE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = lnap1.rpireb if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNAP1.RPIREB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	}
	set X = lnap1.acn if 'X.isNull(),'Db.isDefined("CIF","X") set vRM = $$^MSG(1485,X) do vdderr("ACN", vRM) quit
	set X = lnap1.apps if 'X.isNull(),X'?1.10N,X'?1"-"1.9N set vRM=$$^MSG(742,"N") do vdderr("APPS", vRM) quit
	quit

vdderr(di, vRM) // Column attribute error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("LNAP1","MSG",979,"LNAP1."_di_" "_vRM)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VJOURNAL(RecordLNAP1 lnap1)	//LNAP1 Journal file entries

	type Public Date %EffectiveDate
	type Public String %TSRC,vpar,vx()
	type String TSRC,vdi,vdx()

	if %TSRC.get().isNull() set TSRC="O"
	else  set TSRC=%TSRC

	if %ProcessMode=0 do {
		if TSRC="B" do {
			if 'EFD.get() do {
				do vj2(.lnap1)	// Mode=I Tran=B EFD=N Seq=1 JRNID=LNAP1_I
				}
			}
		else  if TSRC="O" do {
			if 'EFD.get() do {
				do vj2(.lnap1)	// Mode=I Tran=O EFD=N Seq=1 JRNID=LNAP1_I
				}
			}
		}
	else  if %ProcessMode=1 do {
		if TSRC="B" do {
			if 'EFD.get() do {
				do vj3(.lnap1)	// Mode=U Tran=B EFD=N Seq=1 JRNID=LNAP1_U
				}
			}
		else  if TSRC="O" do {
			if 'EFD.get() do {
				do vj1(.lnap1)	// Mode=U Tran=O EFD=N Seq=1 JRNID=HIST_U
				do vj3(.lnap1)	// Mode=U Tran=O EFD=N Seq=1 JRNID=LNAP1_U
				}
			}
		}

	quit


vj1(RecordLNAP1 lnap1)	// HIST_U  Table CIFH  Pending Loan CIF History Update

	type Public String vx()
	type String vdi

	set vdi="" for  set vdi=vx(vdi).order() quit:vdi=""  do {
		type Public String vx(),%IDENT,%UID,TJD,TLO
		type String v1,vlastkey

		type String vold,vnew

		set vold=vx(vdi).piece("|",1)
		set vnew=vx(vdi).piece("|",2)

		set v1=lnap1.acn
		set vlastkey=Db.nextVal("CIFH","ACN=:v1")
		type RecordCIFH cifh=Db.getRecord("CIFH","ACN=:v1,SEQ=:vlastkey",1)
		set cifh.ident=%IDENT
		set cifh.tcmt=$$TCMT^CIFFUNCS(lnap1.acn_","_lnap1.apps,"LNAP1",vdi,vold,vnew)
		set cifh.tjd=TJD
		set cifh.tlo=TLO
		set cifh.uid=%UID

		do cifh.save("/NOVALFK/NOVALDD/NOVALRI")
		}

	quit


vj2(RecordLNAP1 lnap1)	// LNAP1_I  Table LNAP1HIST  Loan Application History Entry (New)

	type Public String %UID,TJD,TLO
	type String v1,v2,v3,vlastkey
	set v1=lnap1.acn
	set v2=lnap1.apps
	set v3=lnap1.appnum
	set vlastkey=Db.nextVal("LNAP1HIST","ACN=:v1,APPS=:v2,APPNUM=:v3")
	type RecordLNAP1HIST lnap1hist=Db.getRecord("LNAP1HIST","ACN=:v1,APPS=:v2,APPNUM=:v3,TSEQ=:vlastkey",1)
	set lnap1hist.brcd=lnap1.boo
	set lnap1hist.cdt=+$H
	set lnap1hist.ctime=$P($H,",",2)
	set lnap1hist.spd=TJD
	set lnap1hist.tcmt=$$^MSG(301,"LNAP1")
	set lnap1hist.tlo=TLO
	set lnap1hist.uid=%UID

	do lnap1hist.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj3(RecordLNAP1 lnap1)	// LNAP1_U  Table LNAP1HIST  Loan Application History Entry (Modify)

	type Public String vx()
	type String vdi

	set vdi="" for  set vdi=vx(vdi).order() quit:vdi=""  do {
		type Public String vx(),%UID,TJD,TLO
		type String v1,v2,v3,vlastkey

		type String vold,vnew

		set vold=vx(vdi).piece("|",1)
		set vnew=vx(vdi).piece("|",2)

		set v1=lnap1.acn
		set v2=lnap1.apps
		set v3=lnap1.appnum
		set vlastkey=Db.nextVal("LNAP1HIST","ACN=:v1,APPS=:v2,APPNUM=:v3")
		type RecordLNAP1HIST lnap1hist=Db.getRecord("LNAP1HIST","ACN=:v1,APPS=:v2,APPNUM=:v3,TSEQ=:vlastkey",1)
		set lnap1hist.brcd=lnap1.boo
		set lnap1hist.cdt=+$H
		set lnap1hist.ctime=$P($H,",",2)
		set lnap1hist.spd=TJD
		set lnap1hist.tcmt=$$TCMT^CIFFUNCS("","LNAP1",vdi,vold,vnew)
		set lnap1hist.tlo=TLO
		set lnap1hist.uid=%UID

		do lnap1hist.save("/NOVALFK/NOVALDD/NOVALRI")
		}

	quit



vkchged // Access key changed

	type public RecordLNAP1 lnap1

	type public Boolean ER = 0
	type public String RM,vpar,vx()

	type Number %O = 1
	type String vnewkey,voldkey,vux
	type String voldpar = vpar.get()                       // Save filer switches

	if vx("ACN").exists() set vux("ACN") = vx("ACN")
	if vx("APPS").exists() set vux("APPS") = vx("APPS")
	do vkey(1) set voldkey = lnap1.acn_","_lnap1.apps      // Copy old keys into object

	set vpar = $$setPar^UCUTILN(vpar,"NOINDEX")            // Switch Index off
	do vload                                               // Make sure all data is loaded locally
	if vpar["/VALREQ/" do vrequ
	if vpar["/TRIGBEF/" do VBU
	if vpar["/VALDD/" do vddver
	do vexec

	do vkey(2) set vnewkey = lnap1.acn_","_lnap1.apps      // Copy new keys into object
	type RecordLNAP1 vnewrec = lnap1.copy()
	do vnewrec.setMode(0)
	do vnewrec.save("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")

	set %O = 1 do CASUPD^DBSEXECU("LNAP1",voldkey,vnewkey) if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~")) // Cascade update
	set vpar = voldpar
	if vpar["/TRIGAFT/" do VAU

	do vkey(1)                                             // Reset key for delete
	set vpar = $$initPar^UCUTILN("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")
	set %O = 3 do vdelete(1)                               // Delete old record

	quit

vkey(Number i) // Restore access keys

	type public String vux()
	type public RecordLNAP1 lnap1

	if vux("ACN").exists() set lnap1.acn = vux("ACN").piece("|",i)
	if vux("APPS").exists() set lnap1.apps = vux("APPS").piece("|",i)
	quit
