ITUTIL
		 
	/*
	Treasury Utility Functions
	
	Common code used by ITFCV and ITFXV
	NOSTRNUM called by TTXFDT and locally
	BLDOPID called by functions BLDOPID and FULLOPID
	
	---- Revision History -------------------------------------------------
	
	07/25/06 - Pete Chenard - CR 22385
		   Removed unsupported parameter on call to getMode() method.
		   
	01/23/06 - RussellDS - CR19164
		   Converted to PSL.

	-----------------------------------------------------------------------
	*/
	
	quit			// No entry from top


private EFDPP
	/*
	Post processor on EFD prompt field

	Checks for valid business date against the standard Company Calendar
	
	Called by ITFCV and ITFXV.
	*/
	
	type public Boolean ER
	type public Date X
	type public String RM
	
	if 'X.isBusDate() do {
	
		set ER = 1
		// Invalid business date
		set RM = $$^MSG(1275)
	}
	
	quit
	
	
private LPDATEPP

	/*
	Post processor for LPDATE - construct TARRAY()
	
	Called by ITFCV and ITFXV
	*/
	
	type public Date X
	type public Number BRCD
	type public String DEALID, ITSCODE, TARRAY()
	
	if 'X.isNull() do TSEQ^ITUTIL(ITSCODE, DEALID, X, BRCD, %UserID, .TARRAY())
	
	quit
	

private SEQPP

	/*
	Post processor for SEQ prompt
	
	Called by ITFCV and ITFXV
	*/
	
	type public Boolean ER
	type public Date LPDATE
	type public Number X
	type public String BRCD, DEALID, ITSCODE, RM
	
	quit:X.isNull()
	
	type RecordITOPID itopid = Db.getRecord("ITOPID", "ITSCODE=:ITSCODE,DEALID=:DEALID,EFD=:LPDATE,BRCD=:BRCD,UID=:%UserID,TSEQ=:X", 1)
	
	if (itopid.getMode() = 0) do { quit
		
		set ER = 1
		// Invalid operations ID
		set RM = $$^MSG(1410)
	}
	
	if (itopid.vtype '= ITSCODE) do { quit
	
		set ER = 1
		
		// Transaction is not part of a foreign exchange voucher
		if (ITSCODE = "FXV") set RM = $$^MSG(2725)
		
		// Transaction is part of a foreign exchange voucher deal
		else  if (ITSCODE = "FCV") set RM = $$^MSG(2726)
	}
	
	quit
	

private UIDPP

	/*
	Post processor for UID - construct TARRAY()
	
	Called by ITFCV and ITFXV
	*/
	
	type public Date LPDATE, X
	type public Number BRCD
	type public String DEALID, ITSCODE, TARRAY()
	
	if 'X.isNull() do TSEQ^ITUTIL(ITSCODE, DEALID, LPDATE, BRCD, X, .TARRAY())
	
	quit

	
private DTC(Number GLACN,	// GL (G) or Account (A) indicator
	    Number CID,		// Account number
	    String DRCR)	// Debit/Credit indicator
    
	/*
	Default Tran Code

	This function returns the Default transaction code
	for the account that's passed.  ITS converts the standard
	DEBIT/CREDIT indicator that's passed to the default Debit/Credit
	Transaction Code for the product.
	
	Called by ITFCV and ITFXV
	
	RETURNS:
		. $$	Transaction code
	*/
	
	type Number TRB
	type String return

	if (GLACN = "G") do {
		
		if (DRCR = "DR") set return = "MDR"
		else  set return = "MCR"
	}
	
	else  do {
	
		type RecordACN acn = Db.getRecord("ACN", "CID=:CID", 1)
	
		set TRB = acn.trb
	
		type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE=:acn.type", 1)
	
		if TRB.isNull() set TRB = prodctl.trb
	
		if (+TRB = 0) do {
		
			if (DRCR = "DR") set return = prodctl.drtrgp
			else  set return = prodctl.crtrgp
		}
		else  do {
		
			if (DRCR = "DR") set return = prodctl.crtrgp
			else  set return = prodctl.drtrgp
		}
	}

	quit return
		

private DELETE(String ITSCODE,		// "FCV" or "FXV"
	       RecordTTX ttx(),		// Transactions to delete
	       RecordITOPID itopid,	// Main sequence ITOPID record
	       Number CNT,		// Number of elements in ttx array
	       Boolean PFLAG,		// How to delete the transactions [*]	
	       Date TPD,		// New transaction posting date [*]
	       Number BRCD,		// Branch code
	       Date EFD,		// Effective date of reversing entries
	       Date LPDATE)		// Posting date of original transactions [*]
       
	/*
	Deletes a group of related postings

	This function takes on the responsibility of "undoing" a group
	of FXV postings.  It is called for modifcation and deletion (with
	a reposting of the changes taking place for a modification).
	Based on the variable PFLAG, it will undo postings in one of the
	following ways:
	
	     If the deal (deal meaning group of transactions) has
	     posted already, and posted on a previous business day,
	     then the deal is reversed (PFLAG = 2).
	
	     If the deal has posted already, but posted today,
	     then the deal is Error-corrected  (PFLAG = 1)
	
	     If the deal is future dated (simply warehoused in ^TTX),
	     then we just kill the ^TTX entries (PFLAG =0).
	
	ARGUMENT NOTES

		. PFLAG		How to delete these transactions:
				  2       Reverse
				  1       Error-Correct
				  0       Kill - future dated
		. TPD		The new transaction posting date.  If the deals
				are error-corrected or reversed, then reversing
				or error corrected entries will post on "today's"
				business day.
		. LPDATE	The posting date of the original transactions.
				This is used to find the deals that are out there,
				to modify them (or kill them!)
	RETURNS:
		. $$		Success flag			/TYP=L
	*/
	
	type Boolean return
	type Number I
	
	set return = 1
	
	type RecordTTX ttxrev()
	
	for I = 1:1:CNT do {
		
		type Number CID, UID, TSEQ
		type String ACNGL, BSEAMT, ETC, ITC, NSEQ, TAMT, TAMTORIG, TSO, TSOARRAY(), X
		
		type RecordTTX ttxtmp
		
		set ttxtmp = ttx(I).copy()
		
		set CID = ttxtmp.cid
		set ITC = ttxtmp.itc
		set ETC = ttxtmp.etc
		set TAMT = ttxtmp.tamt
		set TAMTORIG = TAMT
		set BSEAMT = ttxtmp.bseamt
		set TSO = ttxtmp.tso
		set UID = itopid.userid
		set TSEQ = itopid.trc
		set ttxtmp.trc = ""
		
		if (I > 1) set TSEQ = ((TSEQ - 1) + I)
		
		set ACNGL = $$FIELD^UTSO(TSO, "ACNGL")
		do OUT^UTSO(.TSOARRAY(), TSO)
		
		type RecordTRN trn = Db.getRecord("TRN", "ETC=:ETC")

		// Already Posted, reverse or error correct entries
		if (PFLAG > 0) do {
			
			if (PFLAG = 1) set TSOARRAY("EC") = ttx(I).tseq
			else  do {
				
				if (trn.cls = "M") set TSOARRAY("REV") = ""
				else  do {
		
					type ResultSet rs = Db.select("TSEQ", "HIST", "CID=:CID AND TJD=:LPDATE AND BRCD=:BRCD AND TRC=:TSEQ AND UID=:UID")
			
					if rs.next() set TSOARRAY("REV") = rs.getCol("TSEQ")
				}
			}
			
			if (PFLAG = 1) set ITC = $$ITC^TTXEXT(ITC, 6, 1)
			else  set ITC = $$ITC^TTXEXT(ITC, 12, 1)
			
			if (trn.cls = "M") do {
				
				if (ITC.extract(1) = 0) set ETC = "MDR"
				else  set ETC = "MCR"
					
				set TAMT = -TAMT
				set ttxtmp.itc = ITC
				set ttxtmp.etc = ETC
				set ttxtmp.tamt = TAMT
				set ttxtmp.efd = EFD
				do IN^UTSO(.TSOARRAY(), .TSO)
				set ttxtmp.tso = TSO
			}
			
			else  do {
				
				type Number J
				
				for J = 1:1:TAMT.length("#") set TAMT.piece("#", J) = -TAMT.piece("#", J)
				for J = 1:1:BSEAMT.length("#") set BSEAMT.piece("#", J) = -BSEAMT.piece("#", J)
				
				set ttxtmp.itc = ITC
				set ttxtmp.tamt = TAMT
				set ttxtmp.bseamt = BSEAMT
				do IN^UTSO(.TSOARRAY(), .TSO)
				set ttxtmp.tso = TSO
			}
			
			set ttxrev(I) = ttxtmp.copy()
		}
		
		// Not posted yet, just remove it
		else  do {
			
			// Update account history
			if (trn.cls '= "M") do {
			
				type Number HISTSEQ
				
				type ResultSet rs = Db.select("MAX(TSEQ)", "HIST", "CID=:CID")
				
				if rs.next() set HISTSEQ = rs.getCol(1) + 1
				else  set HISTSEQ = 1
				
				type RecordHIST hist = Class.new("RecordHIST", "CID=:CID,TSEQ=:HISTSEQ")
				
				set hist.tjd = %SystemDate
				set hist.efd = EFD
				set hist.tso = TSO
				set hist.cdt = %CurrentDate
				set hist.time = %CurrentTime
				set hist.brcd = BRCD
				set hist.trc = TSEQ
				set hist.uid = UID
				
				// Future Amount:~p1 ~p2  deleted
				set hist.tcmt = $$^MSG(3779, ttxtmp.tamt, ttxtmp.tcmt)
				
				do hist.save()
			}
		}
			
		// Delete support files
		set NSEQ = $$FIELD^UTSO(TSO,"NOSTSEQ")
		if 'NSEQ.isNull() do Db.delete("ITNOSTRO", "CID=:CID AND DTJD=:EFD AND TSEQ=:NSEQ")
				
		if (I = 1) do {
				
			type Number SEQBEG, SEQEND
				
			set SEQBEG = itopid.trc
			set SEQEND = SEQBEG + 1000 - 1
				
			do Db.delete("TTXFDT", "TJD=:EFD AND BRCD=:BRCD AND UID=:UID AND TSEQ>=:SEQBEG AND TSEQ<:SEQEND")
			do Db.delete("ITAUDIT", "DEALID=:itopid.dealid AND EFD=:EFD AND BRCD=:BRCD AND UID=:UID AND TSEQ>=:SEQBEG AND TSEQ<:SEQEND")
			do Db.delete("ITNOSX", "TJD=:EFD AND BRCD=:BRCD AND UID=:UID AND TSEQ>=:SEQBEG AND TSEQ<:SEQEND")
			do Db.delete("ITOPID", "ITSCODE=:ITSCODE AND DEALID=:itopid.dealid AND EFD=:EFD AND BRCD=:BRCD AND UID=:UID AND TSEQ>=:SEQBEG AND TSEQ<:SEQEND")
		}
		
		if (ACNGL = "A"), '$$NOSTRO^TTXFDT(CID) set X = $$REMHOLD^PHLD(CID,LPDATE,TAMTORIG)
	}
	
	if (PFLAG > 0) do {
		
		type Boolean ER
		
		do TRNSET^TRNDRV(.ttxrev(), TPD, BRCD, 1)
	
		if ER set return = 0
	}
	
	quit return	


private HOLD(RecordTTX ttx)	// Transaction record
	
	/*
	Places hold on transaction if necessary

	This function attemps to place a "permanent" hold on the account
	which is stored in the transaction that's passed as a parameter.
	It checks [ACN]ITSHLDDAYS to see if a hold period has been
	defined for this account.  That field indicates      the number of
	days in advance to place a "permanent" hold.  If it has been defined,
	a hold is placed with an expiration date of the transaction effective
	date - 1.
	*/
	
	type public String RM
	
	type Date EFD
	type Number CID, HLDDEF, TRB, X
	type String COMMENT, DEALID, HLDARRAY(), TSO
	
	set EFD = ttx.efd
	quit:(EFD '> %SystemDate)		// Past or today's posting date
	
	set CID = ttx.cid
	set TRB = $$TRB^UTRB(CID)
	quit:$$DC^UTRB(ttx.itc1, TRB)		// Deposit to account, no hold necessary
	
	type RecordDEP dep = Db.getRecord("DEP", "CID=:CID", 1)
	
	set HLDDEF = dep.ithlddays
	quit:HLDDEF.isNull()
	
	set TSO = ttx.tso
	set DEALID = $$FIELD^UTSO(TSO, "DEALID")
	set HLDARRAY("DEALID") = DEALID
	set HLDARRAY("TSEQ") = ttx.trc
	set HLDARRAY("ITSCODE") = $$FIELD^UTSO(TSO, "ITSCODE")
	set HLDARRAY("BRCD") = ttx.brcde
	do IN^UTSO(.HLDARRAY(), .COMMENT)

	set X = $$PUTHOLD^PHLD(CID, EFD - HLDDEF, EFD, ttx.tamt, 3 ,%UserID, %UserStation, COMMENT)
	
	// Could not place hold
	if (X < 0) set RM = $$^MSG(630)
	
	quit

	
private LOAD(RecordITOPID itopid,
	     Date EFD,
	     Number BRCD,
	     Number UID,
	     RecordTTX ttx())
     
	/*
	Load data from file into Array - return number of records
	
	Called by ITFCV and ITFXV
	*/

	type Number CNT, SEQBEG, SEQEND
	
	set CNT = 0	

	if (itopid.getMode() = 0) quit 0
	
	set SEQBEG = itopid.trc
	set SEQEND = SEQBEG + 1000 - 1

	if (EFD > %SystemDate) do {
			
		type DbSet ds = Db.selectDbSet("TTXFDT", "TJD=:EFD AND BRCD=:BRCD AND UID=:UID AND TSEQ>=:SEQBEG AND TSEQ<:SEQEND", "TSEQ ASC")
		
		while ds.next() do {
			
			type RecordTTXFDT ttxfdt = ds.getRecord("TTXFDT")
			
			set CNT = CNT + 1
			set ttx(CNT) = ttxfdt.copy()
		}
	}
	else  do {
		
		type DbSet ds = Db.selectDbSet("TTX", "TJD=:EFD AND BRCD=:BRCD AND UID=:UID AND TSEQ>=:SEQBEG AND TSEQ<:SEQEND", "TSEQ ASC")
		
		while ds.next() do {
			
			type RecordTTX ttxtmp = ds.getRecord("TTX")
			
			set CNT = CNT + 1
			set ttx(CNT) = ttxtmp.copy()
		}
	}

	quit CNT

	
private SUPTTBLS(String ITSCODE,	// "FXV" or "FCV"
		 String DEALID,		// Deal ID for this transaction
		 Date EFD,		// Effective date of the transaction
		 Date TPD,		// Teller posting date
		 Number BRCD,		// Branch code
		 RecordTTX ttx(),	// Transaction array
		 String OM())		// OM array from TRNDRV

	/*
	Update support tables for primary transactions.
	
	Called by ITFXC and ITFXV
	*/
	
	type Number N
	
	set N = ""
	for  set N = ttx(N).order() quit:N.isNull()  if '(N#1) do {
	
		type Number TSEQ
		
		set TSEQ = OM(N).piece("|", 3)
	
		set ttx(N).tseq = TSEQ
		
		type RecordITOPID itopid = Class.new("RecordITOPID", "ITSCODE=:ITSCODE,DEALID=:DEALID,EFD=:TPD,BRCD=:BRCD,UID=%UserID,TSEQ=:TSEQ")

		set itopid.trc = ttx(1).tseq
		set itopid.branch = BRCD
		set itopid.userid = %UserID
		set itopid.enterdate = %CurrentDate
		set itopid.vtype = ITSCODE
		
		do itopid.save()
		
		type RecordITAUDIT itaudit = Class.new("RecordITAUDIT", "DEALID=:DEALID,EFD=:TPD,BRCD=:BRCD,UID=%UserID,TSEQ=:TSEQ")
		
		// If we updated TTX, we can use that, otherwise this is a future
		// dated transaction and we need to use TTXFDT
		type RecordTTX ttxcopy
		
		if (EFD '> %SystemDate) set ttxcopy = ttx(N).copy()
		else  do {
			
			type RecordTTXFDT ttxfdt = Db.getRecord("TTXFDT", "TJD=:EFD,BRCD=:BRCD,UID=:%UserID,TSEQ=:TSEQ")
			
			set ttxcopy = ttxfdt.copy()
		}
		set itaudit.cid = ttxcopy.cid
		set itaudit.itc = ttxcopy.itc
		set itaudit.etc = ttxcopy.etc
		set itaudit.tamt = ttxcopy.tamt
		set itaudit.ndate = ttxcopy.efd
		set itaudit.tlo = ttxcopy.tlo
		set itaudit.tso = ttxcopy.tso
		set itaudit.tcmt = ttxcopy.tcmt
		set itaudit.cdt = ttxcopy.cdt
		set itaudit.tim = ttxcopy.tim
		set itaudit.brcde = ttxcopy.brcde
		set itaudit.trc = ttxcopy.trc
		set itaudit.uidt = ttxcopy.uidt
		set itaudit.spr = ttxcopy.spr
		set itaudit.tsb = ttxcopy.tsb
		set itaudit.lnerc = ttxcopy.lnerc
		set itaudit.crcd = ttxcopy.crcd
		set itaudit.rate = ttxcopy.rate
		set itaudit.vdt = ttxcopy.vdt
		set itaudit.cc = ttxcopy.cc
		set itaudit.dir = ttxcopy.dir
		set itaudit.chktyp = ttxcopy.chktyp
		set itaudit.endbal = ttxcopy.endbal
		set itaudit.mult = ttxcopy.mult
		set itaudit.bseamt = ttxcopy.bseamt
		set itaudit.custcd = ttxcopy.custcd
		set itaudit.tresref = ttxcopy.tresref
		set itaudit.rty = ttxcopy.rty
		set itaudit.msd = ttxcopy.msd
		set itaudit.glsc = ttxcopy.glsc
		set itaudit.bcrcd = ttxcopy.bcrcd
		
		do itaudit.save()
		
		type RecordITNOSX itnosx = Class.new("RecordITNOSX", "TJD=:TPD,BRCD=:BRCD,UID=%UserID,TSEQ=:TSEQ")
		
		set itnosx.cid = ttxcopy.cid
		set itnosx.itc = ttxcopy.itc
		set itnosx.etc = ttxcopy.etc
		set itnosx.tamt = ttxcopy.tamt
		set itnosx.efd = ttxcopy.efd
		set itnosx.tlo = ttxcopy.tlo
		set itnosx.tso = ttxcopy.tso
		set itnosx.tcmt = ttxcopy.tcmt
		set itnosx.cdt = ttxcopy.cdt
		set itnosx.tim = ttxcopy.tim
		set itnosx.brcde = ttxcopy.brcde
		set itnosx.trc = ttxcopy.trc
		set itnosx.uidt = ttxcopy.uidt
		set itnosx.spr = ttxcopy.spr
		set itnosx.tsb = ttxcopy.tsb
		set itnosx.lnerc = ttxcopy.lnerc
		set itnosx.crcd = ttxcopy.crcd
		set itnosx.rate = ttxcopy.rate
		set itnosx.vdt = ttxcopy.vdt
		set itnosx.cc = ttxcopy.cc
		set itnosx.dir = ttxcopy.dir
		set itnosx.chktyp = ttxcopy.chktyp
		set itnosx.endbal = ttxcopy.endbal
		set itnosx.mult = ttxcopy.mult
		set itnosx.bseamt = ttxcopy.bseamt
		set itnosx.custcd = ttxcopy.custcd
		set itnosx.tresref = ttxcopy.tresref
		set itnosx.rty = ttxcopy.rty
		set itnosx.msd = ttxcopy.msd
		set itnosx.glsc = ttxcopy.glsc
		set itnosx.bcrcd = ttxcopy.bcrcd
		set itnosx.xpdo = ttxcopy.xpdo
		
		do itnosx.save()
		
		// Eliminated setting of DAYEND for "CFTTX" since no longer used
		
		// Place hold on transaction if necessary
		if $$FIELD^UTSO(ttxcopy.tso, "ACNGL") = "A", '$$NOSTRO^TTXFDT(ttxcopy.cid) do HOLD^ITUTIL(ttxcopy)
	}
	
	quit
	
	
private TSEQ(String ITSCODE,	// "FCV" or "FXV"
	     String DEALID,	// ITS Operations ID
	     Date EFD,		// Effective Date
	     Number BRCD,	// Branch Code
	     String UID,	// User ID
	     String TARRAY())	// Valid TSEQ array	/MECH=REFARR:W
	     
	/*
	Return FCV/FXV sequence numbers based on input
	
	This function will return an array containing valid sequence numbers,
	and descriptions, to be used by ITS FCV and FXV modify, inquiry, 
	and delete actions.  If the user presents SELECT on Sequence, they
	will see the list determined here.  Returned values do not include
	reversals or error corrects, and will include a description of account
	type (GL or IBS Account) and currency code.
	
	Note that this function has been modified from the original (M) version
	to only return the first (primary) transaction in each set.
	
	EXAMPLE:
		. D TSEQ^ITUTIL(ITSCODE,DEALID,X,BRCD,.TARRAY)
	*/
	
	kill TARRAY
	
	type ResultSet rs = Db.select("TSEQ", "ITOPID", "ITSCODE=:ITSCODE AND DEALID=:DEALID AND EFD=:EFD AND BRCD=:BRCD AND UID=:UID AND TSEQ=TRC")
	
	while rs.next() do {
		
		type Boolean hit
		type Number CID, TSEQ
		type String ACNGL, BSTRING, CRCD, ITC, TSO
		
		set hit = 0
		set (CID, CRCD, ITC, TSO) = ""
		
		set TSEQ = rs.getCol("TSEQ")
		
		if (EFD > %SystemDate) do {
			
			type RecordTTXFDT ttxfdt = Db.getRecord("TTXFDT", "TJD=:EFD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ", 1)		
			
			if (ttxfdt.getMode() > 0) do {
				
				set CID = ttxfdt.cid
				set ITC = ttxfdt.itc
				set TSO = ttxfdt.tso
				set CRCD = ttxfdt.crcd
				set hit = 1
			}
		}
		else  do {
			
			type RecordTTX ttx = Db.getRecord("TTX", "TJD=:EFD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ", 1)		
			
			if (ttx.getMode() > 0) do {
				
				set CID = ttx.cid
				set ITC = ttx.itc
				set TSO = ttx.tso
				set CRCD = ttx.crcd
				set hit = 1
			}
		}
			
		if 'hit do {
		
			type RecordITAUDIT itaudit = Db.getRecord("ITAUDIT", "DEALID=:DEALID,EFD=:EFD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ", 1)		
			
			if (itaudit.getMode() > 0) do {
				
				set CID = itaudit.cid
				set ITC = itaudit.itc
				set TSO = itaudit.tso
				set CRCD = itaudit.crcd
			}
		}
		
		// Error correct or reversal
		quit:((ITC.extract(6) = 1) ! (ITC.extract(12) = 1))
		
		if CRCD.isNull() set CRCD = %SystemCurrency
		
		set ACNGL = $$FIELD^UTSO(TSO,"ACNGL")
		
		// IBS Account
		if ACNGL = "A" set BSTRING = $$^MSG(5679)
		// G/L Account
		else  set BSTRING = $$^MSG(1153)
		
		set BSTRING = BSTRING_" "_CID_" ("_CRCD_")"
		
		set TARRAY(TSEQ) = BSTRING
	}
	
	quit
	
	
public NOSTRNUM(Number CID,		// Account Number
		Date DATE,		// Transaction Date
		Boolean UPDATE)		// Update ITNOSTRO table
		
	/*
	Returns a valid Nostro Sequence number in prep for filing
	
	This should only be called by TTXFDT and is not considered generally public.
	
	This function will return a valid Nostro sequence number for an account for a 
	given date to be used by a transaction.  The ^ITNOSTR file is keyed by Account, 
	date, and sequence.  The sequence is returned from this function.
	
	NOTE:  At some point, the approach of reserving a sequence should be
	       re-examined since now should be under TP.

	RETURNS:
		. $$		Valid Nostro Transaction Number
	*/
	
	type Number SEQ
	
	type ResultSet rs = Db.select("MAX(TSEQ)", "ITNOSTRO", "CID=:CID AND DTJD=:DATE")
	
	if rs.isEmpty() set SEQ = ""
	else  if rs.next() set SEQ = rs.getCol(1)
	
	if UPDATE do {
		
		set SEQ = SEQ + 1
		
		type RecordITNOSTRO itnostro = Class.new("RecordITNOSTRO", "CID=:CID,DTJD=:DATE,TSEQ=:SEQ")
		
		// Temporary value
		set itnostro.tcmt = $$^MSG(3782)
	
		do itnostro.save()
	}
	
	quit SEQ
	
	
public BLDOPID(Number DAYS)	// Number of days to go back in TTX [*]

	/*
	Rebuilds ^ITOPID and ^ITOPIDX, master indexes for ITS
	
	Called by functions BLDOPID - partial rebuild, and FULLOPID - full
	rebuild

	This function is designed to rebuild the ITOPID index in case it gets
	damaged, destroyed, or out of synch with what's in ^TTX.  It collates
	sequentially through ^TTX, searching for places where the TSO field
	contains a DEALID.  If it does, then an entry is created in ^ITOPID.
	Remember, even if it's in ^TTX, ITS doesn't know about it unless it's
	in ^ITOPID!
	
	The partial option only rebuilds for the last 30 days.
	
	NOTE:  Prior to converting to PSL, this code also called XFER^ITSINT
	       which collated through global ITNOSPERM.  However, no references
	       to set that global nor matching file definitions could be found,
	       so that code was not converted.
	       
	ARGUMENT NOTES:
		. DAYS		A value of 0 indicates to use all of TTX
	*/
	
	type public String ER, RM
	
	type Date ENDDATE
	type String DEALID, ETC, ETCCLS, ITNOSTR, ITOPID, ITSCODE, TSO
	
	set (ITNOSTR, ITOPID) = ""
	
	lock +ITOPID:2
	else  do { quit
		
		set ER = 1
		// ITOPID index is locked by another user
		set RM = $$^MSG(1579)
	}
	lock +ITNOSTR:2
	else  do { quit
		
		set ER = 1
		// ITNOSTR index is locked by another user
		set RM = $$^MSG(1578)
		lock -ITOPID
	}
	
	do Db.delete("ITNOSTRO")
	do Db.delete("ITOPID")
	
	if (DAYS = 0) set ENDDATE = 1
	else  set ENDDATE = %SystemDate - DAYS
	
	type DbSet ds = Db.selectDbSet("TTX", "TJD>=:ENDDATE AND ITC6<>1 AND ITC12<>1")
	
	while ds.next() do {
		
		type RecordTTX ttx = ds.getRecord("TTX")
		
		set TSO = ttx.tso
		set DEALID = $$FIELD^UTSO(TSO, "DEALID")
		quit:DEALID.isNull()			// Not a treasury deal
		
		set ITSCODE = $$FIELD^UTSO(TSO, "ITSCODE")
		
		type RecordITOPID itopid = Class.new("RecordITOPID", "ITSCODE=:ITSCODE,DEALID=:DEALID,EFD=:ttx.tjd,BRCD=:ttx.brcd,UID=:ttx.uid,TSEQ=:ttx.tseq")
		
		set itopid.trc = ((ttx.tseq \ 1000) * 1000) + 1
		set itopid.branch = ttx.brcd
		set itopid.userid = ttx.uid
		set itopid.enterdate = ttx.cdt
		set itopid.vtype = ITSCODE
		
		do itopid.save()
	}
	
	type DbSet ds2 = Db.selectDbSet("TTXFDT", "TJD>:%SystemDate AND ITC6<>1")
	
	while ds2.next() do {
		
		type RecordTTXFDT ttxfdt = ds2.getRecord("TTXFDT")
	
		set TSO = ttxfdt.tso
		set DEALID = $$FIELD^UTSO(TSO, "DEALID")
		quit:DEALID.isNull()			// Not a treasury deal
		
		set ITSCODE = $$FIELD^UTSO(TSO, "ITSCODE")
		
		type RecordITOPID itopid = Class.new("RecordITOPID", "ITSCODE=:ITSCODE,DEALID=:DEALID,EFD=:ttxfdt.tjd,BRCD=:ttxfdt.brcd,UID=:ttxfdt.uid,TSEQ=:ttxfdt.tseq")
		
		set itopid.trc = ((ttxfdt.tseq \ 1000) * 1000) + 1
		set itopid.branch = ttxfdt.brcd
		set itopid.userid = ttxfdt.uid
		set itopid.enterdate = ttxfdt.cdt
		set itopid.vtype = ITSCODE
		
		do itopid.save()
	
		set ETC = ttxfdt.etc
		if 'ETCCLS(ETC).exists() do {
		
			type RecordTRN trn = Db.getRecord("TRN", "ETC=:ETC")
			
			set ETCCLS(ETC) = trn.cls
		}
		
		if (ETCCLS(ETC) '= "M"), $$NOSTRO^TTXFDT(ttxfdt.cid) do {
		
			type Number INUM
			
			set INUM = $$NOSTRNUM(ttxfdt.cid, ttxfdt.tjd, 1)
			
			set ttxfdt.tso = $$FIELDIN^UTSO(ttxfdt.tso, "NOSTSEQ", INUM)
			
			do ttxfdt.save()
			
			type RecordITNOSTRO itnostro = Class.new("RecordITNOSTRO", "CID=:ttxfdt.cid,DTJD=:ttxfdt.tjd,TSEQ=:INUM")
			
			set itnostro.itc = ttxfdt.itc
			set itnostro.etc = ttxfdt.etc
			set itnostro.tamt = ttxfdt.tamt
			set itnostro.defd = ttxfdt.efd
			set itnostro.tlo = ttxfdt.tlo
			set itnostro.tso = ttxfdt.tso
			set itnostro.tcmt = ttxfdt.tcmt
			set itnostro.cdt = ttxfdt.cdt
			set itnostro.tim = ttxfdt.tim
			set itnostro.brcde = ttxfdt.brcde
			set itnostro.trc = ttxfdt.trc
			set itnostro.uidt = ttxfdt.uidt
			set itnostro.spr = ttxfdt.spr
			set itnostro.crcd = ttxfdt.crcd
			set itnostro.rate = ttxfdt.rate
			set itnostro.vdt = ttxfdt.vdt
			set itnostro.cc = ttxfdt.cc
			set itnostro.dir = ttxfdt.dir
			set itnostro.chktyp = ttxfdt.chktyp
			set itnostro.mult = ttxfdt.mult
			set itnostro.bseamt = ttxfdt.bseamt
			set itnostro.custcd = ttxfdt.custcd
			set itnostro.tresref = ttxfdt.tresref
			set itnostro.msd = ttxfdt.msd
			set itnostro.glsc = ttxfdt.glsc
			set itnostro.bcrcd = ttxfdt.bcrcd
			set itnostro.brcd = ttxfdt.brcd
			set itnostro.uid = ttxfdt.uid
			
			do itnostro.save()
		}
	}
	
	lock -ITOPID
	lock -ITNOSTR
	
	set ER = "W"
	
	// Operations ID table rebuilt
	if (DAYS = 0) set RM = $$^MSG(2108)
	// Operations ID table partially rebuilt
	else  set RM = $$^MSG(2107)
	
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60472^62255^Pete Chenard^22061"	// Signature - LTD^TIME^USER^SIZE
