public	DEPACR1(RecordDEP dep, RecordTTX ttx, RecordTRN trn, Number CTL)

	/*
	Adjust Interest Accrued

	Process adjustments to the accrued interest payable fields
	of deposit accounts.

	Called by deposit transaction codes to adjust interest accrued
	amounts.
	
	CALLED BY: ^LNPTS29, deposit accrual adjustment tran codes

	ARGUMENTS:
		. CTL = Passes control variables /TYP=T/REQ/MECH=VAL
		       CTL = 0 - Accrual (POSACR) processing
			     1 - Authorized Negative accrual (NEGACR) processing
			     2 - Unauth Negative accrual (NEGACRUN) processing
			     3 - Available Interest accrual (AIACR) processing
			     4 - Uncollected accrual (UNCACR) processing

	INPUTS:
		. CTL (control variables)

	---- Revision History ------------------------------------------------
	
	07/19/07 - Anitha Chandran - CR 28314
		   Removed MIN section and modified sections FILE, AUT and 
		   FILESEG to replace all calls to MIN section with the third 
		   actual parameter, since it is no longer needed due to 
		   replacement with EXACTACR in TSO.
		   
	06/20/07 - Chaithra - CR 27528
	   	   The variable "TRB" is scoped locally at the beginning of the 
	   	   procedure to avoid the passing of incorrect value to BCHINTPOST
	   	   in case of negative accrual which resulted in OOB.
	
	07/17/06 - DESHPANDE S K - CR 20748
		   Replaced Transaction variable %TRNPRIM with Transaction 
		   Stored Value.	
	
	01/28/06 - SmithCD - CR 19343 (16890)
		   Made top of procedure public, and perfomred some cleanup.
		   Retrofitted the following change from p01:
		            06/07/03 - STATTOND - CR2916
		   Fixed bug with error correct/reveral when using EXACTACR, 
		   in which the accrual bucket would get updated with an 
		   incorrectly signed amount.
	
	09/28/05 - SAHUN - CR16662
		   Modified the procedure by replacing ttx.tseq#1 check with
		   %TRNPRIM flag since ttx object is not completely built at
		   this point in some situations(e.g during CD renewal).
		   	
	02/01/05 - SmithCD - CR13661
		   Changed occurrence of ITC to ttx.itc in FILE section to 
		   prevent undefined error.

	-----------------------------------------------------------------------
	*/

	type public Boolean ER	
	type Boolean TRB
	
	// Effective dated accrual adjustments are not allowed
	if ttx.getStoredValue("isPrimary"), %EffectiveDate, %EffectiveDate<%SystemDate do Runtime.setErrMSG("DEP", 7766) quit

	type Number ACR, AIACR, SEGEUR, SEGMENT, SEGVAL
	type String TAMT

	do INIT(.dep, .ttx)

	// If segment node is blank (as the case may be if called from RECALSEG)
	// quit from posting routine
	if dep.segflg, 'SEGMENT.isNull(), 'Db.isDefined("DEPSEG", "CID=:dep.cid,SEGMENT=:SEGMENT") quit

	do FILE(.dep, .ttx, .trn) quit:ER

	quit


FILE(RecordDEP dep, RecordTTX ttx, RecordTRN trn)

	// File Data

	type public Boolean ER, TRB
	type public String TAMT
	type public Number ACR, AIACR, CTL, SEGEUR
	
	type Number AMT, EXACTACR

	set AMT = +TAMT

	/*
	  Use exact accrual amount (if specified) to update accrual buckets
	  Exact ACR should always be positive in TSO
	*/
	set EXACTACR = $$FIELD^UTSO(ttx.tso, "EXACTACR")
	if 'EXACTACR.isNull() do {
		if AMT < 0 set AMT = -EXACTACR	// Error correct/reversal
		else  set AMT = EXACTACR	// Regular transaction
		}

	// Do not perform authorizations if called from RECALSEG / EC / REV
	if 'ttx.itc6, 'ttx.itc12, 'SEGEUR do AUT(.dep, .ttx) quit:ER

	// Positive accrual
	if 'CTL set TAMT.piece("#", 3) = TAMT
	// Negative accrual (authorized)
	if CTL=1 set TAMT.piece("#", 6) = TAMT
	// Negative accrual (unauthorized)
	if CTL=2 set TAMT.piece("#", 11) = TAMT
	// Accrued Interest on Available Int
	if CTL=3 set TAMT.piece("#", 14) = TAMT
	// Uncollected accrual
	if CTL=4 set TAMT.piece("#", 18) = TAMT

	set ttx.tamt = TAMT

	// Determine direction

	// Positive bucket amounts
	if 'CTL ! (CTL = 3), 'TRB set AMT = -AMT
	// Negative bucket amounts
	if CTL=1 ! (CTL = 2) ! (CTL = 4), TRB set AMT = -AMT

	set dep.tld = %SystemDate

	if dep.segflg, 'SEGEUR do FILESEG(.ttx, .dep, AMT)
	if 'dep.segflg ! (SEGEUR) do {
		// Positive Accrued Int/Div
		if 'CTL set dep.posacr = ACR + AMT
		// Negative Accrued
		if CTL = 1 set dep.negacr = dep.negacr + AMT
		// Negative Accrued Interest Unauthorized
		if CTL = 2 set dep.negacrun = dep.negacrun + AMT
		// Available Interest Accrued
		if SEGEUR, CTL = 3 set dep.aiacr = AIACR + AMT
		if CTL = 4 set dep.uncacr = dep.uncacr + AMT
		}

	type Number BAL, CMP

	set BAL = dep.posacr
	set CMP = dep.cmp

	// If comp freq. exists restate compounding if accrual is decreased
	if dep.icf, (dep.cmp > BAL) set dep.cmp = BAL
	if dep.cmp '< BAL,'ttx.itc6 set ttx.cmpsav = CMP - BAL
	else  do {
		set dep.cmp = ttx.cmpsav + CMP
		set dep.posacr = BAL
		}
	if dep.cmp < 0 set dep.cmp = 0

	// Update account status
	do ^UPDSTAT(.dep, .trn)

	quit


public EC(RecordDEP dep, RecordTTX ttx, RecordTRN trn, Number CTL)

	/*
	   Called by deposit transaction codes to error correct interest accrued
	   amounts.

	   ARGUMENTS:
	       . CTL = Passes control variables /TYP=T/REQ/MECH=VAL
	               CTL = 0 - Accrual (POSACR) processing
	                     1 - Authorized Negative accrual (NEGACR) processing
	                     2 - Unauth Negative accrual (NEGACRUN) processing
	                     3 - Available Interest accrual (AIACR) processing
	                     4 - Uncollected Uccrual (UNCACR) processing

	   INPUTS:
	       . CTL (control variables)

	*/

	type Number ACR, AIACR, SEGEUR, SEGMENT, SEGVAL
	type String TAMT

	do INIT(.dep, .ttx)

	/*
 	  If segment node is blank (as the case may be if called from RECALSEG)
 	  quit from posting routine
	*/
	if dep.segflg, 'SEGMENT.isNull(), 'Db.isDefined("DEPSEG", "CID=:dep.cid,SEGMENT=:SEGMENT") quit

	if ttx.tso.isLike("%REV#%") do ^UPDCCLD(.dep, .ttx)

	// Account ~p1 not coded for negative accrual
	if (CTL = 1 ! (CTL=2) ! (CTL = 4)),'dep.negacrpo do Runtime.setErrMSG("DEP", 126, dep.cid) quit

	do FILE(.dep, .ttx, .trn)

	quit


AUT(RecordDEP dep, RecordTTX ttx)

	// Authorization Verification

	type public Boolean ER, TRB
	type public Number ACR, AIACR, AMT, CTL, SEGMENT, SEGVAL
	type public String OVR(,,)
	
	type Number RNDACR, RNDAMT

	// Not a Valid Segment for accrual
	if dep.segflg, 'SEGMENT.isNull(), 'SEGVAL do Runtime.setErrMSG("DEP", 7890) quit

	set RNDAMT = AMT
	set RNDAMT = RNDAMT.roundCur()

	if CTL = 3 do { quit:ER
		// Segments in Use Flag must be on
		if 'dep.segflg do Runtime.setErrMSG("DEP", 7893) quit

		// Available Interest Option must be 2
		if dep.iaf '= 2 do Runtime.setErrMSG("DEP", 7891) quit

		// Available Interest Accrual Flag must be on
		if 'dep.aiacrf do Runtime.setErrMSG("DEP", 7892) quit

		set RNDACR = AIACR
		set RNDACR = RNDACR.roundCur()

		// Compare transaction amount with accrued interest amount
		// Amount exceeds accrued interest
		if 'TRB, (RNDACR - RNDAMT) < 0 do Runtime.setErrMSG("DEP", 261) quit
		}

	if CTL '= 3 do { quit:ER
		set RNDACR = ACR
		set RNDACR = RNDACR.roundCur()

		// Compare transaction amount with accrued interest amount
		if 'dep.negacrpo, 'TRB do { quit:ER
			// Account ~p1 not coded for negative accrual
			if CTL = 1 ! (CTL = 2) ! (CTL = 4) do Runtime.setErrMSG("DEP", 126, dep.cid) quit

			// Amount exceeds accrued interest
			if (RNDACR - RNDAMT) < 0, 'dep.minacr.isNull(), dep.minacr ' <0 do Runtime.setErrMSG("DEP", 261) quit
			}
		}

	/*
	  Compare transaction amount with positive (CTL=0) accrued interest
	  or negative (CTL=1) accrued interest amount.
	*/
	if dep.negacrpo do { quit:ER
		type Number RNDNEG

		if CTL = 1 do {
			set RNDNEG = dep.negacr
			set RNDNEG = RNDNEG.roundCur()
			}
		if CTL = 2 do {
			set RNDNEG = dep.negacrun
			set RNDNEG = RNDNEG.roundCur()
			}
		if CTL = 4 do {
			set RNDNEG = dep.uncacr
			set RNDNEG = RNDNEG.roundCur()
			}

		// Amount exceeds negative accrued interest
		if CTL, TRB, (RNDNEG - RNDAMT) < 0 do Runtime.setErrMSG("DEP", 266) quit

		// Amount exceeds positive accrued interest
		if 'CTL, 'TRB, (RNDACR-RNDAMT) < 0 do Runtime.setErrMSG("DEP", 267) quit
		}

	// Restriction Flag
	if dep.rflg do ^UFLG(.dep)

	// Account Status
	if dep.stat set OVR(dep.cid, "OVR", "STAT"_+dep.stat) = ""

	// Outstanding anticipated int/div check <AECOUT>
	if dep.intchk set OVR(dep.cid, "OVR", "AECOUT") = dep.intchk

	quit


INIT(RecordDEP dep, RecordTTX ttx)

	// Initialize data
	
	type public Boolean TRB
	type public String TAMT
	type public Number ACR, AIACR, CTL, SEGEUR, SEGMENT, SEGVAL
	
	set TAMT = +ttx.tamt
	set TRB = dep.trb - ttx.itc1
	set ACR = +dep.posacr
	set SEGEUR = $$FIELD^UTSO(ttx.tso, "SEGEUR")
	set SEGVAL = 0

	if dep.segflg do {
		// Segment Number
		set SEGMENT = $$FIELD^UTSO(ttx.tso, "SEG")
		if dep.segacr ! (SEGEUR) do { quit
			// Segmented account - Accrue at account level
			if CTL=3 set AIACR = dep.aiacr
			}
		// Segmented account - Accrue at segment level
		// Ensure non-null value
		set SEGMENT = +SEGMENT

		type RecordDEPSEG depseg = Db.getRecord("DEPSEG", "CID=:dep.cid,SEGMENT=:SEGMENT")

		set SEGVAL = depseg.segval
		if CTL = 3 set AIACR = depseg.aiacr
		else  set ACR = depseg.posacr
		}

	quit


FILESEG(RecordTTX ttx, RecordDEP dep, Number AMT)

	type public Number ACR, AIACR, CTL, SEGMENT

	if 'dep.segacr do { quit
		// Accruing at segment level
		if 'CTL do {

			type RecordDEPSEG depseg = Db.getRecord("DEPSEG", "CID=:dep.cid,SEGMENT=:SEGMENT")

			// Positive accrual
			// Update depseg.posacr, dep.posacr, dep.taspm/taspnm
			set depseg.posacr =(ACR + AMT)

			// Positive Accrued Int/Div
			set dep.posacr = (dep.posacr + AMT)

			if SEGMENT=0 do {
				// Total Accrual on Segment Prin (Matured)
				set dep.taspm = (dep.taspm + AMT)
				}
			else  do {
				// Total Accrual on Seg Prin (Non-Matured)
				set dep.taspnm = (dep.taspnm + AMT)
				}

			do depseg.bypassSave()
			}

		if CTL=3 do {

			type RecordDEPSEG depseg = Db.getRecord("DEPSEG", "CID=:dep.cid,SEGMENT=:SEGMENT")

			set depseg.aiacr = (AIACR + AMT)

			// Available Interest Accrued
			set dep.aiacr = (dep.aiacr + AMT)

			if SEGMENT = 0 do {
				// Total Avail Int Accrual on Matured Seg
				set dep.taiams = (dep.taiams + AMT)
				}
			else  do {
				// Total Avail Int Accrual on Non-Mat Seg
				set dep.taianms  =(dep.taianms + AMT)
				}

			do depseg.bypassSave()
			}
		}

	// Accruing at account level
	if 'CTL do {

		// Positive Accrued Int/Div
		set dep.posacr = (ACR + AMT)

		// Total Accrual on Seg Prin (Non-Matured)
		set dep.taspnm = (dep.taspnm + AMT)
		}

	if CTL = 3 do {

		// Available Interest Accrued
		set dep.aiacr = (AIACR + AMT)

		// Total Avail Int Accrual on Matured Seg
		set dep.taiams = (dep.taiams + AMT)
		}

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60835^15877^Anitha Chandran^10215"	// Signature - LTD^TIME^USER^SIZE
