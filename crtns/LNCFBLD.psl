LNCFBLD
	/*	Generic Cash Flow Array Builder
	
	  ---- Revision History ------------------------------------------------

	   07/31/06 - KELLYP - CR 22048
	   	Modified FV and END sections to eliminate PRECEDENCE warnings.
	  
	   05/26/06 - KUMARB - CR 21464
	   	Modified AMO section, to change the if condition of teaser rate
	   	expired, and also modified section N2A  to redefined TEASRT 
	   	variable as public.
	   	Modified setion AMO, block "Distribution 1 Frequency" to 
	   	assign the value of NDD with NJD.

	   02/20/06 - KELLYP - CR 19338
	   	Modified AMO section to replace references to PCHND variable w/
	   	ln.pchnd to prevent an UNDEFINED error.  Also removed PCHND from
	   	the new list at the top of the procedure as it's no longer used.
	  
	   01/10/05 - MbuiM - CR 18952
	   	Modified N2A section to replace PMTPI variable with ln.pmtpi to 
	   	resolve undefined error.

	   05/13/05 - KinI - 15524
	   	Modified BIL section to retrieve LNBIL1 sub-fields directly
	   	rather then BP1 master field that is considered a special type
	   	of computed field under DBI standards.

	   02/02/05 - KELLYP - CR 13662
	   	Modified section N2A to prevent an undefined error from 
	   	occurring when creating a loan with an interest index
	   	defined.  Also modified section N2A to conform to PSL
	   	standards and removed pre-2003 revision history.

	   05/26/04 - KELLYP - CR 8446
		Fixed calls to CTL^UINDX.  The parameter list was wrong.

	   01/13/04 - Erik Scheetz - CR 7798
	   	Modified PCH section to use table LNCYCPTS rather
	   	than LNCYC which is being obsoleted.

	   07/10/03 - CARROLLJ - 51349
		Replaced call to NEW^LNPTCHG with call to NEW^PRCPMTCG.

	   01/17/03 - CARROLLJ - 51349
		PSL conversion cleanup.  Removed the NEW linetag.
	*/


	quit

public PCH(RecordLN ln,EFD) // Called from ^LNPTCHG to recalculate IRR at PCOFF.

	/*
	 Arguments: Section assumes that Base and %PR are around.
 
	. RecordLN ln  Loan object                      /TYP=object/REQ
 
 
	Returns:
 
	CF             Cash flow array
 
	Example:
 
	D PCH^LNCFBLD(.ln)
 
	*/

	new APR,CNT,%EXT,LNP,NEW,P,PCH,PLAN
	set (APR,CNT,%EXT,NEW)=0 
	set PCH=1

	// Distribution 1 Last Due - ldd will change
	set LDD=ln.dist1ld
	
	// Original Number of Payments
	set NUMPT=ln.onp
	
	/* 
	 If yield reculation is being done at payment change use new rate
	 and ln.pmtpi that is calculated in LNPTCHG. If yeild recalcualtion
	 is done based on a frequency use the account values.
	*/

	set TYP="PTS"
	type RecordLNCYCPTS lncycpts=Db.getRecord("LNCYCPTS","CID=:CID,TYP=:TYP",1)
	set PAYEE=lncycpts.payee
	set P=lncycpts.plan
	set PLAN=P

	if '$D(PLAN(P)) do {
		type RecordAOAMO aoamo=Db.getRecord("AOAMO","TYP=:TYP,PAYEE=:PAYEE,PLAN=:PLAN")
		set PLAN(P)=aoamo.rypc 
		}
		
	if 'PLAN(P) do {
		set (OIR,IRN,URATE,RATE)=ln.irn
		// Principal and Interest Payment
		set (ROP,PMT,NPMT,OPMT)=ln.pmtpi
		}
	
	// Promotional Rate
	if ln.trexd>%EffectiveDate,ln.trexd'<ODD set (OIR,IRN,URATE,RATE)=ln.trate,TEASRT=1
	else  set (OIR,IRN,URATE,RATE)=ln.irn set TEASRT=0
	
	do N2A(.ln)

	quit

	
public APR(RecordLN ln)	// Called from ^LNAPR to build CF.


	/*
	 Arguments: Section assumes that Base and %PR are around.
 
	. RecordLN ln  Loan object                      /TYP=object/REQ
 
 
	Returns:
 
	CF             Cash flow array
 
	Example:
 
	D APR^LNCFBLD(.ln)
 
	*/

	new APR,%EXT,NEW,PCH

	set (PCH,%EXT)=0 
	set (NEW,APR)=1

	do N1(.ln)
	quit


public	N1(RecordLN ln)


	new %EffectiveDate

	// Original Disbursement Date
	set %EffectiveDate=ln.odd
	// Distribution 1 Last Due
	set NDD=ln.dist1ld
	set (FDT,TDT,CNT)=""

	do N2(.ln)

	quit

	

public	N2(RecordLN ln) //


	// Original Number of Payments
	set NUMPT=ln.onp
	set AMBAS=ln.ambas
	// Promotional Rate
	set TRATE=ln.trate

	// Promotional Rate - Expiration Date
	if ln.trexd>%EffectiveDate do {
		set (OIR,IRN,URATE,RATE)=ln.trate 
		set TEASRT=1
		}
	else  do {
		set (OIR,IRN,URATE,RATE)=ln.irn 
		set TEASRT=0
		}
	set (ROP,PMT,NPMT,OPMT)=ln.pmtpi
	do N2A(.ln)
	quit

	
public	N2A(RecordLN ln) 

	type Public Boolean APR,ER,KEEPCF,KILLCF,NEW,PCH,TEASRT,%EXT
	type Public Date NDD
	type Public Number BASE,CNTC,IRN,OIR,RATE,TRATE,URATE
	type Public String CF(),X,%V(),%VJ()

	type Boolean GEM,ICRC,ISTP,PCRC,PSTP,RARC,RSTP
	type Date ANIRND,ANPTND,ICHND,JD,NJD,SPCHND
	type Number ACNT,AF,ANIRO,ANPTO,CHG,FVCNT,ICAF,ICNT,IRO,NPFV,NSIP,PCAF,PCNT,PMTORG,PTCNT,RAAF,RCNT,SPPINC,TCHG
	type String IACM,PCM

	set (ICRC,NSIP,PCRC,RARC)=1
	set (PTCNT,ACNT,NPFV,PSTP,RSTP,ISTP,ICNT,FVCNT,RCNT,PCNT,TCHG,CHG,GEM)=0

	// Build CF array for add-on/discount loans
	if ln.iam do { quit
		kill CF

		set CHG=ln.onp-ln.cntcr 
		set NDD=ln.mdt
		do CF
		}

	// Interest Accrual Method
	set IACM=ln.iacm
	
	// Payment Calculation Method
	set PCM=ln.pcmval
	
	set SPCHND=ln.rand
	set SPPINC=ln.ppinc
	
	// Original Int/Div Rate
	set IRO=ln.iro 
	if 'IRO set IRO=IRN
	
	// Payment Amount - Original
	set PMTORG=ln.pmtorg 
	if 'PMTORG set PMTORG=ln.pmtpi
	
	// Annual Rate Limit - Original Rate
	set ANIRND=ln.anirnd 
	set ANIRO=ln.aniro
	
	// Annual Pmt Limit - Next Change Date
	set ANPTO=ln.anpto 
	set ANPTND=ln.anptnd
	
	// P&I Payment Change Next Date
	if ln.pchnd,'PCH do TINI(.ln)
	
	if 'CNTC.exists() set CNTC=0

	// Payment Change Method
	if ln.pchm=2!(ln.pchm=3) do {
		set GEM=1 
		if PCH set CNTC=CNTC+1   
		}

	// Int/Div Change - Next Date
	set ICHND=ln.ichnd
	set JD=ln.dist1ld

	// Int/Div Check Frequency
	if 'ln.intfre.isNull() do { quit:ER
		
		set NJD=$$NJD^UFRE(%SystemDate,ln.intfre,.AF) quit:ER
		set ICAF=$$^SCARND(ln.dist1af/AF,0,"","",0) quit:ER
		if ICAF quit
		
		set ISTP=1
		set ICHND=""
		
		if ln.trexd>ln.dist1ld do {
			
			set RATE=ln.trate 
			set TEASRT=1
			}
		else  do {
			
			type Number RRATE,SRATE
			type String PAR
			
			set ISTP=1 
			set TEASRT=0

			set PAR("MATRIX")=ln.intmat
			do CTL^UINDX(.ln,NDD,BASE,.PAR)
			}

		set OIR=RATE
		set IRN=RATE
		set ICHND=""
		}
	
	// Re-amortization - Next Date
	if 'ln.rand.isNull(),'ln.rafre.isNull() do { quit:ER
		set NJD=$$NJD^UFRE(ln.rand,ln.rafre,.AF) quit:ER
		set RAAF=$$^SCARND(ln.dist1af/AF,0,"","",0) quit:ER 
		}

	if 'ln.pchnd.isNull(),'ln.pcfre.isNull() do { quit:ER
		set NJD=$$NJD^UFRE(ln.pchnd,ln.pcfre,.AF) quit:ER
		set PCAF=$$^SCARND(ln.dist1af/AF,0,"","",0) quit:ER
		}
	
	/* 
	 NSIP indicates whether the loan has a non-standard rate of
	 amortization.
	
	 If the loan rate is fixed, at a premium, or at a discount with no
	 prepayment penalty, or a prepayment penalty that is not 100% of term,
	 amortize to 0.00 net def fee.  In this case, NSIP is set to 1, and
	 amortization will cease at 0.00 net def fee.  This is the "standard"
	 method of handling net def fee amortization for all loans, except
	 those under methods 2 and 3.
	
	 If the loan rate is at a discount with 100% of term prepayment
	 penalty, NSIP will be set to 2.  Amortization will run to maturity,
	 but the amount required to satisfy the loan will be checked.  
	*/
	
	// ^LNNEW gave us a good CF array
	if GEM,(APR!(NEW)) set PCRC=0
	if ICHND do { quit:ER

		if ln.trexd>NDD do {
			set RATE=TRATE 
			set TEASRT=1       
			}
		else  do {
			type Number RRATE,SRATE
			type String PAR()
			
			set PAR("MATRIX")=ln.intmat
			
			do CTL^UINDX(.ln,NDD,BASE,.PAR)
			set TEASRT=0
			}

		if ER!(RATE'=IRN)!(URATE'=IRN) do {
			set RATE=IRN
			set URATE=IRN
			}
		
		if ((URATE=IRN)&('TEASRT))!('$L(ln.intoff)) do { quit:ER
			set ISTP=1 
			set ICRC=0 
			if 'GEM set PCRC=0 
			}
		if ((NEW!'%EXT)!(URATE>IRN)!(URATE=IRN)) do {
			set NSIP=1
	
			/* 
			 Check the loan product type to see what the prepayment percentage
			 of term is.  If the prepayment percentage of term is not 100%,
			 we cannot amortize  
			*/

			type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")
			if prodctl.eppoff'=100 quit
			
			set NSIP=2
			}
		}
	
	if 'ICRC,APR,'GEM set PCRC=0
	if 'ICHND set ISTP=1 set ICRC=0
	if 'ln.pchnd set PSTP=1 set PCRC=0
	if 'ln.rand set RSTP=1 set RARC=0
	
	// We are at an interest change date now.
	if ln.pchnd,PCH set PCRC=0
	
	// External call always builds CF
	if %EXT do AMO(.ln) quit
	
	// If for some reason we know we cannot use the existing CF, proceed.
	if KILLCF.get() quit 
	
	// If this is a standard new loan, do not subject it to this processing,
	// as ^LNNEW has already built a good CF.
	if KEEPCF.get() quit
	if NEW,'PCH,'ICRC,'PCRC,'RARC quit
	if 'PCH,'PCRC,'RARC quit

	kill X if '%EXT kill CF
	// KEEPCF indicates that we are building a good CF that may be reused
	// (if there's no KILLCF).
	set KEEPCF=1 set %V("KEEPCF")="" set %VJ("KEEPCF")=""
	do AMO(.ln)

	quit

public AMO(RecordLN ln) // Amortize balance after CHG payments

	new DONE
	set DONE=0
	
	/*
	   We must calculate payment by payment using ^UFRE until we reach the
	   first occurrance of a payment change, rate change, and/or reamorti-
	   zation.  Once all of these processes have been executed once we know
	   what their frequency will be in relationship to one another.  This
	   relation is tracked by PCNT,RCNT,ICNT.  Once all have been reached,
	   we no longer need ^UFRE.
	
	   Go to AM1 only if no teaser rate in effect. Otherwise force to
	   calculate the next NDD to use it to validate the teaser expiration
	   date against it (section P).  If NDD would not be calculated for the
	   payment frequency and NDD never changed then the teaser rate would
	   remain in effect through the entire life of the loan resulting in
	   incorrect yield calculation.
	*/

	for  do { quit:DONE

		if '%EXT,'PCRC,'ICRC,'RARC,($E(PCM,3)'=2),'TEASRT set FVCNT=FVCNT+1
		else  do { quit:DONE
			// Distribution 1 Frequency
			set (LDD,JD)=NDD
			set NJD=$$NJD^UFRE(JD,ln.dist1fre) quit:ER
			if %EXT do { quit:ER
				if NJD>FDT quit
				for  do { quit:(NJD<FDT)
					set NJD=$$NJD^UFRE(JD,ln.dist1fre) quit:ER
					set (LDD,JD)=NJD 
					}
				if NJD>TDT do {
					do END(.ln) 
					set DONE=1
					}
				}
	
			set NDD=NJD
			set FVCNT=1
			do FV(.ln)
			if BASE'<0 quit
			set BASE=SV 
			do END(.ln) 
			set DONE=1 
			} 
			
		/* 
		   TCHG counts the total number of passes through this loop and is com-
		   pared to the original number of payments to know when to stop.
		   CHG counts the number of passes between cash flow entries.
		*/
	
		set CHG=CHG+1 
		set TCHG=TCHG+1
		if 'PCRC set PCNT=PCNT+1
		if 'RARC set RCNT=RCNT+1
		if 'ICRC set ICNT=ICNT+1
		
		// If the loan is a discount or premium AML, recalculate the new rate.
		// Has the loan gone through int calc?
		set XIRN=0 if GEM set XIRN=1
		if 'ISTP do { quit:ER
			if 'ICRC,ICHND,'(ICNT#ICAF) do {
				do FV(.ln)
				set OIR=IRN
				if BASE'>0 quit 
				if ln.trexd>NDD 
				set RATE=TRATE 
				set TEASRT=1
				else  do {
					new INDEX,MATRIX                     
					set INDEX=$$INDDATA^LNU(.ln)    
					set par("INDEX")=INDEX
					set par("MATRIX")=ln.intmat
					do CTL^UINDX(.ln,NDD,BASE,.par)
					set TEASRT=0
					}
				set IRN=+RATE
				set XIRN=1
				set ACNT=ACNT+ICAF
				set ANSTP=0
				}
				
			if ICRC,NDD'<ICHND do {
				do FV(.ln)
				set OIR=IRN
				if BASE'>0 quit 
				if ln.trexd>NDD set RATE=TRATE set TEASRT=1
				else  do {
					new INDEX                
					set INDEX=$$INDDATA^LNU(.ln) 
					set par("INDEX")=INDEX
					set par("MATRIX")=ln.intmat
					do CTL^UINDX(.ln,NDD,BASE,.par)
					set TEASRT=0
					}
				set IRN=+RATE 
				set XIRN=1 
				set ICRC=0 
				set ACNT=ACNT+ICAF 
				set ANSTP=0
				}
			
			// Update the annual rate limits
			if $G(ANIRND)="" quit
			if 'ACNT!(ACNT#(ln.dist1af/ICAF)) quit
			if ANSTP quit
			if ANIRND do {
				set ANIRND=$$NJD^UFRE(ANIRND,"1YA") quit:ER
				set ANIRO=IRN 
				set ANSTP=1
				}
			}

		if 'XIRN set OIR=IRN
		
		set CAL=0
		// There's no need to calc reamortization
		if 'RSTP do { quit:ER
		
			if 'RARC,ln.rand,'(RCNT#RAAF) do {
				set %RAOFF=""
				do RA(.ln) 
				do FV(.ln) 
				do PMT(.ln) 
				do CF
				kill %RAOFF
				set CAL=1
				set ln.ppinc=SPPINC
				set ln.pchnd=SPCHND
				}
		
			if RARC,NDD'<ln.rand do {
				set %RAOFF=""
				do RA(.ln) do FV(.ln) do PMT(.ln) do CF
				kill %RAOFF
				set CAL=1
				set RARC=0
				set ln.ppinc=SPPINC
				set ln.pchnd=SPCHND
				}
			}
		// Calculate a new PMT, check limits.  Process only if CAL=0 (Hasn't
		//   gone through reammo)
	
		if $E(PCM,3)'=2 do { quit:ER
		
			if ln.pchm,'PCRC,ln.pchnd,'CAL,'(PCNT#PCAF) do {	
				do FV(.ln) 
				do PMT(.ln)
				if BASE'>0 quit 
				if 'GEM do {
					do TINI(.ln) 
					do NEW^PRCPMTCG(.ln)

					}
				set PTSTP=0
				set PTCNT=PTCNT+PCAF
				if NPMT'=OPMT set CAL=1 do CF
				}
	
			if ln.pchm,PCRC,'CAL,(NDD'<ln.pchnd) do {
				do FV(.ln) 
				do PMT(.ln)
				if BASE'>0 quit 
				if 'GEM do TINI(.ln) do NEW^PRCPMTCG(.ln)
				set PTSTP=0
				set PTCNT=PTCNT+PCAF
				if NPMT=OPMT quit 
				do CF
				set CAL=1
				set PCRC=0
				}
			/*
			 If teaser rate expired restore the fixed rate from the account
			 and recalculate the payment for that rate. Save the current CF
			 entry for the teaser rate. This is only valid if the account has
			 a teaser rate and the fixed rate. We do not enter this section
			 for accounts with indexed interest rates.
			*/

			if ln.pchm,'CAL,(NDD'<ln.trexd),TEASRT,'ICRC,'PCRC do {
				set IRN=ln.irn
				do FV(.ln)
				do PMT(.ln)
				if BASE'>0 quit 
				if 'GEM do {
					do TINI(.ln) 
					do NEW^PRCPMTCG(.ln)
					}
				set PTSTP=0
				if NPMT=OPMT quit 
				do CF
				set CAL=1
				set PCRC=0
				}
			
			// Update the annual payment limits
			if '$L(ANPTND)!(PTSTP)!('PTCNT!(PTCNT#(ln.dist1af/PCAF))) new GONE
			else  do { 
				set ANPTND=$$NJD^UFRE(ANPTND,"1YA") quit:ER
				set ANPTO=OPMT 
				set PTSTP=1
				}
			}
		if '$L(ANPTND)!('PTCNT!(PTCNT#(ln.dist1af/PCAF)))!(PTSTP) new GONE
		else  do {
			set ANPTND=$$NJD^UFRE(ANPTND,"1YA") quit:ER
			set ANPTO=OPMT
			set PTSTP=1
			}

	  	//   Original P+I loans
		if $E(PCM,3)=2 do {
			set %LD=LDD 
			set %ND=NDD 
			set %BAL=BASE 
			set %INT=$$^UIC($G(%BAL),$G(%LD),$G(%ND),$G(IACM),$G(IRN),C,$G(DIST1AF),$G(DIST1FRE),$G(ICPF),$G(SCHND),$G(SCHLD))
			set %DY=$$DY^UIC($G(IACM),$G(%ND))
			set INT=$$^SCARND(%INT+.005,0,$G(CID))
			set NPMT=INT+(PMTORG-$$^SCARND(INT*IRO/IRN,0,$G(CID))) set NUMPT=2
			do:NPMT'=OPMT CF
			}

		/*
		 If the calculated index rate (RATE) agrees with the current loan rate
		   (IRN) then we can stop calculating interest rate changes (ISTP), as
		   long as the loan isn't a GPM or IEM we can stop calculating payments
		   too (PSTP).
		*/

		if ('ISTP),((URATE=IRN)&('TEASRT)) do {
			set ISTP=1 
			if 'GEM,$E(PCM,3)'=2 set PSTP=1
			}
		/*
		 If the loan has reached its end (TCHG equals the original number of
		 payments), or if the balance is fully amortized, we can stop.
		*/

		if ((TCHG=ln.onp)!(BASE<NPMT)) do {
			do END(.ln) 
			set DONE=1 
			}
		}
	quit

END(RecordLN ln)
	if CHG do {
		do CF
		set CNT=CNT-1
		set ln.ppinc=SPPINC
		set ln.pchnd=SPCHND
		do FV(.ln)
		set CNT=CNT+1
		}
	else  do {
		set ln.ppinc=SPPINC
		set ln.pchnd=SPCHND
		do FV(.ln)
		}
	
	if %EXT quit:BASE'<NPMT 
	set P=+CF(CNT) 
	set N=$P(CF(CNT),"|",2)-1 
	set END=$P(CF(CNT),"|",3,999)

	if 'N set CNT=CNT-1
	if N set CF(CNT)=P_"|"_N_"|"_END

	set IR1=IRN/(ln.dist1af*100)
	set B=$$^SCARND((1+IR1)*BASE,0,$G(CID))
	set CF(CNT+1)=(NPMT+B)_"|1|"_END

	kill CF(CNT+2)
	
	quit
	
CF	// Place entry in CF array.
	set CNT=CNT+1
	set CF(CNT)=OPMT_"|"_CHG_"|"_OIR_"||||"_$G(NDD)
	set CHG=0 
	set OPMT=NPMT
	quit 
	

PMT(RecordLN ln) // Calculate new P+I.

	if BASE<.01 quit 
	set NUMPT=ln.onp-TCHG 
	if 'NUMPT quit 
	
	// Payment Percentage Increase

	if GEM do { quit:CNTC'<NUMCH
		set NPMT=$$^SCARND(OPMT*(ln.ppinc/100+1),0,$G(CID)) 
		set CNTC=CNTC+1 
		set:CNTC=NUMCH PSTP=1
		}

	set IR=IRN/(ln.dist1af*100)
	set (POW,X)=1+IR
	set N=AMBAS-TCHG 
	quit:N=0 
	set EXP=1/$$EXP^%ZFUNC($$LNX^%ZFUNC(POW)*N)
	set RNP=BASE/((1-EXP)/IR)

	// If the change in payments is very small, make no change

	set X=ROP-RNP 
	if X>-.01,X<.01 set RNP=ROP
	set PMT=$$^SCARND(RNP,0,$G(CID)) 	
	set ROP=RNP
	
	if $D(%RAOFF) set NPMT=PMT
	quit 
	

FV(RecordLN ln)	// Calculate the future value of a loan.

	if 'FVCNT quit 
	if BASE<.01 quit 
	set SV=BASE
	set IR1=IRN/(ln.dist1af*100) 
	set (EXP,X)=1+IR1
	set EXP=$$EXP^%ZFUNC($$LNX^%ZFUNC(EXP)*FVCNT)
	set BASE=$$^SCARND((((1-EXP)/IR1)*OPMT)+(BASE*EXP),0,$G(CID))
	if BASE>0 set FVCNT=0 quit 
	
	set BASE=SV 
	set EXP=1+IR1
	if FVCNT<CHG set CHG=CHG-FVCNT
	else  set CHG=0

	/*
	 If the loan would payoff during this period, amortize pts one by one.
	 Stop processing when if the payment is equal to the max payments.
	 Otherwise the payment is too low.
	*/
	
	for  do { quit:((BASE<0)!(CHG=FVCNT))
		set CHG=CHG+1
		set BASE=$$^SCARND((((1-EXP)/IR1)*OPMT)+(BASE*EXP),0,$G(CID))
		}

	quit

TINI(RecordLN ln) // Initiate P+I change data.

	// Payment Amount - Original
	set PMTORG=ln.pmtorg
	// P&I Chg Max $ Inc - Life
	set PMXDIC=ln.pmxdic 
	set PMXDIL=ln.pmxdil
	// P&I Chg Max $ Dec - Life
	set PMXDDC=ln.pmxddc 
	set PMXDDL=ln.pmxddl
	// P&I Chg Max % Inc - Life
	set PMXPIC=ln.pmxpic 
	set PMXPIL=ln.pmxpil
	// P&I Chg Max % Dec - Life
	set PMXPDC=ln.pmxpdc 
	set PMXPDL=ln.pmxpdl
	// P&I Chg Max % Dec - Per Year
	set PMXPIY=ln.pmxpiy 
	set PMXPDY=ln.pmxpdy
	// P&I Chg Max $ Dec - Per Year
	set PMXDIY=ln.pmxdiy 
	set PMXDDY=ln.pmxddy
	// Annual Pmt Limit - Next Change Date
	set ANPTO=ln.anpto 
	set ANPTND=ln.anptnd
	// P&I Chg Min $ Dec - Per Chg
	set PMNDIC=ln.pmndic 
	set PMNDDC=ln.pmnddc
	// Number of Completed Payment Changes
	set NUMCH=ln.numch 
	set CNTC=ln.cntc
	quit 

RA(RecordLN ln) // Initialize Reamortization Data.

	set SPCHND=ln.rand
	set SPPINC=ln.ppinc
	set ln.pchnd=ln.rand 	
	set ln.ppinc=0
	quit 
	
BIL(RecordLN ln) // Build CF array for advance entries in the bill file.

	set CNT=0
	
	set NDD=ln.lbdd		  // Last Bill - Loan Due Date Billed	
	if 'NDD set NDD=ln.schld  // Scheduled Payment - Last Date
	
	set B=ln.schseq
	
	set %PPA=ln.ppa		  // Payment - Partial Amount

	if ln.dseq>ln.schseq set B=ln.dseq-1
	if 'B set B=0

	type ResultSet rs=Db.select("CPIB,CDPD","LNBIL1","SCHSEQ>=:B")
	while rs.next() do {
		set C=rs.getCol("CPIB")-%PPA
		set %PPA=0
		if C set CNT=CNT+1 set CF(CNT)=C_"|1|||||"_rs.getCol("CDPD")
		}
	
	quit 
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60477^65449^Pat Kelly^17446"	// Signature - LTD^TIME^USER^SIZE
