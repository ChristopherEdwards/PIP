PATCALC	 /*
  ORIG: AGARWALS - 11/24/1999
  DESC: Procedure to verify and calculate PAT amounts. This is called by 
        the batch definition BCHPATAUTO (PROC^PATCALC) and procedure 
 	MRPC092 (CAL^PATCALC). It was copied from BCHPATAUTO (EXEC section) 
       	and the multicurrency logic was added to it.
  
  ---- Comments --------------------------------------------------------
  
  ---- Revision History ------------------------------------------------
  	09/11/06 - GIRIDHAL - CR22221
  		   Made the TAMT variable Public in the PAYOFF section
  		   since it is being set earlier on in the procedure and
  		   used in the PAYOFF section.
  		   
	06/22/06 - NATRAJAH - CR21284
		   Replaced TranSet with RecordTTX object and called 
		   TRNSET^TRNDRV instead of ts.postTset, to update
		   rejected transaction in EXC table.
	
 	02/17/06 - PUTTASWH - CR17988
 		   Modified the code to correct the host errors.
 		   		
 	11/29/05 - PUTTASWH - CR17988
 		   Modified the code according to DBI standards.
 	
	05/07/03 - CARROLLJ - 51349
		   Removed the use of the %a array.
   -----------------------------------------------------------------------
 */
 
	quit	

	// Process a batch
public PROC(String SRC,	// Source Code
	Number ACN,	// Customer Number
	Number BATCH)	// Batch	 
	
	type public Boolean ER,PATFEE	
	type public Number REJMET
	type public String RM	
	type Boolean FAIL,POFF,rflg,rty
	type Number CHCID,CID,ITC,NEXTSEQ,RATE,RPASEQ,SEQ,stat,tsseq,TYPE
	type String BCMT,CCODE,CLS,CRCDBASE,CT,ETC,RJ(),SPR,TAMT,TCMT,TSO,trx(),Y 	
	
	type String PAT()
	type RecordTTX ttx()
	
	type RecordPAT1 pat1=Db.getRecord("PAT1","SRC=:SRC,ACN=:ACN,BATCH=:BATCH",1)
	if pat1.start>%SystemDate quit		 	// Start date
	if pat1.stop,pat1.stop'>%SystemDate quit	// Expiration date
	set CHCID=pat1.chcid			       	// Fee account
	set BCMT=pat1.cmt
	set CRCDBASE=pat1.CRCD
	set CCODE=pat1.CCODE
	if CCODE="" set CCODE=0
	set ER=0
	do VER(1,SRC,ACN,BATCH,.PAT(),CCODE,CRCDBASE,.POFF) if ER quit 
	
	set (ER,NEXTSEQ,SEQ)=0
	
	for  set NEXTSEQ=PAT(NEXTSEQ).order() quit:NEXTSEQ.isNull()  do { quit:ER	
		
		set CID=PAT(NEXTSEQ).piece("|",2)
		set TAMT=PAT(NEXTSEQ).piece("|",3) if 'TAMT quit
		set RATE=PAT(NEXTSEQ).piece("|",19)
 
		set SEQ=SEQ+1
		set ttx(SEQ)=Class.new("RecordTTX")
		set ttx(SEQ).cid=CID
		set ttx(SEQ).etc=PAT(NEXTSEQ).piece("|",1)
		set ttx(SEQ).tamt=TAMT
		set ttx(SEQ).rate=RATE
		set ttx(SEQ).bcrcd=pat1.CRCD
		set ttx(SEQ).bseamt=PAT(NEXTSEQ).piece("|",20)
		set ttx(SEQ).crcd=PAT(NEXTSEQ).piece("|",18)
		set SPR=""
		set ETC=PAT(NEXTSEQ).piece("|",1)
		
		type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC",1)
		set ITC=trn.itc
		set ttx(SEQ).itc=ITC
		set CLS=trn.cls
		set TSO=PAT(NEXTSEQ).piece("|",8)
		if TSO="" set TSO=PAT(NEXTSEQ).piece("|",7)
		if TSO["SPR" set SPR=TSO.piece("SPR=",2),TSO=""
		if SPR'="" set ttx(SEQ).spr=SPR
 
		// PAT source and fee account
		set TSO=$$FIELDIN^UTSO(TSO,"PAT",SRC)
		if PATFEE,CHCID do {
			set TSO=$$FIELDIN^UTSO(TSO,"SRVCID",CHCID)
			set TSO=$$FIELDIN^UTSO(TSO,"PATB",BATCH)
			set TSO=$$FIELDIN^UTSO(TSO,"PATA",ACN)
			}
			
		if CLS="D" do {  quit:ER						
			
			type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
			set TYPE=dep.type
			if TYPE="" set ER=1 do ERR(.PAT(),SRC,ACN,BATCH,.POFF) quit
			set RPASEQ=dep.rpaseq
			
			// Get default reason code
			if (RPASEQ)&($$FIELD^UTSO(TSO,$S(ITC.extract():"IRAC",1:"IRAD")).isNull()) do {		
				type RecordIRATYPE iratype=Db.getRecord("IRATYPE","ACN=:dep.acn,RPASEQ=:RPASEQ",1)
				set Y=$S(ITC.extract():iratype.iracon,1:iratype.iradis)
				if Y="" set Y=$S(ITC.extract():iracon,1:iradis)
				set TSO=$$FIELDIN^UTSO(TSO,$S(ITC.extract():"IRAC",1:"IRAD"),Y)
				}
			
			}
			
		set TCMT=BCMT
		
		if ("*M"[CLS)&(trn.cktyp) do {	// See if this is a check transaction
			set CT="^"			
			set TCMT=CT_$TR(PAT(NEXTSEQ).piece("|",6,14),"|",CT)
			} 
			
		set ttx(SEQ).tcmt=TCMT
		set ttx(SEQ).tso=TSO
		set ttx(SEQ).crcd=PAT(NEXTSEQ).piece("|",18)
		
		}
 
	do TRNSET^TRNDRV(.ttx(),TPD,BRCD,4,,.RJ())
 
	if PATFEE,CHCID do {				    
		
		set tsseq="",rflg=0
		for  set tsseq=ttx(tsseq).order() quit:tsseq.isNull()  do { quit:rflg
			
			set FAIL=0
			
			set rty=ttx(tsseq).rty

			if REJMET>0 set stat=RJ.data(),rflg=1
			else  set stat=RJ(tsseq).data()
			/*
			FAIL=0 (Successful) - Process PATS fee
			FAIL=1 (Failed no more retries) - Process PATF fee
			FAIL=2 (Failed with more retries) - No fee at this time
			*/
			// Successful Batch - Calculate batch successful fee
			if 'stat quit	 // FAIL=0
 
			// Failed Batch (Rejected) - Only calculate fee when no
			// more retries are remaining.
			if stat,rty set FAIL=2
 
			// Failed Batch (Rejected) - No more retries, calculate
			// batch fail fee. (stat,'rty)
			else  set FAIL=1			
			}
			
		if FAIL=0 do FEE^PATFEE("PATS",CHCID)
		if FAIL=1 do FEE^PATFEE("PATF",CHCID)
		
		}
	quit
 
	// Calculate all variable amounts and verify a distribution. 
public CALC(String SRC,	// Source Code
	Number ACN,	// Customer Number
	Number BATCH,	// Batch
	String PAT())	// Record PAT 
 
	type public Boolean ER
	type Boolean POFF
	type Number SEQ
	type String CCODE,CRCDBASE	
	
	type RecordPAT1 pat1=Db.getRecord("PAT1","SRC=:SRC,ACN=:ACN,BATCH=:BATCH",1)
	if pat1.getMode() do {	
		set CRCDBASE=pat1.CRCD
		if CRCDBASE="" set CRCDBASE=%SystemCurrency
		set CCODE=pat1.CCODE 
		if CCODE="" set CCODE=0
		set ER=0
		do VER(0,SRC,ACN,BATCH,.PAT(),CCODE,CRCDBASE,.POFF) if ER quit
		set SEQ=""
	}
	quit
 
	// Calc payoff amount
PAYOFF(RecordLN ln,		// Record LN
	Boolean ITC,		// ITC
	String PAT(),		// Record PAT
	Number NET,		// Net Amount
	Number SEQ,		// Sequence Number
	Boolean VAR,		// Amount Indicator
	Boolean POFF,		// Payoff Indicator	
	String SRC,		// Source
	Number ACN,		// Customer Number
	Number BATCH)		// Batch	 	

	type public Boolean ER
	type public String RM,TAMT	
	type Boolean ZITC
	type Date EFD
	type Number acr,bal,DIFF,ETC,N,PAYOFF,ppf,pytd,TYPE,ZAMT
	type String CRCD,ETC,ZTC

	
	// Don't pay off revolving accts, interim or deferred student loans
	if ln.revf quit
	if (ln.idpf=1)!(ln.idpf=3) quit
 
	set TYPE=ln.type
	set CRCD=ln.crcd
	set POFF=0,EFD=%SystemDate
 
	set ppf=ln.ppf
	set bal=ln.bal
	set acr=ln.acr
	set pytd=ln.pytd 
	
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE",1)
 
	// Calculate payoff amount - if account has an error, don't post batch
	// ~p1 - account ~p2	
	type RecordTTX ttx=Class.new("RecordTTX")
	do PAYOFF^LNPO2(.ln,0,.ttx) if ER set RM=$$^MSG(3004,RM,ln.cid) do ERR(.PAT(),SRC,ACN,BATCH,.POFF),PAY3 quit
	set PAYOFF=$$^SCARND(PAYOFF,0,ln.cid) if PAYOFF>TAMT do PAY3 quit
 
	// Account ~p1 payoff not allowed
	if 'prodctl.popat set ER=1,RM=$$^MSG(145,ln.cid) do ERR(.PAT(),SRC,ACN,BATCH,.POFF),PAY3 quit
 
	// Account ~p1 payoff amount $~p2
	if PAYOFF<0 set ER=1,RM=$$^MSG(144,ln.cid,$$^SCARND(PAYOFF,0,ln.cid)) do ERR(.PAT(),SRC,ACN,BATCH,.POFF),PAY3 quit
 
	// Account will be paid off
	set ETC=prodctl.crtrci
 
	// Loan payoff
	set RM="",PAT(SEQ).piece("|",4)=$$^MSG(6875),PAT(SEQ).piece("|",1)=ETC
 
	set DIFF=0,POFF=1
	if +TAMT set DIFF=TAMT-PAYOFF
	set TAMT=PAYOFF
	if VAR do PAY3 quit	
 
	// No variable amounts are used - subtract difference from constants		
	
	set N=0
	if ITC set NET=NET+DIFF
	if 'ITC set NET=NET-DIFF	 
	
	for  set N=N+1 quit:'(PAT(N).exists())  do {
		
		set ZTC=PAT(N).piece("|",1)	
		 
		type RecordTRN trn=Db.getRecord("TRN","ETC=:ZTC",1)
		set ZITC=trn.itc
		if ZITC=ITC quit
		set ZAMT=PAT(N).piece("|",3)
		if DIFF>ZAMT set DIFF=DIFF-ZAMT,PAT(N).piece("|",3)="" quit
		set PAT(N).piece("|",3)=ZAMT-DIFF,DIFF=0
		}
	do PAY3
	quit
 
PAY3    kill %ACM,%ACR,%DY,%INF,%REPEAT,ACR,ADJ,AF,BAL,BALINT,CNT,DIST1AF
	kill ECID,EFD,EPPEN,GRP,IACM,IAM,INF,INTESC,IRCB,IRN,IUN,IUNC,KVAR
	kill LNPO,MDT,MLT,ODD,ONP,OPCHG,OPCHGSV,PAYACM,PAYOFF,PLDF,PMTGRC
	kill PREREB,SCHNUM,TRM,TY,VALDATE
	quit
	
	
	//  Verify this batch for variable amounts and loan payoffs
VER(Boolean MODE,		// Mode 
	String SRC,		// Source
	Number ACN,		// Customer Number
	Number BATCH,   	// Batch Number 
	String PAT(),		// Record PAT	
	String CCODE,		// Customer Code
	String CRCDBASE,	// Currency Code
	Boolean POFF)		// Payoff Indicator
	// MODE=0 means calculate but do not update database. 
	// MODE=1 means calculate and update database.

	type public Boolean ER
	type public String RM
	type Boolean ITC,VAR
	type Number AMT,AST,bal,CID,DC(),EXCAMT,HLD,I,NET,RATE,SEQ,stat,trb
	type String CLS,CRCD,ETC,NC,TAMT,X		
	
	set (NET,VAR,ER,SEQ)=0 
	
	type ResultSet rs=Db.select("SEQ","PAT","SRC=:SRC AND ACN=:ACN AND BATCH=:BATCH")
	
	while rs.next() do {
		set I=rs.getCol("SEQ")		
		
		 // Load sequence from the batch
 
		type RecordPAT pat()
		set pat(I)=Db.getRecord("PAT","SRC=:SRC,ACN=:ACN,BATCH=:BATCH,SEQ=:I",1)
		if 'pat(I).amount set VAR=1
		set ETC=pat(I).trncd 
		
		type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC",1)
		if trn.cls="M" do {
			if trn.acn="" quit
			if pat(I).cid=trn.acn quit
			set pat(I).cid=trn.acn
			set PAT(I).piece("|",2)=pat(I).cid
			do pat(I).bypassSave()
			}		
		set HLD(I)=pat(I).amount		
			
		set PAT(I)=pat(I).trncd_"|"_pat(I).cid_"|"_pat(I).amount_"|"_pat(I).start_"|"_pat(I).stop_"|"_pat(I).ckacn_"|"_pat(I).cknam1
		set PAT(I)=PAT(I)_"|"_pat(I).cknam2_"|"_pat(I).ckaddr1_"|"_pat(I).ckaddr2_"|"_pat(I).ckaddr3_"|"_pat(I).city_"|"_pat(I).state
		set PAT(I)=PAT(I)_"|"_pat(I).mzip_"|"_pat(I).ckmemo_"||"_pat(I).cntry_"|"_pat(I).crcd_"|"_pat(I).rate_"|"_pat(I).bseamt
		}
	
	kill HLD for I=0,1 set DC(I)=0	
	
	for  set SEQ=PAT(SEQ).order() quit:SEQ=""  do { 
		set ETC=PAT(SEQ).piece("|",1)
		set CID=PAT(SEQ).piece("|",2)
		set TAMT=PAT(SEQ).piece("|",3)
		set CRCD=PAT(SEQ).piece("|",18)
		if CRCD="" set CRCD=CRCDBASE		
		
		type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC",1)
		set ITC=trn.itc.extract()
		set CLS=trn.cls
		if (CLS="L")!(CLS="D") do {  if ER quit
			
			type RecordACN acn=Db.getRecord("ACN","CID",1)			
			if 'acn.getMode() do ERR(.PAT(),SRC,ACN,BATCH,.POFF) quit   // Error
			set stat=acn.stat
			if (stat=4) do { quit   // Account is closed
				set ER=1,RM=$$^MSG(8449)
				do ERR(.PAT(),SRC,ACN,BATCH,.POFF)
				}
			set trb=acn.trb
			set bal=acn.bal
			
			}
		if TAMT="*" set AST=SEQ quit		
 
		// Don't execute if TAMT=0, only if TAMT is mnemonic
 
		if 'TAMT,'(TAMT=+TAMT) do {  if ER do ERR(.PAT(),SRC,ACN,BATCH,.POFF) quit
			if TAMT["_NC" set NC="" set TAMT=TAMT.piece("_",1)
			set TAMT=$TR(TAMT,"_")
			set X=TAMT_"^PATOPT"
			do @X
			kill NC
			}
		// Cannot process.  Amount equals $~p1.
	  	if (TAMT'>0)&(MODE) do {  quit
			set ER=1,RM=$$^MSG(472,$$^SCARND(TAMT,0,CID)) 
			do ERR(.PAT(),SRC,ACN,BATCH,.POFF)
			}			
		type RecordLN ln=Db.getRecord("LN","CID",1)
		if $$PAYOFF^UANTICLN(.ln,TAMT) do PAYOFF(.ln,ITC,.PAT(),.NET,SEQ,VAR,.POFF,SRC,ACN,BATCH) quit:ER

		set EXCAMT=TAMT,RATE=1
		if CRCD.get()'=CRCDBASE.get() do {
			do EXC^CRCDUTL(CRCDBASE,CRCD,TAMT,0,'ITC,"00",CCODE,,1)
			}
		set EXCAMT=$$^SCARND(EXCAMT,,,CRCD)
		
		set PAT(SEQ).piece("|",20)=EXCAMT
		set PAT(I).piece("|",19)=RATE		
		set NET=NET+$S(ITC:EXCAMT,1:-EXCAMT)
		if MODE set PAT(SEQ).piece("|",3)=TAMT		
		
		set DC(ITC)=DC(ITC)+TAMT
		}
	
        // All amounts within this batch are zero
	if 'DC(0),'DC(1),MODE set ER=1,RM=$$^MSG(239) do ERR(.PAT(),SRC,ACN,BATCH,.POFF) quit
	
	if AST.exists() do {		
		
		set ETC=PAT(AST).piece("|",1)			
		
		type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC",1)
		set ITC=trn.itc.extract()
		set CRCD=PAT(AST).piece("|",18)		
		
		set AMT=$S(NET<0:-NET,1:NET),RATE=1
		
		if ((NET<0)&('ITC))!((NET>0)&(ITC)) do { quit
		       	set PAT(AST).piece("|",20)=0
			set PAT(AST).piece("|",19)=0
			}
			
		if CRCD.get()'=CRCDBASE.get() do {
			do EXC^CRCDUTL(CRCDBASE,CRCD,AMT,1,'ITC,"00",CCODE,,1)
			set AMT=$$^SCARND(EXCAMT,,,CRCD)
			}
			
		set PAT(AST).piece("|",20)=$S(NET<0:-NET,1:NET)
		set PAT(AST).piece("|",19)=RATE

		if MODE set PAT(AST).piece("|",3)=AMT,NET=0
		}
	// Batch out of balance by $ ~p1
	if (NET'=0)&(MODE=1) do { quit
		set ER=1,RM=$$^MSG(335,$$FN^SCARND(NET,"P",CID.get()))
		do ERR(.PAT(),SRC,ACN,BATCH,.POFF)	
	}
	
	if 'ER,'POFF.get() quit
	// Loan payoff
	if 'ER,POFF.get() set RM=$$^MSG(6875)
	do ERR(.PAT(),SRC,ACN,BATCH,.POFF)
	quit

ERR(String PAT(),	// Record PAT
	String SRC,	// Source Code
	Number ACN,	// Customer Number
	Number BATCH,	// Batch
	Boolean POFF)	// Payoff Indicator	 	
	// Log Error
    
    	type public Boolean ER,MODE
	type public String RM	
	type Number I
	type String DESC	
	
	if 'MODE quit // do not log error if called for reporting purposes	
	
	type RecordSCATBL scatbl=Db.getRecord("SCATBL","FN=:%FN",1)
	set DESC=scatbl.fn
	
	do LOG^UTLEXC($T(+0),"*",DESC,ACN.get(),%ZTSEQ.get(),RM.get())
	
	for I=1:1 quit:'(PAT(I).exists())  do {		
		
		type RecordPATEX patex=Db.getRecord("PATEX","SRC=:SRC,ACN=:ACN,BATCH=:BATCH,SEQ=:I",1)		
		set patex.etc=PAT(I).piece("|",1)
		set patex.cid=PAT(I).piece("|",2)
		set patex.amount=PAT(I).piece("|",3)
		set patex.cmt=PAT(I).piece("|",4)
		set patex.var=PAT(I).piece("|",5)
		do patex.bypassSave() 		
		
		type RecordPATEX1 patex1=Db.getRecord("PATEX1","SRC=:SRC,ACN=:ACN,BATCH=:BATCH",1)		
		set patex1.bcmt=RM
		set patex1.pos='ER
		do patex1.bypassSave()
 
		set (POFF)=""
		}
	quit
  
 #OPTION ResultClass ON
Public String vSIG()	quit "60521^33696^Lakshmi Giridharan^12769"	// Signature - LTD^TIME^USER^SIZE
