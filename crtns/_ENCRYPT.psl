%ENCRYPT	
		 
	/*
	Password Encryption/Authentication
	
	NOTE: Some of the functions contained in this library are only
	      available on Unix systems.
	
	Library:
	
		. AUT		- Authenticate password
		. DECRYPT	- generic entry point for decryption
		. ENC		- Encrypt user password
		. ENCRYPT	- generic entry point for encryption
		. KEY		- Generate SignOnKey
		
		Blowfish related:
		
		. BLKEY		- generate a key for use with BLOWFISH
		. BLKEYHEX 	- generate a key for use with BLOWFISH
				  then, hex-encode it	
		. BLENC 	- encrypt data with plain blowfish
		. BLENCHEX 	- encrypt data with plain blowfish
				  then, hex-encode it	
		. BLDEC 	- decrypt data with plain blowfish
		. BLDECHEX 	- decrypt hex-encoded data with 
				  plain blowfish
				  
		RSA related:
				  
		. KEYPAIR	- generates an RSA public/private key pair.
		. KEYXCHG	- exchanges public key with client.
		. ASCENC	- performs RSA ASCII encode/decode operations.
		. RSAENC	- performs RSA encrypt/decrypt using RSA digital
	
	
	
	---- Revision History -------------------------------------------------
	07/15/06 - RussellDS - CR22121
		   Converted to PSL.
		   
		   Moved to application space since changes necessary to
		   support Unicode.
		   
		   Combined Unix and VMS code.

	-----------------------------------------------------------------------
	*/
	
	quit			// No entry from top
	
	
public KEY(Number LEN)		// String length	/NOREQ/MIN=40/MAX=128

	/*
	Generate SignOnKey

	RETURNS:
		. $$	Sign-on key			/TYP=T

	EXAMPLE:
		set X = $$KEY^%ENCRYPT()
	*/

	type Number I
	type String KEY

	set LEN = LEN.get()
	if ((LEN < 40) ! (LEN > 128)) set LEN = 89.random() + 40
	
	set KEY = ""
	for I = 1:1:LEN set KEY = KEY_(92.random() + 32).byte()
	
	quit KEY


public ENC(String PWD,	// User password (clear)
	   String ENC)	// Encrypted password		/MECH=REFNAM:W
	   
	/*
	Encrypt user password
	
	This function calls the scamd5 external function to encrypt the
	passed string.  This function utilize the MD5 encryption algorithm.

	RETURNS:
		. $$	Condition value                 /TYP=L
			  0 = Success
			  1 = Encryption Error

	EXAMPLE:
		set X = $$ENC^%ENCRYPT(PWD, .ENC)
	*/
	
	type Number enclen, LEN, rc
	type String encpwd, X
	
	set LEN = 128
	
	#IF '$ZVersion.isLike("%VMS%")
	// ***** Start UNIX code ********************
	
	set rc = 0
	set encpwd = "".justify(LEN)		// Create buffer

	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS	
        do &extcall.scamd5(PWD,.encpwd,.LEN,"",.rc)
        #ENDBYPASS

	if (rc '= 32) do {		// Failure
	
		set ENC = ""
		set rc = 1
	}
	else  do {			// Success
		
		set ENC = encpwd
		set rc = 0
	}	
	
	// ***** End Unix code *********************
	
	#ELSE
	// ***** Start VMS Code ********************
	
	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS
	set rc=$&SCAMD5(PWD,.LEN,"")
	#ENDBYPASS
	
	if (rc.piece(",", 1) > 0) do {		// Success
		
		set ENC = X.piece(",", 2, 999)
		set rc = 0
	}
	else  do {				// Failure
		
		set ENC = ""
		set rc = 1
	}
	
	// ***** End VMS code *********************
	#ENDIF
	
	quit rc


public AUT(String KEY,	// Sign-on key			/LEN=128
	   String ENC,	// Encrypted user password	/LEN=128
	   String AUT)	// Authentication key
	   
	/*
	Authenticate password

	RETURNS:
		. $$	Condition value                 /TYP=L
			  0 = Success
			  1 = Encryption Error

	EXAMPLE:
		set X = $$AUT^%ENCRYPT(ENC, KEY, .AUT)
	*/

	type Number I, LEN, rc
	type String X
	
	set LEN = 128
	
	#IF '$ZVersion.isLike("%VMS%")
	// ***** Start UNIX code ********************
	
	set rc = 0
	set AUT = AUT.get()
	
        for I = 1:1:LEN set AUT = AUT_" "
        
	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS	
        do &extcall.scamd5(KEY_ENC,.AUT,.LEN,"",.rc)
        #ENDBYPASS
        
	if (rc '= 32) set rc = 1	// Failure
	
	else  set rc = 0		// Success
	
	// ***** End Unix code *********************
	
	#ELSE
	// ***** Start VMS Code ********************
	
	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS
	set X=$&SCAMD5(KEY_ENC,.LEN,"")
	#ENDBYPASS
	
	if (X.piece(",", 1) > 0) do {		// Success
		
		set AUT = X.piece(",", 2, 999)
		set rc = 0
	}
	else  do {				// Failure
		
		set AUT = ""
		set rc = 1
	}			

	// ***** End VMS code *********************
	#ENDIF
	
	quit rc
	

public RSAENC(ByteString STR,	// String to be encrypted/decrypted
	      Number CONV,	// Operation (0 = encrypt, 1= decrypt)
	      String KEY,	// Ascii encoded public/private key string
	      Number CFLAG)	// Target machine component flag [*]
	      
	/*
	RSA ENCRYPT/DECRYPT Utility - UNIX platform 

	This routine will perform the RSA digital envelope encryption/
	decryption algorithm.

	ARGUMENT NOTES:

		. CFLAG		0 - Microsoft Crypto API
				1 - RSA Crypto API
	RETURNS:
		. $$		Translated String		/TYP=T
	*/

	type String OUT, RC

	#IF '$ZVersion.isLike("%VMS%")
	// ***** Start UNIX code ********************
	
	set OUT = "".justify(STR.length() + 512)
	set RC = 0
	
	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS
	if CONV=0 do &security.rsaenc(.STR,.OUT,.KEY,CFLAG,.RC)
	if CONV=1 do &security.rsadec(.OUT,.STR,.KEY,CFLAG,.RC)
	#ENDBYPASS
	
	if (RC = 0) set OUT = ""	// Failure
	
	// ***** End Unix code *********************
	
	#ELSE
	// ***** Start VMS Code ********************
	
	// This option is not yet supported for OpenVMS. Always return NULL.
	set OUT = ""
	
	// ***** End VMS code *********************
	#ENDIF
	
	
	quit OUT


public KEYPAIR(String STR,	// A pass phrase
	       String PUBKEY,	// Public key string	/MECH=REFNAM:W
	       String PRIKEY)	// Private key string	/MECH=REFNAM:W
	       
	/*
	RSA Public/Private Key Generation Utility

	This routine will generate an ASCII encoded RSA public/private
	key pair.
	
	RETURNS:
		. $$	Null or error message		/TYP=T
	*/

	type Number RC
	type String OUT1, OUT2, RETURN
	
	#IF '$ZVersion.isLike("%VMS%")
	// ***** Start UNIX code ********************
	
	set OUT1 = "".justify("", 512)
	set OUT2 = "".justify("", 1024)
	set RC = 0
	
	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS
	do &security.rsakey(.STR,.OUT1,.OUT2,.RC)
	#ENDBYPASS
	
	if (RC = 0) set RETURN = "Error with RSA key generation"
	else  do {
	
		set PUBKEY = OUT1
		set PRIKEY = OUT2
		set RETURN = ""
	}
	
	// ***** End Unix code *********************
	
	#ELSE
	// ***** Start VMS Code ********************
	
	// This option is not yet supported for OpenVMS. Always return NULL.
	set RETURN = ""
	
	// ***** End VMS code *********************
	#ENDIF
	
	quit ""


public KEYXCHG(String FILE,	// File name
	       String PUBKEY,	// ASCII encoded public key string
	       String OPCODE,	// "import" or "export"
	       Number CFLAG)	// Target machine component flag [*]
	       
	/*
	RSA Public Key Exchange Utility

	This routine will import/export a public key.

	ARGUMENT NOTES:

		. CFLAG		0 - MS Crypto API
				1 - RSA Crypto API
	RETURNS:
		. $$		Success/failure code	/TYP=N
				  0 = failure
				  1 = success
	*/
	
	type Number RC
	type String OUT
	
	#IF '$ZVersion.isLike("%VMS%")
	// ***** Start UNIX code ********************
	
	set OUT = "".justify(512)
	set RC = 0

	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS
	if OPCODE="import" do &security.rsaimp(.FILE,.OUT,CFLAG,.RC)
	if OPCODE="export" do &security.rsaexp(.FILE,.PUBKEY,CFLAG,.RC)
	#ENDBYPASS
	
	if (OPCODE = "import"), (RC = 1) set PUBKEY = OUT
	
	// ***** End Unix code *********************
	
	#ELSE
	// ***** Start VMS Code ********************
	
	// This option is not yet supported for OpenVMS. Always return 0.
	set RC = 0
	
	// ***** End VMS code *********************
	#ENDIF
	
	quit RC


public ASCENC(ByteString STR,	// Input string
	      String OPCODE)	// "encode" or "decode"
	      
	/*
	RSA ASCII Encode/Decode Utility

	This routine performs the RSA ASCII encoding/decoding alg.

	RETURNS:
		. $$	The translated string		/TYP=T
	*/
	
	type Number RC
	type String OUT
	
	#IF '$ZVersion.isLike("%VMS%")
	// ***** Start UNIX code ***************
	
	set OUT = "".justify(STR.length() * 2)
	set RC = 0
	
	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS
	if OPCODE="encode" do &security.ascenc(.OUT,.STR,.RC)
	if OPCODE="decode" do &security.ascdec(.STR,.OUT,.RC)
	#ENDBYPASS
	
	if (RC = 0) set OUT = ""	// Failure
	
	// ***** End Unix code *********************
	
	#ELSE
	// ***** Start VMS Code ********************
	
	// This option is not yet supported for OpenVMS. Always return NULL.
	set OUT = ""
	
	// ***** End VMS code *********************
	#ENDIF
	
	quit OUT


public ENCRYPT(String CALG,	// Crypto algorithm [*]
	       String DATA,	// String to be encrypted
	       String KEY)	// Public/Private/Secret key string
	       
	/*
	This function will act as a "master" encryption entry point.
	Based on the input crypto algorithm, it will direct the call to the
	appropriate function in %ENCRYPT.

	ARGUMENTS NOTES:

		. CALG	"RSA"	RSA digital envelope triple des cbc cipher for 
				UNIX to UNIX
			"RSAMS"	RSA digital envelope triple des cbc cipher for 
				UNIX to Windows
			"RSABF"	RSA digital envelope blowfish cipher 
			"BF"	Plain blowfish encryption
			"BFHEX"	Plain blowfish encryption + hex encoding the
				the encrypted string

	RETURNS:
		. $$	Encrypted string			/TYP=T
			NULL if error or unsupported crypto algorithm.
	*/
	
	#IF '$ZVersion.isLike("%VMS%")
	// ***** Start UNIX code ***************    

	if (CALG = "RSA") quit $$RSAENC(DATA, 0, KEY, 1)
	if (CALG = "RSAMS") quit $$RSAENC(DATA, 0, KEY, 0)
	if (CALG = "RSABF") quit $$RSAENC(DATA, 0, KEY, 2)
	if (CALG = "BF") quit $$BFENC(DATA, KEY)
	if (CALG = "BFHEX") quit $$BFENCHEX(DATA, KEY)
	
	// ***** End Unix code *********************
	
	#ELSE
	// ***** Start VMS Code ********************
	
	// This option is not yet supported for OpenVMS. Always return NULL.
	
	// ***** End VMS code *********************
	#ENDIF

	// Other crypto algorithms are not supported at this time
	quit ""


public DECRYPT(String CALG,	// Crypto algorithm [*]
	       String DATA,	// String to be decrypted
	       String KEY)	// Public/Private/Secret key string
	       
	/*
	This function will act as a "master" decryption entry point.
	Based on the input crypto algorithm, it will direct the call to the
	appropriate function in %ENCRYPT.

	ARGUMENTS NOTES:

		. CALG	"RSA"	RSA digital envelope triple des cbc cipher for 
				UNIX to UNIX
			"RSAMS"	RSA digital envelope triple des cbc cipher for 
				UNIX to Windows
			"RSABF"	RSA digital envelope blowfish cipher 
			"BF"	Plain blowfish encryption
			"BFHEX"	Plain blowfish encryption + hex encoding the
				the encrypted string

	RETURNS:
		. $$	Decrypted string			/TYP=T
			NULL if error or unsupported crypto algorithm.
	*/
	
	#IF '$ZVersion.isLike("%VMS%")
	// ***** Start UNIX code ***************
	
	if (CALG = "RSA") quit $$RSAENC(DATA, 1, KEY, 1)
	if (CALG = "RSAMS") quit $$RSAENC(DATA, 1, KEY, 0)
	if (CALG = "RSABF") quit $$RSAENC(DATA, 1, KEY, 2)
	if (CALG = "BF") quit $$BFDEC(DATA, KEY)
	if (CALG = "BFHEX") quit $$BFDECHEX(DATA, KEY)
	
	// ***** End Unix code *********************
	
	#ELSE
	// ***** Start VMS Code ********************
	
	// This option is not yet supported for OpenVMS. Always return NULL.
	
	// ***** End VMS code *********************
	#ENDIF

	// Other crypto algorithms are not supported at this time

	quit ""
	
	// None of the blowfish options are available on VMS
	#IF '$ZVersion.isLike("%VMS%")
	// ***** Start UNIX code ***************

public BFKEY()

	/*
	Generate Secret Key for blowfish

	RETURNS:
		. $$	Secret key			/TYP=T

	EXAMPLE:
		set X = $$BFKEY^%ENCRYPT()
	*/
	
	type Number RC
	type String KEY

	set KEY = "".justify(57)
	set RC = 0

	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS
	do &security.blfkey(.KEY,.RC)
	#ENDBYPASS
	
	quit KEY


public BFKEYHEX()

	/*
	Generate Secret Key for blowfish and encrypt it to hex

	RETURNS:
		. $$	Secret key in hex	      /TYP=T
	
	EXAMPLE:
		set X = $$BFKEYHEX^%ENCRYPT()
	*/
	
	quit $$TOHEX($$BFKEY())


public TOHEX(ByteString BSTR)	// String to be encrypted to hex

	/*
	Encode a string into its hex representation 

	RETURNS:
		. $$	Hex string representation		/TYP=T

	EXAMPLE:
		set X = $$TOHEX^%ENCRYPT(STR)
	*/
	
	type Number I
	type String HEX
	
	set HEX = ""
	for I = 1:1:BSTR.length() set HEX = HEX_$$FUNC^%DH(BSTR.ascii(I), 2)

	quit HEX


public FROMHEX(String HEX)	// String to be decrypted from hex

	/*
	Decode a hex-encoded string  

	RETURNS:
		. $$	Original string 			/TYP=T

	EXAMPLE:
		set X = $$FROMHEX^%ENCRYPT(HEX)
	*/
	
	type Number I
	type ByteString BSTR
	
	set BSTR = ""

	for I = 1:2:HEX.length() set BSTR = BSTR_(($$FUNC^%HD(HEX.extract(I)) * 16) + $$FUNC^%HD(HEX.extract(I+1))).byte()
	
	quit BSTR
	
	
public BFENC(ByteString DATA,	// String to be encrypted
	     String KEY)	// Secret key string
	     
	/*
	Encode a string with plain blowfish

	RETURNS:
		. $$	Encrypted string			/TYP=T

	EXAMPLE:
		set X = $$BFENC^%ENCRYPT(DATA, KEY)
	*/

	type Number RC
	type String CIPHER

	set CIPHER = "".justify(DATA.length() + 8)
	set RC = 0
	
	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS
	do &security.blfenc(.DATA,.CIPHER,.KEY,.RC)
	#ENDBYPASS
	 
	quit CIPHER


public BFENCHEX(String DATA,	// String to be encrypted
		String KEY)	// Secret key string
		
	/*
	Encode a string with plain blowfish then hex it

	RETURNS:
		. $$	Hex-ed Encrypted string			/TYP=T
      
	EXAMPLE:
		set X = $$BFENCHEX^%ENCRYPT(DATA, KEY)
	*/

	quit $$TOHEX($$BFENC(DATA, KEY))


public BFDEC(ByteString DATA,	// Encrypted string
	     String KEY)	// Secret key string
	     
	/*
	Decode a string with plain blowfish

	RETURNS:
		. $$	Decrypted string			/TYP=T

	EXAMPLE:
		set X = $$BFDEC^%ENCRYPT(DATA, KEY)
	*/

	type Number RC
	type String ORI
	
	set ORI = "".justify(DATA.length())
	set RC = 0

	// Bypass external call
	#ACCEPT Date=07/15/06; Pgm=RussellDS; CR=22121; GROUP=BYPASS
	#BYPASS
	do &security.blfdec(.ORI,.DATA,.KEY,.RC)
	#ENDBYPASS
	
	quit ORI


public BFDECHEX(String DATA,	// Hex-ed encrypted string
		String KEY)	// Secret key string
		
	/*
	Decode a hex-ed string with plain blowfish

	RETURNS:
		. $$	Decrypted string			/TYP=T

	EXAMPLE:
		set X = $$BFDECHEX^%ENCRYPT(DATA, KEY)
	*/
	
	quit $$BFDEC($$FROMHEX(DATA), KEY)
	
	
	// ***** End Unix code *********************
	
	#ENDIF
 #OPTION ResultClass ON
Public String vSIG()	quit "60466^47228^Dan Russell^13964"	// Signature - LTD^TIME^USER^SIZE
