CHKINS	//Public;Check Allocation to Institution
	/*
	
	   DESC: Check Allocation to Institution
	
	   KEYWORDS:
	
	   INPUTS:
	   . System
	
	   . Data [ddfile]di
	
	   . v1 desc of variable /TYP=T
	
	   RETURNS:
	   . XX desc of return   /TYP=T
	
	   RELATED:
	   . $$func^rtn - description of how related
	
	   EXAMPLE:
	   Text of example (line one)
	
	  ---- Revision History ------------------------------------------------
	   
	   04/25/06 - PUTTASWH - CR20665
	 	      Modified FILE section to get the starting check number 
	 	      from the screen and passed the same to DELRNG section to 
	 	      file the changes.
	   
	   02/28/06 - PUTTASWH - CR19783
	 	      Modified EXTBRCD section to pick appropriate records.
	 	    
	   02/21/06 - PUTTASWH - CR19676
	   	      Modified EXTINST and DELRNG sections to check for 
	   	      the appropriate records.
	   
	   02/14/05 - PUTTASWH - CR19539
	   	      Modified EXTBRCD section to initialize RET variable.
	   	      
	   11/17/05 - PUTTASWH - CR17011
	   	      Modified INSRNG and DELRNG sections to pass different
	   	      set of variables instead of the recordset. Modified
	   	      the sections accordingly for the same.
	   	      
	   01/05/04 - CARROLLJ - CR7658
		      Corrected parameter mismatch error.

	   08/21/02 - DATTAR - 49451
		      Converted to PSL

	   07/06/01 - KWANL - 46312
		      Test of ARQ move
	   ----------------------------------------------------------------------
	*/

NEW	// Allocate

	do INIT(0) 
	quit


DEL	// Deallocate

	do INIT(1) 
	quit 


INQ	// Display

	do INIT(2) 
	quit 

	
INIT(%ProcessMode) //

	new OLNTB,VFMQ

	set %PG=0
	set %PAGE=1
	type RecordCHKINS fCHKINS

	do VPG(.fCHKINS)

	quit 
	

VPG(RecordCHKINS fCHKINS) // Page control

	/*
	This is a dummy setting done to properly display menu bar that 
	should contain “File” option in this case which still depends on 
	defined UX array in %O1^DBSCRT8A routine
	*/
	type public String UX=""	

	new FINISH
        set FINISH=0

        for  do { quit:FINISH
                if %PG=0 do VPG00 if ER set FINISH=1 quit
               
                if %PG>0 do VPG01(.fCHKINS)

                if "DFQ"[VFMQ!$G(ER) do VER(.fCHKINS) set FINISH=1 quit

                set %PG=%PG+1
                }
        quit


VPG00 //Entry for page 1

	if %ProcessMode=0 do {
		set %TAB("CHKS")=$$DI^SCATAB("[CHKINS]CHKS",,,"[UTBLCHKS]")
		set %TAB("HIGH")=$$DI^SCATAB("[CHKINS]HIGH",,,,"D POSHIGH^CHKINS")
		}

	if %ProcessMode=1 do {
		set %TAB("CHKS")=$$DI^SCATAB("[CHKINS]CHKS",,,"[CHKINS]CHKS:DISTINCT")
		set %TAB("HIGH")=$$DI^SCATAB("[CHKINS]HIGH",,,"[CHKINS]HIGH:QU ""[CHKINS]CHKS=<<CHKS>>""","D POSHIGH^CHKINS")
		}

	if %ProcessMode=2 do {
		set %TAB("CHKS")=$$DI^SCATAB("[CHKINS]CHKS",,,"[CHKINS]CHKS:DISTINCT")
		set %TAB("HIGH")=$$DI^SCATAB("[CHKINS]HIGH",,,"[CHKINS]HIGH:QU ""[CHKINS]CHKS=<<CHKS>>""")
		}
	
	set %READ="@@%FN,,,CHKS/REQ,HIGH/REQ" 
	set %NOPRMT="N"

	do ^UTLREAD 

	if VFMQ="Q" set ER=1

	quit 


VPG01(RecordCHKINS fCHKINS) //

	if %ProcessMode'=2  do { quit:ER=1
		lock +CHKINS(CHKS):2 
		else  set ER=1 set ET="RECLOC" do ^UTLERR quit
		}

	set fCHKINS=Db.getRecord("CHKINS","CHKS=:CHKS,HIGH=:HIGH",1)

	do DRV^USID(%ProcessMode,"CHKINS",.fCHKINS)

	quit 
	

POSHIGH	//

	if $$INVFMT^CHKNUTL(X) quit

	new EXT
	set EXT=$$EXTINST(CHKS,X,X)

	// check range allocated to institution
	if '%OSAVE,EXT set ER=1 set RM=$$^MSG(8700) quit
	
	// check range not allocated to institution
	if %OSAVE,(EXT'=2) set ER=1 set RM=$$^MSG(8699) quit

	set BRCD=""
	set EXT=$$EXTBRCD(CHKS,X,X,BRCD)
	if EXT set ER=1 quit 

	set EXT=$$EXTCUS(CHKS,X,X)
	if EXT set ER=1 quit 
	quit 

	
public EXTINST(String CHKS,	// Check Type
	String LO,		// Low check number
	String HI)		// High check number

	/*	
	   This label is called for differents routines 
	
	   Return :
	   0 - If the range is not allocated
	   1 - If part of the range is allocated
	   2 - If all the range is allocated	
	*/
	
	new HINXT,LONXT	

	set (LONXT,HINXT)=""
	type DbSet rs=Db.selectDbSet("CHKINS","CHKS=:CHKS AND HIGH>=:LO")
	if rs.next() do {
		type RecordCHKINS chkins=rs.getRecord("CHKINS")
		set HINXT=chkins.high
		set LONXT=chkins.low
		}		
	 
	quit $$TSTRNG(LO,HI,LONXT,HINXT)

	
public EXTBRCD(String CHKS,	// Check Type
	String LO,		// Low check number
	String HI,		// High check number
	Number BRCD) 		// Branch Code
		
	// Exist in ^CHKALLOC

	/*		
	   This label is called for differents routines	
	   If BRCD is passed only test that branch
	
	   Return:
	   0 - If the range is not allocated
	   1 - If part of the range is allocated
	   2 - If all the range is allocated	
	*/

	new BRCDAUX,LONXT,HINXT,RET
	
	set BRCD=$G(BRCD)
	set BRCDAUX=""
	
	if BRCD="" set BRCDAUX=0
	else  set BRCDAUX=BRCD	
	
	set RET=0
	
	type ResultSet rs=Db.select("BRCD","CHKALLOC","BRCD>=:BRCDAUX")
	while rs.next() do { quit:(RET!(BRCD'=""))
		set BRCDAUX=rs.getCol("BRCD")			
		
	        set (HINXT,LONXT)=""
	        type DbSet rs1=Db.selectDbSet("CHKALLOC","BRCD=:BRCDAUX AND TYPE=:CHKS AND HIGH>=:LO")
	        if rs1.next() do {
        	        type RecordCHKALLOC chkalloc=rs1.getRecord("CHKALLOC")
        	        set HINXT=chkalloc.high
        	        set LONXT=chkalloc.low
        	        }        	        
		
		set RET=$$TSTRNG(LO,HI,LONXT,HINXT)
		}
	
	// check range not allocated to branch ~p1
	if BRCD'="",('RET) set RM=$$^MSG(8698,BRCD)

	if RET set RM=$$^MSG(2308,LONXT,HINXT,BRCDAUX) 

	quit RET

	
public EXTCUS(String CHKS,	// Check Type
	String LO,		// Low check number
	String HI)		// High check number 
	
	// Exist in ^CHECK
	
	/*	
	   Return:
	   0 - If the range is not allocated to customer
	   1 - If one check in range is allocated	
	*/
	
	new AUX
	set AUX=""
	
	type ResultSet rs=Db.select("CHKNUM","CHECK","CHKS=:CHKS AND CHKNUM=:LO")
        if rs.next() set AUX=rs.getCol("CHKNUM") 
				
	// Check range already allocated to customer ~p1	  
	if (AUX'=""),(AUX']]HI) set RM=$$^MSG(8695) quit 1  
	
	quit 0
	

TSTRNG(String LO,	// Old Low check number
	String HI,	// Old High check number
	String LONXT,	// New Low check number
	String HINXT)  // New High check number
	// Test two ranges

	/*	
	   This label is called for other screens/routines
	
	   Return :
	   0 - If the range LO-HI is not included in range LONXT-HINXT
	   1 - If part of the range LO-HI is included in LONXT-HINXT
	   2 - If all the range LO-HI is included in LONXT-HINXT
	
	   The next range doesn't exist
	
	     |---T---|
	*/

	// Is not allocated
	if HINXT="" quit 0    
	
	/*
	 The low value in next range is greater than high value in
	 testing range
	     |---N---|
	     |---T---|
	*/
	
	// Is not allocated
	if LONXT]]HI quit 0   
	
	/*
	 The low value in next range is smaller or equal to the low
	 value in testing range and
	 the high value in next range is greater or equal to the high
	 value in testing range


	 |---N---| |---N---| |---N---| |---N---|
	 |---T---| |--T--|    |--T--|  |--T--|
	*/
	
	// All range allocated
	if (HI']]HINXT)&(LONXT']]LO) quit 2  
	
	// The rest of possibilities
	
	/*
	  |-N-|  |-N-|     |-N-| |-N-|       |-N-| |-N-|             |-N-|
	 |--T--| |--T--| |--T--|  |--T--| |--T--|      |--T--| |--T--|
	*/

	// Part is allocated	
	quit 1

public INSRNG(RecordCHKINS fCHKINS)	// Record CHKINS
	// Concatenate existing ranges.

	new AUX,LO
	
	set CHKS=fCHKINS.chks
	set HIGH=fCHKINS.high
	set (LO,LOW)=fCHKINS.low	
	set AUX=""
	
	type ResultSet rs=Db.select("HIGH","CHKINS","CHKS=:CHKS AND HIGH<:LO","HIGH DESC")
	if rs.next() set AUX=rs.getCol("HIGH")

	if AUX'="" do {
		if ($$CHKNXT^CHKNUTL(AUX)'=LO) quit
		type RecordCHKINS chkins=Db.getRecord("CHKINS","CHKS=:CHKS,HIGH=:AUX")
		set LOW=chkins.low
		do Db.delete("CHKINS","CHKS=:CHKS AND HIGH=:AUX")		
		}

	set AUX=""
	type ResultSet rs=Db.select("HIGH,LOW","CHKINS","CHKS=:CHKS AND HIGH>:HIGH","HIGH")
	if rs.next() set AUX=rs.getCol("HIGH")

	if AUX'="" do {
		set LO=rs.getCol("LOW")
		if $$CHKPRV^CHKNUTL(LO)'=HIGH quit
		set HIGH=AUX
		do Db.delete("CHKINS","CHKS=:CHKS AND HIGH=:AUX")
		}

	type RecordCHKINS chkins1=Db.getRecord("CHKINS","CHKS=:CHKS,HIGH=:HIGH",1)
		
	set chkins1.low=LOW
	set chkins1.uid=%UserID

	do chkins1.bypassSave()

	quit 
	
public DELRNG(RecordCHKINS fCHKINS,	// Record CHKINS
	String CHKB)			// Low Check Number
	// Break the existing range
	
	new AUX,HI,LO
	
	set (AUX,LO)=""
	set CHKS=fCHKINS.chks
	set HIGH=fCHKINS.high
	set LOW=CHKB
	
	type ResultSet rs=Db.select("HIGH,LOW","CHKINS","CHKS=:CHKS AND HIGH>=:HIGH")
	if rs.next() do {
		set AUX=rs.getCol("HIGH")
		set LO=rs.getCol("LOW")
		}	
	
	if LO'=LOW do {  quit:ER 

		// Allocate the begining range
		set HI=$$CHKPRV^CHKNUTL(LOW)
		if ER quit
	
		type RecordCHKINS chkins=Db.getRecord("CHKINS","CHKS=:CHKS,HIGH=:HI",1)
		set chkins.low=LO
		set chkins.uid=%UserID
		do chkins.bypassSave()

		}

	if AUX'=HIGH do {  quit:ER 

		// Allocate the ending range
		set LO=$$CHKNXT^CHKNUTL(HIGH)
		if ER quit

		type RecordCHKINS chkins=Db.getRecord("CHKINS","CHKS=:CHKS,HIGH=:AUX",1)
		set chkins.low=LO
		set chkins.uid=%UserID
		do chkins.bypassSave()
		}
	else  do Db.delete("CHKINS","CHKS=:CHKS AND HIGH=:HIGH")
		
	quit 
	

VER(RecordCHKINS fCHKINS)	//

	if $G(ER)!(VFMQ="Q") do END quit

	do FILE(.fCHKINS)

	quit


FILE(RecordCHKINS fCHKINS) //
	
	type public String CHKB
	
	// Low Check Number
	if %ProcessMode=0 do INSRNG(.fCHKINS)     

	if %ProcessMode=1 do DELRNG(.fCHKINS,CHKB)

	quit


END	//

	lock -CHKINS(CHKS,HIGH)
	if ER quit	

	if VFMQ="Q" do {
		// allocation of check type ~p1 not completed
		if %ProcessMode=0 set RM=$$^MSG(8701,CHKS)      

		// deallocation of check type ~p1 not completed
		if %ProcessMode=1 set RM=$$^MSG(8702,CHKS)      
		}
	else  do {
		// allocation of check type ~p1 completed
		if %ProcessMode=0 set RM=$$^MSG(8703,CHKS)

		// deallocation of check type ~p1 completed
		if %ProcessMode=1 set RM=$$^MSG(8704,CHKS)  
		}
	
	set ER="W"
	quit 

vSIG()	quit "60381^3293^Hema Puttaswamy^9420"	// Signature - LTD^TIME^USER^SIZE
