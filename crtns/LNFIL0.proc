LNFIL0 // LN DATA-QWIK filer, part (2)
 // Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 11:25 - shetyes

	quit		// Not called from top


VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do vau29 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do vau46 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() quit
	if vx("ACN").exists() do vau2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ACNRELC").exists() do vau3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ACS").exists() do vau4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AIPR").exists()!vx("AUPTCID").exists()!vx("ALPDUE").exists() do vau5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AMBAS").exists()!vx("ONP").exists()!vx("PCM").exists()!vx("RPP").exists() do vau55 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANIRND").exists() do vau7 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANLD").exists()!vx("ANOFF").exists()!vx("APCND").exists()!vx("EACIP").exists() do vau6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANPTND").exists() do vau8 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BALINT").exists()!vx("REVF").exists()!vx("TDR").exists()!vx("UDBAL").exists()!vx("DBT").exists()!vx("CBT").exists() do vau85 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BLDT").exists() do vau10 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BMET").exists() do vau11 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BNDT").exists()!vx("SCHND").exists() do vau9 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BOO").exists()!vx("CC").exists()!vx("CCODE").exists()!vx("MF").exists()!vx("RESCD").exists() do vau34 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CBF").exists()!vx("CDF").exists()!vx("IRP").exists() do vau12 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CBMET").exists() do vau13 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CBPND").exists() do vau14 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CCL").exists()!vx("CPF").exists()!vx("CRLMT").exists() do vau15 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CHKEURO").exists()!vx("CHKISS").exists()!vx("CHKCNT").exists() do vau16 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CNOFF").exists()!vx("CNCAL").exists() do vau19 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CNVDT").exists() do vau18 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CNVSTAT").exists() do vau20 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CONVACN").exists() do vau21 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CRCD").exists()!vx("SDTA").exists() do vau73 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DARCOVR").exists() do vau22 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DICO").exists()!vx("DIRFRE").exists()!vx("DIRND").exists()!vx("DITGACN").exists() do vau23 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST1FRE").exists() do vau24 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST1ND").exists() do vau25 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST2FRE").exists()!vx("DIST2ND").exists() do vau26 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST3FRE").exists()!vx("DIST3ND").exists() do vau27 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST4FRE").exists()!vx("DIST4ND").exists() do vau28 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DPA").exists() do vau30 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DPMT").exists() do vau31 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DTC").exists() do vau32 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DXSI").exists()!vx("BCAPINT").exists() do vau33 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("FIA").exists() do vau35 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("FPA").exists() do vau36 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GLSC").exists() do vau37 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GRP").exists() do vau38 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IAM").exists()!vx("IDP").exists()!vx("IPL").exists()!vx("IUN").exists()!vx("ICPA").exists()!vx("FLAT").exists()!vx("MDT").exists()!vx("TRM").exists()!vx("PCMVAL").exists()!vx("MAXPTRM").exists()!vx("MINPTRM").exists() do vau42 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ICAP").exists()!vx("IROPT").exists() do vau39 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ICHND").exists()!vx("INDEX").exists()!vx("INTFRE").exists()!vx("INTOFF").exists()!vx("IRN").exists()!vx("INTMAT").exists()!vx("INTSPR").exists()!vx("IRF").exists()!vx("RNDMTD").exists()!vx("MINRATE").exists() do vau41 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IGRC").exists() do vau40 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IRCID").exists()!vx("IRAMTO").exists() do vau43 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("LCAD").exists()!vx("POPT").exists() do vau44 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MAXAGGR").exists() do vau45 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT900").exists()!vx("MT900THR").exists() do vau47 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT910").exists()!vx("MT910THR").exists() do vau48 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NAI").exists() do vau49 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NBTR").exists()!vx("NTROPT").exists() do vau50 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NUMDTP").exists() do vau51 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ODD").exists()!vx("DTNT").exists()!vx("ODT").exists() do vau52 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PAYLKAMT").exists()!vx("PAYLKFRM").exists()!vx("PAYLKTO").exists() do vau53 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PCFRE").exists()!vx("PCHND").exists()!vx("PCOFF").exists() do vau58 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PCHM").exists() do vau54 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMRO").exists() do vau56 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMT").exists() do vau57 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMTDIST").exists()!vx("PMTDISTF").exists() do vau59 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMTMIN").exists() do vau60 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PPDCAT1").exists()!vx("PPDCAT2").exists()!vx("PPDCAT3").exists()!vx("PPDCAT4").exists()!vx("PPDCAT5").exists()!vx("PPDCAT6").exists()!vx("PPDCAT7").exists()!vx("PPDCAT8").exists()!vx("PPDCAT9").exists()!vx("PPDCAT10").exists() do vau61 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PRAMTCID").exists()!vx("PRAMT").exists() do vau62 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PRCNTCID").exists()!vx("PRCNTAP").exists() do vau63 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PTSP").exists() do vau64 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RAFRE").exists() do vau65 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RAND").exists() do vau66 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RDT").exists() do vau67 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RENCD").exists()!vx("TRACN").exists() do vau68 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RND").exists()!vx("ROPT").exists() do vau69 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RNOFF").exists()!vx("RNCAL").exists() do vau72 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RSINTSPR").exists()!vx("RSRNDMTD").exists() do vau70 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RSKOPT").exists() do vau71 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SFRE").exists() do vau74 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SGNCRD").exists()!vx("OSGNCRDC").exists()!vx("PSGNCRDR").exists() do vau75 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SMET").exists() do vau76 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SRCDT").exists() do vau77 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STAT").exists() do vau78 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STROFF").exists()!vx("STRCAL").exists() do vau79 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SUBPLN").exists()!vx("IDP").exists()!vx("IAM").exists() do vau80 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TEB").exists() do vau82 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TITLE1").exists()!vx("TITLE2").exists()!vx("TITLE3").exists()!vx("TITLE4").exists() do vau83 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TRATE").exists()!vx("TREXD").exists() do vau81 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TYPE").exists() do vau84 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("WDLMT").exists() do vau86 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("WDLMTP").exists()!vx("WDND").exists()!vx("WDFRE").exists()!vx("COLLIMPR").exists()!vx("PBNXTDT").exists()!vx("PBFRE").exists()!vx("ADJCOL").exists() do vau87 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("WRKDTE").exists() do vau88 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBD //
	type public Number ER = 0
	type public String vx(),RM
	do vbd1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordLN ln
	if vx("").order().isNull() do AUDIT^UCUTILN(ln,.vx(),10,"|") quit
	if vx("ACS").exists() do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ALPRTY").exists() do vbu2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ALPRTYD").exists() do vbu3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANOFFDT").exists() do vbu4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("APCND").exists()!vx("ANOFF").exists() do vbu5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("APRMTHD").exists() do vbu6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ARUF").exists() do vbu7 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BALLAMT").exists() do vbu8 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BLOFF").exists() do vbu9 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CBMET").exists()!vx("CBPND").exists() do vbu18 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CLPS").exists() do vbu12 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CLS").exists() do vbu13 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CNVDT").exists() do vbu14 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CNVSTAT").exists() do vbu15 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("COLCD").exists() do vbu16 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("COLLST").exists()!vx("PCOLLST").exists()!vx("COLCDTE").exists() do vbu17 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CRLMT").exists() do vbu19 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DARCOVR").exists() do vbu20 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DFP").exists() do vbu21 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DICO").exists() do vbu22 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST1FRE").exists() do vbu23 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST2FRE").exists() do vbu25 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST2ND").exists() do vbu24 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST3FRE").exists()!vx("DIST3ND").exists() do vbu26 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DIST4FRE").exists()!vx("DIST4ND").exists() do vbu27 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DLCAF").exists() do vbu28 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("EMPLBEN").exists()!vx("EMPLNO").exists() do vbu29 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ICPA").exists() do vbu30 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ICPF").exists()!vx("DIST1AF").exists() do vbu31 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("INDEX").exists()!vx("IRN").exists()!vx("EIRN").exists()!vx("IACF").exists()!vx("INTSPR").exists()!vx("RNDMTD").exists()!vx("INTMAT").exists()!vx("INTFRE").exists()!vx("ICHND").exists()!vx("INTOFF").exists()!vx("INTOFFDT").exists()!vx("TRATE").exists()!vx("TREXD").exists() do vbu32 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IPL").exists() do vbu33 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IROPT").exists() do vbu34 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IUN").exists() do vbu35 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MDT").exists()!vx("PCM").exists()!vx("DTNT").exists()!vx("ODD").exists()!vx("TRM").exists()!vx("BUSOPT").exists()!vx("NBDC").exists()!vx("PIACM").exists() do vbu36 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT900").exists() do vbu37 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT910").exists() do vbu38 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NAI").exists()!vx("NAPLMTDT").exists() do vbu39 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PAP").exists()!vx("PAS").exists() do vbu40 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PAYTOL").exists()!vx("PAYTOLP").exists() do vbu55 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PCFRE").exists() do vbu41 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PCHND").exists()!vx("PCOFF").exists()!vx("RAND").exists() do vbu42 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PCOFFDT").exists() do vbu43 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMTDIST").exists() do vbu44 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMTGRC").exists() do vbu45 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PMTPI").exists()!vx("PMTTRS").exists() do vbu46 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PPFREQ").exists() do vbu47 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PROVOAMT").exists()!vx("PROVOPCT").exists()!vx("RACOVR").exists() do vbu48 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RANDOFF").exists() do vbu49 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RENCD").exists()!vx("TRACN").exists() do vbu50 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("REVF").exists()!vx("TDR").exists() do vbu51 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SCHND").exists() do vbu52 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SGNCRD").exists()!vx("PSGNCRDR").exists()!vx("OSGNCRDC").exists() do vbu53 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STAT").exists() do vbu54 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TITLE1").exists()!vx("TITLE2").exists()!vx("TITLE3").exists()!vx("TITLE4").exists() do vbu10 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TYPE").exists() do vbu56 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("UDBAL").exists() do vbu57 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("WDLMTP").exists()!vx("COLLIMPR").exists()!vx("PBNXTDT").exists()!vx("PBFRE").exists()!vx("ADJCOL").exists() do vbu58 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(ln,.vx(),10,"|")
	quit


vai1 // Trigger AFTER_INSERT - After insert trigger

	type public RecordLN ln
								/* 
								---- Revision History---------------------------------------------------

	09/18/01 - MYERSK 47550
		   Removed AU_SGNCRD trigger since XSGNCRD is now an Index.
		   Needed to put Revision History somewhere.

	04/03/00 - KELLYP - 37918
		   Moved all code and revision history comments from this 
		   trigger into a new procedure, LNAI, to prevent compilation
		   errors caused by the LN filer being too large.  Changes to
		   the AFTER_INSERT trigger should now be made to the LNAI proc.
								*/

	do PROC^LNAI(.ln)	// All code moved to AFTER_INSERT Procedure
	quit

vau1 // Trigger AU - After Update trigger for all columns

	type public RecordLN ln
								/*
								---- Revision History ------------------------------------------------
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards. 	

								07/29/01 - VETSENM - 46279
																			Code for LN.CONVACN has been removed to AU_CONVACN. 

								05/15/01 - VETSENM - 43026
																			Set error message for Non-PROFILE account if Conversion
																			Account (LN.CONVACN) is not defined.

																			Set XBAD message if user attempts to perform file
																			maintenance on a Non-PROFILE account (PRODCTL.NONPA=1) 
								*/

	type public Boolean ER

	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")

								// File Maintenance Require Approval
								if prodctl.nonpa=1 do Runtime.setErrXBAD("LN",3005) quit:ER
	
								quit
	

vau2 // Trigger AU_ACN - After Update trigger

	type public RecordLN ln
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI -14385
		   Modified to comply with DBI standards.
	
	01/22/99 - KONGJ - 28973
		   Added a check to return an XBAD msg if both Revolving Process
		   Flag is set to "Y" and small balance threshold fields contain
		   values.
	*/
	
	type public Boolean ER

	// Debit/Credit Balance cannot be defined for rev accts.
	if ln.revf,(ln.dbt!ln.cbt) do Runtime.setErrXBAD("LN",528) quit:ER 
	
	if 'CUVAR.LIMPRO quit

	do START^LIMUPD(ln.cid,"LOAN",ln.acn,ln.acn.oldVal)

	quit 

vau3 // Trigger AU_ACNRELC - After Update of ACNRELC

	type public RecordLN ln
   	/*
   	---- Revision History ------------------------------------------------
	03/15/06 - Srinivar - 19975
	           New after update trigger created to update the relationship
	           code of the escrow account.
	           
	----------------------------------------------------------------------
     	*/
     		
	type Number ECID 
	
	set ECID=$$ECID^LNU(ln.cid,"ESC1")
	if ECID="" quit
		
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
	set dep.acnrelc=ln.acnrelc
	do dep.bypassSave()
		
	quit

vau4 // Trigger AU_ACS - After update accrual processed date

	type public RecordLN ln
	// Accrual Processed Indicator Error
	if ln.acs'=(%SystemDate-1) do Runtime.setErrXBAD("LN","ACS") quit:ER 
	quit
	

vau5 // Trigger AU_AIPR - After Update AIPR, AUPTCID & ALPDUE

	type public RecordLN ln
	/*	
	----Revision History----------------------------------------------------
	
	08/12/99 - ROYTENBERGE/SMITHC - 49809
		   Added code to check: Auto Loan Payment Due Method must be greater
		   than 0 when Auto Loan Payment Account is defined.
	*/


	
	// Auto ln pmt acct requird for int collectd on prin repayments
	if ln.aipr,ln.auptcid="" do Runtime.setErrXBAD("LN",522) quit:ER       
	
	// Auto ln pmt processing requires auto ln pmt acct
	if ln.alpdue,ln.auptcid="" do Runtime.setErrXBAD("LN",523) quit:ER 
	
	/*
	Auto Loan Payment Due Method must be greater than 0 when Auto Loan Payment
	Account is defined
	*/
	if 'ln.alpdue,ln.auptcid'="" do Runtime.setErrMSG("LN",3985) quit:ER 
	quit 

vau6 // Trigger AU_ANALYSIS_INFO - After update analysis information

	type public RecordLN ln
	/*
	Revision History
	------------------------------------------------------------------------
	5/24/02 - JERUCHIMC - 49996
	Define apcld variable if not defined already.	
	*/

	// ESCROW PAYMENT CHANGE Date in the Past
	if ln.apcnd'="",ln.apcnd<%SystemDate do Runtime.setErrXBAD("LN",77) quit:ER 
	if ln.anfre'="" do { quit:ER 
		new apcld
		if ln.apcld="",ln.apcnd set apcld=$$NJD^UFRE(ln.apcnd,"-"_ln.anfre) quit:ER
		if $G(apcld)="" set apcld=ln.apcld
		if $G(ER) do Runtime.setErrXBAD("LN",ET) quit:ER 

		/*	
		Analysis change in process flag not set and there was an analysis
		posting at some time.  We're OK if offset date in future, or if in
		the past and last period preceeds last analysis date (in that case
		in offset period and haven't posted)
		*/

		if 'ln.eacip,ln.anld,ln.anoffdt'>%SystemDate,ln.anld'<apcld do { quit:ER 
			// Analysis In-Proc Flag Not Set, Analysis Posted
			do Runtime.setErrXBAD("LN",509) quit:ER 
			}
	
		if ln.eacip do { quit:ER 
			// OK if offset date in past and next analysis date in the future
			if ln.anoffdt'>%SystemDate,%SystemDate<ln.apcnd quit 
	
			/*
			OK if analysis falls after the last analysis change date and before
			the next offset date -- then we've done off-cycle analysis
			*/
			if ln.anld<ln.anoffdt,ln.anld>apcld quit 

			// Analysis Chng In-Proc Flag Set, Ln Not in Analysis
			do Runtime.setErrXBAD("LN",505) quit:ER 
			}
		}
	quit
	

vau7 // Trigger AU_ANIRND - After update annual rate limit next chg

	type public RecordLN ln
	// NEXT ANNUAL RATE REVIEW DATE in the Past
	if ln.anirnd,ln.anirnd<%SystemDate do Runtime.setErrXBAD("LN",80) quit:ER 
	quit
	

vau8 // Trigger AU_ANPTND - After update annual pmt lmt nxt chg date

	type public RecordLN ln
	// NEXT ANNUAL PMT REVIEW DATE in the Past
	if ln.anptnd'="",ln.anptnd<%SystemDate do Runtime.setErrXBAD("LN",81) quit:ER 
	quit
	

vau9 // Trigger AU_BILL_SCH_INFO - AU bill & sch next dates & dist 1 AF

	type public RecordLN ln
	// Next bill date precedes system processing date
	if (ln.bndt.oldVal'=ln.bndt),ln.bndt'="",ln.bndt<%SystemDate do Runtime.setErrXBAD("LN",14,"BNDT",ln.bndt) quit:ER 
	
	if (ln.schnd.oldVal'=ln.schnd),ln.schnd'="" do { quit:ER 
		// Next scheduled payment date is invalid
		if ln.schnd<%SystemDate do Runtime.setErrXBAD("LN",17,"SCHND",ln.schnd) quit:ER 

		// Check that SCHND is correct relative to DIST1FRE
		if ln.schnd'="",ln.dist1fre'="" do { quit:ER 
			new bndt,cdpd,njd,pdd,XCID,XDATE
			if ln.dist1fre="*" do { quit:$G(pdd)=""!ER 
				new XCID
				set XCID=ln.cid
				new rs 
				type ResultSet rs=Db.select("PDD","LNPS1","CID=:XCID","PDD DESC") 
				if rs.isEmpty() quit
				set pdd=rs.next(),pdd=rs.getCol(1)
				}
	
			// Get date from first bill with due date in future
			set XCID=ln.cid 
			set XDATE=%SystemDate
			new rs 
			type ResultSet rs=Db.select("CDPD","LNBIL1","CID=:XCID AND CDPD>:XDATE","SCHSEQ") 
			if rs.isEmpty() quit
			set cdpd=rs.next(),cdpd=rs.getCol(1)

			// Next scheduled payment date is invalid
			if $G(cdpd),$G(cdpd)'=ln.schnd do Runtime.setErrXBAD("LN",17,"SCHND",ln.schnd,cdpd) quit:ER 

			// Error if date does not correspond to frequency
			// Bump one
			set x=$$NJD^UFRE(ln.schnd,ln.dist1fre) quit:ER     
			// Then reverse
			set x=$$NJD^UFRE(x,"-"_ln.dist1fre) quit:ER
			if ln.schnd'=x do Runtime.setErrXBAD("LN",17,"SCHND",ln.schnd,x) quit:ER 
	
			// Check BNDT based on SCHND
			if ln.bloff="1P" set bndt=$S(ln.schld<%SystemDate:ln.schnd,1:ln.schld)
			else  do {
				new xfre
				set njd=ln.schnd 
				set xfre=ln.dist1fre
				for  set bndt=njd-ln.bloff quit:bndt'<%SystemDate  set njd=$$NJD^UFRE(njd,xfre) quit:$G(ER) 
				}
			// Check next bill date for possible errors
			if ln.bndt'=bndt!$G(ER) do Runtime.setErrXBAD("LN",46,"BNDT",ln.bndt,bndt) quit:ER 
			}
		}
	quit

vau10 // Trigger AU_BLDT - After update bill last date

	type public RecordLN ln
	if ln.bldt'="" do { quit:ER 
		new cbcd,lnbil1dt,XCID
		// Get last bill date from bill file to validate
		set XCID=ln.cid
		new rs 
		type ResultSet rs=Db.select("CBCD","LNBIL1","CID=:XCID","SCHSEQ DESC") 
		if rs.isEmpty() quit
		set cbcd=rs.next(),cbcd=rs.getCol(1)

		// Last bill sequence inconsistent with internal bill
		if $G(cbcd)'="",cbcd<ln.bldt do Runtime.setErrXBAD("LN",2,"BLDT",ln.bldt,cbcd) quit:ER 
		}
	quit
	

vau11 // Trigger AU_BMET - After Update Bill Print Flag Trigger

	type public RecordLN ln
	// Bill Print flag may only be enabled on master commitment when ln.cbf=1
	if (ln.cbf),(ln.ccl'=""),(ln.bmet) do Runtime.setErrMSG("LN","4323") quit:ER
	quit

vau12 // Trigger AU_CBF_CDF_IRP - After Update Builder Loan Flags

	type public RecordLN ln
	/*
								---- Revision History---------------------------------------------------
							 
								08/02/05 - KUMARB - CR16684
		Modified the table name LNLCOM to LN in Db.select
	*/

	/*
			This trigger performs several edit checks for the new Builder Loan flags
			introduced to the system by ARQ 35505.  The rules are as follows:

	- LN.CBF must be the same on a commitment and on all of the accounts
	  tied to the commitment (must be enabled or disabled on all).

	- LN.CDF must be the same on a commitment and on all of the accounts
	  tied to the commitment (must be enabled or disabled on all).

	- LN.IRP may not be enabled if LN.CBF is disabled.

	- If LN.IRP is enabled on the commitment, it must also be enabled on
	  all of the accounts tied to the commitment.

	*/

	// Cannot enable Interest Reserve Processing if Commitment Billing is disabled
	if (ln.irp),('ln.cbf) do Runtime.setErrMSG("LN","4281") quit:ER
	
	if ('ln.cpf),(ln.ccl) do { quit:ER   // Edit checks for an acct tied to a commitment
	
								set XCCL=ln.ccl         // Account's linked commitmemt
								set DATA=Db.getOneRow("CBF,CDF,IRP","LN","XCCL")
	
								// Commitment Billing Flag must equal linked commitment
								if ln.cbf'=$P(DATA,$C(9),1) do Runtime.setErrMSG("LN","4284") quit:ER
	
								// Commitment Delinquency Flag must equal linked commitment
								if ln.cdf'=$P(DATA,$C(9),2) do Runtime.setErrMSG("LN","4286") quit:ER
	
								// Interest Reserve Processing flag must be enabled on this account
								if ($P(DATA,$C(9),3)),('ln.irp) do Runtime.setErrMSG("LN","4305") quit:ER
	
								if 1    // Preserves $T
								}
	
	else  if ln.cpf do { quit:ER           // Edit checks for a commitment
								new ACCTS,rs,XCID
 	
	set XCID=ln.cid
	type ResultSet rs=Db.select("CID","LN","CCL=:XCID")
	if rs.isEmpty() quit

	while rs.next() do { quit:ER	    // Test each loan under commitment
		new DATA,SUBCID

		set SUBCID=rs.getCol(1)
		if 'Db.isDefined("LN","SUBCID") quit

		set DATA=Db.getOneRow("CBF,CDF","LN","SUBCID")

		// Commitment Billing flag must equal linked commitment
		if $P(DATA,$C(9),1)'=ln.cbf do Runtime.setErrMSG("LN","4284") quit:ER				

		// Commitment Delinquency flag must equal linked commitment
		if $P(DATA,$C(9),2)'=ln.cdf do Runtime.setErrMSG("LN","4286") quit:ER
		}
	} 
	quit

vau13 // Trigger AU_CBMET - After update of coupon info

	type public RecordLN ln
	/*
	------------------------------- Revision History -------------------
	10/09/01 - SIVCHUKA - 47644
		Created.
		This trigger will check and update value of LN.CBMET. 
		Section SETCPNS is moved from BU_COUPON_INFO trigger.
		The purpouse of this trigger is to update LN.CBMET before
		check on value of this data item will be performed 
		in LNCPN BEFORE_INSERT trigger.
		This will fix the problem when error msg was coming from ln
		account when payment method was switched from automated
		loan payment to coupon production.
	*/
	
	if 'ln.cbmet.oldVal,ln.cbmet do SETCPNS(.ln)
	if ln.cbmet.oldVal,ln.cbmet do SETCPNS(.ln)
	quit

SETCPNS(RecordLN ln) // Set up coupon information and dayend file for coupon production
	
	new numcpns,PMET
	if ln.cbmet=2,(ln.apcnd=""),(ln.pchnd="") set ln.cbmet.journal=0,ln.cbmet=1
	if ln.cbmet=1 set numcpns=$$CBMET1^LNFUNCS(ln.onp,ln.cntcr)
	if ln.cbmet=2 set numcpns=$$CBMET2^LNFUNCS("",ln.cboff,ln.apcnd,ln.anfre,ln.pchnd,ln.pcfre,ln.icm,ln.dist1nd,ln.dist1fre)
	if ln.cbmet=3 set numcpns=$$CBMET3^LNFUNCS("",ln.cboff,ln.cbfre,ln.dist1nd,ln.dist1fre)
	if ER do Runtime.setErrMSG("LN",3333,$G(RM)) quit
	set ln.cbond.journal=0,ln.cbond=ln.cbpnd
	 
	//Insert dayend entry for next date
	new XTJD,XPMET,XNCP,XPMT,XDIST
	set PMET=3 if ln.odt<ln.cbpnd set PMET=4
	set XTJD=%SystemDate
	set XPMET=PMET
	set XNCP=numcpns
	set XPMT=ln.pmt
	set XCID=ln.cid
	set XDIST=ln.dist1nd
	do Db.insert("LNCPN","PND,PMET,CID,NCP,NCN,NDD,TPT",":XTJD,:XPMET,:XCID,:XNCP,1,:XDIST,:XPMT")
	quit

vau14 // Trigger AU_CBPND - After update coupon book prod next date

	type public RecordLN ln
	// NEXT COUPON PRODUCTION DATE in the Past
	if ln.cbmet=3,ln.cbpnd'="",ln.cbpnd<%SystemDate do Runtime.setErrXBAD("LN",82,"CBPND",ln.cbpnd) quit:ER 
	quit
	

vau15 // Trigger AU_CCL_CPF_CRLMT - AU credit limit, comm link, comm flag

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	
	08/29/05 - KELLYP - CR 16684
		   Modified block of code that calls TTX^LNCL1 to post 
		   undisbursed funds transfers to pass the correct LN record.
		   Previously, this section was always passing the ln object 
		   that this trigger was being executed for, instead of the
		   loan's commitment.
	
	07/19/05 - RussellDS - CR 16614
		   Remove references to vpar("SYSTEM" and replace with variable
		   isSysChg based on system changes to columns that call this
		   trigger.
		   
		   Some PSL clean up.
		   
		   Removed old revision history.

	06/01/04 - KELLYP - CR 9670
		   Modified Db.delete call to use semicolons properly.  Also
		   removed pre-2001 history.
	*/
	
	type public Boolean ER

	type Boolean aruf, isSysChg
	type Number tamt
	          
	set aruf=""
	
	if (ln.ccl.oldVal'=ln.ccl)!(ln.cpf.oldVal'=ln.cpf) do { quit:ER 
		// See if link is valid
		if (ln.ccl.oldVal'=ln.ccl),ln.ccl'="" do { quit:ER
			
			type Boolean cpf, revf
			type Number avlbal, i, stat, XCCL
			type String crcd, data, PARAM

			set XCCL=ln.ccl

			// Cannot link account to itself
			if XCCL=ln.cid do Runtime.setErrMSG("LN",461) quit:ER 

			// Loan Linked to Invalid Commitment
			if 'Db.isDefined("LN","XCCL") do Runtime.setErrXBAD("LN",163,"CCL",XCCL) quit:ER 
		
			if ln.cpf do { quit:ER
				
				type Number XCCL

				set XCCL=ln.ccl
				type RecordLN ln1=Db.getRecord("LN","CID=:XCCL")
	
				// Commitment Billing Flag must equal linked commitment
				if ln1.cbf'=ln.cbf do Runtime.setErrMSG("LN","4284") quit:ER

				// Commitment Delinquency Flag must equal linked commitment
				if ln1.cdf'=ln.cdf do Runtime.setErrMSG("LN","4286") quit:ER
	
				// Loan Payment Frequency must equal linked commitment
				if ln1.dist1fre'=ln.dist1fre do Runtime.setErrMSG("LN","4285") quit:ER

				// Interest Reserve Processing flag must be enabled on this account
				if (ln1.irp=1),(ln.irp="") do Runtime.setErrMSG("LN","4305") quit:ER
			}

			type ResultSet rs=Db.select("AVLBAL,CPF,CRCD,REVF,STAT,ARUF","LN","CID=:XCCL") 
			quit:rs.isEmpty()
			
			set data=rs.next()
			set avlbal=rs.getCol(1)
			set cpf=rs.getCol(2)
			set crcd=rs.getCol(3)
			set revf=rs.getCol(4)
			set stat=rs.getCol(5)
			set aruf=rs.getCol(6)

			// Account ~p1 is not coded for commitment processing
			if 'cpf do Runtime.setErrMSG("LN",118,XCCL) quit:ER 
	
			// To prevent commitment with interest rate
																								if ln.cpf=1,ln.irn>0 do Runtime.setErrXBAD("LN",3004) quit:ER ;sivchuka 7/19/00

			// Loan Linked to Closed Commitment
			if stat=4 do Runtime.setErrXBAD("LN",164,"CCL",XCCL) quit:ER 

			// Credit limit for ~p1 exceeds undisbursed balance for ~p2
			set PARAM=ln.cid_"~"_XCCL          
			if ln.trb,ln.crlmt>avlbal do Runtime.setErrMSG("LN",650,PARAM) quit:ER    

			// Revolving commitments may not spawn sub-commitments
			if ln.cpf,revf do Runtime.setErrMSG("LN",2423) quit:ER 

			// Must use account of the same currency (~p1)
			if ln.crcd'=crcd do Runtime.setErrMSG("LN",6052,ln.crcd) quit:ER 
	
			// Make sure no more than five levels of commitments
			// First Level
			set XCCL=ln.ccl
			for i=1:1 quit:i>4!(XCCL="")  do { quit:ER!XCCL
				type RecordLN lnxccl=Db.getRecord("LN","CID=:XCCL")	
				set XCCL=lnxccl.ccl
			}
			// Commitment heirarchy five levels or less
			if i>4 do Runtime.setErrSTBLER("LN","CCL5") quit:ER 
		}
	
		// Maintain Master Commitments
		// Delete Old entries
		if ln.ccl.oldVal="",ln.cpf.oldVal do { 
			type Number ACN, XCCID
			
			set XCCID=ln.cid
			
			type ResultSet rs=Db.select("ACN","RELCIF","CID=:XCCID") quit:ER 
			while rs.next() do {
				set ACN=rs.getCol(1)
				do Db.delete("LNMCOM1","ACN=:ACN AND CID=:XCCID")
			}
	
		}
		// Add new entries
		if ln.ccl="",ln.cpf do {
			type Number ACN, XCCID
			
			set XCCID=ln.cid
	
			type ResultSet rs=Db.select("ACN","RELCIF","CID=:XCCID") quit:ER 
			while rs.next() set ACN=rs.getCol(1) do Db.insert("LNMCOM1","ACN,CID",":ACN,:XCCID")
	
		}
	}
	
	if (ln.crlmt.oldVal'=ln.crlmt) do { quit:ER 
		// Credit Limit Less Than Minimum
		if ln.crlmt<ln.mincl do Runtime.setErrXBAD("LN",143,"CRLMT",ln.mincl) quit:ER 

		// Credit Limit Greater Than Maximum
		if (ln.maxbal&(ln.amtreq>ln.maxbal)) do Runtime.setErrXBAD("LN",144,"CRLMT",ln.maxbal) quit:ER 
	
		// Maximum Aggregate Draw Amt can't be less than the loan amt
		if (ln.maxaggr'=""),(ln.maxaggr<ln.crlmt) do Runtime.setErrMSG("LN","4279") quit:ER

		if ln.ccl="" set aruf=ln.aruf       
		else  do {
			set XCCL=ln.ccl
			type RecordLN ln2=Db.getRecord("LN","CID=:XCCL")
			set aruf=ln2.aruf
		}
		// Validate credit limit change if commitment link
		if 'ln.aruf,ln.ccl'="" do { quit:ER 
			type Number tamt
			
			set tamt=ln.crlmt-ln.crlmt.oldVal
			if tamt'>0 quit 

			// Change to credit limit exceeds commitment available balance
			if tamt>ln.avlbal do Runtime.setErrMSG("LN",514) quit:ER 
		}

		// Process On Line Limit Check if Credit Limit Increases
		if (ln.crlmt>ln.crlmt.oldVal),(CUVAR.LIMPRO=1) do INIT^PROCLIM
	
		// Update Country, Industry and Soverign Risk Limits
		if CUVAR.LIMPRO do {
			
			type Number AMT, TOTCOM, TOTEXPI, TOTEXPS
			type String DATA, GRP, TMP
			
			if ln.grp="CBL" quit
			// BALCMP
			set AMT=ln.balcmp
			set CRCD=ln.crcd
			set TOTCOM=ln.crlmt.oldVal if AMT>ln.crlmt.oldVal set TOTCOM=AMT
			if ln.crlmt'>TOTCOM,ln.crlmt>ln.crlmt.oldVal quit 
			if ln.crlmt.oldVal'>AMT,ln.crlmt<ln.crlmt.oldVal quit
			
			type Number ACN, ADJ, TOTEXPC
			type String ACNDATA, CNTRY, GOVT, NEW, OLD, SIC, X
			
			set NEW=ln.crlmt set OLD=ln.crlmt.oldVal
			if CRCD'=%SystemCurrency do {
				set NEW=$$CONV^CRCDUTL(NEW,CRCD,%SystemCurrency,1)
				set OLD=$$CONV^CRCDUTL(OLD,CRCD,%SystemCurrency,1)
				set TOTCOM=$$CONV^CRCDUTL(TOTCOM,CRCD,%SystemCurrency,1)
				set AMT=$$CONV^CRCDUTL(AMT,CRCD,%SystemCurrency,1)
			}
			set ACN=ln.acn
			type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN")
			set CNTRY=cif.pcntry
			set GOVT=cif.govt
			set SIC=cif.sic
			if 'Db.isDefined("UTBLCNTRYLIM","CNTRY") do Runtime.setErrMSG("LN",3560,CNTRY) quit:ER 
			type RecordEXPCNTRY expcnt=Db.getRecord("EXPCNTRY","CNTRY=:CNTRY")
			set TOTEXPC=expcnt.totcomexp
			if $E($G(SIC)) do {
				type RecordEXPIND expind=Db.getRecord("EXPIND","IND=:SIC")
				set TOTEXPI=expind.totcomexp
			}
			if $G(GOVT) do {
				type RecordEXPCNSOV expcns=Db.getRecord("EXPCNSOV","CNTRY=CNTRY")
				set TOTEXPS=expcns.totcomexp
			}
			if OLD'<TOTCOM do {
				if NEW>AMT set ADJ=NEW-OLD
				else  set ADJ=AMT-OLD
			}
			else  set ADJ=NEW-TOTCOM
			set TOTEXPC=$$^SCARND(TOTEXPC+ADJ,0,"",%SystemCurrency)     
			do Db.update("EXPCNTRY","TOTCOMEXP=:TOTEXPC","CNTRY=:CNTRY")
			if $G(TOTEXPI) set TOTEXPI=TOTEXPI+ADJ do Db.update("EXPIND","TOTCOMEXP=:TOTEXPI","IND=:SIC")
			if $G(TOTEXPS) set TOTEXPS=TOTEXPS+ADJ do Db.update("EXPCNSOV","TOTCOMEXP=:TOTEXPC","CNTRY=:CNTRY")
		}
	}
	
	// Do transaction(s) to handle changes to commitment link or credit limit
	set (tamt(1),tamt(2),tamt(3))=0
	if (ln.crlmt.oldVal'=ln.crlmt),'(ln.ccl.oldVal'=ln.ccl),ln.ccl'="" set tamt(1)=ln.crlmt.oldVal-ln.crlmt

	if ln.isChanged("CCL", "SYSTEM") set isSysChg = 1
	else  if ln.isChanged("CPF", "SYSTEM") set isSysChg = 1
	else  if ln.isChanged("CRLMT", "SYSTEM") set isSysChg = 1
	else  set isSysChg = 0

	if ln.refflg=1, isSysChg set tamt(1)=ln.crlmt	// ARQ 39399

	if (ln.ccl.oldVal'=ln.ccl) do {
		// Delete link
		if ln.ccl="" set tamt(1)=ln.crlmt.oldVal      
		// Add link
		else  if ln.ccl.oldVal="" set tamt(1)=-ln.crlmt
		// Change link
		else  set tamt(1)=-ln.crlmt set tamt(2)=ln.crlmt.oldVal  
	}
	
	if (ln.crlmt.oldVal'=ln.crlmt),'(ln.ccl.oldVal'=ln.ccl),ln.ccl="" set tamt(1)=ln.crlmt-ln.crlmt.oldVal
	;
	if ln.refflg=1, isSysChg set tamt(1)=ln.crlmt	

	if (ln.crlmt.oldVal'=ln.crlmt),ln.ccl'="",ln.aruf set tamt(3)=ln.crlmt-ln.crlmt.oldVal
	;
	if ln.refflg=1, isSysChg set tamt(1)=ln.crlmt

	// Post transaction(s)
	if aruf!(ln.ccl.oldVal'=ln.ccl) for I=1,2,3 if tamt(I) do { 
		type Number LINKCID, TAMT, XCID
		
		set XCID=CID                          
		set TAMT=tamt(I)
		if I=1 set LINKCID=ln.ccl
		else  set LINKCID=ln.ccl.oldVal
		if LINKCID="" set LINKCID=ln.ccl.oldVal
		if LINKCID="" set LINKCID=CID   
		
		// "~p1 limit modified."
		if (ln.crlmt.oldVal'=ln.crlmt) set TCMT=$$^MSG(4101,XCID)
		
		// Protect from ^LNCL1
		type Number CID
		if I=3 set CID=XCID                 
		else  set CID=LINKCID
		
		// Get the correct corresponding LN record to pass to LNCL1
		type RecordLN lntmp=Db.getRecord("LN","CID=:CID")
		
		do TTX^LNCL1(.lntmp)
		}
	
	// Loan Withdrawal Limit must be changed manually 
	if (ln.crlmt.oldVal'=ln.crlmt),ln.wdlmtp=1 do Runtime.setErrXBAD("LN",527) quit:ER 
	
	quit

vau16 // Trigger AU_CHECK - After Update Checkbook Processing Trigge

	type public RecordLN ln
	/*
	-----Revision History---------------------------------------------------
	12/27/00 - RAJARAMD - 42288
		   Created this trigger. Added code to insert a new record into
		   the Checkbook Production table (CHKPRD) during loan account
		   maintenance if the LN.CHKEURO and LN.CHKISS options are 
		   enabled, and if the LN.CHKCNT is greater than zero.
	*/

	if %ProcessMode=2,ln.chkeuro=1,ln.chkiss=1,ln.chkcnt>0 do { quit:ER
		new XBOO,XCID,XCHKS,XCHKCNT,XACN,XTJD,XUID
		set XBOO=ln.boo
		set XCID=ln.cid
		set XCHKS=ln.chks
		set XCHKCNT=ln.chkcnt
		set XACN=ln.acn
		set XTJD=%SystemDate
		set XUID=%UserID
		do Db.insert("CHKPRD","BRCD,TJD,CID,CHKS,SEQ,CHKCNT,UID,STAT,ACN",":XBOO,:XTJD,:XCID,:XCHKS,1,:XCHKCNT,:XUID,0,:XACN")
		}
	quit	

vau17 // Trigger AU_CID - After Cid change

	type public RecordLN ln
	/*
								---- Revision History ------------------------------------------------
 	
	03/30/05 - KinI - 14385
		   Cleaned up to comply with DBI standards. 
	*/

	if ln.lcad="" quit 

	type Number NEWCID,XCID
	type Date DATA,XTJD

	set NEWCID=ln.cid
	set XCID=ln.cid.oldVal
	set XTJD=%SystemDate-5

	type ResultSet rs=Db.select("TJD","DAYENDLCHG","CID=:XCID AND TJD>:XTJD")
	if rs.isEmpty() quit
	while rs.next() do { 
		set DATA=rs.getCol(1)
	
		type RecordDAYENDLCHG dayendlchg=Db.getRecord("DAYENDLCHG","CID=:XCID,TJD=:DATA")
		set dayendlchg.cid=NEWCID
		do dayendlchg.bypassSave()
		}
	quit

vau18 // Trigger AU_CNVDT - After Update Conversion Date

	type public RecordLN ln
	/* ------------- Revision History -------------------------------------

	03/30/05 - KinI - 14385
		   Cleaned up to comply with DBI standards.
		   Retrofitted CR4000 fix from P01: 
		   Removed Conversion Notification date (LN.CNDT) check for
																			business date since Conversion Notification Date will always
																			be a business date when a calendar is set.  
																			Moved Strike update code to Before Update Conversion Date
																			(BU_CNVDT) trigger.

	04/09/01 - APPLEYARDM - 44274
		   Roll forward ARQ 40572: Added check for conversion
		   notification date if is is a NBD and ln.cfreq is not coded
		   for actual date.
	 ----------------------------------------------------------------------
	*/

	if ln.cnvdt="" quit

	type public Boolean ER	

	// Conversion date must be a business date
	if '$$BD^UNBD(ln.cnvdt,ln.cncal) do Runtime.setErrXBAD("LN","CDTBUS") quit:ER

	// Conversion date requires conversion notification offset
	if ln.cnoff="" do Runtime.setErrXBAD("LN","CDROFF") quit:ER

	// Conversion date must be after the system date
	if ln.cnvdt'>%SystemDate do Runtime.setErrXBAD("LN","CDTASD") quit:ER

	// Conversion Notification Date must be after system date
	if ln.cndt'>%SystemDate do Runtime.setErrXBAD("LN","CNTASD") quit:ER      
	
	quit

vau19 // Trigger AU_CNVINFO - After Update Conversion Date Info

	type public RecordLN ln
	//Conversion date requires conversion notification offset
	if ln.cnvdt'="",ln.cnoff="" do Runtime.setErrMSG("LN",3183) quit
	quit

vau20 // Trigger AU_CNVSTAT - After Update Manual Conversion Status

	type public RecordLN ln
	/*
	This trigger sets the loan for conversion. It is invoked when the loan
	status changes to 1. The process involves setting XCNVMAN entry with the
	history cutoff sequence.
	*/

	if %O=0 quit

	if ln.cnvstat=1 do {
	 	new XTSEQ,XCID
	 	set XCID=ln.cid
	 	set XTSEQ=Db.nextVal("HIST","CID=:XCID")
	 	do Db.insert("XCNVMAN","TSEQ,CID",":XTSEQ,:XCID")
	}
	quit

vau21 // Trigger AU_CONVACN - After Update trigger for CONVACN column.

	type public RecordLN ln
								/*
								---- Revision History ------------------------------------------------

	03/30/05 - KinI - 14385
																			Cleaned up to comply with DBI standards.
	 
								07/29/01 - VETSENM - 46279
																			Set error message for Non-PROFILE account if Conversion
																			Account (LN.CONVACN) is not defined.
								*/ 

	type public Boolean ER
	
	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")

	// Conversion Account Required for Non-PROFILE Institution Account.
	if (prodctl.nonpa=1) , (ln.convacn="") do Runtime.setErrMSG("LN",4896) quit:ER
	quit

vau22 // Trigger AU_DARCOVR - After Update Delinquency Override

	type public RecordLN ln
	/*
	----Revision History---------------------------------------------------

 	08/10/05 - TITOVE - CR 16844
		   Cleaned up as part of DBI3 project. 
	
	*/

	// Asset Class Override has to have a valid value
	if 'ln.darcovr quit

	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE = :ln.type")
	
	// Delinquency reclassification processing not valid for product type ~p1
	if 'prodctl.darcpo do Runtime.setErrMSG("LN",1292,ln.type) quit
	
	// Verify the value exist in UTBLACC: "Invalid table value ~p1"
	if 'Db.isDefined("UTBLACC","ln.cls,ln.darcovr") do Runtime.setErrMSG("LN",1485,"UTBLACC.AC") quit 

	quit

vau23 // Trigger AU_DEF_INT_INFO - After update deferred interest info

	type public RecordLN ln
	/*
		revision history
	1/21/03- sPIER - CR 7985
		Corrected error with Recorddayendgegam in db.delete code
		which caused a compile error.
		
	1/7/03 - Spier - cr7501
		Modified to build DAYENDNEGAM table and delete it as well when dirnd is changed
		
	*/
	if ln.dico'="" do { quit:ER 
		if ln.ditgacn'="" do { quit:ER 
			new data,XCID
			set XCID=ln.cid
			set data=Db.getOneRow("CLS,STAT","LN","XCID") quit:ER 

			// Capitalization Target Account Not Found
			if $P($G(data),$C(9),1)'="L" do Runtime.setErrXBAD("LN",145) quit:ER 

			// Deferred Interest Target Account Closed
			if $P($G(data),$C(9),2)=4 do Runtime.setErrXBAD("LN",146) quit:ER 
			}
		// Deferred Int Resolution Frequency Missing
		if ln.dico="FR",ln.dirfre="" do Runtime.setErrXBAD("LN",147) quit:ER 

		// Deferred Int Not Billed or Capitalized
		if ln.dico="BL",ln.dirnd<ln.bldt do Runtime.setErrXBAD("LN",148) quit:ER 

		// Def Int Next Resolution Date Not Found
		if ln.dico="FR"!(ln.dico="BL"),ln.dirnd="" do Runtime.setErrXBAD("LN",151) quit:ER 

		// Def Int Next Res Date Precedes System Date
		if ln.dirnd'="",ln.dirnd'>%SystemDate do Runtime.setErrXBAD("LN",150) quit:ER 
		}
	if ln.isChanged("DIRND") do {
		type Date old
		set old=ln.dirnd.oldVal
		if old,Db.isDefined("DAYENDNEGAM","TJD=:old,CID=:CID") do Db.delete("DAYENDNEGAM","TJD=:old and CID=:CID")
		if ln.iropt=1!(ln.iropt=2) do {
					
			type RecordDAYENDNEGAM negam=Class.new("RecordDAYENDNEGAM","TJD=:ln.dirnd,CID=:CID")
			do negam.bypassSave()
		}
	}
	quit

vau24 // Trigger AU_DIST1FRE - After update master distribution freq

	type public RecordLN ln

								/*
								---- Revision History ------------------------------------------------
	
								04/05/00 - KELLYP - 35505
																			Added check to ensure that, if the Commitment Billing flag
		   (LN.CBF) is enabled on an account linked to a commitment, 
		   then LN.DIST1FRE must be the same on the account as it is 
		   on the commitment.

	*/


	// Distribution 1 frequency cannot be changed from a *
	if ln.dist1fre.oldVal="*" do Runtime.setErrMSG("LN",1784) quit:ER 

	// Payment elements may not be linked to master frequency of *
	if ln.dist1fre="*",("-"_ln.pmtdistf_"-")["-1-" do Runtime.setErrMSG("LN",1783) quit:ER 

								if (ln.ccl'=""),(ln.cbf) do { quit:ER    // PK - 35505
		new XCCL,XDIST

																set XCCL=ln.ccl
																set XDIST=Db.getOneRow("DIST1FRE","LN","XCCL")
	
																// Loan's payment frequency must equal linked commitment's
																if XDIST'=ln.dist1fre do Runtime.setErrMSG("LN","4285") quit:ER
																}

	
	// Unique considerations if change from regular frequency to payment schedule
	if ln.dist1fre="*" do { quit 

 		new I,XCID,columns,d2f,d3f,d4f,data,dist,element1,element2,fpc,seq
		new sqlcnt,update,values,ZVAL
	
		set XCID=ln.cid
	
		// Load all PEnnEA (Acronyms) and PEnnPF (Distributions) from LNBIL0 table
	
		new v set v="" 
		set v=v_"PE01EA,PE01PF,PE02EA,PE02PF,PE03EA,PE03PF,PE04EA,PE04PF,PE05" 
		set v=v_"EA,PE05PF,PE06EA,PE06PF,PE07EA,PE07PF,PE08EA,PE08PF,PE09EA,P" 
		set v=v_"E09PF,PE10EA,PE10PF,PE11EA,PE11PF,PE12EA,PE12PF,PE13EA,PE13P" 
		set v=v_"F,PE14EA,PE14PF,PE15EA,PE15PF,PE16EA,PE16PF,PE17EA,PE17PF,PE" 
		set v=v_"18EA,PE18PF,PE19EA,PE19PF,PE20EA,PE20PF" 
		set data=Db.getOneRow(v,"LNBIL0","XCID")
			
		/*	
		Build array element1 in form element1(seq)= acronym
		and array element2 in form element2(acronym)= distribution | seq
		For this purpose, seq is equal to 'nn' in column names LNBIL1.PEnnEA etc.
		*/
		set quit=0 for I=1:2:39 do { quit:quit 
	
			new seq,seq2char
	
			// No more elements defined for this loan
			if $P(data,$C(9),I)="" set quit=1 quit 
	
			// Which element are we dealing with?
			set seq=(I+1)/2
	
			// Two character sequence used in column names
			set seq2char=$E(100+seq,2,3)
	
			//  If element distribution is equal to null, change to 1
			if '$P(data,$C(9),(I+1)) set $P(data,$C(9),(I+1))=1
	
			set element1(seq)=$P(data,$C(9),I)
			set element2($P(data,$C(9),I))=$P(data,$C(9),(I+1))_"|"_seq2char
	
			}

		/*		
		Increment all distributions found in LNBIL0 by 1.  This is because
		no elements in payment schedule processing are linked to 1st distribution
		*/
		type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID")
		set (I,update)="" for  set I=$O(element2(I)) quit:I=""  do {
			set update=1
			
			// New distribution
			set dist=element2(I)+1
			set seq=$P(element2(I),"|",2)
	
			set $P(element2(I),"|",1)=dist
	
			if seq=1 set X=lnbil0.pe01 set $P(X,"#",4)=dist,lnbil0.pe01=X
			if seq=1 set X=lnbil0.pe02 set $P(X,"#",4)=dist,lnbil0.pe02=X
			if seq=1 set X=lnbil0.pe03 set $P(X,"#",4)=dist,lnbil0.pe03=X
			if seq=1 set X=lnbil0.pe04 set $P(X,"#",4)=dist,lnbil0.pe04=X
			if seq=1 set X=lnbil0.pe05 set $P(X,"#",4)=dist,lnbil0.pe05=X
			if seq=1 set X=lnbil0.pe06 set $P(X,"#",4)=dist,lnbil0.pe06=X
			if seq=1 set X=lnbil0.pe07 set $P(X,"#",4)=dist,lnbil0.pe07=X
			if seq=1 set X=lnbil0.pe08 set $P(X,"#",4)=dist,lnbil0.pe08=X
			if seq=1 set X=lnbil0.pe09 set $P(X,"#",4)=dist,lnbil0.pe09=X
			if seq=1 set X=lnbil0.pe10 set $P(X,"#",4)=dist,lnbil0.pe10=X
			if seq=1 set X=lnbil0.pe11 set $P(X,"#",4)=dist,lnbil0.pe11=X
			if seq=1 set X=lnbil0.pe12 set $P(X,"#",4)=dist,lnbil0.pe12=X
			if seq=1 set X=lnbil0.pe13 set $P(X,"#",4)=dist,lnbil0.pe13=X
			if seq=1 set X=lnbil0.pe14 set $P(X,"#",4)=dist,lnbil0.pe14=X
			if seq=1 set X=lnbil0.pe15 set $P(X,"#",4)=dist,lnbil0.pe15=X
			if seq=1 set X=lnbil0.pe16 set $P(X,"#",4)=dist,lnbil0.pe16=X
			if seq=1 set X=lnbil0.pe17 set $P(X,"#",4)=dist,lnbil0.pe17=X
			if seq=1 set X=lnbil0.pe18 set $P(X,"#",4)=dist,lnbil0.pe18=X
			if seq=1 set X=lnbil0.pe19 set $P(X,"#",4)=dist,lnbil0.pe19=X
			if seq=1 set X=lnbil0.pe20 set $P(X,"#",4)=dist,lnbil0.pe20=X
			}
	
		if update'="" do lnbil0.save()
		// Insert payment schedule row for elements in distribution 2
		if ln.dist2nd'="" do {
	
			set XFPC="" if +$G(element2("P"))=2 set XFPC=ln.fpa
	
			new XCID,XPDD                     
			set XCID=ln.cid 
			set XPDD=ln.dist2nd
			do Db.insert("LNPS1","CID,PDD,D2F,FPC",":XCID,:XPDD,1,:XFPC")
	
			}
	
		// Insert payment schedule row for elements in distribution 3
		if ln.dist3nd'="" do {
	
			set XFPC="" if +$G(element2("P"))=3 set XFPC=ln.fpa
	
			new XCID,XPDD               
			set XCID=ln.cid 
			set XPDD=ln.dist3nd
			do Db.insert("LNPS1","CID,PDD,D3F,FPC",":XCID,:XPDD,1,:XFPC")
			}
	
		// Insert payment schedule row for elements in distribution 4
		if ln.dist4nd'="" do {
	
			set XFPC="" if +$G(element2("P"))=4 set XFPC=ln.fpa
	
			new XCID,XPDD        
			set XCID=ln.cid 
			set XPDD=ln.dist4nd
			do Db.insert("LNPS1","CID,PDD,D4F,FPC",":XCID,:XPDD,1,:XFPC")
			}
	
		// Build payment schedule from existing payment records
	
		// Load LNBIL1 table CDPD (due date), PEnnEA (Element), PEnnAB (Amount Billed)
	
		set data=""
		new rs 
		new list
		set list="CDPD,PE01EA,PE01AB,PE02EA,PE02AB,PE03EA,PE03AB,PE04EA,PE04AB,PE05EA,PE05AB,PE06EA"
		set list=list_",PE06AB,PE07EA,PE07AB,PE08EA,PE08AB,PE09EA,PE09AB,PE10EA,PE10AB,PE11EA,PE11AB,PE12EA,PE12AB,PE13EA"
		set list=list_",PE13AB,PE14EA,PE14AB,PE15EA,PE15AB,PE16EA,PE16AB,PE17EA,PE17AB,PE18EA,PE18AB,"
		set list=list_"PE19EA,PE19AB,PE20EA,PE20AB"
		type ResultSet rs=Db.select(list,"LNBIL1","CID=:XCID")
		if rs.isEmpty() quit
		while rs.next()  do { quit:ER
			set data=rs.getRow()
			/*
			Build payment schedule lnps1 row where:
	
			pdd = payment due date
			d2f = indicator of whether or not elements in dist 1 are billed
			d3f = indicator of whether or not elements in dist 2 are billed
			d4f = indicator of whether or not elements in dist 3 are billed
			fpc = fixed principal amount
			*/
	
			set (d2f,d3f,d4f,fpc)=""
			set pdd=$P(data,$C(9),1)

			for I=2:2 set PEnnEA=$P(data,$C(9),I) quit:PEnnEA=""  do {

				set PEnnAB=$P(data,$C(9),(I+1))
				if 'PEnnAB quit 
	
				set dist=$P(element2(PEnnEA),"|",1)
	
				if PEnnAB do {
					if dist=2 set d2f=1
					if dist=3 set d3f=1
					if dist=4 set d4f=1
	
					}
	
				if PEnnEA="P" set fpc=PEnnAB
	
				}
	
			new XCID,XPDD,XD2F,XD3F,XD4F,XFPC   
			set XCID=ln.cid 
			set XPDD=pdd 
			set XD2F=d2f 
			set XD3F=d3f 
			set XD4F=d4f 
			set XFPC=fpc
			do Db.insert("LNPS1","CID,PDD,D2F,D3F,D4F,FPC",":XCID,:XPDD,:XD2F,:XD3F,:XD4F,:XFPC")
	
			}
	
		}
	
	quit

vau25 // Trigger AU_DIST1ND - After update of next due date

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	06/22/00 - JERUCHIMC - 40734
		   Added an additional check before setting error
       		   1901 to see if the system changed the data item.
       		   If the system changed the next due date, we want
        	   to allow it.
	
	09/02/99 - ALBINK - 33413
		   Added check so that the account's due date may only be
		   advanced when the loan has been disbursed.  For future
		   dated disbursements, added check so next billing date
		   cannot precede the disbursement date.  Deleted line of code
		   to quit if DIST1ND is changed by the system.  This code
		   needs to be processed whenever DIST1ND is modified.
	*/	
	
	new count,jd,quit,tba
	
	set quit=0
	
	/*
	*** Verifications ***************************************************
	DIST1ND changes prohibited if amounts exist in payment file.
	"Satisfy outstanding obligation of ~p1 before attempting to advance
	due date"
	*/

	if ln.tba set tba=ln.tba do Runtime.setErrMSG("LN",1835,tba) quit:ER 
	
	// "The account's due date may only be advanced" 
	if '(ln.isChanged("DIST1ND","SYSTEM")),ln.bal,ln.dist1nd'>ln.dist1nd.oldVal do Runtime.setErrMSG("LN",1901) quit:ER 
	
	// "Billing precedes disbursement date"  
	if ln.odd'<ln.dist1nd do Runtime.setErrMSG("LN",354) quit:ER 
	
	/*
	"Changes to account's due date prohibited when payment frequency
	field is empty"
	*/
	if ln.dist1fre="" do Runtime.setErrMSG("LN",61) quit:ER 
	
	/*
	"The new due date must be after the due date of the last payment
	record on file"
	*/
	if ln.dist1nd'>ln.lbdd do Runtime.setErrMSG("LN",1867) quit:ER 
	
	/*
	Find payment dates to build.  Each payment record will be due
	after LN.LBDD, and based on the later of LN.LBDD or LN.SCHND
	*/
	set jd=ln.schnd 
	set count=0
	if ln.dist1fre="*",jd=ln.dfp set jd=ln.odd
	else  set jd=$$NJD^UFRE(jd,ln.dist1fre,,1) quit:ER
	for  set jd=$$NJD^UFRE(jd,ln.dist1fre) quit:ER  do { quit:quit 
	
		// Payment record already exists
		if jd'>ln.lbdd quit 
	
		// Payment records before date of first payment
		if jd<ln.dfp quit 
	
		// Only payment records due before the new date must be built
		if jd'<ln.dist1nd set quit=1 quit 
	
		// Guard against infinite loop if account data is corrupted
		set count=count+1 if count>1000 set quit=1 quit 
	
		// Construct payment date array for later use
		set payments(jd)=""
	
		}
	
	// "The new due date must correspond to the account's payment frequency"
	if ln.dist1nd'=jd do Runtime.setErrMSG("LN",1871) quit:ER 
	
	
	/*
	*** Processing ******************************************************
	
	Create zero-amount bills for all due dates between LBDD and
	the new value of DIST1ND, exclusive.
	*/
	
	new cbcd,cid,cirn,coia,cdib,copb,pmtdat,pmtarray
	
	// Account number
	set cid=ln.cid   
	// Cut-off date
	set cbcd=%SystemDate                  
	// Interest rate
	set cirn=ln.irn 
	// Interest adjustment
	set coia=$$^SCARND(ln.inta,,cid)
	// Balance
	set copb=ln.balint
	// Deferred interest
	set cdib=ln.dic-ln.narl
	
	set pmtdat=""
	for  set pmtdat=$O(payments(pmtdat)) quit:pmtdat=""  do {
	
		set pmtarray(pmtdat,"*","LNBIL1.CBCD")=cbcd
		set pmtarray(pmtdat,"*","LNBIL1.CIRN")=cirn
		set pmtarray(pmtdat,"*","LNBIL1.COIA")=coia
		set pmtarray(pmtdat,"*","LNBIL1.COPB")=copb
		set pmtarray(pmtdat,"*","LNBIL1.CDIB")=cdib
	
		}
	
	set ER=$$CHANGE^PROCLNBL(cid,.pmtarray,,0)
	
	quit

vau26 // Trigger AU_DIST2_INFO - After update distribution 2 info

	type public RecordLN ln
	new njd
	
	if ln.dist2fre'="" do {
		// Account is not coded to allow for multiple frequencies
		if '(ln.dist1fre="*"!(ln.mdf)) do Runtime.setErrSTBLER("LN","LNEDGP") quit:ER 

		// Master frequency of * only allows secondary frequencies of * - ~p1
		if ln.dist1fre="*",ln.dist2fre'="*" do Runtime.setErrMSG("LN",1782,"LN.DIST2FRE") quit:ER 

		// ~P1 Must be a multiple of master payment frequency
		if ln.dist2fre'="*",'$$CHK2FRE^LNFUNCS(ln.cid,ln.dist1fre,ln.dist2fre) do Runtime.setErrMSG("LN",1795,"LN.DIST2FRE") quit:ER 
		}
	
	// Requires "*" master payment frequency
	if ln.dist2fre="*",ln.dist1fre'="*" do Runtime.setErrSTBLER("LN","PFRE*3") quit:ER 
	
	if ln.pmtdistf["2" do {
		set njd=$$CHK2ND^LNFUNCS(ln.cid,ln.dist1fre,ln.dist1nd,ln.dist2fre,2,ln.dist2nd,ln.bloff,%SystemDate)

		// Invalid Next 2nd Payment Date
		if njd'="" do Runtime.setErrXBAD("LN",88,"DIST2ND",ln.dist2nd,njd) quit:ER 
		}
	quit

vau27 // Trigger AU_DIST3_INFO - After update distribution 3 info

	type public RecordLN ln
	new njd
	
	if ln.dist3fre'="" do {
		// Account is not coded to allow for multiple frequencies
		if '(ln.dist1fre="*"!(ln.mdf)) do Runtime.setErrSTBLER("LN","LNEDGP") quit:ER 

		// Master frequency of * only allows secondary frequencies of * - ~p1
		if ln.dist1fre="*",ln.dist3fre'="*" do Runtime.setErrMSG("LN",1782,"LN.DIST3FRE") quit:ER 

		// ~P1 Must be a multiple of master payment frequency
		if ln.dist3fre'="*",'$$CHK2FRE^LNFUNCS(ln.cid,ln.dist1fre,ln.dist3fre) do Runtime.setErrMSG("LN",1795,"LN.DIST3FRE") quit:ER 
		}
	
	// Requires "*" master payment frequency
	if ln.dist3fre="*",ln.dist1fre'="*" do Runtime.setErrSTBLER("LN","PFRE*3") quit:ER 
	
	if ln.pmtdistf["3" do {
		set njd=$$CHK2ND^LNFUNCS(ln.cid,ln.dist1fre,ln.dist1nd,ln.dist3fre,3,ln.dist3nd,ln.bloff,%SystemDate)

		// Invalid Next 3rd Payment Date
		if njd'="" do Runtime.setErrXBAD("LN",89,"DIST3ND",ln.dist3nd,njd) quit:ER 
		}
	quit

vau28 // Trigger AU_DIST4_INFO - After update distribution 4 info

	type public RecordLN ln
	new njd
	
	if ln.dist4fre'="" do {
		// Account is not coded to allow for multiple frequencies
		if '(ln.dist1fre="*"!(ln.mdf)) do Runtime.setErrSTBLER("LN","LNEDGP") quit:ER 

		// Master frequency of * only allows secondary frequencies of * - ~p1
		if ln.dist1fre="*",ln.dist2fre'="*" do Runtime.setErrMSG("LN",1782,"LN.DIST2FRE") quit:ER 

		// ~P1 Must be a multiple of master payment frequency
		if ln.dist4fre'="*",'$$CHK2FRE^LNFUNCS(ln.cid,ln.dist1fre,ln.dist4fre) do Runtime.setErrMSG("LN",1795,"LN.DIST4FRE") quit:ER 
		}
	
	// Requires "*" master payment frequency
	if ln.dist4fre="*",ln.dist1fre'="*" do Runtime.setErrSTBLER("LN","PFRE*3") quit:ER 
	
	if ln.pmtdistf["4" do {
		set njd=$$CHK2ND^LNFUNCS(ln.cid,ln.dist1fre,ln.dist1nd,ln.dist4fre,4,ln.dist4nd,ln.bloff,%SystemDate)

		// Invalid Next 4th Payment Date
		if njd'="" do Runtime.setErrXBAD("LN",90,"DIST4ND",ln.dist4nd,njd) quit:ER 
		}
	quit

vau29 // Trigger AU_DOD_INTEG - Date of Death/Disability Integrity Check

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	
	07/19/05 - RussellDS - CR16614
		   Removed references to vpar array, replaced with vpar
		   variable.
		   
		   Minor PSL clean up.
		   
		   Removed old revision history.
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards.
	
	06/01/04 - KELLYP - CR 9670
		   Modified vpar check to avoid operator precedence warning.
	-----------------------------------------------------------------------
	
	This trigger should never have a column name associated with it.  
	It should be called for any and all CIF maintenance.
	*/
	
	type public Boolean ER
	type public String verrors()

	type Boolean DISBRST, DODRST
	type String VERR1, VERR2
	
	quit:vpar.isLike("%/NOVALRI/%")
	quit:vpar.isLike("%/FRMFILER/%")
	
	type RecordCIF cif = Db.getRecord("CIF","ACN=:ln.acn")

	// Verify that the CIFDOD and CIFDODSABL restrictions have not been set.
	// Do not set the restrictions a second time.

	set (DODRST,DISBRST) = 0
	set (VERR1,VERR2) = ""
	
	for  set VERR1=verrors(VERR1).order() quit:VERR1.isNull()  do {
		for  set VERR2=verrors(VERR1,VERR2).order() quit:VERR2.isNull()  do {
			if verrors(VERR1,VERR2).piece("|",3) = "CIFDOD" set DODRST = 1
			if verrors(VERR1,VERR2).piece("|",3) = "CIFDODSABL" set DISBRST = 1
		}
	}
	
	// An account owner is deceased
	if (cif.dod > 0), 'DODRST do Runtime.setErrXBAD("LN","CIFDOD") quit:ER 

	// An account owner is disabled
	if (cif.dodsabl > 0) , 'DISBRST do Runtime.setErrXBAD("LN","CIFDODSABL") quit:ER

	quit 

vau30 // Trigger AU_DPA - AFTER UPDATE DPA

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------

	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards.
		
	03/17/99 - FINCHG - 27393
		   Added check - DPA must be a deposit account
	*/
	
	type public Boolean ER

	// Deposit Payoff Account 
	if ln.dpa'="" do { quit:ER 

		type RecordACN acn
		set acn=Db.getRecord("ACN","CID=:ln.dpa")
		
		// Deposit payoff account must be a deposit account
		if acn.cls'="D" do Runtime.setErrXBAD("LN","LNDPA") quit:ER

		}
	
	quit

vau31 // Trigger AU_DPMT - After insert next due date - pmt amount

	type public RecordLN ln
	// Invalid due payment amount
	if ln.dpmt>0,ln.tba'>0 do Runtime.setErrXBAD("LN",181,"DPMT",ln.dpmt,0) quit:ER 
	quit
	

vau32 // Trigger AU_DTC - After update date account closed

	type public RecordLN ln
	// Open Account has DATE CLOSED
	if ln.dtc'="",ln.stat'=4 do Runtime.setErrXBAD("LN",122,"DTC",ln.dtc) quit:ER 
	quit
	

vau33 // Trigger AU_DXSI - After Update Deferred Excess Interest

	type public RecordLN ln
	/*---- Revision History ------------------------------------------------
	
			09/11/00 - GOMAAR - 41648 
	      Roll Forward for ARQ # 37508 from v6.2
														Added verification check on Bill Capitalized Interest
														as Principal flag and Defer Interest In Excess of Accrual flag.

			---------------------------------------------------------------------*/

	// Deferred Excess interest flag and the Capitalize interest flag cannot both
	// be set at the same time.
	if ln.dxsi,ln.icap do Runtime.setErrMSG("LN","4207") quit:ER
	
	// Defer Excess Accrual must be set when Bill Cap Int as Prin
	if (ln.bcapint),'(ln.dxsi) do Runtime.setErrXBAD("LN","BCAPINT") quit:ER
	quit

vau34 // Trigger AU_ESCROW - After update - changes affecting escrows

	type public RecordLN ln
	/*

	Update escrow account(s) to reflect changes to the columns that fire this
	trigger
	---- Revision History ------------------------------------------------
	
	03/30/06 - RussellDS - CR16892
	   	   Remove references to obsolete membership info.

	03/13/06 - Srinivar -19975	
		   Modified the trigger to fetch the Escrow CID 
		   using $$ECID^LNU instead of $$GETESC^ESCFUNCS.
	
	01/28/04 - CARROLLJ - CR7997
		   Corrected undefined error on variable XMEMNBR.


	*/

	type Number ESCCID,UPDT
		
	
	// Create UPDATE statement based on changed columns
	set UPDT=0
	
	set ESCCID=$$ECID^LNU(ln.cid,"ESC1")
	if ESCCID.isNull() quit
	
	new dep
	type RecordDEP dep=Db.getRecord("DEP","ESCCID")
	if (ln.boo.oldVal'=ln.boo) set dep.boo=ln.boo,UPDT=1
	if (ln.cc.oldVal'=ln.cc) set dep.cc=ln.cc,UPDT=1
	if (ln.ccode.oldVal'=ln.ccode) set dep.ccode=ln.ccode,UPDT=1
	if (ln.mf.oldVal'=ln.mf) set dep.mf=ln.mf,UPDT=1
	if (ln.rescd.oldVal'=ln.rescd) set dep.rescd=ln.rescd,UPDT=1
	
	if UPDT do {
		if vpar.isLike("%/NOUPDATE/%") do dep.save("NOUPDATE/NOINDEX/NOJOURNAL")  if 1 
		else  do dep.save()	
		}
		
	quit

vau35 // Trigger AU_FIA - After Update trigger for FIA column

	type public RecordLN ln
	/*---------- Revision History ------------------------------------------ 

		05/09/06 - Dhanalakshmi R - 21105
		      Modified to use Db.getRecord with getmode instead
		      of Db.insert.

		03/16/06 - ratht - CR 20111
		      Used ln.genprjrep instead of REP variable and 
		      reference %SystemDate instead of DATE in the 
		      Db.insert() statement.
		      
		11/07/00 - VETSENM - 40359

	              If LN.GENPRJREP is set to "Yes" than an entry will be set
																						into the table DAYENDLNNOT.       
	------------------------------------------------------------------------ */ 


	if ln.genprjrep=1 do {

		type public Number CID
		type RecordDAYENDLNNOT lnnot=Db.getRecord("DAYENDLNNOT","DT=:%SystemDate,CID=:CID,ID=4",1)

		if 'lnnot.getMode() do lnnot.bypassSave()
	}
	quit

vau36 // Trigger AU_FPA - After Update trigger for FPA column.

	type public RecordLN ln
	
	/*---------- Revision History------------------------------------------ 

	05/09/06 - Dhanalakshmi R - 21105
		   Modified to use Db.getRecord with getmode instead
		   of Db.insert.
	
	02/13/02 - VETSENM - 49054
		   Assign %SystemDate value to the variable DATE.	

	11/07/00 - VETSENM - 40359
	           
	-----------------------------------------------------------------------*/


	if ln.genprjrep=1 do {

		type public Number CID
		type RecordDAYENDLNNOT lnnot=Db.getRecord("DAYENDLNNOT","DT=:%SystemDate,CID=:CID,ID=4",1)

		if 'lnnot.getMode() do lnnot.bypassSave()
	}
	quit

vau37 // Trigger AU_GLSC - After update valid G/L set code.

	type public RecordLN ln
	/* 
	---- Revision History ------------------------------------------------

	06/01/05 - Kini - 16153
		   Added GLSC verification via GLCHK^ACNFUNCS to ensure that
		   the class and group of GLSC match the class and group of 
		   the loan.

	02/17/05 - Kini - 13991	
		   Modified to replace UTBLGLSCX index table with UTBLGLSC
		   since UTBLGLSCX has been obsoleted.
	*/
	
	type public Boolean ER
	
	// Validate G/L Set Code
	do GLCHK^ACNFUNCS(ln.cls,ln.grp,ln.glsc) quit:ER
	
	quit
	

vau38 // Trigger AU_GRP - After update group

	type public RecordLN ln
	/* ---- Revision History -----------------------------------------------
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards. 

	*/

	type public Boolean ER

	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")

	// Product class or group does not match product type
	if ln.grp'=prodctl.grp do Runtime.setErrMSG("LN",8472) quit:ER 

	quit
	

vau39 // Trigger AU_ICAP - Validate ICAP options

	type public RecordLN ln
	/*	
	Check for valid entries in IROPT and ICAP
	Interest Resolution option required
	*/

	if (ln.icap),'(ln.iropt) do Runtime.setErrXBAD("LN","IROPTREQ") quit:ER 

	// Interest Resolution option cannot be 1 if ICAP is "yes"
	if (ln.icap),(ln.iropt=1) do Runtime.setErrXBAD("LN","RESOPT") quit:ER 
	
	quit

vau40 // Trigger AU_IGRC - After Update

	type public RecordLN ln
	/*
	 ---- Revision History--------------------------------------------------

	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards.
	*/

	if ln.stat=4 quit 

	if ln.idpf'=1 quit

	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")
	if 'prodctl.defal quit  

	type RecordCIF cif
	set cif=Db.getRecord("CIF","ACN=:ln.acn")	
	if 'cif.semfin quit


	type Number AKEY,BUFF,SEQ
	type String NEW,OLD,TABLE

	if ln.igrc.oldVal set OLD=$$EOMJD^SCADAT($$EXT^UMDT(ln.igrc.oldVal,SEMFIN,"","N"))
	else  set OLD=$$EOMJD^SCADAT(SEMFIN)

	if ln.igrc set NEW=$$EOMJD^SCADAT($$EXT^UMDT(ln.igrc,SEMFIN,"","N"))
	else  set NEW=$$EOMJD^SCADAT(SEMFIN)

	// Update OLD, Turn it on

	set AKEY=ln.cid
	set SQL="UPDATE LN SET PTF=1 WHERE CID="_ln.cid
	set TABLE="LN" set SEQ=1
	set BUFF=Db.nextVal("EFD","OLD,SEQ")
	
	type RecordEFD efdold=Class.new("RecordEFD")

	set efdold.efdate=OLD
	set efdold.buff=BUFF	
	set efdold.seq=SEQ
	set efdold.akey=AKEY
	set efdold.table=TABLE
	set efdold.sql=SQL	

	do efdold.save()

	// Update NEW, turn it off

	set SQL="UPDATE LN SET PTF=0 WHERE CID="_ln.cid	
	set BUFF=Db.nextVal("EFD","NEW,SEQ")

	type RecordEFD efdnew=Class.new("RecordEFD")

	set efdnew.efdate=NEW
	set efdnew.buff=BUFF
	set efdnew.seq=SEQ
	set efdnew.akey=AKEY
	set efdnew.table=TABLE
	set efdnew.sql=SQL

	do efdnew.save()

	quit
	

vau41 // Trigger AU_INT_INFO - After update interest information

	type public RecordLN ln
	/*
	----Revision History---------------------------------------------------
	02/17/06 - TELIV - 19573
		   Added LN.MINRATE for the trigger event. Modified the check for 
		   Rate diffrential (IRN<MINRATE+(Max of DEP>IRN))
	
								03/27/05 - JERUCHIMC - 14822
																			Removed CRCD argument in call to RATEFC^LNFUNCS.
		   Retrofitted the following change:
			
																			04/11/04 - TITOVE - CR 8094
																			Modified to quit after first comparison of ln.ichnd to
																			%SystemDate (consistent with LNAI logic). Previously the
																			system would always set up an integrity error if ln.ichnd
																			was equal to today, no matter if the account utilizes
																			interest offset processing or not.

	01/28/04 - CARROLLJ - CR7997
		   Modified call to CTL^UINDX.

	01/17/02 - EDWARDSM - 47407
		   Updated trigger so that an error will be returned if an
		   Index Rounding Flag is defined without a Rounding Method
		   or a Rounding Method is defined without an Index Rounding
		   Flag.

	12/07/00 - PONGRACZD - 40927
		   Roll up change from ARQ 40201
		   Added call to INDFILE^LNU before call to CTL^UINDX to set
		   INDDATA up correctly.  Before, if there was no spread, an
		   extra space was included in INDDATA causing the rounding
		   method to be ingnored.

	08/25/00 - GOMAAR - 41615 
		   Condition of Error Message # 8745 was preventing the
																			Updating of the Interest rate on Effective Date of a loan
																			Account.

	07/19/00 - SIVCHUKA - 40946  (Original ARQ 1#37897 and 2#39849) 
	           Added Non-Fatal XBAD Massage(3004)"Commitment cannot accrue
																			interest"
																			The following message should appear if you attempt to open
																			a commitment with an interest rate, or modify a commitment
																			to have an interest rate. 
	
	07/12/99 - Jerry Petrole - 34005
		   Change for arq 33055 - Check to see that a new IRN falls
		   within account's min and max rates.
	
	03/10/99 - MALTEPESA 31813
		   Rolled code from v60 forward.
		   Added logic to not parse the INDEX field for Interest Matrix.
		   Also added logic to return error if creating an account
		   with Interest Matrix is set to null.
	
	02/27/99 - KLINEB - 32047
		   Roll forward from v5.3.
		   Moved logic for updating INTMAT, INTSPR, RNDMTD when INDEX is
		   updated to null to BU_INDEX trigger.  This was done for
		   processing considerations.  Modified logic to return error
		   message if INTMAT, INTSPR, or RNDMTD are defined and INDEX is
		   not, to accomodate these changes
	
	12/09/98 - HAYMANP - 30705
		   Modified logic to set XBAD code 91 from >SytemDate to '<.
		
	*/

	if (ln.index.oldVal'=ln.index),ln.index="" do {
		set ln.ichnd=""
		set ln.ichld=""
		set ln.intoff=""
		set ln.intfre=""
		set ln.ichm=""
		}
	
	// Interest Offset Required if a Payment change frequency exists
	if ln.intoff="" do { quit:ER 
		if ln.pcfre'="" do Runtime.setErrXBAD("LN","PCFRE") quit:ER 
		}
	if ln.intoff'="" do { quit:ER 
		// Interest Offset Requires an Index 
		if ln.index="" do Runtime.setErrXBAD("LN","INDEX15") quit:ER 
		}
	
	if ln.intfre'="" do { quit:ER 
		// Interest Change Frequency Requires an Index
		if ln.index="" do Runtime.setErrXBAD("LN",8) quit:ER 
	
		// Check against master frequency
		do INTFREF^LNPPC3(ln.intfre,ln.dist1nd,ln.pcmval,ln.dist1fre)
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER 
		}
	
	if ln.index'="" do { quit:ER 
		// Interest Index reqs value in Last Change Date
		if ln.ichld="" do Runtime.setErrXBAD("LN","INDEX11") quit:ER 

		// Interest Index reqs value in Next Change Date
		if ln.ichnd="" do Runtime.setErrXBAD("LN","INDEX12") quit:ER 

		// Interest Index reqs value in int change freq
		if ln.intfre="" do Runtime.setErrXBAD("LN","INDEX13") quit:ER 
		}
	
	if (ln.intfre.oldVal'=ln.intfre)!(ln.ichnd.oldVal'=ln.ichnd)!(ln.intoff.oldVal'=ln.intoff) do { quit:ER 
		new XJD
		if ln.intfre="" quit 
		if ln.ichnd="" do Runtime.setErrMSG("LN",7531,"LN.ICHND") quit 

		// Check date against master frequency
		do ICHNDF^LNPPC3(ln.ichnd,ln.dist1nd,ln.pcmval,ln.dist1fre,ln.intfre)
		if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER 
	
		// No offset processing - next date can be today or greater
		// NEXT INTEREST CHANGE Date in the Past
		  if ln.intoff="" do { quit
																								if ln.ichnd<%SystemDate do Runtime.setErrXBAD("LN",76,"ICHND",ln.ichnd) quit:ER
																								}
		
		  

		// Offset processing -- next date must be greater than today
		// NEXT INTEREST CHANGE Date in the Past
		if ln.ichnd'>%SystemDate do Runtime.setErrXBAD("LN",76,"ICHND",ln.ichnd) quit:ER 
	
		// Offset periods may overlap.  Verify all offset dates in process.
		set XJD=ln.ichnd
		for  quit:(XJD-ln.intoff'<%SystemDate)  do { quit:ER 
			new rate,XCID
			set XCID=ln.cid
			set rate=Db.getOneRow("RATE","LNVRCHG","XJD,XCID") quit:ER 
			if $G(rate)="" do Runtime.setErrXBAD("LN",91) quit:ER 
			set XJD=$$NJD^UFRE(XJD,ln.intfre) quit:ER
			}
		}
	
	// Updating Interest Matrix, Interest Spread, Interest Rounding Method
	
	if ((ln.intmat'="")!(ln.intspr'="")!(ln.rndmtd'=""))&(ln.index="") do Runtime.setErrMSG("LN",8745) quit:ER 
	
	if ln.intmat'="" do {
		set NAME=ln.intmat
		set ITEM=Db.getOneRow("ROW","UTBLMATATT","NAME")
		set DITEM=Db.getOneRow("LN","STBLMATATT","ITEM")

		// Matrix values invalid for this account
		if DITEM="" do Runtime.setErrMSG("LN",3228,RM) quit:ER 
		set ITEM1=Db.getOneRow("MATCOL","UTBLMATATT","NAME")
		if ITEM1'="" do {                   
			set DITEM1=Db.getOneRow("LN","STBLMATATT","ITEM1")

			// Matrix values invalid for this account
			if DITEM1="" do Runtime.setErrMSG("LN",3228,RM) quit:ER 
			}
		}

	// IRF - Rounding Method is required with Interest Rounding Flag
	if ln.irf'="",ln.rndmtd="" do Runtime.setErrMSG("LN",5099) quit:ER

	// IRN validation 

	// To prevent commitment with interest rate
	if ln.cpf=1,ln.irn>0 do Runtime.setErrXBAD("LN",3004) quit:ER  ;SIVCHUKA 07/19/00

	// Data required in data item ~p1
	if ln.irn="",ln.ircb>0 do Runtime.setErrMSG("LN",7531,"LN.IRN") quit:ER 

	// Must have a rate or index
	if ln.irn="",(ln.index="") do Runtime.setErrSTBLER("LN","LNRTRQ") quit:ER 

	// Rate ceiling/floor validation
	new rfloor,rceiling
	do RATEFC^LNFUNCS(ln.type,.rfloor,.rceiling)
	if rceiling="" set rceiling=99.99

	// INTEREST RATE Outside Valid Range
	if ln.irn>rceiling!(ln.irn<rfloor) do Runtime.setErrXBAD("LN",117) quit:ER 
	
	// MINRATE - Minimum Rate Differential - Validate Minimum Rate Differential
	if ln.minrate,(ln.irn<($$MINRATE^LNCDI(CID)+ln.minrate)) do Runtime.setErrXBAD("LN","MINR") quit:ER 
	
	// RNDMTD - Interest Rounding Flag is required with Rounding Method
	if ln.rndmtd'="",ln.irf="" do Runtime.setErrMSG("LN",5100) quit:ER

	// Validate IRN againt account Min and Max Rates - JP 7/9/99 33055
	
	// Too Low
	if ln.intmn'="",ln.irn<ln.intmn do Runtime.setErrXBAD("LN","INVINTRTL") quit:ER       
	// Too High
	if ln.intmx'="",ln.irn>ln.intmx do Runtime.setErrXBAD("LN","INVINTRTH") quit:ER        
	
	// Validate IRN for calculated rate
	do { quit:ER 
		new baseamt,date,RATE
		if ln.intmx!ln.intmnic!ln.intmxic!ln.intmxiy quit 
		if ln.intmn!ln.intmndc!ln.intmxdc!ln.intmxdy quit 
		if ln.index="" quit 
		if ln.intfre="" quit 
		set date=ln.ichld-ln.intoff
		if date<ln.dtnt set date=ln.dtnt

		// No Index Rate Entered for Date
		if 'date do Runtime.setErrXBAD("LN",114) quit:ER 
		if 'ln.cntdr set baseamt=ln.amtreq
		else  set baseamt=ln.balint
		set PAR("INDEX")=ln.index
		set PAR("SPREAD")=ln.intspr
		set PAR("ROUND")=ln.rndmtd
		set PAR("RNDFC")=1
		set PAR("MATRIX")=ln.intmat
		do CTL^UINDX(.ln,date,baseamt,.PAR) quit:ER

		// Interest Rate Inconsistent with Calculated Rate
		if +RATE'=+ln.irn do Runtime.setErrXBAD("LN",133,"IRN",ln.irn,RATE) quit:ER 
		}
	quit

vau42 // Trigger AU_INT_INFO2 - After update int amounts, IAM, IDP info

	type public RecordLN ln
	/*
								---------- Revision History ------------------------------------------

	12/12/01 - VERTLIBA - 48460
																			Modified previous fix to check dates only for loans
																			which have a maturity date.
	
	12/05/01 - GORDONT - 47316
	           Added Error Message check for LN.MDT not to be prior
		   to LN.ODD.

	11/28/01 - GORDONT - 47316
            	   Added code to verify that LN.MDT is greater than
																			LN.ODT else the error "Maturity date must be later than
																			opening date" is displayed.
	
	10/31/00 - LUS - 40355
		   Modified the code that validate the MAX/MIN loan payment
		   term.

	10/19/00 - LUS - 40355
		   Added XBAD Error message to verify whether Loan Payment Term
		   outside valid range. 
	
	09/19/00 - YENDAPALLIS - 39372
		   Changed table name from PRODDFTC to PRODCTL for INTYPRST.
	
	*/
	// abv - 48460 - check dates only for loans which have Maturity date
	// Maturity date must be after disbursement date - arq 47316
	if ln.mdt,ln.mdt'>ln.odd do Runtime.setErrMSG("LN",1680) quit:ER 
														 
	// abv - 48460 - check dates only for loans which have Maturity date
	// Maturity date must be later than opening date - arq 47316
	if ln.mdt,ln.mdt'>ln.odt do Runtime.setErrMSG("LN",1681) quit:ER

	// Add-On Loan has Interest Determined at Payment
	if (ln.iam.oldVal'=ln.iam)!(ln.idp.oldVal'=ln.idp) do { quit:ER 
		if ln.iam,ln.idp do Runtime.setErrXBAD("LN",155) quit:ER 
		}
	
	// Collected Interest Exceeds Original Uncollected
	if (ln.iam.oldVal'=ln.iam)!(ln.ipl.oldVal'=ln.ipl)!(ln.iun.oldVal'=ln.iun) do { quit:ER 
		if ln.iam,ln.ipl>ln.iun do Runtime.setErrXBAD("LN",32,"IPL",ln.ipl,ln.iun) quit:ER 
		}
	
	// FLAT,IAM -Flat Rate Interest Calculation and Interest Amortization Method
	if (ln.flat.oldVal'=ln.flat)!(ln.iam.oldVal'=ln.iam) do { quit:ER 
		if ln.flat=1,ln.iam'>0 do Runtime.setErrXBAD("LN",517) quit:ER 
		}
	
	// IAM,MDT- Interest Amortization Method and Maturity date
	if (ln.mdt.oldVal'=ln.mdt)!(ln.iam.oldVal'=ln.iam) do { quit:ER 
		if ln.mdt="",ln.iam>0 do Runtime.setErrXBAD("LN",518) quit:ER 
		}
	
	// IAM - Interest Amortization Method
	if (ln.iam.oldVal'=ln.iam)!(ln.mdt.oldVal'=ln.mdt)!(ln.trm.oldVal'=ln.trm) do { quit:ER 
		if ln.iam'>0 quit 
		if $$EXT^UMDT(ln.trm,ln.dtnt,0,ln.busopt,ln.nbdc)'=ln.mdt do Runtime.setErrXBAD("LN",519) quit:ER 
		set JD=$$NJD^UFRE(ln.mdt,"-"_ln.dist1fre) quit:ER
		if $$NJD^UFRE(JD,ln.dist1fre)'=ln.mdt do Runtime.setErrXBAD("LN",519) quit:ER 
		}
	
	if (ln.iam.oldVal'=ln.iam) do { quit:ER 
		if ln.iam>0,$$NJD^UFRE(ln.dtnt,ln.dist1fre)'=ln.dfp do Runtime.setErrXBAD("LN",519) quit:ER 
	
		}
	
	// MAX/MIN Loan Payterm Term Verification	
	if ln.minptrm'="" do { quit:ER
																new ODT,TRM
																set ODT=%SystemDate
																set TRM=ln.minptrm
																// Validate term format
																do ^UMDT
																if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
																}
	if ln.maxptrm'="" do { quit:ER
																new ODT,TRM
																set ODT=%SystemDate
																set TRM=ln.maxptrm
																// Validate term format
																do ^UMDT
																if ER do Runtime.setErrMSG("LN",3333,RM) quit:ER
																}
	//Loan Payment Term outside valid range  LUS
								set PCMVAL=$$PCMVAL^LNCDI(ln.pcm)
	if ln.minptrm'="",(ln.mdt<$$MDT^PROCLN(ln.dtnt,ln.odd,ln.minptrm,,ln.busopt,ln.nbdc,ln.amodt,PCMVAL,ln.dist1fre)) do Runtime.setErrXBAD("LN","LNPTRM") quit:ER
	if ln.maxptrm'="",(ln.mdt>$$MDT^PROCLN(ln.dtnt,ln.odd,ln.maxptrm,,ln.busopt,ln.nbdc,ln.amodt,PCMVAL,ln.dist1fre)) do Runtime.setErrXBAD("LN","LNPTRM") quit:ER

	/*
	Int Determ Point Invalid for Pmt Calc Method
	These types of loans should have their interest calculated at billing
	*/
	if (ln.idp.oldVal'=ln.idp) do { quit:ER 
		if ln.idp=1,($E(ln.pcmval,2)>0)!($E(ln.pcmval,3)>2) do Runtime.setErrXBAD("LN",127) quit:ER
		}
	
	// Interest balance option requires interest calc at billing
	if (ln.idp.oldVal'=ln.idp)!(ln.icpa.oldVal'=ln.icpa) do { quit:ER 
		if ln.idp'=1 quit 
		new prio,ICPA
		set ICPA=ln.icpa
		set prio=Db.getOneRow("PRIO","UTBLICPA","ICPA") quit:ER 
		if $E(prio,1)!$E(prio,2)!$E(prio,7)!$E(prio,8)!$E(prio,11) do Runtime.setErrXBAD("LN",521) quit:ER 
		}
	quit

vau43 // Trigger AU_IRCID - After Update Interest Reserve Acct Numbr

	type public RecordLN ln
								/*
								---- Revision History---------------------------------------------------
							 
								08/02/05 - KUMARB - CR16684
		Modified the table name LNLCOM to LN in Db.select
	
								05/15/00 - KELLYP - 35505
		Added code to remove interest reserve account to loan account
		reference in the RELIR global when ln.ircid and ln.iramto have
		been deleted from the loan account's record.
								*/


	/* 
		Interest Reserve Account Number and Interest Reserve Original Amount must 
		both be defined
	*/

	if (ln.ircid=""),(ln.iramto'="") do Runtime.setErrMSG("LN","4289") quit:ER
	if (ln.ircid'=""),(ln.iramto="") do Runtime.setErrMSG("LN","4289") quit:ER

	if (ln.ircid=""),(ln.iramto="") do { quit
	// 35505 - Remove RELIR reference
	new IRCID,LNCID
	set IRCID=ln.ircid.oldVal,LNCID=ln.cid
	if 'Db.isDefined("RELIR","IRCID,LNCID") quit
	do Db.delete("RELIR","IRCID=:IRCID AND LNCID=:LNCID")
	}

	if (ln.ccl'=""),(ln.ircid'="") do { quit:ER

	/* 
 	 This section ensures that the account's linked commitment does not 
	 also have an interest reserve account number defined.  Also performed
	 for sub-commitments tied to a commitment.
 	*/

	new IRCID,XCCL

	set XCCL=ln.ccl
	set IRCID=Db.getOneRow("IRCID","LN","XCCL")   // Commitment's I.R. Acct Number

	/* 
	 Cannot define Interest Reserve Account on both commitment and linked 
	 loans
 	*/

	if IRCID'="" do Runtime.setErrMSG("LN","4290") quit:ER
	
	if 1	// Preserves $T
	}

	else  if (ln.cpf),(ln.ircid'="") do { quit:ER
	
	/*
	 This section ensures that a commitment's linked loans do not have an 
	 interest reserve account number defined if one is defined on the 
	 commitment.
	*/

	new CID,rs

	set CID=ln.cid
	type ResultSet rs=Db.select("CID","LN","CCL=:CID")
	if rs.isEmpty() quit

	while rs.next() do { quit:ER
		new XCID,IRCID
		set XCID=rs.getCol(1)
		if 'Db.isDefined("LN","XCID") quit
		set IRCID=Db.getOneRow("IRCID","LN","XCID")	
		
		/* 
		 Cannot define Interest Reserve Account on both commitment 
		 and linked loans
		*/

		if IRCID'="" do Runtime.setErrMSG("LN","4290") quit:ER
		} 
	}

 if (ln.ircid'="") do { quit:ER		 

	/*
	 This section updates the Interest Reserve to Loan Commitment cross-
	 reference table with the new interest reserve account and loan account
	 numbers as well as the interest reserve original amount.
	*/

	new IRCID,IRAMTO,LNCID

	set IRCID=ln.ircid,LNCID=ln.cid,IRAMTO=ln.iramto

	// Interest Reserve Account is not a valid PROFILE account
	if 'Db.isDefined("DEP","IRCID") do Runtime.setErrMSG("LN","4318") quit:ER

	if Db.isDefined("RELIR","IRCID,LNCID") quit

	type RecordRELIR relir=Class.new("RecordRELIR")
	
	/* 
	 relir.iramtr will be updated by the deposit posting programs when 
	 funds are actually transferred to the account.
	*/

	set relir.ircid=IRCID,relir.lncid=LNCID,relir.iramtr="0"
	do relir.save()  
	}
	quit

vau44 // Trigger AU_LATECHG_INFO - After update late charge information

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	
	02/01/99 - HAYMANP - 28976
		   Added condition LCHGNOTO'=1 to check on LCAD.
	
	*/

	
	if (ln.lcad.oldVal'=ln.lcad) do { quit:ER 
		// Data required in Data Item ~p1
		if ln.dlcaf,ln.lcad="" do Runtime.setErrMSG("LN",7531,"ln.lcad") quit:ER 
	
		// Maintain DAYEND file
		new LCAD,X,XCID,XLCEFD
		set XCID=ln.cid
		set XLCEFD=ln.lcefd
		set XLCAD=ln.lcad
		set XTJD=ln.lcad.oldVal
		if ln.lcad="",ln.lcad.oldVal>%SystemDate  do Db.delete("DAYENDLCHG","TJD=:XTJD and CID=:XCID")
		if ln.lcad'="" do {
			if ln.lcad.oldVal'=""  do Db.delete("DAYENDLCHG","TJD=:XTJD AND CID=:XCID")
			do Db.insert("DAYENDLCHG","TJD,CID,LCEFD",":XLCAD,:XCID,:XLCEFD")
			}
		}
	
	if ln.popt'="",ln.dist1fre'="",ln.lchgnoto'=1 do { quit:ER 
		new i,lcad,lcefd,pmtgrc,XBLDT,XCID
		set XCID=ln.cid 
		set XBLDT=ln.bldt
	
		new rs 
		type ResultSet rs=Db.select("CDPD","LNBIL1","CID=:XCID AND CBCD=:XBLDT","SCHSEQ DESC") 
		//type ResultSet rs=Db.select("CDPD","LNBIL1","CID=:XCID AND CBCD=:XBLDT")
		if rs.isEmpty() quit
		set lcefd=rs.next(),lcefd=rs.getCol(1)
		if $G(lcefd)="" quit 
		set pmtgrc=ln.pmtgrc
		set lcad=lcefd+pmtgrc
		if pmtgrc["P" set lcad=lcefd do { quit:ER 
			for i=1:1:$E(pmtgrc) set lcad=$$NJD^UFRE(lcad,ln.dist1fre) quit:ER 
			set lcad=lcad-$P(pmtgrc,"-",2)
			}
	
		if ln.lcbo="N" for lcad=lcad:1 quit:$$BD^UNBD(lcad) 
		if 'ln.bseq!(ln.bldt+1=ln.odd) quit 
		// Late Charge Action Date Invalid
		if lcad'=ln.lcad do Runtime.setErrXBAD("LN",124,"LCAD",ln.lcad,lcad) quit:ER 
		if lcefd'=ln.lcefd do Runtime.setErrXBAD("LN",129,"LCEFD",ln.lcefd,lcefd) quit:ER 
		}
	quit

vau45 // Trigger AU_MAXAGGR - After Update Maximum Aggregate Draw Amt

	type public RecordLN ln
	/*
	---- Revision History--------------------------------------------------

	01/17/06 - KELLYP - CR 19080
		   Modified the check on ln.maxaggr to check for (ln.maxaggr)
		   instead of ('ln.maxaggr.isNull()).  This prevents a problem
		   from occurring where the system defaults in a zero for this
		   column (because DBTBL1D.NULLIND is enabled) and the check
		   then determines that 0 is not null and 0 is less than the
		   credit limit, and returns error message # 4279 incorrectly.

	03/30/05 - KinI - 14385
	           Cleaned up to comply with DBI standards. 

	*/
	
	type public Boolean ER

	// Maximum Aggregate Draw Amount may not be less than the loan amount
	if (ln.maxaggr),(ln.maxaggr<ln.crlmt) do Runtime.setErrMSG("LN","4279") quit:ER

	quit

vau46 // Trigger AU_MAXO - Late Charge Method Maximum Override

	type public RecordLN ln
	/*---- Revision History--------------------------------------------------------
	
	11/16/00 - MAGERAM - 42816	
		   Modified code for XBAD Message "MAXGTMIN" to check if
		   LN.MAXO has a value.            
	
	10/17/00 - MAGERAM - 40354
		   Created AU_MAXO to verify that LN.MAXO is greater than 
		   LN.MINO else the error "Late Chrg Max Ovr must be greater 
		   than Late Chrg Min Ovr" is displayed.
		
	----------------------------------------------------------------------
	*/
	
	// Late Chrg Max Ovr must be greater than Late Chrg Min Ovr
	if ln.maxo,(ln.maxo<ln.mino) do Runtime.setErrXBAD("LN","MAXGTMIN") quit:ER 
	quit

vau47 // Trigger AU_MT900THR - After Update MT900 Debit Threshold Trgr

	type public RecordLN ln
	// Check to ensure that MT900 Debit Threshold is present if Generate MT900="Y"
	
	if ln.mt900=1 do {
 	if ln.mt900thr="" do {
		new cif900thr,XACN
		set XACN=ln.acn
		set cif900thr=Db.getOneRow("MT900THR","CIF","XACN")
		if cif900thr="" do Runtime.setErrMSG("LN","4077") quit:ER
	}
	}
	quit

vau48 // Trigger AU_MT910THR - After Update MT910 Credit Threshold Trgr

	type public RecordLN ln
	// Check to ensure that MT910 Credit Threshold is defined if Generate MT910='Y'

	if ln.mt910=1 do {
	if ln.mt910thr="" do {
		new cif910thr,XACN
		set XACN=ln.acn
		set cif910thr=Db.getOneRow("MT910THR","CIF","XACN")
		if cif910thr="" do Runtime.setErrMSG("LN",4078) quit:ER
	}
	}
	quit

vau49 // Trigger AU_NAI - After update of Non accrual indicator.

	type public RecordLN ln
	/*---- Revision History ------------------------------------------------

			02/22/00 - HALPINJ - 43896
	      Added code to check if dayend global exists then quit.
	      If trigger is called during dayend processing a SAVEFAIL
	      error would be received.

			08/24/00 - HALPINJ - 41326
	      Create trigger so user cannot modify LN.NAI without
	      changing the G/L set code.
	
			----------------------------------------------------------------------
	*/
	
	new GLSC,LTYPE,NAGL,values
	// If called by dayend process quit.
 if Db.isDefined("DAYENDLNNAO","TJD,CID") quit		// JMH - 02/22/01
	// Non-accrual G/L link not changed.
	if '(ln.glsc.oldVal'=ln.glsc) do Runtime.setErrSTBLER("LN","LNNA3") quit:ER
	set LTYPE=ln.type
	set GLSC=Db.getOneRow("GLSC","PRODDFTL","LTYPE")
	set NAGL=Db.getOneRow("NAGL","PRODCTL","LTYPE")
	if ln.nai=1 do {
	// Non-accral G/L link differs from product type value.
	if ln.glsc'=NAGL do Runtime.setErrSTBLER("LN","LNNA1") quit:ER
	do Db.insert("DAYENDLNNAO","EJD,CID,MAN,UID",":TJD,:CID,1,:%UID") quit:ER
	}
	else  do {
	// G/L link differs from product type value.
	if ln.glsc'=GLSC do Runtime.setErrSTBLER("LN","LNNA2") quit:ER
	do Db.insert("DAYENDLNNAO","EJD,CID,DEL,UID",":TJD,:CID,1,:%UID") quit:ER
	}
	Q
	quit

vau50 // Trigger AU_NBTR - After Neg. Bal. Transfer update

	type public RecordLN ln
	/*
	---- Revision History--------------------------------------------------------
	09/15/99 - KELLYP 34662
		   Added NTROPT column to "Columns Associated" area of trigger
		   definition.  Previously, trigger was not forcing the entry
		   of the NTROPT column when NBTR was present because NTROPT
		   was not associated with the trigger.
	
	03/11/99 - MALTEPESA 31430
		   Added a check to return an XBAD msg if Negative Balance Transfer
		   has value but Negative Transfer option does not.
	*/

	if ln.nbtr="" quit
	if (ln.nbtr),(ln.ntropt="") do Runtime.setErrXBAD("LN",529) quit:ER 
	quit
	

vau51 // Trigger AU_NUMDTP - After Update trigger for column NUMDTP

	type public RecordLN ln
	/*
	---------- Revision History -------------------------------------------

	   03/30/05 - KinI - 14385
		      Added error message text comment.
	
											11/07/00 - VETSENM - 40359
          	      Set XBAD error message for LN.NUNDTP if LN.GENPRJREP=1       
	*/
	
	type public Boolean ER

	// Ln activity proj requires nbr of days to project or mat
								if (ln.genprjrep=1) , (ln.numdtp="") do Runtime.setErrXBAD("LN",238) quit:ER

	quit

vau52 // Trigger AU_ODD_DTNT_ODT - After update of initial dates

	type public RecordLN ln
	/*
	  ------------------------------- Revision History -------------------
	
	02/27/06 - ratht - CR19435
	 	   Added a new line to check the conditon for the column ODD.
	 	   
	12/12/01 - VERTLIBA - 48460
		   Modified previous fix to check dates only for loans
		   which have a maturity date.
	
 	04/06/01 - Terrie Dougherty - 36921
		   Modified to return an error if the opening date is modified 
		   to a date later than the maturity date.
	
	05/24/00 - MOTENJ - 40196
		   Changed the condition checking syntax of %ProcessMode to the
		   correct form(if %ProcessMode'=).

	*/

	// DTNT - Date of Note
	if ln.dtnt="" set ln.dtnt=ln.odd
	else  if ln.mdt,ln.odt>ln.mdt do Runtime.setErrMSG("LN",1681) quit:ER	
	// abv - 48460 - check dates only for loans which have Maturity date
 	
	// DTNT - Date of Note
	if %ProcessMode'=2,ln.dtnt>ln.odd do {
		new odd,dtnt
		set odd=ln.odd 
		set dtnt=ln.dtnt
		if odd set odd=$$DAT^%ZM(odd)
		if dtnt set dtnt=$$DAT^%ZM(dtnt)
		// Disbursement date p1 precedes note date p2.  Change one or both values.
		do Runtime.setErrMSG("LN",1599,"odd~dtnt") quit:ER 
		}

	//ODD - Original Disbursement Date
	
	// "Billing precedes disbursement date" 
	if ln.odd>ln.dist1nd do Runtime.setErrMSG("LN",354) quit:ER 

	quit

vau53 // Trigger AU_PAYOFFLKO - After update- payoff lockout parameters

	type public RecordLN ln

 	/*
 	NOTE: This logic was formerly in LNPO1.m. This trigger maintains the 
 	      Payoff Lockout Dayend exception file LNPOLOE ("POLOE" DAYEND) 
 	      table. The PAYLKTO index on LN will in turn maintain "POLO" 
 	      DAYEND enries.
 	
 	Revision History
 	
 	05/12/06 - SANTHUMS - CR 21227
 		   Modified to check NOT NULL conditions for the columns
 		   prodctl.plmdr,prodctl.plmpr.
 		   
 	03/16/06 - Mugilvannan - CR 20019
 		   . Modified Percentage difference by multipying with 100 to
 		     get the correct percentage.
 		     
 	02/27/06 - SmithCD / Mugil - CR 19740
 		   . Modified to only maintain LNPOLOE records using 
 		     %SystemDate (as original code did in LNPO1.m) to prevent 
 		     "Insufficient Values" error when lnpoloe.paylkto was null
 		   . Added PAYLKFRM and PAYLKTO to the list of column names 
 		     associated with the UPDATE action on the control page
 		   . Used POAM variable instead of referencing ln.poamt 
 		     multiple times for efficiency (ln.poamt is a computed 
 		     column)
 		   . Corrected other logic errors, and simplified code
							 
								06/06/05 - Carol Scott - CR 15816
        	   Modify Db.delete statement.
        	
	05/10/05 - Carol Scott - CR 15816
		   Added trigger.
	
	*/
							 
								type public Cache %CACHE()

	type Number DIFFD, DIFFP, POAM
	type Boolean OVER = 0

	set POAM = ln.poam

	// Difference between Calculated and Entered (absolute value)
	set DIFFD = POAM - ln.paylkamt
	if DIFFD < 0 set DIFFD = -DIFFD

	// Percentage difference 
	if POAM set DIFFP = (DIFFD / POAM)*100
	else  set DIFFP = 0

								//Check limits in product file
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:ln.type")

	// Flag overages if no limits
  	if prodctl.plmdr.isNull(), prodctl.plmpr.isNull() set OVER = (DIFFD '= 0)
  	
	// Payoff Lockout - Min $ Diff To Report
	else  if 'prodctl.plmdr.isNull() set OVER = (DIFFD '< prodctl.plmdr)
	// Payoff Lockout - Min % Diff To Report
	else  if 'prodctl.plmpr.isNull() set OVER = (DIFFP '< prodctl.plmpr)

	// No overage - delete exception file that may exist for current date, 
	// user ID, and account number
	if 'OVER do Db.delete("LNPOLOE", "EFD=:%SystemDate AND CID=:ln.cid") quit

	// There is an overage - add / overwrite exception file for current 
	// date, user ID, account number
	type RecordLNPOLOE lnpoloe = Db.getRecord("LNPOLOE", "EFD=:%SystemDate,%UID=:%UserID,CID=:ln.cid", 1)

	set lnpoloe.polo = ln.paylkamt
	set lnpoloe.posc = POAM
	set lnpoloe.paylkfrm = ln.paylkfrm
	set lnpoloe.paylkto = ln.paylkto

	do lnpoloe.bypassSave()
	
	quit			

vau54 // Trigger AU_PCHM - After Update - Payment Change Method

	type public RecordLN ln
	/* ---- Revision History -------------------------------------------------
	
								11/19/02 - APPLEYARDM - CR 1729/ARQ 50943
																Created trigger to ensure that payment change method
																cannot be updated unless all required data items are
																defined.
	*/
	
	if ln.pchm=2!(ln.pchm=3) do { quit:ER
	
								// Error message "Required if payment change method equals 2 or 3"
								if ln.ppinc="" do Runtime.setErrSTBLER("PRODDFTL","LNGPMREQ") quit:ER
								if ln.numch="" do Runtime.setErrSTBLER("PRODDFTL","LNGPMREQ") quit:ER
								if ln.caf="" do Runtime.setErrSTBLER("PRODDFTL","LNGPMREQ") quit:ER
								}
	
	
	quit

vau55 // Trigger AU_PCM_INFO - AU AMBAS, ONP, PCM, and RPP

	type public RecordLN ln
 	/*
								---------- Revision History ------------------------------------------
	05/10/05 - Carol Scott - CR 15816
		   Remove the crcd parameter from the call to LNFUNCS.
		   It only requires the type parameter.
	
	01/29/04 - CARROLLJ - CR7997
		   Removed dead code.

	09/19/00 - YENDAPALLIS - 39372
		   Added an integrity check for invalid combinations of
		   interest determination point (IDP) and Payment calculation
		   method (PCM). 

	10/13/00 - LEVINTOLR - 40358
																			Added XBAD Error Message checks on the LN.PIIND and LN.PMRO

	*/
	
	
	if (ln.onp.oldVal'=ln.onp)!(ln.ambas.oldVal'=ln.ambas) do { quit:ER 
		new cnt
		// Commitment
		if ln.cpf quit

		// Non-amortizing
		if '$E(ln.pcmval)
		if 'ln.mdt!'ln.trm quit 

		// Original # Pmts Inconsistent with Term of Loan
		if 'ln.onp do Runtime.setErrXBAD("LN",136,"ONP",0) quit 
		if ln.dist1fre="" quit 

		// Only matters for variable pmts
		if ln.pcfre=""!'ln.pcoff quit
		if ln.dist1fre="*" set cnt=$$DATECNT^LNFUNCS(ln.cid)
		else  do { quit:ER 
			new af,njd
			set njd=$$NJD^UFRE(ln.dfp,"-"_ln.dist1fre,.af) quit:ER
			set cnt=$J(((ln.mdt-njd)/365)*af,0,0)
			}
		// Original # Pmts Inconsistent with Term of Loan
		if ln.onp'=cnt do Runtime.setErrXBAD("LN",136,"ONP",cnt) quit:ER 

		// Origin. # PMTS inconsistent with Amort Base # PMT
		if ln.onp>ln.ambas do Runtime.setErrXBAD("LN",168,"ONP",ln.onp,ln.ambas) quit:ER 
		}
	
	if (ln.pcm.oldVal'=ln.pcm)!(ln.rpp.oldVal'=ln.rpp) do { quit:ER 
		// PAYMENT CALC METHOD Requires Missing Payment Plan
		if ln.rpp="",$E(ln.pcmval,3)=4!($E(ln.pcmval,3)=5) do Runtime.setErrXBAD("LN",52) quit:ER 
		}
	
	if $E(ln.pcmval),'ln.onp!'ln.ambas do { quit:ER 
		if $$FBP^LNFUNCS(ln.type)=2,ln.dfp>%SystemDate quit 

		// Payment Meth Requires "Number of Payments" Fields
		do Runtime.setErrXBAD("LN",9) quit:ER 
		}
	
	/*
	Int Determ Point Invalid for Pmt Calc Method
	These types of loans should have their interest calculated at billing
	*/
	if ln.idp=1,($E(ln.pcmval,2)>0)!($E(ln.pcmval,3)>2) do Runtime.setErrXBAD("LN",127) quit:ER

	// Pmt/Mat Recalculation Opt can only be used with P&I loans
								// Only for a P&I loans
								if 'ln.piind,ln.pmro>0 do Runtime.setErrXBAD("LN",236) quit:ER
	quit

vau56 // Trigger AU_PMRO - After Update Pmt/Mat Recalculation Opt

	type public RecordLN ln
	/*
								---------- Revision History ------------------------------------------
	
	01/28/04 - CARROLLJ - CR7997
		   Removed dead code.

															10/13/00 - LEVINTOLR - 40358
																			Added XBAD Error Message checks on the LN.PIIND and LN.PMRO
	
								*/



  	 // Pmt/Mat Recalculation Opt can only be used with P&I loans
 	 // Only for a P&I loans
  	 if 'ln.piind,ln.pmro>0 do Runtime.setErrXBAD("LN",236) quit:ER
	 
	 quit

vau57 // Trigger AU_PMT - After Update PMT

	type public RecordLN ln
		/*
								---- Revision History---------------------------------------------------
	
								04/19/02 - JERUCHIMC - 49370
               	   Created this trigger to update the coupon book if the
		   current payment LN.PMT is changing for today.  This
		   happens, for example, if a cycled item is addded to the
		   loan. In this case, the payment change requires updating
	           the coupon book.  For this change, we are only concerned
		   about updating the coupon book for today, for a new account
																			coupon book method.

								*/
	
	new XPMT,XTJD
	set XTJD=%SystemDate,XPMT=ln.pmt
 	if Db.isDefined("LNCPN","XTJD,3,CID"),ln.cbmet do Db.update("LNCPN","TPT=:XPMT","PND=:XTJD AND PMET=3 AND CID=:CID") 
	quit

vau58 // Trigger AU_PMTCHG_INFO - After Update Payment Change Info

	type public RecordLN ln
	if (ln.pcfre.oldVal'=ln.pcfre),ln.pcfre'="" do { quit:ER 

		// Only P&I loans may use payment change frequencies
		if ln.piind=0 do Runtime.setErrSTBLER("LN","NPINAPF") quit:ER 

		// Pmt Calc Meth Indicates No Pmt Change Freq
		if $E(ln.pcmval,3)=2 do Runtime.setErrXBAD("LN",126) quit:ER 

		// Interest Offset required when payment change frequency contains data
		if ln.intoff="" do Runtime.setErrXBAD("LN","PCFRE") quit:ER 
	
		// Check against master frequency
		// D PCFREF^LNPPC3(LN.INTFRE,LN.DIST1ND,LN.DIST1FRE,LN.PCHM,LN.INTFRE,LN.ICHND)
		do PCFREF^LNPPC3(ln.pcfre,ln.dist1nd,ln.dist1fre,ln.pchm,ln.intfre,ln.ichnd)
		if $G(ER) do Runtime.setErrSTBLER("LN",ET) quit:ER 
		}
	
	if (ln.pchnd.oldVal'=ln.pchnd),ln.pchnd do { quit:ER 

		// Only P&I loans may have payment change next dates
		if ln.piind=0 do Runtime.setErrSTBLER("LN","NPINAPD") quit:ER 

		// NEXT PAYMENT CHANGE DATE in the Past
		if ln.pchnd'>%SystemDate do Runtime.setErrXBAD("LN",79) quit:ER 
	
		// Check against master frequency
		do PCHNDF^LNPPC3(ln.pchnd,ln.dist1nd,ln.intfre,ln.pcfre,ln.ichnd,ln.dist1fre,ln.pchm)
		if $G(ER) do Runtime.setErrSTBLER("LN","NPINAPD") quit:ER 
		}
	
	// NEXT PAYMENT CHANGE DATE in the Past
	if ln.pchnd'>%SystemDate do Runtime.setErrXBAD("LN",79) quit:ER 
	
	// Check that LNPTCHG is set up for correct dates
	set jd=ln.pchnd
	if jd'="" for  quit:jd-ln.pcoff>%SystemDate  do { quit:ER 
		// P&I Change Offset in Past, No New P&I Calculated
		if 'Db.isDefined("LNPTCHG","jd,ln.cid") do Runtime.setErrXBAD("LN",63) quit:ER 
		set jd=$$NJD^UFRE(jd,ln.pcfre) quit:ER
		}
	quit

vau59 // Trigger AU_PMTDIST - After update payment distribution

	type public RecordLN ln
	/*
	If PMTDIST changes, in order or elements, must change bill files,
	LNBIL0 and LNBIL1 to reflect the change.  Note that dropping elements
	is an error
	
	NOTE:  The code in PMTDIST^LNFUNCS should eventually be embedded here
		using SQL.
	*/

	do PMTDIST^LNFUNCS(ln.cid,ln.pmtdist,ln.pmtdistf)
	quit

vau60 // Trigger AU_PMTMIN - After update minimum payment amount

	type public RecordLN ln
	// Minimum payment amount requires principal in string
	if ln.pmtmin,"-"_ln.pmtdist_"-"'["-P-" do Runtime.setErrSTBLER("LN","PMTMIN") quit:ER 
	quit
	

vau61 // Trigger AU_PPDCAT - After update payment due categories

	type public RecordLN ln
	/*
	PPDCAT1-PPDCAT10 - Payment Due Categories
	If any category changes, check them all.  See same code in AFTER_INSERT
	Note:  PPDCAT may look like I-v-ESC3-v-P-v
		Bill file payment element order would be -
		|I...|ESC1...|ESC2...|ESC3...|P...
	First get payment elements from bill file (LNBIL0) in order
	*/


	new element,i,j,k,num,pe,pmtelem,ppdcat
	// Get payment elements
	do PMTELEM^LNFUNCS(ln.cid,.pmtelem) 
	
	// Get valid payment due categories
	set ppdcat(1)=ln.ppdcat1 
	set ppdcat(2)=ln.ppdcat2 
	set ppdcat(3)=ln.ppdcat3
	set ppdcat(4)=ln.ppdcat4 
	set ppdcat(5)=ln.ppdcat5 
	set ppdcat(6)=ln.ppdcat6
	set ppdcat(7)=ln.ppdcat7 
	set ppdcat(8)=ln.ppdcat8 
	set ppdcat(9)=ln.ppdcat9
	set ppdcat(10)=ln.ppdcat10
	
	// Check validity against payment element order
	for i=1:1:ln.npc do { quit:ER 
		set ppdcat="-"_ppdcat(i)_"-"
		// Payment element sequence
		set pe=0                   
		for j=2:2 set element=$P(ppdcat,"-",j) quit:element=""  do { quit:ER 
			set num=0
			// If escrow, get number
			if $$FEEPLN^LNU(element)="" do { 
				for k=$L(element):-1:1 quit:$E(element,k)'?1N 
				set num=+$E(element,k+1,99)
				}
			if '$G(num) set num=1
			set pe=pe+num

			// Account payment string inconsistent with bills
			if $P(pmtelem(pe),"#",1)'=element do Runtime.setErrXBAD("LN",37) quit:ER 
			}
		}
	quit:ER 
	quit

vau62 // Trigger AU_PRAMTCID - After Update Principal Amt Target Acct

	type public RecordLN ln
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
	      Cleaned up to comply with DBI standards. 
	*/ 

	type public Boolean ER

	// Principal Amt Target Acct & Principal Amount at Payoff must both be defined
	if (ln.pramt="") , (ln.pramtcid'="") do Runtime.setErrMSG("LN","4291") quit:ER
	if (ln.pramt'="") , (ln.pramtcid="") do Runtime.setErrMSG("LN","4291") quit:ER
	
	quit

vau63 // Trigger AU_PRCNTCID - After Update Percent at Payoff Trgt Acct

	type public RecordLN ln
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
	      Cleaned up to comply with DBI standards. 
	*/

	type public Boolean ER

	// Percent at Payoff Target Account and Percent at Payoff must both be defined
	if (ln.prcntap="") , (ln.prcntcid'="") do Runtime.setErrMSG("LN","4292") quit:ER
	if (ln.prcntap'="") , (ln.prcntcid="") do Runtime.setErrMSG("LN","4292") quit:ER

	quit

vau64 // Trigger AU_PTSP - After update capitalized points flag

	type public RecordLN ln
	// Net deferred fee data does not exist
	if ln.ptsp,'Db.isDefined("LNCYCPTS","ln.cid,'PTS'") do Runtime.setErrXBAD("LN",36) quit:ER 
	if 'ln.ptsp,Db.isDefined("LNCYCPTS","ln.cid,'PTS'") do Runtime.setErrXBAD("LN",36) quit:ER 
	quit
	

vau65 // Trigger AU_RAFRE - After update re-amoritzation frequency

	type public RecordLN ln
	if ln.rafre'="" do { quit:ER 
		// Only P&I loans may use reamortization frequencies
		if ln.piind=0 do Runtime.setErrSTBLER("LN","NPINARF") quit:ER 
	
		// Check against master frequency
		do RAFREF^LNPPC3(ln.rafre,ln.dist1nd,ln.dist1fre,ln.pcfre,ln.pchnd) quit:ER 
		}
	quit

vau66 // Trigger AU_RAND - After update re-amortization next date

	type public RecordLN ln
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
	        Cleaned up to comply with DBI standards. 

	01/21/04 spier 7985
		correct oldVal reference which did not compile
		when on the OLDRAND instantion line
			
	12/22/03 Spier 7501
		Added code to create a new DAYENDRAND record as well as delete
		the old one when it exists. This is similar to a index except 
		that some processing requires that two entries exist.
	*/

	type public Boolean ER

	if ln.rand do { quit:ER 

		// Only P&I loans may have reamortization next dates
		if ln.piind=0 do Runtime.setErrSTBLER("LN","NPINARD") quit:ER 
	
		// NEXT RE-AMORTIZATION DATE in the Past
		if ln.rand<%SystemDate do Runtime.setErrXBAD("LN",78) quit:ER 
	
		// Check against master frequency
		do PCFREF^LNPPC3(ln.rand,ln.dist1nd,ln.intfre,ln.rafre,ln.ichnd,ln.dist1fre,ln.pchm) quit:ER 
		
		type RecordDAYENDRAND rand=Class.new("RecordDAYENDRAND","RAND=:ln.rand,CID=:ln.cid")
		do rand.bypassSave()
		}

	type Date OLDRAND=ln.rand.oldVal
	type Number CID=ln.cid

	if OLDRAND do Db.delete("DAYENDRAND","RAND=:OLDRAND AND CID=:CID")
	
	quit

vau67 // Trigger AU_RDT - After Update Return Date

	type public RecordLN ln
	new CAL,RD
	set RD=ln.rdt
	if RD="" quit
	set CAL=ln.nbdc
	if CAL="" set CAL="IBS"
	if '$$BD^UNBD(RD,CAL) do Runtime.setErrXBAD("LN","RDTBUS") quit 
	if RD'>%SystemDate do Runtime.setErrXBAD("LN","RDTASD") quit 
	if ln.rnoff="" do Runtime.setErrXBAD("LN","RDROFF") quit 
	quit

vau68 // Trigger AU_RENCD_TRACN - AU Maturity Renewal Code & Transfer Acct

	type public RecordLN ln

	/*
	-----Revision History---------------------------------------------------
	03/28/05 - ALAGARSS - CR 20329
		   Modified the condition prodctl.fbp=2 from prodctl.fbp'=2.
		   
	05/20/05 - MBUIM - CR15982
		   Modified to remove deprecated feature Db.getOneRow and clean
		   up some PSL code.
	*/
	
	type Number TYPE

	set TYPE=ln.type
	
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
	
	if ln.tracn'="" do { quit:ER 
		// Transfer account not allowed for this maturity option.
		if ln.rencd=0!(ln.rencd=4) do Runtime.setErrXBAD("LN","MATOPT") quit 
		
		// For maturity option #1C,#2C,#3C Transfer account must be a loan account
		
		type Number YTRACN
		
		set YTRACN=ln.tracn
		
		type RecordACN acn=Db.getRecord("ACN","CID=:YTRACN")
		
		// Transfer account must be a loan account
		if ((ln.rencd="1C")!(ln.rencd="2C")!(ln.rencd="3C")),(acn.cls'="L") do Runtime.setErrSTBLER("LN","TRACN2") quit:ER
		}
	if ln.tracn="" do { quit:ER 
		// Maturity Option Requires Transfer Account
		if ln.rencd=1!(ln.rencd=2)!(ln.rencd=3) do Runtime.setErrXBAD("LN",110) quit 

		// Fixed Bullet Product Option Requires Transfer Acct
		if prodctl.fbp=2 do Runtime.setErrXBAD("LN",154) quit:ER
		}
	else  if prodctl.fbp=2 do { quit:ER 
	
		type Number XTRACN

		// Maturity Option Requires Transfer Account
		if 'ln.ccl do Runtime.setErrXBAD("LN",110) quit 
		
		set XTRACN=ln.tracn
		
		type RecordLN ln2=Db.getRecord("LN","CID=:XTRACN")
		
		// Transfer Account Requires Same Payment Frequency
		if ln.dist1fre'=ln2.dist1fre do Runtime.setErrXBAD("LN",33) quit:ER 

		// Transfer Account Requires Same Pmt Calc Method
		if ln.pcm'=ln2.pcm do Runtime.setErrXBAD("LN",34) quit:ER 

		// Pmt dates must start on or after variable loan pmts
		if ln.dfp<ln2.dfp do Runtime.setErrXBAD("LN",514) quit:ER 
		}
	quit

vau69 // Trigger AU_RND_ROPT - AU Escrow Elem to Round and Rounding Opt

	type public RecordLN ln
								/*
								---- Revision History---------------------------------------------------
							 
								02/18/00 - SIVCHUKA - 35604
																			Modify Loan Rounding Option. If Escrow Element to Round
																			([LN]RND) present,  Payment Rounding Option ([LN]ROPT)
																			must be=1. And if it's not=1-We sendin ErrMsg.
																			if ln.rnd'="",ln.ropt'=1 do Runtime.setErrXBAD("LN",533).  


								*/

	if ln.rnd'="",ln.ropt'=1 do Runtime.setErrXBAD("LN",533) quit //Sivchuka
	if ln.ropt'>1 do { quit:ER 
		new data,pe,pmtelem,rndesc,x,XESCCID

		do PMTELEM^LNFUNCS(ln.cid,.pmtelem)
		set pe=""
		for  set pe=$O(pmtelem(pe)) quit:pe=""  do {
			set x=pmtelem(pe)
			if ln.rnd=$P(x,"#",1) do {
				// Element to round
				set rndesc=$P(x,"#",1)   
				// Escrow account number
				set XESCCID=$P(x,"#",2)  
				}
			}
		// No escrow account
		if $G(XESCCID)="" quit

		// Loan Rounding Option Set, Escrow Unspecified
		if ln.rnd="" do Runtime.setErrXBAD("LN",112) quit 

		// "Escrow to Round" Account Invalid
		if $G(rndesc)="" do Runtime.setErrXBAD("LN",113) quit 
	
		// Acct does not exist
		if 'Db.isDefined("DEP","XESCCID") do Runtime.setErrXBAD("LN",113) quit

		set data=Db.getOneRow("STAT,ESPF","DEP","XESCCID")

		// Acct closed
		if $P(data,$C(9),1)=4 do Runtime.setErrXBAD("LN",113) quit

		// Acct is self pay
		if $P(data,$C(9),2)=1 do Runtime.setErrXBAD("LN",113) quit
		}
	quit

vau70 // Trigger AU_RSINTSPR_RSRNDMTD - After Update RSINTSPR or RSRNDMTD.

	type public RecordLN ln
	/*---------Revision History---------------------------------------------------
	08/29/00 - LUS - ARQ41547 
	Retrofitted change below:
								ORIG:LUS - ARQ38013 08/15/00
									Rate Schedule Interest Spread and Rounding Method Verification
	*/
	
	if ln.sch'="" do { quit:ER
								new X
								// INDEX2 - Invalid  offset syntax
								set X=ln.rsintspr
								do SPRPP^UINDX if ER do Runtime.setErrSTBLER("LN",ET) quit:ER
								// INDEX3 - Invalid rounding instruction
								set X=ln.rsrndmtd
								do RNDPP^UINDX if ER do Runtime.setErrSTBLER("LN",ET) quit:ER
								}
	quit

vau71 // Trigger AU_RSK_OPT - After Update Risk Analysis Option

	type public RecordLN ln
	/*
	   Revision History
	
	   11/22/05 - NATRAJAH - 13734
		      General DBI3 cleanup.
	*/
	
	// RSKOPT - Risk Analysis Option
	type Public Boolean ER
	if ln.rskopt=1 do Runtime.setErrMSG("LN",3266) quit:ER 
	
	// After Update Trigger Checking group
	type String GRP
	type Number RSKOPT

	set RSKOPT=ln.rskopt
	type ResultSet rs=Db.select("GRP","ACN","CID=:CID")
	set GRP=rs.getCol("GRP")
	// Risk option ~p1 is invalid for product ~p2
	if GRP="CBL",RSKOPT do Runtime.setErrMSG("LN",3337,"RSKOPT~GRP") quit:ER 
	quit
	

vau72 // Trigger AU_RTRNINFO - After Update Return Info

	type public RecordLN ln
	new AO,CDT

	set CDT=ln.cnvdt

	//Return date requires return notification offset
	if ln.rdt'="",ln.rnoff="" do Runtime.setErrMSG("LN",3191) quit
	if ln.rdt'="" quit 
	if CDT=%SystemDate quit 
	
	new rs 
	type ResultSet rs=Db.select("ROSEQ","LNRENEW","CID=:CID AND CNVAPP=1") 
	if rs.isEmpty() quit
	set A0=rs.next(),AO=rs.getCol(1)
	
	
	if rs.getCol(1)'="",ln.rnoff'="" do Db.update("LN","RDT=:CDT","CID=:CID")
	quit

vau73 // Trigger AU_SDTA - After update scheduled disb target acct

	type public RecordLN ln
 	/*
	---- Revision History -------------------------------------------------
	
	03/30/05 - KinI - 14385
	      Cleaned up to comply with DBI standards. 

 	04/26/02 - VERTLIBA - 46419
	     Modified code to quit with an error message: "Disbursement
													Target account not active" if target account is closed (stat=4).
	     Also, added CRCD logic from the BU_SDTA trigger which will be
													deleted.
	*/

	type public Boolean ER

	if ln.sdta do { quit:ER

		type String CRCD
		set CRCD=ln.crcd
		if CRCD="" set CRCD=%SystemCurrency
		
		type RecordACN acn=Db.getRecord("ACN","CID=:ln.sdta")

		// Target account must be different from source account
		if ln.sdta=ln.cid do Runtime.setErrMSG("LN",2599) quit:ER

		// Currency code of target account must be consistent with 
		// source account
		if CRCD'=acn.crcd do Runtime.setErrMSG("LN",655) quit:ER

		// Disbursement Target account not active
		if acn.stat=4 do Runtime.setErrXBAD("LN",160) quit:ER

 		}
	quit

vau74 // Trigger AU_SFRE - Modify SFRE on group when SFRE modified

	type public RecordLN ln
	/*
	---- Revision History--------------------------------------------------------
							01/17/01 - SCOTTC - 43455
																Added the call to UFRE to calculate the statement next date when
																the statement frequency is modified on the account.  This
																deviates from standard Profile practices due to the fact that
																when default statement frequencies are being used, and a freq
																changes and forces the creation of a new statement group, the
																statement next date will change. Same action by the user,
																different results.
	09/23/99 - SCOTTC 34881
		Changed SQLSELECT statement to see if more than one account in
		statement group to search in CMBSTM instead of CMBCID
	*/

	new CSTMGRP,XACN,XDESC,XSFRE,XADDR,XCID,XCMBGRP,XREST,XSFRE
	set XCID=ln.cid 
	set XACN=ln.acn
	
	// find existing statement group
	set CSTMGRP=Db.getOneRow("STMGRP","CMBCID","XCID,XACN")
	if CSTMGRP="" quit

	// find out if more than one account in statement group
	new rs 
	type ResultSet rs=Db.select("ACN","CMBSTM","STMGRP=:CSTMGRP AND ACN=:XACN AND CID<>:XCID") 
	if rs.isEmpty() quit
	set FNDGRP=rs.next(),FNDGRP=rs.getCol(1)
	
	
	//get information to pass to a new group
	if FNDGRP do { quit:ER 
		set XCMBGRP=Db.getOneRow("DESC,ADDR,REST,SFRE","CMBGRP","XACN,CSTMGRP")
		set XDESC=$P(XCMBGRP,$C(9),1) 
		set XADDR=$P(XCMBGRP,$C(9),2) 
		set XREST=$P(XCMBGRP,$C(9),3) 
		set XSFRE=$P(XCMBGRP,$C(9),4)
		if XSFRE'=ln.sfre do { quit:ER 
			// find last statement group for CID
			set NEWGRP=Db.nextVal("CMBGRP","XACN,STMGRP")

			// set new statement group number
			set XSFRE=ln.sfre
			if XADDR="" set XADDR=XCID
			do Db.insert("CMBSTM","ACN,STMGRP,CID",":XACN,:NEWGRP,:XCID")
			do Db.update("CMBSTM","STMGRP=:NEWGRP","ACN=:XACN AND CID=:XCID")
			}
		}

	if '(FNDGRP) do { quit:ER
		//Modify statement group's frequency
		set XSFRE=ln.sfre 
		set XACN=ln.acn
		new njd
		set njd=$$NJD^UFRE(Db.getOneRow("TJD","CUVAR"),XSFRE,.AF) quit:ER		
		do Db.update("CMBGRP","SFRE=:XSFRE,SNDT=:njd","STMGRP=:CSTMGRP AND ACN=:XACN")
		}
	quit 

vau75 // Trigger AU_SGNCRD - Signature Card Letter Processing

	type public RecordLN ln
	/*
	
	 05/18/05 - KELLYP - CR 15268
		Re-introduced this trigger since the XSGNCRD table cannot be
		populated by an index in DBI.  XSGNCRD is now handled as a 
		"calculated" table and its records are created/modified by
		the filers.
	*/


	// Remove any records from XSGNCRD with old signature card values
	do Db.delete("XSGNCRD","CID=:ln.cid")
	
	// If SGNCRD>0 AND PSGNCRDR'=1 track this account in XSGNCRD
	if ln.sgncrd>0,ln.psgncrdr'=1 do {
		type RecordXSGNCRD xsgncrd=Class.new("RecordXSGNCRD")
		set xsgncrd.sjd=%SystemDate
		set xsgncrd.sgncrd=ln.sgncrd
		set xsgncrd.osgncrdc=+ln.osgncrdc
		set xsgncrd.psgncrdr=+ln.psgncrdr
		set xsgncrd.cid=ln.cid
		do xsgncrd.bypassSave()
		}	

	quit

vau76 // Trigger AU_SMET - After Update statement flag

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------

	06/01/04 - KELLYP - CR 9670
		   Modified Db.delete call to use semicolons properly.

	*/	
	
	if ln.smet'=0 quit
	
	type String XACN,XCID,XSTMGRP

	set XCID=ln.cid
	
	type ResultSet rs=Db.select("STMGRP","CMBCID","CID=:XCID") 
	if rs.isEmpty() quit
	set XSTMGRP=rs.next(),XSTMGRP=rs.getCol(1)
	
	if XSTMGRP="" quit 
	set XACN=Db.getOneRow("ACN","LN","XCID")
	
	// Issue a delete to CMBSTM which will then delete CMBCID
	do Db.delete("CMBSTM","ACN=:XACN AND STMGRP=:XSTMGRP AND CID=:XCID")

	quit
	

vau77 // Trigger AU_SRCDT - After update Strike Rate Compare Date

	type public RecordLN ln
	/*
	 -- Revision History ------------------------------------------------
	 
	12/12/2005 - Sreeram Panyaram
		     Added Additional Check into the Error Condition. 	
	
	03/30/05 - KinI - 14385
	        Cleaned up to comply with DBI standards. 

	06/12/00 - RHINEHARTJ - 40586
		Added checks on Strike rate calendar and Strike rate comparative
 		date to make sure they are populated when Strike rate offset 
		has a value.
	*/

	type public Boolean ER
		
	// Strike rate offset requires strike rate compare date
	if ln.stroff,ln.srcdt.isNull() do Runtime.setErrMSG("LN",4359) quit:ER

	// Strike rate compare date cannot precede system date
	if ln.srcdt,ln.srcdt<%SystemDate do Runtime.setErrXBAD("LN","SRCDPSD") quit:ER 

	// Strike rate offset requires strike rate calendar
	if ln.stroff,ln.strcal.isNull() do Runtime.setErrMSG("LN",3198) quit:ER

	// Strike rate compare date must be a business date
	if '$$BD^UNBD(ln.srcdt,ln.strcal) do Runtime.setErrXBAD("LN","SRCDBUS") quit:ER 

	quit

vau78 // Trigger AU_STAT - AFTER UPDATE STAT

	type public RecordLN ln
	/*
	----- Revision History ------------------------------------------------
	
	03/30/05 - KinI - 14385
	           Cleaned up to comply with DBI standards. 

	03/18/99 - MOHAMEDE - 31429
		   Will create future dated entry in DAYENDAROD file if the
		   loan status becomes 4 (closed).
		   Also will remove DAYENDAROD entry if loan status changes from
		   status 4 to any other value.
	*/

	// When loan status becomes 4 (close), create a future dated DAYENAROD.

	type Number XCID=ln.cid
	type public Boolean ER

	if ln.stat=4 do { quit:ER  

		type Number XCOLL

		// COLTYP - Collateral Type
		type ResultSet rs=Db.select("COLL","LNCOL","CID=:ln.cid AND COLTYP=70")
		if rs.isEmpty() quit
		while rs.next() do { 
			set XCOLL=rs.getCol(1)
			
			type RecordCOL col
			set col=Db.getRecord("COL","COLL=:XCOLL")

			if 'col.avrsl quit 

			type RecordDAYENDAROD dayendarod=Class.new("RecordDAYENDAROD")

			set dayendarod.tjd=col.arod + %SystemDate
			set dayendarod.cid=XCID
			set dayendarod.coll=XCOLL

			do dayendarod.bypassSave()
			}
		}

	// Remove future dated DAYENDAROD entry.	
	if ln.stat.oldVal=4,ln.stat'=4 do { quit:ER   

		type Date XAROD
		set XAROD=%SystemDate-1

		do Db.delete("DAYENDAROD","CID=:XCID AND TJD>:XAROD")

		}
	quit

vau79 // Trigger AU_STRINFO - After Update Strike Rate Info

	type public RecordLN ln
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
	           Modified to comply with DBI standards. 
	*/

	if ln.stroff="" quit 

	// Strike Rate Compare Date
	if ln.srcdt="" do {

		type Number CID=ln.cid	
		type Date SCD
		
		set SCD=$$FINDATE^LNCDI(ln.cnvdt,ln.stroff,ln.strcal,ln.srcbind)
		
		do Db.update("LN","SRCDT=:SCD","CID=:CID")
		}
	quit

vau80 // Trigger AU_SUBSIDY - After update of Subsidy Values

	type public RecordLN ln

	/*
								---------------------- Revision History  --------------------------
 	03/16/06 - chhabris - CR19833
		   Added this trigger for keeping check on iam and idp.
	-------------------------------------------------------------------
	 
								*/

	// Subsidized Loans must have interest determined at billing
	if 'ln.subpln.isNull(),ln.idp do Runtime.setErrXBAD("LN",103) quit:ER 

	// Subsidized Loans cannot be Add-On or discount Loan
	if 'ln.subpln.isNull(),ln.iam do Runtime.setErrXBAD("LN",104) quit:ER
	
	quit

vau81 // Trigger AU_TEASER_INFO - After update teaser rate info

	type public RecordLN ln
	/*
	----Revision History----------------------------------------------------

	09/24/99 - ROYTENBERGE - 34627
		   Added code to return error message if Promotional Rate
		   Expiration Date is not greater than system date.
	*/


	// Teaser Expiration Date Exists without Teaser Rate
	if ln.trexd>%SystemDate,ln.trate="" do Runtime.setErrXBAD("LN",15) quit:ER 

	// Teaser Rate Exists without Expiration Date
	if ln.trate'="",ln.trexd="" do Runtime.setErrXBAD("LN",102) quit:ER 
	if ln.trexd'="",ln.trexd'>%SystemDate do Runtime.setErrMSG("LN",914,RM) quit 
	quit
	

vau82 // Trigger AU_TEB - After update total escrow balance

	type public RecordLN ln
	new data,escacr,escbal,pe,pmtelem,XESCCID
	do PMTELEM^LNFUNCS(ln.cid,.pmtelem)
	set pe="" set (escacr,escbal)=0
	for  set pe=$O(pmtelem(pe)) quit:pe=""  set XESCCID=$P(pmtelem(pe),"#",2) if XESCCID do { quit:ER 

		set data=Db.getOneRow("BAL,ACR","DEP","XESCCID")
		set escbal=escbal+$P(data,$C(9),1)
		set escacr=escacr+$P(data,$C(9),2)
		}
	// TOTAL ESCROW BALANCE Not Supported by Accounts
	if +ln.teb'=escbal do Runtime.setErrXBAD("LN",47,"TEB",ln.teb,escbal) quit:ER 

	// Account Status Flag of 1 with No Escrow Balance
	if ln.stat=1,'escbal&'escacr do Runtime.setErrXBAD("LN",131) quit:ER 

	quit

vau83 // Trigger AU_TITLE - After Update Title

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	03/13/06 - Srinivar -19975	
		   Added code to update the account TITLE changes 
		   in Escrow Account when any changes are done in 
		   associated Loan Account.
		   Modified the trigger to fetch the escrow cid 
		   using $$ECID^LNU instead of $$GETESC^ESCFUNCS.
		
	10/02/00 - LAMY - 42029
	           Added a check fo the Pledge account. If one does not
		   exist then quit.
	
	03/17/99 - FINCHG - 27393
		   Added check that loan title matches with any pledged deposit
		   accounts.
	

	If title has changed and loan account is secured by pledged account, tiltles
	between the pledged account and the loan account should be identical.
	*/
	
	type Number ECID
			 
	set ECID=$$ECID^LNU(CID,"ESC1")
	if ECID="" quit
	                
	type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")         
	if ln.title1'=ln.title1.oldVal set dep.title1=ln.title1         
	if ln.title2'=ln.title2.oldVal set dep.title2=ln.title2         
	if ln.title3'=ln.title3.oldVal set dep.title3=ln.title3         
	if ln.title4'=ln.title4.oldVal set dep.title4=ln.title4          
	do dep.bypassSave()  

	new XPLCID,XDEPO,XLNO
	set XLNO=ln.title1_$C(9)_ln.title2_$C(9)_ln.title3_$C(9)_ln.title4
	new rs 
	type ResultSet rs=Db.select("PLDGACN","LNCOL","LNCOL.CID=:CID")
	if rs.isEmpty() quit
	while rs.next() do { quit:ER  
		set XPLCID=rs.getCol(1)
		if XPLCID="" quit  // no pledged account
		set XDEPO=Db.getOneRow("TITLE1,TITLE2,TITLE3,TITLE4","DEP","XPLCID")
		// "Pledged account owners not owners of loan account"
		if XDEPO'=XLNO do Runtime.setErrXBAD("LN","PCIF") quit:ER    
		}
	quit

vau84 // Trigger AU_TYPE - After update type

	type public RecordLN ln
	/*
	---------- Revision History ------------------------------------------

	03/30/05 - KinI - 14385
	      	   Modified to comply with DBI standards. 
	
	03/10/03 - Allan Mattson - 51351
	           Removed calls to ^CFMAIN (Cash Flow obsoleted in V7.0).

	02/04/99 - KONGJ - 30071
		   Changed table name from PRODDFTC to PRODCTL for INTYPRST.
	
	12/23/98 - KONGJ - 30071
		   Changed CIFTYP.INTYPRST to PRODDFTC.INTYPRST.
	
	11/18/98 - KONGJ - 30071
		   Added check to verify a valid combination of customer type,
		   institution type and account type during account maintenance.
	
	*/

	type Number OTYPE
	type Date ZDATE
	type public Boolean ER

	set OTYPE=ln.type.oldVal

	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")	

	set ZDATE=%SystemDate-prodctl.blpsav

	// Product class cannot be changed
	if ln.cls.oldVal'=ln.cls do Runtime.setErrXBAD("LN",178) quit:ER 

	// Distinct processing parameters prohibit product transfer
	if ln.trb.oldVal'=ln.trb do Runtime.setErrXBAD("LN",180) quit:ER 

	// Move contents of bill print file
	type ResultSet rs=Db.select("BILDT","LNBLP","BILDT>:ZDATE AND TYPE=:OTYPE AND CID=:ln.cid")
	if 'rs.isEmpty() while rs.next() do {
	
		type Date BILDT

		set BILDT=rs.getCol("BILDT")	

		type RecordLNBLP lnblp
		set lnblp=Db.getRecord("LNBLP","BILDT=:BILDT,TYPE=:OTYPE,CID=:ln.cid")
		set lnblp.type=ln.type
		
		do lnblp.save()
		}

	// Check Institution Type Restriction at account maintenance

	type RecordCIF cif
	set cif=Db.getRecord("CIF","ACN=:ln.acn")

	// Check for Institution Type Restriction.
	if cif.intype'="" do { quit:ER 
		
		type RecordPRODCTL prodctl1
		set prodctl1=Db.getRecord("PRODCTL","TYPE=:cif.type")
	
		// Check the user table UTBLINTTBL for a valid combination.
		if prodctl1.intyprst do { quit:ER 

			if Db.isDefined("UTBLINTTBL","CIFTYPE=:cif.type,INTYPE=:cif.intype,TYPE=:ln.type") quit 

			// Product not valid for Institution Type
			do Runtime.setErrXBAD("LN","INTYPRST") quit:ER 
			}
		}
	
	quit

vau85 // Trigger AU_UDBAL_INFO - After udpate unadvanced balance info

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards. 
	
	04/10/03 - CARROLLJ - 51349
		   Modified call to BALINT^LNFUNCS to only pass ln object and 
		   removed the use of the data array.

	08/15/02 - CARROLLJ - 43583
		   Modified calls to LNCL1 tp pass the ln object and also
		   removed getoneRow's.
	*/
	
	type public Boolean ER
	type Number TAMT
	
	if ln.aruf do { quit:ER
		// Change revolving flag when undisbursed processing is used
		if ln.cpf do { quit                
			
			// Modify the available credit by the total principal 
			// repaid within all linked non-revolving loans.
			
			type Number NCID
			
			set TAMT=0
			
			// Get each linked loan and add principal repaid
	
			type ResultSet rs=Db.select("CID","LN","CCL=:ln.cid") quit:ER 
			if rs.isEmpty() quit
			while rs.next() do { quit:ER  

				set NCID=rs.getCol(1)
				
				Type RecordLN ln1=Db.getRecord("LN","CID=:NCID")
				
				set TAMT=TAMT+ln1.prnrpd
				}
		
			// Increase available commitment if changed to 
			// revolving, otherwise decrease.

			if TAMT do {
				if 'ln.revf set TAMT=-TAMT
				
				do TTX^LNCL1(.ln)  // Post transaction
				}
			}
	
		// Update BAL and UDBAL by total principal repaid.
		// If REVF is changed to "Y", then increase.  Else decrease.

		set TAMT=ln.prnrpd

		if 'TAMT quit 

		if 'ln.revf set TAMT=-TAMT

		do TTX^LNCL1(.ln)
	
		/*
		The account has been processed.  Now check to see if there is
		a controlling commitment.  If so, then either increase or decrease
		BAL and UDBAL on the commitment.
		*/

		set TAMT=-TAMT
		
		if 'ln.ccl quit      // No controlling commitment       
		
		if 'ln.revf quit     // Commitment is non-revolving        

		do TTX^LNCL1(.ln)
		}
	
	else  do {
		// Modify revolving flag when account does not use undisbursed processing

		set TAMT=ln.prnrpd
		if 'ln.revf set TAMT=-TAMT
	
		if 'TAMT quit 

		set TAMT=-TAMT
		
		// Post transaction to commitment
		if ln.ccl do {                   
			
			Type RecordLN ln2=Db.getRecord("LN","CID=:ln.ccl")
			
			if 'ln2.revf quit	// Not revolving
			
			do TTX^LNCL1(.ln2)
			}
		}
	
	if (ln.balint.oldVal'=ln.balint) ! (ln.udbal.oldVal'=ln.udbal) ! (ln.icpa.oldVal'=ln.icpa) do { quit:ER 
		type Number BALINT
		set BALINT=$$BALINT^LNFUNCS(.ln)

		// Balance for Interest Calculation not supported
		if (+ln.balint '= +BALINT) do Runtime.setErrXBAD("LN",43,"BALINT",ln.balint,BALINT) quit:ER 
		}
	
	// Debit/Credit Balance cannot be defined for rev accts
	if (ln.revf) , (ln.dbt!ln.cbt) do Runtime.setErrXBAD("LN",528) quit:ER 
	
	quit

vau86 // Trigger AU_WDLMT - After update withdrawal limit (WDLMT)

	type public RecordLN ln
	/*
	---- Revision History---------------------------------------------------

	05/10/00 - ANTONOVV - 39845
		Created this trigger to check if the withdrawal limit (WDLMT) is
		higher than the credit limit (CRLMT).
	*/

	// WDLMT(Withdrawal Limit) cannot be greater than CRLMT(Credit Limit)
	if ln.wdlmt'="",ln.wdlmt>ln.crlmt do Runtime.setErrMSG("LN",4191) quit:ER

	quit

vau87 // Trigger AU_WDLMTP - After Update Withdrawal Limit Processing

	type public RecordLN ln
	/*-----Revision History------------------------------------------------
	 05/15/06 - NATRAJAH - 21189	 	    
	 	    Modified the if codition to restrict the system date in 
	 	    "Next Reduction Date" field	 	   
	 	    
	 12/27/00 - RAJARAMD - 42288
		    Added Error messages for the following conditions:
		    1) LN.PBFRE is defined and LN.PBNXTDT is not defined.
		    2) LN.PBNXTDT is defined and LN.PBFRE is not defined.
		    3) LN.COLLIMPR and LN.WDLMTP are both enabled.
		    4) LN.ADJCOL is enabled and LN.COLLIMPR is disabled.
	*/

	// Next withdrawal reduction date on or before the system date
	if ln.wdnd'="",ln.wdnd'>%SystemDate do Runtime.setErrXBAD("LN",524) quit:ER 
	
	// Withdrawal limit frequency requires next withdrawal limit reduction date
	if ln.wdfre'="",ln.wdnd="" do Runtime.setErrXBAD("LN",525) quit:ER 

	// Penalty Balance Next Cutoff Date required
	if ln.pbfre,('ln.pbnxtdt) do Runtime.setErrMSG("LN",4650) quit:ER
	
	// Penalty Balance Review Frequency required
	if ln.pbnxtdt,('ln.pbfre) do Runtime.setErrMSG("LN",4649) quit:ER

	/*
	   Cannot use processing for both Collateral Credit Limit and Loan
	   Withdrawal Limit
	*/
	if ln.collimpr,ln.wdlmtp do Runtime.setErrMSG("LN",4648) quit:ER
	
	/*
	   Adjust Collateral Credit Limit cannot be enabled if Collateral
	   Credit Limit Processing is disabled
	*/
	if ln.adjcol,('ln.collimpr) do Runtime.setErrMSG("LN",4656) quit:ER	
	quit

vau88 // Trigger AU_WRKDTE - After Update Work Date

	type public RecordLN ln
	/*
	---- Revision History ------------------------------------------------
	
	11/11/05 - SATYANAS -18007
		   Converted the code to PSL Standards.
	
	06/03/99 - HILLANBRAND - ARQ33064
		   Added new trigger AU_WRKDTE for Collection Queue
	*/

	type public Boolean ER
	type public Number CID
	
	// Update worked in Collection Report File
	
	type ResultSet rs=Db.select("QUEUE,CLS,WRKED","QCOLLREP","CID=:CID") 
	if rs.isEmpty() quit
	
	if 'rs.getCol(3),('rs.getCol(1).isNull()) do { quit:ER
		
		type RecordQCOLLREP qcollrep=Db.getRecord("QCOLLREP","CID=:CID,CLS=:rs.getCol(2),QUEUE=:rs.getCol(1)",1)
		if qcollrep.getMode() do {
			set qcollrep.wrked=1
			do qcollrep.save()
			}
		}	
		
	quit
	

vbd1 // Trigger BEFORE_DELETE - Before delete trigger

	type public RecordLN ln
								/*
								---- Revision History -----------------------------------------------

	03/09/06 - KELLYP - CR 19958
		   Modified to remove the third parameter from the call to 
		   REMOVE^PROCEFT.  Also removed pre-2003 revision history.

								02/05/04 - Erik Scheetz - CR7501
        	   Removed call to LNPURGU.  This functionality has been
        	   removed from profile04 and is expected to be replaced with
        	   a database independent version.  
	
								*/

	type public Boolean ER

	// Delete escrow accounts
	do DELESC^ESCFUNCS(ln.cid)

	// Delete EFT's	
	do REMOVE^PROCEFT(ln.cid,%SystemDate)

	// Delete RELCIF entries for this account
								do Db.delete("RELCIF","CID=:ln.cid AND ACN=:ln.acn") quit:ER
	do Db.delete("CMBSTM","CID=:ln.cid AND ACN=:ln.acn") quit:ER
	
	quit 

vbi1 // Trigger BEFORE_INSERT - Before Insert trigger

	type public RecordLN ln
								/*
								---- Revision History---------------------------------------------------
	
								04/03/00 - KELLYP - 37918
																			Moved all code and revision history comments from this
																			trigger into a new procedure, LNAI, to prevent compilation
																			errors caused by the LN filer being too large.  Changes to
																			the AFTER_INSERT trigger should now be made to the LNAI proc.
								*/
	
								do PROC^LNBI(.ln)       // All code moved to BEFORE_INSERT Procedure
								quit

vbu1 // Trigger BU_ACS - Before update accrual indicator

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Revision History

	05/31/00 - CHOK - 40196
		   Converted isChanged method.
	*/

	// Only change by system allowed
	// Change to column ~p1 not allowed
	if 'ln.isChanged("ACS","SYSTEM") do Runtime.setErrMSG("LN",412,"LN.ACS") quit:ER 
	quit
	

vbu2 // Trigger BU_ALPRTY - Before Update Automatic Loan Payment

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History--------------------------------------------------------
	
	03/19/99 - KUCHEROVSKYA - 49806
		   When an institution is in the middle of upgrading, the server may
		   on v6.2, some clients are on v62, and other  clients are on v61.
	*/


	if ln.alprty=1,('ln.alprtyd) set ln.alprtyd=999
	if 'ln.alprty set ln.alprtyd=""
	quit
	

vbu3 // Trigger BU_ALPRTYD - Before Update Auto Payment Retry Days

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------------
	
	03/19/99 - KUCHEROVSKYA - 49806
		   When an institution is in the middle of upgrading, the server may
		   on v6.2, some clients are on v62, and other  clients are on v61.
	*/

	if ln.alprtyd>0 set ln.alprty=1
	else  set ln.alprty=0
	quit
	

vbu4 // Trigger BU_ANOFFDT - Before update pmt change offset date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Revision History

	05/31/00 - CHOK - 40196
		   Converted isChanged method.
	*/

	// Only change by system allowed
	// Change to column ~p1 not allowed
	if 'ln.isChanged("ANOFFDT","SYSTEM") do Runtime.setErrMSG("LN",412,"LN.ANOFFDT") quit:ER 
	quit
	

vbu5 // Trigger BU_APCND - Before update analysis payment next date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// If old change date, move to new date
	if (ln.apcnd.oldVal'=ln.apcnd),ln.apcnd.oldVal do {
		new APCND,CID,NAPCND
		set APCND=ln.apcnd.oldVal
		set CID=ln.cid
		if 'Db.isDefined("LNAPCHG","APCND,CID") quit
		set NAPCND=ln.apcnd
		do Db.update("LNAPCHG","APCND=:NAPCND","CID=:CID AND APCND=:APCND")
		}
	
	// Calculate new value for Payment Change Analysis Offset Date
	if 'ln.apcnd set ln.anoffdt.journal=0,ln.anoffdt=""
	else  set ln.anoffdt.journal=0,ln.anoffdt=ln.apcnd-ln.anoff
	quit

vbu6 // Trigger BU_APRMTHD - Before Update of the APRMTHD

	type public RecordLN ln
	do ln.setAuditFlag(1)
	new PAPRM,XTYPE
	set XTYPE=ln.type
	set PAPRM=Db.getOneRow("APRMTHD","PRODDFTL","XTYPE")

	// APR calc method must be consistent with the product type
	if PAPRM'=ln.aprmthd do Runtime.setErrXBAD("LN","526") quit:ER 
	quit
	

vbu7 // Trigger BU_ARUF - Before update advances to reduce undisb

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Undisbursed balance prohibits changes to undisbursed flag
	if ln.udbal>0 do Runtime.setErrSTBLER("LN","CNVARUF") quit:ER 
	
	// Changes to undisbursed processing prohibited on commitments
	if ln.cpf>0 do Runtime.setErrSTBLER("LN","CNVARUF2") quit:ER 
	quit
	

vbu8 // Trigger BU_BAMT - Before Update Balloon Amount Trigger

	type public RecordLN ln
	do ln.setAuditFlag(1)
								/*
								---- Revision History---------------------------------------------------
	41056 - KELLYP - 07/11/00
		Created this trigger.  Need to set payment term (LN.PTRM) equal
		to acount term (LN.TRM) when balloon amount (LN.BALLAMT) is
		defined. 
								*/

	// Set payment term = account term if balloon amount is declared
	if ln.ballamt'="" set ln.ptrm=ln.trm
	quit

vbu9 // Trigger BU_BLOFF - Before update billing offset

	type public RecordLN ln
	do ln.setAuditFlag(1)
	if ln.bloff="1P"!(ln.bloff?.N) do { quit:ER 
		if ln.bloff.oldVal="1P"!(ln.bloff="1P"),ln.schld'=%SystemDate do { quit:ER 
			// May not transfer from/to frequency "1P" on other than payment date
			do Runtime.setErrSTBLER("LN","LNBLOFF3") quit:ER 
			}
	
		// Determine whether or not change is allowed
		if '(ln.bloff="1P"!(ln.bloff.oldVal="1P")) do { quit:ER 
			// New billing offset must be greater than 0
			if ln.bloff'>0 do Runtime.setErrSTBLER("LN","LNBLOFF4") quit:ER 
	
			// May not change billing offset if currently in offset period
			if ln.bseq,ln.bldt+ln.bloff.oldVal>%SystemDate do Runtime.setErrSTBLER("LN","LNBLOFF1") quit:ER 
	
			// Invalid if change would put account in billing offset period
			if ln.bndt.oldVal+ln.bloff.oldVal-ln.bloff<%SystemDate do Runtime.setErrSTBLER("LN","LNBLOFF2") quit:ER 
			}
	
		// Determine new billing next date
		if ln.bloff="1P",ln.bndt'=ln.schnd set ln.bndt=ln.schnd
		else  do {
			new NEWVAL
			set NEWVAL=ln.bndt.oldVal+ln.bloff.oldVal-ln.bloff
			if ln.bndt'=NEWVAL set ln.bndt=NEWVAL
			}
		}
	quit
	

vbu10 // Trigger BU_CCLD - Before update customer contact last date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
		Modified to comply with DBI standards. 
	*/

	// Don't update based on title changes
	if 'CUVAR.LCCTIT quit  

	// Already set for today
	if ln.ccld=%SystemDate quit

	set ln.ccld.journal=0,ln.ccld=%SystemDate

	quit
	

vbu11 // Trigger BU_CID - Account number changed

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Change escrow accounts loan reference number (AREF)
	
	do CHGESC^ESCFUNCS(ln.cid.oldVal,ln.cid)
	quit 

vbu12 // Trigger BU_CLPS - Before update construction loan status

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Additional processing if construction loan status changes from
	1 (interim) to 2 (permanent):
	*/

	if ln.clps.oldVal=1,ln.clps=2 do { quit 
	
		new CRCD,TYPE,data,iacm,pcm
	
		/*
		No further processing required if LN.CNVPRD contains no
		value.  This column indicates the new product to which
		the account should be linked after this change.
		*/
		if ln.cnvprd="" quit 
	
		set ln.type=ln.cnvprd
	
		// Define LTYPE table keys
		set TYPE=ln.type

		/*	
		Retrieve column values from the new product, and update
		the LN record with those values.  PROFILE institutions
		requiring additional columns should modify this trigger
		to reflect that need.
		*/
		set data=Db.getOneRow("PCM,IACM","PRODDFTL","TYPE")
	
		set pcm=$P(data,$C(9),1)
		set iacm=$P(data,$C(9),2)

		/*	
		Update account record unless product value is null, or
		column has already been manually changed by user
		*/
		if '(ln.pcm.oldVal'=ln.pcm),(pcm'="") set ln.pcm=pcm
		if '(ln.iacm.oldVal'=ln.iacm),(iacm'="") set ln.iacm=iacm
	
		quit 
		}
	quit
	

vbu13 // Trigger BU_CLS - Before update class

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Change to column ~p1 not allowed
	do Runtime.setErrMSG("LN",412,"LN.CLS") quit:ER 
	quit
	

vbu14 // Trigger BU_CNVDT - Before update Conversion Date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/* ------------- Revision History --------------------------------------
	
	03/30/05 - KinI - 14385
		   Created the trigger to accomodate the code moved from 
		   AU_CNVDT.

	------------------------------------------------------------------------
								*/

	if ln.cnvdt="" set ln.srcdt="" quit
	
	if ln.srcdt'="" quit

	if ln.stroff'="" set ln.srcdt=$$FINDATE^LNCDI(ln.cnvdt,ln.stroff,ln.strcal,ln.srcbind)

	quit

vbu15 // Trigger BU_CNVSTAT - Before Update Manual Conversion Status

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	This trigger resets the conversion data related to the loan when the 
	loan conversion status changes to reset status.  Possible values for 
	the conversion status [LN]CNVSTAT item are:
	 NULL - loan is not setup for conversion or
	        is in the preconversion status (shell of the loan created) 
	        or is being reset for conversion or
	    1 - loan is setup for conversion
	    2 - loan is in the postconversion status
	*/

	/*
	---- Revision History ------------------------------------------------

	04/10/03 - CARROLLJ - 51349
		   Modified call to BALINT^LNFUNCS to only pass the ln object
		   and removed the use of the data array.

	----------------------------------------------------------------------
	*/

	if %O=0 quit

	if ln.cnvstat=2 quit

	// Calc BALINT for manual loan for conversion
	if ln.cnvstat=1 do {   
		new balint
		set ln.balint=$$BALINT^LNFUNCS(.ln)
	}
	// Reset loan for conversion
	if ln.cnvstat="" do {
		set HISCTF=ln.hisctf
		if (ln.aruf)!(ln.cpf) set ln.udbal=ln.crlmt
		new XCCL
		set XCCL=ln.ccl
		if XCCL do { quit:ER
 			// Update loan's commitment
 			new XBAL,XUDBAL,P
			if ln.revf'="" quit
			if 'Db.isDefined("LN","XCCL") quit   // No commitment on file
			new data
			set data=Db.getOneRow("REVF,BAL,UDBAL","LN","XCCL")
			if '$P(data,$C(9),1) quit   // REVF
			// The commitment is revolving and the underlying loan
			// is not. Decrease the toal principal repaid, which 
			// should be ideally the difference betweenTDR and BAL
			// where bal is the amount that the borrower owes as 
			// entered for conversion.
			set P=ln.tdr-ln.bal       // Total principal repaid
			set XBAL=+$P(data,$C(9),2)-P
			set XUDBAL=+$P(data,$C(9),3)-P
			do Db.update("LN","BAL=:XBAL,UDBAL=:XUDBAL","CID=:XCCL")
		}
		// Reset the loan to a preconversion status
		set ln.bal=""
		set ln.udbal=""
		set ln.teb=""
		set ln.habl1=""
		set ln.hisctf=""
		set ln.schseq=0
		set ln.tdue=0
		set ln.inta=0
		set ln.tba=0
		set ln.bseq=0
		set ln.cuin=0
		set ln.unin=0
		set ln.cupr=0
		set ln.unpr=0
		set ln.cues=0
		set ln.unes=0
		set ln.balint=""
		// Delete billing information
		new XCID
		set XCID=ln.cid
		new rs
		type ResultSet rs=Db.select("SCHSEQ","LNBIL1","CID=:XCID") quit:ER
		while rs.next() do {
			new XSCHSEQ
 			set XSCHSEQ=rs.getCol(1)
 			do Db.delete("LNBIL1","SCHSEQ=:XSCHSEQ AND CID=:XCID")
		}
		// Select all PEnnDA from LNBIL0
		new v,row
		set v=""
		set v=v_"PE01DA,PE02DA,PE03DA,PE04DA,PE05DA,PE06DA,PE07DA,"
		set v=v_"PE08DA,PE09DA,PE10DA,PE11DA,PE12DA,PE13DA,PE14DA,"
		set v=v_"PE15DA,PE16DA,PE17DA,PE18DA,PE19DA,PE20DA"
 		set row=Db.getOneRow(v,"LNBIL0","XCID") quit:ER
		if $G(row)'="" for i=1:1:20 set data=$P(row,$C(9),i) if data'="" do { Q:ER
			new ECID,esccnt
			set ECID=data
			do Db.update("DEP","BAL='',POSACR=''","CID=:ECID")
			new rs
			type ResultSet rs=Db.select("TYP","TRTYPE","CID=:ECID")
			while rs.next() do {
				new TYP
				set TYP=rs.getCol(1)
				do Db.update("TRTYPE","REMYTD='',REMPY=''","TYP=:TYP AND CID=:ECID")
			}
 			if i=1 do Db.update("LNBIL0","PE01PF='',PE01LA='',PE01NA=''","CID=:XCID")
			if i=2 do Db.update("LNBIL0","PE02PF='',PE02LA='',PE02NA=''","CID=:XCID")
			if i=3 do Db.update("LNBIL0","PE03PF='',PE03LA='',PE03NA=''","CID=:XCID")
			if i=4 do Db.update("LNBIL0","PE04PF='',PE04LA='',PE04NA=''","CID=:XCID")
			if i=5 do Db.update("LNBIL0","PE05PF='',PE05LA='',PE05NA=''","CID=:XCID")
			if i=6 do Db.update("LNBIL0","PE06PF='',PE06LA='',PE06NA=''","CID=:XCID")
			if i=7 do Db.update("LNBIL0","PE07PF='',PE07LA='',PE07NA=''","CID=:XCID")
			if i=8 do Db.update("LNBIL0","PE08PF='',PE08LA='',PE08NA=''","CID=:XCID")
			if i=9 do Db.update("LNBIL0","PE09PF='',PE09LA='',PE09NA=''","CID=:XCID")
			if i=10 do Db.update("LNBIL0","PE10PF='',PE10LA='',PE10NA=''","CID=:XCID")
			if i=11 do Db.update("LNBIL0","PE11PF='',PE11LA='',PE11NA=''","CID=:XCID")
			if i=12 do Db.update("LNBIL0","PE12PF='',PE12LA='',PE12NA=''","CID=:XCID")
			if i=13 do Db.update("LNBIL0","PE13PF='',PE13LA='',PE13NA=''","CID=:XCID")
			if i=14 do Db.update("LNBIL0","PE14PF='',PE14LA='',PE14NA=''","CID=:XCID")
			if i=15 do Db.update("LNBIL0","PE15PF='',PE15LA='',PE15NA=''","CID=:XCID")
			if i=16 do Db.update("LNBIL0","PE16PF='',PE16LA='',PE16NA=''","CID=:XCID")
			if i=17 do Db.update("LNBIL0","PE17PF='',PE17LA='',PE17NA=''","CID=:XCID")
			if i=18 do Db.update("LNBIL0","PE18PF='',PE18LA='',PE18NA=''","CID=:XCID")
			if i=19 do Db.update("LNBIL0","PE19PF='',PE19LA='',PE19NA=''","CID=:XCID")
			if i=20 do Db.update("LNBIL0","PE20PF='',PE20LA='',PE20NA=''","CID=:XCID")
		}
		new XTYPE,XGRP
		set XTYPE=ln.type
		set XGRP=ln.grp
		if $G(CEFD)="" set CEFD=TJD-1
		do Db.delete("LNCONCMP","CEFD=:CEFD AND CLS='L' AND TYPE=:XTYPE AND GRP=:XGRP AND CID=:XCID")
		do Db.delete("LNCONVES","CEFD=:CEFD AND CID=:XCID")
		do Db.delete("LNCONBL1","CEFD=:CEFD AND CID=:XCID")
		do Db.delete("XCNVMAN","CID=:XCID")
	}
	quit

vbu16 // Trigger BU_COLCD - Before update collateral code

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// If collateral code changes, reassign the primary collateral record number

	new X,XCID,XCOLCD
	set XCID=ln.cid 
	set XCOLCD=ln.colcd

	// new colcd is being changed to null
	if XCOLCD="" quit                    
	new rs 
	type ResultSet rs=Db.select("COLL","LNCOL,COL","LNCOL.CID=:XCID AND COL.SCOLCD=:XCOLCD") 
	if rs.isEmpty() quit
	set COLL=rs.next(),COLL=rs.getCol(1)
	
	if $G(COLL)'="" if ln.coll'=COLL set ln.coll=COLL
	quit
	

vbu17 // Trigger BU_COLLST - Collection Status Change

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------
	
	11/15/05 - SATYANAS - 18007
		   Added the declaration for ER.
	
	06/14/99 - CARROLLJ 33064
		   If [LN]COLLST-Collsection Status is modified update the
		   [LN]PCOLLST-Previous Collection Status and [LN]COLCDTE-
		   Collection Status Change date.

	
	If collection status is changed update previous collection status and
	Collection Status Change Date
	*/
	
	type public Boolean ER
	
	if (ln.collst.oldVal'=ln.collst) do { quit:ER 
		if ln.colcdte'=%SystemDate set ln.colcdte=%SystemDate
		if ln.collst.oldVal'=ln.collst set ln.pcollst=ln.collst.oldVal
		}
	
	quit
	

vbu18 // Trigger BU_COUPON_INFO - Before update of coupon info

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	------------------------------- Revision History -------------------
	10/09/01 - SIVCHUKS - 47644
		Move section SETCPNS to AU_CBMET. This will fix the problem
		when error msg was coming from ln account when payment method
		was switched from automated loan payment to coupon production.
		When data item ln.cbmet(Reorder Basis)was set in ln account in
		PFW for the first time, call was made to LN to check if record
		for this data item exist in table, and if not,the error msg
		was displayed.
		To prevent error occurring during creation, and before checking
		for ln.cbmet in this trigger, value of data item ln.cbmet will
		be set to LN in AU_CBMET trigger.
		
	07/17/01 - PARRAS - 45335
		Added error checking after the calls to CBMET*^LNFUNCS. 
		Invalid errors were displayed later in the process if the
		error was set in one of these functions.
	
	*/

	if 'ln.cbmet.oldVal,ln.cbmet do {
		if 'ln.cbpnd set ln.cbpnd.journal=0,ln.cbpnd=%SystemDate
		set ln.cbond.journal=0,ln.cbond=ln.cbpnd
		}
	
	if ln.cbmet.oldVal,'ln.cbmet do {
		if ln.cbpnd set ln.cbpnd.journal=0,ln.cbpnd=""
		do DELCPNS(.ln)
		}
	
	if ln.cbmet.oldVal,ln.cbmet do {
		if 'ln.cbpnd set ln.cbpnd.journal=0,ln.cbpnd=%SystemDate
		do DELCPNS(.ln)
		}
	quit 


DELCPNS(RecordLN ln) // Delete future dated coupon records

	// This section will delete multiple future coupon records for an account.
	new DATA,XCID,XJD,XPND,XPMET,rs
	set XJD=(%SystemDate-1)
	set XCID=ln.cid
	type ResultSet rs=Db.select("PND","LNCPN","PND>:XJD AND CID=:XCID")
	if rs.isEmpty() quit
	while rs.next() do { quit:ER  
		set XPND=rs.getCol(1)
		do Db.delete("LNCPN","PND=:XPND AND CID=:XCID")
		}
	quit 

vbu19 // Trigger BU_CRLMT - Before update credit limit

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------

	09/26/06 - SANTHUMS - 23201
		   Modified the code use ln.udbal.oldVal while updating
		   the LN.UDBAL,  since unadvanced balance(Ln.UDBAL) was 
		   not getting updated properly while creating the account.
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards.
		   Removed second argument from MAXFND^LNFUNCS call.

	02/12/99 - MOHAMEDE - 28968
		   If ICPA is set on and the loan balance is greater than credit limit
		   then the credit limit is selected for the interest calculation rather
		   than the loan balance otherwise the loan balance is selected.
	*/

	type public Boolean ER

	// Must change revolving flag and credit limit seperately
	if (ln.revf.oldVal'=ln.revf) do Runtime.setErrSTBLER("LN","REVCR") quit:ER 
	
	// Update UDBAL by the change in CRLMT if appropriate
	if 'ln.aruf set ln.udbal.journal=0,ln.udbal=ln.udbal.oldVal+(ln.crlmt-ln.crlmt.oldVal)
	
	// Update HTBLLTYPE table for correct credit limit total

	// Max funding limit
	if $$MAXFND^LNFUNCS(ln.type) > 0 do {  

		type Number AMT
		set AMT=ln.crlmt-ln.crlmt.oldVal
		
		type RecordHTBLLTYPE htblltype=Db.getRecord("HTBLLTYPE","TYPE=:ln.type",1)	

		if htblltype.getMode()=0 set htblltype.crlmt=AMT
		else  set htblltype.crlmt=htblltype.crlmt+AMT

		do htblltype.bypassSave()

		}

	// New balance amount > credit limit

	type RecordUTBLICPA utblicpa=Db.getRecord("UTBLICPA","KEY=:ln.icpa")

	if (utblicpa.prio).extract(12) set ln.balint=$S(ln.bal'>ln.crlmt:ln.bal,1:ln.crlmt)   

	quit
	
	

vbu20 // Trigger BU_DARCOVR - Before Update Delinq Asset Class Overrid

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	If Delinquency Asset Class Override is updated, update Suspect Indicator.
	If DARCOVR > 0 set SUSPECT to 1.
	If DARCOVR = Null and Expiration period exists set SUSPECT to 3, else set
	SUSPECT to NULL
	*/

	set ln.suspect=$S(ln.darcovr>0:1,(ln.darcexpd&'ln.darcovr):3,1:"")
	quit
	

vbu21 // Trigger BU_DFP - Before update date first payment

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History -------------------------------------------------------
	
	09/02/99 - ALBINK - 33413
		   Added code in order to change and check the value of LN.DIST1ND
		   when the value of LN.DFP is modified.
	*/	


	
	if 'ln.bseq do {
		new newval
		if ln.bloff="1P" set newval=$$NJD^UFRE(ln.dfp,"-"_ln.dist1fre) quit:ER
		else  set newval=ln.dfp-ln.bloff
		if ln.bndt'=newval set ln.bndt=newval
		if ln.schnd'=ln.dfp set ln.schnd=ln.dfp
		if ln.dist1nd'=ln.dfp set ln.dist1nd=ln.dfp 
		}
	
	quit

vbu22 // Trigger BU_DICO - BEFORE UPDATE IROPT FROM DICO

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Synchronize values between DICO & IROPT so that DICO might eventually be
	obsoleted.
	*/
	
	set XDICO=ln.dico
	set ln.iropt.journal=0,ln.iropt=$S(XDICO="":0,XDICO="BL":1,XDICO="FR":2,XDICO="PC":3,XDICO="SP":4)
	quit
	

vbu23 // Trigger BU_DIST1FRE - Before update distribution 1 frequency

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History -------------------------------------------------
	01/28/04 - CARROLLJ - CR7997
		   Correct undefined error on newdistf variable.

	12/04/00 - HUNDERMARKD - 42333
		   Added code to produce an error message if a payment schedule
		   loan has flag PIACM (Calculate P&I Based on IACM) turned on.
	
	03/25/99 - KUCHEROVSKYA - 32401
		   Modified calls to DFP^PROCLN to use LN.TYPE and LN.CRCD as
		   parameters rather than TYPE and CRCD.
	
	02/10/99 - Pete Hayman - 31540
		   Added DIST1LD to list of updated data items.  Also added section
		   for condition when SCHSEQ=0.
	*/	


	if ln.mdt="" do {
		/*
		New method to calculate maturity date using tools in PROCLN.M,
		which is the loan procedure.
		*/

		// Need loan term.
		if ln.trm="" quit 
	
		new BUSOPT,DFP,DIST1FRE,DTNT,LPD,MDT,NBDC,ODD,PCMVAL,TRM,ZAMODT

		// First, we need to calculate DFP (date of first payment.)
		set ODD=ln.odd 
		set DFP="" 
		set DIST1FRE=ln.dist1fre 
		set BLOFF=ln.bloff 
		set DIST1ND=ln.dist1nd
		set DFP=$$DFP^PROCLN(ln.type,ln.crcd,ODD,DIST1FRE,DIST1ND,DFP,BLOFF)

		// Next, calculate LPD (last payment date.)
		set LPD="" set ZAMODT=$$AMODT^PROCLN(ln.type,ln.crcd,ODD,DIST1FRE,DFP,.LPD)
	
		// Finally, calculate MDT (maturity date)
		set DTNT=ln.dtnt 
		set BUSOPT=ln.busopt 
		set TRM=ln.trm 
		set PCMVAL=$$PCMVAL^LNCDI(ln.pcm)
		set NBDC=ln.nbdc
		set MDT=$$MDT^PROCLN(DTNT,ODD,,TRM,BUSOPT,NBDC,LPD,PCMVAL,DIST1FRE) quit:ER 
		set ln.mdt=MDT
	
		}

	new lbdd,npfre,raf,rbndt,rschnd
	
	// Unique considerations if change from regular frequency to payment schedule
	if ln.dist1fre="*" do { quit 
		new dist,n,pmtdistf
	
		// Verification checks to ensure propriety of payment schedule processing
		do { quit:ER 
	
			// Invalid payment calc method for payment schedule processing
			if $E(ln.pcmval,3)'=3!$E(ln.pcmval,2)!($E(ln.pcmval,5)) do Runtime.setErrSTBLER("LN","PFRE*1") quit 
	
			/*
			First character of interest accrual method must not be "0" unless
			interest calculation period frequency has a value.
			Standard interest period method conflicts with payment schedule processing
			*/
			if '$E(ln.iacm),ln.icpf="" do Runtime.setErrSTBLER("LN","PFRE*4") quit 
			
			// Flag PIACM (Calculate P&I Based on IACM) cannot be turned on.
			if ln.piacm do Runtime.setErrSTBLER("LN","PFRE*5") quit		// DJH 12/04/00

			// Maturity date required for payment schedule processing
			if ln.mdt="" do Runtime.setErrSTBLER("LN","PFRE*2") quit 
	
			// Move 4th distribution values before changing to a payment schedule
			if ln.dist4fre'="" do Runtime.setErrMSG("LN",1260) quit 
			}
	
		/*
		Update secondary due dates equal to value of preceding frequency because
		no elements in payment schedule may be linked to dist 1.
		*/
		set ln.dist2nd.journal=0,ln.dist2nd=ln.schnd.oldVal
		set ln.dist2ld.journal=0,ln.dist2ld=ln.schld.oldVal
		set ln.dist3nd.journal=0,ln.dist3nd=ln.dist2nd.oldVal
		set ln.dist3ld.journal=0,ln.dist3ld=ln.dist2ld.oldVal
		set ln.dist4nd.journal=0,ln.dist4nd=ln.dist3nd.oldVal
		set ln.dist4ld.journal=0,ln.dist4ld=ln.dist3ld.oldVal
	
		set ln.dist2fre.journal=0,ln.dist2fre="*"
		set ln.dist3fre.journal=0,ln.dist3fre="*"
		set ln.dist4fre.journal=0,ln.dist4fre="*"
	
		/*
		Bump all values in LN.PMTDISTF.  Corresponding changes to LNBIL0 will
		occur in LNBIL0.
		*/
		set pmtdistf=ln.pmtdistf
		for N=1:1 set dist=$P(pmtdistf,"-",N) quit:dist=""  set $P(newdistf,"-",N)=dist+1
		set ln.pmtdistf.journal=0,ln.pmtdistf=newdistf
	
		/*
		Initialize ONP and AMBAS to 0.  Each payment schedule inserts will
		increment number of payments by 1.
		*/
		set ln.onp=0
		set ln.ambas=0
	
		}
	
	new DATA
	if ln.schseq'=0 do { quit:ER 
		new LBDD
		set LBDD=ln.lbdd
		if LBDD="" set LBDD=ln.schld
		if (ln.schnd.oldVal'=ln.schnd) do { quit:ER 
			if ln.schnd-ln.bloff<%SystemDate do Runtime.setErrSTBLER("LN","LNBLDDT2") quit:ER 
			set DATA=$$DIST1FRE^LNU(ln.dist1fre,ln.bloff,LBDD,ln.dist1nd,ln.schnd,ln.dist1ld) quit:ER 
			}
		else  set DATA=$$DIST1FRE^LNU(ln.dist1fre,ln.bloff,LBDD,ln.dist1nd,,ln.dist1ld) quit:ER 
		}
	
	if ln.schseq=0 do { quit:ER 
		set ln.schld=ln.amodt

		// Since before first scheduled bill, send in AMODT instead of LBDD
		set DATA=$$DIST1FRE^LNU(ln.dist1fre,ln.bloff,ln.amodt,ln.dist1nd,,ln.dist1ld) quit:ER 

		// Update date of first payment
		set ln.dfp=$P(DATA,"|",4)
		}
	
	if $P(DATA,"|",1)'=ln.dist1af set ln.dist1af=$P(DATA,"|",1)
	if $P(DATA,"|",2)'=ln.bndt set ln.bndt=$P(DATA,"|",2)
	if $P(DATA,"|",3)'=ln.schnd set ln.schnd=$P(DATA,"|",3)
	if $P(DATA,"|",4)'=ln.dist1nd set ln.dist1nd=$P(DATA,"|",4)
	if $P(DATA,"|",5)'=ln.dist1ld set ln.dist1ld=$P(DATA,"|",5)
	
	quit

vbu24 // Trigger BU_DIST2ND - Before Update - Distribution 2 Next Due

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History---------------------------------------------------

		07/09/02 - BECKERW - 49913
			Added code to verify that the secondary due dates do
			not precede the first payment due dates.
	 
							09/06/01 - OFALTR - 47394 Custom for RI/RollForward of ARQ 46575
															Created this Trigger to ensure that Int/Div Change - Next Date
															will be equal to Distribution 2 - Next Due, when a frequency of
															'*2' is being Processed.
	
	------------------------------------------------------------------------
	*/
	
	// WVB - 49913
	// Secondary due dates may not precede first payment due dates.
	if ln.dist2nd'="" if ln.dist2nd<ln.dist2nd.oldVal do SETERR^DBSEXECU("LN","ER","DUEDFP") quit:ER

	if ln.intfre'="*2" quit
	set ln.ichnd=ln.dist2nd
	quit

vbu25 // Trigger BU_DIST2_INFO - Before Update Of Distribution 2 Info

	type public RecordLN ln
	do ln.setAuditFlag(1)
	if ln.dist1fre="*" do { quit:ER 
		if ln.dist2fre'="",ln.dist2fre'="*" do { quit:ER 
			do PSREGF1^PROCLN(ln.dist2fre,ln.dist2nd,ln.mdt,2,.ln) quit:ER 
			set ln.dist2fre="*"
			}
		}
	quit 

vbu26 // Trigger BU_DIST3_INFO - Before Update Of Distribution 3 Info

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History---------------------------------------------------

		07/09/02 - BECKERW - 49913
			Added code to verify that the secondary due dates do
			not precede the first payment due dates.

	------------------------------------------------------------------------
	*/

	// WVB - 49913
	// Secondary due dates may not precede first payment due dates.
	if ln.dist3nd'="" if ln.dist3nd<ln.dist3nd.oldVal do SETERR^DBSEXECU("LN","ER","DUEDFP") quit:ER

	if ln.dist1fre="*" do { quit:ER 
		if ln.dist3fre'="",ln.dist3fre'="*" do { quit:ER 
			do PSREGF1^PROCLN(ln.dist3fre,ln.dist3nd,ln.mdt,3,.ln) quit:ER 
			set ln.dist3fre="*"
			}
		}
	quit 

vbu27 // Trigger BU_DIST4_INFO - Before Update of Distribution 4 Info

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History---------------------------------------------------

		07/09/02 - BECKERW - 49913
			Added code to verify that the secondary due dates do
			not precede the first payment due dates.

	------------------------------------------------------------------------
	*/

	// WVB - 49913
	// Secondary due dates may not precede first payment due dates.
	if ln.dist4nd'="" if ln.dist4nd<ln.dist4nd.oldVal do SETERR^DBSEXECU("LN","ER","DUEDFP") quit:ER

	if ln.dist1fre="*" do { quit:ER 
		if ln.dist4fre'="",ln.dist4fre'="*" do { quit:ER 
			do PSREGF1^PROCLN(ln.dist4fre,ln.dist4nd,ln.mdt,4,.ln) quit:ER 
			set ln.dist4fre="*"
			}
		}
	quit 

vbu28 // Trigger BU_DLCAF - Before update late charge assessment flg

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Set action date if flag gets set
	if ln.dlcaf,ln.lcad="" set ln.lcad.journal=0,ln.lcad=%SystemDate
	
	// Clear action date if flag gets removed
	if 'ln.dlcaf,ln.lcad'="" set ln.lcad.journal=0,ln.lcad=""
	quit
	

vbu29 // Trigger BU_EMPLBEN - Before Update of employer benefit flag

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------------

	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards.
	*/

	type public Boolean ER

	// Employer Code is required when Employer Benefit Plan is Yes
	if (ln.emplben=1) , (ln.emplno="") do Runtime.setErrXBAD("LN",198) quit:ER 
	
	type RecordPRODDFTL proddftl=Db.getRecord("PRODDFTL","TYPE=:ln.type")

	// Employer Benefit flag must be consistent with the Product Type
	if (proddftl.emplben=1) , (ln.emplben'=1) do Runtime.setErrMSG("LN",3639) quit:ER 

	quit 

vbu30 // Trigger BU_ICPA - Before update int calc principal adjmnts

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Determine new BALINT based on a change to ICPA
	NOTE:  Modifications to ICPA must be considered here and BALINT^UAVB
	If ICPA is set on then setting balint,data is modified
	to include CRLMT by adding . S data("CRLMT")=LN.CRLMT.M
	*/

								/*
								---- Revision History ------------------------------------------------
	04/10/03 - CARROLLJ - 51349
		   Modified the call to BALINT^LNFUNCS to only pass the ln 
		   object and removed the use of the data array.

								----------------------------------------------------------------------
								*/

	if ln.icpa'="" do {
		new balint
		set balint=$$BALINT^LNFUNCS(.ln)
		if ln.balint'=balint set ln.balint.journal=0,ln.balint=balint
		}
	quit

vbu31 // Trigger BU_ICPF - Before Update ICPF and DIST1AF

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Trace the changes to the LN.ICPF or LN.DIST1AF data items.  If the value of
	LN.ICPF changes and LN.APRMTDH is equal to 2 then the trigger will call
	LNAPR2 procedure to recalculate the APR.
	*/
	
	new EXIT 
	set EXIT=0
	if (ln.icpf.oldVal'=ln.icpf),(ln.aprmthd=2) do { quit:ER 
		new XDISAPR
		set XDISAPR=$$^LNAPR2(ln.irn,ln.icpf,ln.dist1af)
		set ln.disapr=XDISAPR
		set EXIT=1
		}
	
	if EXIT=1 quit 
	
	if (ln.dist1af.oldVal'=ln.dist1af),(ln.aprmthd=2) do { quit:ER 
		new XDISAPR
		set XDISAPR=$$^LNAPR2(ln.irn,ln.icpf,ln.dist1af)
		set ln.disapr=XDISAPR
		}
	
	quit

vbu32 // Trigger BU_INTINFO - Before update interest information

	type public RecordLN ln
	do ln.setAuditFlag(1)

	/*

	   IMPORTANT: Any changes made to this trigger should take into account
	   that it is accessed when the Back-dated Interest Rate Maintenance 
	   function (in PFW) is run, in which special processing takes place, 
	   based on %EffectiveDate (see call to EFDIRN^LNPTS2B call below).

	---- Revision History ------------------------------------------------
	
	10/30/06 - KELLYP - CR 23817
		   Modified to only set LN.INTOFFDT when LN.INTOFF is not null.
		   This prevents a problem where INTOFFDT was set when ICHND
		   was manually changed but INTOFF did not have a value, which 
		   led to problems on the next interest change date.
	
	04/15/05 - SmithCD - CR 15305
		   . Corrected defaulting of ln.ichnd
		   . Removed several parameters in the call to EFDIRN^LNPTS2B, 
		     which are no longer needed
		   . Cleaned up code to conform to current PSL standards
		   . Retrofitted the following change from p01:
		           07/10/03 - MALHOTRAV - CR4903
																			Added TREXD and TRATE to the column list that invokes this
																			trigger. This will prevent the user from making an effective
																			dated change to any of these columns and will return
																			appropriate error message.

	02/23/05 - KELLYP - CR 13662
		Changed %G reference to .get() to prevent an undefined error.
		Also removed pre-2003 revision history.

	01/28/04 - CARROLLJ - CR 7997
		Modified call to CTL^UINDX to pass correct parameters.

	*/
	
	type public Boolean ER

	// Set IRN/EIRN if SAN Processing
	if ln.iacf = 2 do { quit:ER
		if ln.irn.oldVal '= ln.irn do { quit:ER
			if ln.irn.isNull() set ln.irn = $$EIRN^PROCSAN(.ln, ln.eirn, ln.iacf, ln.dist1af)
			else  set ln.eirn = $$IRN^PROCSAN(.ln, ln.irn, ln.iacf, ln.dist1af)
			}
		if ln.eirn.oldVal '= ln.eirn do { quit:ER
			if ln.eirn.isNull() set ln.eirn = $$IRN^PROCSAN(.ln, ln.irn, ln.iacf, ln.dist1af)
			else  set ln.irn = $$EIRN^PROCSAN(.ln, ln.eirn, ln.iacf, ln.dist1af)
			}
		}

	if 'ln.intoff.isNull(), 'ln.index.isNull() do { quit:ER
		/* Default Next Interest Change Date - Interest offset 
		   processing

		   If Interest Change Frequency and payment frequency have not 
		   changed, do not change Interest Change Next Date
		*/
		if ln.intfre.oldVal = ln.intfre, ln.dist1fre.oldVal = ln.dist1fre quit

		type Date DT

		set DT = $$NXDT^BCHVRCHG(%SystemDate, ln.dist1nd, ln.intfre, ln.intoff) quit:ER
		set ln.ichnd = DT + ln.intoff
		}

	if ln.index.isNull() do { quit:ER
		// No index defined - clear interest-related fields
		set ln.ichnd = ""
		set ln.ichld = ""
		set ln.intmat = ""
		set ln.intspr = ""
		set ln.rndmtd = ""
		}
	else  if ln.ichnd.isNull(), 'ln.intfre.isNull() do { quit:ER
		// Default Next Interest Change Date - no Interest Offset 
		// processing
		type Date ICHND

		set ICHND = ln.odd
		for  set ICHND = ICHND.nextFreqDate(ln.intfre) quit:ICHND '< %SystemDate ! (ER)

		set ln.ichnd = ICHND
		}
 		
	if %EffectiveDate.get(), %EffectiveDate < %SystemDate do { quit:ER
		type String index
		type Number irn

		// Cannot use add-on/discount loans
		if ln.iam do Runtime.setErrMSG("LN", 481) quit

		// Account closed
		if ln.stat do Runtime.setErrMSG("LN", 55) quit

		// Must be the same as or after teaser rate expiration date 
		// of ~p1
		if %EffectiveDate < ln.trexd do Runtime.setErrMSG("LN", 1800, ln.trexd.toString()) quit

		// Must be the same as or after the disbursement date of ~p1
		if %EffectiveDate < ln.odd do Runtime.setErrMSG("LN", 1822, ln.odd.toString()) quit

		// Must be after the history purge date of ~p1
		if %EffectiveDate '> ln.hisctf do Runtime.setErrMSG("LN", 1801, ln.hisctf.toString()) quit

		do { quit:ER
			type Number BASEAMT, RATE, RRATE, SRATE, URATE

			// Reset the interest rate if the spread or rounding
			// method was changed
	
			if 'ln.index.isNull() do { quit:ER
				type String PAR()
				
				if 'ln.cntdr set BASEAMT = ln.amtreq
				else  set BASEAMT = ln.balint
				
				set PAR("RNDFC") = 1
				
				do CTL^UINDX(.ln, %EffectiveDate, BASEAMT, .PAR()) quit:ER
				set ln.irn = RATE
				}
	
			/*
			Call routine to calculate and post accrual adjustments 
			and return current irn, index, etc. values in ln object
			*/
			do EFDIRN^LNPTS2B(.ln) quit:ER
			}
		}

	/*
	Set Avg Int Recalc Flag if PCM interest component is 2 (Fixed Avg Int)
	whenever IRN is changed
	*/
	if (ln.irn.oldVal '= ln.irn), '(ln.air.oldVal '= ln.air), ln.air '= 1, ln.pcmval.extract(2) = 2 set ln.air = 1
	
	// Calculate interest change next and last dates if necessary
	if 'ln.index.isNull(), ln.index.oldVal.isNull(), 'ln.intfre.isNull() do { quit:ER
		type String CTL
		type Date ICHLD

		if ln.intoff > 0 set CTL=0
		else  set CTL = 1

		if ln.ichnd.isNull() set ln.ichnd = $$FRSTDATE^ACNFUNCS(%SystemDate, ln.intfre, CTL, ln.intoff, , , , ln.intoffcl) quit:ER

		if ln.ichld.isNull() do { quit:ER
			set ICHLD = ln.ichnd.nextFreqDate(ln.intfre, , 1) quit:ER
			if ICHLD '< ln.amodt set ln.ichld = ICHLD
			}
		}

	// Calculate interest change last date if NULL and ICHND is defined
	if ln.ichnd, ln.ichld.isNull() do { quit:ER
		type Date jd

		if ln.odd = %SystemDate set ln.ichld = ln.odd quit

		/*
		Int/Div Change - Last Date should not be prior to Original
		Disbursement Date and should not be in the future
		*/
		set jd = ln.ichnd
		for  set jd = jd.nextFreqDate(ln.intfre, , 1) quit:ER ! ((jd '> ln.odd) ! (jd < %SystemDate))
		if jd < ln.odd set ln.ichld = ln.odd
		else  set ln.ichld = jd
		}

	// Recalculate APR if IRN is changed
	if (ln.irn.oldVal '= ln.irn), (ln.aprmthd = 2) set ln.disapr = $$^LNAPR2(ln.irn, ln.icpf, ln.dist1af) quit:ER

	// If old interest change next date, move to new date updating ^PCBD 
	// global
	if (ln.ichnd.oldVal '= ln.ichnd) ! (ln.intoff.oldVal '= ln.intoff) do {
		if ln.ichnd.oldVal do {
			type Date ICHND
			type Number LNCID
			
			set ICHND = ln.ichnd.oldVal
			set LNCID = ln.cid
			
			do Db.delete("LNVRCHG", "ICHND=:ICHND AND CID=:LNCID")
			}
		// Calculate new value for Payment Change Analysis Offset Date
		set ln.intoffdt.journal = 0
		if 'ln.ichnd set ln.intoffdt = ""
		else  if 'ln.intoff.isNull() set ln.intoffdt = ln.ichnd - ln.intoff
		}
	
	// Change to column ~p1 not allowed
	if (ln.intoffdt.oldVal '= ln.intoffdt), ('ln.isChanged("INTOFFDT", "SYSTEM")) do Runtime.setErrMSG("LN", 412, "LN.INTOFFDT") quit:ER

	quit

vbu33 // Trigger BU_IPL - Before update interest paid life

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Add-on loans only
	if $E(ln.iam)=1 set ln.balint=ln.balint+(ln.ipl-ln.ipl.oldVal)
	quit
	

vbu34 // Trigger BU_IROPT - Before Update IROPT POPULATE DICO

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	----Revision History---------------------------------------------------
	09/24/99 - JERUCHIMC - 35021
		   Handle case of XIROPT=""
	

	Synchronize values between DICO & IROPT so that DICO might eventually be
	obsoleted.
	*/

	
	set XIROPT=ln.iropt
	set ln.dico.journal=0,ln.dico=$S(XIROPT="":"",XIROPT=0:"",XIROPT=1:"BL",XIROPT=2:"FR",XIROPT=3:"PC",XIROPT=4:"SP")
	quit
	

vbu35 // Trigger BU_IUN - Before update interest unearned (orig)

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Skip discount loans
	if $E(ln.iam)'=2 set ln.balint=ln.balint-(ln.iun-ln.iun.oldVal)
	quit
	

vbu36 // Trigger BU_MDT - Before Update Maturity Date.

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	--- Revision History --------------------------------------------------

	03/02/06 - TITOVE - CR 19733
		   Added quit for special fee type "*" and also a new
		   error message 7106.

	03/30/05 - KinI - 14385
		   Cleaned up to comply with DBI standards. 

	03/22/02 - PONGRACZD - 43877
		   Added Error Message Check for LN.PIACM and LN.PCM.  PIACM
		   can only be set to "Y" when the PCM contains a P&I element.

	06/10/99 - ALBINK - 33586
		   Modified code to determine if booking fees were already
		   filed for the account or the effective date.
	
	03/25/99 - KUCHEROVSKYA - 32401
		   Modified calls to DFP^PROCLN to use LN.TYPE and LN.CRCD as
		   parameters rather than TYPE and CRCD.
	
	01/22/99 - ALBINK - 30896
		   Added code to check the LNFEEP.AMTH rather than
		   LNFEEP.CFWA to determine if the fee is at booking.
	
	01/14/99 - MAGERAM - 30948
		   Added code to check for change in LN.DTNT to assess
		   booking fees.
	
	12/11/98 - ALBINK - 31114
		   Added code in order to assess and file booking fees on a
		   note date modification.
	*/

	type public Boolean ER
	type String PCMVAL	

	set PCMVAL=$$PCMVAL^LNCDI(ln.pcm)

	// PIACM only set to "Y" with a PCM containing a P&I element
	if (ln.piacm=1) , '(PCMVAL.extract(1)) do Runtime.setErrXBAD("LN","PIACM-PCM") quit:ER

	// Assess booking fees on note date modification 
	if (ln.dtnt.oldVal '= ln.dtnt) do { quit:ER 

 		type String XFEETYP

		type ResultSet rs=Db.select("FEETYP","LNFEE","CID=:ln.cid") quit:ER 
		
		while rs.next() do { quit:ER
			set XFEETYP=rs.getCol(1)

			// If fee on the account
			if 'XFEETYP.isNull(),(XFEETYP '= "*") do { quit

				type RecordLNFEE lnfee=Db.getRecord("LNFEE","CID=:ln.cid,FEETYP=:XFEETYP")				

				// If this is a linked fee quit - linked fees are not needed, only the primary fee should be used.
				if lnfee.lfee=1 quit 

				type RecordLNFEEP lnfeep=Db.getRecord("LNFEEP","FEETYP=:XFEETYP", 1)

				// Invalid fee plan ~p1
				if 'lnfeep.getMode() do Runtime.setErrMSG("LNFEEP",7106,XFEETYP) quit

				// If the assessment method is at booking
				if lnfeep.amth=0 do {
					// Booking fees already filed for ~p1
					if ln.dtnt < %SystemDate do Runtime.setErrMSG("LN",3469,ln.cid) quit:ER

					// Update Next Fee Assessment Date
					set lnfee.asnd=ln.dtnt
					do lnfee.save()

					}
				}
			}
		}
	
	if ln.mdt'="" quit

	// New method to calculate maturity date using tools in PROCLN.M,
	// which is the Loan Procedure.

	if ln.trm="" quit 
	
	// First, we need to calculate DFP (date of first payment)
	
	type Date DFP,LPD,ZAMODT
	set DFP=""

	set BLOFF=ln.bloff 
	set DIST1ND=ln.dist1nd
	set DFP=$$DFP^PROCLN(ln.type,ln.crcd,ln.odd,ln.dist1fre,DIST1ND,DFP,BLOFF)
	
	// Next, calculate LPD (last payment date)
	set LPD="" set ZAMODT=$$AMODT^PROCLN(ln.type,ln.crcd,ln.odd,ln.dist1fre,DFP,.LPD)
	
	// Finally, calculate maturity date
	set ln.mdt=$$MDT^PROCLN(ln.dtnt,ln.odd,,ln.trm,ln.busopt,ln.nbdc,LPD,PCMVAL,ln.dist1fre) quit:ER
	
	quit 

	

vbu37 // Trigger BU_MT900 - Before Update trigger for column MT900

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---------------Revision History---------------------------------------

	09/16/05 - KELLYP - CR 17050
		   Modified to fix several logic issues.  Also removed pre-
		   2003 revision history.
								*/

	type public Boolean ER

								if ln.mt900=1,ln.mt900a.isNull() do { quit:ER

		type RecordCIF cif=Db.getRecord("CIF","ACN=:ln.acn")
		
		// SWIFT Address must be defined
		if cif.swiftadd.isNull(),cif.mt900a.isNull() do Runtime.setErrMSG("LN","4029") quit:ER
		}

	quit

vbu38 // Trigger BU_MT910 - Before Update trigger for column MT910.

	type public RecordLN ln
	do ln.setAuditFlag(1)
								/*
								---------------Revision History---------------------------------------

	09/16/05 - KELLYP - CR 17050
		   Modified to fix several logic issues.  Also removed pre-
		   2003 revision history.
								*/

	type public Boolean ER

								if ln.mt910=1,ln.mt910a.isNull() do { quit:ER

		type RecordCIF cif=Db.getRecord("CIF","ACN=:ln.acn")
		
		// SWIFT Address must be defined
		if cif.swiftadd.isNull(),cif.mt910a.isNull() do Runtime.setErrMSG("LN","4029") quit:ER
		}

	quit

vbu39 // Trigger BU_NAI - Before Update of Non-Accrual Indicator

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------	
	
	06/05/06 - GIRIDHAL - CR 21207
	This trigger sets Non-Accrual placement date to systemdate when the 
	non accrual indicator is equal to 1.
								 
	----------------------------------------------------------------------
	*/
	type public Boolean ER

	// Future-dated request invalid
	if ln.naplmtdt > %SystemDate do Runtime.setErrMSG("LN",1152) quit:ER

	if ln.naplmtdt.oldVal = ln.naplmtdt,ln.nai = 1 set ln.naplmtdt = %SystemDate
	quit

vbu40 // Trigger BU_PAS_PAP - Before update payment string or path

	type public RecordLN ln
	do ln.setAuditFlag(1)
	;---- Revision History--------------------------------------------------------
	;
	; 01/28/04 - CARROLLJ - CR7997
 ;	      Modified call to LNCNVST to pass ln object.
	;
	; 3/21/2000 - VERTLIBA - 39649
	;             Corrected setting of ln.ppdcat3 that was missing and
	;             ln.ppdcat2 was used twice instead.
	;
	;-----------------------------------------------------------------------------
	// Calculate payment string information
	if ln.pas'="",ln.pap'="" do {
		new npc,pmtdist,pmtdistf,ppdcat
		set pmtdist=ln.pmtdist 
		set pmtdistf=ln.pmtdistf
		do ^LNCNVST(.ln,ln.cid,ln.pas,ln.pap,.pmtdist,.pmtdistf,.npc,.ppdcat) quit:ER 
		set ln.pmtdist.journal=0,ln.pmtdist=pmtdist 
		set ln.pmtdistf.journal=0,ln.pmtdistf=pmtdistf 
		set ln.npc.journal=0,ln.npc=npc
		set ln.ppdcat1.journal=0,ln.ppdcat1=ppdcat(1) 
		set ln.ppdcat2.journal=0,ln.ppdcat2=ppdcat(2)
		set ln.ppdcat3.journal=0,ln.ppdcat3=ppdcat(3)	;abv 
		set ln.ppdcat4.journal=0,ln.ppdcat4=ppdcat(4)
		set ln.ppdcat5.journal=0,ln.ppdcat5=ppdcat(5) 
		set ln.ppdcat6.journal=0,ln.ppdcat6=ppdcat(6)
		set ln.ppdcat7.journal=0,ln.ppdcat7=ppdcat(7) 
		set ln.ppdcat8.journal=0,ln.ppdcat8=ppdcat(8)
		set ln.ppdcat9.journal=0,ln.ppdcat9=ppdcat(9) 
		set ln.ppdcat10.journal=0,ln.ppdcat10=ppdcat(10)
		}
	quit

vbu41 // Trigger BU_PCFRE - Before update payment change frequency

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------
	
	11/17/00 - CHEUNGA - 42650
																			Added LN.INDEX'="" to prevent null subscript error
																			occurring when index is removed during Account
																			modification.
	
	07/21/99 - LAMY - 33254
		   The following code will make sure that PCHND is updated
		   when PCFRE is changed.
	*/

	
	if (ln.pcfre.oldVal'=ln.pcfre),(ln.dist1fre.oldVal'=ln.dist1fre),(ln.index'="") do {
		set FRE=ln.pcfre
		set D=$$NXDT^BCHVRCHG(%SystemDate,ln.dist1nd,ln.pcfre,ln.pcoff) 
		set JD=D+ln.pcoff
		set ln.pchnd=JD
		}
	quit

vbu42 // Trigger BU_PCHND_RAND - BU pmt or re-amort change next date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
								---------------- Revision History -----------------------
								08/08/01 - SANTOSL - 45848
																			Modified this section to verify if PCHND
																			and CID data item from LNPTCHG table is
																			defined to avoid message of "Record not
																			on file".
								----------------------------------------------------------
								*/
								// If old change date, move to new date
	if (ln.pchnd.oldVal'=ln.pchnd),ln.pchnd.oldVal do {
		new lnptchg
		type RecordLNPTCHG lnptchg=Class.new("RecordLNPTCHG")
																set PCHND=ln.pchnd
		set CID=ln.cid	
		if ln.pchnd="" do Db.delete("LNPTCHG","PCHND=:PCHND AND CID=:CID") quit
		if '(ln.pchnd&ln.piind) quit
		if Db.isDefined("LNPTCHG","PCHND,CID") do {
			set lnptchg=Db.getRecord("LNPTCHG","PCHND,CID")
		}
		set lnptchg.pchnd=ln.pchnd
	        set lnptchg.cid=CID
		do lnptchg.save()
		}
	
	// If old re-amortization date, move to new date
	if (ln.rand.oldVal'=ln.rand),ln.rand.oldVal do {
		new lnrachg
		set RAND=ln.rand.oldVal
		set CID=ln.cid
		if ln.rand="" do Db.delete("LNRACHG","RAND=:RAND AND CID=:CID") quit
		if '(ln.rand&ln.piind) quit
		type RecordLNRACHG lnrachg=Db.getRecord("LNRACHG","RAND,CID")
		set lnrachg.rand=ln.rand
		do lnrachg.save()
		}
	
	// Calculate new value for Payment Change Offset Date
	if (ln.pchnd.oldVal'=ln.pchnd)!(ln.pcoff.oldVal'=ln.pcoff) do {
		if 'ln.pchnd set ln.pcoffdt.journal=0,ln.pcoffdt=""
		else  set ln.pcoffdt.journal=0,ln.pcoffdt=ln.pchnd-ln.pcoff
		}
	
	// Calculate new value for Re-amortization Offset Date
	if (ln.rand.oldVal'=ln.rand)!(ln.pcoff.oldVal'=ln.pcoff) do {
		if 'ln.rand set ln.randoff.journal=0,ln.randoff=""
		else  set ln.randoff.journal=0,ln.randoff=ln.rand-ln.pcoff
		}
	quit

vbu43 // Trigger BU_PCOFFDT - Before update pmt change offset date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Revision History

	05/31/00 - CHOK - 40196
		   Converted isChanged method.
	*/

	// Only change by system allowed
	// Change to column ~p1 not allowed
	if 'ln.isChanged("PCOFFDT","SYSTEM") do Runtime.setErrMSG("LN",412,"LN.PCOFFDT") quit:ER 
	quit
	

vbu44 // Trigger BU_PMTDIST - Update PPDCAT*

	type public RecordLN ln
	do ln.setAuditFlag(1)
	;---- Revision History -----------------------------------------------
	;
	; 01/28/04 - CARROLLJ - CR7997
 ;	      Modified call to LNCNVST to pass ln object.
	;
	; 08/21/00 - AGARWALS - 41477
 ;	      Corrected code. Data items should be set from the local array
 ;	      after the LNCNVST call and not visa versa, as was mistakenly
 ;	      being done.
	;
	; 03/04/00 - RANALLIC - 36989
 ;	      Create Trgger BU_PMTDIST - Update PPDCAT* to update
 ;	      LN(65) when adding Escrow to an existing loan.
 ;	      When updating a loan in PFW for escrow LN(65)
 ;	      was not being updated.  Could not process a payment
 ;	      received a Timeout error.
	;
	;
	;
	;----------------------------------------------------------------------
	new npc,pmtdist,pmtdistf,ppdcat
	set pmtdist=ln.pmtdist,pmtdistf=ln.pmtdistf
	do ^LNCNVST(.ln,ln.cid,ln.pas,ln.pap,.pmtdist,.pmtdistf,.npc,.ppdcat) quit:ER
	set ln.pmtdist=pmtdist
	set ln.pmtdistf=pmtdistf
	set ln.npc=npc
	set ln.ppdcat1=ppdcat(1)
	set ln.ppdcat2=ppdcat(2)
	set ln.ppdcat3=ppdcat(3)
	set ln.ppdcat4=ppdcat(4)
	set ln.ppdcat5=ppdcat(5)
	set ln.ppdcat6=ppdcat(6)
	set ln.ppdcat7=ppdcat(7)
	set ln.ppdcat8=ppdcat(8)
	set ln.ppdcat9=ppdcat(9)
	set ln.ppdcat10=ppdcat(10)
	quit

vbu45 // Trigger BU_PMTGRC - Before update payment grace period

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History--------------------------------------------------------
	07/09/03 - CARROLLJ - 51349
		   Changed call to LNBLDB to call BCHLNBLDB because Routine LNBLDB was 
		   obsoleted.

	04/09/99 - SKLYUTD - 31585
		   Do not need to reset LCAD if PMTGRC is changed before first
		   payment date.
	*/

	// Reset LCAD if PMTGRC changes
	if (ln.pmtgrc'=""),(ln.bldt'<ln.dfp) do {
		new LCAD,lcefd
		set lcefd=ln.bldt+ln.bloff
		if ln.bloff="1P" set lcefd=$$NJD^UFRE(ln.bldt,ln.dist1fre) quit:ER
		do LCAD^BCHLNLD(lcefd,ln.lcbo,ln.pmtgrc,ln.dist1fre,1)
		if LCAD'>%SystemDate set LCAD=%SystemDate
		if ln.lcad'=LCAD set ln.lcad=LCAD
		}
	quit

vbu46 // Trigger BU_PMTPI_PMTTRS - Before update payment components

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	---- Revision History ---------------------------------------------------------
	
	09/07/00 - KELLYP - 41749:001
		   Fixed RECNOFL error that was occuring during escrow creation
		   with 'Db.isDefined on LNCPN.

 	08/28/00 - APPLEYARDM - 41624
		   Roll forward ARQ 39584: Modified trigger to update LNCPN.TPT
		   when escrow is added to account. This fixes problem where 
		   escrow amount was not being added to LNCPN.TPT when LN is 
		   created through PFW.

	*/

	// Set payment to include P&I plus escrow amount
	if ln.piind,ln.pmt'=ln.pmtpi+ln.pmttrs set ln.pmt=ln.pmtpi+ln.pmttrs

	// Update LNCPN if LN.PMT '= LNCPN.TPT

	new XPND,XPMET,XCID,XTPT
	set XPND=%SystemDate,XPMET=3,XCID=ln.cid
	
	if 'Db.isDefined("LNCPN","XPND,XPMET,XCID") quit

	new lncpn
	type RecordLNCPN lncpn
	set lncpn=Db.getRecord("LNCPN","PND=:XPND,PMET=:XPMET,CID=:XCID")

	if lncpn.tpt="" quit		//Nothing to update
	if lncpn.tpt=ln.pmt quit	//Updated already

	set XTPT=ln.pmttrs+ln.pmtpi	
	do Db.update("LNCPN","TPT=:XTPT","PND=:XPND AND PMET=:XPMET AND CID=:XCID")
	quit

vbu47 // Trigger BU_PPFREQ - Before update Prepmt Pen Determ Freq

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Prepayment Penalty processing
	if ln.ppfreq'="" do { quit:ER 
		if ln.ppld="",ln.dist1fre'="" set ln.ppld=$$NJD^UFRE(ln.dfp,ln.dist1fre) quit:ER 
		if ln.ppld'="" do {
			new NJD
			set NJD=$$NJD^UFRE(ln.ppld,ln.ppfreq) quit:ER 
			if NJD'=ln.ppnd set ln.ppnd=NJD
			}
		}
	quit

vbu48 // Trigger BU_PROV - Before update of Provision fields

	type public RecordLN ln
	do ln.setAuditFlag(1)
								/*
								---- Revision History ------------------------------------------------
	
								04/19/05 - TITOVE - CR 15089
																			Modified as part of DBI2 project.
	
								*/

	type public Number ER

	// Data required in Data Item ~p1
	if ln.racovr.isNull(),(ln.provoamt!(ln.provopct)) do Runtime.setErrMSG("LN",7531,"LN.RACOVR") quit:ER 

	// Ovr provision amount and ovr provision percentage not allowed
	if ln.provoamt,ln.provopct do Runtime.setErrMSG("LN",2759) quit:ER 

	quit
	

vbu49 // Trigger BU_RANDOFF - Before update re-amort offset date

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Revision History

	05/31/00 - CHOK - 40196
		   Converted isChanged method.
	*/

	// Only change by system allowed
	// Change to column ~p1 not allowed
	if 'ln.isChanged("RANDOFF","SYSTEM") do Runtime.setErrMSG("LN",412,"ln.randoff") quit:ER 
	quit
	

vbu50 // Trigger BU_RENCD_TRACN - Before update RENCD or TRACN

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/* 05/10/05 - Carol Scott - CR 15816
		Remove the crcd parameter from the call to LNFUNCS.
		It only requires the type parameter.
	*/
							 
								// Transfer account not allowed for this maturity option.
	if ln.tracn'="",ln.rencd=0!(ln.rencd=4) set ln.tracn=""

	// Maturity option requires Transfer Account.
	if ln.tracn="" do { quit:ER 
		if ln.rencd=1!(ln.rencd=2)!(ln.rencd=3) do Runtime.setErrXBAD("LN",110) quit 

		// Fixed Bullet Product Option Requires Transfer Acct
		if $$FBP^LNFUNCS(ln.type)=2 do Runtime.setErrXBAD("LN",154) quit:ER 
		}
	quit
	

vbu51 // Trigger BU_REVF_TDR - Before update rev flag or tot disb amt

	type public RecordLN ln
	do ln.setAuditFlag(1)
	// Must change revolving flag and credit limit seperately
	if (ln.revf.oldVal'=ln.revf),(ln.crlmt.oldVal'=ln.crlmt) do Runtime.setErrSTBLER("LN","REVCR") quit:ER 
	
	// Calculate new UDBAL value
	if 'ln.aruf do {
		if 'ln.revf set ln.udbal.journal=0,ln.udbal=ln.crlmt-ln.tdr
		else  set ln.udbal.journal=0,ln.udbal=ln.crlmt-ln.bal
		}
	quit
	

vbu52 // Trigger BU_SCHND - Before update trigger for LN.SCHND

	type public RecordLN ln
	do ln.setAuditFlag(1)
	new BNDT
	set BNDT=ln.schnd-ln.bloff
	if ln.bloff="1P" set BNDT=ln.schld
	set ln.bndt=BNDT
	quit
	

vbu53 // Trigger BU_SGNCRD - Set SGNCRDCHGDT when Sign Card Values Ch

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	09/28/01 - myersk - 47550 QAR 1
		   Created this trigger to correctly populate LN.SGNCRDCHGDT
	*/
								set ln.sgncrdchgdt=%SystemDate
	quit

vbu54 // Trigger BU_STAT - Before Update STAT

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	----Revision History ----------------------------------------------------
	
	05/16/06 - SmithCD - CR 20855
		   Modified "Deferred fee balance is equal to $~p1" error to 
		   report the amount.

	03/13/06 - KinI - CR 20021
		Modified to add the third parameter "1" when retrieving 
		LNCYCPTS record.

	03/09/06 - KELLYP - CR 19958
		Modified to remove the third parameter from the call to 
		REMOVE^PROCEFT.  Also removed pre-2003 revision history.
	
	08/25/05 - KELLYP - CR 16684
		Modified XCID reference in ln.stat=4 section to prevent an
		undefined error (should have been using ln.cid instead).
	
	08/02/05 - KUMARB - CR16684
		Modified the Check for open accounts linked to commitments
		to select from LN table.

	03/30/05 - KinI - 14385
		Cleaned up to comply with DBI standards. 
	*/
	
	type public Boolean ER=0
	
	if ln.stat=4 do { quit:ER
		
		// Account already closed
		if ln.stat.oldVal=4 do Runtime.setErrMSG("LN",51) quit 

		// Unable to close - balance = ~p1
		if $$^SCARND(ln.bal,0,"","",2) do Runtime.setErrMSG("LN",2784,ln.bal) quit 

		// Unable to close - accrual = ~p1
		if $$^SCARND(ln.acr,0,"","",2) do Runtime.setErrMSG("LN",2783,ln.acr) quit 
	
		// Loan-specific balance checks

		type String data,PTS
		type Number Z
	
		set Z=$$^SCARND(ln.lchg,0,ln.cid)
		// Late charge balance = $~p1
		if (Z) do Runtime.setErrMSG("LN",1595,Z) quit 
	
		set Z=$$^SCARND(ln.udbal,0,ln.cid)
		// Undisbursed balance = $~p1
		if (Z) , (ln.aruf) do Runtime.setErrMSG("LN",2813,Z) quit  
	
		set Z=$$^SCARND(ln.mcnd,0,ln.cid)
		// Miscellaneous charge balance = $~p1
		if (Z) do Runtime.setErrMSG("LN",1746,Z) quit  
	
		set Z=$$^SCARND(ln.iun-ln.ipl,0,ln.cid)
		// Uncollected interest balance = $~p1
		if (Z) , (ln.iam) do Runtime.setErrMSG("LN",2810,Z) quit   
	
		set Z=$$^SCARND(ln.crlmt)
		// Linked loan credit limit ~p1
		if (Z) , (ln.ccl) do Runtime.setErrMSG("LN",8243,Z) quit  
	
		set Z=$$^SCARND(ln.unapf,0,ln.cid)
		// Unapplied funds balance = ~p1
		if (Z) , (ln.ccl) do Runtime.setErrMSG("LN",2809,Z) quit   
	
		do { quit:ER 
			/*
			Check the value of [LN]TEB.  If it has a value then we 
			must reject so the user may close the escrow accounts.  
			If it is zero, then one of two conditions exist: 
			1) the escrow accounts are closed; or 
			2) the sum of the escrow account balances total zero.  
			Check each escrow.
			*/
			type String row
			type Number I

			// Escrow accounts have balances
			if $$^SCARND(ln.teb,0,ln.cid) do Runtime.setErrMSG("LN",1004) quit 
	
			type ResultSet rs=Db.select("PE01DA,PE02DA,PE03DA,PE04DA,PE05DA,PE06DA,PE07DA,PE08DA,PE09DA,PE10DA,PE11DA,PE12DA,PE13DA,PE14DA,PE15DA,PE16DA,PE17DA,PE18DA,PE19DA,PE20DA","LNBIL0","CID=:ln.cid") 
	    		if 'rs.next() quit
	    		set row = rs.getRow()

			for I = 1:1:20 set data = row.piece($C(9),I) if 'data.isNull() do { quit:ER 
				
				type Number ECID=data
				
				type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")

				// Escrow accounts have balances
				if $$^SCARND(dep.bal,0,2) do Runtime.setErrMSG("LN",1004) quit 

				// Close the escrow account if it is open
				if dep.stat'=4 set dep.stat=4 do dep.save() 
				}
			}
	
		// Check for open accounts linked to commitments
		type ResultSet rs=Db.select("STAT","LN","CCL=:ln.cid AND STAT=4")
		if 'rs.isEmpty() do Runtime.setErrMSG("LN",2786) quit:ER
	
		// Check for deferred interest
		set PTS="PTS"
		type RecordLNCYCPTS lncycpts=Db.getRecord("LNCYCPTS","CID=:ln.cid,TYP=:PTS",1)
		 
		set Z=(lncycpts.amt-lncycpts.caltd-lncycpts.npda).roundCur(ln.crcd)

		// Deferred fee balance is equal to $~p1
		if Z do Runtime.setErrMSG("LN",786,Z) quit 


		// Loan record is ok so update BAL,ACR and DTC
		set ln.bal.journal=0,ln.bal=0
		set ln.acr.journal=0,ln.acr=0
		if ln.dtc'=%SystemDate set ln.dtc=%SystemDate
		
		// Delete standing (collection/payment) orders upon loan payoff
		do REMOVE^PROCEFT(ln.cid,%SystemDate)
		}
		
	if ln.stat.oldVal=4 do {
	
		type String data
		
		if ln.dtc'="" set ln.dtc=""
		if ln.acs'=(%SystemDate-1) set ln.acs=%SystemDate-1

		// Update status of escrow accounts
		type ResultSet rs=Db.select("PE01DA,PE02DA,PE03DA,PE04DA,PE05DA,PE06DA,PE07DA,PE08DA,PE09DA,PE10DA,PE11DA,PE12DA,PE13DA,PE14DA,PE15DA,PE16DA,PE17DA,PE18DA,PE19DA,PE20DA","LNBIL0","CID=:ln.cid") 
		if 'rs.next() quit
	    	set row = rs.getRow()

		for I = 1:1:20 set data = row.piece($C(9),I) if 'data.isNull() do { quit:ER 
					
			type Number ECID=data	
			type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")					
			
			// Escrow accounts have balances
			// Open the escrow account if it is closed
			if dep.stat=4 set dep.stat=0 do dep.save()
			}
			
		if ER quit 
		
		// Interest change next date and last date
		if ln.intfre'="" do {					
			
			if ln.ichnd '< %SystemDate quit 
			
			type Date OV=ln.ichnd
			
			for  set OV=$$NJD^UFRE(OV,ln.intfre) quit:OV'<%SystemDate!(ER) 

			if 'ER , (ln.ichnd '= OV) set ln.ichnd=OV
			set OV=$$NJD^UFRE(OV,ln.intfre,,1)
			
			if 'ER , (ln.ichld '= OV) set ln.ichld=OV
			}
			
		if ER set ER=0      // Frequency error, allow integs to show it

		do LOAN^UOPEN(.ln)  // Re-Open an Account

		if ER quit 
				
		type Number XCID,XTKS
		type Date ARND
		type String FRE 
		
		set XCID=CID  // CID is returned by ^LNPTS called from ^UOPEN
	
		// Bring any tickler's with a frequency up to date
		type ResultSet rs=Db.select("TKS,ARND,ARF,EXPD","TIKLACN","CID=:XCID")
		if rs.isEmpty() quit
		while rs.next() do { 
			set ARND=rs.getCol(2)
			
			if ARND>%SystemDate quit 

			if ARND>rs.getCol(4) quit 

			set FRE=rs.getCol(3)
			set XTKS=rs.getCol(1)

			for  set ARND=$$NJD^UFRE(ARND,FRE) quit:ER!(ARND>%SystemDate) 
			if ER quit
			 
			type RecordTIKLACN tiklacn=Db.getRecord("TIKLACN","CID=:XCID,TKS=:XTKS",1)
			set tiklacn.arnd=ARND	      // Next Occurrence
			
			do tiklacn.save()	
			}
			
		if ER set ER=0                        // Frequency error
		}
		
	quit

vbu55 // Trigger BU_TOLCHK - Before Update Tolerance Check Trigger

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
   	 ---- Revision History--------------------------------------------------
	
 		03/31/05 - KinI - 14385
 			Added error message text comment.
	
		08/15/00 - ROYTENBERGE - 40990
			New trigger has been created to display an error 
			message when PAYTOL and PAYTOLP columns are populated 
			at the same time.
	*/

	// Cannot define a fixed tolerance and a tolerance percentage together
	if ln.paytol'="",ln.paytolp'="" do Runtime.setErrMSG("LN",4482) quit:ER

	quit

vbu56 // Trigger BU_TYPE - Before update type

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
								---- Revision History ------------------------------------------------
	
	03/30/05 - KinI - 14385
		   Modified to comply with DBI standards. 
	*/

	type public Boolean ER

	// Be sure new type is still loan class

	type RecordPRODDFTL proddftl=Db.getRecord("PRODDFTL","TYPE=:ln.type")

	// Product type is not defined for this currency
	if proddftl.cls="" do Runtime.setErrMSG("LN",2250) quit:ER 

	// Product class or group does not match product type
	if proddftl.cls'="L" do Runtime.setErrMSG("LN",8472) quit:ER 
	
	// If type changes, change group automatically, if appropriate
	if ln.grp'=proddftl.grp set ln.grp=proddftl.grp
	
	quit
	

vbu57 // Trigger BU_UDBAL - Before update unadvanced balance

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*
	Undisbursed balance cannot be file-maintained on loans using undisbursed
	processing
	*/
	if ln.aruf do Runtime.setErrSTBLER("LN","FMUDBAL") quit:ER 
	quit
	

vbu58 // Trigger BU_WDLMTP - Before Update Withdrawal Limit Process

	type public RecordLN ln
	do ln.setAuditFlag(1)
	/*-----Revision History--------------------------------------------
	12/15/00 - RAJARAMD - 42288
		   Modified trigger to add code if LN.PBLSTDT is not defined,
		   and if LN.PBFRE is defined , the current system processing
		   date (TJD) will be defaulted into the LN.PBLSTDT
		   Modified the trigger to add code if LN.ADJCOL is enabled ,
		   the LN.COLLIM will be recalculated as the sum of
		   LNCOL.PLDGAMT for all the loan collateral records securing
		   the loan.
		   Modified the trigger to add code if LN.COLLIMPR is enabled,
		   this trigger will default the lesser of the LN.CRLMT and
		   the LN.COLLIM into the LN.WDLMT.

	*/
	// Check for Loan Withdrawal Limit Processing
	if 'ln.revf,ln.wdlmtp,ln.wdlmt'="" set ln.wdlmt=ln.crlmt

	if ln.pbfre do {
		if ln.pblstdt="" set ln.pblstdt=%SystemDate
		if ln.pbnxtdt="" set ln.pbnxtdt=$$NJD^UFRE(ln.pblstdt,ln.pbfre) quit:ER
		}

	if ln.adjcol do { quit:ER
		new rs,xcollim,totamt,XCID
		set XCID=ln.cid
		set totamt=0
		type ResultSet rs=Db.select("PLDGAMT","LNCOL","CID=:XCID")
		if rs.isEmpty() quit
		while rs.next() do {
				set xcollim=rs.getCol(1)
				set totamt=totamt+xcollim
				}
		set ln.collim=totamt
		}

	if ln.collimpr do { quit:ER
		if (ln.crlmt<ln.collim) set ln.wdlmt=ln.crlmt
		else  set ln.wdlmt=ln.collim
		}
	quit
