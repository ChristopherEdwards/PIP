LNPDS	//PAYMENT DUE STATUS MAINTENANCE
	/*

	---- Revision History ------------------------------------------------
	05/19/06 - GIRIDHAL - CR 21367
		   Modified FILE section to set mode to zero for LNPDS2 before
		   calling bypassSave() so that an Insert is issued instead of
		   an Update.
		   
	03/31/06 - KELLYP - CR 20516
		   Modified VARB section to sort LNPDS2 records numerically by 
		   UPLIMIT by using an intermediate array.  This prevents the
		   LNPDS2 records from being sorted in ASCII order by UPLIMIT
		   in Oracle environments.

	01/12/06 - KELLYP - CR 18983
		   Modified FILE section to $O through the fLNPDS2 array
		   instead of looping through 12 nodes of it.  This prevents
		   an undefined error from occurring because the screen
		   driver is now responsible for cleaning up any unused 
		   object array nodes.  Also removed pre-2003 revision history.

	06/25/04 - RussellDS - CR 8465
		   Correct PSL compile errors.  Modified to eliminate use
		   of deleted dummy table LNPDS1.
	 
	----------------------------------------------------------------------
	*/

	quit

CREATE	//
        do INIT(0)
        quit


UPD 	//
	do INIT(1)
	quit


INQ 	//
	do INIT(2)
	quit


DEL 	//
	do INIT(3)
	quit


INIT(%ProcessMode)	//

	type Number %PAGE,%PG
	type String TABLE,VFMQ

	set %PG=0
	set TABLE=""
	set %PAGE=$S(%ProcessMode<2:2,1:1)
	type RecordLNPDS fLNPDS
	type RecordLNPDS2 fLNPDS2()
	
	do VPG(.fLNPDS,.fLNPDS2())

	quit


VPG(RecordLNPDS fLNPDS,RecordLNPDS2 fLNPDS2())	// Page control

	type Public Number %PG
	type Public String VFMQ

	type Boolean FINISH = 0

        for  do { quit:FINISH
                if %PG=0 do VPG00(.fLNPDS) if VFMQ="Q" set FINISH=1 quit
		if "DFQ"[VFMQ do VER(.fLNPDS,.fLNPDS2()) set FINISH=1 quit
		if %PG>1 do VPG02(.fLNPDS,.fLNPDS2()) if VFMQ="Q" set FINISH=1 quit
		if "DFQ"[VFMQ do VER(.fLNPDS,.fLNPDS2()) set FINISH=1 quit
		if %PG>0,%ProcessMode=3 do VPG02(.fLNPDS,.fLNPDS2()) if VFMQ="Q" set FINISH=1 quit
		if "DFQ"[VFMQ do VER(.fLNPDS,.fLNPDS2()) set FINISH=1 quit
                if %PG>0 do VPG01(.fLNPDS,.fLNPDS2()) if VFMQ="Q" set FINISH=1 quit
                if "DFQ"[VFMQ do VER(.fLNPDS,.fLNPDS2()) set FINISH=1 quit
                set %PG=%PG+1
                }

	quit


VPG00(RecordLNPDS fLNPDS)	// Set up

	type Public Number CNT
	type Public String ER,IO,TABLE,VFMQ
	
	type Number CMODE = %ProcessMode
	type String %READ,%TAB()

	set %TAB("TABLE")=".TABLE1/TBL=[LNPDS]/XPP=D TPP^LNPDS"
	if %ProcessMode=2 set %TAB("IO")=$$IO^SCATAB($I)

	set %READ="@@%FN,,,TABLE/REQ"
	if %ProcessMode=2 set %READ=%READ_",IO/REQ"

	do ^UTLREAD

	if VFMQ="Q" quit

	if %ProcessMode=2,IO'=$I do OPEN^SCAIO

	if ER quit

	set fLNPDS=Db.getRecord("LNPDS","TABLE=:TABLE",1)

	set CNT=$S(fLNPDS.getMode():fLNPDS.ct,1:"*")

	if %ProcessMode=3 do {
		set ER=0
		do DELCHK
		}
	quit


VPG01(RecordLNPDS fLNPDS,RecordLNPDS2 fLNPDS2())	// Prompt for description, start, and end dates

	if %ProcessMode=4!(%ProcessMode=2) do {
		
		type Number %NOUL = 1
		
		do VARB(.fLNPDS2())

		do DRV^USID(%ProcessMode,"LNPDSB",.fLNPDS2(),.fLNPDS)
		}

	else  do DRV^USID(%ProcessMode,"LNPDSA",.fLNPDS)

	quit


VPG02(RecordLNPDS fLNPDS,RecordLNPDS2 fLNPDS2())	// Prompt for upper limit and description

	type Public Number CNT
	type Public String ER

	if %ProcessMode,CNT do {
		// may not modify used table
		type String ET = "INVLDOPT"
		set ER=1
		do ERR
		}
		
	else  do {
		do VARB(.fLNPDS2())
		do DRV^USID(%ProcessMode,"LNPDSB",.fLNPDS2(),.fLNPDS)
	}
	
	quit


ERR	//
	type Public String ER = 1
	type Public String VFMQ

	do DSPBP^UTLERR

	set VFMQ="Q"
	
	quit


VER(RecordLNPDS fLNPDS,RecordLNPDS2 fLNPDS2()) 	//

	type Public String VFMQ

	if %ProcessMode=2!(%ProcessMode=4)!(VFMQ="Q") do END quit

	do FILE(.fLNPDS,.fLNPDS2())

	do END
	quit


FILE(RecordLNPDS fLNPDS,RecordLNPDS2 fLNPDS2())	// File data

	type public Number CNT
	type public String TABLE
	
	type Number I

	if %ProcessMode=3 do { quit

		do Db.delete("LNPDS","TABLE=:TABLE")
		do Db.delete("LNPDS2","TABLE=:TABLE")
		}

	if CNT="*" set CNT=0

	set fLNPDS.ct=CNT
	do fLNPDS.bypassSave()

	do Db.delete("LNPDS2","TABLE=:TABLE")
	
	set I=""
	for  set I=fLNPDS2(I).order() quit:I.isNull()  do {
		set fLNPDS2(I).table=TABLE
		do fLNPDS2(I).setMode(0)
		do fLNPDS2(I).bypassSave()
		}

	quit


END	//

	type Public String ER,RM,TABLE,VFMQ

	if ER!(%ProcessMode=2)!(%ProcessMode=4) quit

	if VFMQ="Q" do {

		// Table ~p1 not created
		if %ProcessMode=0 set RM=$$^MSG(2593,TABLE.get()) quit

		// Table ~p1 not modified
		if %ProcessMode=1 set RM=$$^MSG(2596,TABLE.get()) quit

		// Table ~p1 not deleted
		set RM=$$^MSG(2595,TABLE.get())
		}
		
	else  do {

		// Table ~p1 created
		if %ProcessMode=0 set RM=$$^MSG(2590,TABLE.get()) quit

		// Table ~p1 modified
		if %ProcessMode=1 set RM=$$^MSG(2592,TABLE.get()) quit

		// Table ~p1 deleted
		set RM=$$^MSG(2591,TABLE.get())
		}

	set ER="W"
	
	quit


VARB(RecordLNPDS2 fLNPDS2())	// init variables for screen LNPDSB

	type public Number %REPEAT = 12
	type public String TABLE

	type Number I,UPLIMIT
	type String TMPARR()

	type ResultSet rs=Db.select("UPLIMIT","LNPDS2","TABLE=:TABLE")
	while rs.next() do {
		set UPLIMIT=rs.getCol("UPLIMIT")
		set TMPARR(UPLIMIT)=""
		}

	set I=0
	set UPLIMIT=""
	
	for  set UPLIMIT=TMPARR(UPLIMIT).order() quit:UPLIMIT.isNull()  do {
		set I=I+1
		set fLNPDS2(I)=Db.getRecord("LNPDS2","TABLE=:TABLE,UPLIMIT=:UPLIMIT")
		}

	for I=I+1:1:%REPEAT set fLNPDS2(I)=Class.new("RecordLNPDS2")

	quit


DELCHK	// Check if table is in use - if so can't delete

	type Public Number CNT
	type Public String ER

	if CNT do {
		// table in use
		type String ET = "INVLDOPT"
		set ER=1
		do ERR
		}
	quit


TPP	// Post processor for TABLE

	type Public Number CMODE
	type Public String I(),X
	
	quit:X.isNull()

	if CMODE=0 do {
		set I(3)=""
		if Db.isDefined("LNPDS","TABLE=:X") do {
			// Currently on file
			type String ET = "LNONFIL"
			do ERR
		}
	}
	
	quit

vSIG()	quit "60404^49835^Lakshmi Giridharan^5619"	// Signature - LTD^TIME^USER^SIZE
