PROCEFT		/*
	---- Revision History -------------------------------------------------
	
	10/05/06 - NATRAJAH - CR22505
		   The PAYMET section is added to return a valid payment 
		   method when creating an EFT order.
		   
	03/09/06 - KELLYP - CR 19958
		   Removed third "FILE" parameter from REMOVE section and 
		   removed code that conditionally set up a SQL FSN array
		   for deleting EFT records.  FSN's aren't used anymore so
		   we just do the deletes here (same as old processing when
		   FILE=1).
	
	11/23/05 - SAHOOU - CR17050
		   Modified DATCHK section by removing the Resultset declaration
		   "type ResultSet rs" from the top and putting this in the do 
		   block in place of "set rs".
		   		   
	11/16/05 - SAHOOU - CR17050
		   Modified NOSCHECK section by replacing Db.getRecord(,,1) in
		   place of Db.isDefined().
		   
	11/11/05 - SAHOOU - CR17050
		   Modified DATIP section by removing the Resultset declaration
		   "type ResultSet rs" from the top and putting this in the do 
		   block in place of "set rs".   

	10/21/05 - chhabris - CR16677
		   Added comment for Error 7617 in NOSCHECK section.
	
	09/10/05 - chhabris - CR16677
		   Added comment for the Error message 7560 in the NOSCHECK 
		   section.

	09/10/05 - chhabris - CR16677
		   Modified REMOVE section to remove the creation of FSN array 
		   and save the object using object.save() as CRT4.m is obsoleted
		   for DBI version which was used to update the accounts using the
		   SQL() array.
		   Also included the changes for Pat Kelly in NOSCHECK section.
		   Modified the check for the existence of the record for XVOSTRO
		   file to DEP file.

	09/07/05 - KELLYP - CR 17118
		   Modified MT103CHK section to remove references to the MT100 
		   message which has been obsoleted by SWIFT.  Also replaced
		   CUVAR DB retrievals with direct CUVAR references and 
		   removed pre-2003 revision history.  Also removed references
		   to EFTPAY.MT103SCR which is also being obsoleted.

	10/03/03 - CARROLLJ - 51630
		   Removed sections XCRCDIP,XNOSCHECK, and XNOSIP.  The screens
		   that call these linetags will be obsolete.  Also removed old
		   revision history.

	----------------------------------------------------------------------
	*/

	quit


public DICHECK(RecordEFTPAY eftpay)	//Public;Edit check fields for format

	/*
	This function replicates the edit checks which are part of the standard
	character based screens (INTPAYBR10,INTPAYBR20,INTPAYHQ10,INTPAYHQ20,
	INTPAYHQ30,INTRECHQ10,INTRECHQ20)
	
	KEYWORDS:
	
	RETURNS:
		. ER,verrors,RM   /TYP=T
	EXAMPLE:
	*/
	if eftpay.efttype'="NDPO" quit
	do CHECK(eftpay.benacn) quit:ER 
	do CHECK(eftpay.benad1) quit:ER 
	do CHECK(eftpay.benad2) quit:ER 
	do CHECK(eftpay.benad3) quit:ER 
	do CHECK(eftpay.benad4) quit:ER 
	do CHECK(eftpay.beninst) quit:ER 
	do CHECK(eftpay.beninstl) quit:ER		// PK 36094
	do CHECK(eftpay.beninst1) quit:ER 		
	do CHECK(eftpay.beninst2) quit:ER 
	do CHECK(eftpay.beninst3) quit:ER 
	do CHECK(eftpay.beninst4) quit:ER 
	do CHECK(eftpay.msg1) quit:ER 
	do CHECK(eftpay.msg2) quit:ER 
	do CHECK(eftpay.msg3) quit:ER 
	do CHECK(eftpay.msg4) quit:ER 
	do CHECK(eftpay.ord2) quit:ER 
	do CHECK(eftpay.ord3) quit:ER 
	do CHECK(eftpay.ord4) quit:ER 
	do CHECK(eftpay.ordinst) quit:ER 
	do CHECK(eftpay.ordinst1) quit:ER 
	do CHECK(eftpay.ordinst2) quit:ER 
	do CHECK(eftpay.ordinst3) quit:ER 
	do CHECK(eftpay.ordinst4) quit:ER 
	if eftpay.mt103flg do MT103CHK(.eftpay) quit:ER  ; 40847
	quit 


CHECK(X)	//


	if X'="" do CHECK^SWFTEDIT(X,.SWFTCHAR)
	if ER do Runtime.setErrMSG("EFTPAY",3333,"RM") quit:ER 
	quit 

MT103CHK(RecordEFTPAY eftpay)	// Performs SWIFT interfield validation testing for MT103s

	// Rules for Bank Operation Code
	new BANKOPT,BNKFLG
	set BANKOPT=eftpay.bankop
	if (BANKOPT="SSTD")!(BANKOPT="SPAY")!(BANKOPT="SPRI") set BNKFLG=1
	else  set BNKFLG=0
 	if (BANKOPT="SPRI")&((eftpay.inter'="")!(eftpay.inter'="")) do Runtime.setErrMSG("EFTPAY",4616,"BANKOPT~56") quit:ER
 	if (BNKFLG)&(eftpay.recacct'="") do Runtime.setErrMSG("EFTPAY",4617,"BANKOPT~54~A") quit:ER
	if (BNKFLG)&(eftpay.triadd1'="") do Runtime.setErrMSG("EFTPAY",4617,"BANKOPT~55~A") quit:ER	
	if (BNKFLG)&(eftpay.benacn="") do Runtime.setErrMSG("EFTPAY",4618,BANKOPT) quit:ER
	
	// Field 57 mandatory if field 56 is present
	new BENFLG
	if (eftpay.beninst="")&(eftpay.beninstl="")&(eftpay.beninst1="") set BENFLG=1
	else  set BENFLG=0
	if ((eftpay.inter'="")!(eftpay.inter1'=""))&(BENFLG) do Runtime.setErrMSG("EFTPAY",4620,"57~56") quit:ER

	// Tests for 23E (Instruction Codes) and 77T (Extended Remittance)
	new BENACN,EXTR,INSTR
	set INSTR=eftpay.instcd
	set BENACN=eftpay.benacn
	if INSTR="" set INSTR=$G(EFT23E)
	if INSTR'="" do { quit:ER
		// Instruction Codes not permitted if EFTPAY.BANKOP=SSTD or SPAY
		if (BANKOPT="SSTD")!(BANKOPT="SPAY") do Runtime.setErrMSG("EFTPAY",4616,"BANKOPT~23E") quit:ER

		new CODES,I,INSARR
		set CODES=""
		for I=1:1 quit:$P(INSTR,$C(13,10),I)=""  do { quit:ER

			new ADDINF,CD,D,DISALLOW,J,SWDATA
			set CD=$E($P(INSTR,$C(13,10),I),1,4)
			set SWDATA=Db.getOneRow("ADDINFO,DISALLOW","STBLSWINSTR","CD")

			set ADDINF=$E($P(INSTR,$C(13,10),I),5,999)
			if (ADDINF'=""),($P(SWDATA,$C(9),1)'=1) do Runtime.setErrMSG("EFTPAY",4614) quit:ER

			// Only Instruction Codes SDVA, TELB, PHOB, and INTC permitted
			if (eftpay.bankop="SPRI")&((CD'="SDVA")!(CD'="TELB")!(CD'="PHOB")!(CD'="INTC")) do Runtime.setErrMSG("EFTPAY",4615) quit:ER

			// Field 59 account subfield must not be present if Instruction code=CHQB
			if (eftpay.benacn'="")&(CD="CHQB") do Runtime.setErrMSG("EFTPAY",4619) quit:ER

			// If field 56A is not present, field 23E may not contain TELI or PHOI
			new field1,field2,txt1,txt2
			if (eftpay.inter="")&((CD="TELI")!(CD="PHOI")) do Runtime.setErrMSG("EFTPAY",5081,"56A~23E~TELI~PHOI") quit:ER

			// If field 57A is not present, field 23E may not contain TELE or PHON
			if (eftpay.beninst="")&((CD="TELE")!(CD="PHON")) do Runtime.setErrMSG("EFTPAY",5081,"57A~23E~TELE~PHON") quit:ER

			// Instruction codes must not be repeated
			if CODES[(CD_",") do Runtime.setErrMSG("EFTPAY",5080) quit:ER
			set CODES=CODES_CD_","

			set DISALLOW=$P(SWDATA,$C(9),2)
			// Illegal combination of Instruction codes: ~p1 and ~p2
			for J=1:1 set D=$P(CODES,",",J) quit:D=""  if DISALLOW[(D_",") do Runtime.setErrMSG("EFTPAY",5079,"D~CD") quit:ER
			}
		}

	new MSG1FLG
	if (eftpay.msg1'="")!(eftpay.msg2'="")!(eftpay.msg3'="")!(eftpay.msg4'="") set MSG1FLG=1
	else  set MSG1FLG=0
	set EXTR=eftpay.extrem
	if EXTR="" set EXTR=$G(EFT77T)	// SWFREE record doesn't exist during create yet
	if (EXTR'="") do {  quit:ER
		if 'CUVAR.extrem do Runtime.setErrMSG("EFTPAY",4612) quit:ER
		if MSG1FLG do Runtime.setErrMSG("EFTPAY",4621,"77T~70") quit:ER
		}
	
	quit

Public ACNIP(XACN,RecordEFTPAY eftpay)	//

	/* 
	Copy of processor EFT_ACN_IP. This code is called to default the values
	of ORD1,ORD2,ORD3,ORD4 from the CIF record. This is called for outgoing
	foreign payments and Standing Foreign payments.
	*/

	new ADDREC,CUSTNAM,TMP

	if XACN="" quit
	
	do eftpay.setAuditFlag(1)
	if eftpay.ord1'="",eftpay.ord2'="",eftpay.ord3'="" quit
	set ADDREC=Db.getOneRow("NAM,MCITY,MSTATE,MZIP,MCNTRY,MAD1,MAD2,MAD3","CIF","XACN")
	if eftpay.ord1="" set eftpay.ord1=$E($P(ADDREC,$C(9),1),1,35)
	if eftpay.ord2="" set eftpay.ord2=$E($P(ADDREC,$C(9),6),1,35)
	if eftpay.ord3="" set eftpay.ord3=$E($P(ADDREC,$C(9),7),1,35)
	if eftpay.ord4="" do {
		set TMP=""
		if $P(ADDREC,$C(9),2)'="" set TMP=$P(ADDREC,$C(9),2)
		if $P(ADDREC,$C(9),3)'="" set TMP=TMP_", "_$P(ADDREC,$C(9),3)
		if $P(ADDREC,$C(9),4)'="",$P(ADDREC,$C(9),4)'=" " set TMP=TMP_", "_$P(ADDREC,$C(9),4)
		if $P(ADDREC,$C(9),5)'="" set TMP=TMP_", "_$P(ADDREC,$C(9),5)
		set eftpay.ord4=TMP
		}
	
	if eftpay.ord3="" do {
		set eftpay.ord3=eftpay.ord4
		set eftpay.ord4=""
		}
	
	do CHECK(eftpay.ord1) quit:ER 
	do CHECK(eftpay.ord2) quit:ER 
	do CHECK(eftpay.ord3) quit:ER 
	do CHECK(eftpay.ord4) quit:ER 
	
	quit 
	
	
Public AMTTYP(AMTTYP,XCID,STBLEFT,TTYPE)
	/*
	 Check for valid Amount Type

	 ARGUMENTS:
		. AMTTYP	Amount Type
		. XCID		Account Number
		. STBLEFT	System EFT Type
		. TTYPE		Transaction Type
	*/

	new DESC

	// Amount Type 1 should always be valid for all types
	if AMTTYP=1 quit

	// Invalid table value ~p1
	if 'Db.isDefined("STBLAMTTYP","AMTTYP") do Runtime.setErrMSG("EFTPAY",1485,"AMTTYP") quit

	type RecordSTBLAMTTYP amttyp=Db.getRecord("STBLAMTTYP","AMTTYP")
	set DESC=amttyp.desc

	// Amount Type ~p1 (~p2) not valid for Account Type
	if TTYPE>1,AMTTYP>1 do Runtime.setErrMSG("EFTPAY",5205,"AMTTYP~DESC") quit:ER

	type RecordACN acn=Db.getRecord("ACN","XCID")

	// Amount Type 18, Max. Periodic W/Amt., segmented deposit accounts only
	if AMTTYP=18 do { quit
		// Amount Type 18 applies only to segmented deposit accounts
		if acn.cls'="D" do Runtime.setErrMSG("EFTPAY",3336,"RM") quit:ER
		type RecordDEP dep=Db.getRecord("DEP","XCID")
		if dep.segflg'=1 do Runtime.setErrMSG("EFTPAY",3336,"RM") quit:ER
	}

	// Check for valid Amount Types based on Account Type and EFT Type

	// Amount Type ~p1 (~p2) not valid for Account Type
	if acn.cls="D",amttyp.acctopt=2 do Runtime.setErrMSG("EFTPAY",5205,"AMTTYP~DESC") quit:ER
	if acn.cls="L",amttyp.acctopt=1 do Runtime.setErrMSG("EFTPAY",5205,"AMTTYP~DESC") quit:ER

	// Amount Type ~p1 (~p2) not valid for Payment Type
	if STBLEFT["PO",amttyp.efttopt=2 do Runtime.setErrMSG("EFTPAY",5206,"AMTTYP~DESC") quit:ER
	if STBLEFT["CO",amttyp.efttopt=1 do Runtime.setErrMSG("EFTPAY",5206,"AMTTYP~DESC") quit:ER

	quit


Public BENINST(BENINST,RecordEFTPAY eftpay)

	if eftpay.mt103flg quit

	if (BENINST'="")!(eftpay.beninstl'="") quit

	new BEN
	set BEN="BENINST1"
	if eftpay.beninst1="" do Runtime.setErrMSG("EFTPAY",2103) quit:ER 
	set BEN="BENINST2"
	if eftpay.beninst2="" do Runtime.setErrMSG("EFTPAY",2103) quit:ER 

	quit 



Public BENIP(XACN,RecordEFTPAY eftpay)	

	/*          
	Beneficiary processor to default beneficiary address information
	for all non-outgoing EFT types. This processor replicates
	library processors :EFT_BEN_IP and EFT_BENACN.
	*/

	do eftpay.setAuditFlag(1)
	if XACN="" quit 
	new data,TMP
	set data=Db.getOneRow("NAM,MAD1,MAD2,MCITY,MSTATE,MZIP,MCNTRY","CIF","XACN")
	set eftpay.benad1=$E($P(data,$C(9),1),1,35)
	set eftpay.benad2=$E($P(data,$C(9),2),1,35)
	set eftpay.benad3=$E($P(data,$C(9),3),1,35)
	if eftpay.benad4="" do {
		set TMP=""
		if $P(data,$C(9),4)'="" set TMP=$P(data,$C(9),4)
		if $P(data,$C(9),5)'="" set TMP=TMP_$E($P(data,$C(9),5),1,35)
		if $P(data,$C(9),6)'="",$P(data,$C(9),6)'=" " set TMP=TMP_","_$P(data,$C(9),6)
		if $P(data,$C(9),7)'="",$P(data,$C(9),7)'=" " set TMP=TMP_","_$P(data,$C(9),7)
		set eftpay.benad4=TMP
		}
	
	if eftpay.benad3="" do {
		set eftpay.benad3=eftpay.benad4
		set eftpay.benad4=""
		}
	
	do CHECK(eftpay.benad1) quit:ER 
	do CHECK(eftpay.benad2) quit:ER 
	do CHECK(eftpay.benad3) quit:ER 
	do CHECK(eftpay.benad4) quit:ER 
	quit 


Public CALCANT(RecordEFTPAY eftpay)	// Calculate anticipated amounts and set these values into the system


	do eftpay.setAuditFlag(1)

	new AAMT,ACNF,AFEE,AHLD,ARTE,BALAVL,CNVAMT,CNVCRCD,DIFF,FEEAMT
	new FEECRCD,HCID,HSEQ

	// Calculate fees and anticipated amounts associated with incoming and
	// outgoing foreign payments (XEFTFCALC uses EFTPAY short name array)
	do ^EFTFCALC(.eftpay,.FEEAMT,.FEECRCD,.CNVAMT,.CNVCRCD,.AAMT,.ARTE,.AFEE,.ACNF,.AHLD)
	if ER do Runtime.setErrMSG("EFTPAY",3333,"RM") quit:ER 

	set eftpay.feecrcd=FEECRCD
	set eftpay.feeamt=$$^SCARND(FEEAMT,0,"",FEECRCD)
	set eftpay.feecrcd2=CNVCRCD
	set eftpay.feeamt2=$$^SCARND(CNVAMT,0,"",CNVCRCD)
	set eftpay.antfee1=AFEE
	set eftpay.antfee2=ACNF
	set eftpay.addhld=AHLD
	set eftpay.antamt=AAMT
	set eftpay.antrate=ARTE
	
	// Incoming payments have fees subtracted from the total
	if eftpay.efttype="NDPOIN" set eftpay.anttotal=eftpay.antamt-eftpay.antfee1-eftpay.antfee2
	
	// Outgoing payments have fees added to the hold total
	else  if eftpay.efttype="NDPO" do { quit:ER
		set eftpay.anttotal=eftpay.antfee1+eftpay.antfee2+eftpay.addhld

		// Do not validate against available balance for GLs
		if eftpay.ttype'<2 quit

		// Determine account's available balance
		set BALAVL=$$TOTBALAVL^EFTFUNCS(eftpay.cid)

		// Add any holds placed for the current payment to the available balance
		type ResultSet rs=Db.select("HCID,HSEQ","EFTHLD","CID=:CID AND SEQ=:SEQ") 
		if 'rs.isEmpty() while rs.next() do {
			set HCID=rs.getCol(1)
			set HSEQ=rs.getCol(2)
			set BALAVL=BALAVL+Db.getOneRow("AMT","PHLD","HCID,HSEQ")
			}
	
		// Compare anticipated total to the available balance
		// Amount exceeds total available balance of ~p1 by ~p2
		set DIFF=BALAVL-eftpay.anttotal
		if eftpay.anttotal>BALAVL do Runtime.setErrMSG("EFTPAY",7656,"BALAVL~DIFF") quit:ER
		}
	if ER do Runtime.setErrMSG("EFTPAY",3333,"RM") quit:ER 
	
	quit 
	
	
Public CRCD(XCRCD,RecordEFTPAY eftpay)	//
	
	/*
	This processor is a copy of processor library utility EFT_CRCD. It is
	called for electonic payments which are not incoming or outgoing foreign
	payments. This is a post processor for the CRCD field.
	*/
	
	if XCRCD="" quit

	new fconv,fcurr,rconv,rcurr,CCACC,ONUS,RECINST,STBLEFT,XCID,XCO
	set RECINST=eftpay.recinst
	set ONUS=Db.getOneRow("ONUS","UTBLEFTINST","RECINST")
	set XCO=CUVAR.co
	
	set XCID=eftpay.cid
	set fcurr=Db.getOneRow("CRCD","ACN","XCID")
	if fcurr="" set fcurr=%SystemCurrency
	if eftpay.recacct'="" S rcurr=$$rcurr(eftpay.recacct)
	else  S rcurr=XCRCD

	// Must use either the recipient or the ""from"" account's currency
	if ONUS,eftpay.ttype<2,eftpay.recacct'="",XCRCD'=rcurr,XCRCD'=fcurr do Runtime.setErrMSG("EFTPAY",1847) quit:ER
	
	set STBLEFT=eftpay.efttype
	set STBLEFT=Db.getOneRow("STBLEFT","CTBLEFTTYPE","STBLEFT")
	if STBLEFT="POC" quit 
	
	set CCACC=Db.getOneRow("POACC,COACC","CRCD","XCO,XCRCD")
	set CCACC=$S(STBLEFT["PO":$P(CCACC,$C(9),1),1:$P(CCACC,$C(9),2))
	
	// Currency "_XCRCD_" not accepted by Clearing Center
	if 'ONUS,'CCACC do Runtime.setErrMSG("EFTPAY",6963,"XCRCD") quit:ER 

	S fconv=$$CONVCRCD(fcurr)
	S rconv=$$CONVCRCD(rcurr)

	if eftpay.ttype=0 do { quit 
		I XCRCD=rcurr,XCRCD=fcurr quit	// all same currency is OK
		I XCRCD=fcurr,fconv,'(STBLEFT'="PO"&(STBLEFT'="SPO")&(STBLEFT'="CO")&(STBLEFT'="SCO")) quit
		I XCRCD=rcurr,rconv,'(STBLEFT'="PO"&(STBLEFT'="SPO")&(STBLEFT'="CO")&(STBLEFT'="SCO")) quit
		I 'ONUS,CCACC quit

		// Account's currency "_rcurr_" is not convertible
		if 'rconv do Runtime.setErrMSG("EFTPAY",6964,"rcurr") quit:ER 
		}


	// If the payment order recipient account is not "on us", the currency of
	// the account is not (cannot) be checked.

	// Currency "_XCRCD_" not convertible
	if eftpay.ttype>1,ONUS,XCRCD'=rcurr,'$$CONVCRCD(XCRCD) do Runtime.setErrMSG("EFTPAY",6965,"XCRCD") quit:ER 
	quit 
	
	

Public CRCDIP(XCRCD,RecordEFTPAY eftpay)	//
	
	/*
	 This subroutine is used by the EFTPAY filer to verify the foreign
	 payment currency code and default values related to the foreign
	 payment's currency. In most cases, a call to CRCDIP should be
	 followed by a call to NOSIP to default SENDNOS and SENDCORR. The
	 payment currency is directly related to the SENDNOS and SENDCORR
	 values. This subroutine was originally copied from the
	 EFT_CRCD_IP data library which is called as a post-procesor to CRCD
	 on the native outgoing and incoming foreign payment screens.
	*/
	
	do eftpay.setAuditFlag(1)

	new CCY,CCYCID,IPA,XCID,XCO

	set XCO=%CompanyName

	if XCRCD="" do Runtime.setErrMSG("EFTPAY",1293) quit:ER

	if 'Db.isDefined("CRCD","XCO,XCRCD") do Runtime.setErrMSG("EFTPAY",1293) quit:ER
	set CCY=Db.getOneRow("CNTRY,CONV,SPTDYS,INTPMT,CALENDAR","CRCD","XCO,XCRCD")

	set XCID=eftpay.cid
	if eftpay.ttype>1 set CCYCID=eftpay.crcd	// GL account
	else  set CCYCID=Db.getOneRow("CRCD","ACN","XCID")

	// Check Allow Foreign Payment flag for outgoing foreign payments
	set IPA=$P(CCY,$C(9),4)
	if eftpay.efttype="NDPO",'IPA do Runtime.setErrMSG("EFTPAY",7543,"XCRCD") quit:ER

	// Check for non-convertible currencies
	if XCRCD'=CCYCID,('$P(CCY,$C(9),2)) do Runtime.setErrMSG("EFTPAY",679,"XCRCD") quit:ER 

	// Default variable field
	if eftpay.varndpo="" set eftpay.varndpo=$P(CCY,$C(9),1)

	quit 


Public EFD(XEFD,RecordEFTPAY eftpay)	//
	
	/*
	This processor is a copy of processor library utility EFT_EFD. It is
	called for electonic payments which are not incoming or outgoing foreign
	payments.
	*/
	
	do eftpay.setAuditFlag(1)
	new efd,MINDATE,MAXDATE,RECINST,ONUS,STBLEFT
	if XEFD="" do Runtime.setErrMSG("EFTPAY",2385) quit:ER 
	
	if (XEFD<%SystemDate)&(eftpay.repost'=1) do Runtime.setErrMSG("EFTPAY",755) quit:ER 
	
	set STBLEFT=eftpay.efttype
	set STBLEFT=Db.getOneRow("STBLEFT","CTBLEFTTYPE","STBLEFT")	
	if STBLEFT="" set STBLEFT=eftpay.efttype

	if STBLEFT="POC" set eftpay.procdt=XEFD quit 
	
	if (eftpay.expdt'="")&(XEFD>eftpay.expdt) do Runtime.setErrMSG("EFTPAY",6063) quit:ER 
	// For direct debits, set the process date from the effective date.
	if STBLEFT="DD" set eftpay.procdt=eftpay.efd quit 

	set MINDAYS=$S(STBLEFT["PO":CUVAR.minpay,STBLEFT["CO":CUVAR.mincol,1:"")
	set MAXDAYS=$S(STBLEFT["PO":CUVAR.maxpay,STBLEFT["CO":CUVAR.maxcol,1:"")
	set (MINDATE,MAXDATE)=%SystemDate
	set:MINDAYS MINDATE=$$NBD^UNBD(%SystemDate,MINDAYS)
	set:MAXDAYS MAXDATE=$$NBD^UNBD(%SystemDate,MAXDAYS)

	set RECINST=eftpay.recinst	
	set ONUS=Db.getOneRow("ONUS","UTBLEFTINST","RECINST")
	
	if 'ONUS&(XEFD<MINDATE) set XRM=$$DAT^%ZM(MINDATE,$G(%MSKD)) do Runtime.setErrMSG("EFTPAY",878,"XRM") quit:ER 
	set efd=$$date^EFTFUNCS(XEFD-1,"1DA",ONUS,0,STBLEFT,eftpay.crcd)
	if XEFD'=efd set eftpay.efd=efd
	if XEFD>MAXDATE set XRM=$$DAT^%ZM(MAXDATE,$G(%MSKD)) do Runtime.setErrMSG("EFTPAY",875,"XRM") quit:ER 
	set eftpay.procdt=procdt
	quit



Public MSGCHK1	//


	if X'="" do {
		do CHECK^SWFTEDIT(X,.SWFTCHAR) quit:ER 
		// If code word is OCMT, skip following two lines... do MSG1^SWFTEDIT then Quit
		if X["OCMT" do MSG1^SWFTEDIT(X,.SWFTEDIT) quit 
		//msg 1350:Invalid format
		if $L(X,"/")-1>2 do Runtime.setErrMSG("EFTPAY",1350,"EFTPAY.MSGFP1") quit:ER 
		if '(X?1"/"1.8A1"/".E) do Runtime.setErrMSG("EFTPAY",1350,"EFTPAY.MSGFP1") quit:ER 
		do MSG1^SWFTEDIT(X,.SWFTEDIT) quit:ER 
		}
	quit 


	
Public MSGCHK(flg,di)	// Check message format and insert /.


	if X'="" do CHECK^SWFTEDIT(X,.SWFTCHAR) quit:ER 
	if (X["OCMT")!(X["CHGS") do MSG2^SWFTEDIT(X,.SWFTEDIT) quit	// MJZ - 35166
	//has more than 2 of "/", msg 1350: Invalid format; msg 8333:Pharse formatted.
	if $L(X,"/")-1>2 do Runtime.setErrMSG("EFTPAY",1350,"EFTPAY."_di) quit:ER 
	//has "/" after 10th character
	if $E(X,11,$L(X))["/" do Runtime.setErrMSG("EFTPAY",1350,"EFTPAY."_di) quit:ER 
	//if neither "/xxx/" nor "//
	if '((X?1"/".8A1"/".E)!(X?2"/".E)) do {
		if ($E(X,1,2)="//"&($L(X)'>34)) quit
		if ($E(X,1)="/"&($L(X)'>34)) set X="/"_X if $G(flg) set ER="W" set RM=$$MSG^MSG(8333) quit 
		if ($E(X,1)="/"&($L(X)>34)) set X="/"_$E(X,1,34) if $G(flg) set ER="W" set RM=$$MSG^MSG(8333) quit 
		if ($E(X,1,2)'="//"&($L(X)'>33)) do {
			if (X?1"/".A) set X="/"_X if $G(flg) set ER="W" set RM=$$MSG^MSG(8333) quit 
			else  set X="//"_X if $G(flg) set ER="W" set RM=$$MSG^MSG(8333) quit 
			}
		if ($E(X,1,2)'="//"&($L(X)>33)) set X="//"_$E(X,1,32) if $G(flg) set ER="W" set RM=$$MSG^MSG(8333)
		}
	do MSG2^SWFTEDIT(X,.SWFTEDIT) quit:ER 
	quit 
	


Public NOSCHECK(RecordEFTPAY eftpay)

	/*
	 This subroutine validates EFTPAY.SENDNOS and EFTPAY.SENDCORR.
	 SENDNOS must be a valid PROFILE account that is not closed.
	 The SENDNOS currency must equal the payment currency. SENDNOS
	 must exist in XVOSTRO if EFTPAY.INTEXT=0 and SENDNOS must
	 exist in XNOS if INTEXT=1.

	 ARGUMENTS:
		. eftpay	EFTPAY object
	*/

	new data,CORRE,CRCD,EMUCRCD,SCRCD,SENDNOS

	set SENDNOS=eftpay.sendnos
	if SENDNOS="" quit

	// Check if the sendnos account exists
	if 'Db.isDefined("DEP","SENDNOS") do Runtime.setErrMSG("EFTPAY",1259,"SENDNOS") quit:ER
	set data=Db.getOneRow("STAT,CRCD","DEP","SENDNOS")

	// Check if the sendnos account is closed
	if $P(data,$C(9),1)=4 do Runtime.setErrMSG("EFTPAY",6050,"SENDNOS") quit:ER

	// Determine EMU currency code
	set EMUCRCD=CUVAR.emucrcd

	// If the settlement is in euro, reset the currency to EMUCRCD
	set CRCD=eftpay.crcd
	if eftpay.setcrcd=1 set CRCD=EMUCRCD

	// Check currency match
	set SCRCD=$P(data,$C(9),2)
	
	// Account ~p1 defined as a ~p2 account
	if CRCD'=SCRCD do Runtime.setErrMSG("EFTPAY",7560,"SENDNOS~SCRCD") quit:ER

	// For internal payments verify that the sendnos account is a
	// vostro account, otherwise verify that the sendnos account
	// exists at the correspondent
	set CORRE=eftpay.sendcorr
	type RecordDEP dep=Db.getRecord("DEP","CID=:SENDNOS",1)
	if (eftpay.intext=0),(dep.getMode()=0) do Runtime.setErrMSG("EFTPAY",13) quit:ER
	if (eftpay.intext'=0) do { quit:ER
		if CORRE="" do Runtime.setErrMSG("EFTPAY",1485,"EFTPAY.SENDCORR") quit:ER

		// Account ~p1 does not exist at ~p2
		if (CORRE'=dep.corre),(CRCD'=dep.crcd) do Runtime.setErrMSG("EFTPAY",7617,"SENDNOS~CORRE") quit:ER
		}

	quit



Public NOSIP(RecordEFTPAY eftpay)	//

	/*
	 This subroutine is used by the EFTPAY filer to default the foreign
	 payment nostro/vostro account (EFTPAY.SENDNOS) and the foreign
	 payment sender's correspondent (EFTPAY.SENDCORR). This subroutine was
	 originally copied from the EFT_NOS_IP data library which is called
	 as a post-procesor to SENDNOS on the native outgoing and incoming
	 foreign payment screens.
	*/

	do eftpay.setAuditFlag(1)

	new EMUCRCD,NOSACCNT,SCRCD

	// Determine the EMU currency code
	set EMUCRCD=CUVAR.emucrcd

	// If the settlement is in euro, reset the settlement curr. to EMUCRCD
	set SCRCD=$S(eftpay.setcrcd=1:EMUCRCD,1:eftpay.crcd)

	// Default to the preferred nostro (CRCD.OURPREF) for the currency
	if eftpay.sendnos="",eftpay.intext=1 set eftpay.sendnos=Db.getOneRow("OURPREF","CRCD","%CompanyName,SCRCD")

	// Default sender's correspondent to SENDNOS correspondent
	set NOSACCNT=eftpay.sendnos
	if eftpay.sendcorr="",NOSACCNT'="" set eftpay.sendcorr=Db.getOneRow("CORRE","ACN","NOSACCNT")

	quit 



Public DATIP(CRCD,EFTTYPE,SENDCORR,PROCDT,EFD)	//

	/*
	 This subroutine is used by the EFTPAY filer to default the foreign
	 payment process date (EFTPAY.PROCDT) and the foreign payment
	 effective date (EFTPAY.EFD).

	 ARGUMENTS:
		. CRCD		Payment currency (EFTPAY.CRCD)
		. EFTTYPE	Payment type (EFTPAY.EFTTYPE)
		. SENDCORR	Payment sender's correspondent (EFTPAY.SENDCORR)
	 RETURNS:
		. PROCDT	Process date
		. EFD		Effective date
	*/

	new CNTRY,CORRCAL,ECAL,ERLYEDT,ERLYPDT,PCAL

	type RecordUTBLCORRE corre
	type RecordCRCD crcd
	
	// Determine the correspondent calendar
	set CORRCAL=""
	if SENDCORR'="" do {
		// Retrieve correspondent's country code
		set corre=Db.getRecord("UTBLCORRE","SENDCORR")
		set CNTRY=corre.cntry
		if CNTRY="" quit

		// Retrieve calendar linked to the country code
		type ResultSet rs=Db.select("DISTINCT NBDC","XCAL","CNTRY=:CNTRY")
		if 'rs.isEmpty(),rs.next() set CORRCAL=rs.getCol(1)
	}

	/*
	 Determine validation calendars for payment type
	 For outgoing payments, PROCDT will be validated using the IBS
	 calendar and EFD will be validated using the correspondent calendar.
	 For incoming payments, PROCDT will be validated using the
	 correspondent calendar and EFD will be validated using the IBS
	 calendar. If a correspondent calendar cannot be determined, then the
	 IBS calendar is used in place of the correspondent calendar.
	*/
	if EFTTYPE="NDPO" set PCAL="",ECAL=CORRCAL
	else  set PCAL=CORRCAL,ECAL=""

	/*
	 Determine the earliest possible process date based on the process date
	 validation calendar. If the current process date is too early, then
	 reset PROCDT to the earliest date, otherwise, set PROCDT to the first
	 business date on or after PROCDT based on PCAL.
	*/
	set ERLYPDT=$$NBD^UNBD(%SystemDate,1,0,PCAL)
	if PROCDT<ERLYPDT set PROCDT=ERLYPDT
	else  set PROCDT=$$NBD^UNBD(PROCDT,1,0,PCAL)

	/*
	 Determine the earliest possible effective date based on the effective
	 date validation calendar and the spot days & calendar of the payment
	 currency. First, the minimum number of required spot days is added to
	 the process date. Second, the first business date on or after the spot
	 day value based on the effective date validation calendar is
	 determined as the earliest date. If the current effective date is too
	 early, then reset EFD to the earliest date, otherwise set EFD to the
	 first business date on or after EFD based on ECAL.
	*/
	set crcd=Db.getRecord("CRCD","%CO,CRCD")
	set ERLYEDT=$S(crcd.sptdys:PROCDT+1,1:PROCDT)
	set ERLYEDT=$$NBD^UNBD(ERLYEDT,crcd.sptdys,0,crcd.calendar)
	set ERLYEDT=$$NBD^UNBD(ERLYEDT,1,0,ECAL)
	if EFD<ERLYEDT set EFD=ERLYEDT
	else  set EFD=$$NBD^UNBD(EFD,1,0,ECAL)

	quit


Public REFNO(SOURCE,RecordEFTPAY eftpay)
	
	/*Calculate and store the REFNO value for incoming,outgoing payments
	which do not have one defined.
	*/


	do eftpay.setAuditFlag(1)
	if eftpay.refno'="" quit 
	new REFNO
	set REFNO=""
	do ^TRREFNO(SOURCE,.REFNO,"")
	set eftpay.refno=REFNO
	quit 
	
	

Public SDTIP(XEFD,RecordEFTPAY eftpay)	//
	
	/*
	This processor is a copy of processor library utility EFT_SDT_IP which is
	called as a post processor for column EFD of OUTGOING foreign payments.
	*/


	if (XEFD>eftpay.efd)&(eftpay.repost'=1) do Runtime.setErrMSG("EFTPAY",7760) quit:ER 
	
	set CAL=Db.getOneRow("CALENDAR","CRCD","%CompanyName,%SystemCurrency")
	if CAL="" quit 
	if '($$BD^UNBD(XEFD,CAL)) do Runtime.setErrMSG("EFTPAY",7648,"CCY") quit:ER 
	quit 



Public VDTIP(XEFD,RecordEFTPAY eftpay)	//

	/*
	This processor is a copy of processor library utility EFT_VDT_IP. It is
	called  as a post processor to field EFD for OUTGOING records.
	*/	

	new CCY,CAL
	
	// Date must not be in the past
	if (XEFD<%SystemDate)&(eftpay.repost'=1) do Runtime.setErrMSG("EFTPAY",755) quit:ER

	set CCY=eftpay.crcd
	set CAL=Db.getOneRow("CALENDAR","CRCD","%CompanyName,CCY")
	if '($$BD^UNBD(XEFD,CAL)) do Runtime.setErrMSG("EFTPAY",7648,"CCY") quit:ER 
	
	set CAL=Db.getOneRow("CALENDAR","CRCD","%CompanyName,%SystemCurrency")
	if '($$BD^UNBD(XEFD,CAL)) do Runtime.setErrMSG("EFTPAY",7648,"CCY") quit:ER 
	quit 
	
	

CONVCRCD(XCRCD)	// return CONV value from CRCD table


	new X
	set X=Db.getOneRow("CONV","CRCD","%CompanyName,%SystemCurrency")
	quit X


	
rcurr(XCID)	//return the account's currency


	new crcd
	
	set crcd=Db.getOneRow("CRCD","ACN","XCID")
	if crcd="" set crcd=%SystemCurrency
	quit crcd



public REMOVE(Number CID,Date BEGDATE) // Delete standing (collection/payment) orders upon loan payoff or deposit closeout
	/*
	 This linetag is called from DEPCL.M and LNPTS23.M and the 
	 before update triggers for both LN and DEP
	*/
	
	type public Boolean ER
	
	type Number SEQ
	
	// Find outstanding EFTPAY records.
	type ResultSet rs=Db.select("SEQ","EFTPAY","CID=:CID AND NOT PROCDT<:BEGDATE AND NOT STATUS IN ('D','R','C')")
	if rs.isEmpty() quit

	type RecordACN acn=Db.getRecord("ACN","CID=:CID")

	// First update PAYEFT record on the account.
	do acn.setAuditFlag(1)
	if acn.cls="D" do PAYEFTD(.acn)
	if acn.cls="L" do PAYEFTL(.acn)
	do acn.save()

	// Then cycle through all outstanding records and mark deleted.
	while rs.next() do {  quit:ER
		
		set SEQ=rs.getCol("SEQ")
		
		type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ")
		do eftpay.setAuditFlag(1)
		set eftpay.status="D"
		do eftpay.save()
		}

	quit 


PAYEFTD(RecordDEP dep)  // Update PAYEFT on DEP account; set to 0.

	set dep.payeft=0
	quit


PAYEFTL(RecordLN ln) // Update PAYEFT on LN account; set to 0.

	set ln.payeft=0
	quit


public GLCHECK(EFTTYPE,TTYPE,CID,RECINST,RECACCT)

	/*
	 Verifies proper use of memo and header G/L accounts

	 ARGUMENTS:
		EFTTYPE		Electronic payment type
	 	TTYPE		Transaction type
	 	CID		Account number
	 	RECINST		Recipient institution
	 	RECACCT		Recipient account
	*/

	new EFTMEMO,OGLTYP,ONUS,RGLTYP

	// Check if no G/Ls are used
	if TTYPE=0 quit

	set EFTMEMO=CUVAR.eftmemo  // Prohibit EFT w/ Memo GL
	set (OGLTYP,RGLTYP)=""

	// If originating account is a G/L, check for header/memo GL accounts
	if (TTYPE=2)!(TTYPE=3) do {  quit:ER
		set OGLTYP=Db.getOneRow("TYPE","GLAD","CID")
		if OGLTYP="H" set ER=1,RM=$$^MSG(4766) quit
		if EFTMEMO,(OGLTYP="M") set ER=1,RM=$$^MSG(4767)
	}

	// If domestic payment, check recipient account for header/memo GL accounts
	if (EFTTYPE'["NDPO"),((TTYPE=1)!(TTYPE=3)) do {  quit:ER
		set ONUS=Db.getOneRow("ONUS","UTBLEFTINST","RECINST")
		if ONUS'=1 quit  // If not ONUS, then recipient has no meaning

		set RGLTYP=Db.getOneRow("TYPE","GLAD","RECACCT")
		if RGLTYP="H" set ER=1,RM=$$^MSG(4766) quit
		if EFTMEMO,(RGLTYP="M") set ER=1,RM=$$^MSG(4767)
	}

	// Check if payment between memo G/L and non-memo G/L
	if (OGLTYP=RGLTYP) quit
	if (OGLTYP="M")!(RGLTYP="M") set ER=1,RM=$$^MSG(4768)

	quit


Public DATCHK(OPT,DATE,SENDCORR)	//

	/*
	 Verify date based on correspondent or IBS calendar
	 This subroutine is used by the EFTPAY filer and the native outgoing
	 and incoming foreign payment screens to verify outgoing and incoming
	 foreign payment settlement dates, EFTPAY.PROCDT and EFTPAY.EFD

	 ARGUMENTS:
		. OPT		Verify option (0=IBS calendar,1=correspondent)
		. DATE		Date to be verified
		. SENDCORR	Sender's correspondent
	*/

	new CAL,CNTRY
		
	// Initialization
	set (CAL,CNTRY)=""

	// Verification based on correspondent
	if OPT,(SENDCORR'="") do {
		// Retrieve correspondent's country code
		type RecordUTBLCORRE corre=Db.getRecord("UTBLCORRE","SENDCORR")
		set CNTRY=corre.cntry
		if CNTRY="" quit

		// Retrieve calendar linked to the country code
		type ResultSet rs=Db.select("DISTINCT NBDC","XCAL","CNTRY=:CNTRY")
		if 'rs.isEmpty(),rs.next() set CAL=rs.getCol(1)
	}

	// Verify date is a valid business date for the calendar
	// STBLMSG - Date must be a valid business date in ~p1
	if CNTRY="" set CNTRY="IBS"
	if '$$BD^UNBD(DATE,CAL) set ER=1,RM=$$^MSG(7648,CNTRY) quit

	quit

Public PAYMET(RecordEFTPAY eftpay)     //Payment Method

	/*
	It returns a payment method
	
	FORMAT:		$$PAYMET^PROCEFT(RecordEFTPAY eftpay)
	
	RETURNS:	"CC" or another valid payment method
			literal specified via customization	   	

	ARGUMENTS:	RecordEFTPAY eftpay - EFTPAY Object
	
	*/
	
	type String PAMT
	type public Boolean ER
	
	#if $$VALID^%ZRTNS("ZPROCEFT") 
		set PAMT=$$PAYMET^ZPROCEFT(.eftpay) if ER quit 0
	#else
		set PAMT="CC"
	#endif

	quit PAMT
 #OPTION ResultClass ON
Public String vSIG()	quit "60543^20171^Hari Natrajan^29456"	// Signature - LTD^TIME^USER^SIZE
