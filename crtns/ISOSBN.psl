ISOSBN(IM)
  /*
 ORIG: KELLYP - 03/07/2001
 DESC: Shared Branch Network "IN" Server

---- Comments --------------------------------------------------------


 This procedure handles all incoming messages from the Shared Branch Network
 where PROFILE acts as the host institution.  Primary message processing is
 handled by the ISO8583 procedure.  Extended fields (large data bits 105 thru
 108) are composed by this procedure for Shared Branch-specific data.

---- Revision History ------------------------------------------------

	04/17/07 - RussellDS - CR26387
		Eliminate use of UHFETCH.
		
	09/06/05 - SAHOOU - CR 16880
	 	Modified Db.getOneRow calls throughout the entire procedure and
	 	in UPDSTAT section is replace with Db.getRecord in place of 
	 	isDefined/update or insert.
	
	09/08/04 - KELLYP - CR 11982
		Replaced references to RELACN with RELCIF.  RELACN is an index
		and should not be directly referenced.  The RELACN table was 
		also obsoleted from the M database.  Also removed pre-2002
		revision history and modified ACCTS section to bring it in-line
		with current PSL standards.

	01/14/02 - KELLYP - 48894
		Modified PMT and PMTXFR sections and added section HISTFEES
		to handle situations where a loan payment's transaction amount
		does not indicate interest, but local HIST variable does.  Fee
		amounts (which include interest) were previously not being
		returned in this scenario.
 */

	// Top level is used so error catching can be enabled

	new INTRFACE,OM

	if $G(IM)="" quit ""

	do START(IM,.OM)

	quit $G(OM)


START(IM,OM)	// Directs Messages to other linetags/procedures 
	/*
	 This section handles the direct processing of messages received
	 from the Shared Branch Network.  Error catching is implemented to
	 provide a null response if a PROFILE run-time error is encountered
	 during processing.  Messages are directed one of three ways:

		- 0790 Network Management messages, received from the network
		router for logging on/off the network, are routed to the NET
		section to build an 0800 response message.
	 
		- 0620 Administrative Advice messages, received from the
		network switch when a response message was formatted
		incorrectly, are routed to the AA section to log the message 
		and to attempt a reversal in the event that the message
		rejected by the network was financial in nature.

		- All other messages are routed to the ISO8583 procedure.

	 ARGUMENTS
		. IM   Incoming Message		/TYP=T/REQ/MECH=VAL
 
	 RETURNS
		. OM	Outgoing Message	/TYP=T/REQ/MECH=REF
	*/

	new MSGTYP
	type String INTRFACE

	catch error {
		new ET,RM
		set ET=error.type

		if ET["%GTM-" do ZE^UTLERR quit
		set ET=ET_"-"_error.thrownAt
		set RM=error.description
		do ^UTLERR
		}

	set INTRFACE="ISOSBN"				// Define as SBN interface
	do REMHDR^SBNUTL(.IM)				// Remove header

	set MSGTYP=$E(IM,1,4)

	if MSGTYP="0790" set OM=$$NET(IM)		// Network Message
	else  if MSGTYP="0620" set OM=$$AA(IM)		// Administrative Advice Message
	else  set OM=$$^ISO8583(IM)			// Standard SBN Message

	if OM="" quit					// Drop null reply

	do ADDHDR^SBNUTL(.OM,1)				// Add header

	quit						// Return message


NET(IM)		// Network Management Message (0790)
	/*
	 This section handles interpreting Network Management Messages (0790
	 proprietary format) sent by the network message router and builds 
	 an 0800 message as the response.

	 ARGUMENTS
		. IM	Incoming Message	/TYP=T/REQ/MECH=VAL

	 RETURNS
		. OM	Outgoing Message (0800)
	*/	

	new BIT,CODE,i,MID,OM,TBL,TMPTM
	type public String INTRFACE

	do INIT^ISO8583(INTRFACE)		// Initialize ISO8583 Vars
	set MID=$$BITMAP^ISO8583(IM,.TBL,.BIT)	// Interpret 0790 message

	set TMPTM=$$TIM^%ZM(%CurrentTime,"24:60:SS")

	for i=105:1:108 do {

		quit:$G(BIT(i))=""

		new sbmsg
		type RecordSBNETMSG sbmsg=Class.new("RecordSBNETMSG")
		set sbmsg.procdt=%CurrentDate
		set sbmsg.tm=TMPTM
		set sbmsg.bitnum=i
		set sbmsg.bitdata=BIT(i)

		do sbmsg.save()			// Save extended field data
		}

	if $G(BIT(121))=1 quit ""		// Drop 0790 Advisement

	/*
	 If SBNET.SBSTAT=0, CODE should be 001 (sign-on).
	 Else, SBNET.SBSTAT=1 so CODE should be 301 (echo-test).
	*/

	type RecordSBNET sbnet=Db.getRecord("SBNET","INTRFACE=:INTRFACE")
        if sbnet.sbstat=1 set CODE="301"
        else  set CODE="001"
	set OM=$$GENNET^ISO8583(CODE)	// Generate 0800

	do UPDSTAT			// Update SBN Server Status

	quit OM		// Return 0800 as response for regular 0790


AA(IM)	// Administrative Advice Message (0620)
	/*
	 This section handles the reception of 0620 Administrative Advice
	 messages sent by the network to PROFILE when a response message
	 generated by PROFILE was formatted incorrectly.  A reversal will
	 attempted if the response message was financial in nature.

	 ARGUMENTS
		. IM   Incoming Message		/TYP=T/REQ/MECH=VAL
 
	 RETURNS
		. OM    Outgoing Message
	*/

	new ATMM,BIT,MID,MSG,OM,TBL
	type public String INTRFACE,RM

	set ATMM=$$NXTSEQ^ISO8583()
	set OM=""			// No reply for 0620 messages
	
	do NSMLOG^PBSNSM(INTRFACE,ATMM,IM,OM,$E($G(RM),1,40))  // Log to NSMLOG

	do INIT^ISO8583(INTRFACE)
	set MID=$$BITMAP^ISO8583(IM,.TBL,.BIT)

	set MSG=$G(BIT(124))		// Message that caused the format error

	kill BIT

	set MID=$E(MSG,1,4)
	if '(($E(MID,2)>1)&($E(MID,2)<6)) quit ""    // Quit if not financial

	set MSG="0420"_$E(MSG,5,$L(MSG))
	set OM=$$^ISO8583(MSG)			    // Attempt Reversal

	quit ""		// Drop 0620 message


EXTFLD(BIT)  // Compose Extended Fields for Verifications, Statements, & Inquiries
	/*
	 This section builds the Shared Branch Extended Field Data for
	 Member Verification, Account Inquiry, and Statement Print messages.  
	 This data is placed into bits 105 through 108 (255 characters max).

	 ARGUMENTS
		. BIT	BIT Array		/TYP=T/REQ/MECH=REFARR:RW

	 RETURNS
		. BIT(105) through BIT(108)
	*/

	new ACCTS,CONCTL,EXTFLD,EXTPGM,EXTSTR,i,IACCTS,LACCTS,QUAL1,QUAL2,MAXCID
	new SACCTS,SBNCIF,TQUAL,VSLC
	type public Boolean ER
	do INIT(.BIT)
	
	if ($G(ER)=1)!(EXTFLD="") do {  quit
		for i=105:1:108 kill BIT(i)
		}

	set EXTSTR="*S1*\"
	set EXTPGM=EXTFLD_"(.EXTSTR)"
	do @EXTPGM			// Compose Large Data Bits

	// 46356 - Do not include large data bits on error
	if ER for i=105:1:108 kill BIT(i)
 
	// Bits 105 - 108 are 255 chars max
	for i=105:1:108 set BIT(i)=$E(EXTSTR,1,255),EXTSTR=$E(EXTSTR,256,$L(EXTSTR))
	for i=105:1:108 if $G(BIT(i))="" kill BIT(i)

	quit


EXTFIN(BIT,RecordTTX ttx())	// Compose Extended Fields for Financial (0210) Reply Messages
	/*
	 This section builds the Shared Branch Extended Field Data for Payment,
	 Transfer, and Payment Transfer messages.  This data is placed into
	 large data bits 105 through 108 (255 characters max).
 
	 ARGUMENTS
		. BIT   BIT Array		/TYP=T/REQ/MECH=REFARR:RW
		. ttx	TTX Object		/TYP=O/REQ/MECH=REF
 
	 RETURNS
		. BIT(105) through BIT(108)
	*/

	new EXTFLD,EXTPGM,EXTSTR,i,QUAL1,QUAL2
	type public Boolean ER

	do INIT(.BIT)

	if ($G(ER)=1)!(EXTFLD="") do {  quit
		for i=105:1:108 kill BIT(i)
		}

	set EXTSTR="*S1*\"
	set EXTPGM=EXTFLD_"(.EXTSTR,.ttx)"	// 46356 - Modified to pass ttx
	do @EXTPGM

	// 46356 - Do not include large data bits on error
	if ER for i=105:1:108 kill BIT(i)

	for i=105:1:108 set BIT(i)=$E(EXTSTR,1,255),EXTSTR=$E(EXTSTR,256,$L(EXTSTR))
	for i=105:1:108 if $G(BIT(i))="" kill BIT(i)

	quit


INIT(BIT)	// Initialize Extended Field Data
	/*
	 This section sets up common variables needed by the EXTFLD and EXTFIN
	 sections and also calls the CIFINIT section when a member verification
	 or inquiry has been received to set up customer information needed in
	 the extended fields.

	 ARGUMENTS
		. BIT   BIT Array		/TYP=T/REQ/MECH=REFARR:RW
	*/

	new i
	type public String MID,QUAL1,QUAL2,TQUAL,MAXCID,VSLC,CONCTL,SBNCIF,EXTFLD,PRCD
	type public Number IACCTS,RSPCD,SACCTS,LACCTS
	type public Boolean ER
	for i=105:1:108 set BIT(i)=""	// Initialize extended fields

	if '$E(MID,3) quit		// Only 0110 and 0210 messages

	set QUAL1=$E($G(BIT(120)),1,3)	// Account Qualifier 1
	set QUAL2=$E($G(BIT(120)),4,6)	// Account Qualifier 2
	if QUAL2="   " set QUAL2=""

	// For verifications and inquiries
	if (QUAL1="VER")!($E(QUAL1,3)="I") do {  quit:ER

		// Calculate max number of accounts to return
		//  Inv or Loan: 6, Share: 10, Share/Loan:4
		set TQUAL=$S(QUAL2="":QUAL1,1:QUAL2)
		set MAXCID=$S((TQUAL="IAI")!(TQUAL="LAI"):6,TQUAL="SAI":10,1:4)
		set VSLC=$S(TQUAL="IAI":"-06-07-08-",TQUAL="SAI":"-01-02-",TQUAL="LAI":"-03-04-05-",1:"-01-02-03-04-05")

		set CONCTL=$TR($G(BIT(127))," ")	// 46356:004

		do CIFINIT(.BIT,.SBNCIF)	// Initialize customer info

		if ER quit

		// No accounts of type indicated by qualifiers
		if ((QUAL1="IAI")!(QUAL2="IAI")),(IACCTS=0) set ER=1,RSPCD=44
		else  if ((QUAL1="SAI")!(QUAL2="SAI")),(SACCTS=0) set ER=1,RSPCD=53
		else  if ((QUAL1="LAI")!(QUAL2="LAI")),(LACCTS=0) set ER=1,RSPCD=39
		else  if ((QUAL1="SLI")!(QUAL2="SLI")),(LACCTS=0),(SACCTS=0) set ER=1,RSPCD="88"
		}

	set EXTFLD=""

	// Verification, Inquiry, or Statement
	if (QUAL1="VER") do {
		if $E(QUAL2,2)'="L" set EXTFLD=$E(QUAL2,1)_"MV"
		else  set EXTFLD="SLMV"
		}
	else  if ($E(QUAL1,3)="I") set EXTFLD=QUAL1
	else  if QUAL1="STM" set EXTFLD=$E(QUAL2,1)_"SP"

	// Payment, Transfer, or Payment Transfer
	else  if ($E(PRCD,1,2)=55) set EXTFLD="PMT"	// PK - 46356
	else  if (QUAL1="TFR"),($E(PRCD,5)<3) set EXTFLD="XFR"
	else  if (QUAL1="TFR"),($E(PRCD,5)>2) set EXTFLD="PMTXFR"

	quit


INIT2	// Initialize Account Information for ISO8583 and verify Service Line Code
	/*
	 This section initializes account and customer number variables, 
	 processing codes, and other variables required by further processing.
	 This section also verifies that the account number(s) passed for a
	 SBN financial transaction exist and also verifies that they have
	 service line code values defined on them (ACN.SLC).

	 FROM and TO account numbers in SBN are formatted as follows:

	 Account Number then equal sign delimeter
	 "Account Number="	
	 
	 Or Customer Number then equal sign delimtere then Account Type
	 "Customer Number=Account Type"
	*/

	new CUVDT,FSLC,TSLC,TTYP
	type public String FACN,FCID,TACN,TCID,BIT,SETDT,PRCD,RT,STF,RM
	type public Number PRE,TAMT,MSGTYP
	type public Boolean ER
	
	// Initialize Customer & Account Numbers
	set FACN=+$P(FCID,"=",1)
	set TACN=+$P(TCID,"=",1)

	/*
	 46356 - Added the following two lines so that ISO8583 treats 0100 
	 Special Purchase with Cash messages as financials (PRCD will be reset
	 according to account group) and treats 0200 Account Inquirys as
	 non-financials.
	*/

	// Special Purchase with Cash is a financial transaction
	if $E(BIT(120),1,3)="SPC" set PRE=0,TAMT=0

	// 0200/0201 Account Inquiry is not a financial transaction
	if ((MSGTYP="0200")!(MSGTYP="0201")),($E(BIT(120),3)="I") set PRE=1

	// For non-financials, not including statements, FACN/TACN can be a CIF or an ACN
	if PRE,($G(BIT(120))'["STM") do {
		if Db.isDefined("CIF","FACN") set FCID=0
		else  if Db.isDefined("ACN","FACN") set FCID=FACN,FACN=0
		else  set (FACN,FCID)=0

		if Db.isDefined("CIF","TACN") set TCID=0
		else  if Db.isDefined("ACN","TACN") set TCID=TACN,TACN=0
		else  set (TACN,TCID)=0
		}
	// 46293:035 - For financials, FACN/TACN could be "ACN=" or "CIF=ACN"
	else  do {
		do FINCID(.FACN,.FCID)
		do FINCID(.TACN,.TCID)
		}

	// Update CUVAR SBN Settlement Date
	set CUVDT=$$CUVSTLDT^SBNUTL($G(SETDT))

	// Rest is for financial transactions only
	if PRE quit

	// Reset processing code
	set TTYP=$E(PRCD,1,2)	
	set PRCD=TTYP_"0000"	// PK - 46356

	// Reset RT based upon local/non-local (deposits only)
	if TTYP="21" do {
		new Q1,TMPRT

		// Get first two characters of Acct Qualifier 1
		set Q1=$E($G(BIT(120)),1,2))

		// Local, use first piece in RT
		if Q1="CL" set RT=$P(RT,",",1) quit

		// Non-Local use second piece in RT
		if Q1="CN" do {  quit
			set TMPRT=RT
			set RT=$P(RT,",",2)
			if RT="" set RT=TMPRT
			}

		// Immediate, no hold placed
		set RT=""
		set PRCD=20_$E(PRCD,3,6)
		}

	// Verify FROM account exists
	if 'Db.isDefined("ACN","FCID") do {  quit:ER
		// Invalid FROM Account Number ~p1
		if 'STF set ER=1,RSPCD=$$RSPCD^ISO8583(2095),RM=$$^MSG(2095,FCID) quit

		// Advice message must process
		set FCID=0
		}

	// Verify Service Line Code for FROM account
	
	type RecordACN acn=Db.getRecord("ACN","CID=:FCID")
	set FSLC=acn.slc
	
	if (FSLC="")!(FSLC>5) do {  quit:ER
		// Service Line Code not defined for account ~p1
		if 'STF set ER=1,RSPCD=$$RSPCD^ISO8583(4970),RM=$$^MSG(4970,FCID) quit

		// Advice message must process
		set FCID=0
		}

	// 46356:003 - Verify account status/override settings
	if '$$STATOVR(FCID) quit

	// Flip FROM/TO accounts for deposits and payments
	if (TTYP=21)!(TTYP=55) set TCID=FCID,TACN=FACN,(FACN,FCID)=0

	if $E(PRCD,1,2)'=40 quit	// Only do rest for transfers

	if TCID,'Db.isDefined("ACN","TCID") do {  quit:ER 
		// Invalid TO Account Number ~p1
		if 'STF set ER=1,RSPCD=$$RSPCD^ISO8583(2096),RM=$$^MSG(2096,TCID,TCID) quit

		// Advice message must process
		set TCID=0	
		}

	// Verify SLC for TO Account
	
	type RecordACN acn1=Db.getRecord("ACN","CID=:TCID")
	set TSLC=acn1.slc		
        
        if (TSLC="")!(TSLC>5) do {  quit:ER
                // Service Line Code not defined for account ~p1
                if 'STF set ER=1,RSPCD=$$RSPCD^ISO8583(4970),RM=$$^MSG(4970,TCID) quit
 
                // Advice message must process
                set TCID=0
                }

	// 46356:003 - Verify account status/override settings
	if '$$STATOVR(FCID) quit

	quit


MV(EXTSTR)	// Member Verification (No Account)
	
	set EXTSTR=EXTSTR_SBNCIF("MNAME")_"\"_SBNCIF("JNAME")_"\"_SBNCIF("ADDR")_"\"
	set EXTSTR=EXTSTR_SBNCIF("CITY")_"\"_SBNCIF("STATE")_"\"_SBNCIF("ZIP")_"\"
	set EXTSTR=EXTSTR_SBNCIF("SSN")_"\"_SBNCIF("PHONE")_"\"
	quit 


IMV(EXTSTR)	// Investment Account Member Verification

	do MV(.EXTSTR)				// Build Customer Info	
	do INV(.EXTSTR)				// Build Inv Acct Info	
	quit


IAI(EXTSTR)	// Investment Account Inquiry

	set EXTSTR=EXTSTR_SBNCIF("MNAME")_"\"
	do INV(.EXTSTR)
	quit


INV(EXTSTR)	// Common tag for IAI verification and inquiries

	new NUMACT,XCID
	type public String ACCTS()

	set NUMACT=IACCTS				// Number of Accounts
	if NUMACT<10 set NUMACT="0"_NUMACT		// Fixed length of 2

	set EXTSTR=EXTSTR_NUMACT_"I"_CONCTL_"\"

	set XCID=""
	for  set XCID=$O(IACCTS(XCID)) quit:XCID=""  do {
		new AVLBAL,BAL,CID,CRTRIN,DATA,LRDT,LSTDIV,MDT,PEN,RATE,SAVBAL
		new SLC,SLCDES,XTYPE

		// Joint owner name entry - Not an account
		if XCID["J" do {  quit
			new TMPCID
			set JNAME=$P(IACCTS(XCID),"|",2)
			set TMPCID=$P(XCID,"J",2)
			set EXTSTR=EXTSTR_JNAME_"\\"_TMPCID_"\\\\\\\\"
			}
			
		type RecordDEP dep=Db.getRecord("DEP","CID=:XCID")
                
                set AVLBAL=dep.totbalav		      // Available Balance
		if AVLBAL<0 set AVLBAL=AVLBAL*(-1),AVLBAL="-"_AVLBAL.zero(8,2,1)
		else  set AVLBAL=AVLBAL.zero(9,2,1)

		set (BAL,SAVBAL)=dep.bal		// Ledger Balance
		if BAL<0 set BAL=BAL*(-1),BAL="-"_BAL.zero(8,2,1)
		else  set BAL=BAL.zero(9,2,1)

		set RATE=dep.irn		        // Interest Rate
		set RATE=RATE.zero(5,3,1)		// Implied Decimal
	
		set MDT=dep.mdt				// Maturity Date
		set MDT=MDT.toDate().toString("YYMMDD")		
		
		set LRDT=dep.dlr                       // Last Renewal Date
		set LRDT=LRDT.toDate().toString("YYMMDD") 
		
		set SLC=$P(IACCTS(XCID),"|",1)		// Service Line Code
		set SLCDES=$P(IACCTS(XCID),"|",2)	// SLC Desc.

		set EXTSTR=EXTSTR_FACN_"="_XCID_$S($P(ACCTS(XCID),"|",4)=1:"=J",1:"")_"\"
		set EXTSTR=EXTSTR_SLC_"\"_SLCDES_"\"_BAL_"\"_AVLBAL_"\"

		set PRIN=SAVBAL,CID=XCID
		do ^DEPPEN			// Calculate Early Wdwl Penalty
		set PEN=PEN.zero(9,2,1)
		set EXTSTR=EXTSTR_PEN_"\"

		set XTYPE=dep.type		// Product Type
		
		type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:XTYPE")
		set CRTRIN=prodctl.crtrin
		set LSTDIV=0

		if CRTRIN'="" do {
		
			type ResultSet rs = Db.select("TAMT", "HIST", "CID=:XCID AND ETC=:CRTRIN", "TSEQ DESC")
			
			if rs.next() set LSTDIV = rs.getCol("TAMT")
		}

		set LSTDIV=LSTDIV.zero(9,2,1)		// Last Int/Div Amount
		set EXTSTR=EXTSTR_LSTDIV_"\"

		set EXTSTR=EXTSTR_RATE_"\"_MDT_"\"_LRDT_"\"
	}
	
	quit


SMV(EXTSTR)	// Share Account Member Verification

	do MV(.EXTSTR)				// Build Customer Info
	do SHA(.EXTSTR)				// Build Share Account Info

	quit


SAI(EXTSTR)	// Share Account Inquiry
	
	type public String SBNCIF()
	set EXTSTR=EXTSTR_SBNCIF("MNAME")_"\"
	do SHA(.EXTSTR)
	quit


SHA(EXTSTR)	// Common linetag for Share verifications and inquiries

	new NUMACT,XCID
	type public String ACCTS()

	set EXTSTR=EXTSTR_"\\"                  	// Skip Remaining Member Fields

	set NUMACT=SACCTS                       	// Number of Accounts
	if NUMACT<10 set NUMACT="0"_NUMACT
	
	set EXTSTR=EXTSTR_NUMACT_"S"_CONCTL_"\"

	set XCID=""
	for  set XCID=$O(SACCTS(XCID)) quit:XCID=""  do {
		new AVLBAL,BAL,DATA,JNAME,SLC,SLCDES

		// Joint owner name entry - Not an account
		if XCID["J" do {  quit
			new TMPCID
			set JNAME=$P(SACCTS(XCID),"|",2)
			set TMPCID=$P(XCID,"J",2)
			set EXTSTR=EXTSTR_JNAME_"\\"_TMPCID_"\\\"
			}

		type RecordDEP dep=Db.getRecord("DEP","CID=:XCID")
		
		set BAL=dep.bal		      // Ledger Balance
		if BAL<0 set BAL=BAL*(-1),BAL="-"_BAL.zero(8,2,1)
		else  set BAL=BAL.zero(9,2,1)

		set AVLBAL=dep.balavail		// Available Balance
		if AVLBAL<0 set AVLBAL=AVLBAL*(-1),AVLBAL="-"_AVLBAL.zero(8,2,1)
		else  set AVLBAL=AVLBAL.zero(9,2,1)

		set SLC=$P(SACCTS(XCID),"|",1)		// Service Line Code
		set SLCDES=$P(SACCTS(XCID),"|",2) 	// SLC Des.

		set EXTSTR=EXTSTR_FACN_"="_XCID_$S($P(ACCTS(XCID),"|",4)=1:"=J",1:"")_"\"
		set EXTSTR=EXTSTR_SLC_"\"_SLCDES_"\"_BAL_"\"_AVLBAL_"\"
		}
	quit


LMV(EXTSTR)	// Loan Account Member Verification

	do MV(.EXTSTR)				// Build Customer Info
	do LN(.EXTSTR)				// Build Loan Acct Info
	quit


LAI(EXTSTR)	// Loan Account Inquiry

	set EXTSTR=EXTSTR_SBNCIF("MNAME")_"\"
	do LN(.EXTSTR)
	quit


LN(EXTSTR)	// Common linetag for Loan verifications and inquiries

	new XCID

	if (QUAL1'="SLI"),(QUAL2'="SLI") set EXTSTR=EXTSTR_"\\"	// Skip Remaining Member Fields

	set LACCTS="0"_LACCTS
	set EXTSTR=EXTSTR_LACCTS_"L"		// Number of Loan Accounts

	if (QUAL1'="SLI"),(QUAL2'="SLI") set EXTSTR=EXTSTR_CONCTL	// Continuation Control
	set EXTSTR=EXTSTR_"\"

	set XCID=""
	for  set XCID=$O(LACCTS(XCID)) quit:XCID=""  do {
		new AVLBAL,BAL,CRLMT,DAA,DATA,i,PMT,POAM,SCHND,SLC,SLCDES

		// Joint owner name entry - Not an account
		if XCID["J" do {  quit
			new TMPCID
			set JNAME=$P(LACCTS(XCID),"|",2)
			set TMPCID=$P(XCID,"J",2)
			set EXTSTR=EXTSTR_JNAME_"\\"_TMPCID_"\\\\\\\\"
			}

		type RecordLN ln=Db.getRecord("LN","CID=:XCID")
		
		set AVLBAL=ln.balavail	     // Available Balance
		if AVLBAL<0 set AVLBAL=AVLBAL*(-1),AVLBAL="-"_AVLBAL.zero(8,2,1)
		else  set AVLBAL=AVLBAL.zero(9,2,1)

		set BAL=ln.bal	            // Ledger Balance
		if BAL<0 set BAL=BAL*(-1),BAL="-"_BAL.zero(8,2,1)
		else  set BAL=BAL.zero(9,2,1)

		set SCHND=ln.schnd			// Next Pmt Date
		set SCHND=SCHND.toDate().toString("YYMMDD")
		
		set PMT=ln.pmtpi	    // P&I Payment
		set PMT=PMT.zero(9,2,1)

		set GRP=ln.grp	            // Account Group
		if GRP="RC" do { 
			set CRLMT=ln.crlmt  // Credit Limit
			set CRLMT=CRLMT.zero(9,2,1)
			}
		else  set CRLMT=""

		set DAA=ln.daa	          // Daily Accrual
		set DAA=DAA.zero(9,5,1)

		set POAM=ln.poam          // Payoff Amount
		set POAM=POAM.zero(9,2,1)

		set SLC=$P(LACCTS(XCID),"|",1)	// Service Line Code
		set SLCDES=$P(LACCTS(XCID),"|",2) // SLC Des.

		set EXTSTR=EXTSTR_FACN_"="_XCID_$S($P(ACCTS(XCID),"|",4)=1:"=J",1:"")_"\"
		set EXTSTR=EXTSTR_SLC_"\"_SLCDES_"\"_SCHND_"\"
		set EXTSTR=EXTSTR_PMT_"\"_BAL_"\"_AVLBAL_"\"_CRLMT_"\"
		set EXTSTR=EXTSTR_DAA_"\"_POAM_"\"
		}
	quit


SLMV(EXTSTR)	// Share and Loan Account Member Verification
 
	do MV(.EXTSTR)                          // Build Customer Info
	do SHA(.EXTSTR)				// Build Share Acct Info

	set EXTSTR=$E(EXTSTR,1,$L(EXTSTR)-1)	// Remove Ending Delimiter
	set EXTSTR=EXTSTR_"&"			// End of Share Info

	do LN(.EXTSTR)				// Build Loan Acct Info
	quit


SLI(EXTSTR)	// Share & Loan Account Inquiry

	set EXTSTR=EXTSTR_SBNCIF("MNAME")_"\"
	do SHA(.EXTSTR)

	set EXTSTR=$E(EXTSTR,1,$L(EXTSTR)-1)    // Remove Ending Delimiter
	set EXTSTR=EXTSTR_"&"                   // End of Share Info
 
	do LN(.EXTSTR)                          // Build Loan Acct Info
	quit


ISP(EXTSTR)	// Investment Account Statement Print
	new SLCTYP
	
	set SLCTYP="I"		// Investment Account
	do STMT(.EXTSTR)	// Generate Statement Info

	quit


SSP(EXTSTR)	// Share Account Statement Print
	new SLCTYP
	
	set SLCTYP="S"		// Share Account
	do STMT(.EXTSTR)	// Generate Statement Info
	
	quit


LSP(EXTSTR)	// Loan Account Statement Print
	new SLCTYP

	set SLCTYP="L"		// Loan Account
	do STMT(.EXTSTR)	// Generate Statement Info

	quit


STMT(EXTSTR)	// Compose Statement Information

	new TMP,TRNS,TSEQ
 
	// Confirm that account exists and SLC and Statement Type match
	if ('FCID) set ER=1
	else  if 'Db.isDefined("ACN","FCID") set ER=1
	else  do {
		new DATA,SLC,TYP
		type RecordACN acn=Db.getRecord("ACN","CID=:FCID")
		set SLC=acn.slc

		if SLC="" set ER=1 quit		// No SLC defined

		type RecordSTBLSBSLC stblsbslc=Db.getRecord("STBLSBSLC","SLC=:SLC",1)
		set TYP=stblsbslc.type
		if SLCTYP'=TYP set ER=1  	// Acct Type/Stmt Type Mismatch
	}

	if ER set RSPCD=$S(SLCTYP="S":53,SLCTYP="L":39,SLCTYP="I":44) quit

	set TRNS=0		// Number of Transactions
	set TMP=""
	
	type ResultSet rs = Db.select("TJD,ETC,TAMT,EFD,ENDBAL,TLO", "HIST", "CID=:FCID", "TSEQ DESC")
	
	while rs.next() do { quit:(TRNS > 9)	// Maximum 10

		set TRNS=TRNS+1		   	// Increment transaction counter

		set TRDT = rs.getCol("TJD")	// Transaction Date
		set TRDT = TRDT.toDate().toString("YYMMDD")

		set ETC = rs.getCol("ETC")	// Transaction Code
		if $L(ETC)>10 set ETC=$E(ETC,1,10)

		set TAMT = rs.getCol("TAMT")	// Transaction Amount
		set TMPAMT=TAMT

		/*
		 TAMT is the total amount of the transaction
		 FEES is the total amount of interest (or dividend) + fees + charges
		 PRAMT is the amount of the transaction applied to the balance
		*/

		if TAMT'["#" do {
			set TAMT=TAMT.zero(9,2,1)
			set FEES=0,FEES=FEES.zero(9,2,1)
			set PRAMT=TMPAMT,PRAMT=PRAMT.zero(9,2,1)
			}

		else  do {
			new i
			set TAMT=$P(TAMT,"#",1)
			set TAMT=TAMT.zero(9,2,1)	// Total Amount

			set PRAMT=$P(TMPAMT,"#",2)	// Sh/Inv/Ln Amount
			set PRAMT=PRAMT.zero(9,2,1)

			set FEES=0

			// 48894 - Fix for piece 5 for loans (undisbursed principal)
			for i=3:1:14 set FEES=FEES+$P(TMPAMT,"#",i)

			set FEES=FEES.zero(9,2,1)
			}

		set ENDBAL = rs.getCol("ENDBAL")	// Ending Balance
		if ENDBAL<0 set ENDBAL=ENDBAL*(-1),ENDBAL="-"_ENDBAL.zero(8,2,1)
		else  set ENDBAL=ENDBAL.zero(9,2,1)

		set TLO = rs.getCol("TLO")		// Terminal Location
		if $L(TLO)>15 set TLO=$E(TLO,1,15)
		set TLO=$TR(TLO,"\","-")

		set EFD = rs.getCol("EFD")		// Effective Date
		if EFD="" set EFD=TRDT
		else  set EFD = EFD.toDate().toString("YYMMDD")

		set TMP=TMP_TRDT_"\"_ETC_"\"_TAMT_"\"_FEES_"\"_PRAMT_"\"
		set TMP=TMP_ENDBAL_"\"_TLO_"\"_EFD_"\"
	}

	if TRNS<10 set TRNS="0"_TRNS

	// Compose Extended Field String
	set EXTSTR=EXTSTR_TRNS_SLCTYP_"\"_TMP

	quit


PMT(EXTSTR,RecordTTX ttx())		// Payment Transaction

	new FEES,LCID,NPD,PRAMT,TAMT

	if 'Class.isValid(ttx(2)) quit

	// LCID should be in "TO" transaction
	set LCID=+ttx(2).cid
	if 'Db.isDefined("LN","LCID") quit

	set TAMT=ttx(2).tamt
	if TAMT'["#" do {  if 1
		// 48894 - Handle TAMT '[ # but HIST available
		do HISTFEES(LCID,TAMT,.PRAMT,.FEES)

		set PRAMT=PRAMT.zero(9,2,1)
		set FEES=FEES.zero(9,2,1)
		}

	else  do {
		new i
		set PRAMT=$P(TAMT,"#",2)      // Principal Amount
		set PRAMT=PRAMT.zero(9,2,1)
 
		set FEES=0
		for i=3:1:14 set FEES=FEES+$P(TAMT,"#",i)
		set FEES=FEES.zero(9,2,1)
		}

	type RecordLN ln=Db.getRecord("LN","CID=:LCID",1)
	set NPD=ln.dist1nd
	set NPD=$$DAT^%ZM(NPD,"YYMMDD")

	set EXTSTR=EXTSTR_FEES_"\"_PRAMT_"\"_NPD_"\"

	quit


XFR(EXTSTR,RecordTTX ttx())		// Transfer Transaction

	new ABAL,DATA,FRCID,FRSLC,FRTYP,LBAL,TOCID,TOSLC,TOTYP

	if 'Class.isValid(ttx(1)) quit
	if 'Class.isValid(ttx(2)) quit

        set FRCID=+ttx(1).cid,TOCID=+ttx(2).cid

        if 'Db.isDefined("ACN","FRCID") quit    // From acct can be DEP or LN
	if 'Db.isDefined("DEP","TOCID") quit	// To acct must be a DEP

	type RecordACN acn=Db.getRecord("ACN","CID=:FRCID")
	set FRSLC=acn.slc 
	if FRSLC="" quit
	
	type RecordSTBLSBSLC stblsbslc=Db.getRecord("STBLSBSLC","SLC=:FRSLC")
	set FRTYP=stblsbslc.type

	type RecordACN acn1=Db.getRecord("ACN","CID=:TOCID")
	set TOSLC=acn1.slc
	if TOSLC="" quit
	
	type ResultSet rs=Db.select("SLC","ACN","SLC=:TOSLC")
	if rs.next() set TOTYP=rs.getCol("SLC")

	// AMT1 - Ledger Bal Before Transaction, AMT2 - Available Bal After Transaction
	set LBAL=acn.bal
	set ABAL=acn.balavail

	set EXTSTR=EXTSTR_"2\"_LBAL.zero(9,2,1)_"\1\"_ABAL.zero(9,2,1)_"\"

	set (ABAL,LBAL)=0

	set LBAL=acn1.bal
	set ABAL=acn1.balavail

	set EXTSTR=EXTSTR_"2\"_LBAL.zero(9,2,1)_"\1\"_ABAL.zero(9,2,1)_"\"

	quit


PMTXFR(EXTSTR,RecordTTX ttx())	// Payment Transfer

	new ABAL,DATA,FEES,FRCID,FRSLC,LBAL,NPD,PRAMT,TAMT,TOCID
	type public String FRTYP

	if 'Class.isValid(ttx(1)) quit
	if 'Class.isValid(ttx(2)) quit

	set FRCID=+ttx(1).cid,TOCID=+ttx(2).cid

	if 'Db.isDefined("ACN","FRCID") quit    // From acct can be DEP or LN
	if 'Db.isDefined("LN","TOCID") quit    // To acct must be a LN

	type RecordACN acn=Db.getRecord("ACN","CID=:FRCID")
	set FRSLC=acn.slc
	if FRSLC="" quit
	
	type RecordSTBLSBSLC stblsbslc=Db.getRecord("STBLSBSLC","SLC=:FRSLC")
	set FRTYP=stblsbslc.type
	// AMT1 - Ledger Bal Before Transaction, AMT2 - Available Bal After Transaction
      
        set LBAL=acn.bal
        set ABAL=acn.balavail
 
        set EXTSTR=EXTSTR_"2\"_LBAL.zero(9,2,1)_"\1\"_ABAL.zero(9,2,1)_"\"

	set (ABAL,LBAL)=0

	set TAMT=ttx(2).tamt
	if TAMT'["#" do {  if 1
		// 48894 - TAMT '[ # but HIST may be available
		do HISTFEES(LCID,TAMT,.PRAMT,.FEES)

		set PRAMT=PRAMT.zero(9,2,1)
		set FEES=FEES.zero(9,2,1)
		}

	else  do {
		new i,TMPAMT

		set TMPAMT=TAMT
		set TAMT=$P(TMPAMT,"#",2)
		set PRAMT=TAMT.zero(9,2,1)
		set FEES=0
                for i=3:1:14 set FEES=FEES+$P(TMPAMT,"#",i)
                set FEES=FEES.zero(9,2,1)
		}

	type RecordACN acn1=Db.getRecord("ACN","CID=:TOCID")
	set LBAL=acn1.bal
	set ABAL=acn1.balavail

	set EXTSTR=EXTSTR_"2\"_LBAL.zero(9,2,1)_"\1\"_ABAL.zero(9,2,1)_"\"	

	type RecordLN ln=Db.getRecord("LN","CID=:TOCID")
	set NPD=ln.dist1nd
	set NPD=$$DAT^%ZM(NPD,"YYMMDD")
	
	set EXTSTR=EXTSTR_FEES_"\"_PRAMT_"\"_NPD_"\"

	quit


CIFINIT(BIT,SBNCIF)	// Initialize SBN-specific customer data
	/*
	 This section builds member information for member verification
	 requests and builds account lists (via calls to CIDSORT) for
	 both member verifications and account inquiries.

	 ARGUMENTS
		. BIT		BIT array		/TYP=T/REQ/MECH=REF
		. SBNCIF	Customer Info Array	/TYP=T/REQ/MECH=REF
 
	 RETURNS
		SBNCIF  - Array of Customer information formatted for SBN
		    SBNCIF("MNAME")             - Member Name (max 30 chars)
	 	    SBNCIF("JNAME")             - Joint Owner Name (max 30 chars)
		    SBNCIF("ADDR")              - Permanent Street Address (max 28)
		    SBNCIF("CITY")              - Permanent City (max 15)
		    SBNCIF("STATE")             - Permanent State (fixed 2)
		    SBNCIF("ZIP")               - Permanent ZIP Code (fixed 10)
		    SBNCIF("SSN")               - Social Sec. Nbr./Tax ID (fixed 9)
		    SBNCIF("PHONE")             - Home Phone Number (fixed 10)

		LACCTS	- Array of Loan Accounts
		SACCTS	- Array of Share Accounts
		IACCTS	- Array of Investment Accounts
	*/

	new ACNLEV,BADCID,CTR,CTROFF,i,LCTR,SCTR
	type public Number FCID,FACN	
 
	set (ACNLEV,BADCID)=0

	if 'Db.isDefined("CIF","FACN") do {
		if Db.isDefined("ACN","FCID") do {
			type RecordACN acn=Db.getRecord("ACN","CID=:FCID")
			set FACN=acn.acn
			set ACNLEV=1	// PK 46293:014
			}
		else  set BADCID=1
		}

	if BADCID do {  quit
		new TQUAL
		if QUAL2=0 set TQUAL=QUAL1
		else  set TQUAL=QUAL2
		set TQUAL=$E(TQUAL,1)
		set RSPCD=$S(TQUAL="S":53,TQUAL="L":39,TQUAL="I":44,1:88)
		set ER=1
		}
 
	new DATA,TEMP
	type RecordCIF cif=Db.getRecord("CIF","ACN=:FACN")
        
	// Compose SBN-formatted Member Name
	set TEMP=cif.nam
	if $L(TEMP)>30 set TEMP=$E(TEMP,1,30)
	set SBNCIF("MNAME")=TEMP

	// If this is an inquiry, get all acct info and quit
	if ($E(QUAL1,3)="I") do ACCTS quit
 
	// Compose SBN-formatted Street Address
	set TEMP=cif.pad1
	if $L(TEMP)>28 set TEMP=$E(TEMP,1,28)
	set SBNCIF("ADDR")=TEMP
 
	// Compose SBN-formatted City
	set TEMP=cif.pcity
	if $L(TEMP)>15 set TEMP=$E(TEMP,1,15)
	set SBNCIF("CITY")=TEMP
 
	// Compose SBN-formatted State
	set SBNCIF("STATE")=cif.pstate

	// Compose SBN-formatted ZIP - Fixed 10 chars
	set TEMP=cif.pzip
	set SBNCIF("ZIP")=TEMP.blank(10)	// Blank fill
 
	// Compose SBN-formatted SSN/Tax ID - Fixed 9 chars
	set TEMP=cif.taxid
	set TEMP=$TR(TEMP,"-")
	set SBNCIF("SSN")=TEMP.blank(9)		// Blank fill

	// Compose SBN-formatted Phone Number - Fixed 10 chars
	set TEMP=cif.hph
	set TEMP=$TR(TEMP,"-")
	set SBNCIF("PHONE")=TEMP.blank(10)	// Blank fill
 
 	do ACCTS
 	
 	quit
 

ACCTS

	type public Number ACNLEV,CTR,CTROFF,IACCTS,LACCTS,LCTR,MAXCID,SACCTS,SCTR
	type public String ACCTS,CONCTL,JACCTS,SBNCIF,TQUAL,VSLC
	type Number FACN2,i,JOINTMD,PATCTR,XCID

	set FACN2=""

	set PATCTR=0
 
	// Determine joint/sole ownership of FCID
	if ACNLEV do {
		// 46293:036 - Get all joint owners for this account (FCID)
		type Number TMPCNT

		set TMPCNT=0
		
		type ResultSet rs=Db.select("ACN","RELCIF","CID=:FCID")
		
		while rs.next() do {
			set FACN2=FACN2_rs.getCol(1)_$C(9)
			set TMPCNT=TMPCNT+1
			}

		if TMPCNT<2 set FACN2="" quit	  // No Joint Owners

		set FACN2=FACN2.extract(1,FACN2.length()-1) // Remove ending tab
		}

	// Initialize Account Totals
	set (IACCTS,SACCTS,LACCTS)=0

	set (CTR,SCTR,LCTR)=0
	set CTROFF=MAXCID*CONCTL
 
	set ACCTS=0
	set SBNCIF("JNAME")=""	// Initialize to null

	// Get all CID's for this ACN
	type ResultSet rs=Db.select("CID","RELCIF","ACN=:FACN")
 
	// Determine if each account is valid to SBN
	while rs.next() do CIDVER(rs.getCol(1),VSLC,.ACCTS,FACN2)

	// Determine Joint Ownership Mode
	set JOINTMD=$$JOINTMD(.ACCTS,.JACCTS)
		
	/*
	 Loop through ACCTS array and set up SACCTS/LACCTS/IACCTS
	 arrays.  The accounts defined in these arrays will be the 
	 accounts returned in the message.
	*/
	set XCID=""
	for  set XCID=$O(ACCTS(XCID)) quit:XCID=""  do {
		type String XSLC
		set XSLC=ACCTS(XCID).piece("|",1)
		do CIDSORT(XCID,XSLC,0)
		}

	/*
	 After all ACCTS records have been considered, handle
	 returning joint owner names for JM=3 (multiple joint
	 owners on accounts).
	*/
	if JOINTMD=3 do {
		type Number XCID
		set XCID=""
		for  set XCID=$O(JACCTS(XCID)) quit:XCID=""  do {
			new XCIF,XSLC
			set XCIF="",XSLC=ACCTS(XCID).piece("|",1)
			for  set XCIF=$O(JACCTS(XCID,XCIF)) quit:XCIF=""  do {
				do CIDSORT(XCID,XSLC,1)
				}
			}
		}

	// Determine if we need to increment continuation control character
	if TQUAL'="SLI" do {
		if CTR>(CTROFF+MAXCID) set CONCTL=CONCTL+1
		else  set CONCTL=""
		}
	else  do {
		if (SCTR>(CTROFF+MAXCID))!(LCTR>(CTROFF+MAXCID)) set CONCTL=CONCTL+1
		else  set CONCTL=""
		}
	set CONCTL=CONCTL.blank(6)

	quit


CIDVER(CID,VSLC,ACCTS,FACN2)	// Determine if account is valid to SBN

	new ACN,BAL,CLS,DATA,EXIT,GRP,JNTLIST,JNTNUM,ODL,RELC,ROLE,rs,SFX,SLC,STAT

	set PATCTR=PATCTR+1

	set EXIT=0

	/*
	 FACN2 is defined when an ACN with joint owners is used in member
	 verification.  In this situation, only return accounts that are
	 jointly owned by the same CIF's as the ACN.
	*/
	if FACN2'="" do {  quit:EXIT
		new TMPCIF

		set TMPCIF=""

		// Only return accounts with only these joint owners
		type ResultSet rs=Db.select("ACN","RELCIF","CID=:CID")
		if 'rs.isEmpty() while rs.next() do {
			set TMPCIF=TMPCIF_rs.getCol(1)_$C(9)
			}

		set TMPCIF=$E(TMPCIF,1,$L(TMPCIF)-1)	// Remove ending tab

		if TMPCIF'=FACN2 set EXIT=1		// Not the same owners
		}
	else  set ODL=0 do {  quit:'ODL
		new RELC
		type RecordRELCIF RELC=Db.getRecord("RELCIF","FACN,CID")
		set ODL=RELC.ODL
		}

	type RecordACN acn=Db.getRecord("ACN","CID=:CID")
        set SLC=acn.slc
	set STAT=acn.stat
	set CLS=acn.cls
	set GRP=acn.grp
	set BAL=acn.bal
	set ACN=acn.acn
	set RELC=acn.acnrelc

	if STAT=4 quit 		// Account closed
	if VSLC'[SLC quit 	// Not the type of acct requested
	if SLC="" quit 		// No Service Line Code defined
	if RELC="" quit 	// No Relationship Code defined

	// Do not include loans (non-RC only) with a zero balance
	if (CLS="L"),(GRP'="RC"),(BAL=0) quit

	// Relationships need to be defined properly for accounts to be valid
	set ROLE=1
	if 'Db.isDefined("RELCODE","RELC,ROLE") quit

	type RecordRELCODE relcode=Db.getRecord("RELCODE","REL=:RELC,ROLE=:ROLE")
	set SFX=relcode.sfx
	set SFX=$$MC^%ZTEXT(SFX)	// 46356:003 - Set to mixed case

	// Do no include joint "And" accounts
	if SFX["And" quit

	// Account has passed all tests, include in message
	set ACCTS(CID)=SLC,ACCTS=ACCTS+1
	set JNTLIST="",JNTNUM=0

	// Get all CIFs for this account
	type ResultSet rs2=Db.select("ACN","RELCIF","CID=:CID")
	if 'rs2.isEmpty() do {
		while rs2.next() do {
			new XACN
			set XACN=rs2.getCol(1)
			// Build Joint Owner Name list for this account
			if XACN'=ACN set JNTLIST=JNTLIST_XACN_$C(9),JNTNUM=JNTNUM+1
			}
		if (JNTNUM>0) set JNTLIST=$E(JNTLIST,1,$L(JNTLIST)-1)	    // Remove ending tab
		}

	set $P(ACCTS(CID),"|",2)=JNTLIST	// JON List
	set $P(ACCTS(CID),"|",3)=JNTNUM		// Number of JO's

	quit


JOINTMD(ACCTS,JACCTS)		// Determine Joint Ownership Mode

	new CIFLIST,CIFNUM,JM,JOLIST,TOTJNT,XCID

	/*
	 Joint Mode 0 - No joint owners on any accounts
	 Joint Mode 1 - One joint owner on some accounts
	 Joint Mode 2 - One joint owner on all accounts
	 Joint Mode 3 - Multiple joint owners on some or all accounts
	*/
	set XCID="",(JM,JOLIST,TOTJNT)=0

	// Determine Joint Ownership Mode
	for  set XCID=$O(ACCTS(XCID)) quit:XCID=""  do {
		new i,JNTLIST,JNTNUM
		set JNTNUM=$P(ACCTS(XCID),"|",3)
		if 'JNTNUM quit

		// Get joint owner name list
		set JNTLIST=$P(ACCTS(XCID),"|",2)

		// For each joint owner, add entry to JACCTS array
		for i=1:1:JNTNUM do {
			type Number XCIF
			if 'JOLIST(XCIF).data() do {
				type RecordCIF cif=Db.getRecord("CIF","ACN=:XCIF")
				set JOLIST(XCIF)=cif.nam
		        	}
			set JOLIST=JOLIST+1
			set TOTJNT=TOTJNT+1
			set JACCTS(XCID,XCIF)=JOLIST(XCIF)
			}
		}

	// No joint owners on any accounts being returned
	if JOLIST=0 quit 0

	// One joint owner
	if (JOLIST=1) do {  quit JM
		new XCIF,XCIFNAME

		set XCIF=$O(JOLIST(""))
		set XCIFNAME=JOLIST(XCIF)
		if $L(XCIFNAME)>30 set XCIFNAME=$E(XCIFNAME,1,30)
		set SBNCIF("JNAME")=XCIFNAME

		if (ACCTS>TOTJNT) do {
			set XCID=""
			for  set XCID=$O(JACCTS(XCID)) quit:XCID=""  set $P(ACCTS(XCID),"|",4)=1
			set JM=1	// One joint owner on some accounts
			}
		else  set JM=2		// One joint owner on all accounts

		kill JACCTS	// No longer needed
		}

	// Multiple joint owners listed on some or all accounts
	set JM=3

	quit JM
	

CIDSORT(CID,SLC,JM3)	// Account Sorter (by Service Line Code)
	/*
	 This section sets up the SACCTS, IACCTS, and LACCTS array.  These 
	 arrays contain the account numbers, and their corresponding service
	 line codes, that will be included in the reply message.  This
	 section also uses counters to determine how many, and which, accounts
	 should be included so that account information is not duplicated in
	 follow-up inquiries and verifications.
	*/

	new EXIST,SLCDES,SLCTYP

	set EXIT=0

	if TQUAL'="SLI" do {
		set CTR=CTR+1
		if (CTR<(CTROFF+1))!(CTR>(CTROFF+MAXCID)) set EXIT=1
		}
	else  do {
		if (SLC="01")!(SLC="02") do {
			set SCTR=SCTR+1
			if (SCTR<(CTROFF+1))!(SCTR>(CTROFF+MAXCID)) set EXIT=1
			}
		else  do {
			set LCTR=LCTR+1
			if (LCTR<(CTROFF+1))!(LCTR>(CTROFF+MAXCID)) set EXIT=1
			}
		}
	if EXIT quit	// Do not include this account in the reply message

	type RecordSTBLSBSLC stblsbslc=Db.getRecord("STBLSBSLC","SLC=:SLC")
	set SLCTYP=stblsbslc.type
	set SLCDES=stblsbslc.des
	
	/*
	 For Joint Mode 3 (multiple owners on accounts), the CID in
	 the array is flagged as a joint owner name by using a "J"
	 character before and after the account number (with customer
	 number at the end).  This prevents entries from being overridden,
	 and also forces the joint owner names to the bottom of the list
	 (must be last items returned in the message).
	*/
	if JM3 set SLCDES=JACCTS(CID,XCIF),CID="J"_CID_"J"_XCIF

	// Accounts to be returned
	if SLCTYP="I" set IACCTS(CID)=SLC_"|"_SLCDES,IACCTS=IACCTS+1
	else  if SLCTYP="S" set SACCTS(CID)=SLC_"|"_SLCDES,SACCTS=SACCTS+1
	else  if SLCTYP="L" set LACCTS(CID)=SLC_"|"_SLCDES,LACCTS=LACCTS+1

	quit


UPDSTAT		// Update SBN Server Status (SBNET.SBSTAT)

	new BIT70,NEWSTAT,SBSTAT
	type public String INTRFACE
	
	// Only for Network Management Messages (0790, 0800 & 0810)
	if $E(MID,2)'>6 quit

	// Get Old SBN Server Status
	type RecordSBNET sbnet=Db.getRecord("SBNET","INTRFACE=:INTRFACE")
	set SBSTAT=sbnet.sbstat

	set BIT70=$G(BIT(70))
	if BIT70="" set BIT70=$S($G(CODE)="001":0,1:SBSTAT)
	
	set NEWSTAT=$S(BIT70="001":1,BIT70="002":0,1:SBSTAT)

	if SBSTAT=NEWSTAT quit			// Quit if they're the same

	set sbnet.sbstat=NEWSTAT
        do sbnet.save()
        quit


FINCID(XACN,XCID)  // Handle different BIT 102/103 formats for financial msg's
 
	new BADCID,TMPCID
 
	set BADCID=0
	set TMPCID=$P(XCID,"=",2)
 
	// Message uses CIF#=ACCT# format
	if TMPCID'="" do {
		set XCID=TMPCID
 
		// May be right account, definitely wrong customer - fail it
		if 'Db.isDefined("CIF","XACN") set BADCID=1 quit
 
		// Right customer, definitely wrong account - fail it
		if 'Db.isDefined("ACN","XCID") set BADCID=1
		}
 
	// Message uses ACCT#= format
	else  do {
		set XCID=XACN

		// Account specified doesn't exist - fail it
		type RecordACN acn=Db.getRecord("ACN","CID=:XCID",1)
		if 'acn.getMode() set BADCID=1 quit
		set XACN=acn.acn
		}
 
	// Problem encountered during customer/acct verification process
	if BADCID set (XACN,XCID)=0
 
	quit

STATOVR(XCID)	// Determine account status and check restriction authorization

	new DATA,GRP,QTVAR,STAT,STVAR

	if XCID=0 quit 1	// STF must process

	type RecordACN acn=Db.getRecord("ACN","CID=:XCID")
	set GRP=acn.grp
	set STAT=acn.stat

	if 'STAT quit 1		// Account active, processing continues

	set STVAR="STAT"_STAT

	set QTVAR=0
	// Userclass not authorized to override this STAT* restriction
	if 'Db.isDefined("UTBLOVR1","GRP,STVAR,%UserClass") do {  quit QTVAR
		type RecordOVRLIT ovrlit=Db.getRecord("OVRLIT","OVR=:STVAR")
		if 'STF set ER=1,RM=ovrlit.desc,RSPCD="SA"
		set XCID=0,QTVAR=1
		}

	quit 1


HISTFEES(LCID,TAMT,PAMT,FAMT)	// Calculate Principal/Fee & Interest Amounts from HIST

	new HSEQ,SSEQ

	if '$D(HIST(LCID)) set PAMT=TAMT,FAMT=0 quit

	set (HSEQ,SSEQ)=""
	set (PAMT,FAMT)=0
	
	for  set HSEQ=$O(HIST(LCID,HSEQ)) quit:HSEQ=""  do {
		for  set SSEQ=$O(HIST(LCID,HSEQ,SSEQ)) quit:SSEQ=""  do {
			new PCS

			set PCS=$L(HIST(LCID,HSEQ,SSEQ),"|")
			for i=1:1:PCS do {

				new HISTREC,PMTTYP,PMTAMT

				set HISTREC=$P(HIST(LCID,HSEQ,SSEQ),"|",i)

				if HISTREC="" quit

				set PMTTYP=$P(HISTREC,"#",2)
				set PMTAMT=$P(HISTREC,"#",3)

				if PMTTYP="P" set PAMT=PAMT+PMTAMT
				else  set FAMT=FAMT+PMTAMT
				}
			}
		}

	if PAMT+FAMT'=TAMT set PAMT=TAMT,FAMT=0 quit

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60739^53895^Dan Russell^37954"	// Signature - LTD^TIME^USER^SIZE
