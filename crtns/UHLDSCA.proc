UHLDSCA(RecordTTX ttx,RecordACN acn,String H())	/*

	ORIG: CHENARD - 04/20/95
	DESC: Check/Float Hold Utility - used to calculate hold days -
	      based on US regulations.
	
	KEYWORDS:
	
	ARGUMENTS:
	   . ttx - Complete transaction object	       /TYP=RecordTTX/REQ

	   . acn - Account object		       /TYP=RecordACN/REQ

	   . H - Hold array, containing transaction sequences
	       to be processed for allocations.	       /TYP=T/REQ/MECH=REFARRAY
	
	Procedure will update TTXHLD & TTXHLDD with values from the
	levels of the hold table and hold detail table that will be updated 
	upon successful processing of the CR transactions.	
	
	-------Revision History-----------------------------------------------
	
	12/06/06 - KUMARB - CR 24314
		   Modify section SQ in check CHLD=0 to check for NULL too.

	11/30/06 - KinI - CR 24136
		   Modified VALDT section to quit if there is different CID
		   in H() array, otherwise hold amount will be erroneously 
		   increased depending on the number of sequences in H() array. 
		   This happens when transactions are posted simultaneously to
		   more then one account on the teller screen.

	11/08/06 - DHANALAKSHMI R - CR 23554
		   Modified the section SQ to suppress the Check Hold Process
		   if Check Hold is not defined in Available Calculation
		   Formula for the account.

	08/28/06 - KUMARB - CR 22464
		   Modify in the beginning of the section UPDHLD8 to suppress 
		   the Check Hold record creation if Check Hold is not defined 
		   in Available Calculation Formula for the account.
	
	05/25/06 - GIRIDHAL - CR21297
		   Removed code from section GETHOLD which checked for key=13.
		   Also removed references to Split day processing.
		   
	04/14/06 - NATRAJAH - CR 19896
		   Modified UPDHLD section, added HLDSEQ order by clause in 
		   HLDDTL resultset, since for current record HLDSEQ value 
		   need to be unique (i.e. last record HLDSEQ value +1).
		   
	03/13/06 - NATRAJAH - CR 20026
		   Modified VALDT section, initialized acn instead of dep to
		   process loan account also.
		   
	03/08/06 - NATRAJAH - CR 19965
		   . In UHLDSCA section, modified the if condition for UPDHLD 
		     call.
		   . While processing value dated hold transaction, to avoid 
		     undefined CHKTYP error in REGCC section moved line of code
		     from F1 section to UHLDSCA section which set the value to
		     CHKTYP.

	02/06/06 - NATRAJAH - CR 19332
		   . Added condition Check for ttx.trc in UHLDSCA section to
		     avoid GTM error.
		   . Corrected the date manipulation in FILE,F1 and HLDFILE 
		     sections.

	12/12/05 - NATRAJAH - CR 13734
		   . Sections parameters are modified, to accept ttx object 
		     instead of ttx() array object and acn object added as a 
		     parameter. And these objects are processed through out
		     the procedure.
		   . Intialized the CID in VALDT section to avoid undefined
		     CID error for value dated transaction.
		   . Modified X1 section to calculate the check hold expiry
		     date, when CHKTYP values null.		   
		   . Modified the if codition "if '($E(PCF,36)),OLD<100 do {" 
		     statement to create hold entry properly in REGCC section.
		   . Modified FAC section to build the FAC array properly.
		   . Modified UPDHLD section to store the hold data properly.
		   . Modified the UHLDSCA section to call UPDHLD section to
		     update the HLDD,HLD7 and HLD8 tables.		   
		   
	11/16/05 - KELLYP - CR 18175
		   Modified GETHOLD to only "incorporate any holds generated 
		   from the current transaction" if the TTXHLD array exists.
		   This prevents an UNDEFINED error from occuring during 
		   GETHOLD calls that were not initiated for a transaction
		   (e.g., via UAVB).  Also removed pre-2003 revision history.

	01/06/05 - TITOVE - CR 13734
	   	   Cleaned up logic as part of DBI2 project.

	12/30/03 - CARROLLJ - CR7658
		   Corrected precedence errors.

	04/11/03 - Dan Russell - 51351
		   Fix error in GETHOLD section.  HD array should not be
		   public.  Plus, there may be no hold records, so HEFD never 
		   gets defined.  Add quit if that's the case.
	*/

	if 'H.data() quit

	type Public Number TSEQ
	type Public String TTXHLD(),TTXHLDD()

	type Date HEFD,JD,REGCCEXP
	type Number AGG,AMT,CHKAMT,CHKSEQ,CHLD,CHLD0,CID,CNT,EXC,EXCDYS,FHLD
	type Number FHLD0,HLDSEQ,LOG,NEW,NET,OLD,OPT,REGCC,REGCCEXC,SEQ,SQ,TRB,VHLD
	type String CAL(),CHKTYP,ECR,EXCTYP,FAC(),HI(),KEY,REGCCNAM,RT,RVR,%SQ,TRC,X

	set (TRC,SEQ,SQ)=""
	set (AGG,NEW,OLD)=0
	set SAVTJD=%SystemDate
	set TRC=ttx.trc
	if TRC="" set TRC=TSEQ.get()
	if TRC="" quit
	
	// If Check Type is not defined in ttx, get it from TSO field
	set CHKTYP=ttx.chktyp
	if CHKTYP="" set CHKTYP=$$FIELD^UTSO(ttx.tso,"CHKTYP")	

	/* Going through the levels of the H array for each SEQ.  It will
	   create the data for array ttxhld.  TTXHLD will be used by TTXP2 to 
	   update the ^HLD.

	example 

	TTXHLD(SEQ,KEY,CID,DATE)="amt1|bal1"                   

	  -Key,CID and date correspond to the HLD file def keys ^HLD(KEY,CID,DATE).
	   The sequence key will be the sequence number of the ttx object.

	  -Amt1 will be the amount to be added to HLD.AMT on the date the hold
	   expires.

	  -Bal1 will be the amount added to the hold balance (HLD.TOTAMT) the
	   day the hold is placed and the subsequent days in between. 

	TTXHLDD(SEQ,CID,HLDSEQ,CHKSEQ)=hold detail

	  -hldseq and chkseq correspond to the HLDD file def keys
	   ^HLDD(CID,HLDSEQ,CHKSEQ).  

	  -Hold detail are the columns in the hold detail table.

	*/
	
	for  set SEQ=$O(H(SEQ)) quit:SEQ=""  do {

		type String TSO()

		// Check amount
		set CHKAMT=ttx.tamt
	
		do OUT^UTSO(.TSO,ttx.tso)
	
		// Extract Routing & Transit table number from TSO field
		set RT=TSO("RT").get()
	
		// Set reversal and/or error correction indicators
		set RVR=TSO("REV").get()
		set ECR=TSO("EC").get()
		set CHKSEQ=TRC
		set HEFD=ttx.efd 

		if HEFD="" set HEFD=%SystemDate
		set LOG=0
		do SQ(.ttx,acn,SEQ)
		if TTXHLD.data() do UPDHLD(.ttx)
		}	

	quit 
	

SQ(RecordTTX ttx,RecordACN acn,SEQ) // Build hold info for each sequence

	/* 

	Arguments:
 
	. RecordTTX	Transaction Object		/TYP=RecordTTX/REQ
	. acn 		Account object		       	/TYP=RecordACN/REQ
	. SEQ		Transaction Sequence		/TYP=N/REQ/MECH=VAL
 
	*/

	type Public Number AMT,CHLD,CHLD0,CID,FHLD,FHLD0,RCALL,REGCC,SQ,TRB,VHLD
	type Public String ECR,FAC(),H(),KEY,RVR,%SQ
	
	//Value dated transaction
	if H(SEQ,0).data() do VALDT(.ttx,SEQ) quit
	
	if 'RCALL.get(),(RVR.get()!ECR.get()) quit
	
	set SQ=""
	for  set SQ=$O(H(SEQ,SQ)) quit:SQ=""  do {
		set CHLD0=0
		set FHLD0=0
		set AMT=H(SEQ,SQ).piece("|",2) 
		if 'AMT quit 
		set CID=H(SEQ,SQ).piece("|",1)
		if CID'=ttx.cid quit
		set %SQ=H(SEQ,SQ).piece("|",3)
		//Hold days - pre-determined
		set CHLD=H(SEQ,SQ).piece("|",4)
		//Float days - pre-determined
		set FHLD=H(SEQ,SQ).piece("|",5)
		//Value days - pre-determined
		set VHLD=H(SEQ,SQ).piece("|",6)

		// Transaction to Reduce Balance
		set TRB=$S(acn.trb:-1,1:1)

		// Float hold allocation
		if VHLD="" do {
			kill FAC(7) 
			set KEY=7 
			do FLTHLD(.acn) 
			do FILE(.ttx,.acn,KEY,SEQ)
			}

		// Check hold allocation Reg CC Account
		kill FAC(8) 
		set KEY=8 

		set BALAVLCALCFO = $$BALAVLFO^DEPCDI(CID)

		// Suppress check hold if Available Balance Calculation Formula
		// does not include check holds
		if (BALAVLCALCFO.extract(4)'=1) quit

		set REGCC=acn.regcc
		set FHLD0=0

		if CHLD.isNull()!(CHLD=0) set CHLD0=1
		else  do {
			type Number STPOS
			type String HTB
			// Check Hold Routing and Transit Table
			set HTB=acn.hldtbl
			// Check Hold Percentage
			if 'HTB,acn.hldp1="" set HTB=1
			// Determine starting position in the H(SEQ) array
			set STPOS=(HTB*3)-$S(REGCC:1,1:0)
			// If zero-day hold, set the flag
			if H(SEQ).get().piece("|",STPOS)=0 set CHLD0=1
			}

		// Reg CC rules apply, unless it is a zero-day hold
		if REGCC,'CHLD0 do REGCC(.ttx,.acn,SEQ) quit 
		do CHKHLD(.acn,SEQ)
		do FILE(.ttx,.acn,8,SEQ)	
		}
		
	quit 
	
FLTHLD(RecordACN acn) // Determine float hold days/factors

	/* 

	Arguments:
 
	. RecordACN	Account Object		/TYP=RecordACN/REQ

	*/

	type Public Number FHLD,FHLD0,SEQ
	type Public String FAC(),H(),HI()

	type String HLDTBL

	// Float hold table linkage
	set HLDTBL=acn.flttbl
	// Float Hold Percentage
	if 'HLDTBL,acn.fltp1="" set HLDTBL=1
	
	//Float days included in transaction
	if FHLD'="" do { quit
		set HI(7)=FHLD
		set FAC(7,0)=FHLD_"|"_100
		// If zero-day hold, set the flag
		if FHLD=0 set FHLD0=1
		}
	
	if HLDTBL do {
		// Determine starting position in the H(SEQ) array of hold days
		set FAC=(HLDTBL*3)-2
		// Set the number of hold days + 100% of the amount indicator
		set HI(7)=H(SEQ).get().piece("|",FAC)_"|100"
		set FAC(7,0)=H(SEQ).get().piece("|",FAC)_"|100"
		// If zero-day hold, set the flag                
		if H(SEQ).get().piece("|",FAC)=0 set FHLD0=1
		}

		// Load float hold factors - days and percentages, from account record
	else  do {
		set HI(7)="" 
		for FAC=3:4:19 do FAC(.acn,.FAC)
		}
	quit 
	
CHKHLD(RecordACN acn,SEQ) // Determine check hold days/factors

	/*

	Arguments:
 
	. RecordACN	Account Object 			/TYP=RecordACN/REQ
 
	. SEQ		Transaction Sequence		/TYP=N/REQ/MECH=VAL
 
	*/

	type Public Number CHLD,CHLD0,REGCC
	type Public String FAC(),H(),HI()

	type String HLDTBL
	
	// Check hold table linkage
	set HLDTBL=acn.hldtbl
	// Check Hold Percentage
	if 'HLDTBL,acn.hldp1="" set HLDTBL=1
	
	// Hold days included in transaction
	if CHLD'="" do { quit
		set HI(8)=CHLD
		set FAC(8,0)=CHLD_"|"_100
		if CHLD=0 set CHLD0=1
		}
	
	if HLDTBL do {
		// Determine starting position in the H(SEQ) array of hold days
		set FAC=(HLDTBL*3)-$S(REGCC:1,1:0)
		// Set the number of hold days + 100% of the amount indicator
		set HI(8)=H(SEQ).get().piece("|",FAC)_"|100"
		set FAC(8,0)=H(SEQ).get().piece("|",FAC)_"|100"
		if H(SEQ).get().piece("|",FAC)=0 set CHLD0=1
		}

		// Load check hold factors - days and percentages, from account record
	else  do {
		set HI(8)=""
		for FAC=1:4:17 do FAC(.acn,.FAC)
		}
	quit 
	
FILE(RecordTTX ttx,RecordACN acn,KEY,SEQ)

	/* 

	Arguments:
 
	. RecordTTX	Transaction Object 		/TYP=RecordTTX/REQ

	. RecordACN	Account Object 			/TYP=RecordACN/REQ

	. KEY		Float Type			/TYP=N/REQ

	. SEQ		Transaction Sequence		/TYP=N/REQ/MECH=VAL

	*/
	
	type Public Date JD
	type Public String FAC(),HI()

	type Date TJD
	type Number CNT,HTYPE,I,PC5,S
	
	// Effective Date
	if ttx.efd set TJD=ttx.efd
	else  set TJD=SAVTJD
	
	// Check holds use different calendar
	if KEY=8 set HTYPE=1
	else  set HTYPE=0
	
	set CNT=0 
	for I=TJD:1 quit:I=(TJD+HI(KEY)+CNT+1)  do CAL(HTYPE)
	set FAC="" 
	set JD=TJD
	set S=0 
	
	// Process all FAC entries
	for  set FAC=$O(FAC(KEY,FAC)) quit:FAC=""  do F1(.acn,.ttx,SEQ)

	quit 
	

F1(RecordACN acn,RecordTTX ttx,SEQ)	// Sub-procedure for FILE section

	/* 

	Arguments:
	
	. RecordACN	Account Object			/TYP=RecordACN/REQ
 
	. RecordTTX	Transaction Object 		/TYP=RecordTTX/REQ

	. SEQ		Transaction Sequence		/TYP=N/REQ/MECH=VAL

	*/

	type Public Date HEFD,JD,TTXTJD
	type Public Number AMT,CHLD0,CHKAMT,CHKSEQ,CID,CNT,FHLD0,HLDSEQ,NET,REGCC,S,SQ,TRB
	type Public String CAL(),CHKTYP,EXCTYP,FAC(),H(),KEY,RT,TTXHLD(),TTXHLDD()

	type String PC5,X
	
	do acn.setAuditFlag()
	
	if FAC(KEY,FAC).piece("|",1)="",KEY=7 quit 
	if FAC(KEY,FAC).piece("|",1)="",KEY=8,CHKTYP=3 quit 
	// Get the percentage for the current entry in FAC array
	set NET=FAC(KEY,FAC).get().piece("|",2)
	
	// Use currency of the account for rounding calculation
	// Calculate the portion of AMT for the current entry in FAC array
	set NET=$$^SCARND(AMT*NET/100,0,acn.crcd,acn.crcd)
	
	// Start at effective date
	set JD=TJD
	if FAC(KEY,FAC) do {
		set CNT=0
		if 'CAL(JD).get() for  set JD=$O(CAL(JD)) quit:CAL(JD)
		do F2
		}
	
	// REGCC does not apply to zero-day holds                
	if KEY=8,REGCC,'CHLD0 do RCCX(.ttx,SEQ) set EXCTYP=0
	if JD>SAVTJD set S=1
	
	// Account has to be updated with zero-day holds data    
	if KEY=7,FHLD0,JD=SAVTJD set S=1
	if KEY=8,CHLD0,JD=SAVTJD set S=1
	
	if S,KEY=7 set acn.balcol=acn.balcol-(NET*TRB)
	if S,KEY=8 set acn.chkhld=acn.chkhld+NET
	
	do HLDFILE(KEY,TJD,JD,NET,.TTXHLD,SEQ)
	
	set HLDSEQ=ttx.trc
	set X=TTXHLDD(SEQ,CID,HLDSEQ,CHKSEQ).get()
	if X="" set X=CHKTYP_"|"_RT_"|"_CHKAMT_"|"_H(SEQ,SQ).piece("|",2)
	// Hold allocation detail
	set PC5=X.piece("|",5) 
	set:PC5'="" PC5=PC5_"~"
	set PC5=PC5_$S(KEY=7:"FLT",1:"CHK")_"#"_JD_"#"_NET
	set X.piece("|",5)=PC5
	set X.piece("|",6)=HEFD

	set TTXHLDD(SEQ,CID,HLDSEQ,CHKSEQ)=X
	
	quit 
		
F2	// Calculate JD

	type Public Date JD
	type Public Number CNT
	type Public String CAL(),FAC(),KEY
	
	type Number STP
	set STP=0
	
	for  quit:STP  set JD=$O(CAL(JD)) quit:JD=""  do {
		set CNT=CNT+CAL(JD)
		if CNT=(+FAC(KEY,FAC)) set STP=1
		}
	
	quit 
	
FAC(RecordACN acn,FAC)	// Build FAC

	/*
	Arguments:

	. RecordACN	Account Object 			/TYP=RecordACN/REQ
 
	Returns:
 
	. FAC		Float hold information		/TYP=ARRAY
 
	*/

	type Public String HI(),KEY

	type String X1,X2

	if FAC=1 do {
		set X1=acn.hldp1
		set X2=acn.hldd1
		}
	if FAC=3 do {
		set X1=acn.fltp1
		set X2=acn.fltd1
		}
	if FAC=5 do {
		set X1=acn.hldp2
		set X2=acn.hldd2
		}
	if FAC=7 do {
		set X1=acn.fltp2
		set X2=acn.fltd2
		}
	if FAC=9 do {
		set X1=acn.hldp3
		set X2=acn.hldd3
		}
	if FAC=11 do {
		set X1=acn.fltp3
		set X2=acn.fltd3
		}
	if FAC=13 do {
		set X1=acn.hldp4
		set X2=acn.hldd4
		}
	if FAC=15 do {
		set X1=acn.fltp4
		set X2=acn.fltd4
		}
	if FAC=17 do {
		set X1=acn.hldp5
		set X2=acn.hldd5
		}
	if FAC=19 do {
		set X1=acn.fltp5
		set X2=acn.fltd5
		}

	if X1.isNull() quit	
	set FAC(KEY,FAC)=X2_"|"_X1
	set:X2>HI(KEY) HI(KEY)=X2
	quit 
	

REGCC(RecordTTX ttx,RecordACN acn,SEQ) // Reg CC considerations

	/* 

	Arguments:
 
	. RecordTTX	Transaction Object 		/TYP=RecordTTX/REQ

	. RecordACN	Account Object 			/TYP=RecordACN/REQ

	. SEQ		Transaction Sequence		/TYP=N/REQ/MECH=VAL
 
	*/

	type Public Date REGCCEXP
	type Public Number AMT,AGG,CID,EXC,NEW,OLD,OPT,REGCCEXC
	type Public String CHKTYP,ETC,EXCTYP,FAC(),HI()

	type Number PCF
	type String TRNTYP

	set EXCTYP=0
	// Reg CC Exception Account
	set REGCCEXC=acn.regccexc
	// Reg CC Exception Expiration Date
	set REGCCEXP=acn.regccexp
	if REGCCEXC,REGCCEXP,%SystemDate'<REGCCEXP set REGCCEXC=""
	// New account exception rules apply
	if REGCCEXC=1 do X1(.ttx,.acn,SEQ) quit
	
	/* CHKTYP - Check type
	          1 = Treasurer's checks, postal money orders, etc.
	          2 = Mail, night deposit, etc.
	          3 = Hold based on R&T number
	          4 = Redeposit exceptions
	          5 = Doubtful collection
	*/

	// One day hold applies to entire amount for check type 1
	if CHKTYP=1 do { quit
		set (HI(8),FAC(8,0))="1|100" 
		do FILE(.ttx,.acn,8,SEQ) 
		}	

	// Aggregate by account (REGCCOPT=0) or by customer (REGCCOPT=1)
	set OPT=$S(CUVAR.regccopt:acn.acn,1:CID)
	
	/* AGG - Daily aggregate check deposit amount
	       If REGCCEXC=1 total account CHKTYP 1 & 2 amounts
	       Otherwise, total primary customer CHKTYP 3 amounts
	
	 OLD - $100 one day availability amount consumed
	       Does not apply to new accounts
	       Check type 1 not included
	
	 NEW - Additional amount added to OLD
	
	 EXC - Exception amount
	
	*/

	type RecordDAYENDRCC0 rcc0=Db.getRecord("DAYENDRCC0","TJD=:%SystemDate,OPT=:OPT",1)
	if rcc0.getMode() do {
		set AGG=rcc0.agg
		set OLD=rcc0.one
		set NEW=0
		}

	// One day hold applies to first $100 for all check types if Disable
	// Reg CC processing flag for the transaction code is not set 

	type RecordTRN trn=Db.getRecord("TRN","ETC=:ttx.etc")
	set TRNTYP=trn.trntyp
	set PCF=trn.pcf
	
	if ETC="" set ETC=ttx.etc

	// Disable Reg CC Processing
	if '($E(PCF,36)),OLD<100 do {
		do ONE(.ttx,.acn,SEQ) 
		set AMT=AMT-NEW 
		if 'AMT,CHKTYP'=3 do XDE0 quit
		}

	// Two day hold applies to remaining amount for check type 2
	if CHKTYP=2 do { quit
		set (HI(8),FAC(8,0))="2|100" 
		do XDE0 
		do FILE(.ttx,.acn,8,SEQ) 
		}
	
	// Determine exception amount and apply hold, if applicable
	set EXC=$S(REGCCEXC!(CHKTYP>3):AMT,AGG+AMT+NEW>5000:AGG+AMT+NEW-5000,1:0)
	set:EXC>AMT EXC=AMT 
	if EXC do {
		do EXC(.ttx,.acn,SEQ) 
		set AMT=AMT-EXC
		}

	// Update daily aggregate amounts in DAYEND REGCC tables and apply
	// holds on non-exception based amounts
	if CHKTYP=3 set AGG=AGG+AMT+NEW+EXC

	do XDE0 

	if AMT do {
		do CHKHLD(.acn,SEQ) 
		do FILE(.ttx,.acn,8,SEQ)
		}
	quit 
	
XDE0	//

	type Public Number AGG,NEW,OLD,OPT
	type Public String RCALL

	// Do not build DAYEND global if RECALC1 is the calling routine
	if RCALL.get() quit 
	
	type RecordDAYENDRCC0 dercc0=Db.getRecord("DAYENDRCC0","TJD=:%SystemDate,OPT=:OPT",1) 
	set dercc0.tjd=%SystemDate 
	set dercc0.opt=OPT 
	set dercc0.agg=AGG 
	set dercc0.one=(OLD+NEW) 
	do dercc0.bypassSave() 
	
	quit	

X1(RecordTTX ttx,RecordACN acn,SEQ)	// New account exception (risky depositor)

	/* 

	Arguments:
 
	. RecordTTX	Transaction Object 		/TYP=RecordTTX/REQ	

	. SEQ		Transaction Sequence		/TYP=N/REQ/MECH=VAL
 
	   Check types 3 extends holds by the number of days in [CUVAR]REGCC2
	     up to a maximum of [CUVAR]REGCCNAM
	   Check types 4 extends holds by the number of days in [CUVAR]REGCC4
	   Check types 5 extends holds by the number of days in [CUVAR]REGCC6
	*/

	type Public Number AGG,AMT,EXC
	type Public String CHKTYP,FAC(),HI()

	type Number DYS,TEMPCHKTYP

	if CHKTYP>2 do { quit
		set EXC=AMT 
		do EXC(.ttx,.acn,SEQ) 
		}

	/* Check types 1 and 2 amounts > $5000 are held for the number
	 of days in [CUVAR]REGCC1.  Amounts < $5000 are held 1 day
	 for check type 1, 2 days for check type 2.	
	*/	
	set AGG=0
	type RecordDAYENDRCC1 rcc1=Db.getRecord("DAYENDRCC1","TJD=:%SystemDate,CID=:ttx.cid",1)
	if rcc1.getMode() set AGG=rcc1.agg

	// Determine exception amount; update daily aggregate amounts
	set EXC=$S(AGG+AMT>5000:AGG+AMT-5000,1:0) 
	set AGG=AGG+AMT
	set:EXC>AMT EXC=AMT
	
	if CHKTYP="" set TEMPCHKTYP=acn.hldd1
	else  set TEMPCHKTYP=CHKTYP

	if TEMPCHKTYP>CUVAR.regccnam set TEMPCHKTYP=CUVAR.regccnam
	
	// Update daily aggregate amounts and DAYEND.
	// Apply holds on both non-exception & exception amounts.
	do XDE1
	set AMT=AMT-EXC 
	if AMT do {
		set (HI(8),FAC(8,0))=TEMPCHKTYP_"|100" 
		do FILE(.ttx,.acn,8,SEQ)
		}
	if EXC do {
		set AMT=EXC 
		do EXCDYS 
		set (HI(8),FAC(8,0))=DYS_"|100" 
		do FILE(.ttx,.acn,8,SEQ)
		}
	quit 
	
XDE1	// Do not build DAYEND global if RECALC1 is the calling routine

	type Public Number AGG,CID
	type Public String RCALL

	if RCALL.get() quit

	type RecordDAYENDRCC1 dercc1=Db.getRecord("DAYENDRCC1","TJD=:%SystemDate,CID=:CID",1)

	if dercc1.getMode() set dercc1.agg=AGG

	else  do {
		set dercc1.tjd=TJD
		set dercc1.cid=CID
		set dercc1.agg=AGG
		}

	do dercc1.bypassSave() 

	quit 
	
ONE(RecordTTX ttx,RecordACN acn,SEQ)	// Apply one day hold on first $100
	/* 

	Arguments:
 
	. RecordTTX	Transaction Object 		/TYP=RecordTTX/REQ

	. RecordACN	Account Object 			/TYP=RecordACN/REQ

	. SEQ		Transaction Sequence		/TYP=N/REQ/MECH=VAL
 
	*/

	type Public Number AMT,NEW,OLD

	// Additional qualifying amount
	set NEW=$S(OLD+AMT>100:100-OLD,1:AMT)

	type Number AMT
	type String FAC(),HI() 
	
	set (HI(8),FAC(8,0))="1|100"
	set AMT=NEW
	
	do FILE(.ttx,.acn,8,SEQ)
	quit 
	

EXC(RecordTTX ttx,RecordACN acn,SEQ)	// Apply hold on exception amount

	/* 

	Arguments:
 
	. RecordTTX()	Transaction Object 		/TYP=RecordTTX/REQ

	. RecordACN	Account Object 			/TYP=RecordACN/REQ

	. SEQ		Transaction Sequence		/TYP=N/REQ/MECH=VAL
 
	*/

	type Public Number EXC
	type Public String EXCTYP

	type Number AMT,DYS
	type String FAC(),N,HI(),X

	set AMT=EXC
	do EXCDYS 
	do CHKHLD(.acn,SEQ)
	set N=""
	
	// Extend R&T hold days by institution level exception days
	for  set N=$O(FAC(8,N)) quit:N=""  do {
		set X=+FAC(8,N)+DYS
		// New acct max
		if EXCTYP=2,CUVAR.regccnam'="",X>CUVAR.regccnam set X=CUVAR.regccnam
		set FAC(8,N).piece("|",1)=X
		if X>HI(8) set HI(8)=X
		}
	
	do FILE(.ttx,.acn,8,SEQ)
	
	quit 
	

EXCDYS	// Exception days

	type Public Number REGCCEXC
	type Public String CHKTYP,EXCTYP

	// Redeposited checks
	if CHKTYP=4 do { quit
		set EXCTYP=4 
		do E1
		}
		
	// Doubtful collection
	if CHKTYP=5 do { quit
		set EXCTYP=6 
		do E1
		}

	// New account
	if REGCCEXC=1 do { quit
		set EXCTYP=$S(CHKTYP<3:1,1:2) 
		do E1
		}

	// Repeat O/D; large deposits
	if CHKTYP=3 do { quit
		set EXCTYP=$S(REGCCEXC=2:5,1:3) 
		do E1
		}
	quit 
	
E1	//
	type Public Number DYS,EXCTYP,LOG

	set DYS=$S(EXCTYP=1:CUVAR.regcc1,EXCTYP=2:CUVAR.regcc2,EXCTYP=3:CUVAR.regcc3,EXCTYP=4:CUVAR.regcc4,EXCTYP=5:CUVAR.regcc5,EXCTYP=6:CUVAR.regcc6)
	if DYS set LOG=1
 	quit 
	

RCCX(RecordTTX ttx,SEQ)	// Log exceptions

	/* 

	Arguments:
 
	. RecordTTX	Transaction Object 		/TYP=RecordTTX/REQ

	. SEQ		Transaction Sequence		/TYP=N/REQ/MECH=VAL
 
	*/

	type Public Date JD
	type Public Number AMT,BRCD,CID
	type Public String EXCTYP,RCALL,TRC

	type String X

	// Do not build DAYEND global if RECALC1 is the calling routine
	if RCALL.get() quit

	set X=Db.nextVal("DAYENDRCCX2","%SystemDate,BRCD,%UserID,TRC")

	type RecordDAYENDRCCX2 derccx2=Class.new("RecordDAYENDRCCX2") 
	set derccx2.tjd=%SystemDate
	set derccx2.brcd=BRCD
	set derccx2.uid=%UserID
	set derccx2.tseq=TRC
	set derccx2.cid=CID
	set derccx2.seq=X
	set derccx2.exctyp=EXCTYP
	set derccx2.hldexp=JD
	set derccx2.excamt=AMT
	
	do derccx2.bypassSave() 
	
	quit 
	

CAL(HTYPE)	// Handle non-business days

	/*
	
	   ARGUMENTS:
	
	   . HTYPE Hold Type  /TYP=N/REQ/MECH=VAL
	
	      0 = Float Hold
	      1 = Check Hold
	*/

	type Public Number CNT,I
	type Public String CAL()

	type Number NBDAYS
	type String CALTYPE

	if HTYPE set CALTYPE="FED"
	else  set CALTYPE="IBS"
	
	set NBDAYS='$$BD^UNBD(I,CALTYPE)
	set CNT=CNT+NBDAYS 
	set CAL(I)='NBDAYS
	quit 
	
VALDT(RecordTTX ttx,	// Transaction Object 
      Number SEQ)	// Transaction Sequence

	type public Number CHLD0,FHLD0
	type public String H(),TTXHLD()

	type Date EFD,VALDT
	type Number AMT,CID,VHLD
	type String ETC
	
	/* 
	  When transactions are posted simultaneously to more then one account,
	  H() array contains info for different CIDs. Make sure hold is filed
	  to correct account. 
	*/
	if H(SEQ,0).piece("|",1) '= ttx.cid quit
	
	// Value date hold cannot be a zero-day hold
	set (CHLD0,FHLD0)=0
	set CID=ttx.cid
	
	set AMT=ttx.tamt
	set AMT=$S(AMT["#":AMT.piece("#",2),1:AMT)
	set EFD=ttx.efd
	set:EFD="" EFD=%SystemDate
	if 'ttx.itc.extract() set AMT=-AMT
	
	// Set Value hold days if they were not set already in H array
	set VHLD=H(SEQ,0).piece("|",6)
	if VHLD="" set VHLD=ttx.vdt-EFD
	set VALDT=EFD+VHLD
	
	// Transaction to Reduce Balance
	type RecordACN acn=Db.getRecord("ACN","CID=:ttx.cid")
	if acn.trb set AMT=-AMT
	
	do HLDFILE(7,EFD,VALDT,AMT,.TTXHLD,SEQ)
	
	quit
	
	
HLDFILE(KEY,EFD,EXP,AMT,TTXHLD,SEQ)

	/*
	   ARGUMENTS:
	    . KEY Hold Type  			/TYP=N/REQ/MECH=VAL
	     	7 = Float/Value Hold
	     	8 = Check Hold
	
	    . EFD Hold effective date 		/TYP=D/REQ/MECH=VAL
	
	    . EXP Hold expiration date 		/TYP=D/REQ/MECH=VAL
	
	    . AMT Hold amount  			/TYP=$/REQ/MECH=VAL
	    
	    . TTXHLD Hold array			/TYP=ARR/REQ/MECH=REFARR:RW
	    
	    . SEQ Hold transaction sequence	/TYP=N/REQ/MECH=VAL

	RETURNS:

	    . TTXHLD Hold entries for ^HLD
	
	*/

	type public Number CID,CHLD0,FHLD0

	type Date DT
	type Number ZHFLG
	
	// Set the flag for zero-day holds                       
	if FHLD0.get()!CHLD0.get() set ZHFLG=1
	else  set ZHFLG=0
	
	for DT=EFD:1:(EXP-1) quit:DT>TJD  do {
		
		// Create new entry for each DT between EFD & EXP if necessary
		if 'TTXHLD(SEQ,KEY,CID,DT).data() do {
			set TTXHLD(SEQ,KEY,CID,DT).piece("|",1)=0
			set TTXHLD(SEQ,KEY,CID,DT).piece("|",2)=AMT
			}
		else  set TTXHLD(SEQ,KEY,CID,DT).piece("|",2)=TTXHLD(SEQ,KEY,CID,DT).piece("|",2)+AMT
		
		if 'TTXHLD(SEQ,KEY,CID,DT).piece("|",1),'TTXHLD(SEQ,KEY,CID,DT).piece("|",2),DT'=EFD kill TTXHLD(SEQ,KEY,CID,DT) quit
		}


	// Set/update the piece 1 expiration amount for hold expiration date
	
	if 'TTXHLD(SEQ,KEY,CID,EXP).data() do {
		set TTXHLD(SEQ,KEY,CID,EXP).piece("|",1)=AMT
		set TTXHLD(SEQ,KEY,CID,EXP).piece("|",2)=0
		}
	else  set TTXHLD(SEQ,KEY,CID,EXP).piece("|",1)=TTXHLD(SEQ,KEY,CID,EXP).piece("|",1)+AMT

	if EXP'>TJD,'TTXHLD(SEQ,KEY,CID,EXP).piece("|",2),'ZHFLG set TTXHLD(SEQ,KEY,CID,EXP).piece("|",2)=TTXHLD(SEQ,KEY,CID,EXP).piece("|",2)-AMT
		
	quit 

public GETHOLD(KEY,CID,STDT,ENDDT,HOLD)	//PReturns an array of total hold amounts

	/*	
	   This function is used to build an array of hold amounts outstanding
	   for each record in the ^HLD, starting at the date passed in (STDT).
	   It should be outside of any loop to minimize disk access. Routines
	   that will use this information will be able to get it directly from
	   the array, therefore minimizing the processing time required.
	   The valid values for KEY argument are 7, 8 and 13 only.
	
	   ARGUMENTS:

	   . KEY     Hold Type  	         /TYP=N/REQ/MECH=VAL
	             7 = Float/Value Hold
	             8 = Check Hold
	
	    . CID     Profile Account Number 	/TYP=N/REQ/MECH=VAL
	
	    . STDT    Starting Date       	/TYP=D/REQ/MECH=VAL
	
	    . ENDDT   Ending Date           	/TYP=D/REQ/MECH=VAL
	
	    . HOLD()  Array of holds     	 /TYP=ARRAY/REQ/MECH=REFARR
	
	   RETURNS:
	    . HOLD()  Array of total hold amounts
	*/

	type public Number SEQ
	type public String TTXHLD()

	kill HOLD(KEY,CID)
	set HOLD(KEY,CID)=""

	// The value of KEY can only be 7 (float/value holds), 8 (check holds)
	if KEY'=7,KEY'=8,KEY'=13 quit 
	
	type Date HEFD
	type Number AMT,ALCAMT,TOTAMT
	type String HD

	// Accumulate all the hold records in HD array, starting with
	// the entry prior to STDT
	if KEY=7 do {
		type ResultSet rs=Db.select("EXPDT,AMT,TOTAMT","HLD7","CID=:CID AND EXPDT=:STDT OR EXPDT>:ENDDT","EXPDT DESC")
		if rs.isEmpty() quit
		while rs.next() do {
			set HEFD=rs.getCol(1)
			set AMT=rs.getCol(2)
			set TOTAMT=rs.getCol(3)

			set HD(KEY,HEFD)=AMT_"|"_TOTAMT
			}
		}

	if KEY=8 do {
		type ResultSet rs=Db.select("EXPDT,AMT,TOTAMT,ALCAMT","HLD8","CID=:CID AND EXPDT=:STDT OR EXPDT>:ENDDT","EXPDT DESC")
		if rs.isEmpty() quit
		while rs.next() do {
			set HEFD=rs.getCol(1)
			set AMT=rs.getCol(2)
			set TOTAMT=rs.getCol(3)
			set ALCAMT=rs.getCol(4)

			set HD(KEY,HEFD)=AMT_"|"_TOTAMT_"|"_ALCAMT
			}
		}


	quit:'$D(HD)		// No hold entires
	
	// Incorporate any holds generated from the current transaction
	if TTXHLD(SEQ,KEY,CID,HEFD).exists() for  set HEFD=$O(HD(KEY,HEFD)) quit:HEFD=""  do {
		type String A,B
		set A=HD(KEY,HEFD)
		set B=TTXHLD(SEQ,KEY,CID,HEFD)
		set HD(KEY,HEFD)=(A.piece("|",1)+B.piece("|",1))_(A.piece("|",2)+B.piece("|",2))
		}
	
	// Set up HOLD record for each hold date
	set HEFD=""
	for  set HEFD=$O(HD(KEY,HEFD)) quit:HEFD=""  set HOLD(KEY,CID,HEFD)=HD(KEY,HEFD).piece("|",2)
	
	quit 
	
GETPHOLD(KEY,CID,STDT,ENDDT,PHOLD)	

	/*	
	   This function is used to build an array of permanent hold amounts
	   It should be outside of any loop to minimize disk access. Routines
	   that will use this information will be able to get it directly from
	   the array, therefore minimizing the processing time required.
	
	   ARGUMENTS:
	    . KEY   Hold Type           /TYP=N/REQ/MECH=VAL
	            3 = Permanent Hold
	            9 = ATM Permanent Hold
	
	    . CID     Profile Account Number /TYP=N/REQ/MECH=VAL
	
	    . STDT    Starting Date       /TYP=D/REQ/MECH=VAL
	
	    . ENDDT   Ending Date  /TYP=D/REQ/MECH=VAL
	
	    . PHOLD()  Array of holds    /TYP=ARRAY/REQ/MECH=REFARR:RW

	*/
	kill PHOLD(KEY,CID)
	set PHOLD(KEY,CID)=""
	
	type Date HLDEXP,HLDSTDT
	type Number AREF,HLDAMT,HLDSEQ,PERCNT
	type String HLDREC
	
	// Go through all permanent hold records
	set HLDSEQ=""
	if KEY=3 do {
		type ResultSet rs=Db.select("THLDAMT","PHLD","CID=:CID AND STDT <= :ENDDT AND ( EXPDT IS NULL OR EXPDT > :STDT )")  
		if rs.isEmpty() quit
		while rs.next() do {
			set HLDAMT=rs.getCol("THLDAMT")
			do COMP
			}
		}

	if KEY=9 do {
		type ResultSet rs=Db.select("EXPTM,EXPDT,AMT","PHLD9","CID=:CID")  
		if rs.isEmpty() quit
		while rs.next() do {
			set HLDSTDT=rs.getCol(1)
			set HLDEXP=rs.getCol(2)
			if HLDSTDT>ENDDT quit
			if ((HLDEXP'="")&(HLDEXP'>STDT)) quit	
			set HLDAMT=rs.getCol(3)
			do COMP
			}
		}
	quit
	

COMP	//

	type Public Date HLDEXP,HLDSTDT
	type Public Number HLDAMT,CID
	type Public String KEY,PHOLD()

	type Date JD
	type Number PREVAMT

	set JD=$O(PHOLD(KEY,CID,HLDSTDT+1),-1)
	if JD set PREVAMT=PHOLD(KEY,CID,JD)
	else  set PREVAMT=0
	set PHOLD(KEY,CID,HLDSTDT)=HLDAMT+PREVAMT
	set JD=HLDSTDT
	for  set JD=$O(PHOLD(KEY,CID,JD)) quit:(JD>HLDEXP)!'(JD)  set PHOLD(KEY,CID,JD)=PHOLD(KEY,CID,JD)+HLDAMT
	
	quit
 

UPDHLD(RecordTTX ttxp)	// Updates HLD & HLDD from information stored in TTXHLD & TTXHLDD.

	/*	
	   Updates HLD and HLDD from the information stored in TTXHLD
	   and TTXHLDD arrays.  These are expected to be hanging around.
	   
	ARGUMENTS:
		. ttxp - Complete transaction object         /TYP=RecordTTX/REQ
	INPUTS:
		. TTXHLD  - Hold allocation detail used to update HLD /TYP=T/REQ/MECH=A

		. TTXHLDD  - Hold allocation detail used to update HLDD /TYP=T/REQ/MECH=A

		. SEQ - System sequence number of transaction object to be updated /TYP=N/REQ
	*/

	type Public Number SEQ
	type Public String TTXHLD(),TTXHLDD()

	type Date DATE
	type Number AMT,BAL,CID
	type String KEY

	set CID=ttxp.cid
	set AMT=0
	set BAL=0
	set KEY=""
	
	// Get pieces of HLD info from TTXHLD
	for  set KEY=$O(TTXHLD(SEQ,KEY)) quit:KEY=""  do {
		set DATE=""
		for  set DATE=$O(TTXHLD(SEQ,KEY,CID,DATE)) quit:DATE=""  do {
			set AMT=TTXHLD(SEQ,KEY,CID,DATE).piece("|",1)
			set BAL=TTXHLD(SEQ,KEY,CID,DATE).piece("|",2)
	
			if KEY=7 do UPDHLD7(CID,DATE,AMT,BAL)
			if KEY=8 do UPDHLD8(CID,DATE,AMT,BAL)
			}
		}      

	// Take out Hold detail information from TTXHLDD to update HLDD
	type Date TPD
	type Number CHKSEQ,CNT,HLDSEQ,XTRC	
	set CNT=0 
	set HLDSEQ=""
	for  set HLDSEQ=$O(TTXHLDD(SEQ,CID,HLDSEQ)) quit:HLDSEQ=""  do {
		set CNT=CNT+1
		set CHKSEQ=""
		for  set CHKSEQ=$O(TTXHLDD(SEQ,CID,HLDSEQ,CHKSEQ)) quit:CHKSEQ=""  do {
			set XTRC=ttxp.trc
			if ttxp.tjd.isNull() set TPD=%SystemDate
			else  set TPD=ttxp.tjd
			
			type ResultSet rs=Db.select("TPD,BRCD,TRC,UID,HLDSEQ","HLDDTL","TPD=:TPD AND CID=:CID","HLDSEQ ASC")
			while rs.next() do {
				type Date TJD
				type String BRCD,HLDSEQD,TRC,UID
				set TJD=rs.getCol(1)
				set BRCD=rs.getCol(2) 
				set TRC=rs.getCol(3)
				set UID=rs.getCol(4)
				set HLDSEQD=rs.getCol(5)
				set CNT=HLDSEQD+1
				if TPD=%SystemDate,TRC=XTRC,UID=%UserID do { quit
						
					/*
					Remove HLDD lower levels and HLDDTL if a duplicate of HLDDTL 
					exists.  Based on update of ^HLDD in CRT4.
					*/
					
					set CNT=0
					do Db.fastDelete("HLDD","TJD,CID,HLDSEQ")
					do Db.delete("HLDDTL","SPD=:TPD AND CID=:CID")
					}
				}

			do UPDHLDD(.ttxp,HLDSEQ,.CNT)

			type RecordHLDD hldd=Class.new("RecordHLDD")
			set hldd.tjd=%SystemDate
			set hldd.cid=CID
			set hldd.hldseq=CNT
			set hldd.chkseq=Db.nextVal("HLDD","TJD,CID,HLDSEQ")
			set hldd.trc=ttxp.trc
			set hldd.chktyp=TTXHLDD(SEQ,CID,HLDSEQ,CHKSEQ).piece("|",1)
			set hldd.rt=TTXHLDD(SEQ,CID,HLDSEQ,CHKSEQ).piece("|",2)
			set hldd.chkamt=TTXHLDD(SEQ,CID,HLDSEQ,CHKSEQ).piece("|",3)
			set hldd.hldamt=TTXHLDD(SEQ,CID,HLDSEQ,CHKSEQ).piece("|",4)
			set hldd.chkflt=TTXHLDD(SEQ,CID,HLDSEQ,CHKSEQ).piece("|",5)
			set hldd.ted=TTXHLDD(SEQ,CID,HLDSEQ,CHKSEQ).piece("|",6)
	
			do hldd.bypassSave() 
				
			}
		}
	quit
	
UPDHLDD(RecordTTX ttxp,HLDSEQ,CNT)

	/* 

	Arguments:
 
	. RecordTTX	Transaction Object 		/TYP=RecordTTX/REQ

	. HLDSEQ	Hold sequence key		/TYP=N/REQ

	. SEQ		Transaction Sequence		/TYP=N/REQ/MECH=VAL
 	*/

	type Public Number CID
		
	if CNT=0 set CNT=1
	type RecordHLDDTL hlddtl=Class.new("RecordHLDDTL")
	set hlddtl.spd=%SystemDate
	set hlddtl.cid=CID
	set hlddtl.hldseq=CNT
	if ttxp.tjd.isNull() set hlddtl.tpd=%SystemDate
	else  set hlddtl.tpd=ttxp.tjd
	set hlddtl.brcd=BRCD
	set hlddtl.trc=ttxp.trc
	set hlddtl.uid=%UserID
	
	do hlddtl.bypassSave()
	
	quit


UPDHLD7(CID,DATE,AMT,BAL)

	/* The function is used to update ^HLD7

	Arguments:
 
	. CID     Profile Account Number 	/TYP=N/REQ/MECH=VAL

	. DATE	  Hold Date			/TYP=D/REQ/MECH=VAL
	
	. AMT     Hold Amount to add		/TYP=N/REQ/MECH=VAL
	
	. BAL	  Amount to increase total hold /TYP=N/REQ/MECH=VAL
		  balance.		
	*/


	type RecordHLD7 hld7=Db.getRecord("HLD7","CID=:CID,EXPDT=:DATE",1)

	if hld7.getMode() do {
		set hld7.amt=hld7.amt+AMT
		set hld7.totamt=hld7.totamt+BAL
		}

	else  do {
		set hld7.cid=CID
		set hld7.expdt=DATE
		set hld7.amt=AMT
		set hld7.totamt=BAL
		}

	do hld7.bypassSave()

	quit

UPDHLD8(CID,DATE,AMT,BAL)

	/* The function is used to update ^HLD7

	Arguments:
 
	. CID     Profile Account Number 	/TYP=N/REQ/MECH=VAL

	. DATE	  Hold Date			/TYP=D/REQ/MECH=VAL
	
	. AMT     Hold Amount to add		/TYP=N/REQ/MECH=VAL
	
	. BAL	  Amount to increase total hold /TYP=N/REQ/MECH=VAL
		  balance.		
	*/
	
	type String BALAVLCALCFO

	set BALAVLCALCFO = $$BALAVLFO^DEPCDI(CID)
	
	// Suppress check hold if Available Balance Calculation Formula
	// does not include check holds
	if BALAVLCALCFO.extract(4)'=1 quit

	type RecordHLD8 hld8=Db.getRecord("HLD8","CID=:CID,EXPDT=:DATE",1)

	if hld8.getMode() do {
		set hld8.amt=hld8.amt+AMT
		set hld8.totamt=hld8.totamt+BAL
		}

	else  do {
		set hld8.cid=CID
		set hld8.expdt=DATE
		set hld8.amt=AMT
		set hld8.totamt=BAL
		}

	do hld8.bypassSave()

	quit

vSIG()	quit "60607^23249^Balasubramonian Sankar^32021"	// Signature - LTD^TIME^USER^SIZE
