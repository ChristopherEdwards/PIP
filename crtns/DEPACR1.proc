public	DEPACR1(RecordDEP dep, RecordTTX ttx, RecordTRN trn, Number CTL)

	/*
	Adjust Interest Accrued

	Process adjustments to the accrued interest payable fields
	of deposit accounts.

	Called by deposit transaction codes to adjust interest accrued
	amounts.
	
	CALLED BY: ^LNPTS29, deposit accrual adjustment tran codes

	ARGUMENTS:
		. CTL = Passes control variables /TYP=T/REQ/MECH=VAL
		       CTL = 0 - Accrual (POSACR) processing
			     1 - Authorized Negative accrual (NEGACR) processing
			     2 - Unauth Negative accrual (NEGACRUN) processing
			     3 - Available Interest accrual (AIACR) processing
			     4 - Uncollected accrual (UNCACR) processing

	INPUTS:
		. CTL (control variables)

	---- Revision History ------------------------------------------------
	
	07/17/06 - DESHPANDE S K - CR 20748
		   Replaced Transaction variable %TRNPRIM with Transaction 
		   Stored Value.	
	
	01/28/06 - SmithCD - CR 19343 (16890)
		   Made top of procedure public, and perfomred some cleanup.
		   Retrofitted the following change from p01:
		            06/07/03 - STATTOND - CR2916
		   Fixed bug with error correct/reveral when using EXACTACR, 
		   in which the accrual bucket would get updated with an 
		   incorrectly signed amount.
	
	09/28/05 - SAHUN - CR16662
		   Modified the procedure by replacing ttx.tseq#1 check with
		   %TRNPRIM flag since ttx object is not completely built at
		   this point in some situations(e.g during CD renewal).
		   	
	02/01/05 - SmithCD - CR13661
		   Changed occurrence of ITC to ttx.itc in FILE section to 
		   prevent undefined error.

	-----------------------------------------------------------------------
	*/

	type public Boolean ER	

	// Effective dated accrual adjustments are not allowed
	if ttx.getStoredValue("isPrimary"), %EffectiveDate, %EffectiveDate<%SystemDate do Runtime.setErrMSG("DEP", 7766) quit

	type Number ACR, AIACR, SEGEUR, SEGMENT, SEGVAL
	type String TAMT

	do INIT(.dep, .ttx)

	// If segment node is blank (as the case may be if called from RECALSEG)
	// quit from posting routine
	if dep.segflg, 'SEGMENT.isNull(), 'Db.isDefined("DEPSEG", "CID=:dep.cid,SEGMENT=:SEGMENT") quit

	do FILE(.dep, .ttx, .trn) quit:ER

	quit


FILE(RecordDEP dep, RecordTTX ttx, RecordTRN trn)

	// File Data

	type public Boolean ER, TRB
	type public String TAMT
	type public Number ACR, AIACR, CTL, SEGEUR
	
	type Number AMT, EXACTACR

	set AMT = +TAMT

	/*
	  Use exact accrual amount (if specified) to update accrual buckets
	  Exact ACR should always be positive in TSO
	*/
	set EXACTACR = $$FIELD^UTSO(ttx.tso, "EXACTACR")
	if 'EXACTACR.isNull() do {
		if AMT < 0 set AMT = -EXACTACR	// Error correct/reversal
		else  set AMT = EXACTACR	// Regular transaction
		}

	// Do not perform authorizations if called from RECALSEG / EC / REV
	if 'ttx.itc6, 'ttx.itc12, 'SEGEUR do AUT(.dep, .ttx) quit:ER

	// Positive accrual
	if 'CTL set TAMT.piece("#", 3) = TAMT
	// Negative accrual (authorized)
	if CTL=1 set TAMT.piece("#", 6) = TAMT
	// Negative accrual (unauthorized)
	if CTL=2 set TAMT.piece("#", 11) = TAMT
	// Accrued Interest on Available Int
	if CTL=3 set TAMT.piece("#", 14) = TAMT
	// Uncollected accrual
	if CTL=4 set TAMT.piece("#", 18) = TAMT

	set ttx.tamt = TAMT

	// Determine direction

	// Positive bucket amounts
	if 'CTL ! (CTL = 3), 'TRB set AMT = -AMT
	// Negative bucket amounts
	if CTL=1 ! (CTL = 2) ! (CTL = 4), TRB set AMT = -AMT

	set dep.tld = %SystemDate

	if dep.segflg, 'SEGEUR do FILESEG(.ttx, .dep, AMT)
	if 'dep.segflg ! (SEGEUR) do {
		// Positive Accrued Int/Divdo MIN(.ttx)
		if 'CTL set dep.posacr = $$MIN(.dep, .ttx, ACR + AMT)
		// Negative Accrueddo MIN(.ttx)
		if CTL = 1 set dep.negacr = $$MIN(.dep, .ttx, dep.negacr + AMT)
		// Negative Accrued Interest Unauthorizeddo MIN(.ttx)
		if CTL = 2 set dep.negacrun = $$MIN(.dep, .ttx, dep.negacrun + AMT)
		// Available Interest Accrueddo MIN(.ttx)
		if SEGEUR, CTL = 3 set dep.aiacr = $$MIN(.dep, .ttx, AIACR + AMT)
		if CTL = 4 set dep.uncacr = $$MIN(.dep, .ttx, dep.uncacr + AMT)
		}

	type Number BAL, CMP

	set BAL = dep.posacr
	set CMP = dep.cmp

	// If comp freq. exists restate compounding if accrual is decreased
	if dep.icf, (dep.cmp > BAL) set dep.cmp = BAL
	if dep.cmp '< BAL,'ttx.itc6 set ttx.cmpsav = CMP - BAL
	else  do {
		set dep.cmp = ttx.cmpsav + CMP
		set dep.posacr = BAL
		}
	if dep.cmp < 0 set dep.cmp = 0

	// Update account status
	do ^UPDSTAT(.dep, .trn)

	quit


public EC(RecordDEP dep, RecordTTX ttx, RecordTRN trn, Number CTL)

	/*
	   Called by deposit transaction codes to error correct interest accrued
	   amounts.

	   ARGUMENTS:
	       . CTL = Passes control variables /TYP=T/REQ/MECH=VAL
	               CTL = 0 - Accrual (POSACR) processing
	                     1 - Authorized Negative accrual (NEGACR) processing
	                     2 - Unauth Negative accrual (NEGACRUN) processing
	                     3 - Available Interest accrual (AIACR) processing
	                     4 - Uncollected Uccrual (UNCACR) processing

	   INPUTS:
	       . CTL (control variables)

	*/

	type Number ACR, AIACR, SEGEUR, SEGMENT, SEGVAL
	type String TAMT

	do INIT(.dep, .ttx)

	/*
 	  If segment node is blank (as the case may be if called from RECALSEG)
 	  quit from posting routine
	*/
	if dep.segflg, 'SEGMENT.isNull(), 'Db.isDefined("DEPSEG", "CID=:dep.cid,SEGMENT=:SEGMENT") quit

	if ttx.tso.isLike("%REV#%") do ^UPDCCLD(.dep, .ttx)

	// Account ~p1 not coded for negative accrual
	if (CTL = 1 ! (CTL=2) ! (CTL = 4)),'dep.negacrpo do Runtime.setErrMSG("DEP", 126, dep.cid) quit

	do FILE(.dep, .ttx, .trn)

	quit


AUT(RecordDEP dep, RecordTTX ttx)

	// Authorization Verification

	type public Boolean ER, TRB
	type public Number ACR, AIACR, AMT, CTL, SEGMENT, SEGVAL
	type public String OVR(,,)
	
	type Number RNDACR, RNDAMT

	// Not a Valid Segment for accrual
	if dep.segflg, 'SEGMENT.isNull(), 'SEGVAL do Runtime.setErrMSG("DEP", 7890) quit

	set RNDAMT = $$MIN(.dep, .ttx, AMT)
	set RNDAMT = RNDAMT.roundCur()

	if CTL = 3 do { quit:ER
		// Segments in Use Flag must be on
		if 'dep.segflg do Runtime.setErrMSG("DEP", 7893) quit

		// Available Interest Option must be 2
		if dep.iaf '= 2 do Runtime.setErrMSG("DEP", 7891) quit

		// Available Interest Accrual Flag must be on
		if 'dep.aiacrf do Runtime.setErrMSG("DEP", 7892) quit

		set RNDACR = $$MIN(.dep, .ttx, AIACR)
		set RNDACR = RNDACR.roundCur()

		// Compare transaction amount with accrued interest amount
		// Amount exceeds accrued interest
		if 'TRB, (RNDACR - RNDAMT) < 0 do Runtime.setErrMSG("DEP", 261) quit
		}

	if CTL '= 3 do { quit:ER
		set RNDACR = $$MIN(.dep, .ttx, ACR)
		set RNDACR = RNDACR.roundCur()

		// Compare transaction amount with accrued interest amount
		if 'dep.negacrpo, 'TRB do { quit:ER
			// Account ~p1 not coded for negative accrual
			if CTL = 1 ! (CTL = 2) ! (CTL = 4) do Runtime.setErrMSG("DEP", 126, dep.cid) quit

			// Amount exceeds accrued interest
			if (RNDACR - RNDAMT) < 0, 'dep.minacr.isNull(), dep.minacr ' <0 do Runtime.setErrMSG("DEP", 261) quit
			}
		}

	/*
	  Compare transaction amount with positive (CTL=0) accrued interest
	  or negative (CTL=1) accrued interest amount.
	*/
	if dep.negacrpo do { quit:ER
		type Number RNDNEG

		if CTL = 1 do {
			set RNDNEG = $$MIN(.dep, .ttx, dep.negacr)
			set RNDNEG = RNDNEG.roundCur()
			}
		if CTL = 2 do {
			set RNDNEG = $$MIN(.dep, .ttx, dep.negacrun)
			set RNDNEG = RNDNEG.roundCur()
			}
		if CTL = 4 do {
			set RNDNEG = $$MIN(.dep, .ttx, dep.uncacr)
			set RNDNEG = RNDNEG.roundCur()
			}

		// Amount exceeds negative accrued interest
		if CTL, TRB, (RNDNEG - RNDAMT) < 0 do Runtime.setErrMSG("DEP", 266) quit

		// Amount exceeds positive accrued interest
		if 'CTL, 'TRB, (RNDACR-RNDAMT) < 0 do Runtime.setErrMSG("DEP", 267) quit
		}

	// Restriction Flag
	if dep.rflg do ^UFLG(.dep)

	// Account Status
	if dep.stat set OVR(dep.cid, "OVR", "STAT"_+dep.stat) = ""

	// Outstanding anticipated int/div check <AECOUT>
	if dep.intchk set OVR(dep.cid, "OVR", "AECOUT") = dep.intchk

	quit


INIT(RecordDEP dep, RecordTTX ttx)

	// Initialize data
	
	type public Boolean TRB
	type public String TAMT
	type public Number ACR, AIACR, CTL, SEGEUR, SEGMENT, SEGVAL
	
	set TAMT = +ttx.tamt
	set TRB = dep.trb - ttx.itc1
	set ACR = +dep.posacr
	set SEGEUR = $$FIELD^UTSO(ttx.tso, "SEGEUR")
	set SEGVAL = 0

	if dep.segflg do {
		// Segment Number
		set SEGMENT = $$FIELD^UTSO(ttx.tso, "SEG")
		if dep.segacr ! (SEGEUR) do { quit
			// Segmented account - Accrue at account level
			if CTL=3 set AIACR = dep.aiacr
			}
		// Segmented account - Accrue at segment level
		// Ensure non-null value
		set SEGMENT = +SEGMENT

		type RecordDEPSEG depseg = Db.getRecord("DEPSEG", "CID=:dep.cid,SEGMENT=:SEGMENT")

		set SEGVAL = depseg.segval
		if CTL = 3 set AIACR = depseg.aiacr
		else  set ACR = depseg.posacr
		}

	quit


MIN(RecordDEP dep, RecordTTX ttx, Number TOTAMT)

	/*
	   For primary transactions, set to 0 if less than .01.
	   For secondary transactions, it is up to the originating routine to
	   process this transaction with decimal precision of 5. Then the
	   originating routine must round to the proper decimal precision for
	   the currency of the account before filing.
	   Does not apply if decimal precision greater than 3 (including
	   decimal point)
	*/
	
	type Number LOWDEC, DEC, TCID
	type String CRCD
	
	if ("AMT#1").length() > 3 quit TOTAMT
	if 'ttx.getStoredValue("isPrimary") quit TOTAMT

	set CRCD = ttx.crcd
	if CRCD.isNull() set CRCD = dep.cid
	if CRCD.isNull() set CRCD = %SystemCurrency

	// currency's decimal precision
	set DEC = $$curdec^CRCDUTL(CRCD)
	// Lowest value for given decimal
	set LOWDEC = 10 ** (-DEC)

	quit $select($fnumber(TOTAMT, "-") < LOWDEC:0, 1:TOTAMT)


FILESEG(RecordTTX ttx, RecordDEP dep, Number AMT)

	type public Number ACR, AIACR, CTL, SEGMENT

	if 'dep.segacr do { quit
		// Accruing at segment level
		if 'CTL do {

			type RecordDEPSEG depseg = Db.getRecord("DEPSEG", "CID=:dep.cid,SEGMENT=:SEGMENT")

			// Positive accrual
			// Update depseg.posacr, dep.posacr, dep.taspm/taspnm
			set depseg.posacr = $$MIN(.dep,.ttx, (ACR + AMT))

			// Positive Accrued Int/Div
			set dep.posacr = $$MIN(.dep, .ttx, (dep.posacr + AMT))

			if SEGMENT=0 do {
				// Total Accrual on Segment Prin (Matured)
				set dep.taspm = $$MIN(.dep, .ttx, (dep.taspm + AMT))
				}
			else  do {
				// Total Accrual on Seg Prin (Non-Matured)
				set dep.taspnm = $$MIN(.dep, .ttx, (dep.taspnm + AMT))
				}

			do depseg.bypassSave()
			}

		if CTL=3 do {

			type RecordDEPSEG depseg = Db.getRecord("DEPSEG", "CID=:dep.cid,SEGMENT=:SEGMENT")

			set depseg.aiacr = $$MIN(.dep, .ttx, (AIACR + AMT))

			// Available Interest Accrued
			set dep.aiacr = $$MIN(.dep,.ttx, (dep.aiacr + AMT))

			if SEGMENT = 0 do {
				// Total Avail Int Accrual on Matured Seg
				set dep.taiams = $$MIN(.dep,.ttx, (dep.taiams + AMT))
				}
			else  do {
				// Total Avail Int Accrual on Non-Mat Seg
				set dep.taianms  =$$MIN(.dep, .ttx, (dep.taianms + AMT))
				}

			do depseg.bypassSave()
			}
		}

	// Accruing at account level
	if 'CTL do {

		// Positive Accrued Int/Div
		set dep.posacr = $$MIN(.dep, .ttx, (ACR + AMT))

		// Total Accrual on Seg Prin (Non-Matured)
		set dep.taspnm = $$MIN(.dep, .ttx, (dep.taspnm + AMT))
		}

	if CTL = 3 do {

		// Available Interest Accrued
		set dep.aiacr = $$MIN(.dep, .ttx, (AIACR + AMT))

		// Total Avail Int Accrual on Matured Seg
		set dep.taiams = $$MIN(.dep, .ttx, (dep.taiams + AMT))
		}

	quit

vSIG()	quit "60463^59631^Shriram Deshpande^11047"	// Signature - LTD^TIME^USER^SIZE
