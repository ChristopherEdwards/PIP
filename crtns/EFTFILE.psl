EFTFILE(RecordEFTPAY eftpay, String vpar, Boolean vparNorm) // EFTPAY - Electronic Payment File Filer
	// Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/30/2007 14:16 - joynerd
	// Generated from DATA-QWIK schema in: /profile/v72qa_gtmlx  by: /v72qa_gtmlx/crtns/DBSFILB.obj

	// Data Dictionary Data Items (223)            03/14/2007
	// Trigger Definition (23)                     12/17/2004
	// Journal File Definition (10)                10/24/2006
	/*
		vpar      Runtime qualifiers:      /NOREQ/MECH=REFARR:R

		/[NO]CASDEL   - Cascade delete
		/[NO]FRMFILER - Called from another filer
		/[NO]INDEX    - Update Indexes
		/[NO]JOURNAL  - Journal update
		/[NO]TRIGAFT  - After update triggers
		/[NO]TRIGBEF  - Before update triggers
		/[NO]UPDATE   - Update primary table
		/[NO]VALDD    - Validate column values
		/[NO]VALFK    - Validate foreign keys
		/[NO]VALREQ   - Validate not null values
		/[NO]VALRI    - Validate transaction integrity
		/[NO]VALST    - Validate database state
	*/

	type public String verrors()

	type String vx(), vxins()                              // audit column array
	type Number %O = eftpay.getMode()                      // Processing mode
	set vpar = vpar.get()                                  // Initialize vpar

	if %O = 0 do AUDIT^UCUTILN(eftpay,.vxins(),11,"|")
	if %O = 1 quit:'eftpay.isChanged()  do AUDIT^UCUTILN(eftpay,.vx(),11,"|")

	if 'vparNorm.get() set vpar = $$initPar^UCUTILN(vpar)  // Run-time qualifiers

	// Define local variables for access keys for legacy triggers
	type String CID = eftpay.cid
	type String SEQ = eftpay.seq

	if %O = 0 do { quit                                    // Create record control block
		do vinit                                              // Initialize column values
		if vpar["/TRIGBEF/" do VBI                            // Before insert triggers
		if vpar["/VALREQ/" do vreqn                           // Check required
		if vpar["/VALDD/" do vddver                           // Check values
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 1 do { quit                                    // Update record control block
		if vx("CID").exists()!vx("SEQ").exists() do vkchged quit // Primary key changed
		if vpar["/TRIGBEF/" do VBU                            // Before update triggers
		if vpar["/VALREQ/" do vrequ                           // Check required
		if vpar["/VALDD/" do VDDUX^DBSFILER("EFTPAY",.vx)
		set %O = 1 do vexec
		if vpar["/TRIGAFT/" do VAU                            // After update triggers
	}

	if %O = 2 do { quit                                    // Verify record control block
		if vpar["/VALREQ/" do vreqn                           // Check required
		set vpar = $$setPar^UCUTILN(vpar,"NOJOURNAL/NOUPDATE")
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 3 do { quit                                    // Delete record control block
		quit:'Db.isDefined("EFTPAY","CID = :eftpay.cid and SEQ = :eftpay.seq") // No record exists
		if vpar["/TRIGBEF/" do VBD                            // Before delete triggers
		do vdelete(0)
		if vpar["/TRIGAFT/" do VAD                            // After delete triggers
	}

	quit

vlegacy(Number %ProcessMode,String vpar) // Legacy interface (^DBSDF9 for %O=0, EXT^DBSFILER for %O = 2)

	type public String CID
	type public String SEQ

	type RecordEFTPAY eftpay = Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ")
	if (%ProcessMode = 2) do {
		do eftpay.setMode(2)

		do EFTFILE(eftpay,vpar)
	}
	else  do VINDEX(eftpay)

	quit

vLITCHK() quit 0 // Table does not have columns involved in literals


vexec // Execute transaction

	type public Number %O
	type public String vpar,vobj(),vx(),vxins()

	type public RecordEFTPAY eftpay

	type String vERRMSG

	if vpar["/VALST/" if '(''Db.isDefined("EFTPAY","CID = :eftpay.cid and SEQ = :eftpay.seq") = ''%O) set vERRMSG = $$^MSG($select(%O:7932,1:2327)) throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))

	if vpar'["/NOUPDATE/" do {

		if %O = 0  set eftpay.LCHDT = %SystemDate
		type String n = -1
		type String x

		if %O = 0 for  set n = vobj(eftpay,n).order() quit:n.isNull()  do {
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^EFTPAY(vobj(eftpay,-3),vobj(eftpay,-4),n)=vobj(eftpay,n)
			#ENDBYPASS
		}

		else  for  set n = vobj(eftpay,-100,n).order() quit:n.isNull()  do {
			quit:'$D(vobj(eftpay,n))
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^EFTPAY(vobj(eftpay,-3),vobj(eftpay,-4),n)=vobj(eftpay,n)
			#ENDBYPASS
		}

		// Allow global reference and M source code
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
		#BYPASS
		if $D(vobj(eftpay)) S ^EFTPAY(vobj(eftpay,-3),vobj(eftpay,-4))=vobj(eftpay)
		#ENDBYPASS

		if vpar["/JOURNAL/" do VJOURNAL(.eftpay)              // Create journal files
	}

	if vpar["/INDEX/",'(%O = 1)!'vx("").order().isNull() do VINDEX(.eftpay) // Update Index files

	quit

vload // Record Load - force loading of unloaded data

	type public RecordEFTPAY eftpay
	type String n = ""

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	for  set n=$order(^EFTPAY(vobj(eftpay,-3),vobj(eftpay,-4),n)) quit:n=""  if '$D(vobj(eftpay,n)),$D(^EFTPAY(vobj(eftpay,-3),vobj(eftpay,-4),n))#2 set vobj(eftpay,n)=^(n)
	#ENDBYPASS
	quit

vdelete(Boolean vkeychg) // Record Delete

	type public String vobj(),vpar
	type public RecordEFTPAY eftpay

	if 'vkeychg.get(),eftpay.isChanged() throw Class.new("Error","%PSL-E-DBFILER,Deleted object cannot be modified")

	if vpar["/CASDEL/" do VCASDEL                          // Cascade delete
	if vpar["/INDEX/" do VINDEX(.eftpay)                   // Delete index entries
	if vpar["/JOURNAL/" do VJOURNAL(.eftpay)               // Create journal entries

	// Allow global reference - Delete record
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^EFTPAY(vobj(eftpay,-3),vobj(eftpay,-4))
	#ENDBYPASS
	quit


vinit // Initialize default values

	type public RecordEFTPAY eftpay

	// Type local variables for access keys for defaults
	type public String CID
	type public String SEQ

	if eftpay.creatseq.isNull() set eftpay.creatseq = 0    // creatseq
	type public String TJD
	if eftpay.datecre.isNull() set eftpay.datecre = TJD    // datecre
	if eftpay.erivalid.isNull() set eftpay.erivalid = 0    // erivalid
	if eftpay.exttrf.isNull() set eftpay.exttrf = 0        // exttrf
	if eftpay.feeconv.isNull() set eftpay.feeconv = 0      // feeconv
	if eftpay.hldauto.isNull() set eftpay.hldauto = 0      // hldauto
	if eftpay.inttrn.isNull() set eftpay.inttrn = 0        // inttrn
	if eftpay.mt103flg.isNull() set eftpay.mt103flg = 0    // mt103flg
	if eftpay.mt202flg.isNull() set eftpay.mt202flg = 0    // mt202flg
	if eftpay.nxtpmt.isNull() set eftpay.nxtpmt = 0        // nxtpmt
	if eftpay.origfee.isNull() set eftpay.origfee = 0      // origfee
	if eftpay.ovstop.isNull() set eftpay.ovstop = 0        // ovstop
	if eftpay.pri.isNull() set eftpay.pri = 0              // pri
	if eftpay.prtpmt.isNull() set eftpay.prtpmt = 0        // prtpmt
	if eftpay.reject.isNull() set eftpay.reject = 0        // reject
	if eftpay.repair.isNull() set eftpay.repair = 0        // repair
	if eftpay.repost.isNull() set eftpay.repost = 0        // repost
	if eftpay.rtrnflg.isNull() set eftpay.rtrnflg = 0      // rtrnflg
	if eftpay.timecre.isNull() set eftpay.timecre = $P($H,",",2) // timecre
	type public String %UID
	if eftpay.uid.isNull() set eftpay.uid = %UID           // uid
	quit


vreqn // Validate required data items

	type public RecordEFTPAY eftpay

	if eftpay.amttyp.isNull() do vreqerr("AMTTYP") quit
	if eftpay.cc.isNull() do vreqerr("CC") quit
	if eftpay.crcdcid.isNull() do vreqerr("CRCDCID") quit
	if eftpay.creatseq.isNull() do vreqerr("CREATSEQ") quit
	if eftpay.efttype.isNull() do vreqerr("EFTTYPE") quit
	if eftpay.erivalid.isNull() do vreqerr("ERIVALID") quit
	if eftpay.exttrf.isNull() do vreqerr("EXTTRF") quit
	if eftpay.feeconv.isNull() do vreqerr("FEECONV") quit
	if eftpay.hldauto.isNull() do vreqerr("HLDAUTO") quit
	if eftpay.inttrn.isNull() do vreqerr("INTTRN") quit
	if eftpay.met.isNull() do vreqerr("MET") quit
	if eftpay.mt103flg.isNull() do vreqerr("MT103FLG") quit
	if eftpay.mt202flg.isNull() do vreqerr("MT202FLG") quit
	if eftpay.nxtpmt.isNull() do vreqerr("NXTPMT") quit
	if eftpay.origfee.isNull() do vreqerr("ORIGFEE") quit
	if eftpay.ovstop.isNull() do vreqerr("OVSTOP") quit
	if eftpay.pri.isNull() do vreqerr("PRI") quit
	if eftpay.prtpmt.isNull() do vreqerr("PRTPMT") quit
	if eftpay.reject.isNull() do vreqerr("REJECT") quit
	if eftpay.repair.isNull() do vreqerr("REPAIR") quit
	if eftpay.repost.isNull() do vreqerr("REPOST") quit
	if eftpay.rtrnflg.isNull() do vreqerr("RTRNFLG") quit
	quit

vrequ // Valid required columns on update


	type public String vx()
	type public RecordEFTPAY eftpay

	if eftpay.cid.isNull() do vreqerr("CID") quit
	if eftpay.seq.isNull() do vreqerr("SEQ") quit

	if 'vobj(eftpay,-100,0,"").order().isNull() do {
		if vx("FEECONV").exists(),eftpay.feeconv.isNull() do vreqerr("FEECONV") quit
		if vx("INTTRN").exists(),eftpay.inttrn.isNull() do vreqerr("INTTRN") quit
		if vx("CRCDCID").exists(),eftpay.crcdcid.isNull() do vreqerr("CRCDCID") quit
	}
	if 'vobj(eftpay,-100,20,"").order().isNull() do {
		if vx("MT202FLG").exists(),eftpay.mt202flg.isNull() do vreqerr("MT202FLG") quit
		if vx("MT103FLG").exists(),eftpay.mt103flg.isNull() do vreqerr("MT103FLG") quit
	}
	if 'vobj(eftpay,-100,21,"").order().isNull() do {
		if vx("RTRNFLG").exists(),eftpay.rtrnflg.isNull() do vreqerr("RTRNFLG") quit
		if vx("ORIGFEE").exists(),eftpay.origfee.isNull() do vreqerr("ORIGFEE") quit
		if vx("REPAIR").exists(),eftpay.repair.isNull() do vreqerr("REPAIR") quit
	}
	if 'vobj(eftpay,-100,"0*","").order().isNull() do {
		if vx("CC").exists(),eftpay.cc.isNull() do vreqerr("CC") quit
		if vx("MET").exists(),eftpay.met.isNull() do vreqerr("MET") quit
		if vx("AMTTYP").exists(),eftpay.amttyp.isNull() do vreqerr("AMTTYP") quit
		if vx("EFTTYPE").exists(),eftpay.efttype.isNull() do vreqerr("EFTTYPE") quit
		if vx("PRI").exists(),eftpay.pri.isNull() do vreqerr("PRI") quit
		if vx("NXTPMT").exists(),eftpay.nxtpmt.isNull() do vreqerr("NXTPMT") quit
		if vx("REJECT").exists(),eftpay.reject.isNull() do vreqerr("REJECT") quit
		if vx("REPOST").exists(),eftpay.repost.isNull() do vreqerr("REPOST") quit
		if vx("PRTPMT").exists(),eftpay.prtpmt.isNull() do vreqerr("PRTPMT") quit
		if vx("OVSTOP").exists(),eftpay.ovstop.isNull() do vreqerr("OVSTOP") quit
		if vx("CREATSEQ").exists(),eftpay.creatseq.isNull() do vreqerr("CREATSEQ") quit
		if vx("HLDAUTO").exists(),eftpay.hldauto.isNull() do vreqerr("HLDAUTO") quit
		if vx("EXTTRF").exists(),eftpay.exttrf.isNull() do vreqerr("EXTTRF") quit
	}
	if 'vobj(eftpay,-100,"EUR","").order().isNull() do {
		if vx("ERIVALID").exists(),eftpay.erivalid.isNull() do vreqerr("ERIVALID") quit
	}
		if vx("AMTTYP").exists(),eftpay.amttyp.isNull() do vreqerr("AMTTYP") quit
		if vx("CC").exists(),eftpay.cc.isNull() do vreqerr("CC") quit
		if vx("CRCDCID").exists(),eftpay.crcdcid.isNull() do vreqerr("CRCDCID") quit
		if vx("CREATSEQ").exists(),eftpay.creatseq.isNull() do vreqerr("CREATSEQ") quit
		if vx("EFTTYPE").exists(),eftpay.efttype.isNull() do vreqerr("EFTTYPE") quit
		if vx("ERIVALID").exists(),eftpay.erivalid.isNull() do vreqerr("ERIVALID") quit
		if vx("EXTTRF").exists(),eftpay.exttrf.isNull() do vreqerr("EXTTRF") quit
		if vx("FEECONV").exists(),eftpay.feeconv.isNull() do vreqerr("FEECONV") quit
		if vx("HLDAUTO").exists(),eftpay.hldauto.isNull() do vreqerr("HLDAUTO") quit
		if vx("INTTRN").exists(),eftpay.inttrn.isNull() do vreqerr("INTTRN") quit
		if vx("MET").exists(),eftpay.met.isNull() do vreqerr("MET") quit
		if vx("MT103FLG").exists(),eftpay.mt103flg.isNull() do vreqerr("MT103FLG") quit
		if vx("MT202FLG").exists(),eftpay.mt202flg.isNull() do vreqerr("MT202FLG") quit
		if vx("NXTPMT").exists(),eftpay.nxtpmt.isNull() do vreqerr("NXTPMT") quit
		if vx("ORIGFEE").exists(),eftpay.origfee.isNull() do vreqerr("ORIGFEE") quit
		if vx("OVSTOP").exists(),eftpay.ovstop.isNull() do vreqerr("OVSTOP") quit
		if vx("PRI").exists(),eftpay.pri.isNull() do vreqerr("PRI") quit
		if vx("PRTPMT").exists(),eftpay.prtpmt.isNull() do vreqerr("PRTPMT") quit
		if vx("REJECT").exists(),eftpay.reject.isNull() do vreqerr("REJECT") quit
		if vx("REPAIR").exists(),eftpay.repair.isNull() do vreqerr("REPAIR") quit
		if vx("REPOST").exists(),eftpay.repost.isNull() do vreqerr("REPOST") quit
		if vx("RTRNFLG").exists(),eftpay.rtrnflg.isNull() do vreqerr("RTRNFLG") quit
	quit

vreqerr(di) // Required error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("EFTPAY","MSG",1767,"EFTPAY."_di)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit


VAD //
	type public Number ER = 0
	type public String vx(),RM
	do vad1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	do vau2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() quit
	if vx("AMTTYP").exists() do vau3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CRCD").exists()!vx("SETCRCD").exists()!vx("INTEXT").exists()!vx("SENDNOS").exists()!vx("SENDCORR").exists()!vx("PROCDT").exists()!vx("EFD").exists() do vau6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("EXPDT").exists() do vau4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PARTAMT").exists()!vx("REPOST").exists() do vau5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STATUS").exists() do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBD //
	type public Number ER = 0
	type public String vx(),RM
	do vbd1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordEFTPAY eftpay
	do vbu4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() do AUDIT^UCUTILN(eftpay,.vx(),11,"|") quit
	if vx("AMOUNT").exists()!vx("ANTTOTAL").exists()!vx("CRCD").exists()!vx("FEECONV").exists()!vx("CCODE").exists()!vx("FEETYPE").exists()!vx("ANTRATE").exists()!vx("RCVRCHG").exists()!vx("RCVRCHGC").exists()!vx("FEEPAYOR").exists() do vbu12 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CID").exists()!vx("RECACCT").exists()!vx("RECINST").exists()!vx("TTYPE").exists() do vbu6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CRCTACCT").exists()!vx("CRCTGL").exists() do vbu7 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("EFTSRCDD").exists() do vbu2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("HLDAUTO").exists() do vbu8 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MSG1").exists()!vx("MSG2").exists()!vx("MSG3").exists()!vx("MSG4").exists() do vbu5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MSGFP1").exists()!vx("MSGFP2").exists()!vx("MSGFP3").exists()!vx("MSGFP4").exists()!vx("MSGFP5").exists()!vx("MSGFP6").exists() do vbu9 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PTYSTAT").exists() do vbu13 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("REJECT").exists() do vbu10 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SENDNOS").exists()!vx("INTEXT").exists()!vx("SENDCORR").exists()!vx("PROCDT").exists()!vx("EFD").exists() do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SETCRCD").exists() do vbu11 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STATUS").exists() do vbu3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(eftpay,.vx(),11,"|")
	quit


vad1 // Trigger AFTER_DELETE - After Delete trigger

	type public RecordEFTPAY eftpay
	/*
	 ---- Revision History ------------------------------------------------

	 06/26/02 - SIGDAE - 50872
		Added code to remove EFTREF records in eftpay.refno is not null.
	 ----------------------------------------------------------------------
	*/

	new REFNO
	if eftpay.refno'="" do {
		set REFNO=eftpay.refno
		do Db.delete("EFTREF","REFNO=:REFNO")
	}
	quit

vai1 // Trigger AFTER_INSERT - EFTPAY Filer After Insert Trigger

	type public RecordEFTPAY eftpay
	/*
	   ---- Revision History ------------------------------------------------

	   08/10/04 - KELLYP - CR 11405
	   	      Added check on STBLEFT for NDPO's when testing ttype
	   	      because ttype is not set for foreign payments.

	   10/17/02 - RICKARDSC - 49098
		      Added check for EFD<PROCDT for foreign payments
		      Added calls to DATCHK for PROCDT and EFD for foreign
		      payments

	   10/16/02 - SIGDAE - 51270
		      Added checks for Amount Type.

	   04/22/02 - SIGDAE - 50427
		      Modified updates to dep/ln.payeft to use bypassSave
		      method.  Also move this code under the IBS section.

	   12/12/01 - SIGDAE - 48558
		      Modified trigger to only check the account level for
	 	      EFTDEB and EFTREQ.  Added check for EFTDD.
	
	   10/24/01 - RICKARDSC - 45998
		      Modified trigger to always validate SENDNOS and SENDCORR
		      by a call to NOSCHECK^PROCEFT for outgoing and incoming
		      foreign payments, and added SETCRCD check.

	   10/18/01 - SIGDAE - 47857
		      Added code to check domestic payment ONUS recipient 
		      account to see if it is valid and not closed.

	   06/13/01 - SIGDAE - 45301
		      Fix undefined error for variable xtype.

	   06/11/01 - SIGDAE - 45301
		      Consolidated $$SqlSelect macros to minimize the number of
		      global accesses and reduce the amount of compiled code
		      that gets generated; eliminated unnecessary macros.

		      Modified calls to MSG1 and MSG2^SWFTEDIT to pass a second
		      argument (SWFTCHAR) to avoid the need to build the string
		      of acceptable characters for each field.  Moved this edit
		      checking after other, less labor intensive edit checking
		      has been performed.

		      Removed older revision history.

	   10/24/00 - JERUCHIMC - 42266
	              Remove integrity check.

	   10/05/00 - MaltepesA 42199
		      Added check if efttype="" then set it to
		      STBLEFTTYPE.EFTTYPE

  	   09/07/00 - MaltepesA - 41255
          	      Modified to look at the new table STBLEFTTYPE to get a
             	      payment type instead of getting it directly from EFTPAY table.	
	  
	   08/07/00 - SCHWARTZC - 41394
	              Removed code updating eftpay.lnm.  This code has been 
		      moved to the BEFORE_INSERT and BEFORE_UPDATE triggers.
	*/

	if (%ProcessMode=2) quit
	
	new CLS,CRCD,EMUMEM,STBLEFT,XCID,XACN

	type RecordDEP dep
	type RecordLN ln

	// Invalid CIF ~p1
	set XACN=eftpay.acn
	if XACN'="",'Db.isDefined("CIF","XACN") do Runtime.setErrMSG("EFTPAY",7575) quit:ER
	set XCID=eftpay.cid

	set STBLEFT=eftpay.efttype
	set STBLEFT=Db.getOneRow("STBLEFT","CTBLEFTTYPE","STBLEFT")

	// Date cannot be less than date of creation
	if eftpay.efd<eftpay.datecre do Runtime.setErrMSG("EFTPAY",8368) quit:ER

	// IBS account
	if (STBLEFT'["NDPO"),(eftpay.ttype<2) do { quit:ER
		new CLS,EFTDD,EFTDEB,EFTREQ,PAYEFT,STAT

		// ~p1 is not a valid account number
		if '+XCID do Runtime.setErrMSG("EFTPAY",7683,"XCID") quit:ER
		if 'Db.isDefined("ACN","XCID") do Runtime.setErrMSG("EFTPAY",7683,"XCID") quit:ER

		if Db.isDefined("DEP","XCID") do {
			set dep=Db.getRecord("DEP","XCID")
			set CLS="D"
			set EFTDD=dep.eftdd
			set EFTDEB=dep.eftdeb
			set EFTREQ=dep.eftreq
			set PAYEFT=dep.payeft
			set STAT=dep.stat
		}
		else  do {
			set ln=Db.getRecord("LN","XCID")
			set CLS="L"
			set EFTDD=ln.eftdd
			set EFTDEB=ln.eftdeb
			set EFTREQ=ln.eftreq
			set PAYEFT=ln.payeft
			set STAT=ln.stat
		}

		// Account ~p1 is closed
		if STAT=4 do Runtime.setErrMSG("EFTPAY",6050,XCID) quit:ER

		// Collection orders not permitted for account ~p1
		if STBLEFT["CO",EFTREQ'=1 do Runtime.setErrMSG("EFTPAY",3810,XCID) quit:ER

		// Payment orders not permitted for account ~p1
		if STBLEFT["PO",EFTDEB'=1 do Runtime.setErrMSG("EFTPAY",3805,XCID) quit:ER

		// Direct debits not permitted for account ~p1
		if STBLEFT="DD",EFTDD'=1 do Runtime.setErrMSG("EFTPAY",5085,XCID) quit:ER

		// Set the PAYEFT flag on account upon creation of standing order
		if CLS="D",PAYEFT'=1 do {
			set dep.payeft=1
			do dep.bypassSave()
		}
		if CLS="L",PAYEFT'=1 do {
			set ln.payeft=1
			do ln.bypassSave()
		}
	}

	// Domestic payment ONUS recipient account
	if STBLEFT'["NDPO",'(eftpay.ttype#2) do { quit:ER
		new ONUS,RECACCT,RECINST,STAT
		set RECINST=eftpay.recinst
		set ONUS=Db.getOneRow("ONUS","UTBLEFTINST","RECINST")
		if 'ONUS quit

		set RECACCT=eftpay.recacct
		// ~p1 is not a valid account number
		if '+RECACCT do Runtime.setErrMSG("EFTPAY",7683,RECACCT) quit:ER
		if 'Db.isDefined("ACN","RECACCT") do Runtime.setErrMSG("EFTPAY",7683,RECACCT) quit:ER
		set STAT=Db.getOneRow("STAT","ACN","RECACCT")

		// Account ~p1 is closed
		if STAT=4 do Runtime.setErrMSG("EFTPAY",6050,RECACCT) quit:ER
	}

	// Check for valid Amount Types based on Account Type and EFT Type
	do AMTTYP^PROCEFT(eftpay.amttyp,eftpay.cid,STBLEFT,eftpay.ttype) quit:ER

	// Minimum 2 lines required for intermediary
	if eftpay.inter2="",eftpay.inter1'="" do Runtime.setErrMSG("EFTPAY",2101) quit:ER

	// SETCRCD cannot equal 1 if non-IN currency
	set CRCD=eftpay.crcd
	set EMUMEM=Db.getOneRow("EMU","CRCD","%CompanyName,CRCD")
	if EMUMEM'=1,eftpay.setcrcd=1 do Runtime.setErrMSG("EFTPAY",3604) quit:ER

	// Incoming foreign payments
	if STBLEFT="NDPOIN" do { quit:ER
		// Debit account cannot be same as beneficiary's account
		if XCID'="",eftpay.sendnos=eftpay.cid do Runtime.setErrMSG("EFTPAY",7754) quit:ER

		// Validate SENDNOS and SENDCORR
		do NOSCHECK^PROCEFT(.eftpay) quit:ER

		// Settlement date cannot be less than payment date
		if eftpay.efd<eftpay.procdt do Runtime.setErrMSG("EFTPAY",7542) quit:ER

		// Verify PROCDT and EFD
		do DATCHK^PROCEFT(1,eftpay.procdt,eftpay.sendcorr) quit:ER
		do DATCHK^PROCEFT(0,eftpay.efd,eftpay.sendcorr) quit:ER
	}
	
	// Outgoing foreign payments
	if STBLEFT="NDPO" do { quit:ER
		// Credit account cannot be same as payment account
		if eftpay.sendnos'="",eftpay.sendnos=eftpay.acn do Runtime.setErrMSG("EFTPAY",7657) quit:ER

		// Validate SENDNOS and SENDCORR
		do NOSCHECK^PROCEFT(.eftpay) quit:ER

		do BENINST^PROCEFT(eftpay.beninst,.eftpay) quit:ER

		// Settlement date cannot be less than payment date
		if eftpay.efd<eftpay.procdt do Runtime.setErrMSG("EFTPAY",7542) quit:ER

		// Verify PROCDT and EFD
		do DATCHK^PROCEFT(0,eftpay.procdt,eftpay.sendcorr) quit:ER
		do DATCHK^PROCEFT(1,eftpay.efd,eftpay.sendcorr) quit:ER

		// Ensure fields conform to SWIFT standards
		do DICHECK^PROCEFT(.eftpay)
	}
	
	// Standing foreign payments
	if STBLEFT="NDPOST" do BENINST^PROCEFT(eftpay.beninst,.eftpay) quit:ER
	
	// Validate message format /text/ or //text
	if eftpay.msgfp1'="" do MSG1^SWFTEDIT(eftpay.msgfp1,.SWFTCHAR) quit:ER
	if eftpay.msgfp2'="" do MSG2^SWFTEDIT(eftpay.msgfp2,.SWFTCHAR) quit:ER
	if eftpay.msgfp3'="" do MSG2^SWFTEDIT(eftpay.msgfp3,.SWFTCHAR) quit:ER
	if eftpay.msgfp4'="" do MSG2^SWFTEDIT(eftpay.msgfp4,.SWFTCHAR) quit:ER
	if eftpay.msgfp5'="" do MSG2^SWFTEDIT(eftpay.msgfp5,.SWFTCHAR) quit:ER
	if eftpay.msgfp6'="" do MSG2^SWFTEDIT(eftpay.msgfp6,.SWFTCHAR) quit:ER
	quit

vau1 // Trigger AFTER_STATUS - After Status Update to "D"elete Trigger

	type public RecordEFTPAY eftpay
	/*---- Revision History ------------------------------------------------

	 04/22/02 - SIGDAE - 50427
		    Modified updates to dep/ln.payeft to use bypassSave
		    method.

	 07/24/01 - YURKOVICG - 45987
		    Moved code which updates PAYEFT flag above check of HLDAUTO.
		    Cleaned up structure of code at end of trigger.
	
	 06/11/01 - SIGDAE - 45301
		    Miscellaneous clean-up.

	 08/04/00 - SCHWARTZC - 41394
	            Removed code setting EFTPAY.LNM if it was null.  This code
		    has been moved to the BEFORE_UPDATE trigger.

	----------------------------------------------------------------------
	*/

	if eftpay.status="AP",eftpay.uidmod=%UserID do Runtime.setErrMSG("EFTPAY",7682) quit:ER
	if eftpay.status="V",eftpay.uidadd=%UserID do Runtime.setErrMSG("EFTPAY",7687) quit:ER

	// Remaining code not for G/Ls
	if eftpay.ttype'<2 quit

	// Update PAYEFT flag on account
	if eftpay.status="D" do {
		new CLS,XCID
		set XCID=eftpay.cid

		type ResultSet rs
		set rs=Db.select("SEQ","EFTPAY","CID=:XCID AND STATUS='A'")
		if 'rs.isEmpty() quit

		if Db.isDefined("DEP","XCID") do { quit
			type RecordDEP dep
			set dep=Db.getRecord("DEP","XCID")
			set dep.payeft=0
			do dep.bypassSave()
		}
		if Db.isDefined("LN","XCID") do {
			type RecordLN ln
			set ln=Db.getRecord("LN","XCID")
			set ln.payeft=0
			do ln.bypassSave()
		}
	}

	/*
	   Remove hold on outgoing clean payment if the status is 
	   changed to "D"elete and HLDAUTO flag is on.
	*/
	if eftpay.status="D",eftpay.hldauto=1 do { quit:ER
		new X
		set X=$$RMHLDS^EFTFUNCS(eftpay.cid,eftpay.seq)
		if 'X do Runtime.setErrMSG("EFTPAY",8343) quit
		}
	
	// SENDNOS required when outgoing has been approved
	if eftpay.efttype="NDPO",eftpay.status="AP",eftpay.sendnos="" do Runtime.setErrMSG("EFTPAY",7668) quit:ER

	quit

vau2 // Trigger AFTER_UPDATE - After Update all fields

	type public RecordEFTPAY eftpay
	/* 
	---- Revision History ------------------------------------------------
	04/22/02 - SIGDAE - 50427
		   Added check for EFTPAY.EFTTYPE="NDPO" before calling
		   DICHECK.

	06/11/01 - SIGDAE - 45301
		   Removed unused code.

		   Deleted older revision history.
	----------------------------------------------------------------------
	*/

	if eftpay.efttype="NDPO" do DICHECK^PROCEFT(.eftpay)

	quit

vau3 // Trigger AFT_UPD_AMTTYP - After Update of Amount Type

	type public RecordEFTPAY eftpay
	/*
	 ---------- Revision History ------------------------------------------

	 10/16/02 - SIGDAE - 51270
		Added checks for Amount Type.

	 ----------------------------------------------------------------------
	*/

	new EFTTYPE

	set EFTTYPE=eftpay.efttype

	type RecordCTBLEFTTYPE ctbleft=Db.getRecord("CTBLEFTTYPE","EFTTYPE")

	// Check for valid Amount Types based on Account Type and EFT Type
	do AMTTYP^PROCEFT(eftpay.amttyp,eftpay.cid,ctbleft.stbleft,eftpay.ttype) quit:ER
	quit

vau4 // Trigger AFT_UPD_EXPDT - After Update Expiration Date

	type public RecordEFTPAY eftpay
	/*
	  ---- Revision History ------------------------------------------------

	  03/04/02 - SIGDAE - 49001:01
		Added code to check Expiration Date.
	  ----------------------------------------------------------------------
	*/

	if eftpay.expdt="" quit

	new BD,CAL,CRCD,UFRE

	set CRCD=eftpay.crcd
	set CAL=Db.getOneRow("CALENDAR","CRCD","%CompanyName,CRCD")
	set UFRE=eftpay.frequency
	set BD=Db.getOneRow("BD","USRFRE","UFRE")

	// Expiration date must be business day.
	if (BD'=""&(BD'["A")),'$$BD^UNBD(eftpay.expdt,CAL) do Runtime.setErrMSG("EFTPAY",6062) quit:ER
	else  if UFRE'["A",'$$BD^UNBD(eftpay.expdt,CAL) do Runtime.setErrMSG("EFTPAY",6062) quit:ER

	// Effective date greater than Expiration date.
	if eftpay.efd>eftpay.expdt do Runtime.setErrMSG("EFTPAY",6063) quit:ER
	quit

vau5 // Trigger AFT_UPD_PARTAMT - After Update Partial Amount

	type public RecordEFTPAY eftpay
	/*
	 ---- Revision History ------------------------------------------------

	 12/20/03 - CARROLLJ - CR7658
		Added #ACCEPT prior to xecute command.

	 08/07/01 - SIGDAE - 46611
		Added arguments to PP^PROCRICO call.

		Removed older revision history.
	*/

	new PGM,PPSEQ

	if eftpay.partamt="" do {
		set PPSEQ=eftpay.seq
		set PGM=$$GET^UBCHID("BCHEFT") if PGM="" quit
		set XECUTE="D public^"_PGM_"(CID,PPSEQ,,,1)"
		#ACCEPT DATE=12/30/03;PGM=John Carroll
		xecute XECUTE
		}

	if eftpay.partamt="" quit
	new PPSEQ
	set PPSEQ=$$PP^PROCRICO(CID,SEQ,eftpay.partamt)
	if ER quit
	if PPSEQ="" quit

	// Protect SEQ
	new SEQ

	// Process the partial payment record via call to public linetag in batch
	set PGM=$$GET^UBCHID("BCHEFT") if PGM="" quit
	set XECUTE="D public^"_PGM_"(CID,PPSEQ)"
	#ACCEPT DATE=12/30/03;PGM=John Carroll
	xecute XECUTE
	quit

vau6 // Trigger AFT_UPD_SENDNOS - After Update Sender's Nostro/Vostro

	type public RecordEFTPAY eftpay
	/*
	 ---- Revision History ------------------------------------------------
	 10/17/02 - RICKARDSC - 49098
		Added check for EFD<PROCDT for foreign payments
		Added calls to DATCHK for PROCDT and EFD for foreign
		payments
	*/

	new CRCD,EMUMEM

	// SETCRCD cannot equal 1 if non-IN currency
	set CRCD=eftpay.crcd
	set EMUMEM=Db.getOneRow("EMU","CRCD","%CompanyName,CRCD")
	if EMUMEM'=1,eftpay.setcrcd=1 do Runtime.setErrMSG("EFTPAY",3604) quit:ER

	// Non-foreign payment
	if eftpay.efttype'["NDPO" do { quit:ER
		// Verify PROCDT and EFD
		do SDTIP^PROCEFT(eftpay.procdt,.eftpay) quit:ER
		do VDTIP^PROCEFT(eftpay.efd,.eftpay) quit:ER
	}

	// Incoming foreign payments
	if eftpay.efttype="NDPOIN" do { quit:ER
		// Validate SENDNOS and SENDCORR for foreign payments
		do NOSCHECK^PROCEFT(.eftpay) quit:ER

		// Settlement date cannot be less than payment date
		if eftpay.efd<eftpay.procdt do Runtime.setErrMSG("EFTPAY",7542) quit:ER

		// Verify PROCDT and EFD
		do DATCHK^PROCEFT(1,eftpay.procdt,eftpay.sendcorr) quit:ER
		do DATCHK^PROCEFT(0,eftpay.efd,eftpay.sendcorr) quit:ER
	}

	// Outgoing foreign payments
	if eftpay.efttype="NDPO" do { quit:ER
		// Validate SENDNOS and SENDCORR for foreign payments
		do NOSCHECK^PROCEFT(.eftpay) quit:ER

		// Settlement date cannot be less than payment date
		if eftpay.efd<eftpay.procdt do Runtime.setErrMSG("EFTPAY",7542) quit:ER

		// Verify PROCDT and EFD
		do DATCHK^PROCEFT(0,eftpay.procdt,eftpay.sendcorr) quit:ER
		do DATCHK^PROCEFT(1,eftpay.efd,eftpay.sendcorr) quit:ER
	}
	quit

vbd1 // Trigger BEFORE_DELETE - Before Delete Trigger

	type public RecordEFTPAY eftpay
	if eftpay.status'="D" set ER=1,RM=$$^MSG(433,eftpay.status)
	quit

vbi1 // Trigger BEFORE_INSERT - Before insert of eftpay record

	type public RecordEFTPAY eftpay
	/*
	   ---- Revision History ------------------------------------------------
	   
	   05/11/04 - RussellDS - CR9592
	  	Added code to calculate and set value of EFTPAY.CRCDCID.

	   10/17/02 - RICKARDSC - 49098
		Added call to DATIP for foreign payments
		Removed calls to SDTIP2 and VDTIP2 for incoming foreign
		payments

	   10/16/02 - SIGDAE - 51270
		Moved check on Amount Type equal 18 to After Insert Trigger.

		Deleted older revision history.

	   03/04/02 - SIGDAE - 49001:01
		o Modified '["NDPO" section to move the auto hold logic
		  into this section.  The "}" was in the wrong location.
		o Modified '["NDPO" section to use the currency code
		  calendar when checking Expiration Date.

	   02/08/02 - RICKARDSC - 48359
		Modified to call CALCANT^PROCEFT for all incoming and outgoing
		foreign payments.

	   12/06/01 - SIGDAE - 48608
		o Modified calls to place holds to use new PSL version 
		  of PLHLDS^EFTFUNCS.
		o Set eftpay.hldauto=0 for G/L account orders.
		o Change DEBCHECK^BCHEFT call to use DEBCHECK^EFTFUNCS

	   10/24/01 - RICKARDSC - 45998
		Removed validation of SENDNOS and SENDCORR for outgoing and
		incoming foreign payments. The validation has been moved to
		the AFTER_INSERT trigger.
		Modified SETCRCD default logic to use CUVAR.SCDFT.

	   10/18/01 - SIGDAE - 47857
		Moved check for same account transaction to non-foreign
		payment section since RECINST will not be defined during
		creation for foreign orders.

	   10/15/01 - SIGDAE - 47552
		o Added code to set TRIES equal to UTBLEFTINST.RETRY for
		  Direct Debits.
		o Removed setting of AMOUNT for Amount types greater than 1.

	*/
	
	new CRCD,EFTTYPE,EMUMEM,PROCDT,SCDFT,STBLEFT,VALDT,XCID

	if eftpay.efttype="" quit

	set CRCD=eftpay.crcd
	set XCID=eftpay.cid
 	set EFTTYPE=eftpay.efttype

	type RecordCTBLEFTTYPE ctbleft=Db.getRecord("CTBLEFTTYPE","EFTTYPE")

	set STBLEFT=ctbleft.stbleft

	// Verify proper use of memo and header G/Ls in the EFTPAY record
	do GLCHECK^PROCEFT(STBLEFT,eftpay.ttype,eftpay.cid,eftpay.recinst,eftpay.recacct)
	if ER quit
	
	// Calculate and set value of CRCDCID
	set eftpay.crcdcid=$$CRCDCID^EFTFUNCS(eftpay.cid,eftpay.ttype,eftpay.crcd)

	/*
	 Default settlement currency flag
	 Settlement currency must equal 0 for a non-In currency.
	*/
	set EMUMEM=Db.getOneRow("EMU","CRCD","%CompanyName,CRCD")
	if EMUMEM=1 do {
		set SCDFT=Db.getOneRow("SCDFT","CUVAR")
		if eftpay.setcrcd="" set eftpay.setcrcd=+SCDFT
		}
	else  set eftpay.setcrcd=0

	// Cannot be a negative amount
	if eftpay.amount<0 do Runtime.setErrMSG("EFTPAY",415) quit:ER

	// Verify the decimal precision of the payment currency.
	new CURDEC,DECPRS
	set CURDEC=Db.getOneRow("CURDEC","CRCD","%CompanyName,CRCD") quit:ER
	set DECPRS=.1**CURDEC
	if eftpay.amount#DECPRS>0 do Runtime.setErrMSG("EFTPAY",775) quit:ER
		
	//  Populate PTYSTAT if PTYSTAT is null
	if eftpay.ptystat="" set eftpay.ptystat=999
	// Only standing payment orders may have a priority status
	if (STBLEFT'="SPO"),(eftpay.ptystat'=999) do Runtime.setErrMSG("EFTPAY",4187,"RM") quit:ER
	
	// Holds for Profile accounts only
	if eftpay.ttype>1 set eftpay.hldauto=0

	// Non Foreign EFTPAY entries
	if STBLEFT'["NDPO" do { quit:ER
		new DATA,EFTINST,ONUS,RECINST

		set RECINST=eftpay.recinst
		set EFTINST=Db.getOneRow("ONUS,RETRY","UTBLEFTINST","RECINST")
		set ONUS=$P(EFTINST,$C(9),1)

		if eftpay.status="" set eftpay.status="A"
		if eftpay.met="" set eftpay.met=ctbleft.paymetdft
		if eftpay.met="" set eftpay.met="CC"
		if eftpay.amttyp="" set eftpay.amttyp=1
		if eftpay.hldauto="" set eftpay.hldauto=ctbleft.hldauto
		if STBLEFT="DD",eftpay.tries="" set eftpay.tries=$P(EFTINST,$C(9),2)
		if eftpay.tries="" set eftpay.tries=ctbleft.tries
		if eftpay.ttype<2 do { quit:ER
			set DATA=Db.getOneRow("BOO,CC,LNM","ACN","XCID")
			if eftpay.brcd="" set eftpay.brcd=$P(DATA,$C(9),1)
			if eftpay.cc="" set eftpay.cc=$P(DATA,$C(9),2)
			if eftpay.lnm="" set eftpay.lnm=$P(DATA,$C(9),3)
			}
		if eftpay.crcd="" set eftpay.crcd=%SystemCurrency

		// Set the source of the direct debit to 1 (Manually Input)
		if STBLEFT="DD" set eftpay.eftsrcdd=1

		// Debit Account cannot be the Beneficiary's Account
		if eftpay.cid=eftpay.recacct,ONUS,((eftpay.ttype=0)!(eftpay.ttype=3)) do Runtime.setErrMSG("EFTPAY",7754) quit:ER

		do ACNIP^PROCEFT(eftpay.acn,.eftpay) quit:ER
		do CRCD^PROCEFT(eftpay.crcd,.eftpay) quit:ER

		/*
		 If using financial option 1, effective date must match offset days
		 If STBLEFT is XCO then do not worry about the offset days because
		 XCOs get created on the same date.

		 Invalid offset in (efttype) for Effective Date:
		*/
		new erstr
		set erstr=EFTTYPE_"~"_$$^MSG(5951,eftpay.efd)
 		if ctbleft.fintras=1,eftpay.efd'=(%SystemDate+ctbleft.ftod) do Runtime.setErrMSG("EFTPAY",5407,erstr) quit:ER
	
		// Frequency required for standing orders
		if eftpay.frequency="",(STBLEFT="SPO"!(STBLEFT="SCO")) do Runtime.setErrMSG("EFTPAY",2105) quit:ER
		if eftpay.frequency'="",eftpay.efd="" set eftpay.efd=$$NJD^UFRE(%SystemDate,eftpay.frequency) if ER do Runtime.setErrMSG("EFTPAY",3333,"RM") quit:ER
		do EFD^PROCEFT(eftpay.efd,.eftpay) quit:ER

		// verify debit authorization - DDs only checked when processed
		if (STBLEFT="CO"!(STBLEFT="SCO")),$$DEBCHECK^EFTFUNCS(.eftpay,ONUS) do Runtime.setErrMSG("EFTPAY",3333,"RM") quit:ER

		/*
		 Payment orders and standing payment orders for Segmented
		 accounts must supply segment information in UNIQTSO.
		*/
		if STBLEFT["PO",'(eftpay.uniqtso["SEGI#")&'(eftpay.uniqtso["SEGP#") do { quit:ER
			new CLS,SEGFLG
			set CLS=Db.getOneRow("CLS","ACN","XCID")
			if CLS'="D" quit
			set SEGFLG=Db.getOneRow("SEGFLG","DEP","XCID")
			if SEGFLG=1 do Runtime.setErrMSG("EFTPAY",3350,"RM") quit:ER
			}

		if eftpay.expdt'="" do { quit:ER			//MCA 6-6-00
			new CAL,UFRE,bd
			set CAL=Db.getOneRow("CALENDAR","CRCD","%CompanyName,CRCD")
			set UFRE=eftpay.frequency
			set bd=Db.getOneRow("BD","USRFRE","UFRE")
			if (bd'=""&(bd'["A")),'$$BD^UNBD(eftpay.expdt,CAL) do Runtime.setErrMSG("EFTPAY",6062) quit:ER //MCA 6-6-00
			else  if UFRE'["A",'$$BD^UNBD(eftpay.expdt,CAL) do Runtime.setErrMSG("EFTPAY",6062) quit:ER	//MCA 6-6-00
			if eftpay.efd>eftpay.expdt do Runtime.setErrMSG("EFTPAY",6063) quit:ER
			}

		if eftpay.ttype<2,eftpay.hldauto do { quit:ER
			new HSEQ
			S HSEQ=$$PLHLDS^EFTFUNCS(.eftpay)
			if HSEQ=0 do Runtime.setErrMSG("EFTPAY",630) quit
			set eftpay.hldseq=HSEQ
			}
																}

	// Outgoing Foreign Payment Orders
	if STBLEFT="NDPO" do { quit:ER

		if eftpay.refno="" do REFNO^PROCEFT(2,.eftpay) quit:ER
		// assign ORD fields if they have not been entered into the record
		do ACNIP^PROCEFT(eftpay.acn,.eftpay)
	
		// Place calculated values in the record
		do CALCANT^PROCEFT(.eftpay) quit:ER
	
		// Validate currency and default payment currency related fields
		do CRCDIP^PROCEFT(eftpay.crcd,.eftpay) quit:ER

		// Default to an external payment
		if eftpay.intext="" set eftpay.intext=1

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// Default PROCDT and EFD
		set PROCDT=eftpay.procdt
		set VALDT=eftpay.efd
		do DATIP^PROCEFT(eftpay.crcd,eftpay.efttype,eftpay.sendcorr,.PROCDT,.VALDT) quit:ER
		if eftpay.procdt="" set eftpay.procdt=PROCDT
		if eftpay.efd="" set eftpay.efd=VALDT

		// places hold on outgoing clean payment for inserts if nondoc PO and 'ogl.
		if eftpay.ttype<2 do { quit:ER
			new HSEQ

			// now insert the hold into PHLD
			set HSEQ=$$PLHLDS^EFTFUNCS(.eftpay)
			if HSEQ=0 do Runtime.setErrMSG("EFTPAY",630) quit 
			set eftpay.hldseq=HSEQ

			// Hold is always placed. Set HLDAUTO=1 so hold removals work.
			set eftpay.hldauto=1
			}
		}
	
	// Incoming Foreign Payment Orders
	if STBLEFT="NDPOIN" do { quit:ER
	
		if eftpay.refno="" do REFNO^PROCEFT(3,.eftpay) quit:ER

		// Decimal precision error
		if eftpay.amount#($$MOD^SCARND("",eftpay.crcd)) do Runtime.setErrMSG("EFTPAY",775) quit:ER
		do CALCANT^PROCEFT(.eftpay) quit:ER
		do BENIP^PROCEFT(eftpay.acn,.eftpay)

		// Validate currency and default payment currency related fields
		do CRCDIP^PROCEFT(eftpay.crcd,.eftpay) quit:ER

		// Default to an external payment
		if eftpay.intext="" set eftpay.intext=1

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// Default PROCDT and EFD
		set PROCDT=eftpay.procdt
		set VALDT=eftpay.efd
		do DATIP^PROCEFT(eftpay.crcd,eftpay.efttype,eftpay.sendcorr,.PROCDT,.VALDT) quit:ER
		if eftpay.procdt="" set eftpay.procdt=PROCDT
		if eftpay.efd="" set eftpay.efd=VALDT

		if eftpay.constant="" do { quit:ER
			new ccycid,XCID
			set XCID=eftpay.cid
			if eftpay.ttype>1 set ccycid=eftpay.crcd
			else  set ccycid=Db.getOneRow("CRCD","ACN","XCID")

			//currency can not equal system currency
			if ccycid=%SystemCurrency new MSG set MSG="CRCD" do Runtime.setErrMSG("EFTPAY",7531,"MSG") quit:ER
			}
		}
	
	// Standing payment foreign orders
	if STBLEFT="NDPOST" do { quit:ER

		new NJD
		set NJD=$$NJD^UFRE(%SystemDate,eftpay.frequency) if ER do Runtime.setErrMSG("EFTPAY",3333,"RM") quit:ER
		if eftpay.frequency'="" do { quit:ER
			if eftpay.frequency<0 do Runtime.setErrMSG("EFTPAY",1354) quit:ER
			set eftpay.efd=eftpay.procdt
			if eftpay.procdt'="" quit 
			set eftpay.procdt=NJD
			set eftpay.efd=NJD
			}
	
		if eftpay.expdt'="" do { quit:ER

			// Expiration date precedes system date.
			if eftpay.expdt<%SystemDate do Runtime.setErrMSG("EFTPAY",1843) quit:ER
	
			// Expiration date precedes next process date.
			if eftpay.expdt<eftpay.procdt do Runtime.setErrMSG("EFTPAY",1846) quit:ER
			}

		//Enter either payment amount or account amount.
		if eftpay.amount'="",eftpay.antamt'="" do Runtime.setErrMSG("EFTPAY",1883) quit:ER
		if eftpay.amount="",eftpay.antamt="" do Runtime.setErrMSG("EFTPAY",1883) quit:ER
	
		//Payment amount must have a positive value.
		if eftpay.amount<0 do Runtime.setErrMSG("EFTPAY",1888) quit:ER
		if eftpay.antamt<0 do Runtime.setErrMSG("EFTPAY",1888) quit:ER
		}

	new TOTLEN
	set TOTLEN=$L(eftpay.msg1)+$L(eftpay.msg2)+$L(eftpay.msg3)+$L(eftpay.msg4)
	set TOTLEN=TOTLEN+$L(eftpay.recinst)+$L(eftpay.recacct)+$L(eftpay.efttype)
	set TOTLEN=TOTLEN+$L(eftpay.seq)+$L(eftpay.benad1)+$L(eftpay.cid)+$L(eftpay.lnm)
	set TOTLEN=TOTLEN+$L(eftpay.constant)+$L(eftpay.variable)+$L(eftpay.specific)
	set TOTLEN=TOTLEN+$L(eftpay.met)+$L(eftpay.source)+$L(eftpay.thold)
	set TOTLEN=TOTLEN+4
	if TOTLEN>200 do Runtime.setErrMSG("EFTPAY",2338,"RM") quit:ER
	
	quit

vbu1 // Trigger BEFORE_SENDNOS - Before Update of SENDNOS

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/*
	 ---- Revision History ------------------------------------------------

	 10/17/02 - RICKARDSC - 49098
		Added call to DATIP for foreign payments

	 10/29/01 - RICKARDSC - 45998
		Modified to use NOSIP^PROCEFT to default SENDNOS and SENDCORR

	 10/15/01 - SIGDAE - 47552
		Change 3rd argument for call to NOSSPP^DEALSINT to be 
		SENDNOS instead of X.

	 06/11/01 - SIGDAE - 45301
		Miscellaneous clean-up.

		Deleted pre-2000 revision history.
	*/

	new erstr,EFTTYPE,PROCDT,VALDT

	type RecordCTBLEFTTYPE etype

	set EFTTYPE=eftpay.efttype
	set etype=Db.getRecord("CTBLEFTTYPE","EFTTYPE")

	// Invalid offset in (efttype) for Effective Date:
	set erstr=EFTTYPE_"~"_$$^MSG(5951,eftpay.efd)
	if etype.fintras=1,eftpay.efd'=(%SystemDate+etype.ftod) do Runtime.setErrMSG("EFTPAY",5407,erstr)

	// Outgoing and Incoming Foreign Payment Orders
	if (eftpay.efttype="NDPO")!(eftpay.efttype="NDPOIN") do {

		// Default to an external payment
		if eftpay.intext="" set eftpay.intext=1

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// Default PROCDT and EFD
		set PROCDT=eftpay.procdt
		set VALDT=eftpay.efd
		do DATIP^PROCEFT(eftpay.crcd,eftpay.efttype,eftpay.sendcorr,.PROCDT,.VALDT) quit:ER
		if eftpay.procdt="" set eftpay.procdt=PROCDT
		if eftpay.efd="" set eftpay.efd=VALDT
	}
	quit

vbu2 // Trigger BEFORE_SOURCEDD - Update before SOURCEDD

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/*
	 ---Revision History----------------------------------------------------------

	 06/11/01 - SIGDAE - 45301
		    Replaced reference to eftpay.efttype with STBLEFTTYPE value.

		    Removed pre-2000 revision history
	*/

	new STBLEFT
	set STBLEFT=eftpay.efttype
	set STBLEFT=Db.getOneRow("STBLEFT","CTBLEFTTYPE","STBLEFT")
	/*
	   Set the source of the direct debit to 1 (Manually Input). If the payment
	   is a direct debit.
	*/
	if STBLEFT="DD" set eftpay.eftsrcdd=1
	quit

vbu3 // Trigger BEFORE_STATUS - Before Update of Status

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/*
	 ---Revision History----------------------------------------------------------

	 12/06/01 - SIGDAE - 48608
		Added code to call DATES^EFTFUNCS to define next possible
		effective date and corresponding process date when 
		resubmitting a suppressed order.

	 06/11/01 - SIGDAE - 45301
		Miscellaneous clean-up.  Removed insert of DAYENDEFT record.
		Since this is an index, updating PROCDT will handle the
		creation of the new entry.

		Deleted pre-2000 revision history.
	*/

	// Resubmit of Suppressed order - set new EFD and PROCDT if necessary
	if eftpay.status="A",eftpay.status.oldVal="SUP",eftpay.procdt<%SystemDate do {
		new ONUS,PROCDT,RECINST,STBLEFT
		set RECINST=eftpay.recinst
		set ONUS=Db.getOneRow("ONUS","UTBLEFTINST","RECINST")
		set STBLEFT=eftpay.efttype
		set STBLEFT=Db.getOneRow("STBLEFT","CTBLEFTTYPE","STBLEFT")
		set eftpay.efd=$$DATES^EFTFUNCS(%SystemDate,"1DA",ONUS,0,STBLEFT,eftpay.crcd,.PROCDT)
		set eftpay.procdt=PROCDT
	}
	quit

vbu4 // Trigger BEFORE_UPDATE - EFTPAY Before Update Trigger

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/*
	   ---- Revision History -----------------------------------------------
	  
	  01/10/03 - KINI - 51316
		     Removed quit in the middle of the code since it prevented 
		     successful filer compilation and subsequent code 
		     execution.          	   
	
	  06/11/01 - SIGDAE - 45301
		     Miscellaneous clean-up.
		     Deleted pre-2000 revision history.

	  08/07/00 - SCHWARTZC - 41394
	             Modified to set eftpay.lnm when it is null. eftpay.lnm
		     is required for maker checker processing.

	  02/09/00 - SCHWARTZC - 35615
		     Modify change made on 01/11/00 to include reversals.

	  01/11/00 - KELLYP - 35902
		     Modified to allow modifications to the EFTPAY record
		     for status "C", "R", and "D" in the event that it is
		     being modified because of a cancellation or return.
	*/

	new oldstat
	set oldstat=eftpay.status.oldVal
	if '$G(EXPORT)&'$G(CANCEL)&'$G(RETURN)&'$G(REVERSE)&((oldstat="C")!(oldstat="R")!(oldstat="D")) do Runtime.setErrMSG("EFTPAY",7669,oldstat) quit

	/*
	   CDS 8/23/99
	   Verify that the amount entered conforms to the decimal precision of the
	   payment currency.
	*/
	new curdec,DECPRS,CO,EMUMEM,CRCD
	set CO=%CompanyName
	set CRCD=eftpay.crcd
	set curdec=Db.getOneRow("CURDEC","CRCD","CO,CRCD") quit:ER
	set DECPRS=.1**curdec
	if eftpay.amount#DECPRS>0 do Runtime.setErrMSG("EFTPAY",775) quit:ER

	if (eftpay.ttype<2),(eftpay.lnm="") do {
		new LNM,XCID
		set XCID=eftpay.cid
		set LNM=Db.getOneRow("LNM","ACN","XCID")
		set eftpay.lnm=LNM
		}
	quit

vbu5 // Trigger BEFORE_UPDATE_MSG - Before Update MSG

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)

	new TOTLEN
	set TOTLEN=$L(eftpay.msg1)+$L(eftpay.msg2)+$L(eftpay.msg3)+$L(eftpay.msg4)
	set TOTLEN=TOTLEN+$L(eftpay.recinst)+$L(eftpay.recacct)+$L(eftpay.efttype)
	set TOTLEN=TOTLEN+$L(eftpay.seq)+$L(eftpay.benad1)+$L(eftpay.cid)+$L(eftpay.lnm)
	set TOTLEN=TOTLEN+$L(eftpay.constant)+$L(eftpay.variable)+$L(eftpay.specific)
	set TOTLEN=TOTLEN+$L(eftpay.met)+$L(eftpay.source)+$L(eftpay.thold)
	set TOTLEN=TOTLEN+4
	if TOTLEN>200 do Runtime.setErrMSG("EFTPAY",2338,"RM") quit:ER
	quit

vbu6 // Trigger BEFORE_UPD_ACCOUNT - Before Updating Account Number

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)

	/* 
	   ---Revision History-------------------------------------------------------------------------

	   12/12/01 - SIGDAE - 48558
		Replaced EFTMEMO check code with call to GLCHECK^PROCEFT.

	   10/18/01 - SIGDAE - 47857
		Added code to check domestic payment ONUS recipient
		account to see if it is valid and not closed.

	   06/11/01 - SIGDAE - 45301
		Miscellaneous clean-up.

		Deleted pre-2000 revision history.
	   
	   12/14/00 - JERUCHIMC - 43158
		Expand Memo G/L account edit check to include header G/Ls.
	
	   12/10/00 - JERUCHIMC - 43150 (roll forward 41875)
		Add edit check for Memo G/L account
	*/

	new STBLEFT

	new STBLEFT
	set STBLEFT=eftpay.efttype
	set STBLEFT=Db.getOneRow("STBLEFT","CTBLEFTTYPE","STBLEFT")

	do GLCHECK^PROCEFT(eftpay.efttype,eftpay.ttype,eftpay.cid,eftpay.recinst,eftpay.recacct)
								quit:ER

								// Domestic payment ONUS recipient account
								if STBLEFT'["NDPO",'(eftpay.ttype#2) do { quit:ER
		new ONUS,RECACCT,RECINST,STAT
		set RECINST=eftpay.recinst
		set ONUS=Db.getOneRow("ONUS","UTBLEFTINST","RECINST")
		if 'ONUS quit
	
		set RECACCT=eftpay.recacct
		// ~p1 is not a valid account number
		if '+RECACCT do Runtime.setErrMSG("EFTPAY",7683,RECACCT) quit:ER
		if 'Db.isDefined("ACN","RECACCT") do Runtime.setErrMSG("EFTPAY",7683,RECACCT) quit:ER
		set STAT=Db.getOneRow("STAT","ACN","RECACCT")
	
		// Account ~p1 is closed
		if STAT=4 do Runtime.setErrMSG("EFTPAY",6050,RECACCT) quit:ER
								}

	/*
	   The following checks that for a payment order or standing payment order, the
	   originating account is not segmented, unless segment information is supplied
	   in UNIQTSO.
	*/
	I STBLEFT["PO",'(eftpay.uniqtso["SEGI#")&'(eftpay.uniqtso["SEGP#") do {
		new CLS,SEGFLG,XCID
		set XCID=eftpay.cid
		set CLS=Db.getOneRow("CLS","ACN","XCID")
		if CLS'="D" quit
		set SEGFLG=Db.getOneRow("SEGFLG","DEP","XCID")
		; Cannot manually create payment orders for segmented accounts
		if SEGFLG=1 do Runtime.setErrMSG("EFTPAY",3350,"RM") quit:ER
		}
	quit

vbu7 // Trigger BEFORE_UPD_CRCTACCT - Before Update Correct Account

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/* ---Revision History-------------------------------------------------------------------------
	
	01/06/04 - CARROLLJ - CR7658
		Added #ACCEPT prior to xecute command.

	08/07/01 - SIGDAE - 46611
		Modified the call to PROCRICO^PROCRICO to use new function
		NEWACCT^PROCRICO().

		Removed older revision history,
	*/

	new CRCTACCT,CRCTGL,NEWCID,NEWCIDSQ,NEWSEQ,newcid
	set CRCTACCT=eftpay.crctacct
	set CRCTGL=eftpay.crctgl
	if CRCTACCT'="" set newcid=Db.getOneRow("CID","ACN","CRCTACCT")
	if CRCTGL'="" set newcid=Db.getOneRow("ACN","GLAD","CRCTGL")
	
	//~p1 Not a valid account number
	if (CRCTACCT'=""),(newcid="") set ER=1,RM=$$^MSG(3058,CRCTACCT) quit

	//Invalid G/L account ~p1
	if (CRCTGL'=""),(newcid="") set ER=1,RM=$$^MSG(1364,CRCTGL) quit

	if eftpay.repost'=1 quit

	// Call to PSL procedure to handle changing the account number
	set NEWCIDSQ=$$NEWACCT^PROCRICO(CID,SEQ,CRCTACCT,CRCTGL)
	if ER quit
	if NEWCIDSQ="" quit
	set NEWCID=$P(NEWCIDSQ,"|",1)
	set NEWSEQ=$P(NEWCIDSQ,"|",2)

	set eftpay.status="D"

	// Protect SEQ
	new SEQ

	// Process the partial payment record via call to public linetag in batch
	set PGM=$$GET^UBCHID("BCHEFT") if PGM="" quit
	set XECUTE="D public^"_PGM_"(NEWCID,NEWSEQ)"
	#ACCEPT DATE=12/30/03;PGM=John Carroll
	xecute XECUTE
	quit

vbu8 // Trigger BEFORE_UPD_HLDAUTO - Maintain Holds on HLDAUTO

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/*
		---Revision History-----------------------------------------------------

		05/22/02 - SIGDAE - 49389
		Removed setting of HLDSEQ="" after call to RMHLDS^EFTFUNCS.

		12/06/01 - SIGDAE - 48608
		Modified calls to place holds to use new PSL version of
		PLHLDS^EFTFUNCS.

		07/17/01 - SIGDAE - 45449
		Added argument FREQUENCY to PLHLDS2^EFTFUNCS call.
	
		06/11/01 - SIGDAE - 45301
		Changed call for domestic order holds to use new function
		PLHLDS2^EFTFUNCS.

		01/05/01 - Carol Scott - 43034
  		This trigger will either remove a hold if the HLDAUTO flag 
		is turned off, or add a hold if the hold auto flag is set.
	*/

	if eftpay.ttype>1 quit

	//Add hold
	if eftpay.hldauto=1 do { quit:ER   
	new HSEQ
	S HSEQ=$$PLHLDS^EFTFUNCS(.eftpay)
	if HSEQ=0 do Runtime.setErrMSG("EFTPAY",630) quit:ER
	set eftpay.hldseq=HSEQ
	}

	// Remove hold
	if eftpay.hldauto=0 do { quit:ER
	new HLDREM
	set HLDREM=$$RMHLDS^EFTFUNCS(eftpay.cid,eftpay.seq)
	if 'HLDREM do Runtime.setErrMSG("EFTPAY",7675) quit:ER
	}
	quit

vbu9 // Trigger BEFORE_UPD_MSGFP - Validate foreign payment message format

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	;-----------Revision History------------------------------------------
	;
	; 12/20/99 - KARPIAKP - 36155 (orig 35442)
 	;            Added code to pass parameters to MSGCHK function to indicate
 	;            the name of the column. It is required by MSGCHK to generate
 	;            the error message if the value does not pass the validation,
 	;            otherwise an undefined error is being generated by ^PROCEFT.
 	;            Changed last line where If statement was testing MSGFP5 while
 	;            the editcheck was performed for MSGFP6.

	// Validate message format /text/ or //text
	
	new X
	if eftpay.msgfp1'="" set X=eftpay.msgfp1 do MSGCHK1^PROCEFT
	if eftpay.msgfp2'="" set X=eftpay.msgfp2 do MSGCHK^PROCEFT(0,"MSGFP2") set eftpay.msgfp2=X quit:ER
	if eftpay.msgfp3'="" set X=eftpay.msgfp3 do MSGCHK^PROCEFT(0,"MSGFP3") set eftpay.msgfp3=X quit:ER
	if eftpay.msgfp4'="" set X=eftpay.msgfp4 do MSGCHK^PROCEFT(0,"MSGFP4") set eftpay.msgfp4=X quit:ER
	if eftpay.msgfp5'="" set X=eftpay.msgfp5 do MSGCHK^PROCEFT(0,"MSGFP5") set eftpay.msgfp5=X quit:ER
	if eftpay.msgfp6'="" set X=eftpay.msgfp6 do MSGCHK^PROCEFT(0,"MSGFP6") set eftpay.msgfp6=X quit:ER
	quit

vbu10 // Trigger BEFORE_UPD_REJECT - Before Update Reject

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)

	/* ---Revision History-------------------------------------------------------------------------
	
	   10/18/99 - DUJ - 33890
			Converted M code to PSL.

	   5/17/99 - JERUCHIMC - 32492
			Set status to rejected if we are rejecting the order.
	*/

	if eftpay.reject'=1 quit
	set eftpay.status="R"
	quit

vbu11 // Trigger BEFORE_UPD_SETCRCD - Before Update of SETCRCD

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/* ---Revision History-------------------------------------------------------------------------
	
	   10/26/01 - RICKARDSC - 45998
			Modified SETCRCD default logic to use CUVAR.SCDFT, and
			added calls to NOSIP^PROCEFT for foreign payments.

	   10/18/99 - DUJ - 33890
			Converted M code to PSL.

	   02/25/99 - JERUCHIMC - 32010
			Set settlement currency to 0 for a non-In currency.
	
	   07/29/98 - JERUCHIMC - 28545
			Set UX array for EFTPAY.EURAMT
	
	   06/19/98 - JERUCHIMC - 28545
			Set the EURRATE and EURAMT data items and default payment information 
			into MSGFP1 (which represents SWIFT field 32) whenever settlement currency =1.
			Do not allow null value of SETCRCD.
	*/

	new CRCD,EMUMEM,EURAMT,SCDFT

	/*
	 Default settlement currency flag
	 Settlement currency must equal 0 for a non-In currency.
	*/
	set CRCD=eftpay.crcd
	set EMUMEM=Db.getOneRow("EMU","CRCD","%CompanyName,CRCD")
	if EMUMEM=1 do {
		set SCDFT=Db.getOneRow("SCDFT","CUVAR")
		if eftpay.setcrcd="" set eftpay.setcrcd=+SCDFT
		}
	else  set eftpay.setcrcd=0

	// Outgoing foreign payment
	if eftpay.efttype="NDPO" do { quit:ER

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// If SETCRCD=1, default EURRATE, EURAMT, and MSGFP1
		if eftpay.setcrcd'=1 quit

		set eftpay.msgfp1="/OCMT/"_eftpay.crcd_eftpay.amount_",/"
		set eftpay.eurrate=$$FNCRATE^EFTUTL(eftpay.crcd)
		set EURAMT=eftpay.amount/eftpay.eurrate
		set eftpay.euramt=$$^SCARND(EURAMT,,,,2)
		}

	// Incoming foreign payment
	if eftpay.efttype="NDPOIN" do { quit:ER

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""
		}
	quit

vbu12 // Trigger BEF_UPD_AMT_CRCD - Before Update of AMOUNT,CRCD,FEECONV,CCO

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/* 
	 ---Revision History-------------------------------------------------------------------------

	 10/17/02 - RICKARDSC - 49098
		Added call to DATIP for foreign payments

	 05/22/02 - SIGDAE - 49389
		Removed setting of HLDSEQ="" after call to RMHLDS^EFTFUNCS.

	 02/08/02 - RICKARDSC - 48359
		Added feetype, antrate, rcvrchg, rcvrchgc and feepayor to
		the UPDATE column list for the trigger.

	 12/06/01 - SIGDAE - 48608
		Modified call to place holds to use new PSL 
		version of PLHLDS^EFTFUNCS.  Also replaced
		call to HLDAMT^EFTFUNCS with a Db.getOneRow call.

	 10/26/01 - RICKARDSC - 45998
		Added calls to CRCDIP^PROCEFT & NOSIP^PROCEFT for
		incoming and outgoing foreign payments.

	 07/24/01 - YURKOVICG - 45987
	 	Modified code that handles NDPO type payment
		orders.  Since code was added to BEFORE_INSERT
		trigger to set HLDAUTO=1 for all NDPO's, no 
		need to check EFTTYPE if HLDAUTO=1.
		Cleaned up structure of code at end of trigger.

	 07/17/01 - SIGDAE - 45449
		Added argument FREQUENCY to PLHLDS2^EFTFUNCS call.

	 06/11/01 - SIGDAE - 45301
		Changed call for domestic order holds to use new 
		function PLHLDS2^EFTFUNCS.

		Removed pre-2000 revision history
	
	 02/10/00 - SCHWARTZC - 35615
		Fix for PSL conversion.
	*/

	new PROCDT,VALDT,XAMT

	// Cannot be a negative amount
	if eftpay.amount<0 do Runtime.setErrMSG("EFTPAY",415) quit:ER
	
	// Decimal precision error
	set XAMT=eftpay.amount
	if eftpay.efttype="NDPOIN" do { quit:ER
		if XAMT#($$MOD^SCARND("",eftpay.crcd)) do Runtime.setErrMSG("EFTPAY",775) quit:ER
		do CALCANT^PROCEFT(.eftpay) quit:ER

		// Validate and default payment currency related fields
		do CRCDIP^PROCEFT(eftpay.crcd,.eftpay) quit:ER

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// Default PROCDT and EFD
		set PROCDT=eftpay.procdt
		set VALDT=eftpay.efd
		do DATIP^PROCEFT(eftpay.crcd,eftpay.efttype,eftpay.sendcorr,.PROCDT,.VALDT) quit:ER
		if eftpay.procdt="" set eftpay.procdt=PROCDT
		if eftpay.efd="" set eftpay.efd=VALDT
		}
	
	if eftpay.efttype="NDPO" do { quit:ER
		do CALCANT^PROCEFT(.eftpay) quit:ER

		// Validate and default payment currency related fields
																do CRCDIP^PROCEFT(eftpay.crcd,.eftpay) quit:ER

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// Default PROCDT and EFD
		set PROCDT=eftpay.procdt
		set VALDT=eftpay.efd
		do DATIP^PROCEFT(eftpay.crcd,eftpay.efttype,eftpay.sendcorr,.PROCDT,.VALDT) quit:ER
		if eftpay.procdt="" set eftpay.procdt=PROCDT
		if eftpay.efd="" set eftpay.efd=VALDT
		}

	// The code below is for hold functionality only
	if eftpay.hldauto'=1!(eftpay.ttype>1) quit
	
	/*
	   Places hold on outgoing clean payment if amount changed only 
	   on payment orders where status '= delete, and 'ogl.
	*/
	if eftpay.status'="D",(((eftpay.amount.oldVal'=eftpay.amount))!((eftpay.anttotal.oldVal'=eftpay.anttotal))) do {
		new HSEQ,X

		set HSEQ=eftpay.hldseq

		// if verify or approval and amount is same on hold, just quit.
		if HSEQ'="",(eftpay.anttotal=Db.getOneRow("AMT","PHLD","CID,HSEQ")),((eftpay.status="V")!(eftpay.status="AP")) quit
	
		// Otherwise try to delete old holds.
		set X=$$RMHLDS^EFTFUNCS(eftpay.cid,eftpay.seq)
		if 'X do Runtime.setErrMSG("EFTPAY",8343) quit
	
		// Now place new holds.
		set HSEQ=$$PLHLDS^EFTFUNCS(.eftpay)
		if HSEQ=0 do Runtime.setErrMSG("EFTPAY",630) quit
		set eftpay.hldseq=HSEQ
	}
	quit

vbu13 // Trigger BU_PTYSTAT - Populate PTYSTAT if changed to null

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
								//  Populate PTYSTAT if PTYSTAT is null
	if eftpay.ptystat="" set eftpay.ptystat=999
	
								//        Display message if trying to prioritize anything but an SPO
								//        "Only Standing Payments Order may have a priority status".
	if (eftpay.efttype'="SPO"),(eftpay.ptystat'=999) do Runtime.setErrMSG("EFTPAY",4187,"RM") quit:ER
	quit


vddver // Validate data dictionary attributes

	type public Number %O
	type public String vpar,vx()

	type String vRM,X
	type public RecordEFTPAY eftpay

	if (%O = 2) do vload

	if vobj(eftpay,0).exists() do {

		set X = eftpay.acn if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("ACN", vRM) quit
		set X = eftpay.addhld if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ADDHLD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.antamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ANTAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.antfee1 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ANTFEE1"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.antfee2 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ANTFEE2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.antrate if 'X.isNull() set vRM = $$VAL^DBSVER("N",12,0,,,,,6) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ANTRATE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.anttotal if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ANTTOTAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if eftpay.benacn.length()>34 set vRM = $$^MSG(1076,34) do vdderr("BENACN", vRM) quit
		if eftpay.benad1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BENAD1", vRM) quit
		if eftpay.benad2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BENAD2", vRM) quit
		if eftpay.benad3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BENAD3", vRM) quit
		if eftpay.benad4.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BENAD4", vRM) quit
		set X = eftpay.beninst if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("BENINST", vRM) quit
		if eftpay.beninst1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BENINST1", vRM) quit
		if eftpay.beninst2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BENINST2", vRM) quit
		if eftpay.beninst3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BENINST3", vRM) quit
		if eftpay.beninst4.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BENINST4", vRM) quit
		if eftpay.beninstl.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BENINSTL", vRM) quit
		set X = eftpay.benseq if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("BENSEQ", vRM) quit
		set X = eftpay.ccode if 'X.isNull(),'Db.isDefined("UTBLCC","X") set vRM = $$^MSG(1485,X) do vdderr("CCODE", vRM) quit
		if eftpay.cifinst.length()>40 set vRM = $$^MSG(1076,40) do vdderr("CIFINST", vRM) quit
		set X = eftpay.consndpo if 'X.isNull(),'Db.isDefined("UTBLFOREX","X") set vRM = $$^MSG(1485,X) do vdderr("CONSNDPO", vRM) quit
		if eftpay.crcdcid.length()>3 set vRM = $$^MSG(1076,3) do vdderr("CRCDCID", vRM) quit
		set X = eftpay.feeamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.FEEAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.feeamt2 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.FEEAMT2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[eftpay.FEECONV) set vRM=$$^MSG(742,"L") do vdderr("FEECONV", vRM) quit
		if eftpay.feecrcd.length()>3 set vRM = $$^MSG(1076,3) do vdderr("FEECRCD", vRM) quit
		if eftpay.feecrcd2.length()>3 set vRM = $$^MSG(1076,3) do vdderr("FEECRCD2", vRM) quit
		set X = eftpay.feepayor if 'X.isNull(),'Db.isDefined("STBLFEEPAYOR","X") set vRM = $$^MSG(1485,X) do vdderr("FEEPAYOR", vRM) quit
		set X = eftpay.feetype if 'X.isNull(),'Db.isDefined("EFTFEE","X") set vRM = $$^MSG(1485,X) do vdderr("FEETYPE", vRM) quit
		set X = eftpay.hldseq if 'X.isNull(),X'?1.5N,X'?1"-"1.4N set vRM=$$^MSG(742,"N") do vdderr("HLDSEQ", vRM) quit
		set X = eftpay.inter if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("INTER", vRM) quit
		if eftpay.inter1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("INTER1", vRM) quit
		if eftpay.inter2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("INTER2", vRM) quit
		if eftpay.inter3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("INTER3", vRM) quit
		if eftpay.inter4.length()>35 set vRM = $$^MSG(1076,35) do vdderr("INTER4", vRM) quit
		if '("01"[eftpay.INTTRN) set vRM=$$^MSG(742,"L") do vdderr("INTTRN", vRM) quit
		set X = eftpay.lchdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LCHDT", vRM) quit
		set X = eftpay.loaddate if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LOADDATE", vRM) quit
		if eftpay.ord1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("ORD1", vRM) quit
		if eftpay.ord2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("ORD2", vRM) quit
		if eftpay.ord3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("ORD3", vRM) quit
		if eftpay.ord4.length()>35 set vRM = $$^MSG(1076,35) do vdderr("ORD4", vRM) quit
		if eftpay.origamt.length()>15 set vRM = $$^MSG(1076,15) do vdderr("ORIGAMT", vRM) quit
		if eftpay.origamt2.length()>15 set vRM = $$^MSG(1076,15) do vdderr("ORIGAMT2", vRM) quit
		if eftpay.origcid.length()>12 set vRM = $$^MSG(1076,12) do vdderr("ORIGCID", vRM) quit
		if eftpay.origfile.length()>60 set vRM = $$^MSG(1076,60) do vdderr("ORIGFILE", vRM) quit
		set X = eftpay.origin if 'X.isNull(),'Db.isDefined("STBLEFTORG","X") set vRM = $$^MSG(1485,X) do vdderr("ORIGIN", vRM) quit
		set X = eftpay.pri2 if 'X.isNull(),'Db.isDefined("STBLPRIORITY","X") set vRM = $$^MSG(1485,X) do vdderr("PRI2", vRM) quit
		set X = eftpay.rate if 'X.isNull() set vRM = $$VAL^DBSVER("N",12,0,,,,,6) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.RATE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if eftpay.reccorr.length()>12 set vRM = $$^MSG(1076,12) do vdderr("RECCORR", vRM) quit
		set X = eftpay.recv if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("RECV", vRM) quit
		if eftpay.recvcorr.length()>12 set vRM = $$^MSG(1076,12) do vdderr("RECVCORR", vRM) quit
		set X = eftpay.recvopt if 'X.isNull(),'{List}"A,B,D".contains(X) set vRM = $$^MSG(1485,X) do vdderr("RECVOPT", vRM) quit
		if eftpay.refno.length()>20 set vRM = $$^MSG(1076,20) do vdderr("REFNO", vRM) quit
		if eftpay.relrefno.length()>16 set vRM = $$^MSG(1076,16) do vdderr("RELREFNO", vRM) quit
		set X = eftpay.sendcorr if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("SENDCORR", vRM) quit
		set X = eftpay.sendnos if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("SENDNOS", vRM) quit
		if eftpay.sndr.length()>35 set vRM = $$^MSG(1076,35) do vdderr("SNDR", vRM) quit
		if eftpay.uidacc.length()>20 set vRM = $$^MSG(1076,20) do vdderr("UIDACC", vRM) quit
		if eftpay.uidadd.length()>20 set vRM = $$^MSG(1076,20) do vdderr("UIDADD", vRM) quit
		if eftpay.uidapp.length()>20 set vRM = $$^MSG(1076,20) do vdderr("UIDAPP", vRM) quit
		if eftpay.uidmod.length()>20 set vRM = $$^MSG(1076,20) do vdderr("UIDMOD", vRM) quit
		if eftpay.uidver.length()>20 set vRM = $$^MSG(1076,20) do vdderr("UIDVER", vRM) quit
		set X = eftpay.varndpo if 'X.isNull(),'Db.isDefined("STBLCNTRY","X") set vRM = $$^MSG(1485,X) do vdderr("VARNDPO", vRM) quit
	}

	if vobj(eftpay,1).exists() do {

		if eftpay.msg1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("MSG1", vRM) quit
		if eftpay.msg2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("MSG2", vRM) quit
		if eftpay.msg3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("MSG3", vRM) quit
		if eftpay.msg4.length()>35 set vRM = $$^MSG(1076,35) do vdderr("MSG4", vRM) quit
		set X = eftpay.pcode if 'X.isNull(),'Db.isDefined("STBLEFTPCODE","X") set vRM = $$^MSG(1485,X) do vdderr("PCODE", vRM) quit
		set X = eftpay.rectype if 'X.isNull(),'Db.isDefined("UTBLEXTYP","X") set vRM = $$^MSG(1485,X) do vdderr("RECTYPE", vRM) quit
	}

	if vobj(eftpay,5).exists() do {

		if eftpay.msgfp1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("MSGFP1", vRM) quit
		if eftpay.msgfp2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("MSGFP2", vRM) quit
		if eftpay.msgfp3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("MSGFP3", vRM) quit
		if eftpay.msgfp4.length()>35 set vRM = $$^MSG(1076,35) do vdderr("MSGFP4", vRM) quit
		if eftpay.msgfp5.length()>35 set vRM = $$^MSG(1076,35) do vdderr("MSGFP5", vRM) quit
		if eftpay.msgfp6.length()>35 set vRM = $$^MSG(1076,35) do vdderr("MSGFP6", vRM) quit
	}

	if vobj(eftpay,10).exists() do {

		set X = eftpay.ordinst if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("ORDINST", vRM) quit
		if eftpay.ordinst1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("ORDINST1", vRM) quit
		if eftpay.ordinst2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("ORDINST2", vRM) quit
		if eftpay.ordinst3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("ORDINST3", vRM) quit
		if eftpay.ordinst4.length()>35 set vRM = $$^MSG(1076,35) do vdderr("ORDINST4", vRM) quit
	}

	if vobj(eftpay,11).exists() do {

		if eftpay.recv1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("RECV1", vRM) quit
		if eftpay.recv2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("RECV2", vRM) quit
		if eftpay.recv3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("RECV3", vRM) quit
		if eftpay.recv4.length()>35 set vRM = $$^MSG(1076,35) do vdderr("RECV4", vRM) quit
		if eftpay.recv5.length()>35 set vRM = $$^MSG(1076,35) do vdderr("RECV5", vRM) quit
		if eftpay.recv6.length()>35 set vRM = $$^MSG(1076,35) do vdderr("RECV6", vRM) quit
	}

	if vobj(eftpay,12).exists() do {

		if eftpay.brhqmsg1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BRHQMSG1", vRM) quit
		if eftpay.brhqmsg2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BRHQMSG2", vRM) quit
		if eftpay.brhqmsg3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BRHQMSG3", vRM) quit
		if eftpay.brhqmsg4.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BRHQMSG4", vRM) quit
		set X = eftpay.gltscode if 'X.isNull(),'Db.isDefined("STBLGLTSCODE","X") set vRM = $$^MSG(1485,X) do vdderr("GLTSCODE", vRM) quit
	}

	if vobj(eftpay,20).exists() do {

		if '("01"[eftpay.MT103FLG) set vRM=$$^MSG(742,"L") do vdderr("MT103FLG", vRM) quit
		if '("01"[eftpay.MT202FLG) set vRM=$$^MSG(742,"L") do vdderr("MT202FLG", vRM) quit
	}

	if vobj(eftpay,21).exists() do {

		if eftpay.benacnsw.length()>34 set vRM = $$^MSG(1076,34) do vdderr("BENACNSW", vRM) quit
		if eftpay.efdkey.length()>20 set vRM = $$^MSG(1076,20) do vdderr("EFDKEY", vRM) quit
		set X = eftpay.feeamtpmt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.FEEAMTPMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[eftpay.ORIGFEE) set vRM=$$^MSG(742,"L") do vdderr("ORIGFEE", vRM) quit
		if eftpay.origmtyp.length()>12 set vRM = $$^MSG(1076,12) do vdderr("ORIGMTYP", vRM) quit
		set X = eftpay.origseq if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("ORIGSEQ", vRM) quit
		if eftpay.origtrno.length()>17 set vRM = $$^MSG(1076,17) do vdderr("ORIGTRNO", vRM) quit
		if eftpay.prockey.length()>20 set vRM = $$^MSG(1076,20) do vdderr("PROCKEY", vRM) quit
		if '("01"[eftpay.REPAIR) set vRM=$$^MSG(742,"L") do vdderr("REPAIR", vRM) quit
		set X = eftpay.rtndt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("RTNDT", vRM) quit
		set X = eftpay.rtnfeeamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.RTNFEEAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.rtnfeeamt2 if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.RTNFEEAMT2"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if eftpay.rtnfeecrcd.length()>3 set vRM = $$^MSG(1076,3) do vdderr("RTNFEECRCD", vRM) quit
		set X = eftpay.rtnfeetype if 'X.isNull(),'Db.isDefined("EFTFEE","X") set vRM = $$^MSG(1485,X) do vdderr("RTNFEETYPE", vRM) quit
		set X = eftpay.rtntotcid if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.RTNTOTCID"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.rtntotpmt if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.RTNTOTPMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[eftpay.RTRNFLG) set vRM=$$^MSG(742,"L") do vdderr("RTRNFLG", vRM) quit
		set X = eftpay.subcc if 'X.isNull(),'Db.isDefined("UTBLCCNTR","X") set vRM = $$^MSG(1485,X) do vdderr("SUBCC", vRM) quit
		set X = eftpay.subscid if 'X.isNull(),'Db.isDefined("GLAD","X") set vRM = $$^MSG(1485,X) do vdderr("SUBSCID", vRM) quit
	}

	if vobj(eftpay,25).exists() do {

		set X = eftpay.bgtseq if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("BGTSEQ", vRM) quit
		if eftpay.blaccnbr.length()>40 set vRM = $$^MSG(1076,40) do vdderr("BLACCNBR", vRM) quit
		set X = eftpay.ptystat if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PTYSTAT", vRM) quit
	}

	if vobj(eftpay,100).exists() do {

		if eftpay.ordp.length()>35 set vRM = $$^MSG(1076,35) do vdderr("ORDP", vRM) quit
		if eftpay.rcvrcorp.length()>35 set vRM = $$^MSG(1076,35) do vdderr("RCVRCORP", vRM) quit
		if eftpay.sndrcorp.length()>35 set vRM = $$^MSG(1076,35) do vdderr("SNDRCORP", vRM) quit
		if eftpay.sndrp.length()>35 set vRM = $$^MSG(1076,35) do vdderr("SNDRP", vRM) quit
		if eftpay.trip.length()>35 set vRM = $$^MSG(1076,35) do vdderr("TRIP", vRM) quit
	}

	if vobj(eftpay,103).exists() do {

		set X = eftpay.actrcvrchg if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ACTRCVRCHG"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.bankop if 'X.isNull(),'Db.isDefined("STBLSWBOP","X") set vRM = $$^MSG(1485,X) do vdderr("BANKOP", vRM) quit
		set X = eftpay.ben if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("BEN", vRM) quit
		if eftpay.beninstp.length()>35 set vRM = $$^MSG(1076,35) do vdderr("BENINSTP", vRM) quit
		set X = eftpay.freeptr if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("FREEPTR", vRM) quit
		if eftpay.interp.length()>35 set vRM = $$^MSG(1076,35) do vdderr("INTERP", vRM) quit
		set X = eftpay.msgtyp if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("MSGTYP", vRM) quit
		set X = eftpay.ord if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("ORD", vRM) quit
		if eftpay.ordacc.length()>35 set vRM = $$^MSG(1076,35) do vdderr("ORDACC", vRM) quit
		if eftpay.origcrcd.length()>3 set vRM = $$^MSG(1076,3) do vdderr("ORIGCRCD", vRM) quit
		set X = eftpay.rcvrchg if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.RCVRCHG"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if eftpay.rcvrchgc.length()>3 set vRM = $$^MSG(1076,3) do vdderr("RCVRCHGC", vRM) quit
		if eftpay.regrep1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("REGREP1", vRM) quit
		if eftpay.regrep2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("REGREP2", vRM) quit
		if eftpay.regrep3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("REGREP3", vRM) quit
		set X = eftpay.sendinst if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("SENDINST", vRM) quit
		set X = eftpay.sworgamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.SWORGAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.swrate if 'X.isNull() set vRM = $$VAL^DBSVER("N",15,0,,,,,8) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.SWRATE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if eftpay.triadd1.length()>35 set vRM = $$^MSG(1076,35) do vdderr("TRIADD1", vRM) quit
		if eftpay.triadd2.length()>35 set vRM = $$^MSG(1076,35) do vdderr("TRIADD2", vRM) quit
		if eftpay.triadd3.length()>35 set vRM = $$^MSG(1076,35) do vdderr("TRIADD3", vRM) quit
		if eftpay.triadd4.length()>35 set vRM = $$^MSG(1076,35) do vdderr("TRIADD4", vRM) quit
		set X = eftpay.trib if 'X.isNull(),'Db.isDefined("UTBLCORRE","X") set vRM = $$^MSG(1485,X) do vdderr("TRIB", vRM) quit
		if eftpay.trntypcd.length()>3 set vRM = $$^MSG(1076,3) do vdderr("TRNTYPCD", vRM) quit
	}
	set X = eftpay.cid if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("CID", vRM) quit
	set X = eftpay.seq if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("SEQ", vRM) quit

	if vobj(eftpay,"EUR").exists() do {

		if '("01"[eftpay.ERIVALID) set vRM=$$^MSG(742,"L") do vdderr("ERIVALID", vRM) quit
		set X = eftpay.euramt if 'X.isNull() set vRM = $$VAL^DBSVER("N",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.EURAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.eurrate if 'X.isNull() set vRM = $$VAL^DBSVER("N",12,0,,,,,6) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.EURRATE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.setcrcd if 'X.isNull(),'Db.isDefined("STBLEURSC","X") set vRM = $$^MSG(1485,X) do vdderr("SETCRCD", vRM) quit
	}

	if vobj(eftpay).exists() ! 'vobj(eftpay,"").order().isNull() do {

		set X = eftpay.actamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ACTAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.actamtfee if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ACTAMTFEE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.actcnv if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ACTCNV"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.actfee if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.ACTFEE"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.amount if 'X.isNull() set vRM = $$VAL^DBSVER("$",15,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.AMOUNT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.amttyp if 'X.isNull(),'Db.isDefined("STBLAMTTYP","X") set vRM = $$^MSG(1485,X) do vdderr("AMTTYP", vRM) quit
		if eftpay.benname.length()>32 set vRM = $$^MSG(1076,32) do vdderr("BENNAME", vRM) quit
		set X = eftpay.brcd if 'X.isNull(),'Db.isDefined("UTBLBRCD","X") set vRM = $$^MSG(1485,X) do vdderr("BRCD", vRM) quit
		set X = eftpay.cc if 'X.isNull(),'Db.isDefined("UTBLCCNTR","X") set vRM = $$^MSG(1485,X) do vdderr("CC", vRM) quit
		set X = eftpay.chkid if 'X.isNull(),'Db.isDefined("SCAU","X") set vRM = $$^MSG(1485,X) do vdderr("CHKID", vRM) quit
		set X = eftpay.constant if 'X.isNull(),'Db.isDefined("UTBLECOACT","X") set vRM = $$^MSG(1485,X) do vdderr("CONSTANT", vRM) quit
		set X = eftpay.crcc if 'X.isNull(),'Db.isDefined("UTBLCCNTR","X") set vRM = $$^MSG(1485,X) do vdderr("CRCC", vRM) quit
		if eftpay.crcd.length()>3 set vRM = $$^MSG(1076,3) do vdderr("CRCD", vRM) quit
		set X = eftpay.crctacct if 'X.isNull(),X'?1.20N,X'?1"-"1.19N set vRM=$$^MSG(742,"N") do vdderr("CRCTACCT", vRM) quit
		set X = eftpay.crctgl if 'X.isNull(),X'?1.20N,X'?1"-"1.19N set vRM=$$^MSG(742,"N") do vdderr("CRCTGL", vRM) quit
		if '("01"[eftpay.CREATSEQ) set vRM=$$^MSG(742,"L") do vdderr("CREATSEQ", vRM) quit
		if eftpay.custid.length()>32 set vRM = $$^MSG(1076,32) do vdderr("CUSTID", vRM) quit
		set X = eftpay.datecre if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("DATECRE", vRM) quit
		set X = eftpay.daysoutstndg if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("DAYSOUTSTNDG", vRM) quit
		set X = eftpay.efd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EFD", vRM) quit
		set X = eftpay.eftsrcdd if 'X.isNull(),'Db.isDefined("STBLEFTSRCDD","X") set vRM = $$^MSG(1485,X) do vdderr("EFTSRCDD", vRM) quit
		set X = eftpay.efttype if 'X.isNull(),'Db.isDefined("CTBLEFTTYPE","X") set vRM = $$^MSG(1485,X) do vdderr("EFTTYPE", vRM) quit
		if eftpay.etc.length()>10 set vRM = $$^MSG(1076,10) do vdderr("ETC", vRM) quit
		set X = eftpay.expdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EXPDT", vRM) quit
		if '("01"[eftpay.EXTTRF) set vRM=$$^MSG(742,"L") do vdderr("EXTTRF", vRM) quit
		set X = eftpay.frequency if 'X.isNull() set vRM = "" do DBSEDT^UFRE("[EFTPAY]FREQUENCY",0) if 'vRM.get().isNull() do vdderr("FREQUENCY", vRM) quit
		if '("01"[eftpay.HLDAUTO) set vRM=$$^MSG(742,"L") do vdderr("HLDAUTO", vRM) quit
		set X = eftpay.intext if 'X.isNull(),'{List}"0,1".contains(X) set vRM = $$^MSG(1485,X) do vdderr("INTEXT", vRM) quit
		if eftpay.lnm.length()>20 set vRM = $$^MSG(1076,20) do vdderr("LNM", vRM) quit
		set X = eftpay.lpdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LPDT", vRM) quit
		set X = eftpay.lppdate if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LPPDATE", vRM) quit
		set X = eftpay.met if 'X.isNull(),'Db.isDefined("STBLPAYMET","X") set vRM = $$^MSG(1485,X) do vdderr("MET", vRM) quit
		set X = eftpay.mkrid if 'X.isNull(),'Db.isDefined("SCAU","X") set vRM = $$^MSG(1485,X) do vdderr("MKRID", vRM) quit
		if eftpay.msg103dt.length()>22 set vRM = $$^MSG(1076,22) do vdderr("MSG103DT", vRM) quit
		if eftpay.msg192dt.length()>22 set vRM = $$^MSG(1076,22) do vdderr("MSG192DT", vRM) quit
		if eftpay.msg199dt.length()>22 set vRM = $$^MSG(1076,22) do vdderr("MSG199DT", vRM) quit
		if eftpay.msg202dt.length()>22 set vRM = $$^MSG(1076,22) do vdderr("MSG202DT", vRM) quit
		if eftpay.msg292dt.length()>22 set vRM = $$^MSG(1076,22) do vdderr("MSG292DT", vRM) quit
		if '("01"[eftpay.NXTPMT) set vRM=$$^MSG(742,"L") do vdderr("NXTPMT", vRM) quit
		if '("01"[eftpay.OVSTOP) set vRM=$$^MSG(742,"L") do vdderr("OVSTOP", vRM) quit
		set X = eftpay.partamt if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.PARTAMT"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[eftpay.PRI) set vRM=$$^MSG(742,"L") do vdderr("PRI", vRM) quit
		set X = eftpay.procdt if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("PROCDT", vRM) quit
		if '("01"[eftpay.PRTPMT) set vRM=$$^MSG(742,"L") do vdderr("PRTPMT", vRM) quit
		if eftpay.recacct.length()>34 set vRM = $$^MSG(1076,34) do vdderr("RECACCT", vRM) quit
		set X = eftpay.recinst if 'X.isNull(),'Db.isDefined("UTBLEFTINST","X") set vRM = $$^MSG(1485,X) do vdderr("RECINST", vRM) quit
		if '("01"[eftpay.REJECT) set vRM=$$^MSG(742,"L") do vdderr("REJECT", vRM) quit
		set X = eftpay.rejreas if 'X.isNull(),'Db.isDefined("UTBLCCRJ","X") set vRM = $$^MSG(1485,X) do vdderr("REJREAS", vRM) quit
		set X = eftpay.rempay if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.REMPAY"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		if '("01"[eftpay.REPOST) set vRM=$$^MSG(742,"L") do vdderr("REPOST", vRM) quit
		set X = eftpay.retcode if 'X.isNull(),'Db.isDefined("UTBLRETCODE","X") set vRM = $$^MSG(1485,X) do vdderr("RETCODE", vRM) quit
		set X = eftpay.sfpseq if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("SFPSEQ", vRM) quit
		if eftpay.source.length()>200 set vRM = $$^MSG(1076,200) do vdderr("SOURCE", vRM) quit
		if eftpay.specific.length()>10 set vRM = $$^MSG(1076,10) do vdderr("SPECIFIC", vRM) quit
		set X = eftpay.status if 'X.isNull(),'Db.isDefined("STBLESTAT","X") set vRM = $$^MSG(1485,X) do vdderr("STATUS", vRM) quit
		if eftpay.subcid.length()>16 set vRM = $$^MSG(1076,16) do vdderr("SUBCID", vRM) quit
		if eftpay.subcode.length()>2 set vRM = $$^MSG(1076,2) do vdderr("SUBCODE", vRM) quit
		if eftpay.subnam.length()>32 set vRM = $$^MSG(1076,32) do vdderr("SUBNAM", vRM) quit
		if eftpay.tcmt.length()>510 set vRM = $$^MSG(1076,510) do vdderr("TCMT", vRM) quit
		set X = eftpay.thold if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.THOLD"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.timecre if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"C") do vdderr("TIMECRE", vRM) quit
		set X = eftpay.totpaid if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.TOTPAID"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.tpaawcmp if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"EFTPAY.TPAAWCMP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
		set X = eftpay.tries if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("TRIES", vRM) quit
		set X = eftpay.tseq if 'X.isNull(),X'?1.6N,X'?1"-"1.5N set vRM=$$^MSG(742,"N") do vdderr("TSEQ", vRM) quit
		set X = eftpay.ttype if 'X.isNull(),X'?1N set vRM=$$^MSG(742,"N") do vdderr("TTYPE", vRM) quit
		if eftpay.uid.length()>20 set vRM = $$^MSG(1076,20) do vdderr("UID", vRM) quit
		if eftpay.uniqtso.length()>150 set vRM = $$^MSG(1076,150) do vdderr("UNIQTSO", vRM) quit
		if eftpay.utilityid.length()>24 set vRM = $$^MSG(1076,24) do vdderr("UTILITYID", vRM) quit
		if eftpay.variable.length()>10 set vRM = $$^MSG(1076,10) do vdderr("VARIABLE", vRM) quit
		set X = eftpay.xseq if 'X.isNull(),X'?1.6N,X'?1"-"1.5N set vRM=$$^MSG(742,"N") do vdderr("XSEQ", vRM) quit
	}
	quit

vdderr(di, vRM) // Column attribute error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("EFTPAY","MSG",979,"EFTPAY."_di_" "_vRM)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VJOURNAL(RecordEFTPAY eftpay)	//EFTPAY Journal file entries

	type Public Date %EffectiveDate
	type Public String %TSRC,vpar,vx()
	type String TSRC,vdi,vdx()

	if %TSRC.get().isNull() set TSRC="O"
	else  set TSRC=%TSRC

	if %ProcessMode=0 do {
		if TSRC="B" do {
			do vj1(.eftpay)	// Mode=I Tran=B EFD=N,E Seq=1 JRNID=EFTPAY1_I
			do vj2(.eftpay)	// Mode=I Tran=B EFD=N,E Seq=1 JRNID=EFTREF_I
			do vj5(.eftpay)	// Mode=I Tran=B EFD=N,E Seq=1 JRNID=HIST_I
			do vj9(.eftpay)	// Mode=I Tran=B EFD=N,E Seq=1 JRNID=PAYHIST_I
			}
		else  if TSRC="O" do {
			do vj1(.eftpay)	// Mode=I Tran=O EFD=N,E Seq=1 JRNID=EFTPAY1_I
			do vj2(.eftpay)	// Mode=I Tran=O EFD=N,E Seq=1 JRNID=EFTREF_I
			do vj5(.eftpay)	// Mode=I Tran=O EFD=N,E Seq=1 JRNID=HIST_I
			do vj9(.eftpay)	// Mode=I Tran=O EFD=N,E Seq=1 JRNID=PAYHIST_I
			}
		}
	else  if %ProcessMode=1 do {
		if TSRC="B" do {
			do vj3(.eftpay)	// Mode=U Tran=B EFD=N,E Seq=1 JRNID=EFTREF_U
			do vj4(.eftpay)	// Mode=U Tran=B EFD=N,E Seq=1 JRNID=HIST_D
			do vj8(.eftpay)	// Mode=U Tran=B EFD=N,E Seq=1 JRNID=PAYHIST_D
			do vj10(.eftpay)	// Mode=U Tran=B EFD=N,E Seq=1 JRNID=PAYHIST_U
			quit:'vx.data()
			if vx("STATUS").exists() do vj6(.eftpay,"STATUS")	// Mode=U Tran=B EFD=N,E Seq=1 JRNID=HIST_U_C
			if vx("STATUS").exists() do vj7(.eftpay,"STATUS")	// Mode=U Tran=B EFD=N,E Seq=1 JRNID=HIST_U_SUP
			}
		else  if TSRC="F" do {
			quit:'vx.data()
			if vx("STATUS").exists() do vj6(.eftpay,"STATUS")	// Mode=U Tran=F EFD=N,E Seq=1 JRNID=HIST_U_C
			if vx("STATUS").exists() do vj7(.eftpay,"STATUS")	// Mode=U Tran=F EFD=N,E Seq=1 JRNID=HIST_U_SUP
			}
		else  if TSRC="O" do {
			do vj3(.eftpay)	// Mode=U Tran=O EFD=N,E Seq=1 JRNID=EFTREF_U
			do vj4(.eftpay)	// Mode=U Tran=O EFD=N,E Seq=1 JRNID=HIST_D
			do vj8(.eftpay)	// Mode=U Tran=O EFD=N,E Seq=1 JRNID=PAYHIST_D
			do vj10(.eftpay)	// Mode=U Tran=O EFD=N,E Seq=1 JRNID=PAYHIST_U
			quit:'vx.data()
			if vx("STATUS").exists() do vj6(.eftpay,"STATUS")	// Mode=U Tran=O EFD=N,E Seq=1 JRNID=HIST_U_C
			if vx("STATUS").exists() do vj7(.eftpay,"STATUS")	// Mode=U Tran=O EFD=N,E Seq=1 JRNID=HIST_U_SUP
			}
		}

	quit


vj1(RecordEFTPAY eftpay)	// EFTPAY1_I  Table EFTPAY1  EFTPAY Account Number Level (Insert)

							//// Save this line for Public datatyping, if needed
	type String vlastkey
	set vlastkey=eftpay.cid
	type RecordEFTPAY1 eftpay1=Db.getRecord("EFTPAY1","CID=:vlastkey",1)
	set eftpay1.seq=eftpay.seq

	do eftpay1.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj2(RecordEFTPAY eftpay)	// EFTREF_I  Table EFTREF  EFT Tres Ref Index (Insert)

	if eftpay.refno'=""
	else  quit

							//// Save this line for Public datatyping, if needed
	type String vlastkey
	set vlastkey=eftpay.refno
	type RecordEFTREF eftref=Db.getRecord("EFTREF","REFNO=:vlastkey",1)
	set eftref.cid=eftpay.cid
	set eftref.seq=eftpay.seq

	do eftref.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj3(RecordEFTPAY eftpay)	// EFTREF_U  Table EFTREF  EFT Tres Ref Index (Update)

	if eftpay.refno'=""
	else  quit

	type Public String vx()
	type String vdi

	set vdi="" for  set vdi=vx(vdi).order() quit:vdi=""  do { quit
							//// Save this line for Public datatyping, if needed
		type String vlastkey
		set vlastkey=eftpay.refno
		type RecordEFTREF eftref=Db.getRecord("EFTREF","REFNO=:vlastkey",1)
		set eftref.cid=eftpay.cid
		set eftref.seq=eftpay.seq

		do eftref.save("/NOVALFK/NOVALDD/NOVALRI")
		}

	quit


vj4(RecordEFTPAY eftpay)	// HIST_D  Table HIST  Transaction History (Delete)

	if eftpay.status="D"
	else  quit
	if eftpay.ttype<2&(eftpay.ttype'="")
	else  quit

	type Public String vx()
	type String vdi

	set vdi="" for  set vdi=vx(vdi).order() quit:vdi=""  do { quit
		type Public String %IDENT,%UID,TJD,TLO
		type String v1,vlastkey
		set v1=eftpay.cid
		set vlastkey=Db.nextVal("HIST","CID=:v1")
		type RecordHIST hist=Db.getRecord("HIST","CID=:v1,TSEQ=:vlastkey",1)
		set hist.brcd=eftpay.brcd
		set hist.cdt=+$H
		set hist.crcd=eftpay.crcd
		set hist.ident=%IDENT
		set hist.tcmt=$$^MSG(3028,eftpay.eftdesc)
		set hist.time=$P($H,",",2)
		set hist.tjd=TJD
		set hist.tlo=TLO
		set hist.uid=%UID

		do hist.save("/NOVALFK/NOVALDD/NOVALRI")
		}

	quit


vj5(RecordEFTPAY eftpay)	// HIST_I  Table HIST  Transaction History (Insert)

	if +eftpay.ttype<2&(+eftpay.ttype'="")
	else  quit

	type Public String %IDENT,%UID,TJD,TLO
	type String v1,vlastkey
	set v1=eftpay.cid
	set vlastkey=Db.nextVal("HIST","CID=:v1")
	type RecordHIST hist=Db.getRecord("HIST","CID=:v1,TSEQ=:vlastkey",1)
	set hist.brcd=eftpay.brcd
	set hist.cdt=+$H
	set hist.crcd=eftpay.crcd
	set hist.efd=eftpay.efd
	set hist.ident=%IDENT
	set hist.tcmt=$$EFTDSC^EFTFUNCS(eftpay.efttype,eftpay.recinst,eftpay.recacct,eftpay.rectype,eftpay.status)
	set hist.time=$P($H,",",2)
	set hist.tjd=TJD
	set hist.tlo=TLO
	set hist.tso=eftpay.source
	set hist.uid=%UID

	do hist.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj6(RecordEFTPAY eftpay,String vdi)	// HIST_U_C  Table HIST  HIST Record for STATUS="C"

	if eftpay.status="C"
	else  quit
	if eftpay.ttype<2&(eftpay.ttype'="")
	else  quit

	type Public String %UID,TJD,TLO
	type String v1,vlastkey
	set v1=eftpay.cid
	set vlastkey=Db.nextVal("HIST","CID=:v1")
	type RecordHIST hist=Db.getRecord("HIST","CID=:v1,TSEQ=:vlastkey",1)
	set hist.brcd=eftpay.brcd
	set hist.cdt=+$H
	set hist.tcmt=$$EFTDSC^EFTFUNCS(eftpay.efttype,eftpay.recinst,eftpay.recacct,eftpay.rectype,eftpay.status)
	set hist.time=$P($H,",",2)
	set hist.tjd=TJD
	set hist.tlo=TLO
	set hist.uid=%UID

	do hist.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj7(RecordEFTPAY eftpay,String vdi)	// HIST_U_SUP  Table HIST  HIST record for STATUS="SUP"

	if eftpay.status="SUP"
	else  quit
	if eftpay.ttype<2&(eftpay.ttype'="")
	else  quit

	type Public String %UID,TJD,TLO
	type String v1,vlastkey
	set v1=eftpay.cid
	set vlastkey=Db.nextVal("HIST","CID=:v1")
	type RecordHIST hist=Db.getRecord("HIST","CID=:v1,TSEQ=:vlastkey",1)
	set hist.brcd=eftpay.brcd
	set hist.cdt=+$H
	set hist.tcmt=$$TCMTSUP^EFTFUNCS(eftpay.cid)
	set hist.time=$P($H,",",2)
	set hist.tjd=TJD
	set hist.tlo=TLO
	set hist.uid=%UID

	do hist.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj8(RecordEFTPAY eftpay)	// PAYHIST_D  Table PAYHIST  Electronic Payment Hist. (Delete)

	if eftpay.status="D"
	else  quit

	type Public String vx()
	type String vdi

	set vdi="" for  set vdi=vx(vdi).order() quit:vdi=""  do { quit
		type Public String %UID,TJD,TLO
		type String v1,v2,vlastkey
		set v1=eftpay.cid
		set v2=eftpay.seq
		set vlastkey=Db.nextVal("PAYHIST","CID=:v1,SEQ=:v2")
		type RecordPAYHIST payhist=Db.getRecord("PAYHIST","CID=:v1,SEQ=:v2,TSEQ=:vlastkey",1)
		set payhist.brcd=eftpay.brcd
		set payhist.cdt=+$H
		set payhist.src=eftpay.efttype
		set payhist.tcmt=$$^MSG(3028,eftpay.eftdesc)
		set payhist.time=$P($H,",",2)
		set payhist.tjd=TJD
		set payhist.tlo=TLO
		set payhist.uid=%UID

		do payhist.save("/NOVALFK/NOVALDD/NOVALRI")
		}

	quit


vj9(RecordEFTPAY eftpay)	// PAYHIST_I  Table PAYHIST  Electronic Payment Hist. (Insert)

	type Public String %UID,TJD,TLO
	type String v1,v2,vlastkey
	set v1=eftpay.cid
	set v2=eftpay.seq
	set vlastkey=Db.nextVal("PAYHIST","CID=:v1,SEQ=:v2")
	type RecordPAYHIST payhist=Db.getRecord("PAYHIST","CID=:v1,SEQ=:v2,TSEQ=:vlastkey",1)
	set payhist.brcd=eftpay.brcd
	set payhist.cdt=+$H
	set payhist.efd=eftpay.efd
	set payhist.src=eftpay.efttype
	set payhist.tcmt=$$^MSG(6712,eftpay.eftdesc)
	set payhist.time=$P($H,",",2)
	set payhist.tjd=TJD
	set payhist.tlo=TLO
	set payhist.uid=%UID

	do payhist.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj10(RecordEFTPAY eftpay)	// PAYHIST_U  Table PAYHIST  Electronic Payment Hist. (Update)

	if eftpay.status'="D"
	else  quit

	type Public String vx()
	type String vdi

	set vdi="" for  set vdi=vx(vdi).order() quit:vdi=""  do {
		type Public String vx(),%UID,TJD,TLO
		type String v1,v2,vlastkey

		type String vold,vnew

		set vold=vx(vdi).piece("|",1)
		set vnew=vx(vdi).piece("|",2)

		set v1=eftpay.cid
		set v2=eftpay.seq
		set vlastkey=Db.nextVal("PAYHIST","CID=:v1,SEQ=:v2")
		type RecordPAYHIST payhist=Db.getRecord("PAYHIST","CID=:v1,SEQ=:v2,TSEQ=:vlastkey",1)
		set payhist.brcd=eftpay.brcd
		set payhist.cdt=+$H
		set payhist.efd=eftpay.efd
		set payhist.src=eftpay.efttype
		set payhist.tcmt=$$TCMTFM^ACNFUNCS("","EFTPAY",vdi,vold,vnew)
		set payhist.time=$P($H,",",2)
		set payhist.tjd=TJD
		set payhist.tlo=TLO
		set payhist.uid=%UID

		do payhist.save("/NOVALFK/NOVALDD/NOVALRI")
		}

	quit



public VINDEX(RecordEFTPAY eftpay) // Update index entries

		type Public String vx()

	if %ProcessMode=1 do { quit
		if vx("PROCDT").exists()!vx("EFTTYPE").exists()!vx("PTYSTAT").exists() do vi1(.eftpay)
		if vx("EFD").exists()!vx("EFTTYPE").exists() do vi2(.eftpay)
		if vx("EFTTYPE").exists()!vx("BRCD").exists() do vi3(.eftpay)
		if vx("EFTTYPE").exists()!vx("BRCD").exists()!vx("SFPSEQ").exists() do vi4(.eftpay)
		if vx("EFTTYPE").exists() do vi5(.eftpay)
		if vx("DATECRE").exists()!vx("EFTTYPE").exists()!vx("BRCD").exists() do vi6(.eftpay)
		if vx("REFNO").exists()!vx("EFTTYPE").exists()!vx("BRCD").exists() do vi7(.eftpay)
		if vx("LNM").exists()!vx("BRCD").exists()!vx("STATUS").exists() do vi8(.eftpay)
		if vx("LOADDATE").exists()!vx("BRCD").exists() do vi9(.eftpay)
	}
	do vi1(.eftpay)
	do vi2(.eftpay)
	do vi3(.eftpay)
	do vi4(.eftpay)
	do vi5(.eftpay)
	do vi6(.eftpay)
	do vi7(.eftpay)
	do vi8(.eftpay)
	do vi9(.eftpay)

	quit
	

vi1(RecordEFTPAY eftpay) // Maintain DAYENDEF index entries (Index by Process Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = eftpay.procdt
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v3 = eftpay.efttype
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = eftpay.cid
	type String v5 = eftpay.ptystat
	if v5.isNull() set v5=(PSL.maxCharValue-1).char()
	type String v6 = eftpay.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^DAYEND(v1,"EFTOUT",v3,v4,v5,v6)) do vidxerr("DAYENDEF")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^DAYEND(v1,"EFTOUT",v3,v4,v5,v6)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("PROCDT").exists() set v1=vx("PROCDT").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("EFTTYPE").exists() set v3=vx("EFTTYPE").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()
	if vx("PTYSTAT").exists() set v5=vx("PTYSTAT").piece("|",1) set:v5.isNull() v5=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^DAYEND(v1,"EFTOUT",v3,v4,v5,v6)
	#ENDBYPASS
	quit

vi2(RecordEFTPAY eftpay) // Maintain EFTINDX index entries (Index by Effective Date)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = eftpay.efd
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = eftpay.cid
	type String v3 = eftpay.efttype
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = eftpay.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^EFTINDX(v1,v2,v3,v4)) do vidxerr("EFTINDX")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^EFTINDX(v1,v2,v3,v4)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("EFD").exists() set v1=vx("EFD").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("EFTTYPE").exists() set v3=vx("EFTTYPE").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^EFTINDX(v1,v2,v3,v4)
	#ENDBYPASS
	quit

vi3(RecordEFTPAY eftpay) // Maintain EFTSFPX1 index entries (Index NDPOSTs by BRCD,CID,SEQ)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = eftpay.efttype
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = eftpay.brcd
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = eftpay.cid
	type String v4 = eftpay.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^EFTSFPX(v1,v2,v3,v4)) do vidxerr("EFTSFPX1")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^EFTSFPX(v1,v2,v3,v4)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("EFTTYPE").exists() set v1=vx("EFTTYPE").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("BRCD").exists() set v2=vx("BRCD").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^EFTSFPX(v1,v2,v3,v4)
	#ENDBYPASS
	quit

vi4(RecordEFTPAY eftpay) // Maintain EFTSFPX3 index entries (Index NDPOSTs by BRCD,SFPSEQ)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = eftpay.efttype
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = eftpay.brcd
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = eftpay.cid
	type String v5 = eftpay.sfpseq
	if v5.isNull() set v5=(PSL.maxCharValue-1).char()
	type String v6 = eftpay.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^EFTSFPX("SFP",v2,v3,v4,v5,v6)) do vidxerr("EFTSFPX3")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^EFTSFPX("SFP",v2,v3,v4,v5,v6)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("EFTTYPE").exists() set v2=vx("EFTTYPE").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("BRCD").exists() set v3=vx("BRCD").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()
	if vx("SFPSEQ").exists() set v5=vx("SFPSEQ").piece("|",1) set:v5.isNull() v5=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^EFTSFPX("SFP",v2,v3,v4,v5,v6)
	#ENDBYPASS
	quit

vi5(RecordEFTPAY eftpay) // Maintain EFTX1 index entries (Index by Account & Pmt Type)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = eftpay.cid
	type String v2 = eftpay.efttype
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = eftpay.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^EFTX1(v1,v2,v3)) do vidxerr("EFTX1")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^EFTX1(v1,v2,v3)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("EFTTYPE").exists() set v2=vx("EFTTYPE").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^EFTX1(v1,v2,v3)
	#ENDBYPASS
	quit

vi6(RecordEFTPAY eftpay) // Maintain EFTX2 index entries (Index by Create Date & Type)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = eftpay.datecre
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = eftpay.efttype
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = eftpay.brcd
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = eftpay.cid
	type String v5 = eftpay.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^EFTX2(v1,v2,v3,v4,v5)) do vidxerr("EFTX2")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^EFTX2(v1,v2,v3,v4,v5)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("DATECRE").exists() set v1=vx("DATECRE").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("EFTTYPE").exists() set v2=vx("EFTTYPE").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("BRCD").exists() set v3=vx("BRCD").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^EFTX2(v1,v2,v3,v4,v5)
	#ENDBYPASS
	quit

vi7(RecordEFTPAY eftpay) // Maintain EFTX3 index entries (Index by reference number)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = eftpay.refno
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = eftpay.efttype
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = eftpay.brcd
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = eftpay.cid
	type String v5 = eftpay.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^EFTX3(v1,v2,v3,v4,v5)) do vidxerr("EFTX3")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^EFTX3(v1,v2,v3,v4,v5)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("REFNO").exists() set v1=vx("REFNO").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("EFTTYPE").exists() set v2=vx("EFTTYPE").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("BRCD").exists() set v3=vx("BRCD").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^EFTX3(v1,v2,v3,v4,v5)
	#ENDBYPASS
	quit

vi8(RecordEFTPAY eftpay) // Maintain EFTX4 index entries (Index by last name, branch)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = eftpay.lnm
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = eftpay.brcd
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = eftpay.status
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = eftpay.cid
	type String v5 = eftpay.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^EFTX4(v1,v2,v3,v4,v5)) do vidxerr("EFTX4")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^EFTX4(v1,v2,v3,v4,v5)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("LNM").exists() set v1=vx("LNM").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("BRCD").exists() set v2=vx("BRCD").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("STATUS").exists() set v3=vx("STATUS").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^EFTX4(v1,v2,v3,v4,v5)
	#ENDBYPASS
	quit

vi9(RecordEFTPAY eftpay) // Maintain EFTXLD index entries (Index by Load Date, Branch)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = eftpay.loaddate
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = eftpay.brcd
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = eftpay.cid
	type String v4 = eftpay.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^EFTXLD(v1,v2,v3,v4)) do vidxerr("EFTXLD")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^EFTXLD(v1,v2,v3,v4)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("LOADDATE").exists() set v1=vx("LOADDATE").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("BRCD").exists() set v2=vx("BRCD").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^EFTXLD(v1,v2,v3,v4)
	#ENDBYPASS
	quit

public VIDXBLD(List vlist) // Rebuild index files (External call)


	type Number %ProcessMode=0                             // Create mode
	type Number i

	if vlist.get().isNull() set vlist="VINDEX"             // Build all

	type DbSet ds=Db.selectDbSet("EFTPAY")

	while ds.next() do {
		type RecordEFTPAY eftpay=ds.getRecord("EFTPAY")
		if vlist.contains("VINDEX") do VINDEX(.eftpay) quit
		if vlist.contains("DAYENDEF") do vi1(.eftpay)
		if vlist.contains("EFTINDX") do vi2(.eftpay)
		if vlist.contains("EFTSFPX1") do vi3(.eftpay)
		if vlist.contains("EFTSFPX3") do vi4(.eftpay)
		if vlist.contains("EFTX1") do vi5(.eftpay)
		if vlist.contains("EFTX2") do vi6(.eftpay)
		if vlist.contains("EFTX3") do vi7(.eftpay)
		if vlist.contains("EFTX4") do vi8(.eftpay)
		if vlist.contains("EFTXLD") do vi9(.eftpay)
	}

	quit


public VIDXBLD1(RecordEFTPAY eftpay, List vlist) // Rebuild index files for one record (External call)


	type Number i

	if vlist.contains("VINDEX") do VINDEX(.eftpay) quit
	if vlist.contains("DAYENDEF") do vi1(.eftpay)
	if vlist.contains("EFTINDX") do vi2(.eftpay)
	if vlist.contains("EFTSFPX1") do vi3(.eftpay)
	if vlist.contains("EFTSFPX3") do vi4(.eftpay)
	if vlist.contains("EFTX1") do vi5(.eftpay)
	if vlist.contains("EFTX2") do vi6(.eftpay)
	if vlist.contains("EFTX3") do vi7(.eftpay)
	if vlist.contains("EFTX4") do vi8(.eftpay)
	if vlist.contains("EFTXLD") do vi9(.eftpay)

	quit


vidxerr(di) // Error message

	D SETERR^DBSEXECU("EFTPAY","MSG",1225,"EFTPAY."_di)

	quit


vkchged // Access key changed

	type public RecordEFTPAY eftpay

	type public Boolean ER = 0
	type public String RM,vpar,vx()

	type Number %O = 1
	type String vnewkey,voldkey,vux
	type String voldpar = vpar.get()                       // Save filer switches

	if vx("CID").exists() set vux("CID") = vx("CID")
	if vx("SEQ").exists() set vux("SEQ") = vx("SEQ")
	do vkey(1) set voldkey = eftpay.cid_","_eftpay.seq     // Copy old keys into object

	set vpar = $$setPar^UCUTILN(vpar,"NOINDEX")            // Switch Index off
	do vload                                               // Make sure all data is loaded locally
	if vpar["/VALREQ/" do vrequ
	if vpar["/TRIGBEF/" do VBU
	if vpar["/VALDD/" do vddver
	do vexec

	do vkey(2) set vnewkey = eftpay.cid_","_eftpay.seq     // Copy new keys into object
	type RecordEFTPAY vnewrec = eftpay.copy()
	do vnewrec.setMode(0)
	do vnewrec.save("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")

	set %O = 1 do CASUPD^DBSEXECU("EFTPAY",voldkey,vnewkey) if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~")) // Cascade update
	set vpar = voldpar
	if vpar["/TRIGAFT/" do VAU

	do vkey(1)                                             // Reset key for delete
	set vpar = $$initPar^UCUTILN("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")
	set %O = 3 do vdelete(1)                               // Delete old record

	quit

vkey(Number i) // Restore access keys

	type public String vux()
	type public RecordEFTPAY eftpay

	if vux("CID").exists() set eftpay.cid = vux("CID").piece("|",i)
	if vux("SEQ").exists() set eftpay.seq = vux("SEQ").piece("|",i)
	quit

VCASDEL // Cascade delete logic

	type public RecordEFTPAY eftpay
	type public String vpar

	do Db.delete("PAYHIST","CID=:eftpay.cid AND SEQ=:eftpay.seq",vpar) // Cascade delete

	quit

VIDXPGM()	quit "EFTFILE"	// Location of index program

