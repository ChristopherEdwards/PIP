LNSVINI		/*
	PROCEDURE:  LNSVINI
	ORIG: Kathy Bradley - 4/18/89
	DESC: Initialize Security Pricing
 
	---- Comments --------------------------------------------------------

	This procedure provides for loading security pricing information in
	different formats.  The formats are defined in procedures and
	registered in table CTBLSPS.  A run-time program is generated by
	combining the code in this procedure (below the TEMPLATE tag) with
	the custom code in the procedure pointed to by CTBLSPS.  The run-time
	program performs the security pricing loading.

	NOTE:  Custom code for insert must have a RECCALL section which
	is called to process an input record in variable REC.  It should
	call SPSFILE to file the data.  It must define CUSIP, DES, VAL, EFD,
	and SRC for use by SPSFILE.  It may also update variables TINV for 
	invalid records and TSKIP for skipped records.  Custom code should
	also update TMP(CUSIP) for records that are updated.  This allows
	filing of exceptions for records that did not get updated.

	If called from the top, user will be prompted for the format to
	use, the input file, and an update only flag.  (If update only,
	the custom code can choose to only update existing records and
	not add new records.)

	If called at EXEC, input is the three parameters above and there
	is no interactive prompting.
	
	---- Revision History ------------------------------------------------

	12/10/03 - CARROLLJ - CR7239
		   Modified EXEC section to set N variable to null before for
		   loop.

	01/09/03 - Dan Russell - 51349
		   Fix bug in SPSFILE section with missing quotes.

	04/12/02 - Dan Russell
		   Rewritten to PSL.
	*/


	new IO,%READ,SRC,%TAB,UPD,VFMQ

	set %TAB("SRC")=".SRC1/HLP=[CTBLSPS]SRC/TBL=[CTBLSPS]"
	set %TAB("IO")=$$IO^SCATAB
	set %TAB("UPD")=".UPD1",UPD=1
	set %READ="@@%FN,,,SRC/REQ,IO/REQ,UPD/REQ"
	do ^UTLREAD
	if VFMQ="Q" do {
		// Security pricing file not applied
		set ER="W",RM=$$^MSG(2463)
	}
	else  do {
		do EXEC(SRC,IO,UPD)
		// Security pricing file applied
		if 'ER set ER="W",RM=$$^MSG(2462)
	}
	quit


EXEC(SRC,IO,UPD)	// Public - Entry to run without prompting
	/*
 	ARGUMENTS:

		. SRC	Format name		/TYP=T/MECH=VAL/REQ
			From table CTBLSPS

		. IO	Input file		/TYP=T/MECH=VAL/REQ

		. UPD	Update-only flag	/TYP=L/MECH=VAL/NOREQ
						/DEFAULT=1
	*/

	new CMPERR,CODE,CUSIP,CUSTCODE,DES,EFD,EOF,I,N,PGMNAME,PROCNAME,REC
	new TAGS,TMP,VAL

	set ER=0

	set PGMNAME="TMP"_($J#100000)

	if $G(UPD)="" set UPD=1
	
	// Load this procedure into CODE array to get template
	do ^ULODTMPL("LNSVINI","CODE",,.TAGS)
	quit:ER

	// Remove code prior to TEMPLATE section
	for I=1:1:TAGS("TEMPLATE") kill CODE(I)

	// Set up header
	set CODE(1)=PGMNAME_$C(9)_"// Security loader format "_SRC_".  Compiled by LNSVINI"
	set CODE(2)=""

	// Insert custom format code
	type ResultSet spsrs
	set spsrs=Db.select("PROCNAME","CTBLSPS","SRC=:SRC")

	// Procedure name required
	if spsrs.isEmpty() set ER=1,RM=$$^MSG(8568) quit

	if spsrs.next() set PROCNAME=spsrs.getCol(1)
	if $G(PROCNAME)="" set ER=1,RM=$$^MSG(8568) quit

	kill TAGS
	do ^ULODTMPL(PROCNAME,"CUSTCODE",,.TAGS)	// Load custom code
	// No definition for Procedure ~p1
	if '$D(CUSTCODE) set ER=1,RM=$$^MSG(8610,PROCNAME) quit

	// Remove SPSFILE line from custom code.  Needed there to prevent
	// errors on mass recompile of procedures
	if $D(TAGS("SPSFILE")) kill CUSTCODE(TAGS("SPSFILE"))

	set N=""
	for I=$O(CODE(""),-1)+1:1 set N=$O(CUSTCODE(N)) quit:N=""  set CODE(I)=CUSTCODE(N)

	// Build compiled routine
	do BUILDRTN^UCGM(.CODE,PGMNAME,.CMPERR)
	if $D(CMPERR) do {
		set N=""
		for  set N=$O(CMPERR(N)) quit:N=""  do {
			if 'ER set ER=1,RM=CMPERR(N)
			set RM(N)=CMPERR(N)
		}
	}
	quit:ER

	// Run the routine
	do ^@PGMNAME

	// Update exception file for records not updated
	type ResultSet svalrs
	set svalrs=Db.select("CUSIP","UTBLSVAL")

	if svalrs.isEmpty() quit
	while svalrs.next() do {
		new CUSIP
		set CUSIP=svalrs.getCol(1)
		// Only care if wasn't updated
		if '$D(TMP(CUSIP)) do {
			new ER,ET
			// Security Price not updated for CUSIP # ~p1
			set ER=1,ET=$$^MSG(4236,CUSIP)
			// Security Pricing Values Update
			do LOG^UTLEXC("LNVSINI","*",$$^MSG(4237),CUSIP,$G(%ZTSEQ),ET)
		}
	}

	// Remove run-time program
	do DEL^%ZRTNDEL(PGMNAME)

	quit


RECCALL	// Dummy label required to prevent mass recompile errors.  Actual label
	// is in inserted custom code.



TEMPLATE	// Template code follows

	/* The code below this line is used as the template for building
	   the compiled, run-time routine.  Do not replace line tag
	   TEMPLATE or place any code that is not related to the template
	   below this line.

	   The template code will be combined with a selected procedure
	   from CTBLSPS to create a temporary run-time routine.

	   This code was previously in routine LNSVFMT.

	   See notes at the top of procedure LNSVINI for information about
	   what the custom code is responsible for.
	*/

	catch error {
		do ZE^UTLERR
		set ER=1
		}

	new TAPP,TINV,TOT,TSKIP

	set (EOF,ER,TOT,TAPP,TINV,TSKIP)=0

	// Open the input file	
	type IO input=Class.new("IO")
	set input.fileName=IO
	set input.openParams="READ"
	do input.open()

	// Record Reader
	for  set REC=input.read(.EOF) quit:EOF  do {
		set TOT=TOT+1
		do RECCALL	// Process record in inserted code
	}
		
	if +EOF=1 do {
		set ER="W"
		// Total number of CUSIPs in file: ~p1
		set RM(1)=$$^MSG(4231,TOT)
		// Total number of CUSIPs updated: ~p1
		set RM(2)=$$^MSG(4232,TAPP)
		// Total number of Invalid CUSIPs: ~p1
		set RM(3)=$$^MSG(4233,TINV)
		// Total number of CUSIPs not on file: ~p1
		set RM(4)=$$^MSG(4234,TSKIP)
	}
	else  set ER=1,RM=$P(EOF,"|",2)

	do input.close()

	quit


SPSFILE	// File record to CTBLSPS

	if Db.isDefined("UTBLSVAL","CUSIP=:CUSIP") do {
		// Only update description if it has a value
		type RecordUTBLSVAL utblsval=Db.getRecord("UTBLSVAL","CUSIP=:CUSIP")
		set utblsval.efd=EFD
		if DES'="" set utblsval.des=DES
		else  set utblsval.val=VAL
		do utblsval.bypassSave()
	}
	else  do {
		type RecordUTBLSVAL utblsval=Class.new("RecordUTBLSVAL")
		set utblsval.cusip=CUSIP
		set utblsval.des=DES
		set utblsval.efd=EFD
		set utblsval.src=SRC
		do utblsval.bypassSave()
	}

	set TAPP=TAPP+1		// Total records applied
	quit


	// --------------------------------------------------------------------
	// No code below this line -- custom code inserted at end of procedure

vSIG()	quit "59886^43573^Sanchez SCM Administrator^6152"	// Signature - LTD^TIME^USER^SIZE
