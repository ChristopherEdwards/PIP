DBSDF1F(RecordDBTBL1 dbtbl1, String vpar, Boolean vparNorm) // DBTBL1 - Data Dictionary File Definition Filer
	// Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 11:23 - shetyes
	// Generated from DATA-QWIK schema in: /profile/v72qa_gtmlx  by: /v72qa_gtmlx/crtns/DBSFILB.obj

	// Data Dictionary Data Items (54)             12/23/2005
	// Trigger Definition (7)                      11/29/2005
	/*
		vpar      Runtime qualifiers:      /NOREQ/MECH=REFARR:R

		/[NO]CASDEL   - Cascade delete
		/[NO]FRMFILER - Called from another filer
		/[NO]INDEX    - Update Indexes
		/[NO]JOURNAL  - Journal update
		/[NO]TRIGAFT  - After update triggers
		/[NO]TRIGBEF  - Before update triggers
		/[NO]UPDATE   - Update primary table
		/[NO]VALDD    - Validate column values
		/[NO]VALFK    - Validate foreign keys
		/[NO]VALREQ   - Validate not null values
		/[NO]VALRI    - Validate transaction integrity
		/[NO]VALST    - Validate database state
	*/

	type public String verrors()

	type String vx(), vxins()                              // audit column array
	type Number %O = dbtbl1.getMode()                      // Processing mode
	set vpar = vpar.get()                                  // Initialize vpar
	if %O = 0 do AUDIT^UCUTILN(dbtbl1,.vxins(),11,"|")
	if %O = 1 quit:'dbtbl1.isChanged()  do AUDIT^UCUTILN(dbtbl1,.vx(),11,"|")

	if 'vparNorm.get() set vpar = $$initPar^UCUTILN(vpar)  // Run-time qualifiers

	// Define local variables for access keys for legacy triggers
	type String %LIBS = dbtbl1.%libs
	type String FID = dbtbl1.fid

	if %O = 0 do { quit                                    // Create record control block
		do vinit                                              // Initialize column values
		if vpar["/TRIGBEF/" do VBI                            // Before insert triggers
		if vpar["/VALREQ/" do vreqn                           // Check required
		if vpar["/VALDD/" do vddver                           // Check values
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 1 do { quit                                    // Update record control block
		if vx("%LIBS").exists()!vx("FID").exists() do vkchged quit // Primary key changed
		if vpar["/TRIGBEF/" do VBU                            // Before update triggers
		if vpar["/VALREQ/" do vrequ                           // Check required
		if vpar["/VALDD/" do VDDUX^DBSFILER("DBTBL1",.vx)
		set %O = 1 do vexec
		if vpar["/TRIGAFT/" do VAU                            // After update triggers
	}

	if %O = 2 do { quit                                    // Verify record control block
		if vpar["/VALREQ/" do vreqn                           // Check required
		set vpar = $$setPar^UCUTILN(vpar,"NOJOURNAL/NOUPDATE")
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 3 do { quit                                    // Delete record control block
		quit:'Db.isDefined("DBTBL1","%LIBS = :dbtbl1.%libs and FID = :dbtbl1.fid") // No record exists
		if vpar["/TRIGBEF/" do VBD                            // Before delete triggers
		do vdelete(0)
	}

	quit

vlegacy(Number %ProcessMode,String vpar) // Legacy interface (^DBSDF9 for %O=0, EXT^DBSFILER for %O = 2)

	type public String %LIBS
	type public String FID

	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1","%LIBS=:%LIBS,FID=:FID")
	if (%ProcessMode = 2) do {
		do dbtbl1.setMode(2)

		do DBSDF1F(dbtbl1,vpar)
	}
	else  do VINDEX(dbtbl1)

	quit

vLITCHK() quit 0 // Table does not have columns involved in literals


vexec // Execute transaction

	type public Number %O
	type public String vpar,vobj(),vx(),vxins()

	type public RecordDBTBL1 dbtbl1

	type String vERRMSG

	if vpar["/VALST/" if '(''Db.isDefined("DBTBL1","%LIBS = :dbtbl1.%libs and FID = :dbtbl1.fid") = ''%O) set vERRMSG = $$^MSG($select(%O:7932,1:2327)) throw Class.new("Error","%PSL-E-DBSFILER,"_vERRMSG.replace(",","~"))

	if vpar'["/NOUPDATE/" do {

		set dbtbl1.LTD = %CurrentDate
		set dbtbl1.USER = %UserName
		if %O = 0, vpar'["/NOLOG/" do ^DBSLOGIT(dbtbl1,%O,.vxins())
		if %O = 1, vpar'["/NOLOG/" do ^DBSLOGIT(dbtbl1,%O,.vx())

		type String n = -1
		type String x

		if %O = 0 for  set n = vobj(dbtbl1,n).order() quit:n.isNull()  do {
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^DBTBL(vobj(dbtbl1,-3),1,vobj(dbtbl1,-4),n)=vobj(dbtbl1,n)
			#ENDBYPASS
		}

		else  for  set n = vobj(dbtbl1,-100,n).order() quit:n.isNull()  do {
			quit:'$D(vobj(dbtbl1,n))
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^DBTBL(vobj(dbtbl1,-3),1,vobj(dbtbl1,-4),n)=vobj(dbtbl1,n)
			#ENDBYPASS
		}

		// Allow global reference and M source code
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
		#BYPASS
		if $D(vobj(dbtbl1))  S ^DBTBL(vobj(dbtbl1,-3),1,vobj(dbtbl1,-4))=vobj(dbtbl1)
		#ENDBYPASS
	}

	if vpar["/INDEX/",'(%O = 1)!'vx("").order().isNull() do VINDEX(.dbtbl1) // Update Index files

	quit

vload // Record Load - force loading of unloaded data

	type public RecordDBTBL1 dbtbl1
	type String n = ""

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	for  set n = $order(^DBTBL(vobj(dbtbl1,-3),1,vobj(dbtbl1,-4),n)) quit:n.isNull()  if 'vobj(dbtbl1,n).data(),^DBTBL(vobj(dbtbl1,-3),1,vobj(dbtbl1,-4),n).data()#2 set vobj(dbtbl1,n) = ^(n)
	quit

vdelete(Boolean vkeychg) // Record Delete

	type public String vobj(),vpar
	type public RecordDBTBL1 dbtbl1

	if 'vkeychg.get(),dbtbl1.isChanged() throw Class.new("Error","%PSL-E-DBFILER,Deleted object cannot be modified")

	if vpar["/CASDEL/" do VCASDEL                          // Cascade delete
	if vpar["/INDEX/" do VINDEX(.dbtbl1)                   // Delete index entries
	if vpar'["/NOLOG/" do ^DBSLOGIT(dbtbl1,3)

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	kill ^DBTBL(vobj(dbtbl1,-3),1,vobj(dbtbl1,-4))         // Delete Record
	quit


vinit // Initialize default values

	type public RecordDBTBL1 dbtbl1

	// Type local variables for access keys for defaults
	type public String %LIBS
	type public String FID

	if dbtbl1.del.isNull() set dbtbl1.del = 124            // del
	if dbtbl1.dflag.isNull() set dbtbl1.dflag = 0          // dflag
	if dbtbl1.dftord.isNull() set dbtbl1.dftord = 0        // dftord
	if dbtbl1.extendlength.isNull() set dbtbl1.extendlength = 0 // extendlength
	if dbtbl1.fsn.isNull() set dbtbl1.fsn = "f"_$E($TR(FID,"_","z"),1,7) // fsn
	if dbtbl1.log.isNull() set dbtbl1.log = 0              // log
	if dbtbl1.netloc.isNull() set dbtbl1.netloc = 0        // netloc
	if dbtbl1.rectyp.isNull() set dbtbl1.rectyp = 1        // rectyp
	if dbtbl1.rflag.isNull() set dbtbl1.rflag = 0          // rflag
	if dbtbl1.syssn.isNull() set dbtbl1.syssn = "PBS"      // syssn
	if dbtbl1.val4ext.isNull() set dbtbl1.val4ext = 0      // val4ext
	quit


vreqn // Validate required data items

	type public RecordDBTBL1 dbtbl1

	if dbtbl1.acckeys.isNull() do vreqerr("ACCKEYS") quit
	if dbtbl1.des.isNull() do vreqerr("DES") quit
	if dbtbl1.dflag.isNull() do vreqerr("DFLAG") quit
	if dbtbl1.dftord.isNull() do vreqerr("DFTORD") quit
	if dbtbl1.extendlength.isNull() do vreqerr("EXTENDLENGTH") quit
	if dbtbl1.fdoc.isNull() do vreqerr("FDOC") quit
	if dbtbl1.log.isNull() do vreqerr("LOG") quit
	if dbtbl1.rflag.isNull() do vreqerr("RFLAG") quit
	if dbtbl1.val4ext.isNull() do vreqerr("VAL4EXT") quit
	quit

vrequ // Valid required columns on update


	type public String vx()
	type public RecordDBTBL1 dbtbl1

	if dbtbl1.%libs.isNull() do vreqerr("%LIBS") quit
	if dbtbl1.fid.isNull() do vreqerr("FID") quit

	if 'vobj(dbtbl1,-100,10,"").order().isNull() do {
		if vx("DFTORD").exists(),dbtbl1.dftord.isNull() do vreqerr("DFTORD") quit
		if vx("EXTENDLENGTH").exists(),dbtbl1.extendlength.isNull() do vreqerr("EXTENDLENGTH") quit
	}
	if 'vobj(dbtbl1,-100,13,"").order().isNull() do {
		if vx("FDOC").exists(),dbtbl1.fdoc.isNull() do vreqerr("FDOC") quit
	}
	if 'vobj(dbtbl1,-100,16,"").order().isNull() do {
		if vx("ACCKEYS").exists(),dbtbl1.acckeys.isNull() do vreqerr("ACCKEYS") quit
	}
	if 'vobj(dbtbl1,-100,22,"").order().isNull() do {
		if vx("VAL4EXT").exists(),dbtbl1.val4ext.isNull() do vreqerr("VAL4EXT") quit
		if vx("RFLAG").exists(),dbtbl1.rflag.isNull() do vreqerr("RFLAG") quit
		if vx("DFLAG").exists(),dbtbl1.dflag.isNull() do vreqerr("DFLAG") quit
	}
	if 'vobj(dbtbl1,-100,100,"").order().isNull() do {
		if vx("LOG").exists(),dbtbl1.log.isNull() do vreqerr("LOG") quit
	}
	if 'vobj(dbtbl1,-100,"0*","").order().isNull() do {
		if vx("DES").exists(),dbtbl1.des.isNull() do vreqerr("DES") quit
	}
		if vx("ACCKEYS").exists(),dbtbl1.acckeys.isNull() do vreqerr("ACCKEYS") quit
		if vx("DES").exists(),dbtbl1.des.isNull() do vreqerr("DES") quit
		if vx("DFLAG").exists(),dbtbl1.dflag.isNull() do vreqerr("DFLAG") quit
		if vx("DFTORD").exists(),dbtbl1.dftord.isNull() do vreqerr("DFTORD") quit
		if vx("EXTENDLENGTH").exists(),dbtbl1.extendlength.isNull() do vreqerr("EXTENDLENGTH") quit
		if vx("FDOC").exists(),dbtbl1.fdoc.isNull() do vreqerr("FDOC") quit
		if vx("LOG").exists(),dbtbl1.log.isNull() do vreqerr("LOG") quit
		if vx("RFLAG").exists(),dbtbl1.rflag.isNull() do vreqerr("RFLAG") quit
		if vx("VAL4EXT").exists(),dbtbl1.val4ext.isNull() do vreqerr("VAL4EXT") quit
	quit

vreqerr(di) // Required error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("DBTBL1","MSG",1767,"DBTBL1."_di)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit


VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	if vx("").order().isNull() quit
	if vx("ACCKEYS").exists() do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PARFID").exists() do vau2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBD //
	type public Number ER = 0
	type public String vx(),RM
	do vbd1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordDBTBL1 dbtbl1
	do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() do AUDIT^UCUTILN(dbtbl1,.vx(),11,"|") quit
	if vx("GLOBAL").exists() do vbu2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(dbtbl1,.vx(),11,"|")
	quit


vai1 // Trigger AFTER_INSERT - After Insert

	type public RecordDBTBL1 dbtbl1

	/*
	-----Revision History--------------------------------------------------
	11/19/05 - RussellDS - CR18065
		   Eliminate Db.update and insert.  Move code for GLREF to
		   before insert trigger.
	
	04/29/04 - RussellDS - CR9172
		   Cleaned up variable scoping
	*/
	
	type Number i
	type String ACCKEYS, FID, KEY

	set ACCKEYS = dbtbl1.acckeys
	set FID = dbtbl1.fid

	// Create missing access keys in DBTBL1D

	for i = 1:1:ACCKEYS.length(",") do {
		
		set KEY = ACCKEYS.piece(",", i)
		
		type RecordDBTBL1D dbtbl1d = Class.new("RecordDBTBL1D", "%LIBS='SYSDEV',FID=:FID,DI=:KEY")
		
		set dbtbl1d.nod = i_"*"
		set dbtbl1d.des = KEY
		set dbtbl1d.rhd = KEY
		set dbtbl1d.len = 12
		set dbtbl1d.typ = "N"
		set dbtbl1d.req = 1
		
		do dbtbl1d.save()
	}

	quit 

vau1 // Trigger AU_ACCKEYS - After update accecc keys

	type public RecordDBTBL1 dbtbl1
	/*
	---------- Revision History ------------------------------------------
	10/28/04 - RussellDS - CR8058
		   Fix logic errors that are not correctly renumbering keys.
		   
		   Revise code to use current PSL methods.
		   
		   Remove old revision history.
		   
	04/29/04 - RussellDS - CR9172
		   Cleaned up variable scoping
	----------------------------------------------------------------------
	*/
	
	type Public String FID
	
	type Number KEYNUM
	type String GBLREF, KEYNAME, NEWKEYS(), OLDKEYS
	
	set OLDKEYS = dbtbl1.acckeys.oldVal		// Old access keys
	set NEWKEYS = dbtbl1.acckeys			// New access keys

	// Reset global reference
	set GBLREF = "^"_dbtbl1.global_"("_NEWKEYS
	do Db.update("DBTBL1", "GLREF=:GBLREF", "%LIBS='SYSDEV' AND FID=:FID")
	
	for KEYNUM = 1:1:NEWKEYS.length(",") set NEWKEYS(NEWKEYS.piece(",", KEYNUM)) = KEYNUM
	
	// If old key is no longer new key, delete it
	for KEYNUM = 1:1:OLDKEYS.length(",") do {
		set KEYNAME = OLDKEYS.piece(",", KEYNUM)
		if 'NEWKEYS(KEYNAME).exists() do Db.delete("DBTBL1D", "%LIBS='SYSDEV' AND FID=:FID AND DI=:KEYNAME")
	}
	
	// For new keys, if already existed, update key number, otherwise add key
	set KEYNAME = ""
	for  set KEYNAME = NEWKEYS(KEYNAME).order() quit:KEYNAME.isNull()  do {
		set KEYNUM = NEWKEYS(KEYNAME)
		
		type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D", "%LIBS='SYSDEV',FID=:FID,DI=:KEYNAME", 1)
		
		if dbtbl1d.nod '= (KEYNUM_"*") do {
		
			set dbtbl1d.nod = KEYNUM_"*"
			
			if 'dbtbl1d.getMode()  do {			// New key
				set dbtbl1d.typ = "N"
				set dbtbl1d.len = 12
				set dbtbl1d.des = KEYNAME
				set dbtbl1d.rhd = KEYNAME
				set dbtbl1d.req = 1
			}
			
			do dbtbl1d.save()
		}
	}
			
	quit

vau2 // Trigger AU_PARFID - After update supertype information

	type public RecordDBTBL1 dbtbl1
	//----------------------------------------------------------------------
	// Copy data item info from supertype file to descendant files
	//----------------------------------------------------------------------
	
	/*
	-----Revision History--------------------------------------------------
	04/29/04 - RussellDS - CR9172
		   Cleaned up variable scoping

	*/
	
	type Public String FID
	
	type String nparfid,oparfid
	
	set nparfid=dbtbl1.parfid              // Supertype file name
	set oparfid=dbtbl1.parfid.oldVal       // Original name
	if oparfid'="" do PARDEL^DBSDF(oparfid,FID)    // Delete old data
	if nparfid'="" do PARCOPY^DBSDF(nparfid,FID)   // Create new data
	
	quit 

vbd1 // Trigger BEFORE_DELETE - Before Delete

	type public RecordDBTBL1 dbtbl1
	// Delete data items
	
	do Db.delete("DBTBL1D","%LIBS='SYSDEV' AND FID=:FID")
	
	quit

vbi1 // Trigger BEFORE_INSERT - Before Insert

	type public RecordDBTBL1 dbtbl1

	/* ----- Revision History ---------------------------------------------
	
	11/19/05 - RussellDS - CR18065
		   Move code previously in after insert trigger that was doing
		   updates and deletes here.
	*/

								// Default global name

	if dbtbl1.global.isNull() do {

		if $E(dbtbl1.fid,1,4)="UTBL"!($E(dbtbl1.fid,1,5)="ZUTBL") set dbtbl1.global="UTBL"
		else  if $E(dbtbl1.fid,1,4)="STBL"!($E(dbtbl1.fid,1,5)="ZSTBL") set dbtbl1.global="STBL" 
		else  if $E(dbtbl1.fid,1,4)="CTBL"!($E(dbtbl1.fid,1,5)="ZCTBL") set dbtbl1.global="CTBL" 
	}
	
	// Reset full global reference
	
	set dbtbl1.glref = "^"_dbtbl1.global_"("_dbtbl1.acckeys
	
	quit
	

vbu1 // Trigger BEFORE_UPDATE - Before  Update

	type public RecordDBTBL1 dbtbl1
	do dbtbl1.setAuditFlag(1)
	/*
	---------- Revision History ------------------------------------------
	04/29/04 - RussellDS - CR9172
		   Cleaned up variable scoping
	
	06/25/98 - Chiang - 29226
	           Removed M code (S DI=" ") from the trigger definition.
	
	12/05/97 - Chiang - 26983
	           Moved field delimiter logic into AU_DEL trigger
	*/

	// Set up username and date last updated
	
	set dbtbl1.user=%UserName		// User name
	set dbtbl1.ltd=%CurrentDate            	// Date
	
	quit 
	

vbu2 // Trigger BU_GLOBAL - Change GLREF field

	type public RecordDBTBL1 dbtbl1
	do dbtbl1.setAuditFlag(1)
	
	new gbl
	set gbl=dbtbl1.glref                			// Old reference
	set dbtbl1.glref=$C(94)_dbtbl1.global_"("_$P(gbl,"(",2) // New reference
	quit 
	


vddver // Validate data dictionary attributes

	type public Number %O
	type public String vpar,vx()

	type String vRM,X
	type public RecordDBTBL1 dbtbl1

	if (%O = 2) do vload

	if vobj(dbtbl1,0).exists() do {

		if dbtbl1.global.length()>8 set vRM = $$^MSG(1076,8) do vdderr("GLOBAL", vRM) quit
	}

	if vobj(dbtbl1,1).exists() do {

		if dbtbl1.akey1.length()>12 set vRM = $$^MSG(1076,12) do vdderr("AKEY1", vRM) quit
	}

	if vobj(dbtbl1,2).exists() do {

		if dbtbl1.akey2.length()>12 set vRM = $$^MSG(1076,12) do vdderr("AKEY2", vRM) quit
	}

	if vobj(dbtbl1,3).exists() do {

		if dbtbl1.akey3.length()>12 set vRM = $$^MSG(1076,12) do vdderr("AKEY3", vRM) quit
	}

	if vobj(dbtbl1,4).exists() do {

		if dbtbl1.akey4.length()>12 set vRM = $$^MSG(1076,12) do vdderr("AKEY4", vRM) quit
	}

	if vobj(dbtbl1,5).exists() do {

		if dbtbl1.akey5.length()>12 set vRM = $$^MSG(1076,12) do vdderr("AKEY5", vRM) quit
	}

	if vobj(dbtbl1,6).exists() do {

		if dbtbl1.akey6.length()>12 set vRM = $$^MSG(1076,12) do vdderr("AKEY6", vRM) quit
	}

	if vobj(dbtbl1,7).exists() do {

		if dbtbl1.akey7.length()>12 set vRM = $$^MSG(1076,12) do vdderr("AKEY7", vRM) quit
	}

	if vobj(dbtbl1,10).exists() do {

		set X = dbtbl1.dbase if 'X.isNull(),'{List}"GTM,ORACLE".contains(X) set vRM = $$^MSG(1485,X) do vdderr("DBASE", vRM) quit
		set X = dbtbl1.del if 'X.isNull(),'Db.isDefined("DBCTLDELIM","X") set vRM = $$^MSG(1485,X) do vdderr("DEL", vRM) quit
		if dbtbl1.dftdes.length()>200 set vRM = $$^MSG(1076,200) do vdderr("DFTDES", vRM) quit
		if dbtbl1.dftdes1.length()>200 set vRM = $$^MSG(1076,200) do vdderr("DFTDES1", vRM) quit
		if dbtbl1.dfthdr.length()>78 set vRM = $$^MSG(1076,78) do vdderr("DFTHDR", vRM) quit
		if '("01"[dbtbl1.DFTORD) set vRM=$$^MSG(742,"L") do vdderr("DFTORD", vRM) quit
		set X = dbtbl1.exist if 'X.isNull(),X'?1.6N,X'?1"-"1.5N set vRM=$$^MSG(742,"N") do vdderr("EXIST", vRM) quit
		if '("01"[dbtbl1.EXTENDLENGTH) set vRM=$$^MSG(742,"L") do vdderr("EXTENDLENGTH", vRM) quit
		set X = dbtbl1.filetyp if 'X.isNull(),'Db.isDefined("DBCTLFILETYP","X") set vRM = $$^MSG(1485,X) do vdderr("FILETYP", vRM) quit
		set X = dbtbl1.ltd if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("LTD", vRM) quit
		if dbtbl1.mplctdd.length()>25 set vRM = $$^MSG(1076,25) do vdderr("MPLCTDD", vRM) quit
		set X = dbtbl1.netloc if 'X.isNull(),'{List}"0,1,2".contains(X) set vRM = $$^MSG(1485,X) do vdderr("NETLOC", vRM) quit
		if dbtbl1.parfid.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PARFID", vRM) quit
		set X = dbtbl1.syssn if 'X.isNull(),'Db.isDefined("SCASYS","X") set vRM = $$^MSG(1485,X) do vdderr("SYSSN", vRM) quit
		if dbtbl1.user.length()>20 set vRM = $$^MSG(1076,20) do vdderr("USER", vRM) quit
	}

	if vobj(dbtbl1,12).exists() do {

		if dbtbl1.fsn.length()>12 set vRM = $$^MSG(1076,12) do vdderr("FSN", vRM) quit
	}

	if vobj(dbtbl1,13).exists() do {

		if dbtbl1.fdoc.length()>30 set vRM = $$^MSG(1076,30) do vdderr("FDOC", vRM) quit
	}

	if vobj(dbtbl1,14).exists() do {

		if dbtbl1.qid1.length()>100 set vRM = $$^MSG(1076,100) do vdderr("QID1", vRM) quit
	}

	if vobj(dbtbl1,16).exists() do {

		if dbtbl1.acckeys.length()>100 set vRM = $$^MSG(1076,100) do vdderr("ACCKEYS", vRM) quit
	}

	if vobj(dbtbl1,22).exists() do {

		if '("01"[dbtbl1.DFLAG) set vRM=$$^MSG(742,"L") do vdderr("DFLAG", vRM) quit
		if dbtbl1.predaen.length()>255 set vRM = $$^MSG(1076,255) do vdderr("PREDAEN", vRM) quit
		if '("01"[dbtbl1.RFLAG) set vRM=$$^MSG(742,"L") do vdderr("RFLAG", vRM) quit
		if dbtbl1.screen.length()>12 set vRM = $$^MSG(1076,12) do vdderr("SCREEN", vRM) quit
		if '("01"[dbtbl1.VAL4EXT) set vRM=$$^MSG(742,"L") do vdderr("VAL4EXT", vRM) quit
	}

	if vobj(dbtbl1,99).exists() do {

		if dbtbl1.fpn.length()>4 set vRM = $$^MSG(1076,4) do vdderr("FPN", vRM) quit
		if dbtbl1.publish.length()>30 set vRM = $$^MSG(1076,30) do vdderr("PUBLISH", vRM) quit
		if dbtbl1.udacc.length()>8 set vRM = $$^MSG(1076,8) do vdderr("UDACC", vRM) quit
		if dbtbl1.udfile.length()>8 set vRM = $$^MSG(1076,8) do vdderr("UDFILE", vRM) quit
		if dbtbl1.udpost.length()>20 set vRM = $$^MSG(1076,20) do vdderr("UDPOST", vRM) quit
		if dbtbl1.udpre.length()>20 set vRM = $$^MSG(1076,20) do vdderr("UDPRE", vRM) quit
	}

	if vobj(dbtbl1,100).exists() do {

		if dbtbl1.archfiles.length()>255 set vRM = $$^MSG(1076,255) do vdderr("ARCHFILES", vRM) quit
		if dbtbl1.archkey.length()>12 set vRM = $$^MSG(1076,12) do vdderr("ARCHKEY", vRM) quit
		if dbtbl1.glref.length()>100 set vRM = $$^MSG(1076,100) do vdderr("GLREF", vRM) quit
		if '("01"[dbtbl1.LOG) set vRM=$$^MSG(742,"L") do vdderr("LOG", vRM) quit
		if dbtbl1.ptrtim.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PTRTIM", vRM) quit
		if dbtbl1.ptrtimu.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PTRTIMU", vRM) quit
		if dbtbl1.ptrtld.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PTRTLD", vRM) quit
		if dbtbl1.ptrtldu.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PTRTLDU", vRM) quit
		if dbtbl1.ptruser.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PTRUSER", vRM) quit
		if dbtbl1.ptruseru.length()>12 set vRM = $$^MSG(1076,12) do vdderr("PTRUSERU", vRM) quit
		set X = dbtbl1.rectyp if 'X.isNull(),'{List}"0,1,10,11".contains(X) set vRM = $$^MSG(1485,X) do vdderr("RECTYP", vRM) quit
	}

	if vobj(dbtbl1,101).exists() do {

		if dbtbl1.listdft.length()>450 set vRM = $$^MSG(1076,450) do vdderr("LISTDFT", vRM) quit
	}

	if vobj(dbtbl1,102).exists() do {

		if dbtbl1.listreq.length()>500 set vRM = $$^MSG(1076,500) do vdderr("LISTREQ", vRM) quit
	}
	if dbtbl1.%libs.length()>12 set vRM = $$^MSG(1076,12) do vdderr("%LIBS", vRM) quit
	if dbtbl1.fid.length()>256 set vRM = $$^MSG(1076,256) do vdderr("FID", vRM) quit

	if vobj(dbtbl1).exists() ! 'vobj(dbtbl1,"").order().isNull() do {

		if dbtbl1.des.length()>40 set vRM = $$^MSG(1076,40) do vdderr("DES", vRM) quit
	}
	quit

vdderr(di, vRM) // Column attribute error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("DBTBL1","MSG",979,"DBTBL1."_di_" "_vRM)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit


public VINDEX(RecordDBTBL1 dbtbl1) // Update index entries

		type Public String vx()

	if %ProcessMode=1 do { quit
		if vx("FSN").exists() do vi1(.dbtbl1)
		if vx("GLOBAL").exists() do vi2(.dbtbl1)
		if vx("PARFID").exists() do vi3(.dbtbl1)
		if vx("UDFILE").exists() do vi4(.dbtbl1)
	}
	do vi1(.dbtbl1)
	do vi2(.dbtbl1)
	do vi3(.dbtbl1)
	do vi4(.dbtbl1)

	quit
	

vi1(RecordDBTBL1 dbtbl1) // Maintain FSN index entries (File Short Name)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = dbtbl1.%libs
	type String v3 = dbtbl1.fsn
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = dbtbl1.fid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
		if '$D(^XDBREF("DBTBL1.FSN",v2,v3,v4)) do vidxerr("FSN")
		}


	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	if %ProcessMode<2 set ^XDBREF("DBTBL1.FSN",v2,v3,v4)="" 
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("FSN").exists() set v3=vx("FSN").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	kill ^XDBREF("DBTBL1.FSN",v2,v3,v4)
	quit

vi2(RecordDBTBL1 dbtbl1) // Maintain GLOBAL index entries (Global Name)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = dbtbl1.%libs
	type String v3 = dbtbl1.global
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = dbtbl1.fid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
		if '$D(^XDBREF("DBTBL1.GLOBAL",v2,v3,v4)) do vidxerr("GLOBAL")
		}


	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	if %ProcessMode<2 set ^XDBREF("DBTBL1.GLOBAL",v2,v3,v4)="" 
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("GLOBAL").exists() set v3=vx("GLOBAL").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	kill ^XDBREF("DBTBL1.GLOBAL",v2,v3,v4)
	quit

vi3(RecordDBTBL1 dbtbl1) // Maintain PARFID index entries (Inheritance Filename)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = dbtbl1.%libs
	type String v3 = dbtbl1.parfid
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = dbtbl1.fid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
		if '$D(^DBINDX(v1,"PARFID",v3,v4)) do vidxerr("PARFID")
		}


	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	if %ProcessMode<2 set ^DBINDX(v1,"PARFID",v3,v4)="" 
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("PARFID").exists() set v3=vx("PARFID").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	kill ^DBINDX(v1,"PARFID",v3,v4)
	quit

vi4(RecordDBTBL1 dbtbl1) // Maintain UDFILE index entries (Record Filer Routine)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = dbtbl1.%libs
	type String v3 = dbtbl1.udfile
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = dbtbl1.fid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
		if '$D(^XDBREF("DBTBL1.UDFILE",v2,v3,v4)) do vidxerr("UDFILE")
		}


	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	if %ProcessMode<2 set ^XDBREF("DBTBL1.UDFILE",v2,v3,v4)="" 
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("UDFILE").exists() set v3=vx("UDFILE").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	kill ^XDBREF("DBTBL1.UDFILE",v2,v3,v4)
	quit

public VIDXBLD(List vlist) // Rebuild index files (External call)


	type Number %ProcessMode=0                             // Create mode
	type Number i

	if vlist.get().isNull() set vlist="VINDEX"             // Build all

	type DbSet ds=Db.selectDbSet("DBTBL1")

	while ds.next() do {
		type RecordDBTBL1 dbtbl1=ds.getRecord("DBTBL1")
		if vlist.contains("VINDEX") do VINDEX(.dbtbl1) quit
		if vlist.contains("FSN") do vi1(.dbtbl1)
		if vlist.contains("GLOBAL") do vi2(.dbtbl1)
		if vlist.contains("PARFID") do vi3(.dbtbl1)
		if vlist.contains("UDFILE") do vi4(.dbtbl1)
	}

	quit


public VIDXBLD1(RecordDBTBL1 dbtbl1, List vlist) // Rebuild index files for one record (External call)


	type Number i

	if vlist.contains("VINDEX") do VINDEX(.dbtbl1) quit
	if vlist.contains("FSN") do vi1(.dbtbl1)
	if vlist.contains("GLOBAL") do vi2(.dbtbl1)
	if vlist.contains("PARFID") do vi3(.dbtbl1)
	if vlist.contains("UDFILE") do vi4(.dbtbl1)

	quit


vidxerr(di) // Error message

	D SETERR^DBSEXECU("DBTBL1","MSG",1225,"DBTBL1."_di)

	quit


vkchged // Access key changed

	type public RecordDBTBL1 dbtbl1

	type public Boolean ER = 0
	type public String RM,vpar,vx()

	type Number %O = 1
	type String vnewkey,voldkey,vux
	type String voldpar = vpar.get()                       // Save filer switches

	if vx("%LIBS").exists() set vux("%LIBS") = vx("%LIBS")
	if vx("FID").exists() set vux("FID") = vx("FID")
	do vkey(1) set voldkey = dbtbl1.%libs_","_dbtbl1.fid   // Copy old keys into object

	set vpar = $$setPar^UCUTILN(vpar,"NOINDEX")            // Switch Index off
	do vload                                               // Make sure all data is loaded locally
	if vpar["/VALREQ/" do vrequ
	if vpar["/TRIGBEF/" do VBU
	if vpar["/VALDD/" do vddver
	do vexec

	do vkey(2) set vnewkey = dbtbl1.%libs_","_dbtbl1.fid   // Copy new keys into object
	type RecordDBTBL1 vnewrec = dbtbl1.copy()
	do vnewrec.setMode(0)
	do vnewrec.save("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")

	set %O = 1 do CASUPD^DBSEXECU("DBTBL1",voldkey,vnewkey) if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~")) // Cascade update
	set vpar = voldpar
	if vpar["/TRIGAFT/" do VAU

	do vkey(1)                                             // Reset key for delete
	set vpar = $$initPar^UCUTILN("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")
	set %O = 3 do vdelete(1)                               // Delete old record

	quit

vkey(Number i) // Restore access keys

	type public String vux()
	type public RecordDBTBL1 dbtbl1

	if vux("%LIBS").exists() set dbtbl1.%libs = vux("%LIBS").piece("|",i)
	if vux("FID").exists() set dbtbl1.fid = vux("FID").piece("|",i)
	quit

VCASDEL // Cascade delete logic

	type public RecordDBTBL1 dbtbl1
	type public String vpar

	do Db.delete("DBTBL1D","%LIBS=:dbtbl1.%libs AND FID=:dbtbl1.fid",vpar) // Cascade delete

	do Db.delete("DBTBL1F","%LIBS=:dbtbl1.%libs AND FID=:dbtbl1.fid",vpar) // Cascade delete

	do Db.delete("DBTBL1F","%LIBS=:dbtbl1.%libs AND TBLREF=:dbtbl1.fid",vpar) // Cascade delete

	do Db.delete("DBTBL7","%LIBS=:dbtbl1.%libs AND TABLE=:dbtbl1.fid",vpar) // Cascade delete

	do Db.delete("DBTBL8","%LIBS=:dbtbl1.%libs AND FID=:dbtbl1.fid",vpar) // Cascade delete

	do Db.delete("DBTBL9","%LIBS=:dbtbl1.%libs AND PRITABLE=:dbtbl1.fid",vpar) // Cascade delete

	quit

VIDXPGM()	quit "DBSDF1F"	// Location of index program

