LNPP6FIL(RecordLNPP6 lnpp6, String vpar, Boolean vparNorm) // LNPP6 - Loan Purchased Status - Single Filer
	// Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 11:27 - shetyes
	// Generated from DATA-QWIK schema in: /profile/v72qa_gtmlx  by: /v72qa_gtmlx/crtns/DBSFILB.obj

	// Data Dictionary Data Items (29)             11/22/2003
	// Trigger Definition (5)                      04/01/2006
	// Journal File Definition (2)                 12/25/2006
	/*
		vpar      Runtime qualifiers:      /NOREQ/MECH=REFARR:R

		/[NO]CASDEL   - Cascade delete
		/[NO]FRMFILER - Called from another filer
		/[NO]INDEX    - Update Indexes
		/[NO]JOURNAL  - Journal update
		/[NO]TRIGAFT  - After update triggers
		/[NO]TRIGBEF  - Before update triggers
		/[NO]UPDATE   - Update primary table
		/[NO]VALDD    - Validate column values
		/[NO]VALFK    - Validate foreign keys
		/[NO]VALREQ   - Validate not null values
		/[NO]VALRI    - Validate transaction integrity
		/[NO]VALST    - Validate database state
	*/

	type public String verrors()

	type String vx(), vxins()                              // audit column array
	type Number %O = lnpp6.getMode()                       // Processing mode
	set vpar = vpar.get()                                  // Initialize vpar
	if %O = 0 do AUDIT^UCUTILN(lnpp6,.vxins(),1,"|")
	if %O = 1 do AUDIT^UCUTILN(lnpp6,.vx(),1,"|")

	if 'vparNorm.get() set vpar = $$initPar^UCUTILN(vpar)  // Run-time qualifiers

	// Define local variables for access keys for legacy triggers
	type String CID = lnpp6.cid

	if %O = 0 do { quit                                    // Create record control block
		do vinit                                              // Initialize column values
		if vpar["/TRIGBEF/" do VBI                            // Before insert triggers
		if vpar["/VALREQ/" do vreqn                           // Check required
		if vpar["/VALDD/" do vddver                           // Check values
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 1 do { quit                                    // Update record control block
		if vx("CID").exists() do vkchged quit                 // Primary key changed
		if vpar["/TRIGBEF/" do VBU                            // Before update triggers
		if vpar["/VALREQ/" do vrequ                           // Check required
		if vpar["/VALDD/" do VDDUX^DBSFILER("LNPP6",.vx)
		set %O = 1 do vexec
		if vpar["/TRIGAFT/" do VAU                            // After update triggers
	}

	if %O = 2 do { quit                                    // Verify record control block
		if vpar["/VALREQ/" do vreqn                           // Check required
		set vpar = $$setPar^UCUTILN(vpar,"NOJOURNAL/NOUPDATE")
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 3 do { quit                                    // Delete record control block
		quit:'Db.isDefined("LNPP6","CID = :lnpp6.cid")        // No record exists
		if vpar["/TRIGBEF/" do VBD                            // Before delete triggers
		do vdelete(0)
	}

	quit

vlegacy(Number %ProcessMode,String vpar) // Legacy interface (^DBSDF9 for %O=0, EXT^DBSFILER for %O = 2)

	type public String CID

	type RecordLNPP6 lnpp6 = Db.getRecord("LNPP6","CID=:CID")
	if (%ProcessMode = 2) do {
		do lnpp6.setMode(2)

		do LNPP6FIL(lnpp6,vpar)
	}
	else  do VINDEX(lnpp6)

	quit

vLITCHK() quit 0 // Table does not have columns involved in literals


vexec // Execute transaction

	type public Number %O
	type public String vpar,vobj(),vx(),vxins()

	type public RecordLNPP6 lnpp6

	type String vERRMSG

	if vpar["/VALST/" if '(''Db.isDefined("LNPP6","CID = :lnpp6.cid") = ''%O) set vERRMSG = $$^MSG($select(%O:7932,1:2327)) throw Class.new("Error","%PSL-E-DBSFILER,"_vERRMSG.replace(",","~"))
	if vpar["/VALFK/" do CHKFKS                            // Check foreign keys
	if vpar["/VALRI/" do VFKEYS                            // Foreign key definition

	if vpar'["/NOUPDATE/" do {

		// Allow global reference and M source code
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
		#BYPASS
		if $D(vobj(lnpp6))  S ^LP(vobj(lnpp6,-3))=vobj(lnpp6)
		#ENDBYPASS

		if vpar["/JOURNAL/" do VJOURNAL(.lnpp6)               // Create journal files
	}

	if vpar["/INDEX/",'(%O = 1)!'vx("").order().isNull() do VINDEX(.lnpp6) // Update Index files

	quit

vdelete(Boolean vkeychg) // Record Delete

	type public String vobj(),vpar
	type public RecordLNPP6 lnpp6

	if vpar["/INDEX/" do VINDEX(.lnpp6)                    // Delete index entries
	if vpar["/JOURNAL/" do VJOURNAL(.lnpp6)                // Create journal entries

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	ZWI ^LP(vobj(lnpp6,-3))                                // Delete Record
	quit


vinit // Initialize default values

	type public RecordLNPP6 lnpp6

	// Type local variables for access keys for defaults
	type public String CID

	if lnpp6.rfpf.isNull() set lnpp6.rfpf = 0              // rfpf
	quit


vreqn // Validate required data items

	type public RecordLNPP6 lnpp6

	if lnpp6.pl.isNull() do vreqerr("PL") quit
	if lnpp6.rfpf.isNull() do vreqerr("RFPF") quit
	if lnpp6.slcd.isNull() do vreqerr("SLCD") quit
	quit

vrequ // Valid required columns on update


	type public String vx()
	type public RecordLNPP6 lnpp6

	if lnpp6.cid.isNull() do vreqerr("CID") quit

		if vx("PL").exists(),lnpp6.pl.isNull() do vreqerr("PL") quit
		if vx("RFPF").exists(),lnpp6.rfpf.isNull() do vreqerr("RFPF") quit
		if vx("SLCD").exists(),lnpp6.slcd.isNull() do vreqerr("SLCD") quit
	quit

vreqerr(di) // Required error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("LNPP6","MSG",1767,"LNPP6."_di)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit


VFKEYS // Foreign keys

	type public String vfkey(),vpar

	type public RecordLNPP6 lnpp6
	if 'lnpp6.cid.isNull() set vfkey("^ACN("_""""_lnpp6.cid_""""_","_50_")")="LNPP6(CID) -> LN"
	if 'lnpp6.pl.isNull() set vfkey("^UTBL("_"""LNPP"""_","_""""_lnpp6.slcd_""""_","_""""_lnpp6.pl_""""_")")="LNPP6(SLCD,PL) -> LNPP2"
	quit

CHKFKS   // Check foreign keys when not under buffer


	type public RecordLNPP6 lnpp6
	type public Number %O
	type String vERRMSG

	if 'Db.isDefined("LN",":lnpp6.cid") set vERRMSG = $$^MSG(8563,"LNPP6(CID) -> LN") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	if 'Db.isDefined("LNPP2",":lnpp6.slcd,:lnpp6.pl") set vERRMSG = $$^MSG(8563,"LNPP6(SLCD,PL) -> LNPP2") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	quit


VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	if vx("").order().isNull() quit
	if vx("LIFIN").exists()!vx("LIFPR").exists()!vx("LIFSF").exists()!vx("PLRFR").exists()!vx("PLRIR").exists()!vx("PLRPR").exists()!vx("PYRIN").exists()!vx("PYRPR").exists()!vx("PYRSF").exists()!vx("YTDIN").exists()!vx("YTDPR").exists()!vx("YTDSF").exists() do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBD //
	type public Number ER = 0
	type public String vx(),RM
	do vbd1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordLNPP6 lnpp6
	if vx("").order().isNull() do AUDIT^UCUTILN(lnpp6,.vx(),1,"|") quit
	if vx("RFPF").exists() do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(lnpp6,.vx(),1,"|")
	quit


vai1 // Trigger AFTER_INSERT - After Insert of LN part sold

	type public RecordLNPP6 lnpp6
	/*
	This function is called after a loan has been inserted into the LNPP6
	file. It is used to update the LN and LNPP2 files with information
	related to this new record.

	---- Revision History ------------------------------------------------
	06/12/03 - CARROLLJ - 51349
		    Rewrote trigger to correct undefined error when updating
		    lnpp2.reppb.


	*/
	
	if %ProcessMode=2 quit
	new XCID,XBAL,XPL,XSLCD
	set XCID=lnpp6.cid
	set XPL=lnpp6.pl
	set XSLCD=lnpp6.slcd
	Type RecordLN ln=Db.getRecord("LN","CID=:XCID")
	set XBAL=ln.bal
	Type RecordLNPP2 lnpp2=Db.getRecord("LNPP2","SLCD=:XSLCD,PL=:XPL",1)
	set lnpp2.slcd=XSLCD
	set lnpp2.pl=XPL
	set lnpp2.reppb=lnpp2.reppb+XBAL
	set lnpp2.taip=lnpp2.taip+1
	do lnpp2.bypassSave()
	
	set ln.ppflg=1
	do ln.bypassSave()
	quit
	

vau1 // Trigger AFTER_UPDATE - After Update trigger

	type public RecordLNPP6 lnpp6
	/*
	---------- Revision History ------------------------------------------
	09/16/99 - CARROLLJ - 31126
		   Convert to PSL.

	

	This after-update trigger is executed anytime one of the
	following fields from the file LNPP6 are changed:
	LIFIN,LIFPR,LIFSF,PLRFR,PLRIR,PLRPR,PYRIN,PYRPR,PYRSF,YTDIN,YTDPR,YTDSF
	This code is used to update the LNPP2 file with the amounts which
	have changed as a result of an update to particular fields in LNPP6
	The LNPP2 fields which can be updated are:
	IPL,PRL,SPL,SCP,CIP,PRLR,IPY,PRPY,SPY,IYTD,PRYTD,SYTD
	*/

	new XPL,XSLCD

	set XSLCD=lnpp6.slcd
	set XPL=lnpp6.pl
	type RecordLNPP2 lnpp2=Db.getRecord("LNPP2","XSLCD,XPL")
	
	if lnpp6.slcd=""!(lnpp6.pl="") quit 
	new SQLUPD,VAR,XSLCD,XPL,X
	set XPL=lnpp2.pl
	set SQLUPD=""
	
	if (lnpp6.lifin.oldVal'=lnpp6.lifin) do {
		set VAR=lnpp6.lifin-lnpp6.lifin.oldVal
		set SQLUPD=SQLUPD_",lnpp2.ipl=lnpp2.ipl+"_VAR
		}
	
	if (lnpp6.lifpr.oldVal'=lnpp6.lifpr) do {
		set VAR=lnpp6.lifpr-lnpp6.lifpr.oldVal
		set SQLUPD=SQLUPD_",lnpp2.prl=lnpp2.prl+"_VAR
		}
	
	if (lnpp6.lifsf.oldVal'=lnpp6.lifsf) do {
		set VAR=lnpp6.lifsf-lnpp6.lifsf.oldVal
		set SQLUPD=SQLUPD_",lnpp6.spl=lnpp2.spl+"_VAR
		}
	
	if (lnpp6.plrfr.oldVal'=lnpp6.plrfr) do {
		set VAR=lnpp6.plrfr-lnpp6.plrfr.oldVal
		set SQLUPD=SQLUPD_",lnpp2.scp=lnpp2.scp+"_VAR
		}
	
	if (lnpp6.plrir.oldVal'=lnpp6.plrir) do {
		set VAR=lnpp6.plrir-lnpp6.plrir.oldVal
		set SQLUPD=SQLUPD_",lnpp2.cip=lnpp2.cip+"_VAR
		}
	
	if (lnpp6.plrpr.oldVal'=lnpp6.plrpr) do {
		set VAR=lnpp6.plrpr-lnpp6.plrpr.oldVal
		set SQLUPD=SQLUPD_",lnpp2.prlr=lnpp2.prlr+"_VAR
		}
	
	if (lnpp6.pyrin.oldVal'=lnpp6.pyrin) do {
		set VAR=lnpp6.pyrin-lnpp6.pyrin.oldVal
		set SQLUPD=SQLUPD_",lnpp2.ipy=lnpp2.ipy+"_VAR
		}
	
	if (lnpp6.pyrpr.oldVal'=lnpp6.pyrpr) do {
		set VAR=lnpp6.pyrpr-lnpp6.pyrpr.oldVal
		set SQLUPD=SQLUPD_",lnpp2.prpy=lnpp2.prpy+"_VAR
		}
	
	if (lnpp6.pyrsf.oldVal'=lnpp6.pyrsf) do {
		set VAR=lnpp6.pyrsf-lnpp6.pyrsf.oldVal
		set SQLUPD=SQLUPD_",lnpp2.spy=lnpp2.spy+"_VAR
		}
	
	if (lnpp6.ytdin.oldVal'=lnpp6.ytdin) do {
		set VAR=lnpp6.ytdin-lnpp6.ytdin.oldVal
		set SQLUPD=SQLUPD_",lnpp2.iytd=lnpp2.iytd+"_VAR
		}
	
	if (lnpp6.ytdpr.oldVal'=lnpp6.ytdpr) do {
		set VAR=lnpp6.ytdpr-lnpp6.ytdpr.oldVal
		set SQLUPD=SQLUPD_",lnpp2.prytd=lnpp2.prytd+"_VAR
		}
	
	if (lnpp6.ytdsf.oldVal'=lnpp6.ytdsf) do {
		set VAR=lnpp6.ytdsf-lnpp6.ytdsf.oldVal
		set SQLUPD=SQLUPD_",lnpp2.sytd=lnpp2.sytd+"_VAR
		}
	
	if SQLUPD=1 do lnpp2.save()
	quit

vbd1 // Trigger BEFORE_DELETE - Before Delete of a loan part record

	type public RecordLNPP6 lnpp6
	new XSLCD,XPL

	type RecordLN ln=Db.getRecord("LN","CID")
	set XSLCD=lnpp6.slcd
	set XPL=lnpp6.pl
	type RecordLNPP2 lnpp2=Db.getRecord("LNPP2","XSLCD,XPL")

	/*
	This function is called when a LNPP6 record is deleted to reset some
	values in the LNPP2 and LN records.
	*/

	new X,XBAL,XCID,XDIF,XREPPB
	set XCID=lnpp6.cid
	set XBAL=ln.bal                        
	set XREPPB=lnpp2.reppb                 
	/*
	when the record is deleted, update ln.ppflg to indicate that
	the account is no longer part of a loan sold pool
	*/
	set X=0 do Db.update("LN","PPFLG=0","CID=:XCID")
	
	/*
	Update LNPP2.TAD (total accounts deleted) and LNPP2.REPPB ( Last
	Statement - Principal Balance) as we are deleting this
	record if the record has not been removed from the pool before being
	deleted.
	*/
	if lnpp6.rfpf'=1 do {
		set XDIF=XREPPB-XBAL
		set X=0 do Db.update("LNPP2","TAD=TAD+1,REPPB=:XDIF","SLCD=:XSLCD AND PL=:XPL")
		}
	quit
	

vbi1 // Trigger BEFORE_INSERT - Before Insert of LN part

	type public RecordLNPP6 lnpp6
	/*
	---- Revision History ------------------------------------------------
	03/31/06 - BHOLT - CR19735
		   Removed getrecord for lnpp6 and replaced lnpp6.slcd 
		   and lnpp6.pl in place of SL and PL for error message 56.
		    
	12/05/05 - chhabris - CR18008
		   Replaced the deprecated methods. 
	
	----------------------------------------------------------------------
	*/

	/*
	This function is used to set values for LNPP6 fields BBAL,PLSPB,PLRPB
	and PPRIL when the LNPP6 record is being inserted. It is also used to
	validate the creation of the record.  The validation performed:
		The account must exist
		A record can not exist for this account in the LNPP6 record
		The loan can not have escrow accounts
		Account must have interest calculated at billing
	*/	
	
	new BAL,DATA,VALUE,X,XCID
	set XCID=lnpp6.cid

	// verify that the account is a loan
	type RecordLN ln=Db.getRecord("LN","CID=:XCID",1)
	if 'ln.getMode() do Runtime.setErrMSG("LNPP6",1259,XCID) quit:ER
	
	
	// Verify that the account is not already in a sellers pool
	type RecordLNPP6 ln1pp6=Db.getRecord("LNPP6","CID=:XCID",1)
	
	if ln1pp6.getMode() do {
				
		// Account currently on file for seller ~p1, pool ~p2
		do Runtime.setErrMSG("LNPP6",56,"lnpp6.slcd~lnpp6.pl") quit:ER 
		}
	
	// Retrieve data from the account in order to set some defaults in LNPP6
	// and check integrity of insert
	type RecordLN ln=Db.getRecord("LN","CID=:XCID",1)
	if ln.getMode() set DATA=ln.bal_$C(9)_ln.udbal_$C(9)_ln.aruf_$C(9)_ln.iytd_$C(9)_ln.pmtdist_$C(9)_ln.idp
	
	//PMTDIST
	set ESC=$P(DATA,$C(9),5)

	// Invalid.  Loan account has escrow accounts.
	for I=1:1 set BIL=$P(ESC,"-",I) quit:BIL=""  if $$ESC^LNU(BIL) do Runtime.setErrMSG("LNPP6",1522,"XCID") quit:ER 
	
	// Interest determination Point
	// Account must have interest calculated at billing
	if $P(DATA,$C(9),6) do Runtime.setErrMSG("LNPP6",73,"XCID") quit:ER 
	
	/*
	BBAL,PLSPB,PLRPB are based on the account balance unless the advances
	to reduce undisbused balance flag is on, then UDBAL is used for as
	part of the calculation of these fields.
	*/
	set BAL=$P(DATA,$C(9),1) if $P(DATA,$C(9),3) set BAL=BAL-$P(DATA,$C(9),2)
	set lnpp6.bbal=BAL
	set lnpp6.plspb=BAL
	set lnpp6.plrpb=BAL

	// Set PLRIL = LN.IYTD
	set lnpp6.plril=$P(DATA,$C(9),4)
	quit

vbu1 // Trigger BU_RFPF - Before Update of remove from pool  

	type public RecordLNPP6 lnpp6
	do lnpp6.setAuditFlag(1)
	/*
	---- Revision History ------------------------------------------------
	12/05/05 - chhabris - CR18008
		   Replaced the deprecated methods. 
	
	----------------------------------------------------------------------
	*/

	/*
	This function is executed when the field RFPF is modified. This field
	changes when a account is either removed from the pool or restored
	to a "active" status within the pool. Basically we need to update the
	LN and LNPP2 files with this change in status.
	*/
	
	new PPADD,PPFLG,X,XCID,XPL,XSLCD
	set XCID=lnpp6.cid
	set XSLCD=lnpp6.slcd
	set XPL=lnpp6.pl
	set PPADD=+(lnpp6.rfpf)
	/*
	when the record is removed from pool, update ln.ppflg to indicate
	that the account is no longer part of a loan sold pool. When added
	back to the pool this field must be reset to yes.
	*/
	type RecordLN ln=Db.getRecord("LN","CID=:XCID",1)
	if ln.getMode()	set PPFLG=ln.ppflg
	else  set PPFLG=""
		
	if PPFLG'=PPADD set PPFLG=PPADD do Db.update("LN","PPFLG=:PPFLG","CID=:XCID")
	
	/*
	Update LNPP2.TAD (total accounts deleted) if the record is removed
	from the pool or restored to the pool. Add one when removing it,
	subtract 1 if it is being restored.
	*/
	if PPADD do Db.update("LNPP2","TAD=TAD+1","SLCD=:XSLCD AND PL=:XPL")
	if 'PPADD do Db.update("LNPP2","TAD=TAD-1","SLCD=:XSLCD AND PL=:XPL")
	quit
	


vddver // Validate data dictionary attributes

	type public Number %O
	type public String vpar,vx()

	type String vRM,X
	type public RecordLNPP6 lnpp6

	set X = lnpp6.cid if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("CID", vRM) quit
	set X = lnpp6.bbal if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.BBAL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.invac if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("INVAC", vRM) quit
	set X = lnpp6.lifin if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.LIFIN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.lifpr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.LIFPR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.lifsf if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.LIFSF"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.pl if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PL", vRM) quit
	set X = lnpp6.plrap if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLRAP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.plrfr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLRFR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.plrfs if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PLRFS", vRM) quit
	set X = lnpp6.plric if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLRIC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.plril if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLRIL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.plrir if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLRIR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.plrls if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("PLRLS", vRM) quit
	set X = lnpp6.plrpb if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLRPB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.plrpc if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLRPC"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.plrpr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLRPR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.plrrl if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLRRL"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.plrrp if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLRRP"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.plspb if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PLSPB"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.pyrin if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PYRIN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.pyrpr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PYRPR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.pyrsf if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.PYRSF"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	if '("01"[lnpp6.RFPF) set vRM=$$^MSG(742,"L") do vdderr("RFPF", vRM) quit
	set X = lnpp6.sdat if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("SDAT", vRM) quit
	set X = lnpp6.slcd if 'X.isNull(),'Db.isDefined("LNPP1","X") set vRM = $$^MSG(1485,X) do vdderr("SLCD", vRM) quit
	set X = lnpp6.ytdin if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.YTDIN"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.ytdpr if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.YTDPR"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	set X = lnpp6.ytdsf if 'X.isNull() set vRM = $$VAL^DBSVER("$",12,0,,,,,2) if 'vRM.isNull() set vRM = $$^MSG(979,"LNPP6.YTDSF"_" "_vRM) throw Class.new("Error","%PSL-E-DBFILER,"_vRM.replace(",","~"))
	quit

vdderr(di, vRM) // Column attribute error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("LNPP6","MSG",979,"LNPP6."_di_" "_vRM)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VJOURNAL(RecordLNPP6 lnpp6)	//LNPP6 Journal file entries

	type Public Date %EffectiveDate
	type Public String %TSRC,vpar,vx()
	type String TSRC,vdi,vdx()

	if %TSRC.get().isNull() set TSRC="O"
	else  set TSRC=%TSRC

	if %ProcessMode=0 do {
		if TSRC="B" do {
			do vj1(.lnpp6)	// Mode=I Tran=B EFD=N,E Seq=1 JRNID=HIST_I
			}
		else  if TSRC="O" do {
			do vj1(.lnpp6)	// Mode=I Tran=O EFD=N,E Seq=1 JRNID=HIST_I
			}
		}
	else  if %ProcessMode=1 do {
		if TSRC="B" do {
			do vj2(.lnpp6)	// Mode=U Tran=B EFD=N,E Seq=1 JRNID=HIST_U
			}
		else  if TSRC="O" do {
			do vj2(.lnpp6)	// Mode=U Tran=O EFD=N,E Seq=1 JRNID=HIST_U
			}
		}

	quit


vj1(RecordLNPP6 lnpp6)	// HIST_I  Table HIST  Loan Part Purchased insert

	type Public String EFD,%IDENT,%UID,TJD,TLO
	type String v1,vlastkey
	set v1=lnpp6.cid
	set vlastkey=Db.nextVal("HIST","CID=:v1")
	type RecordHIST hist=Db.getRecord("HIST","CID=:v1,TSEQ=:vlastkey",1)
	set hist.cdt=+$H
	set hist.efd=$G(EFD)
	set hist.ident=%IDENT
	set hist.tcmt=$$^MSG(6873,lnpp6.slcd,lnpp6.pl)
	set hist.time=$P($H,",",2)
	set hist.tjd=TJD
	set hist.tlo=TLO
	set hist.uid=%UID

	do hist.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj2(RecordLNPP6 lnpp6)	// HIST_U  Table HIST  History of updates

	type Public String vx()
	type String vdi

	set vdi="" for  set vdi=vx(vdi).order() quit:vdi=""  do {
		type Public String vx(),EFD,%IDENT,%UID,TJD,TLO,vfmtable
		type String v1,vlastkey

		type String vold,vnew,vfmtable

		set vold=vx(vdi).piece("|",1)
		set vnew=vx(vdi).piece("|",2)
		set vfmtable=vx(vdi).piece("|",11)

		set v1=lnpp6.cid
		set vlastkey=Db.nextVal("HIST","CID=:v1")
		type RecordHIST hist=Db.getRecord("HIST","CID=:v1,TSEQ=:vlastkey",1)
		set hist.cdt=+$H
		set hist.efd=$G(EFD)
		set hist.ident=%IDENT
		set hist.tcmt=$$TCMTFM^ACNFUNCS("","LNPP6",vdi,vold,vnew,,$$^MSG(6874,lnpp6.cid),vfmtable)
		set hist.time=$P($H,",",2)
		set hist.tjd=TJD
		set hist.tlo=TLO
		set hist.uid=%UID

		do hist.save("/NOVALFK/NOVALDD/NOVALRI")
		}

	quit



public VINDEX(RecordLNPP6 lnpp6) // Update index entries

		type Public String vx()

	if %ProcessMode=1 do { quit
		if vx("SLCD").exists()!vx("PL").exists() do vi1(.lnpp6)
		if vx("SLCD").exists()!vx("PL").exists() do vi2(.lnpp6)
	}
	do vi1(.lnpp6)
	do vi2(.lnpp6)

	quit
	

vi1(RecordLNPP6 lnpp6) // Maintain LNPPX index entries (Loan Part Purchased X-Ref)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = lnpp6.slcd
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = lnpp6.pl
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = lnpp6.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
		if $D(^LP(vobj(lnpp6,-3)))#2,'$D(^LP(v1,v2,v3)) do vidxerr("LNPPX")
		}


	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	if %ProcessMode<2 set ^LP(v1,v2,v3)="" 
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("SLCD").exists() set v1=vx("SLCD").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("PL").exists() set v2=vx("PL").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	kill ^LP(v1,v2,v3)
	quit

vi2(RecordLNPP6 lnpp6) // Maintain SLCD index entries (Seller Code/Poll ID)

	type Public String vx()
	type Boolean vdelete = 0
	type String v1 = lnpp6.slcd
	if v1.isNull() set v1=(PSL.maxCharValue-1).char()
	type String v2 = lnpp6.pl
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = lnpp6.cid

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
		if $D(^LP(vobj(lnpp6,-3)))#2,'$D(^LP(v1,v2,v3)) do vidxerr("SLCD")
		}


	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	if %ProcessMode<2 set ^LP(v1,v2,v3)="" 
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("SLCD").exists() set v1=vx("SLCD").piece("|",1) set:v1.isNull() v1=(PSL.maxCharValue-1).char()
	if vx("PL").exists() set v2=vx("PL").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602
	kill ^LP(v1,v2,v3)
	quit

public VIDXBLD(List vlist) // Rebuild index files (External call)


	type Number %ProcessMode=0                             // Create mode
	type Number i

	if vlist.get().isNull() set vlist="VINDEX"             // Build all

	type DbSet ds=Db.selectDbSet("LNPP6")

	while ds.next() do {
		type RecordLNPP6 lnpp6=ds.getRecord("LNPP6")
		if vlist.contains("VINDEX") do VINDEX(.lnpp6) quit
		if vlist.contains("LNPPX") do vi1(.lnpp6)
		if vlist.contains("SLCD") do vi2(.lnpp6)
	}

	quit


public VIDXBLD1(RecordLNPP6 lnpp6, List vlist) // Rebuild index files for one record (External call)


	type Number i

	if vlist.contains("VINDEX") do VINDEX(.lnpp6) quit
	if vlist.contains("LNPPX") do vi1(.lnpp6)
	if vlist.contains("SLCD") do vi2(.lnpp6)

	quit


vidxerr(di) // Error message

	D SETERR^DBSEXECU("LNPP6","MSG",1225,"LNPP6."_di)

	quit


vkchged // Access key changed

	type public RecordLNPP6 lnpp6

	type public Boolean ER = 0
	type public String RM,vpar,vx()

	type Number %O = 1
	type String vnewkey,voldkey,vux
	type String voldpar = vpar.get()                       // Save filer switches

	set vux = vx("CID")
	set voldkey = vux.piece("|",1),vobj(lnpp6,-3) = voldkey // Copy old keys into object

	set vpar = $$setPar^UCUTILN(vpar,"NOINDEX")            // Switch Index off
	if vpar["/VALREQ/" do vrequ
	if vpar["/TRIGBEF/" do VBU
	if vpar["/VALDD/" do vddver
	do vexec

	set vnewkey = vux.piece("|",2),vobj(lnpp6,-3) = vnewkey // Copy new keys into object
	type RecordLNPP6 vnewrec = lnpp6.copy()
	do vnewrec.setMode(0)
	do vnewrec.save("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")

	set %O = 1 do CASUPD^DBSEXECU("LNPP6",voldkey,vnewkey) if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~")) // Cascade update
	set vpar = voldpar
	if vpar["/TRIGAFT/" do VAU

	set vobj(lnpp6,-3) = vux.piece("|",1)                  // Reset key for delete
	set vpar = $$initPar^UCUTILN("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")
	set %O = 3 do vdelete(1)                               // Delete old record

	quit

VIDXPGM()	quit "LNPP6FIL"	// Location of index program

