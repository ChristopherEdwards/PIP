public	ZUIC(Number PR, Date FD, Date TD, String IM, Number IR, String CT, Number AF, String IF, String IP, Date SN, Date SL)
	
	/*
	Custom Int Calc Utility
	
	       ORIG:  GORMAN - 04/09/91

	   Utility considers account interest processing parameters in the
	   calculation of interest amount between two specified dates.

	   The dates passed are inclusive. If interest amounts are needed
	   for the month of December, for example, the calling program should
	   pass a from-date of December 1 and a to-date of December 31.

	   The "Next Date" data field in the account records (either the
	   deposit Next Interest Posting Date or the loan Next Scheduled
	   Payment Date) is one day after the last date considered when
	   interest is computed to that date. The calling program will
	   therefore usually subtract 1 from the Next Date before the call
	   to $$^UIC. For example, if the Last Date is December 1, and the
	   Next Date is January 1, the calling routine will pass a FD of
	   December 1, and a TD of January 1 minus 1, or December 31.
	   
	   NOTE: This procedure should be analyzed when UIC.PROC is changed,
	         to determine if the changes also need to be reflected here
	         (the core example of a custom interest calculation)

	   KEYWORDS: Interest, Loans, Deposits, Calculations

	   ARGUMENTS:
	   . PR		Principal Amount			/REQ

	   . FD		From-Date				/REQ
	    		The calculation beginning date.

	   . TD		To-Date    				/REQ
			The calculation ending date.  If the
	    		calculation is to the end of a
	    		deposit interest posting or loan
	    		interest payment period, the value of
	    		TD should be one day less than either
	    		[DEP]INP or [LN]SCHND.

	   . IM		Interest Method (IACM)			/REQ

	   . IR		Interest Rate (IRN)			/REQ

	   . CT		Processing Control			/NOREQ

	           	Option Description

		      	1	0 - Calculate over specified date range
		      	  	1 - Calculate for full payment/posting period

		      	2	0 - No daily compounding special processing
		      	  	1 - Assume daily compounding over date range

	     ----------  The following parameters are required only  ----------
	                 if the first digit of IACM is "0".

	   . AF		Annual Factor ([LN]DIST1AF)		/COND

	   . IF		Interest Freq ([LN]DIST1FRE, [DEP]IPF)	/COND

	   . IP		Interest Period Frequency (ICPF)	/COND


	     ----------  The following parameters are required only  ----------
	                 if the first digit of IACM is "0" and an
	                 odd period CT.extract(1)=0 is required.

	   . SN		Next Sched Date ([LN]SCHND, [DEP]INP)	/COND

	   . SL		Last Sched Date ([LN]SCHLD, [DEP]IPLD]	/COND

	   RETURNS
	   . $$		Interest Amount				/TYP=$

	   LIBRARY
	   . $$DY	Days in Year				/TYP=N


	---- Revision History -------------------------------------------------
	
	08/02/06 - KELLYP - CR 22048
		   Modified EXEC1 section to eliminate PRECEDENCE warning.
	
	01/30/06 - Srinivar / SmithCD - CR 16890
		   Copied this procedure from UIC.PROC, and made modifications 
		   to accomodate escrow account custom interest accrual 
		   processing. Retrofited the following from p01dev1:
			   02/23/04 - APPLEYARDM - CR 8539
                     Added section LNOVRIDE to overide DEP.IRN and DEP.IACM
                     values with values from the associated loan when
                     calculating negative interest amounts on escrow
                     accounts.
     
	08/08/05 - SmithCD CR 16724
		   . Modified INDEX section to properly handle BALINT to fix
		     an undefined error
		   . Removed use of CTL variable (not needed in this version)
		   . Changed leap year checks to use .isLeapYear() instead 
		     of #4
		   . Performed some minor cleanup
		   . Removed old revision history
	
	05/31/05 - SmithCD - CR 15902
		   . Modified EXEC2 to scope INT locally to preven doubling of 
		     calculated interest
		   . Retrofitted the following fix from p01:
		             04/28/03 - ANTONOVS - CR 3672
			Modified sections EXEC1 and EXEC2 to correctly set 
			period for accrual calculation for Interest Accrual 
			Methods 00, 01, 03.
	
	02/01/05 - SmithCD - CR13661
		   . Made changes to conform to current PSL standards
		   . Removed DY variable (was not being used) and unnecessary 
		     manipulation (protection) of PR variable
		   . Renamed local FD and TD rextrinsic functions to FROMDATE 
		     and TODATE, respectively, for the sake of readability
		   . Removed DEPLIM, DEPICH0, DEPICH1 sections, and replaced 
		     by setting PAR("LIMIT") in section INDEX (no lonnger 
	     necessary in the DBI version b/c all code is using 
		     objects)
		   . Removed pre-conversion revision history
	
	11/22/04 - RussellDS - CR13365
		   Add public tag to UIC line to eliminate PSL warnings.

	-----------------------------------------------------------------------
	*/
	
	type Boolean REV
	type Number INT

	set CT=CT.get()
	set IP=IP.get()
	set AF=AF.get()
	set IF=IF.get()
	set IP=IP.get()
	set SN=SN.get()
	set SL=SL.get()

	set (INT,REV)=""

	// Swap dates if not in valid order
	if TD<FD do {

		type Date TMPDATE

		set REV=1
		set TMPDATE=TD+1
		set TD=FD
		set FD=TMPDATE
		}

	// Custom calculation - overlay escrow IRN, IACM, etc. from loan 
	// account if BALINT on escrow account is negative
	type public Number CID
	type public RecordACN acn
	if 'acn.exists() ! (acn.exists() & (acn.cid '= CID)) set acn = Db.getRecord("ACN", "CID=:CID")
	do LNOVRIDE(.acn, PR, .IR, .IM, .AF, .IF, .IP, .SN,)
	set IR = IR / 100
	
	do EXEC

	// Reverse sign of calculated interest if TD is before FD
	if REV set INT=-INT

	quit INT


EXEC	// Processing

	type public String CT,IF,IM,IP
	type public Date FD,FROMDATE,SL,SN,TD,TODATE
	type public Number AF,INT,IR,PR
	type public Boolean ER

	type Number CYF,CYT,I,YR
	type Boolean Q

	// Define all required parameters for standard period methods
	if 'IM.extract(1) do { quit:Q 

		set Q=0

		do IM0(.IM,IP,.IF,.SN,.SL,.AF,TD)

		if CT.extract(1),IP.isNull() do {
			set INT = 360/AF*PR*IR/$$DY(IM,TD)
			set Q=1
			}
		}

	// Find calendar year associated with from- and to-date
	set CYF=FD.year()
	set CYT=TD.year()

	for YR=CYF:1:CYT do { quit:ER
		
		set FROMDATE=$$FROMDATE()
		set TODATE=$$TODATE()
		set I=$$EXEC1(FROMDATE,TODATE)

		if ER quit

		set INT=INT+I

		// Daily compounding
		if CT.extract(2) set PR=PR+I

		}
	quit


EXEC1(Date FD2, Date TD2)	// Calculations

	type public String CT,IF,IM
	type public Number AF,IR,PR
	type public Date SL,SN
	type public Boolean ER,IPDIND

	type Number FPI
	type Date JD,NJD,PER()
	
	if CT.extract(2)=1,IM.extract(1)=1 quit $$DCF1
	if IM.extract(1)=1 quit (TD2-FD2+1)*PR*IR/$$DY(IM,TD2)

	// Calc for continuous ACM
	if IM.extract(1)=2 quit PR*($$EXP^%ZFUNC(IR/$$DY(IM,TD2)*(TD2-FD2+1))-1)

	// The PER array defines scheduled payment/posting periods.

	// The code below applies only to IACM 00, 01 and 03 (standard period)

	// Calculate one full period's interest
	set FPI=360/AF*PR*IR/$$DY(IM,TD2)

	if SN.exists(),TD2<SN,FD2'<SL set PER(SN)=SL quit $$EXEC2()

	// Add a day except on the posting date if IPD is set
	set NJD=TD2+('IPDIND.get())
	set NJD=NJD.nextFreqDate("-"_IF) quit:ER 0
	set JD=NJD
	set NJD=JD.nextFreqDate(IF) quit:ER 0
	set PER(NJD)=JD+1

	for  do { quit:ER!(FD2'<NJD)
		set JD=NJD
		set NJD=JD.nextFreqDate("-"_IF) quit:ER
		set PER(JD)=NJD+1
		}

	if ER quit 0

	quit $$EXEC2()


EXEC2()

	type public Date FD2,PER(),TD2
	type public String CT
	type public Number FPI,PERIOD
	
	type Number INT = 0	
	type Date DATE = "",FROM,TO

	/*
	 The PER array is PER(last_day_of_period)=first_day_of_period,
	 for a 1MAE frequency in January of 2000, PER(58104)=58074
	*/
	for  set DATE=PER(DATE).order() quit:DATE.isNull()  do {

		// Select the correct starting (FROM) date
		set FROM=$select(FD2<PER(DATE):PER(DATE),1:FD2)
		set TO=$select(TD2>DATE:DATE,1:TD2)

		/*
		  Add one day to the ending (TO) date to make it inclusive.
		  Example:  We have PER array PER(58100)=58074,PER(58104)=58101
		  We need to add one to the last date 58104+1=58105 to make
		  the date range inclusive.  We don't want to increment 58100,
		  so check PER("").order(-1) to affect only the last entry.
		*/
		if PER("").order(-1)=DATE set TO=TO+1

		set PERIOD=DATE-PER(DATE)

		if TO=FROM quit

		set INT=INT+$select('CT.extract(2):(TO-FROM)/PERIOD*FPI,1:$$DCF0)

		}

	quit INT


DCF1()	// Returns daily compounded interest amount - actual days in period

	type public Number IR,PR
	type public Date FD2,TD2
	type public String IM

	// Daily interest factor
	type Number DIF

	set DIF=$$LNX^%ZFUNC(1+(IR/$$DY(IM,TD2)))

	quit PR*($$EXP^%ZFUNC(DIF*(TD2-FD2+1))-1)


DCF0()	// Returns daily compounded interest amount - standard days in period

	type public Number AF,IR,PERIOD,PR
	type public Date DATE,FROM,TO
	type public String IM

	// Daily interest factor
	type Number DIF

	set DIF=$$LNX^%ZFUNC(1+(IR*360/$$DY(IM,DATE)/AF/PERIOD))

	quit PR*($$EXP^%ZFUNC(DIF*(TO-FROM))-1)


FROMDATE()	// Find from-date in calendar year YR

	type public Number CYF,YR
	type public Date FD

	if YR=CYF quit FD

	quit $$DSJD^SCADAT("1/1/"_YR)


TODATE()	// Find to-date in calendar year YR

	type public Number CYT,YR
	type public Date TD
	
	if YR=CYT quit TD

	quit $$DSJD^SCADAT("12/31/"_YR)


public DY(String IM,Date FD)	// Number of days in interest calculation year
	/*

	   KEYWORDS: Interest, Deposits, Loans

	   ARGUMENTS:
	   . FD		From-Date				/TYP=D/REQ
	    		The calculation beginning date.

	   . IM		Interest Method (IACM)			/TYP=T/REQ

	   RETURNS
	   . $$		Interest Amount				/TYP=$

	*/

	if IM.extract(2)=1 quit $select(FD.isLeapYear():366,1:365)
	if IM.extract(2)=3 quit 365

	quit 360


public REV(Date FD, Date TD, String IACM, Number PV, Number IRN, String IPFRE, Date IPN, Date IPL)
	// Reverse Daily Int Calculation
	/*
	   An extrinsic function which uses the standard financial formulas
	   to compute interest earnings for the past.  To adapt these
	   calculations to IBS IACMs and variable frequencies, both the term
	   and interest rate must be altered.

	   This utility was written for ^RECALC.

	   KEYWORDS: Interest, Deposits

	   ARGUMENTS:
	   . FD		From-Date					/TYP=D/REQ
	    		The calculation beginning date.

	   . TD		To-Date						/TYP=D/REQ
	    		The calculation ending date. TD is
	    		THE DAY AFTER the calculation is to
	    		stop. If TD and FD represent deposit
	    		interest posting dates, then TD should
	    		be the next posting date.

	   . IACM	Interest Calc Method (IACM)			/TYP=T/REQ

	   . PV		Present Value					/TYP=$/REQ
	    		The balance or transaction amount
	    		upon which we are to calculate interest.

	   . IRN	Nominal Interest Rate				/TYP=$/REQ
	    		The annual nominal interest rate.

	   . IPFRE	Interest Payment Frequency			/TYP=F/REQ

	   . IPN	Interest Posting Next Date			/TYP=D/OPT
	    		The next date interest is to be posted.

	   . IPL	Interest Posting Last Date			/TYP=D/OPT
	    		The last date interest was posted.


	   RETURNS:
	   . $$		Unjustified value of the interest amount.

	   . ER		Error flag (0=No Error, 1=Error Encountered)
	*/
	
	type public Boolean ER
	type public Number IR
	
	type String FRE
	type Number DIP,IPAF,NU,NUM,PVO
	type Date DT,JD,NJD,NX

	set PVO=PV
	set (DIP,ER,IPAF)=""

	/*
	 If we're using a standard interest calc method 00, 01 or 03 then we
	 need to consider days in period (DIP).
	*/
	set NUM=IACM.extract(1)

	if 'NUM do { if ER quit ""

		// If we were not supplied with date information, compute.
		if IPL.get().isNull() set IPL=TD.nextFreqDate(IPFRE,.IPAF,1) quit:ER
		if IPN.get().isNull() set IPN=TD.nextFreqDate(IPFRE,.IPAF) quit:ER
		if IPAF.get().isNull() set NJD=TD.nextFreqDate(IPFRE,.IPAF) quit:ER

		set DT(IPN)=IPL

		set FRE="-"_IPFRE

		for  quit:IPL'>FD  do { if ER quit

			if DT(IPL).exists() set IPL=DT(IPL) quit

			set JD=IPL
			set IPL=JD.nextFreqDate(FRE) quit:ER
			set DT(JD)=IPL

			}

		set DT=DT("").order(-1)
		set DIP=DT-DT(DT)
		}

	/*
	Go back in time day-by-day.  For each day, figure the previous day's
	balance using the standard formulas.  This in fact is not the balance
	but it's what the balance plus interest to compound 
	(dep.bal+dep.cmp) would have been.
	*/
	for NX=(TD-1):-1:FD do { if ER quit

		/*
		 If we are using a standard method (NUM=0) and if we cross
		 into a prior interest period, adjust DIP
		*/
		if 'NUM,DT(DT)>NX do {
			set DT=DT(DT).order(-1)
			if 'DT.isNull() set DIP=DT-DT(DT)
			}

		set NU=$$NPCNV(1,IACM,IPAF,DIP,NX)
		set IR=$$IRC(IRN,IACM,NX,IPAF,DIP)
		set PV=$$PV^UFINC(PV,IR,NU)

		}

	if ER quit ""

	quit PVO-PV


IRC(Number IR, String IACM, Date D, Number AF, Number DIP)	// Determine periodic rate

	// 10 and 11
	if IACM=10 quit IR/360
	if IACM=11 quit IR/$$DY^UIC(IACM,D)

	// 20, 21 and 23.
	if IACM.extract(1)=2 quit $$EXP^%ZFUNC(IR/$$DY^UIC(IACM,D))-1

	// 03 and 13.  Note that previous line handles 23s.
	if IACM.extract(2)=3 quit IR/365

	if IACM="00" quit IR/AF*(AF*DIP)/$$DY^UIC("01",D)/DIP
	
	// Default and 01s
	quit IR/$$DY^UIC(IACM,D)


NPCNV(Number N, String IM, Number AF, Number DYS, Date D)
	// Convert term to acheive proper IACM

	/*
	   This paragraph "tricks" the standard formula by altering the number of
	   days in the period for the standard period IACMs 00, 01, 03.

	   Except for IACM.extract(1)=0 the days do not have to be adjusted.
	*/
	
	type public Boolean IPDIND

	if IM.extract(1) quit N

	/*
	Standard/standard gets adusted based upon the actual number of days
	in the year.  This is necessary as the interest is accrued 365 days
	per year even though it's based on 360 days.
	*/
	if IM="00" quit N*$$DY^UIC("01",D)/((AF*DYS))

	// For 01 and 03 methods adjust based upon days in the period.
	quit N*360/((AF*DYS))


IM0(String IM, String IP, String IF, Date SN, Date SL, Number AF, Date ED)
	// Interest methods with first character "0"
	
	type public Boolean ER,IPDIND
	
	type Date NJD

	// Define effective date
	if ED.get().isNull() set ED=%SystemDate

	// Use override parameters if IP defined
	if 'IP.isNull() do { quit

		// Re-define parameters based upon override frequency ICPF
		set IF=IP

		// Define the next posting date based on IPD flag
		if IPDIND.get() set SN=ED
		if SN.get().isNull() set SN=ED.nextFreqDate(IF,.AF) quit:ER

		set SL=SN.nextFreqDate("-"_IP,.AF) if ER quit
		}

	if IF.isNull() set IM=1_IM.extract(2) quit

	// Define the next posting date based on IPD flag
	if IPDIND.get() set SN=ED
	// Define next and/or last dates if not defined
	if SN.get().isNull() set SN=ED.nextFreqDate(IF,.AF) quit:ER
	if SL.get().isNull() set SL=SN.nextFreqDate("-"_IF,.AF) quit:ER

	// Ensure that last date is before today, and next date is after last
	for  quit:ER!(SL'>ED)  set SN=SL,SL=SN.nextFreqDate("-"_IF) if ER quit

	if SN'>SL set SN=SL.nextFreqDate(IF) if ER quit
	// Define annual factor if needed
	if 'AF set NJD=ED.nextFreqDate(IF,.AF) if ER quit

	quit


public GETIPDA(RecordDEP dep, RecordTTX ttx, Number CMP)

	/*
	   This is called from FDV when the include interest posting
	   day flag is on. A54 is set so it's filed back to the account.

	   KEYWORDS:

	   ARGUMENTS:
	   . dep	Deposit Account object			/TYP=RecordDEP

	   . ttx	Transaction object			/TYP=RecordTTX

	   . CMP	0 - Do not compile			/TYP=N/NOREQ
	    		1 - Compile

	   RETURNS:
	   . dep	Updated account object

	   EXAMPLE:
		do GETIPDA^UIC(.dep) quit:ER
	*/
	
	type public Boolean ER
	
	type Number ACR, ANUFAC, BALINT, DAYSPER = "", DENOM, IRCB, IRN, OLDCMP
	type Boolean ICHNDFLG, NOHIST

	// Include Posting Date Accrual bucket already set
	if 'dep.ipda.isNull() quit

	// Account not set up to accrue interest
	if 'dep.ircb quit

	set ANUFAC = dep.intaf

	if '%SystemDate.isLeapYear() set DENOM = 36500
	else  set DENOM = 36600

	set OLDCMP = dep.cmp
	set NOHIST = 0
	
	set IRCB = dep.ircb

	// Ledger Balances
	if IRCB = 1 ! (IRCB = 5) set BALINT = dep.bal
	// Collected Balance
	else  if IRCB = 3 ! (IRCB = 6) set BALINT = dep.balcol
	// Sales Price
	else  if IRCB = 4 set BALINT = $select(dep.bal:dep.salesprc, 1:0)
	// Default
	else  set BALINT = 0

	// Include Posting Date Tfr Amt
	if dep.ipdtrf set BALINT = BALINT - dep.ipdtrf

	if 'dep.maxacr.isNull(), BALINT > dep.maxacr set BALINT = dep.maxacr

	if dep.ichnd = %SystemDate do { quit:ER
		set ICHNDFLG = 1
		set dep.ichld = dep.ichnd
		set dep.ichnd = %SystemDate.nextFreqDate(dep.intfre) quit:ER
		}
	else  set ICHNDFLG = 0

	// Keep old value of [DEP]CMP to set [DEP]CMP1 in SAVCMP section
	if dep.inc = %SystemDate do { quit:ER
		set dep.inc = %SystemDate.nextFreqDate(dep.icf) quit:ER
		set dep.cmp = dep.posacr
		set dep.ilc = %SystemDate
		}

	set IRN = +dep.irn

	if 'dep.index.isNull() do INDEX(.dep, BALINT) quit:ER

	// Determine calc parameters if account uses scheduled period int calc
	if 'dep.iacm.extract(1)  do { quit:ER
		type Date LDT = ""
		type Number AF = dep.intaf

		// Int/Div Next Posted
		do IM0INP(.dep.iacm, dep.icpf, dep.ipf, dep.inp, .LDT, .AF, %SystemDate) quit:ER

		set DAYSPER = dep.inp - LDT
		}

	// If ^DEPLBB changes IRCB, continue on as regular accrual
	if IRCB = 5 ! (IRCB = 6) do { if IRCB = 5 ! (IRCB = 6), 'ER do UPDIPD(.dep, .ttx) quit

		// Low Balance account
		type Number IPDAADJ

		set ACR = ""

		do ^DEPLBB(.dep, .ACR, .IRCB, .BALINT, 0) quit:ER

		if ACR '< 0 set IPDAADJ = ""
		else  do {
			set IPDAADJ = ACR.roundDec(5)
			if IRCB = 5 ! (IRCB = 6) set ACR = 0
			}

		set dep.ipdaadj = IPDAADJ
		set dep.posacr = dep.posacr + IPDAADJ
		}

	if ER quit

	if dep.iacm.extract() = 2 ! ((dep.inc - dep.ilc) = 1) do {
		type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE=:dep.type")
		do SAVCMP(.dep, prodctl.savdbda)
		}

	if 'dep.minacr.isNull(), BALINT < dep.minacr set ACR = $select(dep.minopt:0, 1:-dep.posacr)
	else  set ACR = $$CALCINP(.dep, dep.iacm, BALINT, IRN, dep.cmp, dep.posacr, ANUFAC, DAYSPER, DENOM)
	set ACR = ACR.roundDec(5)
		
	do UPDIPD(.dep, .ttx)

	quit


UPDIPD(RecordDEP dep, RecordTTX ttx)

	// Update account data

	type public Boolean ER, NOHIST
	type public Number ACR, AWTIND, IRN

	type Number NEGUNDAA, RATE, UNCACR

	/*
	 Calculate Accrued Withholding Tax when backup withholding (DEP.BWF)
	 and Accrued Withholding Tax Processing (DEP.AWTP) are set
	*/
	if dep.bwf, dep.awtp do { if ER quit

		type Number BWA, TAXRATE = ""

		do ^DEPBW(.dep, .ttx, ACR, .BWA, , CUVAR.BWAPGM, dep.awti, IRN, .TAXRATE, .AWTIND) quit:ER

		set BWA = BWA.roundDec(5)

		// AWT - Update Accrued Withholding Tax amount
		set dep.awt = dep.awt + BWA

		// If new TAXRATE is different generate a file maintenance entry in HIST
		if TAXRATE '= dep.awtr do {
			if 'NOHIST.exists() do dep.setAuditFlag(1)
			set dep.awtr = TAXRATE
			}
		}

	set UNCACR = ""
	
	// Calculate uncollected accruals
	if 'dep.ufindex.isNull(), dep.niao,dep.niao '= 3 do UNCACR(.dep, .UNCACR) quit:ER

	set RATE = IRN

	//  Update accrual buckets 
	do ACRBKT(.dep, .ACR, .UNCACR) quit:ER

	// Include Posting Date Accrual
	set dep.ipda = ACR - UNCACR
	set dep.negundaa = NEGUNDAA

	quit


INDEX(RecordDEP dep,	// Deposit account			/REF:R
      Number BALINT)	// Balance for interest calculations

	 // Calculate the interest index

	type public Number IRN
	type public Boolean ER, ICHNDFLG, NOHIST
	type public String ET

	type Date TEFD
	type String PAR()
	type Number RATE, RRATE, SRATE, URATE

	// Promotional Rate - Expiration Date
	if dep.trexd > %SystemDate quit
	
	/*
	If this is a low balance account and the account is positive,
	let DEPLBB (below) compute RATE. If the account is negative,
	define the balance based on the IRCB and continue.
	*/

	if dep.ircb = 5, dep.bal < 0 set BALINT = dep.bal
	else  if dep.ircb = 5 quit

	// Collected Balance
	if dep.ircb = 6, dep.balcol < 0 set BALINT = dep.balcol
	else  if dep.ircb = 6 quit

	// Int/Div Review Offset (Days)
	set TEFD = dep.ichld

	set PAR("IXLOAD") = 0
	set PAR("NOTSER") = 1
	set PAR("LIMIT") = 1

	do CTL^UINDX(.dep, .TEFD, BALINT, .PAR()) quit:ER

	// Rate has not been entered for effective date
	if TEFD.isNull() do Runtime.setErrSTBLER("INDEX", "INDEX7") quit

	type RecordINDEX index = Db.getRecord("INDEX", "INDEX=:dep.index")

	// If basis and the rate is not scheduled to change, don't change it.
	if +index.basrel = 0, 'ICHNDFLG quit

	/*
	 NOHIST is defined in routine ^UIC (Interest Posting) for
	 same day accrual option.
	*/

	if (dep.irn - RATE) = 0 set IRN = RATE quit

	if 'NOHIST.exists() do dep.setAuditFlag(1)
	
	set IRN = RATE
	set dep.irn = RATE

	quit


HIST(RecordDEP dep, String DI, String OV, String NV)

	type public Number CID

	type Number HSEQ

	// File Maintenance - Last Date
	set dep.fmld=%SystemDate

	set HSEQ=Db.nextVal("HIST","CID")

	type RecordHIST hist = Class.new("RecordHIST")

	set hist.cid = CID
	set hist.tseq = HSEQ
	set hist.tjd = %SystemDate
	set hist.tlo = %UserStation
	set hist.tcmt = CID_"[DEP]"_DI_":"_OV_":"_NV
	set hist.cdt = %CurrentDate
	set hist.time = %CurrentTime
	set hist.uid = %UserID

	do hist.save()

	quit


IM0INP(String IM, String IP, String IF, Date SN, Date SL, Number ANUFAC, Date ED)

	// Interest methods with first character "0"

	type public Boolean ER
	
	type Date NJD

	// Use override parameters if IP defined
	if 'IP.isNull() set IF = IP
	else  if IF.isNull() set IM = 1_IM.extract(2) quit

	// Define next date if not defined
	if SN.isNull() set SN = ED.nextFreqDate(IF, .ANUFAC) quit:ER

	// Define last date if not defined
	if SL.isNull() set SL = SN.nextFreqDate("-"_IF, .ANUFAC) quit:ER

	// Ensure that last date is before today
	for  quit:SL '> ED  set SN = SL, SL = SN.nextFreqDate("-"_IF) quit:ER

	// Ensure that next date is after last
	if SN '> SL set SN = SL.nextFreqDate(IF) quit:ER

	// Define annual factor if needed
	if 'ANUFAC set NJD = ED.nextFreqDate(IF, .ANUFAC) quit:ER

	quit


SAVCMP(RecordDEP dep, Boolean SAVDBDA)

	type public Number OLDCMP
	
	// Save compounding data for daily and continuous methods

	// Positive Accrued Int/Div
	if dep.iacm.extract(1) = 2 set dep.cmp = dep.posacr
	
	if 'SAVDBDA quit

	// Compounded Int/Div - 4 Days Ago
	set dep.cmp4 = dep.cmp3

	// Compounded Int/Div - 3 Days Ago
	set dep.cmp3 = dep.cmp2

	// Compounded Int/Div - 2 days Ago
	set dep.cmp2 = dep.cmp1

	// Compounded Int/Div - 2 days Ago
	if (OLDCMP + dep.daa) '= dep.posacr set dep.cmp1 = OLDCMP

	// Compounded Int/Div - 2 days Ago
	else  set dep.cmp1 = ""

	quit


private	CALCINP(RecordACN acn,		// Account			/REF:R
		Number IACM,		// Interest accrual method
		Number BALINT,		// Balance for interest calc
		Number IRN,		// Interest rate
		Number CMP,		// Compounding
		Number POSACR,		// Accrual
		Number ANUFAC,		// Annual factor
		Number DAYSPER,		// Days in period
		Number DENOM)		// Denominator

	// Accrue for one day

	// Custom calculation - overlay escrow IRN, IACM, etc. from loan 
	// account if BALINT on escrow account is negative
	do LNOVRIDE(.acn, BALINT, .IRN, .IACM, .ANUFAC, , , , .DAYSPER)

	//  Actual number days in period
	if IACM = "10" quit (BALINT + CMP) * IRN / 36000
	else  if IACM = "11" quit (BALINT + CMP) * IRN / DENOM
	else  if IACM = "13" quit (BALINT + CMP) * IRN / 36500
	
	// Standard number of days in period
	else  if IACM = "00" quit (BALINT + CMP) * IRN / ANUFAC / 100 / DAYSPER
	else  if IACM = "01" quit (BALINT + CMP) * IRN * 360 / ANUFAC / DENOM / DAYSPER
	else  if IACM = "03" quit (BALINT + CMP) * IRN * 360 / ANUFAC / 36500 / DAYSPER
	
	// Continuous compounding
	else  if IACM = "20" quit (BALINT + POSACR) * ($$EXP^%ZFUNC(IRN / 36000) - 1)
	else  if IACM = "21" quit (BALINT + POSACR) * ($$EXP^%ZFUNC(IRN / DENOM) - 1)
	else  if IACM = "23" quit (BALINT + POSACR) * ($$EXP^%ZFUNC(IRN / 36500) - 1)
	
	quit 0


UNCACR(RecordDEP dep, Number UNCACR)

	type public Boolean ER
	type public Number ANUFAC, DAYSPER, DENOM
		
	type Number BALAVL, USEOFUNC

	set BALAVL = dep.balavl
	if BALAVL '< 0 quit

	if dep.bal '< 0 set USEOFUNC = -BALAVL
	else  set USEOFUNC = dep.bal - BALAVL

	if USEOFUNC do { quit:ER

		type String PAR()
		type Number RATE, RRATE, SRATE, URATE

		set PAR("INDEX") = dep.ufindex
		set PAR("IXLOAD") = 0
		set PAR("NOTSER") = 1
		set PAR("IPMODE") = 0
		set PAR("ROUND") = 0

		do CTL^UINDX(.dep, %SystemDate, USEOFUNC, .PAR()) quit:ER

		set UNCACR = $$CALCINP(.dep, dep.iacm, USEOFUNC, RATE, dep.cmp, dep.posacr, ANUFAC, DAYSPER, DENOM)
		set UNCACR = UNCACR.roundDec(5)

		if dep.dumi, (UNCACR < dep.dumi) set UNCACR = dep.dumi
		}

	quit


ACRBKT(RecordDEP dep, Number ACR, Number UNCACR)

	type public Number ANUFAC, BAL, BALINT, DAYSPER, DENOM, NEGUNDAA, RATE

	type Number NACR

	set NACR = 0
	set NEGUNDAA = 0

	if ACR < 0, dep.negacrpo do {

		type Number NEGACR = -ACR

		// Set negacr to Init Day or Subs Day Overdraft min int if less than min.
		if dep.idomi, dep.odlim > BALINT, NEGACR < dep.idomi set NEGACR = dep.idomi
		else  if dep.sdomi, NEGACR < dep.sdomi set NEGACR = dep.sdomi

		// Accrue int for use of overdraft funds according to neg int opt (NIAO)
		if ('UNCACR) ! ((UNCACR) & ((dep.niao = 1) ! (dep.niao = 3) ! ((dep.niao = 4) & (UNCACR < NEGACR)))) do {

			// Auth O/D Limit Expiration Date
			if 'dep.odexp.isNull() do { quit

				// Beyond expiration date - all unauthorized
				if dep.odexp < %SystemDate set dep.negacrun = dep.negacrun - ACR quit

				// Within term
				if BAL < -dep.odlim do { quit

					type Number TRATE

					set TRATE = RATE

					if 'dep.index.isNull() do {
						type String PAR()
						type Number RATE, RRATE, SRATE, URATE

						type RecordINDEX index = Db.getRecord("INDEX", "INDEX=:dep.index")

						if index.indtyp '= "I" quit

						set PAR("INDEX") = dep.index
						set PAR("IXLOAD") = 0
						set PAR("NOTSER") = 0
						set PAR("IPMODE") = 0

						do CTL^UINDX(.dep, dep.ichld, -dep.odlim, .PAR())

						set TRATE = RATE
						}

					// Calculate authorized accrual
					set NACR = -$$CALCINP(.dep, dep.iacm, -dep.odlim, TRATE, dep.cmp, dep.posacr, ANUFAC, DAYSPER, DENOM)
					set NACR = NACR.roundDec(5)

					// Daily unauthorized accrual
					set NEGUNDAA = NEGACR - NACR

					// Accumulate Authorized Accrual
					set dep.negacr = dep.negacr + NACR

					// Accumulate unauthorized accrual
					set dep.negacrun = dep.negacrun + NEGUNDAA
					}

				set dep.negacr = dep.negacr - ACR
				}

			set dep.negacr = dep.negacr - ACR
			}

		// Accrue int. for use of uncoll. funds according to Neg. Int. Appl. Opt.
		set UNCACR = +UNCACR
		if (UNCACR '= 0) & ((dep.niao = 1) ! (dep.niao = 2) ! ((dep.niao = 4) & (UNCACR > NEGACR))) set dep.uncacr = dep.uncacr + UNCACR
		}
	else  do {
		set dep.posacr = dep.posacr + ACR
		if UNCACR set dep.uncacr = dep.uncacr + UNCACR
		}

	quit
	
	
LNOVRIDE(RecordACN acn,	// Account					/REF:R
	 Number PR,	// Principal Amount
         Number IR,	// Interest Rate (IRN)				/REF:RW
         String IM,	// Interest Method (IACM)			/REF:RW
         Number AF,	// Annual Factor (DIST1AF)			/NOREQ/REF:RW
         String IF,	// Interest Freq ([LN]DIST1FRE, [DEP]IPF)	/NOREQ/REF:RW
         String IP,	// Interest Period Frequency (ICPF)		/NOREQ/REF:RW
         Date SN,	// Next Sched Date ([LN]SCHND, [DEP]INP)	/NOREQ/REF:RW
	 Number DP)	// Days in Period				/NOREQ/REF:RW

	// Override deposit variables w/ loan variables for negative interest 
	// calculations on escrow accounts
	
	type public RecordLN ln
	type public Boolean ER
	type public Number CID
	
	type RecordDEP dep

	type Date SL

	if acn.grp '= "ESC" quit

	set dep = {RecordDEP}acn

	// No loan account tied to the escrow
	if dep.aref.isNull() quit
	
	// Escrow account with a non-negative principal - use IACM = 11
	if '(PR < 0) set IM = "11" quit
	
	if 'ln.exists() ! (ln.exists() & (ln.cid '= dep.aref)) set ln = Db.getRecord("LN", "CID=:dep.aref")
		
	set IR = ln.irn
	set IM = ln.iacm

	// Reset conditional variables
	set AF = dep.intaf
	set IF = dep.ipf
	set IP = dep.icpf
	set SN = dep.inp
	
	if 'IM.extract(1) do { quit:ER
		set SL = ""
		do IM0INP(.IM, IP, IF, SN, .SL, .AF, %SystemDate) quit:ER
		set DP = SN - SL
		}
	
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60479^60365^Pat Kelly^26782"	// Signature - LTD^TIME^USER^SIZE
