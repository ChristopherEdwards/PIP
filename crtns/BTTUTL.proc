BTTUTL		/*
	 Procedure ID:	BTTUTL - Accrual Utilities

	  Description:	This procedure definition contains utilities that are
        	        associated with the accrual process (batch definition
                	BTTDRV).

	  Orig Author:	Allan Mattson
	  Code Review:  Mark Spier
            Orig Date:	05/26/99


	----- Revision History -----------------------------------------------
	05/11/06 - RussellDS - CR21219
		   Add order by clause to nth and ver sections.
		   
		   Removed old revision history.

	------------------------------------------------------------------

	*/

	quit


INIT	// Initialize BTTACN table

	/*
	This subroutine is used to re-build BTTACN.  BTTACN is used by the
	accrual driver to pass an account range with an evenly distributed
	number of accounts to each thread.
	*/

	type Number beg,blk,buf,cnt,end,maxcid,seq,tot

	type ResultSet rscnt=Db.select("COUNT(CID)","ACN")
	if rscnt.next() set tot=rscnt.getCol(1)

	// Number of accounts to be processed per HTM message exchange
	set blk=$$blk(tot,.buf)

	// Delete table
	do Db.fastDelete("BTTACN")

	set maxcid=$$maxcid
	type Boolean QUIT=0
	set beg=0
	for seq=1:1:buf do { quit:QUIT

		if seq=buf set end=maxcid
		else  set end=$$nth(beg,blk,.cnt)

		type RecordBTTACN bttacn=Class.new("RecordBTTACN")
		set bttacn.seq=seq
		set bttacn.beg=beg
		set bttacn.end=end
		set bttacn.cnt=cnt
		do bttacn.bypassSave()

		// More buffers available, but not needed	SPG 02/22/02
		if end=maxcid set QUIT=1 quit
		
		// Reset beginning account for next sequence
		set beg=end
	}

	quit


private	RESET	// Re-set BTTACN

	/*
	This subroutine is used to re-distribute accounts in BTTACN based
	upon the number of accounts in the database.  As the size of the
	database increases, the number of accounts passed to each thread
	will be increased.

	Called by:  Batch definition BTTDRV
	*/

	type Number adj,beg,blk,buf,cnt,end,maxcid,num,seq,tot

	type ResultSet rs=Db.select("SEQ,BEG,END,CNT","BTTACN")

	set tot=0
	while rs.next() do {

		set seq=rs.getCol(1)
		set beg=rs.getCol(2)
		set end=rs.getCol(3)
		set cnt=rs.getCol(4)

		set tot=tot+cnt
		set buf(seq)=beg_"|"_end_"|"_cnt
	}

	// If the number of message buffers has changed, re-init BTTACN
	set blk=$$blk(tot,.buf) 
	if buf("").order(-1)'=buf do INIT quit

	// Delete table
	do Db.fastDelete("BTTACN")

	set maxcid=$$maxcid
	set (adj,beg)=0

	for seq=1:1 do {  quit:end=maxcid

		set end=$P(buf(seq),"|",2)
		set cnt=$P(buf(seq),"|",3)
		set adj=blk-cnt+adj

		if seq=buf set end=maxcid
		else  set end=$$nth(end,adj,.num)

		type RecordBTTACN bttacn=Class.new("RecordBTTACN")
		set bttacn.seq=seq
		set bttacn.beg=beg
		set bttacn.end=end
		set bttacn.cnt=cnt
		do bttacn.bypassSave()

		// Reset beginning account for next sequence
		set beg=end
	}
	quit


nth(cid,cnt,num)	//Get 'n'th prev/next account key

	/*
	ARGUMENTS:
	     . cid	Account number		/TYP=N/REQ/MECH=VAL
	     . cnt	'n'th account		/TYP=N/REQ/MECH=VAL
	     . num	Number of accts found	/TYP=N/REQ/MECH=VAL

			May be less than 'cnt' if at beginning/end
			of file.
	RETURNS:
	     $$		'n'th account number from 'cid'
			NULL = beginning/end of file
	*/

	type Public Number maxcid

	set num=0

	/*
	If the count is negative, return the 'n'th previous key.  This will
	have the effect of decreasing the account range.
	*/

	if cnt<0 do {
		type ResultSet rs=Db.select("CID","ACN","CID<:cid","CID DESC")
		if rs.isEmpty() set cid=0 quit
		while rs.next() do { quit:num'>cnt
			set cid=rs.getCol(1)
			set num=num-1
			}

	}

	/*
	If the count is positive, return the 'n'th next key.  This will
	have the effect of increasing the account range.
	*/

	else  do {
		type ResultSet rs=Db.select("CID","ACN","CID>:cid", "CID ASC")
		if rs.isEmpty() set cid=maxcid quit
		while rs.next() do { quit:num'<cnt
			set cid=rs.getCol(1)
			set num=num+1
			}
		}

	quit cid


blk(tot,buf)	// Calculate block size

	/*
	Calculate the number of accounts per message buffer each thread
	will need to process so that each thread will require no more
	than five message exchanges with the scheduler.

	ARGUMENTS:
	     . tot	Total accounts		/TYP=N/REQ/MECH=VAL
	     . buf	Number of buffers	/TYP=N/NOREQ/MECH=REF:W

			Each buffer reflects a range of accounts passed
			by the scheduler to a thread.  The buffer number
			is a pointer to the sequence number in BTTACN.
	*/
   
	type Number threads

	type RecordDBTBL33 dbtbl33=Db.getRecord("DBTBL33","%LIBS='SYSDEV',BCHID='BTTDRV'")

	set threads=dbtbl33.threads
	
	if +threads=0 do {
		type RecordCUVAR cuvar = Db.getRecord("CUVAR")
		
		set threads = cuvar.bttjob
	}
   
	set buf = threads * 5
	quit (tot \ buf) + 1


maxcid()

	type RecordDBTBL1D dbtbl=Db.getRecord("DBTBL1D","%LIBS=:%Library,FID='ACN',DI='CID'")
	type Number val=(10**dbtbl.len)-1

	quit val



ver	// Verify number of accounts within block

	/*
	This subroutine is used to verify the ranges of accounts that are
	stored in BTTACN.  It is used for testing/validation only.
	*/

	type Number beg,cid,cnt,end,i,maxcid,seq

	set maxcid=$$maxcid
	type ResultSet rs
	set rs=Db.select("SEQ,BEG,END,CNT","BTTACN", "", "SEQ ASC")
 
	while rs.next() do {
 
		set seq=rs.getCol(1)
		set beg=rs.getCol(2)
		set end=rs.getCol(3)
		set cnt=rs.getCol(4)

		if end="" set end=maxcid

		set cid=beg 
		type ResultSet rscnt=Db.select("COUNT(CID)","ACN","CID>:cid and CID<:end+1")
		if rscnt.next() set i=rscnt.getCol(1)
		//I18N=OFF

		write !
		write " seq=",seq
		write " beg=",beg
		write " end=",end
		write " cnt=",cnt
		write " act=",i

		//I18N=ON
	}
	
	quit

vSIG()	quit "60396^44350^Dan Russell^5290"	// Signature - LTD^TIME^USER^SIZE
