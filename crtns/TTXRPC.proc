TTXRPC	// Financial Transaction Remote procedure Call
	/*
	   ORIG:  MATTSON - 28 MAY 1991
	
	---- Revision History ------------------------------------------------
	
	01/09/07 -  VanithaK - CR 24810
		    Retrofit from ICGWeb01_Dev_Profile view for Profile Direct
		    Enhancements.
		    12/06/06 - SIGDAE - CR23919
	            Modified section POBS to build the POBS array
	            based on data within STBLTSO.
	            
	03/14/05 - SmithCD - 13782
		   . Fixed multiple/conflicting variable declarations within 
		     SPV, HISTN, CKREG, and MSC sections
		   . Restored SEQ variable to parameters passed to HISTN and 
		     CKREG sections
		   . Made all sections public, since they are called externally
		   . Modified to comply to current PSL standards
		   . Removed old revision history
	
	12/10/04 - Jeruchimc - 13228 
	           changed "Procedure to procedure" in comment at top.
	           Prevents compiler warning from recognizing procedure.
	           
	08/24/04 - RussellDS - CR11678
		   Fixed section CLOUT calls to QLF, PSI, and MSC -- were not
		   passing SEQ parameter.
		   
		   Cleaned up scope warnings.
	
	*/
	
	quit
	

public	CLOUT(RecordTTX ttx())
	/*
	   This client function is called at a PROFILE front-end
	   processor to format a financial transaction into a TSSP message,
	   expected at the host.  The function relies on already defined context,
	   held in the ttx and SPV arrays, to construct the new message.
	
	   INPUTS:
	
	           . BRCD - Branch Code where transaction is
	                    being processed
	                                  /TYP=N/TBL=[UTBLBRCD]/REQ
	
	           . SPV -  Supervisory Authorization array,
	                    SPV        /TYP=T
	
	           . TPD -  Teller Posting Date		/TYP=D/REQ

	   ARGUMENTS:

	           . ttx  -  Transaction object array  	/TYP=RecordTTX/REQ
	
	   RETURNS:
	
	           . REC -  Formatted transactions in
	                    financial transaction record
	                    structure.       		/TYP=T
	
	    PROFILE Financial Transaction Record
	
	    Pos  Name Req Description             Type      Max Len
	
	     1   BRCD    Y   Branch code             N         6
	     2   TPD     Y   Teller Posting date     D         5
	     3   ACN     Y   Account number  (CID)   N         12
	     4   ETC     Y   Transaction code        T         12
	     5   TAMT    Y   Transaction amount      $         14
	     6   TRC     Y   Client transaction #    N         12
	    *7   CRCD    N   Currency code info      T
	     8   EFD     N   Effective date          D         5
	     9   VDT     N   Value date              D         5
	   *10   SPV     N   Supervisor auth.        T
	   *11   QLF     N   Transaction qualifiers  T
	   *12   PSI     N   Payment system instr.   T
	   *13   MSC     N   Miscellaneous info.     T
	    14   TCMT    N   Transaction comment     T         40
	    15   HISTN N   Transaction Notes       T
	   *16   CKREG   N   Check Register Info     T
	    34   SYSBASE N   System Base Equiv.      N         12
	
	   * indicates complex fields containing one or more sub-fields
	*/

	catch vERROR {
		type String ET, RM
		
		set ET = vERROR.type
		if ET [ "%GTM-" do ZE^UTLERR quit
		set ET = ET_"-"_vERROR.thrownAt
		set RM = vERROR.description
		do ^UTLERR
		}
		
	type Public String %LOGID
		
	type Number CID, i, OCC, SEQ
	type String CHKTYP, CK(), CUSTCD, ETC, FTF, HISTN, MSC, msd
	type String POBS(,,), PSI, QLF, REC, TRAN, TREF, SPR, UTSO, XTSO

	//initialize POBS array
	do POBS(.POBS)
	//Check if context is still valid
	if %LOGID do context(.ttx(), %LOGID)

	set SEQ = ""
	for  set SEQ = ttx(SEQ).order() quit:SEQ.isNull()  do {
	
		type String FLD, ITC, XTSO
		
		set ETC = ttx(SEQ).etc
		type RecordTRN trn = Db.getRecord("TRN", "ETC")

		set ITC = ttx(SEQ).itc

		//Misc screen data
		set msd = ttx(SEQ).msd
		set (MSC,PSI,QLF)=""
	
		set FLD(1) = $$BRCD
		set FLD(2) = $$TPD
		set FLD(3) = ttx(SEQ).cid
		set FLD(4) = ttx(SEQ).etc
		set FLD(5) = ttx(SEQ).tamt

		// E/C or reversal - set amt positive
		if (ITC.extract(6) + ITC.extract(12)) set FLD(5) = $$TAMT^TRNUTL(FLD(5))

		set FLD(6) = ttx(SEQ).trc
		set CUSTCD = ttx(SEQ).custcd
		if trn.cls = "M" set CUSTCD=""
		set FLD(7) = $$CRCD(.ttx(),SEQ)
		set FLD(8) = ttx(SEQ).efd
		set FLD(9) = ttx(SEQ).vdt
		set OCC = ttx(SEQ).cc
		set CHKTYP = ttx(SEQ).chktyp

		//Treasury reference #
		set TREF = ttx(SEQ).tresref
		set UTSO = ttx(SEQ).tso
		set SPR = ttx(SEQ).spr

		do OUT^UTSO(.XTSO, UTSO)
		if UTSO.isNull() set XTSO=""

		//Supervisor authorizations
		set FLD(10) = $$SPV(.trn, .ttx(), SEQ, ttx(SEQ).cid)

		//Transaction qualifiers
		set FLD(11) = $$QLF(SEQ, .XTSO)

		//Payment system instructions
		set FLD(12) = $$PSI(SEQ, .XTSO)

		//Miscellaneous fields
		set FLD(13) = $$MSC(SEQ, .XTSO, msd)
		set FLD(14) = ttx(SEQ).tcmt

		//Transaction notes
		set FLD(15) = $$HISTN(SEQ, .HISTN)

		//Check register information
		set FLD(16) = $$CKREG(SEQ, .CK)

		//System base equivalent amount
		set FLD(17) = ttx(SEQ).sysbase
		for i = 17:-1:7 quit:'FLD(i).isNull()  kill FLD(i)

		//Build length-value record
		set REC(SEQ) = $$V2LV^MSG(.FLD)
		}

	quit $$V2LV^MSG(.REC)
	

public	context(RecordTTX ttx(), String %LOGID)

	/*
	Check if context is still valid
	
	   If the current token is not logged in the SIGNON file, create a new
	   change context message for posting date and branch code.
	*/

	type Public Number CRTMCP, ER
	type Public String RM

	type String par(), TOKEN
	
	set TOKEN = %LOGID.piece("|", 6)

	if 'TOKEN.isNull(), Db.isDefined("SIGNONT", "%UserID,TOKEN") quit

	set par(1) = $$V2LV^MSG(1)
	set par(1) = par(1)_$$V2LV^MSG("BRCD")_$$V2LV^MSG(ttx(1).brcd)
	set par(1) = par(1)_$$V2LV^MSG("TPD")_$$V2LV^MSG(ttx(1).tjd)
	set par(1) = par(1)_$$V2LV^MSG("CRTMCP")_$$V2LV^MSG(+CRTMCP.get())
	set ER = $$NMSP^PBSCLI(3, .RM, "", .par) quit:ER
	 
	type RecordSIGNONT signont = Class.new("RecordSIGNONT")	
	set signont.datetime = %CurrentDate        
	set signont.uid = %UserID
	set signont.token = TOKEN
	
	do signont.bypassSave()
	
	quit 
	

public	BRCD()	// Return the branch code value

	/*
	   This function will return a value for branch code, depending on
	   whether the teller is currently on-line or off-line, and if the
	   sequence is the first on the screen or not.  In on-line cases, the
	   teller sign-on will have established context on the server and there-
	   fore, BRCD and TPD can be omitted from the message.
	*/

	type Public Boolean %NET
	type Public Number BRCD,SEQ
	type Public String %LOGID

	type Number brcd
	type String TOKEN
	
	set brcd = ""

	if '%LOGID.get() set brcd = BRCD

	//Processing on client
	else  do {
		if SEQ > 1 quit 
		set brcd = BRCD quit:'%NET 
		set TOKEN = %LOGID.piece("|", 6)
		if 'TOKEN.isNull(), Db.isDefined("SIGNONT", "%UserID,TOKEN") set brcd = "" quit
		}
	
	quit brcd
	

public	TPD()	// Return the teller posting date value
	/*
	   This function will return a value for posting date, depending on
	   whether the teller is currently on-line or off-line, and if the
	   sequence is the first on the screen or not.  In on-line cases, the
	   teller sign-on will have established context on the server and there-
	   fore, BRCD and TPD can be omitted from the message.
	*/

	type Public Boolean %NET
	type Public Date TPD
	type Public Number SEQ
	type Public String %LOGID

	type Date tpd
	type String TOKEN
	
	if '%LOGID.get() set tpd = TPD
	else  set tpd = ""

	//Processing on client
	else  do {
		if SEQ > 1 quit
		set tpd = TPD quit:'%NET 
		set TOKEN = %LOGID.piece("|", 6)
		if 'TOKEN.isNull(), Db.isDefined("SIGNONT", "%UserID,TOKEN") set tpd = "" quit
		}
		
	quit tpd
	
	
public	CRCD(RecordTTX ttx(), Number SEQ)

	/*
	
	Multi-currency information
	
	   ARGUMENTS:
	
	. ttx 		Transaction object array		/TYP=RecordTTX/REQ

	. SEQ		Transaction object array sequence	/TYP=N/REQ
	
	   INPUTS:

	. CRCDBASE						/TYP=T
	*/
	
	type Public Boolean %MCP
	type Public String CRCDBASE, CUSTCD
	
	type String BASE, CRCD(), CRCDX, MULT, RATE, X

	if '%MCP quit $$LV2V^MSG("")
	
	//currency code
	set CRCD(1) = ttx(SEQ).crcd
	//exchange rate
	set CRCD(2) = ttx(SEQ).rate
	set CRCD(3) = $S(CRCDBASE.get()=CRCD(1):"", 'CRCDBASE.get().isNull():CRCDBASE, 1:%SystemCurrency)
	//multiply/divide indicator
	set CRCD(4) = ttx(SEQ).mult
	//customer code - used for getting rate
	set CRCD(5) = CUSTCD.get()
	//Base equivalency amount
	set CRCD(6) = ttx(SEQ).bseamt

	set X = ""
	for  set X = CRCD(X).order(-1) quit:X.isNull() ! ('CRCD(X).isNull())  if CRCD(X).isNull() kill CRCD(X)

	quit $$V2LV^MSG(.CRCD)
	
	
public	SPV(RecordTRN trn, RecordTTX ttx(), Number SEQ, Number TCID)

	/*	
	   ARGUMENTS:
		
	   . trn 		Transaction Code object 	/TYP=RecordTRN/REQ

	   . ttx 		Transaction object array	/TYP=RecordTTX/REQ
	
	   . SEQ		Transaction sequence number, as
	   			it exists in ttx 	 	/TYP=N/REQ
	
	   . TCID		Account number from the transaction
	                	sequence SEQ.			/TYP=N/REQ
	
	   RETURNS:
	
	         . zspv -  Supervisory authorization information
	                   for field 10 of financial transaction
	                   record format.
	*/
	
	type Public String PWD, SPV()
	
	if 'SPV(SEQ).data() quit ""
	if TCID.isNull() quit ""

	type Number CID, XSEQ
	type String ETC, GRP, OVR, TYP, UID, UCLS, ZSPV
	
	set (CID, OVR, TYP) = "" 
	set XSEQ = 1
	
	for  set CID = SPV(SEQ, CID).order() quit:CID.isNull()  do {
		// External Transaction Code
		set ETC = ttx(SEQ).etc

		// Transaction Group
		set GRP = trn.grp
		for  set OVR = SPV(SEQ, CID, OVR).order() quit:OVR.isNull()  do {
			for  set TYP = SPV(SEQ, CID, OVR, TYP).order() quit:TYP.isNull()  do {
				type String REST()
				set REST(1) = OVR_"_"_GRP_"_"_TYP
				set REST(2) = SPV(SEQ, CID, OVR, TYP).piece("|",1)
				set REST(3) = PWD.get()
				if CID '= TCID set REST(4) = CID
				set ZSPV(XSEQ) = $$V2LV^MSG(.REST) set XSEQ = XSEQ + 1
				}
			}
		}
	
	//return LV format
	quit $$V2LV^MSG(.ZSPV)
	

public	QLF(Number SEQ, String ZTSO)

	/*
	Transaction Qualifiers
	
	   ARGUMENTS:
	
	         . SEQ  - Transaction sequence number, as
	                  it exists in ttx			  	/TYP=N/REQ
	
	         . ZTSO - The existing TSO array, extracted out of
	                  the transaction array for
			  sequence SEQ.   				/TYP=T/REQ
			
	   RETURNS:
	
	         . zqlf - Transaction qualifier information to
	                  file into field 11 of financial transaction
	                  record format.   /TYP=T
	*/
	
	type Public String CHKTYP, OCC, PBK(), POBS(,,), TCK

	type String QLF, zqlf()
	
	set zqlf = ""
	
	set QLF = ""
	for  set QLF = ZTSO(QLF).order() quit:QLF.isNull()  do {
		if 'POBS("TSSP", "QLF", QLF).data() quit 
		set zqlf(QLF) = QLF_"#"_ZTSO(QLF)
		}
	
	// add any other qualifiers that are not already in TSO
	if 'CHKTYP.isNull() do {
		set zqlf("CHKTYP") = "CHKTYP#"_CHKTYP
		if TCK.exists() set zqlf("TCK") = "TCK#"_TCK
		}
	if PBK(SEQ).data() do {
		type Number PBKBAL
		set PBKBAL = PBK(SEQ)
		set zqlf("PBKBAL") = "PBKBAL#"_PBKBAL
		}
	
	//Override cost center
	if 'OCC.isNull() set zqlf("OCC") = "OCC#"_OCC
	
	if zqlf.data() > 1 quit $$V2LV^MSG(.zqlf())
	
	quit ""
	

public	PSI(Number SEQ, String ZTSO)

	/*
	
	Payment System Instructions
	
	   ARGUMENTS:
	
	            . SEQ  -  Transaction sequence number, as
	                      it exists in ttx			 	 /TYP=N/REQ
	
	
	   RETURNS:
	
	            . ZPSI -  Payment instructions to file into
	                      field 12 of financial transaction
	                      record format.				/TYP=T
	*/

	type Public String POBS(,,)

	type String PSI, ZPSI
	
	set (PSI, ZPSI)=""
	for  set PSI = ZTSO(PSI).order() quit:PSI.isNull()  do {
		if 'POBS("TSSP", "PSI", PSI).data() quit 
		set ZPSI(PSI) = PSI_"#"_ZTSO(PSI)
		}
	if ZPSI.data() > 1 quit $$V2LV^MSG(.ZPSI)
	
	quit ""
	
	
public	MSC(Number SEQ, String ZTSO, String MSD)

	/*
	Miscellaneous information field
	
	   ARGUMENTS:
	
		.  SEQ 	Transaction sequence number, as
			it exists in ttx			/TYP=N/REQ

	        . ZTSO	TSO array, pulled out of
	        	ttx array for sequence SEQ 		/TYP=T
	
	        . MSD	Misc screen data			/TYP=T
	
	   RETURNS:
	
	        . ZMSC	Miscellaneous transaction information
	                to file into field 13 of financial
	                transaction record format.		/TYP=T
	*/
	
	type Public String POBS(,,), SPR, TREF
	
	type String MSC, ZMSC
	
	set (MSC, ZMSC) = ""
	for  set MSC = ZTSO(MSC).order() quit:MSC.isNull()  do {
		if 'POBS("TSSP", "MSC", MSC).data(), "Zz"'[MSC.extract() quit 
		set ZMSC(MSC) = MSC_"#"_ZTSO(MSC)
		}
	
	// add any other miscellaneous fields that are not in TSO
	if 'MSD.get().isNull() set ZMSC("MSD") = "MSD#"_MSD
	if 'TREF.get().isNull() set ZMSC("TREF") = "TREF#"_TREF
	if 'SPR.get().isNull() set ZMSC("SPR") = "SPR#"_SPR
	
	if ZMSC.data() > 1 quit $$V2LV^MSG(.ZMSC)
	
	quit ""
	
	
public	HISTN(Number SEQ, String HISTN())

	/*
	
	Transaction Notes
	
	ARGUMENTS:
	
		.  SEQ  - Transaction sequence number, as
			it exists in ttx 				/TYP=N/REQ
	
		. HISTN - Transaction Notes, keyed by
			sequence 	 				/TYP=T/NOREQ/MECH=REFARRAY
	
	RETURNS:
	   
		. STRING   - History notes string
	*/
	
	if 'HISTN(SEQ).data() quit ""
	
	type Number XSEQ
	type String STRING
	
	set (XSEQ, STRING)=""
	for  set XSEQ = HISTN(SEQ,XSEQ).order() quit:XSEQ.isNull()  do {
		set STRING = STRING.get()_HISTN(SEQ,XSEQ)_$C(13,10)
		}

	quit STRING
	

public	CKREG(Number SEQ, String CK())	// Check Register Information

	/*
	   ARGUMENTS:
	
		.  SEQ - Transaction sequence number, as
	                     it exists in ttx  			/TYP=N/REQ
	
		.  CK  - CK array, pulled out of
	                     TR array for sequence SEQ 		/TYP=T
	
	   RETURNS:
	
	            . ZCHKREG - Check register information
	                     to file into field 16 of financial
	                     transaction record format. /TYP=T
	*/

	type Number CKREGLEN, I
	type String CKREG, XCK()
	
	set XCK = ""
	
	if 'CK(SEQ).data() quit ""
	
	set CKREG = CK(SEQ)
	set CKREGLEN = CKREG.length("^")
	for I = 1:1:CKREGLEN set XCK(I) = CKREG.piece("^", I)
	
	if XCK.data() > 1 quit $$V2LV^MSG(.XCK())
	
	quit ""
	
	
public	POBS(String POBS(,,))	// Private; Build complex fields array

	/*
	  Transaction Qualifiers
	*/
	
	type String QLF, TSO
	
	set (QLF, TSO) = ""
	type ResultSet rs = Db.select("KEY,QTYP,DESC","STBLTSO")
	while rs.next() do {
		set TSO = rs.getCol("KEY")
		set QLF = rs.getCol("QTYP")
		if 'QLF.isNull() set POBS("TSSP", QLF, TSO) = rs.getCol("DESC") 
	}	
	
	quit

vSIG()	quit "60645^64383^Vanitha Krishnasamy^13860"	// Signature - LTD^TIME^USER^SIZE
