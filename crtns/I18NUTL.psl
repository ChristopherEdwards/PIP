I18NUTL	// Utility Programs for I18N Phase I 
	/*
	 ORIG:  	PRAKASHJ - 11/28/05
	 DESC:		This program contains utility function for I18N Phase I.
	 
	 CALLED BY:	I18N*
	
	---Revision History-------------------------------------------
	
	07/25/06 - Pete Chenard - CR 22385
		   Removed unsupported parameter from .char() method call
	
	11/29/05 - PRAKASHJ - CR16921
		   Converted to PSL. 
	
	--------------------------------------------------------------
	*/

	quit
	
public POS(String lib,String dbtbltype,String file,String pos) // Build position-table of V4X dataitems 
	
	type Number p
	
	kill pos
	
	// Collating thru filedefinition and set pos array if v4xflag is set
	type ResultSet rs=Db.select("DI,VAL4EXT,POS","DBTBL1D","%LIBS='SYSDEV' AND FID=:file")
	while rs.next() do {
		if rs.getCol("VAL4EXT") do {
			set p=rs.getCol("POS")
			set pos($S(p="":1,1:p))=file_"|"_rs.getCol("DI")
			}
		}

	quit
	
VALKEY(String key) // Return of key value
	
	type Number n
	type String x

	set n=1,x=""
	
	// Converts list of variable names to list of variable values
	for  quit:key.piece(",",n)=""  set x=x_$S(n=1:"",1:",")_@key.piece(",",n),n=n+1 

	quit x 
	
public BLDMTB // Build tables for I18NMTRA Screen
	
	type public Number WORD
	type public String EXTDT,HP,NP,OHP,OPDMY,PTYPDSC,SRC()

	type Number DBTYP,DPCNT,DPTOT,DT,PK,PTCNT
	type String DBNAM,DBTDSC,DP(),OP(),PTBL(),PTYP,UXFI,UXDI

	set DT="",DPTOT=0,DPCNT=1
	
	// Collate thru detail records and update I18NMTRA Screen tables
	for  set DT=SRC(DT).order() quit:DT=""  do {
		set DPTOT=DPTOT+1
		set SRC=SRC(DT)
		type RecordI18NEXTD i18nextd=Db.getRecord("I18NEXTD","EXTDT=:EXTDT,NORMPHR=:NP,GLOBREF=:SRC",1)
		set OP(DPTOT)=i18nextd.origphr
		set DBTYP=i18nextd.dbtyp
		set DP(DPTOT).piece("|",1)=$S(i18nextd.targphr'="":i18nextd.targphr,1:OP(DPTOT)) 	
		set DP(DPTOT).piece("|",2)=i18nextd.ptype
		set UXFI=i18nextd.uxfi
		set UXDI=i18nextd.uxdi
		if DBTYP=99 set DBNAM=i18nextd.uxfi
		if DBTYP'=99 set DBNAM=(SRC.piece(",",3)).translate(")","") 
		set DBTDSC=$S(DBTYP=1:"File",DBTYP=2:"Screen",DBTYP=5:"Report",DBTYP=99:"Table",1:"General")
		set PTBL=DBTDSC_":"_DBNAM_" ["_UXFI_"]"_UXDI
		set PTBL(DPTOT)=PTBL
		}
	
	// Update I18NMTRA Screen variables if detail records
	if '(WORD),(SRC.exists()) do {
		set OP=OP(DPCNT),DP=DP(DPCNT).piece("|",1)
		set PK="",PK=PTBL(PK).order(),PTBL=PTBL(PK)
		set PTYP=DP(DPCNT).piece("|",2)
		type RecordSTBLI18NPT i18npt=Db.getRecord("STBLI18NPT","PTYPE=:PTYP",1)
		set PTYPDSC=i18npt.desc
		}

 	type RecordI18NEXTH i18nexth=Db.getRecord("I18NEXTH","EXTDT=:EXTDT,NORMPHR=:NP",1)
	
	// Update I18NMTRA Screen variables if not detail records
	if (WORD)!('SRC.exists()) do {
		set OP=" ",DP=" ",PTBL=" ",PTYP=10,PTYPDSC=" ",OPDMY=" "
		set PTCNT=i18nexth.ptcnts,DPTOT=PTCNT.piece(",",10)
		}

	// Set up translation test
	set HP=$S(i18nexth.targphr'="":i18nexth.targphr,1:NP),OHP=HP

	quit

	
public GETPHR(String phrobj,String phrase,String phrtab,Number tabcnt) // Browse the MLD for matching phrases
		
	type Number pref,prefok
	type String idx2
	
	set idx2=""
	set tabcnt=0
	set prefok=0
	
	// Get subscripts for second index in phrasefile (target/source) 
	if phrobj="S" do {
		type ResultSet rs=Db.select("TARGPHR,PREFPHR","I18NMLD","SRCPHR=:phrase","TARGPHR")
		while rs.next() do {
			set idx2=rs.getCol("TARGPHR")
			set pref=rs.getCol("PREFPHR")
			if pref set phrtab=idx2,prefok=1
			set tabcnt=tabcnt+1
			set phrtab(idx2)=$S(pref:"*",1:"")
			}
		}

	if phrobj="S" do {
		type ResultSet rs1=Db.select("SRCPHR","I18NMLDX","TARGPHR=:phrase")
		while rs1.next() do {
			set idx2=rs1.getCol("SRCPHR")
			set pref=0
			set tabcnt=tabcnt+1
			set phrtab(idx2)=""
			}
		}

	do phrOK

	quit phrtab.get()
	
phrOK	// Now we have all translations in phrtab("...")+preftrans in phrtab

	type public Number prefok,tabcnt
	type public String phrobj,phrase,phrtab
		
	if tabcnt,'prefok do {
		if phrobj="S" do {
			type ResultSet rs=Db.select("TARGPHR","I18NMLD","SRCPHR=:phrase","TARGPHR")
			if rs.next() set phrtab=rs.getCol("TARGPHR")
			}
		if phrobj="T" do {
			type ResultSet rs1=Db.select("SRCPHR","I18NMLDX","TARGPHR=:phrase","SRCPHR")
			if rs1.next() set phrtab=rs1.getCol("SRCPHR")
			}
		}

	quit
	
public TRANEXT(String extdt,String phr,String trans) //
	/*	The phrase must exist in MLD.  MLD will only be
		used of one translation exists for the source
		phrase		
	*/

	set trans=""

	if (phr.get()).isNull() quit
	if (extdt.get()).isNull() quit

	type RecordI18NEXTH i18nexth=Db.getRecord("I18NEXTH","EXTDT=:extdt,NORMPHR=:phr",1)
	set trans=i18nexth.targphr
	if trans.isNull() do perfect1 quit

	type RecordI18NMLD i18nmld=Db.getRecord("I18NMLD","SRCPHR=:phr,TARGPHR=:trans")
	if 'i18nmld.getMode() set trans=""
	if trans.isNull() do perfect1

	quit
	
perfect1 // Find existing MLD entry, must have only one translation
	
	type public String phr,trans

	type Number cnt

	if 'trans.isNull() quit
	
	set trans=$$GETPHR("S",phr,,.cnt)
	if cnt'=1 set trans=""

	quit
	
public TRANSLATE(Number tmet,String phr,String trans)	// Translate with correct method 
	
	type Number twOK
	type String wtab1,wtab2,word,tw
	
	set trans="",word="",twOK=0
 
	if tmet=0 do perfect quit
	if tmet=1 do bestfit quit
	if tmet=2 do perfect,bestfit quit
	if tmet=3 do bestfit,perfect

	quit
	
perfect // Perfect Match
	
	type public String phr,trans
	
	if 'trans.isNull() quit
	
	set trans=$$GETPHR("S",phr)
	
	quit
	
bestfit //Best fit pr. word
	
	type public String phr,trans

	type String phrbar,pw()

	if 'trans.isNull() quit

	set phrbar=phr.translate(" ","|")
	do PHRSPLIT(phrbar,.pw())
	do PHRMERG(phrbar,.trans,.pw())
	
	quit
	
	
GETSRC(String src,String piece) //
	/*	Return record as defined by src(global ref)
		piece is optional, if include the return contains only the
		field the piece refers to for the given src(global ref)
	
		This routine uses the src to build a MUMPS string, then
		executes it
	
		Example: if src=^DBTBL(SYSDEV,1,FILE,9,FIELD), then gs
		is built to: S y=$D(^DBTBL("SYSDEV",1,"FILE",9,"FIELD")
	*/

	type Number c,i
	type String gs,k,x,y
	
	set gs="S y=$G("_src.piece("(",1)_"("
	set k=(src.piece("(",2)).extract(1,(src.piece("(",2)).length()-1)
	set i=1,x="",y="",c=0
	
	// Loop thru variable level of keys
	for  set x=k.piece(",",i) quit:x=""  do {
		if (x.extract(1)=""""),(x.extract(x.length())="""") set x=""""_x_""""
		if 'c set c=(x["[") 
		if c do {
			if 'y.isNull() set y=y_"," 
			set c=(x'["]")
			if ('c),(x["""") set x=x.piece("]",1)_"]"""_x.piece("]",2)_""""
			set y=y_x
			if 'c set x=y
			}
		if 'c set gs=gs_$S(i=1:"",1:",")_$S(x?.N:"",1:"""")_x_$S(x?.N:"",1:"""")
		set i=i+1  
		}

	// Include some ending parens to gs
	set gs=gs_"))"
	
	#ACCEPT CR=unknown; PGM=PMC; DATE=2006-07-25; GROUP=XECUTE
	xecute gs
	
	// Return record
	if 'piece.exists() quit y

	// Return field only
	if piece.exists() quit y.piece("|",piece)

	quit	
	
public SETSRC(String src,String p,String data,Number dbtyp,String uxfi,String uxdi,Number tsid,String origphr,Number unrep) //
	/*	Replaces back into PROFILE the Translated Phrase to the same
		location as the original phrase
		writes logfile ^I18NLOG
		returns 1 for success, 0 for failure
	*/

	type public Number subs
	type public String gs
	
	type Number i,maxlen,q,os,ox,oy,run,z
	type String c,n,op,p1n,k,x,y

	// set to replace if not included
	if 'unrep.exists() set unrep=0

	set q=1
	
	// Get original content of src
	set n=$$GETSRC(src)
	// First piece of screen prompt record
	set os=n.piece("|",1)
	// y coordinate on screen (used only if scn phr)
	set oy=os\1000
	// x coordinate on screen (used only if scn phr)
	set ox=(os+0)#1000
	// original phrase before translation
	set op=n.piece("|",p)
	if uxfi="DUMMY" set op=$$GETPRMT^I18NPRMT(op)

	// Quit if original=translated
	if op=data do { quit 0
		do PRINTLOG(0,src,p,data,op,uxfi,uxdi,tsid)
		}
	
	// Test for global reference
	// Nothing defined by src
	if n.isNull() do { quit 0
		do PRINTLOG(1,src,p,data,op,uxfi,uxdi,tsid)
		}
	
	// Test to make sure original source has not changed
	if (origphr.get()),(unrep'=1) do {
		if origphr'=op do {
			do PRINTLOG(10,src,p,op,origphr,uxfi,uxdi,tsid)
			}
		}
	
	// Test for length
	// First, get maxlen of phrase to be replaced
	set maxlen=$$GETMAX(src,dbtyp,uxfi,uxdi)
	if (data.exists()>maxlen),(uxfi'="DUMMY") do { quit 0
		do PRINTLOG(2,src,p,data,op,uxfi,uxdi,tsid)
		}
	
	// Screen/Report translated
	if ((dbtyp=2)!(dbtyp=5)),(uxfi'="DUMMY") do {
		// if translated phrase>org phrase
		if (data.length()>op.length()) do {
			do PRINTLOG(11,src,p,data,op,uxfi,uxdi,tsid)
			set z=ox+(op.length()-data.length()) if z<1 set z=1
			set x=oy*(1000+z)
			set p1n=n.piece("|",1)
			// reset xy coordinates
			set p1n.piece("*",1)=$S(x>0:x,1:1)
			if (ox)!(oy) set n.piece("|",1)=p1n,n.piece("|",3)=data.length()
			}
		// if translated phrase<org
		if (data.length()<op.length()) do {
			set z=ox+(op.length()-data.length()) if ox=1,dbtyp=5 set z=1
			set p1n=n.piece("|",1)
			// reset xy coordinates
			set p1n.piece("*",1)=oy*(1000+z)
			if (ox)!(oy) set n.piece("|",1)=p1n,n.piece("|",3)=data.length()
			}
		}
	
	// Not Screen/Report translated
	if (dbtyp'=2),(dbtyp'=5) do {
		// if translated phrase>org phrase
		if (data.length()>op.length()) do {
			do PRINTLOG(11,src,p,data,op,uxfi,uxdi,tsid) 
			}
		}
	
	// For phrases from STBLPROMPT, add into string
	if uxfi="STBLPROMPT" set data=$$getdes^I18NNRM(op,data)
	if uxfi="DUMMY" set data=$$SETPRMT^I18NPRMT(n,data)
	
	// Build UX array for DBSFILER  --  Do not call DBSFILER - set globally
	set n.piece("|",p)=data
	
	// build execution string for variable length src
	set gs=src.piece("(",1)_"("
	set k=(src.piece("(",2)).extract(1,(src.piece("(",2)).length()-1)
	
	set i=1,subs=1,x="",run=0,z=""
	for  set x=k.piece(",",i) quit:x=""  do {
		if x.extract()="""" set run=2
		if ('run),(x["[") set run=1
		set z=z_$S(z'="":",",1:"")_x
		if (run=2),(x.extract(x.length()))="""" set run=0,z=z.extract(2,z.length()-1)
		if (run=1),(x["]") set run=0
		if 'run do {
			set y="i18n"_subs
			set @y=z,gs=gs_$S(subs=1:"",1:",")_y
			set z="",subs=subs+1
			}
		set i=i+1
		}
	
	set gs=gs_")"
	if q set @gs=n
	
	if q do PRINTLOG(99,src,p,data,op,uxfi,uxdi,tsid)
	
	quit 1
	
PRINTLOG(Number en,String src,String p,String tphr,String ophr,String uxfi,String uxdi,Number tsid) 
	
	type Number dead,stat
	type String ef,repdt,reptim
	
	// default ef to generic error
	set dead=1,ef="Unknown Error"
	
	// Errors
	if en=0 set stat=0,ef="Phrase already replaced"
	if en=1 set stat=0,ef="Global reference does not exist"
	if en=2 set stat=0,ef="Translated phrase longer than system maximum"
	
	// Warnings
	if en=10 set stat=1,ef="Orignal phrase changed since extract"
	if en=11 set stat=1,ef="Translated phrase longer than original"
	
	// Total Success
	if en=99 set stat=2,ef="Replaced"
	
	// Write out log message
	set repdt=%CurrentDate
	set reptim=%CurrentTime
	if p="" set p=1
	
	type RecordI18NLOG i18nlog=Db.getRecord("I18NLOG","TSID=:tsid,REPDT=:repdt,REPTIM=:reptim,SRC=:src,PIECE=:p,EN=:en",1)
	set i18nlog.status=stat
	set i18nlog.em=ef
	set i18nlog.tphr=tphr
	set i18nlog.ophr=ophr
	set i18nlog.uxfi=uxfi
	set i18nlog.uxdi=uxdi
	do i18nlog.save()
	quit
 	
GETMAX(String src,Number dbtyp,String uxfi,String uxdi) //
	/*
	 Return maximum acceptable length of phrase to
	 be replaced. The max length depends on the dbtyp.
	 For a screen or report, the maximum length of a 
	 phrase is the amount of room to the left of the
	 prompt until the prev field or beginning of line.
	 For a datafile, the max length is as described in the
	 field description in DBTBL1D.
	*/

	type public Boolean ER

	type Number col,fnum,len,maxlen,pcol,pfnum,prow,row
	type String data,ddexpr,ooepos,pdata,psrc

	set maxlen=99	// default max setting
	
	if 'src.get() set src=""
	if 'dbtyp.get() set dbtyp=""
	if 'uxdi.get() set uxdi=""
	if 'uxfi.get() set uxfi=""
	
	/*
	 This is the screen/report logic required for OOE
	 The maximum length for the prompt phrase is figured by taking
	 the current starting position (x,y coordinates) of the prompt phrase
	 then look back to the previous field starting position, adding the
	 length of the prev field to get an ending position of the previous
	 field, then finding the difference between the ending postion of the
	 previous field and the starting position of the current prompt field.
	 This result is added to the length of the current prompt to get a 
	 maximum length
	*/

	if (dbtyp=2)!(dbtyp=5) do { quit maxlen	
		// if screen or report do logic set up current variables and quit with max length
		set fnum=+src.piece(",",4)
		set data=$$GETSRC(src)
		set ooepos=+data.piece("|",1)
		set col=ooepos.extract(ooepos.length()-2,ooepos.length())
		set row=ooepos.extract(1,ooepos.length()-3)
		// set up previous variables
		if fnum<1 quit
		if fnum=1 do { quit
			set maxlen=col-1+(data.piece("|",11)).length()
			}
		if fnum>1 set pfnum=fnum-1 do {
			set psrc=src
			set psrc.piece(",",4)=pfnum_")"
			set pdata=$$GETSRC(psrc)
			set ooepos=+pdata.piece("|",1)
			set pcol=ooepos.extract(ooepos.length()-2,ooepos.length())
			set prow=ooepos.extract(1,ooepos.length()-3)
			}
		if prow=row do {
			set len=pdata.piece("|",3)
			if len'="" set pcol=pcol+len+1
			if len="" set pcol=pcol+(pdata.piece("|",11)).length()+1
			set maxlen=col-pcol+(data.piece("|",11)).length()
			}
		if prow'=row set maxlen=col-1+(data.piece("|",11)).length()
		}

	/*
	 The maximum length of the field is calculated by looking up the 
	 the field in the data dictionary with the uxid and uxfi names
	*/
	if (dbtyp=1)!(dbtyp=99) do { quit maxlen
		// set up expression for DBSDD
		set ddexpr="SYSDEV."_uxfi_"."_uxdi
		set len=($$DI^DBSDD(ddexpr)).piece("|",2)
		if ER=0 set maxlen=len
		}

	quit maxlen
	
public TESTSEL(RecordI18NTS2 i18nts2,Date extdt,String np,String src,RecordI18NEXTD i18nextd) //
	
	/* We only test on Detailed Phrase, because the normalised phrase
	   will automatic follow with the use of EXTkey2(NORMPHR)
	*/

	type Number dbtyp,selok
	type String dbnam,sel,x
	
	set selok=1
	
	if (src=0) do tstnrm(.i18nts2,.i18nextd) quit
	 
	// test selection criteria 1 - DBTBL type 
	set sel=i18nts2.seldbtbl
	if sel'="*" do { quit:'selok 0
		set selok=(sel=i18nextd.dbtyp)
		}
	
	// test selection criteria 2 -  name filter
	set sel=i18nts2.selnmsk		// DBTBL Name filter
	if sel'="*" do { quit:'selok 0
		if i18nextd.dbtyp'=99 do {
			set x=(src.get()).piece("(",2)
			set x=(x.get()).piece(")")
			set x=(x.get()).piece(",",3)
			}
		if i18nextd.dbtyp=99 set x=i18nextd.uxfi
		set selok=$$match(x,sel)
		}
	
	// test selection criteria 3 - Phrase filter ; Testing on original phrase
	set sel=i18nts2.selpmsk
	if sel'="*" do { quit:'selok 0  
		set x=np.get()
		set selok=$$match(x,sel)
		}
	
	// test selection criteria 4 - Phrase Type 
	set sel=i18nts2.selptype
	if sel'="*" do { quit:'selok 0  
		set selok=(sel=i18nextd.ptype)
		}
	
	// test selection criteria 6 - Subsystem 
	set sel=i18nts2.selsubsys
	if sel="" set sel="*"
	if sel'="*" do { quit:'selok 0
		if i18nextd.dbtyp=99 do {
			set dbtyp=99,dbnam=i18nextd.uxfi
			if dbnam="STBLPROMPT" set dbnam="U_"_(src.piece(",",2)).piece(")",1)
			if dbnam="STBLMSG" set dbnam="M_"_(src.piece(",",2)).piece(")",1)
			if dbnam="STBLMBAR" set dbnam="B_"_(src.piece(",",2)).piece(")",1)
			if dbnam="SCATBL" set dbtyp=4,dbnam=(src.piece(",",2)).piece(")",1)
			if dbnam="SCATBL0" set dbtyp=3,dbnam=(src.piece(",",2)).piece(")",1)
			}
		if i18nextd.dbtyp'=99 set dbtyp=src.piece(",",2),dbnam=src.piece(",",3)
		set x="",selok=0	
		type RecordI18NMOD i18nmod=Db.getRecord("I18NMOD","MOD=:sel,ITEM=:dbtyp,NAME=:dbnam",1)
		set selok=i18nmod.getMode()
		}
	
	// test selection criteria 7 - Translation Status
	set sel=i18nts2.seltrnstat2
	if sel'="*" do { quit:'selok 0
		set selok=(sel=i18nextd.ttype)
		}

	// No test failed, phrase is according to selection criterias
	quit 1		
	
tstnrm(RecordI18NTS2 i18nts2,RecordI18NEXTD i18nextd) // test Translation Status

	type public Number selok
	type public String np,sel

	type String x

	set sel=i18nts2.seltrnstat
	if sel'="*" do { quit:'selok 0
		set selok=(sel=i18nextd.trasdt)  
		}
	
	// test Phrase filter 		
	set sel=i18nts2.selpmsk
	if sel'="*" do { quit:'selok 0  
		set x=np.get()
		set selok=$$match(x,sel)
		}

	// No test failed so phrase is according to selection criterias
	quit 1	
	
match(String str,String msk) // String is according to mask definition 

	type String hit,x

	if msk["*" do {
		set x=msk.piece("*")
		set hit=(str.extract(1,x.length())=x)
		}
	if msk'["*" set hit=(str=msk)

	quit hit
	
public GETKEY(RecordI18NTSETN i18ntsn,Date extdt,String np,String srctab) // Get NORMalised phrase key + detail 

	type Number i,ts,tsseqN
	
	set extdt=i18ntsn.extkey1n
	set np=i18ntsn.extkey2n
	set ts=i18ntsn.tsid
	set tsseqN=i18ntsn.nseq
	
	set i=1
	type ResultSet rs=Db.select("EXTKEY3","I18NTSETD","TSID=:ts AND NSEQ=:tsseqN")
	while rs.next() do {
		set srctab(i)=rs.getCol("EXTKEY3")
		set i=i+1
		}
	
	quit

LOGOPN(String n)	// Open I18N log Utility
	
       type String d,f,s
       type public IO ioil8nlg
       
       set s=CUVAR.SPLDIR
       set d=%CurrentDate.toString("MMDDYEAR")

       if 's.isNull() set f=s_n_d_".LOG"
       else  do {
       		set s=$$CDIR^%TRNLNM
		set f=s_n_d_".LOG" 
       		}
       
       set ioil8nlg.fileName=f
       set ioil8nlg.openParams="NEWV"
       catch ioxcpt {
              if ioxcpt'["%PSL-E-IO" throw ioxcpt
              write "Open failed: ", ioxcpt.type, !
              quit 0
       }

       do ioil8nlg.open()
       quit 1

LOGWRT(String r)	// Write I18N log record Utility

       type public Number %i18nlog
       type IO ioil8nlg=Class.new("IO")
       if %i18nlog.isNull() set %i18nlog=$$LOGOPN("I18NREP")
       if %i18nlog'=0 do {
              set r=r_13.char()_10.char()
              do ioil8nlg.write(r)
              }
       quit   

LOGCLS(IO f) //Close I18N log Utility
	
	do f.close()                                       
	quit
	
	
XFKEY(String phrobj) // Invoke Interactiv MLD Utility 
	
	type public Number v4x
	type String %fkey,I(),idx3,idx5,RM

	set %fkey=""
	set idx3=""
	set idx5=""

	if (I(2).get()).piece("]",2)'=""  quit:'v4x  do {
		set idx3=((I(2).get()).piece("]",1)).piece("[",2)
		if idx3="*" set v4x=1
		set idx5=(I(2).get()).piece("]",2)
		type RecordDBTBL1D dbtbl1d=Db.getRecord("DBTBL1D","%LIBS=""SYSDEV"",,FID=:idx3,,DI=:idx5")
		if 'dbtbl1d.val4ext set RM=$$^MSG("DQ334")
		}
	//do ^I18NCRT(phrobj,.X,idx3,idx5)
	quit
	
LOADFKEY	// load custom Function keys into PROFILE variables 
		// these settings last as long as the user is signed onto PROFILE

	type public String %cmmd(),%fkey()
	
	// attach F9 to ZTST variable
	set %fkey("[20~")="ZTST"
	// attach F10 to ZTTS variable
	set %fkey("[21~")="ZTTS"
	// f9 hit and calls mld
	set %cmmd("ZTST")="D XFKEY^I18NUTL(""S"")"
	// f10 hit and calls mld
	set %cmmd("ZTTS")="D XFKEY^I18NUTL(""T"")"

	quit
	
public TIME(Number sec) //This takes the number of seconds and returns the hours:minutes:sec

	type Number hhh,mm,ss
	
	// number of hours
	set hhh=sec\3600
	// get remaining seconds after hours
	set sec=sec-(hhh*3600)
	// number of minutes
	set mm=sec\60
	// get remaining seconds after hours and minutes
	set sec=sec-(mm*60)
	set ss=sec
	
	// Return with formatted hhh:mm:ss
	quit hhh_":"_(mm+100).extract(2,3)_":"_(ss+100).extract(2,3)			
	
PHRSPLIT(String phrbar,String pw())	// Splitt incoming phrase into array 

	type Number e,i,wcnt
	type String osword,phrpar,phrparn,tphrpar,tw
	
	if (phrbar.get()).isNull() quit
	
	// Cre arr pw(word) for each word in original source phrase
	for i=1:1:phrbar.length("|") do {
		set osword=phrbar.piece("|",i) quit:osword=""
		// get translated word frm MLD
		set tw=$$GETPHR("S",osword)
		if tw.isNull() quit
		set pw(osword)=i_"|"_i_"|"_tw
		quit
		}
	
	/*Add parital phrases to pw array for best fitting a partial
	 phrase is a combination of several words that are then
	 looked up in the MLD for a prior translation
	
	 For Example:
		The org src phr = "Word1 Word2 Word3"
		Two partial phrases would be generated for MLD partial lookup
		1.	"Word1 Word2"
		2.	"Word2 Word3"
	*/
	
	// set wcnt to number of words in org src phr
	set wcnt=phrbar.length("|")
	for i=1:1:wcnt do {
		for e=i+1:1:wcnt do {
			set phrpar=phrbar.piece("|",i,e)
			if phrpar=phrbar quit
			set phrparn=phrpar.translate("|"," ")
			// find trans in MLD
			set tphrpar=$$GETPHR("S",phrparn)
			if 'tphrpar.isNull() set pw(phrpar)=i_"|"_e_"|"_tphrpar
			quit
			}
		quit
		}

	quit
	
PHRMERG(String phrbar,String trans,String pw()) // Merge array pw() to one phrase (opposite of PHRSPLIT)

	type Number getout,i
	type String arrdat,mark(),parphr,prev,tparphr,transnew,tword,word
	
	if (pw("").order()).isNull() set trans="" quit
	
	set trans=phrbar
	set word=""
	
	//First replace individual words
	for  set word=pw(word).order() quit:word=""  do {
		if word["|" quit
		set arrdat=pw(word)
		set tword=arrdat.piece("|",3)
		set trans.piece("|",arrdat.piece("|",1))=tword
		quit
		}
	
	//Then replace partial phrases
	for i=1:1:phrbar.length("|") do {
		set mark(i)="N"
		}
	
	set parphr=""
	for  set parphr=pw(parphr).order() quit:parphr=""  do {
		if parphr'["|" quit
		set arrdat=pw(parphr)
		set tparphr=arrdat.piece("|",3)
		set getout=0
		for i=arrdat.piece("|",1):1:arrdat.piece("|",2) do {
			if mark(i)="Y" set getout=1
			}
		if getout=1 quit
		for i=arrdat.piece("|",1):1:arrdat.piece("|",2) set mark(i)="Y"
		for i=arrdat.piece("|",1):1:arrdat.piece("|",2) do {
			set trans.piece("|",i)=""
			}
		set trans.piece("|",arrdat.piece("|",1))=tparphr
		}

	// Remove upbars from trans now
	set trans=trans.translate("|"," ")
	
	set prev=""
	set transnew=""
	for i=1:1:trans.length() do {
		if (prev=" "),(trans.extract(i)=" ") quit
		set transnew=transnew_trans.extract(i)
		set prev=trans.extract(i)
		}
	set trans=transnew

	quit
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60473^56807^Pete Chenard^21046"	// Signature - LTD^TIME^USER^SIZE
