EFTFUNCS		/*
	 ORIG: GOLPIRAD - 04/18/96
	 DESC: EFT Utilities

	 LIBRARY:
	  . DEBCHECK	Debit Authorization Check
	  . CRCDCID	Returns currency for CRCDCID
	  . DATES	Returns next valid EFD and corresponding PROCDT
	  . ORDAMT	Determine the order amounts in both currencies
	  . PLHLDS	Place EFT Holds
	  . RMHLDS	Remove EFT Holds
	  . TCMTSUP	CO suppressed due to stop type ~p1
	  . TOTBALAVL	Total available balance/credit limit
	  . TRREFQ	Treasury Reference Number query
	  . TRTYPE	Treasury Reference Payment Type

	---- Comments --------------------------------------------------------

	---- Revision History ------------------------------------------------

	08/09/06 - CHHABRIS - CR22501
		   Retrofited the below code from P01DEV1.

		03/30/06 - SIGDAE - CR 20275
	 	    o Modified section DATES to add a new argument (EOD2) to
	 	      indicate that the function should not allow PROCDT equal
	 	      to the System Date during the end of day 2 period.  This
	 	      will protect the case where an EFTPAY record could be 
	 	      created with a PROCDT equal to today after QUE068 has run 
	 	      during the EOD period but before the date has been switched.
	 	    o Modified section DATES to redefine the frequency to "1DA" 
	 	      after the first call to NDATE so the effective date is only
	 	      bumped forward a single day at a time when lead days exist.
 	    
	03/22/06 - KELLYP - CR 20145
		   Rewrote DEBCHECK section to retrofit changes made in P01 
		   to eliminate errors with debit authorization logic.  Also 
		   removed pre-2003 revision history.

	08/10/05 - Mugilvannan - CR 16732
		   Added XFRDSC and EFTDSC sections to handle the generation
		   of funds transfer-oriented teller comments for Regulation-
		   E processing.

	09/17/03 - CARROLLJ - 51630
		   Removed XDEBCHECK and XPLHLDS sections.  They are no longer
		   called.

	02/18/03 - sPIER - 51423
		   Correct compiler syntax errors
	*/

	quit	


public DEBCHECK(RecordEFTPAY eftpay, Boolean ONUS, Number BGTSEQ, Number BGTBILL, Number BGTCID)

	/*
	 Debit Authorization Check

	 ARGUMENTS:
		ONUS	- On-us transaction indicator
		BGTSEQ	- Budget Sequence Number	/REF
		BGTBILL	- Billing Account Number	/REF
		BGTCID	- Budget Account Number		/REF

	 INPUTS:
		STBLEFT	- System EFT Type

	 RETURNS:
		$$	- Pass or Fail
			  0	- Passed or not required
			  1	- Failed

	Notes:
	  EFTPAY.TTYPE Values
	 	0 - Customer to Customer
	 	1 - Customer to G/L
	 	2 - G/L to Customer
	 	3 - G/L to G/L
	*/

	type public Boolean ER
	type public String RM,STBLEFT

	type Boolean AUTHFLG,ogl,rgl
	type Number ACN,AUTACCT,AUTINST,CUSIDOPT,DCID,XSEQ
	type String ACNTYPE,RMSAV

	// Debit Authorizations not enabled at institution level
	if 'CUVAR.DEBAUT quit 0

	if STBLEFT'="DD",STBLEFT'="SCO",STBLEFT'="CO" quit 0
	if STBLEFT'="DD",ONUS'=1 quit 0

	// G/L to G/L does not require authorization
	if eftpay.ttype=3 quit 0

	// At this point, STBLEFT should = DD, SCO, or CO w/ ttype<3

	set rgl=0

	// For direct debits...
	if STBLEFT="DD" do {
 
		// The account to debit is the orginating account
		set DCID=eftpay.cid
		
		//  Authorized account is the recipient
		set AUTACCT=eftpay.recacct
		set AUTINST=eftpay.recinst
 
		/* 
		 DD sent from a customer to a customer or a DD sent from a
		 customer to a G/L.  Account to debit is a customer.  Get
		 the customer #.
		*/
		if eftpay.ttype<2 do {
			set ACNTYPE="C"
			type RecordACN acn=Db.getRecord("ACN","CID=:DCID")
			set ACN=acn.acn
			if eftpay.ttype=1 set rgl=1
                	}
		
		// DD sent from a G/L to a customer - Account to debit is a G/L
		if eftpay.ttype=2 do {
			set ACNTYPE="G"
			set ACN=DCID
			}
		}
	// For CO's and SCO's...
	else  do {
 
		// The account to debit is the recipient account.
		set DCID=eftpay.recacct
                
		// Authorized account is the originating account
		set AUTACCT=eftpay.cid
		set AUTINST=CUVAR.ISO
 
		/* 
		 CO/SCO sent from a customer to customer or sent from
		 a G/L to customer - Account to debit is a customer.
		 Get the customer #. 
		*/
		if ('(eftpay.ttype#2)) do {
			set ACNTYPE="C"
			type RecordACN acn=Db.getRecord("ACN","CID=:DCID")
			set ACN=acn.acn
			if eftpay.ttype=2 set rgl=1
			}
		/* 
		 CO/SCO sent from a customer to a G/L - Account to debit is
                 a G/L 
		*/
		if eftpay.ttype=1 do {
			set ACNTYPE="G"
			set ACN=DCID
			}
		}

	// Not sure when, if ever, CUSIDOPT should equal anything other than 1
	set CUSIDOPT=1

	// Check for the presence of debit authorization.
	
	set AUTHFLG=$$AUT^DEBAUT(ACNTYPE,ACN,AUTACCT,AUTINST,,eftpay.efd,eftpay.amount,CUSIDOPT,eftpay.custid,eftpay.crcd,.ER,.RM,,.XSEQ,DCID)
	if AUTHFLG=0 set RMSAV=RM,ER=0,RM="",AUTHFLG=$$AUT2^DEBAUT(ACNTYPE,ACN,AUTINST,eftpay.efd,eftpay.amount,eftpay.crcd,DCID)
	if AUTHFLG=0 do { quit 1
		/*
		 If the AUT2 call returns the default error response
		 'No Debit Authorization', use the response from the
		 call to AUT.  This will avoid having the AUT2 call
		 stepping on a more descriptive error message.
		*/
		if RM'=RMSAV,RM=$$^MSG(1925) set RM=RMSAV
		set ER=1
		}

	if XSEQ.get().isNull() quit 0

	type RecordDEBAUT debaut=Db.getRecord("DEBAUT","ACNTYPE=:ACNTYPE,ACN=:ACN,AUTINST=:AUTINST,AUTACCT=:AUTACCT,SEQ=:XSEQ")
	set BGTSEQ=debaut.bgtseq	// Budget sequence num
	set BGTBILL=debaut.billnbr	// Billing account # for budget accts
	set BGTCID=debaut.bgtcid	// Budget account number

	quit 0


public CRCDCID(CID,PMTTYP,CRCDEFT)
	/*
	 Returns currency for CRCDCID

	 This is called by computed data item [EFTPAY]CRCDCID
	*/

	if PMTTYP<2,Db.isDefined("ACN","CID") quit Db.getOneRow("CRCD","ACN","CID")
	quit CRCDEFT


Public DATES(EFD,FRE,ONUS,DAYS,STBLEFT,CRCD,PROCDT,EOD2)
	/*
	 Returns next valid EFD and corresponding PROCDT

	 Generate the next effective date and process date for
	 this payment order.

	 Based on the effecive date and frequency, figure out
	 what the next effective date will be.  Then figure out
	 what the process date must be in order to get the order
	 to the clearing center in time.

	 If the order is "on us", the effective date and the
	 process date will be the same.

	 ARGUMENTS:
		. EFD		- Effective Date (Start Date)
		. FRE		- Profile Frequency
		. ONUS		- On-us transaction indicator
		. DAYS		- Minimum days in future
		. STBLEFT 	- EFT System Type
		. CRCD		- Order Currency Code
		. PROCDT	- Process Date		/REF
		. EOD2		- Protect EOD2 period	/REF:R

	 INPUTS:
		. MINPAY Minimum days for a payment order
		. MINCOL Minimum days for a collection order

	 RETURNS:
		. $$  Effective Date
	*/

	type public String %STFHOST
	type Number I,MINDAYS,STFDAY
	type String EFDCAL,PRDCAL

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

	if (STBLEFT["PO")!(STBLEFT["DD") set MINDAYS=$S(MINPAY.data():MINPAY,1:cuvar.minpay)
	else  if STBLEFT["CO" set MINDAYS=$S(MINCOL.data():MINCOL,1:cuvar.mincol)
	else  set MINDAYS=""

	if EFD.isNull() set EFD=%SystemDate

	// End of Day 2 period, do not allow PROCDT equal to System Date
	if EOD2.get(),%STFHOST.get(),%SystemDate=$$TTL^RCHK() set STFDAY=1
	else  set STFDAY=0
	
	type RecordCRCD crcd1=Db.getRecord("CRCD","CO=:%CompanyName,CRCD=:CRCD")
	set EFDCAL=crcd1.calendar

	type RecordCRCD crcd2=Db.getRecord("CRCD","CO=:%CompanyName,CRCD=:%SystemCurrency")
	set PRDCAL=crcd2.calendar

	// Tack on EFD calendar to Frequency for NJD^UFRE call
	if FRE'["/" set FRE=FRE_"/"_EFDCAL

	for  do { quit:ER!(PROCDT'<(%SystemDate+STFDAY+DAYS.get())) 
		set EFD=$$NDATE(EFD,FRE,EFDCAL) quit:ER
		if ONUS set PROCDT=EFD quit 
		set PROCDT=$$PRBD(EFD,MINDAYS,PRDCAL)
		
		// If the event of lead days we only want to move forward 1 day, not a whole period
		set FRE="1DA/"_EFDCAL
		}
	quit EFD


NDATE(JD,FRE,CAL)
	/*
	 Return next valid business date.  'A'ctual day frequencies
	 will use next valid business date if actual day is a not
	 a business date based on the calendar attached to FRE.
	*/
	set NJD=$$NJD^UFRE(JD,FRE) quit:ER ""
	if '$$BD^UNBD(NJD,CAL) set NJD=$$NBD^UNBD(NJD,1,0,CAL)
	quit NJD


PRBD(DATE,NBD,CAL)
	/*
	 Return prior business date.  Today is a valid choice.
	*/
	
	if NBD=0,$$BD^UNBD(DATE,CAL) quit DATE

	while NBD>0 do {
		set DATE=DATE-1
		if $$BD^UNBD(DATE,CAL) set NBD=NBD-1
	}
	quit DATE


public ORDAMT(AMTTYP,AMT,FCID,FREQ,CRCD,TAMT,EFTTYPE,RCID)
	/*

	 Determine the order amounts in both currencies.

	 ARGUMENTS:
		. AMTTYP 	Amount Type
		. AMT  		Amount in order's currency
		. FCID  	Account Number
		. FREQ  	Order Frequency (18)
		. CRCD  	Order's currency
		. TAMT  	Amount in account's currency MECH=REF
		. EFTTYPE 	EFT Type
		. RCID		Recipient Account Number

	 RETURNS:
		. $$  Amount in order's currency
	*/

	new OFFSET,TRNTYP

	type RecordACN acn
	type RecordCTBLEFTTYPE efttype
	type RecordTRN trn

	// Initialize TAMT to be eftpay.amount
	set TAMT=AMT

	// G/L account
	if 'Db.isDefined("ACN","FCID") quit TAMT

	set acn=Db.getRecord("ACN","FCID")

	// Single currency order
	if CRCD=acn.crcd do { quit TAMT
		// If variable amount redefine TAMT, otherwise just use AMT
		if AMTTYP'=1 set TAMT=$$CIDAMT(AMTTYP,TAMT,FCID,FREQ,$G(RCID))
	}

	// Multi-currency order

	// Use EFT Type offset tran code to determine the type of transaction
	set efttype=Db.getRecord("CTBLEFTTYPE","EFTTYPE")
	set OFFSET=efttype.etc
	set trn=Db.getRecord("TRN","OFFSET")
	set TRNTYP=$E(trn.itc)

	/*
	 The amount in eftpay.amount is only valid for Amount Type 1 and
	 Amount type 2.  For these types, the amount may need to be
	 converted to the account's currency since $$CIDAMT() only deals
	 with amounts in the account's currency.
	*/

	if AMTTYP<3 set TAMT=$$CONV(CRCD,acn.crcd,AMT,TRNTYP,acn.ccode) quit:ER 0

	if AMTTYP=1 quit AMT

	// Determine account amounts
	set TAMT=$$CIDAMT(AMTTYP,TAMT,FCID,FREQ,$G(RCID))
	if TAMT'["|",+TAMT=0 quit 0

	// Determine order amounts
	for I=1:1:$L(TAMT,"|") set $P(AMT,"|",I)=$$CONV(acn.crcd,CRCD,$P(TAMT,"|",I),'TRNTYP,acn.ccode)

	quit AMT


CIDAMT(AMTTYP,AMT,CID,FREQ,RCID)
	/*
	 Determine the amount in account's currency

	 AMTTYP = 1  --> Fixed amount
	 AMTTYP = 2  --> Amount of balance over threshhold (AMT)
	 AMTTYP = 3  --> Entire available balance
	 AMTTYP = 4  --> Total Due
	 AMTTYP = 5  --> Total Due, No Charges
	 AMTTYP = 6  --> Total Interest Due
	 AMTTYP = 7  --> Total Interest Due, No Charges
	 AMTTYP = 8  --> Total Principal Due
	 AMTTYP = 9  --> Total Principal Due, No Charges
	 AMTTYP = 10 --> Total Bill Amount
	 AMTTYP = 11 --> Total Billed, No Charges
	 AMTTYP = 12 --> Available Total Bill Amount
	 AMTTYP = 13 --> Total Uncollected Amount
	 AMTTYP = 14 --> Total Uncollected, No Charge
	 AMTTYP = 15 --> Most Recent Bill
	 AMTTYP = 16 --> Current Bill
	 AMTTYP = 17 --> Oldest Bill Outstanding
	 AMTTYP = 18 --> Maximum Periodic Withdrawal Amount
	 AMTTYP = 19 --> Each bill
	 AMTTYP = 99 --> Custom Amount Type Calculation Program
			 For type 99 to calculate properly, function
			 $$CUSTOM^ZEFTOPT must exist.  See release notes
			 for ARQ 46739 for details and sample function.

	 NC	--> Used as a flag to determine whether a charge
		    will be applied to a bill.
			NC = 1	==> No Charge
			NC = 0 ==> A charge will be applied
	*/

	if AMTTYP=1 quit AMT			// Fixed amount
	new %A,X

	if AMTTYP<4 set X=$$BAL(CID) quit:ER 0
	else  set X=0
	if AMTTYP=2 quit $S(X>AMT:X,1:0)	// Return balance over a threshhold
	if AMTTYP=3 quit X

	if AMTTYP=18 do { quit X
		new AF,MAXAWA
		set X=$$BAL(CID)
		set MAXAWA=Db.getOneRow("MAXAWA","DEP","CID")

		set X=$$NJD^UFRE(%SystemDate,$G(FREQ),.AF) quit:ER 
		set X=MAXAWA/AF
		}

	// ARGUMENTS - $$LINETAG^EFTOPT(CID,NC)
	// where CID=account number, NC=no charge flag (1=no charge)
	if AMTTYP=4 quit $$DUE^EFTOPT(CID,0)
	if AMTTYP=5 quit $$DUE^EFTOPT(CID,1)
	if AMTTYP=6 quit $$INT^EFTOPT(CID,0)
	if AMTTYP=7 quit $$INT^EFTOPT(CID,1)
	if AMTTYP=8 quit $$PRIN^EFTOPT(CID,0)
	if AMTTYP=9 quit $$PRIN^EFTOPT(CID,1)
	if AMTTYP=10 quit $$TBA^EFTOPT(CID,0)
	if AMTTYP=11 quit $$TBA^EFTOPT(CID,1)
	if AMTTYP=12 quit $$TBAAVL^EFTOPT(CID,RCID,0)
	if AMTTYP=13 quit $$UNC^EFTOPT(CID,0)
	if AMTTYP=14 quit $$UNC^EFTOPT(CID,1)
	if AMTTYP=15 quit $$MRB^EFTOPT(CID)
	if AMTTYP=16 quit $$CB^EFTOPT(CID)
	if AMTTYP=17 quit $$OBO^EFTOPT(CID)
	if AMTTYP=19 quit $$EBL^EFTOPT(CID)
	#if $$VALID^%ZRTNS("ZEFTOPT") if AMTTYP=99 quit $$CUSTOM^ZEFTOPT()

	quit X

BAL(CID) // Compute available balance

	new BALAVL,CLS,DATA,MINBAL,X

	set CLS=Db.getOneRow("CLS","ACN","CID")

	// 51167 - Set up BALAVL w/ BAL for Loan, BALAVL for Deposit
	if CLS="L" set DATA=Db.getOneRow("BAL,SBWAMT","LN","CID")
	else  set DATA=Db.getOneRow("BALAVL,MINBAL","DEP","CID")

	set BALAVL=$P(DATA,$C(9),1)
	set MINBAL=$P(DATA,$C(9),2)

	if AMTTYP=2 do { quit:ER ""
		// Available balance is less than threshold amount
		if AMT<MINBAL set ER=1,RM=$$^MSG(8636) quit	
		set X=BALAVL-AMT
		if X<MINBAL set ER=1,RM=$$^MSG(8636)
	}

	else  set X=BALAVL-MINBAL

	// Balance is less than zero
	if X<0 set ER=1,RM=$$^MSG(315) quit 0
	// Balance is equal to zero
	if X=0 set ER=1,RM=$$^MSG(314) quit 0

	quit X


CONV(FCRCD,TCRCD,TAMT,TRNTYP,CCODE) 
	/*
	 Currency Conversion

	 ARGUMENTS:
		. FCRCD		From Currency
		. TCRCD		To Currency
		. TAMT		Transaction Amount
		. TRNTYP	Transaction Type
		. CCODE		Customer Code

	 RETURNS:
		. $$  Converted Amount
	*/

	// Variable I newed to protect it when called by section ORDAMT
	new EXCAMT,I,MAXRATE,MINRATE,MULTIPLY,RATE,TRESREF,VARIANCE

	if FCRCD=TCRCD quit TAMT

	do EXC^CRCDUTL(FCRCD,TCRCD,TAMT,1,TRNTYP,"00",CCODE,,1) if ER quit 0
	set EXCAMT=$$^SCARND(EXCAMT,0,,TCRCD)
	quit EXCAMT


public PLHLDS(RecordEFTPAY eftpay)
	/*
	 Place EFT Holds

	 Place holds for a payment/collection order on the
	 account and any linked protection accounts as needed. Returns
	 primary account hold sequence number (or null) if all holds 
	 were placed for the entire value of REQAMT. Returns 0 if any 
	 problems occur.

	 RETURNS:
		HLDSEQ for primary account if all holds were placed for
		the entire value of REQAMT.  Or 0 if any problems occur.

	 KEYWORDS:	Permanent Holds, Outgoing Foreign Payment Orders

	 ARGUMENTS:

	 INPUTS:

	 RELATED:
		. $$RMHLDS^EFTFUNCS - Removes holds placed on all accounts
		  for an outgoing foreign payment order.

	 EXAMPLE:
		S VAL=$$PLHLDS^EFTFUNCS(.eftpay)	
	*/

	new CID,CLS,DATA,EFTTYPE,EXPDT,HLDAMT,HLDMAX,SEQ,PHLD,STBLEFT
	new STDT,TCMT,TRNTYP

	set CID=eftpay.cid
	set SEQ=eftpay.seq
	set EFTTYPE=eftpay.efttype
	set DATA=Db.getOneRow("STBLEFT,HLDMAX,ETC","CTBLEFTTYPE","EFTTYPE")
	set STBLEFT=$P(DATA,$C(9),1)
	set HLDMAX=$P(DATA,$C(9),2)

	// Set up Foreign Payment order information
	if STBLEFT["NDPO" do {
		set TRNTYP=""
		set STDT=%SystemDate
		set HLDAMT=eftpay.anttotal

		// Determine hold expiration date
		if HLDMAX'="" set EXPDT=$$NBD^UNBD(STDT,HLDMAX,0,$G(CAL))+1
		else  set EXPDT=""

		// TRREF # ~p1 NDPO SEQ # ~p2
		set TCMT=$$^MSG(8344,eftpay.refno,eftpay.seq)
	}
	// Set up Domestic Payment order information
	else  do {
		new CAL,CRCD,OFFSET,X

		// Use EFT Type offset tran code to determine the type of transaction
		set OFFSET=$P(DATA,$C(9),3)
		set TRNTYP=Db.getOneRow("ITC","TRN","OFFSET")
		set CRCD=eftpay.crcd
		set CAL=Db.getOneRow("CALENDAR","CRCD","%CompanyName,CRCD")

		// Determine start date
		if TRNTYP set STDT=%SystemDate
		else  set STDT=eftpay.efd

		// Determine hold amount
		set X=$$ORDAMT(eftpay.amttyp,eftpay.amount,eftpay.cid,eftpay.frequency,eftpay.crcd,.HLDAMT,EFTTYPE)

		// Determine hold expiration date
		// Default one for domestic payment system only
		if HLDMAX="" set HLDMAX=1
		set EXPDT=$$NBD^UNBD(STDT,HLDMAX,0,CAL)+1

		// Permanent hold Sequence Number ~p1 added
		set TCMT=$$^MSG(5664)
	}

	if +HLDAMT=0 quit 0

	set CLS=Db.getOneRow("CLS","ACN","CID")

	// Do not check balances for collection orders
	if 'TRNTYP,STBLEFT'["NDPO" set PHLD(CID)=HLDAMT

	// Check balances, build PHLD array
	else  if '$$BLDPHLD(CID,HLDAMT,.PHLD,CLS) quit 0

	// Place holds contained in PHLD array
	if '$$INSPHLD(CID,SEQ,.PHLD,HLDAMT,STDT,EXPDT,TCMT,EFTTYPE,CLS) quit 0

	quit $P($G(PHLD(CID)),"|",2)


BLDPHLD(XCID,REQNET,PHLD,CLS)
	/*
	 Build PHLD array
	*/

	new ODO,SBAL,TAMT

	// Determine starting balance
	if CLS="L" set SBAL=Db.getOneRow("AVLBAL","LN","XCID")
	if CLS="D" do {
		new DATA,ODBB
		set DATA=Db.getOneRow("ODBB,BAL,BALCOL,BALAVL","DEP","XCID")

		//  Determine starting balance based on OD Balance Base
		set ODBB=+$P(DATA,$C(9),1)

		if ODBB=0 set SBAL=$P(DATA,$C(9),2) quit
		if ODBB=1 set SBAL=$P(DATA,$C(9),3) quit
		if ODBB=2 set SBAL=$P(DATA,$C(9),4)
	}

	if SBAL<0 set SBAL=0
	if REQNET'>SBAL set TAMT=REQNET set REQNET=0
	else  set TAMT=SBAL set REQNET=REQNET-SBAL

	// Set up an array entry for PHLD for the main account
	if SBAL>0 set PHLD(XCID)=TAMT

	// Check to see if hold amount is satisfied
	if REQNET=0 quit 1

	// Check is Overdraft Option is available
	set ODO=Db.getOneRow("ODO","ACN","XCID")
	if '(ODO#2) quit 0

	// Build Overdraft Priority array
	new ODACN,PRI,XPRI
	set ODACN=""

	type ResultSet rs
	set rs=Db.select("PRI,ODACN","DEPODP","CID=:XCID")

	if 'rs.isEmpty() while rs.next() do {
		set PRI=rs.getCol(1)
		set ODACN=rs.getCol(2)
		set XPRI(PRI)=ODACN
	}

	// Build PHLD array entries based on priority array entries
	set PRI=""
	for  set PRI=$O(XPRI(PRI)) quit:PRI=""  do { quit:REQNET=0 
		new AVLAMT,BCRCD,CCODE,DATA,EXCAMT,HCID,TAMT
		set HCID=XPRI(PRI)
		set DATA=Db.getOneRow("CRCD,CCODE,BALAVAIL","ACN","HCID")
		set BCRCD=$P(DATA,$C(9),1)
		if BCRCD="" set BCRCD=%SystemCurrency
		set CCODE=$P(DATA,$C(9),2)
		set AVLAMT=$P(DATA,$C(9),3)
		if AVLAMT'>0 quit

		/*
		 REQNET is in the order's currency so compare this
		 with the AVLAMT in the order's currency, ORDAMT.

		 If REQNET is greater the hold amount will be AVLAMT,
		 which is already in the account's currency.  
		 Otherwise the hold amount will be REQNET, which
		 would need to be converted to the account's currency.
		*/
		set ORDAMT=$$CONV(BCRCD,CRCD,AVLAMT,TRNTYP,CCODE) quit:ER
		if REQNET>ORDAMT do {
			set PHLD(HCID)=AVLAMT
			set REQNET=REQNET-ORDAMT
		}
		else  do {
			set PHLD(HCID)=$$CONV(CRCD,BCRCD,REQNET,TRNTYP,CCODE) quit:ER
			set REQNET=0
		}
	}

	quit:ER 0

	// Not enough funds available
	if REQNET>0 quit 0

	quit 1


INSPHLD(CID,SEQ,PHLD,HLDAMT,STDT,EXPDT,TCMT,EFTTYPE,CLS)
	/*
	 Place permanent and float holds
	*/

	new ACCT,CODE,HSEQ,TAMT
	set CODE=$$CODE(EFTTYPE)
	set ACCT=""
	for  set ACCT=$O(PHLD(ACCT)) quit:ACCT=""  do { quit:ER 
		set TAMT=PHLD(ACCT)
		set HSEQ=Db.nextVal("PHLD","ACCT")

		type RecordPHLD phld=Class.new("RecordPHLD")

		set phld.cid=ACCT
		set phld.seq=HSEQ
		set phld.stdt=STDT
		set phld.expdt=EXPDT
		set phld.amt=TAMT
		set phld.phc=CODE
		set phld.tcmt=TCMT

		do phld.save() quit:ER

		type RecordEFTHLD efthld=Class.new("RecordEFTHLD")
		
		set efthld.cid=CID
		set efthld.seq=SEQ
		set efthld.hcid=ACCT
		set efthld.hseq=HSEQ

		do efthld.bypassSave()

		set $P(PHLD(ACCT),"|",2)=HSEQ
		}
	quit:ER 0

	if CLS="L" quit 1

HLD7	// If IRCB is 3 (Collected Balance) also place a float hold
	set IRCB=Db.getOneRow("IRCB","DEP","CID")
	if IRCB=3 do {
		new AMT,MODE

		type RecordHLD7 hld7
		if Db.isDefined("HLD7","CID,EXPDT") set hld7=Db.getRecord("HLD7","CID,EXPDT") if 1
		else  set hld7=Class.new("RecordHLD7")

		set hld7.cid=CID
		set hld7.expdt=EXPDT
		set hld7.amt=hld7.amt+HLDAMT

		do hld7.save()
	}
	quit:ER 0
	quit 1


CODE(EFTTYPE)

	new CODE

	if EFTTYPE="" quit 99

	set CODE=Db.getOneRow("HLDCODE","CTBLEFTTYPE","EFTTYPE")

	if CODE="" quit 99
	quit CODE


public RMHLDS(CID,SEQ)
	/*
	 Expire EFT Holds

	 Expire any permanent holds placed for outgoing foreign payment
	 order on account CID.  Uses the [EFTHLD] table to
	 reference the HSEQ and HCID.  Returns TRUE if all holds are
	 expired successfully and FALSE if any problems occur.

	 KEYWORDS:	Permanent Holds, Outgoing Foreign Payment Orders

	 ARGUMENTS:
		. CID	EFTPAY CID	/TYP=N/REQ/MECH=VAL

		. SEQ	EFTPAY SEQ	/TYP=N/REQ/MECH=VAL

	 RETURNS:
		. ER	Error

	 RELATED:
		. $$PLHLDS^EFTFUNCS - The PLHLDS function places holds on the
		account and any link overdraft accounts.

	 EXAMPLE:
		S VAL=$$RMHLDS^EFTFUNCS(CID,SEQ)
	*/
	new EXPDT,HCID,HSEQ,HLDAMT,IRCB,SAVTLO,X

	type RecordDEP dep
	type RecordPHLD phld

	set ER=0

	// Protect TLO from being changed by DELHOLD^PHLD
	set SAVTLO=%UserStation

	if Db.isDefined("DEP","CID") do {
		set dep=Db.getRecord("DEP","CID")
		set IRCB=dep.ircb
	}
	else  set IRCB=""

	set (EXPDT,HLDAMT)=""
	set (HCID,HSEQ)=""

	type ResultSet rs
	set rs=Db.select("HCID,HSEQ","EFTHLD","CID=:CID AND SEQ=:SEQ")

	if 'rs.isEmpty() while rs.next() do {
		set HCID=rs.getCol(1)
		set HSEQ=rs.getCol(2)

		if 'Db.isDefined("PHLD","HCID,HSEQ") quit
		set phld=Db.getRecord("PHLD","HCID,HSEQ")

		// Expired
		if phld.expdt'>%SystemDate quit

		if IRCB=3 do {
			set HLDAMT=HLDAMT+phld.amt
			if EXPDT="" set EXPDT=phld.expdt
		}

		// Update Expiration Date on hold to expire it
		set phld.expdt=%SystemDate
		do phld.save()
	}

	// If IRCB is 3 (Collected Balance) also remove float hold
	if IRCB=3,HLDAMT>0,EXPDT'="" do {
		if 'Db.isDefined("HLD7","CID,EXPDT") quit
		type RecordHLD7 hld7
		set hld7=Db.getRecord("HLD7","CID,EXPDT")
		set hld7.amt=hld7.amt-HLDAMT
		do hld7.save()
		}

	set %UserStation=SAVTLO
	quit:ER 0
	quit 1


public TCMTSUP(CID)
	/*
	 CO suppressed due to stop type ~p1
	*/

	new COSTYP
	set COSTYP=Db.getOneRow("COSTYP","LN","CID")
	// CO suppressed due to stop type ~p1
	quit $$^MSG(3783,COSTYP)


public TOTBALAVL(CID) //Public
	/*
	 Calculate the total available balance of a deposit account.
	 Calculate the available credit limit of a loan account.
	 The total available balance includes all valid overdraft
	 protection accounts.

	 KEYWORDS:	Total Available Balance

	 ARGUMENTS:
		. CID	/TYP=T/REQ/MECH=VAL

	 INPUTS:

	 RETURNS:
		. $$	Total available balance  /TYP=T

	 EXAMPLE:
		TOTBALAVL=$$TOTBALAVL^EFTFUNCS(CID)
	*/

	Type Public RecordDEP dep

	new CLS,TOTAL

	set TOTAL=""

	set CLS=Db.getOneRow("CLS","ACN","CID")
	if CLS="D" do {
		new DATA
		set DATA=Db.getOneRow("ODO,ODBB,TOTBALAV,TOTCRLIM,BAL,BALCOL,BALAVL","DEP","CID")

		if $P(DATA,$C(9),1)=0 set TOTAL=$P(DATA,$C(9),7)
		else  do {
			new ODBB
			set ODBB=+$P(DATA,$C(9),2)
			set TOTAL=$P(DATA,$C(9),3)
			set TOTAL=TOTAL+$P(DATA,$C(9),4)

			if ODBB=0 set TOTAL=TOTAL+$P(DATA,$C(9),5) quit
			if ODBB=1 set TOTAL=TOTAL+$P(DATA,$C(9),6) quit
			if ODBB=2 set TOTAL=TOTAL+$P(DATA,$C(9),7)
			}
		}

	if CLS="L" set TOTAL=Db.getOneRow("AVLBAL","LN","CID")

	quit TOTAL


public TRREFQ(ETYPE,EREF)
	/*
	 Treasury Reference Number query

	 It is possible that the current reference number being filed back is
	 not the most recently issued one (it is possible that a newer one was
	 issued and filed before the current one gets filed.)  We need to make
	 sure that we only update TRREF if the current treasury reference
	 number is newer that what is currently in TRREF.
	 The logic makes sure that we don't file an older reference number
	 over a newer one.
	*/

	new OLDREF,OLDNUM,OLDYMD,NEWNUM,NEWYMD,TYPE
	set TYPE=5
	if ETYPE="NDPO" set TYPE=2
	if ETYPE="NDPOIN" set TYPE=3
	if ETYPE=1 set TYPE=1

	// get old reference number from the TRREF table
	set OLDREF=Db.getOneRow("REFNO","TRREF","TYPE")
	set OLDYMD=$E(OLDREF,7,10)		// extract year/month

	set NEWYMD=$E(EREF,7,10)		// get year/month to be inserted

	/*
	 if year/month changed, then go ahead
	 and update TRREF with EFTPAY.REFNO, then quit
	*/
	if NEWYMD'=OLDYMD quit 1

	/*
	 at this point, year/month is same so compare the old number to the
	 new one.  if the old one is newer, don't file anything - just quit
	*/
	set OLDNUM=$E(OLDREF,1,6)
	set NEWNUM=$E(EREF,1,6)
	if OLDNUM>NEWNUM quit 0

	// at this point, we know EFTPAY.REFNO is newer so file that back
	quit 1


public TRTYPE(EFTTYPE)
	/*
	 Treasury Reference Payment Type
	*/
	if EFTTYPE="NDPO" quit 2
	if EFTTYPE="NDPOIN" quit 3
	quit 5


public date(EFD,FRE,ONUS,DAYS,STBLEFT,CRCD)
	/*
	 Older version of function DATES, which returns Process
	 Date via global variable procdt.

	 This function should not be used by new code.
	*/

	set EFD=$$DATES(EFD,FRE,ONUS,DAYS,STBLEFT,CRCD,.PROCDT)
	set procdt=PROCDT
	quit EFD

public XFRDSC(RecordTTX ttx)		// Transaction object

	/*
	Generate U.S. Regulation E Trans. Description for Internal Funds XFR's

	 This section generates a transaction description according 
	 to the standards defined by U.S. Regulation E for internal 
	 funds transfers and stores it in the TR array for the SEQ
	 specified.  Depending upon the direction of the monetary 
	 transfer, the description will be in one of the following 
	 two forms:
	 
	 ~p1 transfer to ~p2 ~p3 account ~p4
	 ~p1 transfer from ~p2 ~p3 account ~p4
	 
	 Where...
	 	P1 = "Requested" or "Completed"
	 	P2 = Recipient Institution Name
	 	P3 = Recipient Account Type
	 	P4 = Recipient Account Number
	*/
	 
	type String P1,XFRCID,XFRDSC
	
	set XFRCID=$$FIELD^UTSO(ttx.tso,"XFR")
	
	if 'XFRCID quit
	 
	if %EffectiveDate>%SystemDate set P1=$$^MSG(5352) // Requested
	else  set P1=$$^MSG(3267).extract(1,9) // Completed
	 
	type RecordACN acn=Db.getRecord("ACN","CID=:XFRCID",1)
	
	// ~p1 transfer from ~p2 ~p3 account ~p4
	if ttx.itc.extract(1) set XFRDSC=$$^MSG(5170,P1,CUVAR.co,acn.grp,XFRCID)
	
	// ~p1 transfer to ~p2 ~p3 account ~p4
	else  set XFRDSC=$$^MSG(5169,P1,CUVAR.co,acn.grp,XFRCID)
 	
 	if 'ttx.tcmt.isNull() set ttx.tcmt=XFRDSC_" ~ "_ttx.tcmt
 	else  set ttx.tcmt=XFRDSC
 
	quit

	
public EFTDSC(String EFTTYPE, String RECINST, String RECACCT, String RECTYPE, String STATUS)
	/*
	Generate U.S. Regulation E Trans. Description for Domestic Payment Orders

	 This section generates and returns a transaction description 
	 (to be used in TTX.TCMT and HIST.TCMT) according to the 
	 standards defined by U.S. Regulation E for domestic payment 
	 orders.  Depending upon the direction of the monetary transfer, 
	 the description will be in one of the following two forms:
	 
	 ~p1 transfer to ~p2 ~p3 account ~p4
	 ~p1 transfer from ~p2 ~p3 account ~p4
	 
	 Where...
	 	P1 = "Requested" or "Completed"
	 	P2 = Recipient Institution Name
	 	P3 = Recipient Account Type
	 	P4 = Recipient Account Number
	*/
	
	type String P1,P2,P3,XFRDSC

	type RecordCTBLEFTTYPE cefttype=Db.getRecord("CTBLEFTTYPE","KEY=:EFTTYPE",1)
	
	// Foreign pmt's don't need a Reg E comment
	if cefttype.stbleft["NDPO" quit ""

	if STATUS'="C" set P1=$$^MSG(5352) // Requested
	else  set P1=$$^MSG(3267).extract(1,9) // Completed
	
	set P2=$$XINSTNAM^PROCOMP(RECINST)  // Recipient Institution Name
	
	if 'RECTYPE.isNull() do {
		type RecordUTBLEXTYP uextyp=Db.getRecord("UTBLEXTYP","ACCTYP=:RECTYPE",1)
		set P3=uextyp.des
		}
	else  set P3=""
	
	// ~p1 transfer from ~p2 ~p3 account ~p4
	if cefttype.stbleft["CO" set XFRDSC=$$^MSG(5170,P1,P2,P3,RECACCT)
	
	// ~p1 transfer to ~p2 ~p3 account ~p4
	else  set XFRDSC=$$^MSG(5169,P1,P2,P3,RECACCT)
	
	quit XFRDSC

vSIG()	quit "60499^8359^Sanjay Chhabria^25810"	// Signature - LTD^TIME^USER^SIZE
