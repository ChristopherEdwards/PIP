TTXRPST		//;PBS -  - V4.0  AUTO REPOST OF REJECTED ITEMS
	/*
	       ORIG:  Pete Chenard - 12/12/89
	  CALLED BY:
	      CALLS:
	   PROJ #'S:  P150 A600 T608
	       DESC:  This routine will repost rejected transactions that the
	              user decided to pay using function RET001. This routine
	              is called by function RET003.
	
	   GLOBALS -
	       READ:
	        SET:
	
	      INPUT:
	     OUTPUT:
		      BCD  : Branch from RET table (can be BOO)
		      BRCD : Posting Branch
	 
	  ---- Revision History -----------------------------------------------
	
	06/29/06 - DESHPANDE S K - CR 20748
		   Replace exc.disc with exc.sysbase in CHECK section.
		    	  
	03/14/05 - SmithCD - CR 13782
		   . Removed TEMPTTXPOS (obsolete) usage in EXEC section
		   . Removed UIDPP section, which was dead code
		   . Moved the call to %EXT^TTXPOS from the OFFSET section to 
		     the TELLER section, and modified to pass %ProcessID, 
		     BRCD, TLR, and LJD
		   . Restructured SETUP and EXEC sections
		   . Corrected problem in section FILE, where PCC was 
		     initialized to null instead of OCC
		   . Corrected processing involving utblsrc.patfee in CHECK 
		     section to actually use it (the prior code was useless)
		   . Fixed issues with TSEQ / SEQ
		   . Fixed undefined TAMT variable in CHECK section
		   . Brought some sections in-line
		   . Removed code involving MX that does not apply
		   . Modified to comply with current PSL standards

	12/29/03 - CARROLLJ - CR7658
		   Corrected undefined error in BATCHJ section.

	07/08/03 - Erik Scheetz - 51349
		   Replaced call to EXC2TTX with copy method.  
		   Removed obsoleted Schema class methods.

	02/04/02 - SCOTTC - 43583
		   Convert to PSL.  Remove history prior to 2001.	

	*/
	
	type String GLACN(), PAT2(,,,), TELLER(,,), VFMQ
	type Number NUMPOS, OLNTB, SEQ
	
	set VFMQ = " "
	set NUMPOS = 0
	
	// Page control

	while '("DFQ".isLike("%"_VFMQ_"%")) do VPG00
	
	if (%ProcessMode = 2)!(%ProcessMode = 4) ! (VFMQ = "Q") do END quit
	
	do FILE
	do END
	
	quit
	
	
FILE	// Post transactions

	type public Number BRCD, OCC, OFFSET(,)

	type String FEE, PRETRES
	type Number HLDSEQ, ORET, RET

	do SETUP

	// Set up Default Cost Center.
	type RecordUTBLBRCD utblbrcd = Db.getRecord("UTBLBRCD", "BRCD=:BRCD", 1)
	set OCC = utblbrcd.ccdef

	/*
	Compute the offset amount for the batch that was just created
	File the ^TTX entries for the offsetting transaction amounts.
	*/
	if OFFSET.data() do TELLER

	quit 
	

SETUP	// Determine the users to repost

	type public Date LJD
	type public Number BCD, BRCD, NUMPOS
	type public String GLACN(), TELLER(,,), XUID

	type String ET
	type Boolean ER
	
	set BCD = BRCD
	
	type DbSet ds = Db.selectDbSet("RET", "UID=:XUID AND TJD=:LJD AND BRCD=:BRCD")

	while ds.next()  do {

		type Number TELLNUM, SAREC

		set ER = 0

		type RecordEXC0 exc0 = Db.getRecord("EXC0", "TJD=:LJD,BRCD=:BRCD,UID=:XUID", 1)
		
		// User has already been processed
		if exc0.ret = "*" quit

		type RecordSCAU scau = Db.getRecord("SCAU", "UID=:XUID", 1)

		if scau.rtuid.isNull() do { quit
			// Invalid repost user ID
			do Runtime.setErrSTBLER("EXC0", "INVLDRPUID")
			do LOGERR 
			}
	
		// Count the number of users posted
		set NUMPOS = NUMPOS + 1
	
		set GLACN(XUID) = scau.tsdr_"|"_scau.tscr
		set TELLER(LJD, BRCD, XUID) = ""
	
		set TELLNUM = 0
		set SAREC = ""
		
		type RecordRET ret = ds.getRecord("RET")

		do EXEC(.ret, scau.rtuid)
		}

	quit


EXEC(RecordRET ret, String RTUID)	// Process one user sequence

	type public Number BRCD, NUMPOS, SEQ, TELLNUM

	if $$VERITEM(.ret) do {

		// Create a teller posting batch in ^TTX using the repost teller

		type String %UserID
		
		set SEQ = Db.nextVal("TTX", "%SystemDate,BRCD,RTUID")
	
		/* 
		CHECK sets both ^TTX for the repost teller and the OFFSET 
		array. OFFSET stores the total of the offsetting transaction 
		amounts by CRCD and RTUID. 
		*/

		do CHECK(.ret, RTUID)
		}

	if TELLNUM=0, NUMPOS '= 0 set NUMPOS = NUMPOS - 1

	quit 
	

TELLER  // Flag all tellers as having already been processed for this day

	type public String TELLER(,,), TLR
	type public Number BRCD
	type public Date LJD

	set TLR = ""
	
	for  set TLR = TELLER(LJD,BRCD,TLR).order() quit:TLR.isNull()  do {
		type RecordEXC0 exc0 = Db.getRecord("EXC0", "TJD=:LJD,BRCD=:BRCD,UID=:TLR", 1)
		if 'exc0.getMode() quit
		
		set exc0.ret = "*"
		do exc0.bypassSave()

		// Repost the original rejected transaction using 
		// the repost teller
		do %EXT^TTXPOS(%ProcessID, BRCD, TLR, LJD)
		}

	quit 
	

CHECK(RecordRET ret, String RTUID)
	// Check the number of times this record has remaining to retry

	type public Number BCD, BRCD, OFFSET(,), SAREC, SEQ, TELLNUM
	type public String FEE, GLACN(), PAT2(,,,), PRETRES, XUID
	type public Date LJD
	type public Boolean ER

	type Boolean DC
	type String CRCD, ITC, KEY, SRCTYP, UTSO
	type Number I, REC, RMHLD
	
	set REC = ret.tseq

	type RecordEXC exc = Db.getRecord("EXC", "TJD=:LJD,BRCD=:BRCD,UID=:XUID,TSEQ=:REC", 1)
	if 'exc.getMode() quit
	if exc.rty quit                            

	set TELLNUM = TELLNUM + 1                  

	/*
	Put the EXC object into an array so it can be
	copied to ttx when complete
	*/
	
	// Set the transaction up in the today's TTX file
	
	set DC = exc.itc.extract()
	set CRCD = exc.crcd
	
	if CRCD.isNull() set CRCD = %SystemCurrency
		
	set OFFSET(CRCD, RTUID) = OFFSET(CRCD, RTUID).get() + $S(DC:exc.tamt,1:-exc.tamt)
	
	/*
	If this record is in the same screen as the last record filed
	into TTX, file it into the same screen in TTX (SEQ=SEQ+1).
	*/

	if (REC \ 1000) = SAREC set SEQ = SEQ + 1
	else  set SEQ = (((SEQ \ 1000) + 1) * 1000) + 1
	
	set SAREC = REC \ 1000
	
	/*
	Reset TSO,TCMT to the original value
	Set item RETSPV in TSO to 1-Yes, to file into SPV.
	*/

	set exc.tso = $$FIELDIN^UTSO(exc.tso, "RETSPV", 1)
	
	// If PAT transaction, Build PAT2 fee array if PAT BATCH asseses fees
	set UTSO = ""
	do OUT^UTSO(.UTSO, exc.tso)
	if UTSO("PAT").exists() do {
		
		type String PAT
		type Number ACN, BATCH, CHCID
		
		set SRCTYP = "PAT"
		set KEY = UTSO("PAT")
		
		type RecordUTBLSRC utblsrc = Db.getRecord("UTBLSRC", "SRCTYP=:SRCTYP,KEY=:KEY", 1)
		if utblsrc.patfee.isNull() quit

		new PAT,ACN,BATCH,CHCID
		set PAT = UTSO("PAT").get() quit:PAT.isNull()
		set ACN = UTSO("PATA").get() quit:ACN.isNull()
		set BATCH = UTSO("PATB").get() quit:BATCH.isNull()
		set CHCID = UTSO("SRVCID").get() quit:CHCID.isNull()
		
		set PAT2(PAT, ACN, BATCH, SEQ) = CHCID_"|"_BRCD_"|"_RTUID
		}
	
	set exc.otso = ""
	set exc.tcmt = exc.otcmt
	set exc.otcmt = ""
	set exc.trc = SEQ     
	
	/*  
	Update the ITC of TX so that the transaction is not
	considered system generated.
	*/
	
	set ITC = exc.itc

	if ITC.extract(7) = 2 set ITC = $$ITC^TTXEXT(ITC,7,0)

	// remove trailing zeros                       
	for I = ITC.length():-1:2 quit:ITC.extract(I) '= 0  set ITC = ITC.extract(1, I-1)
	set exc.itc = ITC

	type RecordTTX ttx = exc.copy("CC=BEN,BCRCD=OTCMT,XPDO=exc.tso")

	set ttx.tjd = %SystemDate
	set ttx.brcd = BRCD
	set ttx.uid = RTUID
	set ttx.tseq = SEQ
	set ttx.cid = exc.cid

	do ttx.bypassSave()
	
	/* 
	This section will set up the individual balancing debit
	or credit to the GL suspense account of the teller that
	had the transactions reject.

	If the original transaction was a credit, use debit tran code,
	debit offset.  Otherwise, use credit tran code, offset.
	*/
	
	if DC do {
		set exc.cid = GLACN(XUID).piece("|",1)
		set exc.etc = "TSDR"
		}
	if 'DC do {
		set exc.cid = GLACN(XUID).piece("|",2)
		set exc.etc = "TSCR"
		}

	set exc.itc = 'DC
	set exc.rty = "*"
	set SEQ = SEQ + 1

	type RecordTTX ttx2 = exc.copy("CC=BEN,BCRCD=OTCMT,XPDO=exc.tso")

	set ttx2.tjd = %SystemDate
	set ttx2.brcd = BRCD
	set ttx2.UID = RTUID
	set ttx2.TSEQ = SEQ
	set ttx2.cid = exc.cid

	do ttx2.bypassSave()
	
	// Post any return item fees.
	do EXT^RETFEE(LJD, BCD, ret.cid, XUID, REC, PRETRES, FEE)
	
	if 'ret.hldseq.isNull() set RMHLD = $$RMHLD^RETUTL(ret.cid, ret.hldseq) quit:ER

	set ret.proc = 1

	do ret.bypassSave()

	quit 
	

LOGERR	// Log error in standard exception file

	type public Boolean ER
	type public Number ERR
	type public String %FN, ET

	type String DESC
	
	set ERR = ERR.get() + 1
	set DESC = %FN.get()
	if DESC.isNull() set DESC = %RoutineName

	//Repost of Rejected Items
	do LOG^UTLEXC(DESC, "*", $$^MSG(5479), "", "", ET.get())

	kill ET
	set ER = 0

	quit 
	

VERITEM(RecordRET ret)
	/*
	   Return 0 if the item should not be posted
	   Return 1 if the item should be posted

	*/

	type public String FEE, RET
	type public Number PRETRES
	
	type Boolean RTNVAL, OFFDYS

	quit:ret.proc 0

	set OFFDYS = $$OFFDAYS(.ret)
	
	// Account Review Completion
	
	set RTNVAL = 0
	if ret.review ! (OFFDYS = 2), (RET = 0) set RTNVAL=1
	else  if OFFDYS = 1 do {
		// Default Charge Fee Indicator
		set FEE = ret.dfee
		// Default Return Reason
		set PRETRES = ret.dpretres
		// Default Return Flag
		set RTNVAL = (ret.dret = 0)
		}
	else  set RTNVAL = 0
	
	/*
	If RET.FEEPROC is set then we have already charged fees for this
	return item.  Set the fee and primary return reason to null strings
	to prevent RETFEE from charging a duplicate fee.
	Fee Process
	*/

	if ret.feeproc = 1 set (FEE, PRETRES) = ""
	
	quit RTNVAL

	
OFFDAYS(RecordRET ret)
	/*
	   Return 2 if the posting source or offset days are not defined.
	   Return 1 if the offset days have been exceeded.
	   Return 0 if the offset days have not been exceeded.

	*/
	type public Date LJD
	
	type Number OFFSET
	type Date OFFDATE
	
	quit:ret.src.isNull() 2
	
	type RecordCTBLINC ctblinc = Db.getRecord("CTBLINC", "KEY=:ret.src", 1)
	set OFFSET = ctblinc.offset
	quit:OFFSET.isNull() 2
	
	if OFFSET>0 do {
		type RecordDEP dep = Db.getRecord("DEP", "CID=:ret.cid")
		set OFFDATE = $$NBD^UNBD(LJD + 1, OFFSET, 0, dep.nbdc)
		}
	else  set OFFDATE = LJD
	
	if %SystemDate '< OFFDATE quit 1
	
	quit 0


VPG00	// Set up

	type public Date LJD
	type public Number BRCD
	type public String VFMQ, XUID

	type String %READ, %TAB()

	set (LJD, BRCD, XUID) = ""
	
	set %TAB("LJD") = ".EFD2/HLP=[RET]TJD/TBL=[RET]TJD:DISTINCT"
	set %TAB("BRCD") = ".BRCD1/HLP=[RET]BRCD/TBL=[EXC]BRCD:DISTINCT:QUERY ""[EXC]TJD=<<LJD>>"""
	set %TAB("XUID") = ".A3/HLP=[RET]UID/TBL=[EXC]UID:DISTINCT:QUERY ""[EXC]BRCD=<<BRCD>>,[EXC]TJD=<<LJD>>"""
	
	set %READ = "@@%FN,,,LJD/REQ,BRCD/REQ,XUID/REQ" 
	
	do ^UTLREAD
	if VFMQ = "Q" quit 
	
	quit 
	

END	// End of processing

	type public Boolean ER
	type public Number ERR, NUMPOS
	type public String RM()

	if ER.get() ! (%ProcessMode=2) ! (%ProcessMode=4) quit 

	set ER = "W"
	
	// No transactions to repost
	if NUMPOS + ERR.get() = 0 set RM = $$^MSG(1998) quit

	//No posting occurred
	if NUMPOS = 0 set RM(1) = $$^MSG(1973)

	//Reposting complete.  ~p1 batches processed.
	else  set RM(1) = $$^MSG(2379, +NUMPOS.get())

	//~p1 errors encountered.  Run standard exception report.
	if ERR.get() set RM(2) = $$^MSG(3035, ERR)

	quit 
	

vSIG()	quit "60457^33413^Shriram Deshpande^10442"	// Signature - LTD^TIME^USER^SIZE
