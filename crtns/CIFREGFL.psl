CIFREGFL(RecordCIFEXTREG cifextreg, String vpar, Boolean vparNorm) // CIFEXTREG - CIF External Inst Account Registration Filer
	// Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/30/2007 14:13 - joynerd
	// Generated from DATA-QWIK schema in: /profile/v72qa_gtmlx  by: /v72qa_gtmlx/crtns/DBSFILB.obj

	// Data Dictionary Data Items (24)             08/06/2007
	// Trigger Definition (7)                      10/12/2006
	// Journal File Definition (2)                 09/28/2006
	/*
		vpar      Runtime qualifiers:      /NOREQ/MECH=REFARR:R

		/[NO]CASDEL   - Cascade delete
		/[NO]FRMFILER - Called from another filer
		/[NO]INDEX    - Update Indexes
		/[NO]JOURNAL  - Journal update
		/[NO]TRIGAFT  - After update triggers
		/[NO]TRIGBEF  - Before update triggers
		/[NO]UPDATE   - Update primary table
		/[NO]VALDD    - Validate column values
		/[NO]VALFK    - Validate foreign keys
		/[NO]VALREQ   - Validate not null values
		/[NO]VALRI    - Validate transaction integrity
		/[NO]VALST    - Validate database state
	*/

	type public String verrors()

	type String vx(), vxins()                              // audit column array
	type Number %O = cifextreg.getMode()                   // Processing mode
	set vpar = vpar.get()                                  // Initialize vpar

	if %O = 0 do AUDIT^UCUTILN(cifextreg,.vxins(),10,"|")
	if %O = 1 quit:'cifextreg.isChanged()  do AUDIT^UCUTILN(cifextreg,.vx(),10,"|")

	if 'vparNorm.get() set vpar = $$initPar^UCUTILN(vpar)  // Run-time qualifiers

	// Define local variables for access keys for legacy triggers
	type String ACN = cifextreg.acn
	type String SEQ = cifextreg.seq

	if %O = 0 do { quit                                    // Create record control block
		do vinit                                              // Initialize column values
		if vpar["/TRIGBEF/" do VBI                            // Before insert triggers
		if vpar["/VALREQ/" do vreqn                           // Check required
		if vpar["/VALDD/" do vddver                           // Check values
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 1 do { quit                                    // Update record control block
		if vx("ACN").exists()!vx("SEQ").exists() do vkchged quit // Primary key changed
		if vpar["/TRIGBEF/" do VBU                            // Before update triggers
		if vpar["/VALREQ/" do vrequ                           // Check required
		if vpar["/VALDD/" do VDDUX^DBSFILER("CIFEXTREG",.vx)
		set %O = 1 do vexec
		if vpar["/TRIGAFT/" do VAU                            // After update triggers
	}

	if %O = 2 do { quit                                    // Verify record control block
		if vpar["/VALREQ/" do vreqn                           // Check required
		set vpar = $$setPar^UCUTILN(vpar,"NOJOURNAL/NOUPDATE")
		do vexec
		if vpar["/TRIGAFT/" do VAI                            // After insert triggers
	}

	if %O = 3 do { quit                                    // Delete record control block
		quit:'Db.isDefined("CIFEXTREG","ACN = :cifextreg.acn and SEQ = :cifextreg.seq") // No record exists
		if vpar["/TRIGBEF/" do VBD                            // Before delete triggers
		do vdelete(0)
	}

	quit

vlegacy(Number %ProcessMode,String vpar) // Legacy interface (^DBSDF9 for %O=0, EXT^DBSFILER for %O = 2)

	type public String ACN
	type public String SEQ

	type RecordCIFEXTREG cifextreg = Db.getRecord("CIFEXTREG","ACN=:ACN,SEQ=:SEQ")
	if (%ProcessMode = 2) do {
		do cifextreg.setMode(2)

		do CIFREGFL(cifextreg,vpar)
	}
	else  do VINDEX(cifextreg)

	quit

vLITCHK() quit 0 // Table does not have columns involved in literals


vexec // Execute transaction

	type public Number %O
	type public String vpar,vobj(),vx(),vxins()

	type public RecordCIFEXTREG cifextreg

	type String vERRMSG

	if vpar["/VALST/" if '(''Db.isDefined("CIFEXTREG","ACN = :cifextreg.acn and SEQ = :cifextreg.seq") = ''%O) set vERRMSG = $$^MSG($select(%O:7932,1:2327)) throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	if vpar["/VALFK/" do CHKFKS                            // Check foreign keys
	if vpar["/VALRI/" do VFKEYS                            // Foreign key definition

	if vpar'["/NOUPDATE/" do {

		type String n = -1
		type String x

		if %O = 0 for  set n = vobj(cifextreg,n).order() quit:n.isNull()  do {
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^CIFEXTR(vobj(cifextreg,-3),vobj(cifextreg,-4),n)=vobj(cifextreg,n)
			#ENDBYPASS
		}

		else  for  set n = vobj(cifextreg,-100,n).order() quit:n.isNull()  do {
			quit:'$D(vobj(cifextreg,n))
			// Allow global reference and M source code
			#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS
			#BYPASS
				S ^CIFEXTR(vobj(cifextreg,-3),vobj(cifextreg,-4),n)=vobj(cifextreg,n)
			#ENDBYPASS
		}


		if vpar["/JOURNAL/" do VJOURNAL(.cifextreg)           // Create journal files
	}

	if vpar["/INDEX/",'(%O = 1)!'vx("").order().isNull() do VINDEX(.cifextreg) // Update Index files

	quit

vload // Record Load - force loading of unloaded data

	type public RecordCIFEXTREG cifextreg
	type String n = ""

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	for  set n=$order(^CIFEXTR(vobj(cifextreg,-3),vobj(cifextreg,-4),n)) quit:n=""  if '$D(vobj(cifextreg,n)),$D(^CIFEXTR(vobj(cifextreg,-3),vobj(cifextreg,-4),n))#2 set vobj(cifextreg,n)=^(n)
	#ENDBYPASS
	quit

vdelete(Boolean vkeychg) // Record Delete

	type public String vobj(),vpar
	type public RecordCIFEXTREG cifextreg

	if 'vkeychg.get(),cifextreg.isChanged() throw Class.new("Error","%PSL-E-DBFILER,Deleted object cannot be modified")

	if vpar["/CASDEL/" do VCASDEL                          // Cascade delete
	if vpar["/INDEX/" do VINDEX(.cifextreg)                // Delete index entries
	if vpar["/JOURNAL/" do VJOURNAL(.cifextreg)            // Create journal entries

	// Allow global reference - Delete record
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^CIFEXTR(vobj(cifextreg,-3),vobj(cifextreg,-4))
	#ENDBYPASS
	quit


vinit // Initialize default values

	type public RecordCIFEXTREG cifextreg

	// Type local variables for access keys for defaults
	type public String ACN
	type public String SEQ

	type public String TJD
	if cifextreg.cdate.isNull() set cifextreg.cdate = TJD  // cdate
	quit


vreqn // Validate required data items

	type public RecordCIFEXTREG cifextreg

	if cifextreg.extacct.isNull() do vreqerr("EXTACCT") quit
	if cifextreg.extacctp.isNull() do vreqerr("EXTACCTP") quit
	if cifextreg.extinst.isNull() do vreqerr("EXTINST") quit
	if cifextreg.regmet.isNull() do vreqerr("REGMET") quit
	if cifextreg.status.isNull() do vreqerr("STATUS") quit
	quit

vrequ // Valid required columns on update


	type public String vx()
	type public RecordCIFEXTREG cifextreg

	if cifextreg.acn.isNull() do vreqerr("ACN") quit
	if cifextreg.seq.isNull() do vreqerr("SEQ") quit

	if 'vobj(cifextreg,-100,1,"").order().isNull() do {
		if vx("EXTINST").exists(),cifextreg.extinst.isNull() do vreqerr("EXTINST") quit
		if vx("EXTACCT").exists(),cifextreg.extacct.isNull() do vreqerr("EXTACCT") quit
		if vx("EXTACCTP").exists(),cifextreg.extacctp.isNull() do vreqerr("EXTACCTP") quit
	}
	if 'vobj(cifextreg,-100,2,"").order().isNull() do {
		if vx("STATUS").exists(),cifextreg.status.isNull() do vreqerr("STATUS") quit
		if vx("REGMET").exists(),cifextreg.regmet.isNull() do vreqerr("REGMET") quit
	}
		if vx("EXTACCT").exists(),cifextreg.extacct.isNull() do vreqerr("EXTACCT") quit
		if vx("EXTACCTP").exists(),cifextreg.extacctp.isNull() do vreqerr("EXTACCTP") quit
		if vx("EXTINST").exists(),cifextreg.extinst.isNull() do vreqerr("EXTINST") quit
		if vx("REGMET").exists(),cifextreg.regmet.isNull() do vreqerr("REGMET") quit
		if vx("STATUS").exists(),cifextreg.status.isNull() do vreqerr("STATUS") quit
	quit

vreqerr(di) // Required error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("CIFEXTREG","MSG",1767,"CIFEXTREG."_di)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit


VFKEYS // Foreign keys

	type public String vfkey(),vpar

	type public RecordCIFEXTREG cifextreg
	if 'cifextreg.acn.isNull() set vfkey("^CIF("_""""_cifextreg.acn_""""_","_1_")")="CIFEXTREG(ACN) -> CIF"
	quit

CHKFKS   // Check foreign keys when not under buffer


	type public RecordCIFEXTREG cifextreg
	type public Number %O
	type String vERRMSG

	if 'Db.isDefined("CIF",":cifextreg.acn") set vERRMSG = $$^MSG(8563,"CIFEXTREG(ACN) -> CIF") throw Class.new("Error","%PSL-E-DBFILER,"_vERRMSG.replace(",","~"))
	quit


VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	if vx("").order().isNull() quit
	if vx("EXTINST").exists()!vx("EXTACCT").exists() do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STATUS").exists() do vau2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBD //
	type public Number ER = 0
	type public String vx(),RM
	do vbd1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordCIFEXTREG cifextreg
	do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() do AUDIT^UCUTILN(cifextreg,.vx(),10,"|") quit
	if vx("STATUS").exists() do vbu2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(cifextreg,.vx(),10,"|")
	quit


vai1 // Trigger AFTER_INSERT - After Insert Trigger for CIFEXTREG

	type public RecordCIFEXTREG cifextreg

	/*
	 ----------Revision History------------------------------------

	 10/05/06 - NATRAJAH - 22505
	 	Retrofited new trigger from P01DEV1 view as per the below
	 	mentioned CR.
	 	03/27/06 - Ed Sigda - CR 20275
	 	Create in Profile01 view.
	 	
	 09/19/05 - Kevin Hailey - CR 17234
	 	Modified code to not set field CIFEXT.STATUS.

	 09/07/05 - Kevin Hailey - CR 17117
		Added trigger.  This trigger check to ensure that the external
		account does not already exist for the client.  It will also
		create an entry in CIFEXT if the status is "Registered" and the
		Registration Method equals "Pre-Approved".  Otherwise if the
		status is "Not Registered" and the Registration Method equals
		"Random Payment Orders" it will create one or more random
		payment orders.

									--------------------------------------------------------------
	*/

	type ResultSet rs
	type RecordCIFEXT cifext
	
	// External account already exists
	set rs=Db.select("SEQ","CIFEXTREG","ACN=:cifextreg.acn AND EXTINST=:cifextreg.extinst AND EXTACCT=:cifextreg.extacct AND SEQ<>:cifextreg.seq")
	if 'rs.isEmpty() do Runtime.setErrMSG("CIFEXTREG","5668") quit

	// Only for inserts
	quit:%ProcessMode'=0
	
	/*
	If Status="Registered" and Registration Method equals "Pre-Approved"
	create an entry if CIFEXT
	*/
	if cifextreg.status=2,cifextreg.regmet=1 do {
		set cifext=Class.new("RecordCIFEXT")
		set cifext.acn=cifextreg.acn
		set cifext.seq=Db.nextVal("CIFEXT","ACN=:cifextreg.acn")
		set cifext.transit=cifextreg.transit
		set cifext.extinst=cifextreg.extinst
		set cifext.extacct=cifextreg.extacct
		set cifext.type=cifextreg.type
		set cifext.addr=cifextreg.addr
		set cifext.bencity=cifextreg.bencity
		set cifext.prov=cifextreg.prov
		set cifext.pc=cifextreg.pc
		set cifext.time=cifextreg.time
		set cifext.desc=cifextreg.desc
		set cifext.benname=cifextreg.benname
		set cifext.constant=cifextreg.constant
		set cifext.extacctp=cifextreg.extacctp
	
		do cifext.save()
	}
	
	/*
	If Status equals "Not Registered" and Registration Method equals
	"Random Payment Orders" create one or more random payment orders
	*/
	else  if cifextreg.status=1,cifextreg.regmet=3 do RANDOM^CIFEXTFU(cifextreg.acn,cifextreg.seq)
	
		
	quit

vau1 // Trigger AU_ACCOUNT - After Update of Account Information

	type public RecordCIFEXTREG cifextreg

	/*
	 ----------Revision History------------------------------------

	 10/05/06 - NATRAJAH - 22505
	 	Retrofited new trigger from P01DEV1 view as per the below
	 	mentioned CR.
	 	07/06/06 - Ed Sigda - CR 22476
		Modification to update EFTPAY with changes in 
		BENCITY, BENNAME, and EXTACCTP.
		
	 03/27/06 - Ed Sigda - CR 20275
	 	Create in Profile01 view.
	 	
	 09/07/05 - Kevin Hailey - CR 17117
		Added trigger.  This trigger check to ensure that the 
		external account does not already exist for the client.
		It will also update any EFTPAY records assosciated with
		the registration that are in a status of Added.

									--------------------------------------------------------------
	*/

	type DbSet ds
	type ResultSet rs
	type RecordCIFEXT cifext
	type RecordCUVAR cuvar
	type RecordCIFEXTREGAMT regamt
	type RecordEFTPAY eftpay
	type RecordUTBLEXTYP eftgrp
	type RecordUTBLEXTYP oeftgrp
	type Number oextaccp

	// External account already exists
	set rs=Db.select("SEQ","CIFEXT","ACN=:cifextreg.acn AND EXTINST=:cifextreg.extinst AND EXTACCT=:cifextreg.extacct")
	if 'rs.isEmpty() do Runtime.setErrMSG("CIFEXTREG","5668") quit
	set oextaccp=cifextreg.extacctp.oldVal

	// Update EFTPAY records that are still in an added status
	set ds=Db.selectDbSet("CIFEXTREGAMT","ACN=:cifextreg.acn AND SEQ=:cifextreg.seq")
	while ds.next() do {
		set regamt=ds.getRecord()
		
		set eftpay=Db.getRecord("EFTPAY","CID=:regamt.cid,SEQ=:regamt.payseq")

		if eftpay.status'="A" throw class.new("Error",","_$$^MSG(5673))
		
		do eftpay.setAuditFlag(1)
		
		set eftpay.recinst=cifextreg.extinst
		set eftpay.recacct=cifextreg.extacct
		
		if cifextreg.isChanged("EXTACCTP") do {
			set oeftgrp=Db.getRecord("UTBLEXTYP","ACCTYP=:cifextreg.extacctp.oldVal")
			set eftgrp=Db.getRecord("UTBLEXTYP","ACCTYP=:cifextreg.extacctp")
			
			quit:((oeftgrp.grp'="MISC")&(eftgrp.grp'="MISC"))
			
			set eftpay.ttype=$S(eftpay.ttype#2:eftpay.ttype-1,1:eftpay.ttype+1)
			
			quit:eftpay.ttype<2
			
			set cuvar=Db.getRecord("CUVAR")
			set eftpay.cc=cuvar.extvalcc	
		}
		
		// edit benname/bencity in TSO field if changed
		if cifextreg.benname'=cifextreg.benname.oldVal set eftpay.uniqtso=$$FIELDIN^UTSO(eftpay.uniqtso,"EXTNAME",cifextreg.benname)
		if cifextreg.bencity'=cifextreg.bencity.oldVal set eftpay.uniqtso=$$FIELDIN^UTSO(eftpay.uniqtso,"EXTCITY",cifextreg.bencity)
		
		do eftpay.save()
	}
	quit

vau2 // Trigger AU_STATUS - After Update of STATUS

	type public RecordCIFEXTREG cifextreg

	/*
	 ----------Revision History------------------------------------

	 10/05/06 - NATRAJAH - 22505
	 	Retrofited new trigger from P01DEV1 view as per the below
	 	mentioned CR.
	 	08/01/06 - Ed Sigda - 22476
	 	Added call to RFUND^CIFEXTFU for account funding 
	 	when account is updated to registered status and
	 	entry exists in CIFEXTRFUND table.
	 	03/27/06 - Ed Sigda - CR 20275
	 	Create in Profile01 view.
	 	
	 09/19/05 - Kevin Hailey - CR 17234
	 	Modified code to not set field CIFEXT.STATUS.

	 09/07/05 - Kevin Hailey - CR 17117
		Added trigger.  This trigger will check if the status
		is being updated to 2 - Registered.  If it is, an entry in
		CIFEXT will be created using the information contained in
		CIFEXTREG.

									--------------------------------------------------------------
	*/

	type RecordCIFEXT cifext

	if cifextreg.status=2 do {
		set cifext=Class.new("RecordCIFEXT")
		set cifext.acn=cifextreg.acn
		set cifext.seq=Db.nextVal("CIFEXT","ACN=:cifextreg.acn")
		set cifext.transit=cifextreg.transit
		set cifext.extinst=cifextreg.extinst
		set cifext.extacct=cifextreg.extacct
		set cifext.type=cifextreg.type
		set cifext.addr=cifextreg.addr
		set cifext.bencity=cifextreg.bencity
		set cifext.prov=cifextreg.prov
		set cifext.pc=cifextreg.pc
		set cifext.time=cifextreg.time
		set cifext.desc=cifextreg.desc
		set cifext.benname=cifextreg.benname
		set cifext.constant=cifextreg.constant
		set cifext.extacctp=cifextreg.extacctp
		
		do cifext.save()
		
		// create funding payment order if CIFEXTRFUND entry exists
		do RFUND^CIFEXTFU(cifextreg.acn,cifextreg.seq)	
	}
	quit

vbd1 // Trigger BEFORE_DELETE - Before Delete Trigger for CIFEXTREG

	type public RecordCIFEXTREG cifextreg

	/*
	 ----------Revision History------------------------------------

	 10/05/06 - NATRAJAH - 22505
	 	Retrofited new trigger from P01DEV1 view as per the below
	 	mentioned CR.
	 	03/27/06 - Ed Sigda - CR 20275
	 	Create in Profile01 view.
	 	
	 09/07/05 - Kevin Hailey - CR 17117
		Added trigger. This trigger will update all EFTPAY records
		to a status of "D" that are associated with the current
		CIFEXTREG record.
		
		This logic was added to the BEFORE trigger instead of the
		AFTER trigger because a foreign key exists that deletes the
		CIFEXTREGAMT table.  Therefore this table no longer exists
		when processing the AFTER delete trigger.

									--------------------------------------------------------------
	*/

	type DbSet ds
	type RecordCIFEXTREGAMT regamt
	type RecordEFTPAY eftpay
	
	set ds=Db.selectDbSet("CIFEXTREGAMT","ACN=:cifextreg.acn AND SEQ=:cifextreg.seq")
	while ds.next() do {
		set regamt=ds.getRecord()
		
		set eftpay=Db.getRecord("EFTPAY","CID=:regamt.cid,SEQ=regamt.payseq")
		
		do eftpay.setAuditFlag(1)
		
		if eftpay.status'="A" quit
		
		set eftpay.status="D"
		
		do eftpay.save()
	}
	quit

vbi1 // Trigger BEFORE_INSERT - Before Insert Trigger for CIFEXTREG

	type public RecordCIFEXTREG cifextreg

	/*
	 ----------Revision History------------------------------------

	 10/05/06 - NATRAJAH - 22505
	 	Retrofited new trigger from P01DEV1 view as per the below
	 	mentioned CR.
	 	03/27/06 - Ed Sigda - CR 20275
	 	Create in Profile01 view.
	 	
	 09/07/05 - Kevin Hailey - CR 17117
		Added trigger.  This trigger will default the records
		Expiration Date based on the current System Date plus the
		External Account Validation Maximum Days value in the
		Institution Variables table(CUVAR.EXTVALMAXDAY).
		
									--------------------------------------------------------------
	*/

	type RecordCUVAR cuvar
	
	set cuvar=Db.getRecord("CUVAR")
	
	// Default Expiration Date if it is null and CUVAR.EXTVALMAXDAY has a value
	if cifextreg.expdate.isNull(),'cuvar.extvalmaxday.isNull() set cifextreg.expdate=%SystemDate+cuvar.extvalmaxday
	
	/*
	Default status.  If pre-approved then 2 - Registered,
	otherwise 1 - Not Registered.
	*/
	if cifextreg.regmet=1 set cifextreg.status=2
	else  set cifextreg.status=1
	quit

vbu1 // Trigger BEFORE_UPDATE - Before Update Trigger for CIFEXTREG

	type public RecordCIFEXTREG cifextreg
	do cifextreg.setAuditFlag(1)

	/*
	 ----------Revision History------------------------------------

	 10/05/06 - NATRAJAH - 22505
	 	Retrofited new trigger from P01DEV1 view as per the below
	 	mentioned CR.
	 	03/27/06 - Ed Sigda - CR 20275
	 	Create in Profile01 view.
	 	
	 09/07/05 - Kevin Hailey - CR 17117
		Added trigger.  This trigger will Prevent a registration that
		is already in a "Registered" status from being modified. 
		
									--------------------------------------------------------------
	*/
	
	// Registered External Account cannot be modified
	if 'cifextreg.status.isNull(),cifextreg.status.oldVal=2 do Runtime.setErrMSG("CIFEXTREG","5672") quit
	quit

vbu2 // Trigger BU_STATUS - Before Update of STATUS

	type public RecordCIFEXTREG cifextreg
	do cifextreg.setAuditFlag(1)

	/*
	 ----------Revision History------------------------------------

	 10/05/06 - NATRAJAH - 22505
	 	Retrofited new trigger from P01DEV1 view as per the below
	 	mentioned CR.
	 	03/27/06 - Ed Sigda - CR 20275
	 	Create in Profile01 view.
	 	
	 09/07/05 - Kevin Hailey - CR 17117
		Added trigger to update audit information. Trigger
		used instead of table definition audit field since
		the current date is required.

									--------------------------------------------------------------
	*/

	set cifextreg.ruid=%UserID
	set cifextreg.rdate=%CurrentDate
	set cifextreg.rtime=%CurrentTime

	
	quit


vddver // Validate data dictionary attributes

	type public Number %O
	type public String vpar,vx()

	type String vRM,X
	type public RecordCIFEXTREG cifextreg

	if (%O = 2) do vload

	if vobj(cifextreg,1).exists() do {

		if cifextreg.addr.length()>32 set vRM = $$^MSG(1076,32) do vdderr("ADDR", vRM) quit
		if cifextreg.bencity.length()>40 set vRM = $$^MSG(1076,40) do vdderr("BENCITY", vRM) quit
		if cifextreg.benname.length()>32 set vRM = $$^MSG(1076,32) do vdderr("BENNAME", vRM) quit
		set X = cifextreg.constant if 'X.isNull(),'Db.isDefined("UTBLECOACT","X") set vRM = $$^MSG(1485,X) do vdderr("CONSTANT", vRM) quit
		if cifextreg.desc.length()>40 set vRM = $$^MSG(1076,40) do vdderr("DESC", vRM) quit
		if cifextreg.extacct.length()>20 set vRM = $$^MSG(1076,20) do vdderr("EXTACCT", vRM) quit
		set X = cifextreg.extacctp if 'X.isNull(),'Db.isDefined("UTBLEXTYP","X") set vRM = $$^MSG(1485,X) do vdderr("EXTACCTP", vRM) quit
		set X = cifextreg.extinst if 'X.isNull(),'Db.isDefined("UTBLEFTINST","X") set vRM = $$^MSG(1485,X) do vdderr("EXTINST", vRM) quit
		if cifextreg.pc.length()>32 set vRM = $$^MSG(1076,32) do vdderr("PC", vRM) quit
		if cifextreg.prov.length()>32 set vRM = $$^MSG(1076,32) do vdderr("PROV", vRM) quit
		if cifextreg.time.length()>14 set vRM = $$^MSG(1076,14) do vdderr("TIME", vRM) quit
		if cifextreg.transit.length()>5 set vRM = $$^MSG(1076,5) do vdderr("TRANSIT", vRM) quit
		if cifextreg.type.length()>32 set vRM = $$^MSG(1076,32) do vdderr("TYPE", vRM) quit
	}

	if vobj(cifextreg,2).exists() do {

		set X = cifextreg.cdate if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("CDATE", vRM) quit
		set X = cifextreg.expdate if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("EXPDATE", vRM) quit
		set X = cifextreg.failcnt if 'X.isNull(),X'?1.2N,X'?1"-"1.1N set vRM=$$^MSG(742,"N") do vdderr("FAILCNT", vRM) quit
		set X = cifextreg.rdate if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"D") do vdderr("RDATE", vRM) quit
		set X = cifextreg.regmet if 'X.isNull(),'Db.isDefined("STBLCIFEXTMET","X") set vRM = $$^MSG(1485,X) do vdderr("REGMET", vRM) quit
		set X = cifextreg.rtime if 'X.isNull(),X'?1.5N set vRM=$$^MSG(742,"C") do vdderr("RTIME", vRM) quit
		if cifextreg.ruid.length()>20 set vRM = $$^MSG(1076,20) do vdderr("RUID", vRM) quit
		set X = cifextreg.status if 'X.isNull(),'Db.isDefined("STBLCIFEXTST","X") set vRM = $$^MSG(1485,X) do vdderr("STATUS", vRM) quit
		if cifextreg.valcmt.length()>60 set vRM = $$^MSG(1076,60) do vdderr("VALCMT", vRM) quit
	}
	set X = cifextreg.acn if 'X.isNull(),X'?1.12N,X'?1"-"1.11N set vRM=$$^MSG(742,"N") do vdderr("ACN", vRM) quit
	set X = cifextreg.seq if 'X.isNull(),X'?1.3N,X'?1"-"1.2N set vRM=$$^MSG(742,"N") do vdderr("SEQ", vRM) quit
	quit

vdderr(di, vRM) // Column attribute error

	type public Boolean ER = 0
	type public String RM
	do SETERR^DBSEXECU("CIFEXTREG","MSG",979,"CIFEXTREG."_di_" "_vRM)
	if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VJOURNAL(RecordCIFEXTREG cifextreg)	//CIFEXTREG Journal file entries

	type Public Date %EffectiveDate
	type Public String %TSRC,vpar,vx()
	type String TSRC,vdi,vdx()

	if %TSRC.get().isNull() set TSRC="O"
	else  set TSRC=%TSRC

	if %ProcessMode=0 do {
		if TSRC="B" do {
			do vj1(.cifextreg)	// Mode=I Tran=B EFD=N,E Seq=1 JRNID=CIFEXTREGH_I
			}
		else  if TSRC="O" do {
			do vj1(.cifextreg)	// Mode=I Tran=O EFD=N,E Seq=1 JRNID=CIFEXTREGH_I
			}
		}
	else  if %ProcessMode=1 do {
		if TSRC="B" do {
			do vj2(.cifextreg)	// Mode=U Tran=B EFD=N,E Seq=1 JRNID=CIFEXTREGH_U
			}
		else  if TSRC="O" do {
			do vj2(.cifextreg)	// Mode=U Tran=O EFD=N,E Seq=1 JRNID=CIFEXTREGH_U
			}
		}

	quit


vj1(RecordCIFEXTREG cifextreg)	// CIFEXTREGH_I  Table CIFEXTREGH  History entry for new record

	type Public String %IDENT,%UID,TJD,TLO
	type String v1,v2,vlastkey
	set v1=cifextreg.acn
	set v2=cifextreg.seq
	set vlastkey=Db.nextVal("CIFEXTREGH","ACN=:v1,SEQ=:v2")
	type RecordCIFEXTREGH cifextregh=Db.getRecord("CIFEXTREGH","ACN=:v1,SEQ=:v2,HSEQ=:vlastkey",1)
	set cifextregh.hdate=+$H
	set cifextregh.htime=$P($H,",",2)
	set cifextregh.ident=%IDENT
	set cifextregh.sjd=TJD
	set cifextregh.tlo=TLO
	set cifextregh.uid=%UID

	do cifextregh.save("/NOVALFK/NOVALDD/NOVALRI")

	quit


vj2(RecordCIFEXTREG cifextreg)	// CIFEXTREGH_U  Table CIFEXTREGH  History entry for record maintenance

	type Public String vx()
	type String vdi

	set vdi="" for  set vdi=vx(vdi).order() quit:vdi=""  do {
		type Public String vx(),EFD,%IDENT,%UID,TJD,TLO
		type String v1,v2,vlastkey

		type String vold,vnew

		set vold=vx(vdi).piece("|",1)
		set vnew=vx(vdi).piece("|",2)

		set v1=cifextreg.acn
		set v2=cifextreg.seq
		set vlastkey=Db.nextVal("CIFEXTREGH","ACN=:v1,SEQ=:v2")
		type RecordCIFEXTREGH cifextregh=Db.getRecord("CIFEXTREGH","ACN=:v1,SEQ=:v2,HSEQ=:vlastkey",1)
		set cifextregh.hdate=+$H
		set cifextregh.htime=$P($H,",",2)
		set cifextregh.ident=%IDENT
		set cifextregh.sjd=TJD
		set cifextregh.tcmt=$$TCMTFM^ACNFUNCS("","CIFEXTREG",vdi,vold,vnew,$G(EFD))
		set cifextregh.tlo=TLO
		set cifextregh.uid=%UID

		do cifextregh.save("/NOVALFK/NOVALDD/NOVALRI")
		}

	quit



public VINDEX(RecordCIFEXTREG cifextreg) // Update index entries

		type Public String vx()

	if %ProcessMode=1 do { quit
		if vx("EXTINST").exists()!vx("EXTACCT").exists() do vi1(.cifextreg)
		if vx("STATUS").exists()!vx("EXPDATE").exists() do vi2(.cifextreg)
		if vx("STATUS").exists() do vi3(.cifextreg)
	}
	do vi1(.cifextreg)
	do vi2(.cifextreg)
	do vi3(.cifextreg)

	quit
	

vi1(RecordCIFEXTREG cifextreg) // Maintain ACCOUNT index entries (Order By Ext Inst and Account)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cifextreg.extinst
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cifextreg.extacct
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = cifextreg.acn
	type String v5 = cifextreg.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("EXTREGA",v2,v3,v4,v5)) do vidxerr("ACCOUNT")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("EXTREGA",v2,v3,v4,v5)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("EXTINST").exists() set v2=vx("EXTINST").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("EXTACCT").exists() set v3=vx("EXTACCT").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("EXTREGA",v2,v3,v4,v5)
	#ENDBYPASS
	quit

vi2(RecordCIFEXTREG cifextreg) // Maintain EXPIRED index entries (Order By Status,Expiration Dt)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cifextreg.status
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cifextreg.expdate
	if v3.isNull() set v3=(PSL.maxCharValue-1).char()
	type String v4 = cifextreg.acn
	type String v5 = cifextreg.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XREF("EXTREGE",v2,v3,v4,v5)) do vidxerr("EXPIRED")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XREF("EXTREGE",v2,v3,v4,v5)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("STATUS").exists() set v2=vx("STATUS").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()
	if vx("EXPDATE").exists() set v3=vx("EXPDATE").piece("|",1) set:v3.isNull() v3=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XREF("EXTREGE",v2,v3,v4,v5)
	#ENDBYPASS
	quit

vi3(RecordCIFEXTREG cifextreg) // Maintain STATUS index entries (Registration Status)

	type Public String vx()
	type Boolean vdelete = 0
	type String v2 = cifextreg.status
	if v2.isNull() set v2=(PSL.maxCharValue-1).char()
	type String v3 = cifextreg.acn
	type String v4 = cifextreg.seq

	if %ProcessMode=2 do { quit

		// Allow global reference
		#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
		#BYPASS
		if '$D(^XCIFEXTR("STATUS",v2,v3,v4)) do vidxerr("STATUS")
		#ENDBYPASS
		}

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	if %O<2 set ^XCIFEXTR("STATUS",v2,v3,v4)="" 
	#ENDBYPASS
	quit:%ProcessMode=0

	if %ProcessMode=3 set vdelete=1
	if vx("STATUS").exists() set v2=vx("STATUS").piece("|",1) set:v2.isNull() v2=(PSL.maxCharValue-1).char()

	// Allow global reference
	#ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS
	#BYPASS
	kill ^XCIFEXTR("STATUS",v2,v3,v4)
	#ENDBYPASS
	quit

public VIDXBLD(List vlist) // Rebuild index files (External call)


	type Number %ProcessMode=0                             // Create mode
	type Number i

	if vlist.get().isNull() set vlist="VINDEX"             // Build all

	type DbSet ds=Db.selectDbSet("CIFEXTREG")

	while ds.next() do {
		type RecordCIFEXTREG cifextreg=ds.getRecord("CIFEXTREG")
		if vlist.contains("VINDEX") do VINDEX(.cifextreg) quit
		if vlist.contains("ACCOUNT") do vi1(.cifextreg)
		if vlist.contains("EXPIRED") do vi2(.cifextreg)
		if vlist.contains("STATUS") do vi3(.cifextreg)
	}

	quit


public VIDXBLD1(RecordCIFEXTREG cifextreg, List vlist) // Rebuild index files for one record (External call)


	type Number i

	if vlist.contains("VINDEX") do VINDEX(.cifextreg) quit
	if vlist.contains("ACCOUNT") do vi1(.cifextreg)
	if vlist.contains("EXPIRED") do vi2(.cifextreg)
	if vlist.contains("STATUS") do vi3(.cifextreg)

	quit


vidxerr(di) // Error message

	D SETERR^DBSEXECU("CIFEXTREG","MSG",1225,"CIFEXTREG."_di)

	quit


vkchged // Access key changed

	type public RecordCIFEXTREG cifextreg

	type public Boolean ER = 0
	type public String RM,vpar,vx()

	type Number %O = 1
	type String vnewkey,voldkey,vux
	type String voldpar = vpar.get()                       // Save filer switches

	if vx("ACN").exists() set vux("ACN") = vx("ACN")
	if vx("SEQ").exists() set vux("SEQ") = vx("SEQ")
	do vkey(1) set voldkey = cifextreg.acn_","_cifextreg.seq // Copy old keys into object

	set vpar = $$setPar^UCUTILN(vpar,"NOINDEX")            // Switch Index off
	do vload                                               // Make sure all data is loaded locally
	if vpar["/VALREQ/" do vrequ
	if vpar["/TRIGBEF/" do VBU
	if vpar["/VALDD/" do vddver
	do vexec

	do vkey(2) set vnewkey = cifextreg.acn_","_cifextreg.seq // Copy new keys into object
	type RecordCIFEXTREG vnewrec = cifextreg.copy()
	do vnewrec.setMode(0)
	do vnewrec.save("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")

	set %O = 1 do CASUPD^DBSEXECU("CIFEXTREG",voldkey,vnewkey) if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~")) // Cascade update
	set vpar = voldpar
	if vpar["/TRIGAFT/" do VAU

	do vkey(1)                                             // Reset key for delete
	set vpar = $$initPar^UCUTILN("/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/")
	set %O = 3 do vdelete(1)                               // Delete old record

	quit

vkey(Number i) // Restore access keys

	type public String vux()
	type public RecordCIFEXTREG cifextreg

	if vux("ACN").exists() set cifextreg.acn = vux("ACN").piece("|",i)
	if vux("SEQ").exists() set cifextreg.seq = vux("SEQ").piece("|",i)
	quit

VCASDEL // Cascade delete logic

	type public RecordCIFEXTREG cifextreg
	type public String vpar

	do Db.delete("CIFEXTREGAMT","ACN=:cifextreg.acn AND SEQ=:cifextreg.seq",vpar) // Cascade delete

	do Db.delete("CIFEXTREGH","ACN=:cifextreg.acn AND SEQ=:cifextreg.seq",vpar) // Cascade delete

	quit

VIDXPGM()	quit "CIFREGFL"	// Location of index program

