R01S719	// YVBMCAM - VBM Interface Add/Modify Report
	// Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 12:55 - shetyes

	type public Number ER=0
	type public Number vbatchq
	type public String IO,RM,VRWOPT()
	type String RECSIZ
	type Number OLNTB
	type String %READ,RID,RN,%TAB,VFMQ
	type String BANKID="BLUESHIFT"
	type Date PRODATE=%SystemDate-1
	type String RECVR="0400"

	set RID="YVBMCAM"
	set RN="VBM Interface Add/Modify Report"
	if IO.get()="" set IO=$I

	do INIT^%ZM()

	do VPREBQ quit:VFMQ.get()			// Pre-processor (before query)

	set %TAB("BANKID")="|12|||||||T|Bank ID|||||"
	set %TAB("IO")=$$IO^SCATAB
	set %TAB("PRODATE")="|10|||||||D|Process Date|||||"
	set %TAB("RECVR")="|4|||||||T|REC VERSION|||||"

	set %READ="IO/REQ,PRODATE#1,BANKID#1,RECVR#1,"

	// Skip device prompt option
	if VRWOPT("NOOPEN").get() set %READ=%READ.piece(",",2,99)

	set VFMQ=""
	if %READ'="" do { quit:VFMQ.get()="Q"
		set OLNTB=30
		set %READ="@RN/CEN#1,,"_%READ
		do ^UTLREAD
		}

	if 'vbatchq.get() do V0
	quit

V0	// External report entry point

	type public Number AUXPTR,ER,VTBLNAM
	type public String IO,IOPAR,IOSL,IOTYP,%MSKD,RM,VDISTKEY,VRWOPT()
	type public String RECSIZ
	type public Date PRODATE
	type public String BANKID,RECVR
	type Number vcrt,VD(),VFMQ,vh(),vI,vlc,VLC,VNEWHDR,VOFFLG,VPN,VR,VRG,vs(),VSEQ,VT()
	type String VWHERE
	type Literal String VSELECT
	type String %TIM,ACNRELC,BATCHDT,BATCHID,BILMOD,CLS,CONAM,COUNT(),CUSADD,CUSMOD,DEPADD,DEPMOD,DETAIL,DETAIL1A,DETAIL2,DETAIL3,FILLER1,FILLER2,FM(),GRP,LIST,LNADD,LNMOD,MYDESC(),NUMOFSIG,RELACN,RELADD,RELDEL,RELMOD,RID,RN,ROLE,SORT,TAXREQ,TYP,VL,VLOF,VREL(),VRF(),VSTATS(),vCOL,vHDG,vc1,vc2,vc3,vc4,vc5,vc6,vc7,vc8,vc9,vovc1,vovc2,vrundate,vsysdate

	set CONAM=CUVAR.conam
	set ER=0,RID="YVBMCAM",RN="VBM Interface Add/Modify Report"
	set VL=""

	use 0 if 'VRWOPT("NOOPEN").get() do { quit:ER
		if 'VRWOPT("IOPAR").get().isNull() set IOPAR = VRWOPT("IOPAR")
		else  if ((IOTYP.get()="RMS")!(IOTYP.get()="PNTQ")),('IOPAR.get().isLike("%/OCHSET=%")),$$VALID^%ZRTNS("UCIOENCD") do {
			// Accept warning if ^UCIOENCD does not exist
			#ACCEPT Date=07/26/06; Pgm=RussellDS; CR=22121; Group=MISMATCH
			type String CHRSET=$$^UCIOENCD("Report","YVBMCAM","V0","*")
			if 'CHRSET.isNull() set IOPAR = IOPAR_"/OCHSET="_CHRSET
		}
		do OPEN^SCAIO
	}
	set vcrt=(IOTYP="TRM")
	if 'vcrt set IOSL=99999999			// Non-interactive
	else  do {					// Interactive
		do TERM^%ZUSE(IO,"WIDTH=70")
		write $$CLEARXY^%TRMVT
		}

	do INIT^%ZM()


	// Initialize variables
	set (vc1,vc2,vc3,vc4,vc5,vc6,vc7,vc8,vc9)=""
	set (VFMQ,vlc,VLC,VOFFLG,VPN,VRG)=0
	set VNEWHDR=1
	set VLOF=""
	set %TIM=$$TIM^%ZM
	set vrundate=%CurrentDate.toString(),vsysdate=%SystemDate.toString()

	do {
		type Number I,J,K
		for I=0:1:4 do {
			set (vh(I),VD(I))=0,vs(I)=1	// Group break flags
			set VT(I)=0			// Group count
			for J=1:1:0 do {
				for K=1:1:3 set VT(I,J,K)=""	// Initialize function stats
				}
			}
		}

	do Db.delete("TMPRPTBR","JOBNO=:%ProcessID")	// Report browser data
	if VDISTKEY.get()="" do { quit:VFMQ		// Report Pre-processor (after query)
		do VPREAQ
		if VFMQ set vh(0)=1 do VEXIT(0)
		}

	set vh(0)=0

	// Run report directly
	do VINILAST
	type ResultSet rwrs=Db.select("YVBMTMP.SORT,YVBMTMP.KEY,YVBMTMP.ACN,YVBMTMP.BILLPAY,YVBMTMP.RELATE,YVBMTMP.CLS,YVBMTMP.GRP,YVBMTMP.TYPE,YVBMTMP.NUMOFSIG","YVBMTMP","","YVBMTMP.SORT,YVBMTMP.KEY","","DQMODE=1")
	if ER.get() use 0 write $$MSG^%TRMVT(RM.get(),"",1)	// Debug Mode
	if rwrs.isEmpty() do VEXIT(1) quit
	while rwrs.next() do { quit:VFMQ
		type String V,VI
		set V=rwrs.getRow().toString()
		set VI=""
		do VGETDATA(V,VI)
		do VPRINT quit:VFMQ
		do VSAVLAST
		}
	do VEXIT(0)

	quit


VINILAST	// Initialize last access key values
	type Public String vovc1,vovc2
	set vovc1="",vovc2=""
	quit

VSAVLAST	// Save last access keys values
	type Public String vovc1,vc1,vovc2,vc2
	set vovc1=vc1,vovc2=vc2
	quit


VGETDATA(String V,String VI)	//
	type Public String vc1,vc2,vc3,vc4,vc5,vc6,vc7,vc8,vc9
	set vc1=V.piece($C(9),1)			// YVBMTMP.SORT
	set vc2=V.piece($C(9),2)			// YVBMTMP.KEY
	set vc3=V.piece($C(9),3)			// YVBMTMP.ACN
	set vc4=V.piece($C(9),4)			// YVBMTMP.BILLPAY
	set vc5=V.piece($C(9),5)			// YVBMTMP.RELATE
	set vc6=V.piece($C(9),6)			// YVBMTMP.CLS
	set vc7=V.piece($C(9),7)			// YVBMTMP.GRP
	set vc8=V.piece($C(9),8)			// YVBMTMP.TYPE
	set vc9=V.piece($C(9),9)			// YVBMTMP.NUMOFSIG
	quit

	// User-defined pre/post-processor code

VPREAQ	// Pre-processor (after query)

 /* This table shows the meaning of the SORT dataitem for the YVBMTMP file.
   The 1st piece is the DI that KEY represents and the 2nd piece is the
   operation, the 3rd piece is the description for each entry.
 */
                          
 type public Boolean ER
 type public Date BATCHDT,PRODATE
 type public Number NUMOFSIG,RELACN,ROLE,TAXREQ
 type public String ACNRELC,BILMOD,COUNT(),CUSADD,CUSMOD,DEPADD,DEPMOD,FM()
 type public String LIST,LNADD,LNMOD,MYDESC(),RELDEL,RELADD,RELMOD,SORT

 type Number ACN,CID,I,LASTACN,LASTADD,LASTCID,LASTFM,SEQ,TOT,TYP,TSEQ
 type String CLS,DI,DI2,FID,fs,GRP,NEWV,OLDV,REF,TAG,TCMT

 set CUSADD="0010"	// "CIF|A|ADD CUST"
 set CUSMOD="0020"	// "CIF|M|MOD CUST"
 set DEPADD="0030"	// "CID|A|ADD DEP "
 set LNADD="0040"	// "CID|A|ADD LN  "
 set DEPMOD="0050"	// "CID|M|MOD DEP "
 set LNMOD="0060"	// "CID|M|MOD LN  "
 set RELDEL="0070"	// "CID|D|DEL REL "
 set RELADD="0080"	// "CID|A|ADD REL "
 set RELMOD="0090"	// "CID|M|MOD REL "
 set BILMOD="0100"	// "CID|M|MOD BILLPAY Enablement"
                                                    
 type ResultSet rs=Db.select("KEY,DES","UTBLYVBMACT")
 while rs.next() do {
 	set I=rs.getCol("KEY")
 	set MYDESC(I)=rs.getCol("DES")
 	}
                          
 set LIST="CADD,CMOD,CDEL,AADD,AMOD,ADEL,REL,RDEL,RMOD,BILL"
 for I=1:1:LIST.length(",") set COUNT(LIST.piece(",",I))=0

 // value of 0 or 1 means US FORMAT
 set TAXREQ=CUVAR.taxreq
 if ('TAXREQ.isNull()),("0,1"[TAXREQ) set TAXREQ=1
 else  set TAXREQ=0
 set BATCHDT=PRODATE.toString("MMDDYEAR")
 set fs=$C(9),ER=0

 do Db.fastDelete("YVBMTMP","PID=:%ProcessID")

 // Collate through DTJNA to get new CUSTOMERS and ACCOUNTS
 type ResultSet rs1=Db.select("CLS,GRP,TYP,CID","DTJNA","TJD=:PRODATE")
 while rs1.next() do {
 	set CLS=rs1.getCol("CLS")
 	set GRP=rs1.getCol("GRP")
 	set TYP=rs1.getCol("TYP")
 	set CID=rs1.getCol("CID")
 	set SORT=$S(CLS="*":CUSADD,CLS="D":DEPADD,CLS="L":LNADD,1:"") quit:SORT.isNull()
 	set TAG=$S(CLS="*":"CADD",1:"AADD")
                    	
 	// Add CUSTOMER record to tmp file					
 	if SORT=CUSADD do { quit
 		set COUNT(TAG)=COUNT(TAG)+1
	     	type RecordYVBMTMP yvbmtmp=Db.getRecord("YVBMTMP","PID=:%ProcessID,SORT=:SORT,KEY=:CID",1)
     		set yvbmtmp.cls=CLS
	     	set yvbmtmp.grp=GRP
	     	set yvbmtmp.type=TYP
 		do yvbmtmp.bypassSave()
 		}

 	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
 	set ACN=acn.acn
 	set ACNRELC=acn.acnrelc
 	if ACN.isNull() quit
                          	
 	// Add RELATE account/customer PRIMARY record to tmp file
 	set COUNT("REL")=COUNT("REL")+1
 	type RecordYVBMTMP yvbmtmp=Db.getRecord("YVBMTMP","PID=:%ProcessID,SORT=:RELADD,KEY=:CID_""#""",1)
 	set yvbmtmp.cls=CLS
 	set yvbmtmp.grp=GRP
 	set yvbmtmp.type=TYP
 	set yvbmtmp.relate="P"
 	set yvbmtmp.acn=ACN
 	do yvbmtmp.bypassSave()
                          	
 	// Add RELATE account/customer SECONDARY record(s) to tmp file
 	set NUMOFSIG=1
	type DbSet ds=Db.selectDbSet("RELCIF","CID=:CID")
 	while ds.next() do {
		type RecordRELCIF relcif=ds.getRecord("RELCIF")
 		set RELACN=relcif.acn
 		set ROLE=relcif.role
 		set NUMOFSIG=NUMOFSIG+$$VREL(ACNRELC,ROLE)
 		set COUNT("REL")=COUNT("REL")+1
	     	type RecordYVBMTMP yvbmtmp=Db.getRecord("YVBMTMP","PID=:%ProcessID,SORT=:RELADD,KEY=:CID_""#""_RELACN",1)
	     	set yvbmtmp.cls=CLS
     		set yvbmtmp.grp=GRP
	     	set yvbmtmp.type=TYP
 		set yvbmtmp.relate="S"
 		set yvbmtmp.acn=ACN
 		do yvbmtmp.bypassSave()
 		}

 	// Add ACCOUNT record to tmp file
 	set COUNT(TAG)=COUNT(TAG)+1
 	type RecordYVBMTMP yvbmtmp1=Db.getRecord("YVBMTMP","PID=:%ProcessID,SORT=:SORT,KEY=:CID",1)
 	set yvbmtmp1.cls=CLS
 	set yvbmtmp1.grp=GRP
 	set yvbmtmp1.type=TYP
 	set yvbmtmp1.numofsig=NUMOFSIG
 	do yvbmtmp1.bypassSave()
                         	
 	// Add BILLPAY enablement record to tmp file
 	set COUNT("BILL")=COUNT("BILL")+1
 	type RecordYVBMTMP yvbmtmp2=Db.getRecord("YVBMTMP","PID=:%ProcessID,SORT=:BILMOD,KEY=:CID",1)
 	set yvbmtmp2.cls=CLS
 	set yvbmtmp2.grp=GRP
 	set yvbmtmp2.type=TYP
	set yvbmtmp2.acn=ACN
	set yvbmtmp2.billpay="Y"
 	do yvbmtmp2.bypassSave()
 	}

 // Collate through DTJFM to get Updates to files DEP and LN.
 set LASTADD="",LASTFM="",LASTCID=""
 kill FM
 type ResultSet rs3=Db.select("CLS,GRP,TYP,CID,TSEQ,TCMT","DTJFM","TJD=:PRODATE","TJD,CLS,GRP,TYP,CID,TSEQ DESC")
 while rs3.next() do {
 	set CLS=rs3.getCol("CLS")
 	set GRP=rs3.getCol("GRP")
 	set TYP=rs3.getCol("TYP")
 	set CID=rs3.getCol("CID")
 	set TSEQ=rs3.getCol("TSEQ")
 	set TCMT=rs3.getCol("TCMT")
 	set REF=TCMT.piece(":",1)
 	set OLDV=TCMT.piece(":",2)
 	set NEWV=TCMT.piece(":",3)
 	set DI=REF.piece("]",2)
 	set FID=(REF.piece("]",1)).piece("[",2)
 	set DI2=$S(DI?1"ROLE".N:"ROLE",1:DI)

 	// ignore all F/M records for acct added today
 	if CID=LASTADD quit
 	if CID'=LASTCID do RELFM(LASTCID) set LASTCID=CID
                          	
 	// DEPADD=Add DEPOSIT account. LNADD=Add LOAN account.
 	set TAG=$S(CLS="D":DEPADD,CLS="L":LNADD,1:"") quit:TAG.isNull()

 	// if the account was just added to tmp file then ignore f/m
 	type RecordYVBMTMP yvbmtmp=Db.getRecord("YVBMTMP","PID=:%ProcessID,SORT=:TAG,KEY=:CID",1)
 	if yvbmtmp.getMode() set LASTADD=CID quit
                          	
 	// Process non-ownership changes
 	if ",ROLE,ACN,ACNRELC,"'[(","_DI2_",") do { quit
 		if CID=LASTFM quit
 		set LASTFM=CID,COUNT("AMOD")=COUNT("AMOD")+1
 		set SORT=$S(CLS="D":DEPMOD,1:LNMOD)
 		type RecordYVBMTMP yvbmtmp=Db.getRecord("YVBMTMP","PID=:%ProcessID,SORT=:SORT,KEY=:CID",1)
 		set yvbmtmp.cls=CLS
 		set yvbmtmp.grp=GRP
 		set yvbmtmp.type=TYP
 		do yvbmtmp.bypassSave()
 		}

 	// Process OWNERSHIP changes, don't do anything for RELACNC changes,
 	// since they will be accompanyied by ROLE and/or ACN changes.
 	if DI["ROLE" do { quit
 		/* The first role encountered going in reverse is the new
 		  new role, each one encountered after that is considered
 		  the old value and just keeps going that way.
 		  since we don't know how many will find we can't create
 		  the apporpriate rel records until we get to the next acct
 		*/
 		set ACN=(TCMT.piece(":",4)).piece("CIF ",2)
 		if FM(CID,ACN).exists() set FM(CID,ACN).piece("|",1)=OLDV
 		else  set FM(CID,ACN)=OLDV_"|"_NEWV
 		}

 	if (DI="ACN"),(",ACN,DEP,LN,RELCIF,"[(","_FID_",")) do { quit
 		if 'OLDV.isNull() set FM(CID,"OWN").piece("|",1)=OLDV
 		if ('NEWV.isNull()),((FM(CID,"OWN").piece("|",2)).isNull()) set FM(CID,"OWN").piece("|",2)=NEWV
 		}
 	}

 // process any remaining RELATE records
 if FM.exists() do RELFM(LASTCID)
                          
 // Collate through CIFD to get Updates to files CIF.
 set LASTACN=""
 type ResultSet rs4=Db.select("ACN,SEQ,TCMT","CIFD","TJD=:PRODATE","TJD,ACN,SEQ DESC")
 while rs4.next() do {
 	set ACN=rs4.getCol("ACN")
 	set SEQ=rs4.getCol("SEQ")
 	set TCMT=rs4.getCol("TCMT")
 	if ACN=LASTACN quit
 	set LASTACN=ACN
 	type RecordYVBMTMP yvbmtmp=Db.getRecord("YVBMTMP","PID=:%ProcessID,SORT=:CUSADD,KEY=:ACN",1)
 	if yvbmtmp.getMode() quit
 	set COUNT("CMOD")=COUNT("CMOD")+1
 	set yvbmtmp.sort=CUSMOD
 	set yvbmtmp.cls="*"
 	set yvbmtmp.grp="CIF"
 	}

 // The one is for the header record.
 set TOT=1
 for I=1:1:LIST.length(",") set TOT=TOT+COUNT(LIST.piece(",",I))
 set COUNT("TOT")=TOT

 quit
                          
VREL(ACNRELC,ROLE) // Return 1 of suffix="AND" otherwise 0

 type public String VREL()
                          
 type String SFX

 if (ACNRELC.isNull())!(ROLE.isNull()) quit 0
 set SFX=VREL(ACNRELC,ROLE).get()
 if 'SFX.isNull() quit:SFX="AND" 1  quit 0
 type RecordRELCODE relcode=Db.getRecord("RELCODE","REL=:ACNRELC,ROLE=:ROLE",1)
 if 'relcode.getMode() quit 0
 set SFX=relcode.sfx
 set SFX=$$UPPER^%ZFUNC(SFX)
 set VREL(ACNRELC,ROLE)=SFX

 quit $S(SFX["AND":1,1:0)
                          
RELFM(CID) // Process FM() array to create records form RELATE ADD/DELETE
 
 type public Number TYP
 type public String CLS,COUNT(),GRP,FM(),RELDEL
                          
 type String ACN,ADDACN,DELACN,OLDV,NEWV,OWN

 if ('FM.exists())!((CID.get()).isNull()) quit
 set ACN=""
 for  set ACN=FM(CID,ACN).order() quit:ACN.isNull()  do {
 	set OLDV=FM(CID,ACN).piece("|",1)
 	set NEWV=FM(CID,ACN).piece("|",2)
 	if (OLDV.isNull()&(NEWV.isNull()))!(OLDV=NEWV) quit
 	set (DELACN,ADDACN)=ACN,OWN="S"
 	if ACN="OWN" do {
 		set DELACN=OLDV
 		set ADDACN=NEWV
 		set OWN="P"
 		}
 	if 'OLDV.isNull() do {
 		type RecordYVBMTMP yvbmtmp=Db.getRecord("YVBMTMP","PID=:%ProcessID,SORT=:RELDEL,KEY=:CID_""#""_DELACN",1)
 		set yvbmtmp.cls=CLS
 		set yvbmtmp.grp=GRP
 		set yvbmtmp.type=TYP
 		set yvbmtmp.relate=OWN
 		set yvbmtmp.acn=DELACN
 		set COUNT("RDEL")=COUNT("RDEL")+1
 		}
 	if NEWV.isNull() quit
 	set COUNT("REL")=COUNT("REL")+1
 	type RecordYVBMTMP yvbmtmp=Db.getRecord("YVBMTMP","PID=:%ProcessID,SORT=:RELDEL,KEY=:CID_""#""_ADDACN",1)
 	set yvbmtmp.cls=CLS
 	set yvbmtmp.grp=GRP
 	set yvbmtmp.type=TYP
 	set yvbmtmp.relate=OWN
 	set yvbmtmp.acn=ADDACN
	}
 kill FM

 quit
	quit

VPREBQ	// Pre-processor (before query)

 type public Number RECSIZ
 type public String IO
 
 set IO=(%SystemDate-1).toString("MMDD")_".AMD"
 // Set record size to be large enough to handle biggest record
 set RECSIZ=679
	quit

VBRSAVE(Number LINE,String DATA)	// Save for report browser
	type RecordTMPRPTBR tmprptbr=Class.new("RecordTMPRPTBR")
	set tmprptbr.jobno=%ProcessID
	set tmprptbr.lineno=LINE
	set tmprptbr.pageno=0
	set tmprptbr.seq=0
	set tmprptbr.data=DATA
	do tmprptbr.bypassSave()
	quit

VEXIT(NOINFO)	// Exit from report
	type Public Number IOSL,vcrt,VFMQ,vh(),VLC,VPN,VRWOPT,VSTATS()
	type Public String IO,VTBLNAM
	type Number I,PN,vs(),z
	type String VL=""
	set vs(1)=0,vs(2)=0,vs(3)=0,vs(4)=0
	if 'VFMQ do VSUM
	if 'VFMQ do VRSUM
	if 'VFMQ do {
		// No information available to display
		if NOINFO=1 set VL=$$^MSG(4655) do VOM
		if vcrt set VL="" for z=VLC+1:1:IOSL do VOM

		if 'VTBLNAM.exists() do {
			set vs(2)=0
			do VBREAK,stat^DBSRWUTL(2)
			}
		}

	if 'VFMQ,vcrt set PN=-1 do ^DBSRWBR(2)
	if 'VRWOPT("NOCLOSE").get() do CLOSE^SCAIO
	do Db.delete("TMPRPTBR","JOBNO=:%ProcessID")	// Report browser data

	quit

VPRINT	// Print section
	type Public Number VD(),VFMQ,VH0,vh(),VNEWHDR,VR,VRG,VRWOPT,VSEQ
	type Number vskp()

	if VRWOPT("NODTL").get() set vskp(1)=1,vskp(2)=1,vskp(3)=1,vskp(4)=1	// Skip detail
	do VBREAK
	do VSUM quit:VFMQ

	if VH0.get() set vh(0)=0,VNEWHDR=1 kill VH0	// Page Break
	if 'vh(0) do VHDG0 quit:VFMQ
	if 'vskp(4).get() do VDTL4 quit:VFMQ
	do VSTAT
	quit

VBREAK	//
	type Public Number VD(),vh(),VH0,vs(),VT()
	quit:'VT(4)
	type Public String vc1,vovc1,vc2,vovc2
	type Number vb1,vb2,vb3,vb4
	set (vb1,vb2,vb3,vb4)=0
	if vb3!(vovc1'=vc1) set vs(4)=0,vh(4)=0,VD(3)=0,vb4=1
	quit

VSUM	// Report Group Summary
	type Public Number VFMQ,vs()
	if 'vs(4) set vs(4)=1 do stat^DBSRWUTL(4)
	if 'vs(3) set vs(3)=1 do stat^DBSRWUTL(3)
	if 'vs(2) set vs(2)=1 do stat^DBSRWUTL(2)
	quit

VSTAT	// Data field statistics
	type Public Number VRWOPT(),VT()
	type Public String VSTATS

	set VT(4)=VT(4)+1
	quit

VDTL4	// Detail
	type public String ACNRELC,BANKID,BATCHDT,BATCHID,BILMOD,CLS,COUNT(),CUSADD,CUSMOD,DEPADD,DEPMOD,DETAIL,DETAIL1A,DETAIL2,DETAIL3,ER,FILLER1,FILLER2,FM(),GRP,IOSL,LIST,LNADD,LNMOD,MYDESC(),NUMOFSIG,PRODATE,RECSIZ,RECVR,RELACN,RELADD,RELDEL,RELMOD,ROLE,SORT,TAXREQ,TYP,V,VD(),VFMQ,VL,VLC,VO,VOFFLG,VREL(),VRG,VT(),vc1,vc2,vc3,vc4,vc5,vc6,vc7,vc8,vc9,verror,vh(),vovc1,vovc2

	if VLC+3>IOSL do VHDG0 quit:VFMQ

	do VP1 quit:VFMQ!verror.get()  set V=$E(DETAIL,1,500) set VL=V
	set VL=VL_$J("",500-VL.length())_$E(DETAIL1A,1,179)
	if 'VL.translate(" ").isNull() do VOM
	set VL=$E(DETAIL2,1,372)
	if 'VL.translate(" ").isNull() do VOM
	set VL=$E(DETAIL3,1,69)
	if 'VL.translate(" ").isNull() do VOM
	quit


VHDG0	// Page Header
	type Public Number ER,IOSL,vcrt,verror,VFMQ,vh(),VLC,VNEWHDR,VPN,VRG,VRWOPT()
	type public String %MSKD,%TIM,ACNRELC,BANKID,BATCHDT,BATCHID,BILMOD,CLS,CONAM,COUNT(),CUSADD,CUSMOD,DEPADD,DEPMOD,DETAIL,DETAIL1A,DETAIL2,DETAIL3,FILLER1,FILLER2,FM(),GRP,LIST,LNADD,LNMOD,MYDESC(),NUMOFSIG,PRODATE,RECSIZ,RECVR,RELACN,RELADD,RELDEL,RELMOD,RID,RN,ROLE,SORT,TAXREQ,TYP,VL,VREL(),vc1,vc2,vc3,vc4,vc5,vc6,vc7,vc8,vc9,vovc1,vovc2,vrundate,vsysdate
	type Number PN,V,VO
	if VRWOPT("NOHDR").get() quit			// Skip page header
	set vh(0)=1,VRG=0
	if VL'="" do VOM
	if vcrt,VPN>0 do { quit:VFMQ!'VNEWHDR
		type Number PN,X
		set VL=""
		for X=VLC+1:1:IOSL do VOM
		set PN=VPN
		do ^DBSRWBR(2)
		set VLC=0
		quit:VFMQ
		if VNEWHDR write $$CLEARXY^%TRMVT
		else  set VLC=VLC+1,VPN=VPN+1
		}

	set ER=0,VPN=VPN+1,VLC=0

	set VL="H"
	set VL=VL_$J("",2-VL.length())_$E(BANKID,1,12)
	set VL=VL_$J("",14-VL.length())_$E(BATCHDT,1,8)
	set VL=VL_$J("",22-VL.length())_$E(RECVR,1,4)
	do VP2 quit:VFMQ!verror.get()  set V=$E(BATCHID,1,9)
	set VL=VL_$J("",26-VL.length())_V
	do VP3 quit:VFMQ!verror.get()  set V=$E(FILLER1,1,185)
	set VL=VL_$J("",35-VL.length())_V
	do VOM

	set VNEWHDR=0
	if vcrt set PN=VPN do ^DBSRWBR(2,1)		// Lock report page heading

	quit


VRSUM	// Report Summary
	type Public Number IOSL,verror,VFMQ,vh,VLC,VT(),VX()
	type Public String ACNRELC,BANKID,BATCHDT,BATCHID,BILMOD,CLS,COUNT(),CUSADD,CUSMOD,DEPADD,DEPMOD,DETAIL,DETAIL1A,DETAIL2,DETAIL3,ER,FILLER1,FILLER2,FM(),GRP,LIST,LNADD,LNMOD,MYDESC(),NUMOFSIG,PRODATE,RECVR,RELACN,RELADD,RELDEL,RELMOD,ROLE,SORT,TAXREQ,TYP,VREL(),vovc1,vovc2
	type Number I
	type String V,VL

	set VL=""
	if 'vh(0) do VHDG0 quit:VFMQ
	if VLC+1>IOSL do VHDG0 quit:VFMQ

	set VL="T "
	set VL=VL_$J("",2-VL.length())_$E(BANKID,1,12)
	set VL=VL_$J("",14-VL.length())_$E(BATCHDT,1,8)
	do VP4 quit:VFMQ!verror.get()  set V=$E(FILLER2,1,198)
	set VL=VL_$J("",22-VL.length())_V
	do VOM
	quit

VOM	// Output print line
	type Public Number VLC
	type Public String IO,VL

	use IO
	write VL_$J("",69-VL.length()),!
	set VL="",VLC=VLC+1
	quit

	// Pre/post-processors

VP1	// Column pre-processor - Variable: DETAIL

	type public String vc1,vc2,vc3,vc4,vc5,vc6,vc7,vc8,vc9
 /*
   Build detail record based on fields SORT and KEY. All formatting needs
   to be done within this pre-proc because there are 4 different layouts for the
   detail record.
                           
   CUSTOMER RECORD LENGTH=679 DETAIL1,DETAIL1A
   ACCOUNT  RECORD LENGTH=372 DETAIL2
   RELATE   RECORD LENGTH=69  DETAIL3
   BILLPAY  RECORD LENGTH=69  DETAIL3
 */

 type public Number ACN,KEY,NUMOFSIG,TYPE,ZERO
 type public String BILLPAY,CLS,CUSADD,CUSMOD,BILMOD,DEPADD,DEPMOD,DETAIL,DETAIL1A,DETAIL2
 type public String DETAIL3,DMASK,fs,GRP,LNADD,LNMOD,N,RELADD,RELATE,RELDEL,RELMOD,SORT,SPC,X

 set (DETAIL,DETAIL1A,DETAIL2,DETAIL3)=""
 set DMASK="MMDDYEAR",SPC=" ",ZERO=0,fs=$C(9),N="N"
                          
 set SORT=vc1
 set KEY=vc2
 set ACN=vc3
 set BILLPAY=vc4
 set RELATE=vc5
 set CLS=vc6
 set GRP=vc7
 set TYPE=vc8
 set NUMOFSIG=vc9

 // Add/Modify Cust
 if (SORT=CUSADD)!(SORT=CUSMOD) do { quit
 	do CUST
 	set DETAIL1A=DETAIL.extract(501,679)
 	set DETAIL=DETAIL.extract(1,500)
 	}

 // Add/Mod Account
 if (SORT=DEPADD)!(SORT=DEPMOD)!(SORT=LNADD)!(SORT=LNMOD) do { quit
 	do ACT
 	set DETAIL2=DETAIL,DETAIL=""
 	}

 // Add/Modify/Delete Relationship
 if (SORT=RELADD)!(SORT=RELDEL)!(SORT=RELMOD) do { quit
 	do RELATE
 	set DETAIL3=DETAIL,DETAIL=""
 	}

 // BillPay Enablement
 if SORT=BILMOD do { quit
 	do BILLPAY
 	set DETAIL3=DETAIL,DETAIL=""
 	}

 quit
                          
BILLPAY // BillPay Enablement Update.
                         
 type public Number ACN
 type public String BILLPAY,DETAIL,KEY

 // Functions "100"
 set DETAIL="BRS"
 do FM(3,1,"U")			// Update indicator / Will always be an update
 do FM(4,32,KEY)			// Account Number
 do FM(36,32,$$CIN(ACN))	// Customer Number
 do FM(68,1,BILLPAY)		// Primary or Secondary owner

 quit
                          
RELATE // Add/Modify/Delete Account Relationship.

 type public Number ACN,CID
 type public String DETAIL,KEY,RELADD,RELATE,RELMOD,SORT,X
                          
 type Number tmpACN
                          
 // Functions "070,080,090"
 set tmpACN=ACN
 set CID=KEY.piece("#",1),ACN=KEY.piece("#",2)
 if RELATE="P" set ACN=tmpACN
 set DETAIL="RAS"
 set X=$S(SORT=RELADD:"A",SORT=RELMOD:"U",1:"D")
 do FM(3,1,X)				// Add/Update/Delete indicator
 do FM(4,32,CID)			// Account Number
 do FM(36,32,$$CIN(ACN))	// Customer Number
 do FM(68,1,RELATE)		// Primary or Secondary owner

 quit
                          
ACT // Add/Modify Account record. SORT=DEPADD,LNADD,DEPMOD,LNMOD

 type public Date BATCHDT,MDT,ODT,TJD
 type public Number ACN,AVLBAL,BAL,CRLMT,IRN,KEY,NUMOFSIG,TYPE,ZERO
 type public String ACCTNAME,ACNRELC,AD1,AD2,ADD,CITY,CLS,CRCD,DEPADD,DETAIL,DMASK
 type public String LNADD,MYDESC(),MZIP,N,nick,pdesc,SORT,SPC,STATE,TITLE1,URELATE,X,%CRCD
                          
 type String SUF
                          
 if CLS="D" do {
 	type RecordDEP dep=Db.getRecord("DEP","CID=:KEY",1)
 	set ACN=dep.acn
 	set ACCTNAME=dep.acctname
 	set BAL=dep.bal
 	set AVLBAL=dep.balavl
 	set ODT=dep.odt
 	set TITLE1=dep.title1
 	set ACNRELC=dep.acnrelc
 	set MDT=dep.mdt
 	set IRN=dep.irn
 	set CRCD=dep.crcd
 	}
 if CLS="L" do {
 	type RecordLN ln=Db.getRecord("LN","CID=:KEY",1)
 	set ACN=ln.acn
 	set ACCTNAME=ln.acctname
 	set BAL=ln.bal
 	set AVLBAL=ln.avlbal
 	set ODT=ln.odt
 	set TITLE1=ln.title1
 	set ACNRELC=ln.acnrelc
 	set MDT=ln.mdt
 	set IRN=ln.irn
 	set CRCD=ln.crcd
 	set CRLMT=ln.crlmt
 	}
 type RecordACNADDR acnaddr=Db.getRecord("ACNADDR","CID=:KEY",1)
 set AD1=acnaddr.ad1
 set AD2=acnaddr.ad2
 set CITY=acnaddr.city
 set STATE=acnaddr.state
 set MZIP=acnaddr.mzip
                          
 set ADD=$S(SORT=DEPADD:1,SORT=LNADD:1,1:0)
 if (CRCD.get()).isNull() set CRCD=%CRCD
                          
 set DETAIL="A L"				// Account Long record
 do FM(3,1,$S(ADD:"A",1:"M"))	// Add or Modify
 do FM(4,12,ZERO,N)			// Account ID (optional)
 do FM(16,32,KEY)				// Account Number
 do FM(48,32,$$CIN(ACN))		// Customer Ref (optional)
 do FM(80,4,ZERO,N)			// Status (Value=0000)
                          
 set SUF="S"
 if 'ACNRELC.isNull() do {
 	set SUF=URELATE(ACNRELC).get() quit:'SUF.isNull()
                          	
 	type Number CNT
                          	
 	set CNT=0
 	type ResultSet rs=Db.select("REQ","RELCODE","REL=:ACNRELC")
 	while rs.next() do {
 		set CNT=CNT+rs.getCol("REQ")
 		}
 	// S=SINGLE J=JOINT
 	set (SUF,URELATE(ACNRELC))=$S(CNT>1:"J",1:"S")
 	}
                          
 set X=TYPE_SUF
 set pdesc=((MYDESC(X).get()).piece("|",1)).extract(1,18)
 set nick=(MYDESC(X).get()).piece("|",2)
 if pdesc.isNull() do {
 	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE",1)
 	set pdesc=prodctl.des
 	if pdesc.isNull() set pdesc="UNKNOWN"
 	set pdesc=$$RTRIM^%ZS(pdesc.extract(1,18))
 	set MYDESC(TYPE_"S")=pdesc_"-IND|"_pdesc
 	set MYDESC(TYPE_"J")=$$RTRIM^%ZS(pdesc.extract(1,16))_"-JT|"_pdesc
 	set pdesc=MYDESC(X).piece("|",1),nick=MYDESC(X).piece("|",2)
 	}

 // ProductDesc (blank for mod)
 do FM(84,19,pdesc.piece("|",1),,ADD)
 if nick.isNull() set nick=pdesc
 if 'nick.isNull() do {
   type RecordTMPRPT3 tmprpt3=Db.getRecord("TMPRPT3","PID=:%ProcessID,KEY1='PDESC',KEY2=:ACN,KEY3=:nick",1)
   set X=tmprpt3.data+1
   do tmprpt3.bypassSave()
 	set nick=nick_"-"_X
 	}

 do FM(103,19,pdesc,,ADD)				// CustAcctDesc (blank for mod)
 do FM(122,4,NUMOFSIG,N)				// Number of signatures needed
 do FM(126,16,$S(CLS="D":0,1:CRLMT),N)	// InitialDeposit. dep=0 ln=credit limit
 do FM(142,16,0,N)						// Balance on VBM (MOD=0)
 do FM(158,16,BAL*100,N,ADD)			// Balance on PROFILE (MOD=0)
 do FM(174,16,AVLBAL*100,N,ADD)		// Available Balance (MOD=0)
 do FM(190,8,(IRN*10000)\1,N,ADD)		// Current Yield (MOD=0)
 do FM(198,8,SPC)						// Date of last update to VBM.
 do FM(198,8,$S(ADD:SPC,1:BATCHDT))	// Date of last update to VBM.
 do FM(206,8,ODT.toString(DMASK))		// Opening Date.
 do FM(214,8,ODT.toString(DMASK))		// Date account approved.

 if 'MDT.isNull() set X=MDT.toString(DMASK)
 else  do {
 	type Number D,M,Y,Z

 	set Y=TJD.toString("YEAR")+30
 	set M=TJD.toString("MM")
 	set D=TJD.toString("DD")
 	set Z=(Y_M_D).toString("YEARMMDD")
 	if Z>1 set X=Z.toString(DMASK) quit
 	set D=1,M=M+1
 	if M>12 set M=1,Y=Y+1
 	set M=$$RJ(M,2),D=$$RJ(D,2)
 	set Z=(Y_M_D).toString("YEARMMDD")
 	if Z>1 set X=Z.toString(DMASK) quit
 	}

 do FM(222,8,X)		// expireDate (maturity date)
 do FM(230,4,99,N)		// depositForm 99=UNKNOWN
 do FM(234,30,TITLE1)	// Name to print on statement
 do FM(264,30,AD1)		// Mailing address
 do FM(294,30,AD2)		// street address line 2
 do FM(324,25,CITY)
 do FM(349,2,STATE)
 do FM(351,5,MZIP.extract(1,5),N)
 do FM(356,4,MZIP.extract(7,10),N)
 do FM(360,12,ZERO,N)		// Filler

 quit
                          
RJ(NUM,LEN,DEC) //

 quit ($J(NUM,LEN,DEC.get())).translate(" ",0)
                          
CUST	// Add/Modify Customer record. SORT=CUSADD,CUSMOD

 type public Boolean BWF,ER,NR,TAXEXM
 type public Date DOB
 type public Number ACN,KEY,TAXREQ,TYPE,W9STAT,ZERO
 type public String ADD,BPH,CUSADD,DETAIL,DMASK,EMAIL,FAXNUM,FNAM,HPH,INC,LNM,MAD1,MAD2,MCITY,MNAM,MSTATE,MZIP,N,NAM,SORT,SPC,SSN,TAXID
                          
 set ACN=KEY
 type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN",1)
 if ER quit
 set NAM=cif.nam
 set LNM=cif.lnm
 set DOB=cif.dob
 set TAXID=cif.taxid
 set MAD1=cif.mad1
 set MAD2=cif.mad2
 set MCITY=cif.mcity
 set MSTATE=cif.mstate
 set MZIP=cif.mzip
 set EMAIL=cif.email
 set W9STAT=cif.w9stat
 set BWF=cif.bwf
 set NR=cif.nr
 set TAXEXM=cif.taxexm
 set HPH=cif.hph
 set BPH=cif.bph
 set FAXNUM=cif.faxnum
 set INC=cif.inc
 set TYPE=cif.type
                          
 set ADD=$S(SORT=CUSADD:1,1:0)
 // IF PERSONAL CIF set FNAM and MNAM to the firstname and middle initial
 set (FNAM,MNAM)=""
 if TYPE=0 set FNAM=NAM.piece(" ",1),MNAM=$S(NAM.length(" ")>2:NAM.piece(" ",2),1:"")
 set SSN=""
 if (TAXREQ),(TYPE=0) set SSN=TAXID,TAXID=""
                          
 set DETAIL="C L"
 do FM(3,1,$S(SORT=CUSADD:"A",1:"M"))	// Add or Modify
 do FM(4,32,$$CIN(ACN))		// CUSTOMER NUMBER
 do FM(36,20,FNAM)			// FIRST NAME
 do FM(56,1,MNAM)			// MIDDLE INITIAL
 do FM(57,20,LNM)			// LAST NAME
 do FM(77,20,SPC)			// Mothers Maiden Name
 do FM(97,8,DOB.toString(DMASK))	// Date of Birth
 do FM(105,11,SSN,,ADD)	// SSN
 do FM(116,30,MAD1)		// Addr 1
 do FM(146,30,MAD2)		// Addr 2
 do FM(176,25,MCITY)
 do FM(201,2,MSTATE)
 do FM(203,5,MZIP.extract(1,5),N)	// ZIP
 do FM(208,4,MZIP.extract(7,10),N)	// Zip +4
 do FM(212,49,EMAIL)
 do FM(261,20,TAXID)		// TaxPayerID
 do FM(281,1,$S(TAXID'="":1,1:0))	// TaxID confirmed
 do FM(282,1,BWF)			// Are Taxes Withheld ?
 do FM(283,1,TAXEXM)		// Is Customer Tax Exempt ?
 do FM(284,1,NR)			// NonResident ?
 do FM(285,1,ZERO)			// Joint Account ? (NO)
 do FM(286,8,SPC)			// PW Expire Date
 do FM(294,20,ZERO,N)		// Driver License #
 do FM(314,2,SPC)			// Driver License State
 do FM(316,12,HPH)			// Home Phone Number
 do FM(328,12,BPH)			// Work Phone Number
 do FM(340,12,FAXNUM)
 do FM(352,2,ZERO,N)		// Credit Bureau offer
 do FM(354,10,ZERO,N)		// Credit Bureau Beacon
 do FM(364,30,SPC)			// Previous Bank
 do FM(394,12,SPC)			// BillPay Regisration ID
 do FM(406,4,ZERO,N)		// BillSrlNo
 do FM(410,4,ZERO,N)		// CustStat
 do FM(414,4,ZERO,N)		// toBillPayerCnt
 do FM(418,4,SPC)			// PIN number
 do FM(422,12,SPC)			// CardBaseNum
 do FM(434,30,SPC)			// EmpName
 do FM(464,30,SPC)			// EmpAddr1
 do FM(494,30,SPC)			// EmpAddr2
 do FM(524,25,SPC)			// EmpCity
 do FM(549,2,SPC)			// EmpState
 do FM(551,5,ZERO,N)		// EmpZip1
 do FM(556,4,ZERO,N)		// EmpZip2
 do FM(560,12,SPC)			// EmpPhone
 do FM(572,4,ZERO,N)		// EmpLength
 do FM(576,4,SPC)			// EmpStat
 do FM(580,30,SPC)			// EmpIncome
 do FM(610,24,$$CIN(ACN))	// UserName
 do FM(634,27,SPC)			// Reserved
 do FM(661,18,SPC)			// Filler

 quit
                          
FM(OFF,LEN,FLD,FMT,ADD,FILL,JUS) //

 type public String BUF,DETAIL
                           
 type Number NEXT,STOP,STRT
 type String REPLY,X

 set REPLY=""
 if (LEN.get()).isNull() set LEN=FLD.length()
 // If ADD=0 then this is a modify and this field should be blanked out.
 if ADD.get()=0 set FLD="",FMT="A",FILL=" "
 set STRT=OFF+1
 set STOP=STRT+LEN-1
 set NEXT=STOP+1
 if (FMT.get()).isNull() set FMT="A"
 if (FILL.get()).isNull() set FILL=$S(FMT="A":" ",1:"0")
 set BUF.piece(FILL,LEN+1)=""
 if (JUS.get()).isNull() set JUS=$S(FMT="A":"L",1:"R")
 if JUS="L" set REPLY=FLD.extract(1,LEN)_BUF.extract(1,LEN-FLD.length())
 else  set REPLY=BUF.extract(1,LEN-FLD.length())_FLD.extract(1,LEN)
 set X=DETAIL
 set DETAIL=X.extract(1,OFF)_$J("",OFF-X.length())_REPLY_X.extract(NEXT,X.length())

 quit
 
CIN(KEY) //

 type String CIN

 set CIN="000000000000".extract(1,12-KEY.length())_KEY
 if CIN.length()<12 set CIN="7"_CIN
 set CIN="5081"_CIN

 quit CIN
	quit

VP2	// Column pre-processor - Variable: BATCHID

 type public String BATCHID
 
 set BATCHID=""
	quit

VP3	// Column pre-processor - Variable: FILLER1

 type public String FILLER1
 
 type Number I
 
 set FILLER1="0"
 for I=1:1:184 set FILLER1=FILLER1_"0"
	quit

VP4	// Column pre-processor - Variable: FILLER2

 type public String FILLER2
 
 type Number I
 
 set FILLER2="0"
 for I=1:1:197 set FILLER2=FILLER2_"0"
	quit
