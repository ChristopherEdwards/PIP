DEPDI
	/*
 	 PROCEDURE ID:	DEPDI
 	     Original:	
		 Date:	
	         Desc:	Deposit Account Computed Values

	---- Revision History ------------------------------------------------
	
	04/18/07 - RussellDS - CR26387
		   Eliminate use of UHFETCH.
		   
		   Eliminated call to DBSCHK, which is going to be obsoleted.
	
	12/21/06 - PUTTASWH - CR 24538
		   Added sections AEIA,STMCHK,IPP,HISTCHK and HISTCHK2.
		   
	05/15/06 - RussellDS - CR21296
		   Remove unnecessary reference to %CACHE.
		   
		   Cleaned up PSL warning issues.
	
	05/02/06 - RussellDS - CR20209
		   Modified ZDIPROC to replace obsoleted table MFIAEXT with
		   columns moved to CIFACCTS.
	
	04/28/06 - SkariahV - CR20553
		   Modified the section SIP to process the status of check
		   as "Deleted" if the check is Deleted.	
		   
	02/09/06 - BHOLT - CR19066
		   Replaced the call to MPLCT section of DBSDI in the 
		   section TCMT.
		   
	11/21/05 - PUTTASWH - CR17011
		   Removed the comments in SIP section that referred to
		   SCA337.RPT.
		   
	10/03/05 - RussellDS - CR16911
		   Fix error in ODAVLF section preventing proper return of
		   linked overdraft accounts' data.
		   
		   Cleaned up minor PSL warnings.
		   
		   Removed old revision history.

	08/31/05 - TITOVE - CR 16844
		   Modified section NEGEFD, removed "newing" of TJD to prevent
		   undefined when subsequently referencing %SystemDate. Also,
		   removed the words "ORDER BY" from select statements in INTPAID
		   and NEGEFD sections.

	07/27/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.
	
	06/04/04 - HillanbrandLE - CR 8006
		   Removed subsection AMTLD and added the logic in the 
		   XDEP05^DEPCDI subsection.  Corrected various other warnings
		   throughout the procedure and removed sections of code no longer
		   needed as coding calling these sections has either been move 
		   to the element that called it, replaced or was obsoleted.
	*/
	

	quit
	

Public ZDI(RecordDEP dep,CID,COMPUTE,OPT,TYPES,OWNER,NOIRA,CLOSED,EXTERNAL,POSBAL)
	/* This section is designed to allow users to create custom data items.
	Calls to this subroutine should be used as computed expression on 
	computed data items. For more information refer to ARQ 35500 - 
	Combined Commercial DDA Analysis. 

	ARGUMENTS:
		. dep Deposit account	TYP=RecordDEP/NOREQ (if CID is defined)

		. CID Account Number	TYP=N/NOREQ (if .dep is instantiated)

		. COMPUTE Custom computed data item name

		. OPT Average balance option (balance for the
			current service charge period)

			%AGG - The aggregate average balance
			%AVB - The highest average balance
			%AVC - The highest average collected balance

			%LB  - The highest low balance (intra-day)
			%LB1 - The highest low balance (end-of-day)

		. TYPES Product types included, comma separated

		. OWNER Include only those accounts owned by the customer
			(0 = no, 1 = yes, default = no)

		. NOIRA Exclude retirement accounts
			(0 = no, 1 = yes, default = no)

		. CLOSED  Include Closed Accounts in balance calc's
			(0 = no, 1 = yes, Default = no)

		. EXTERNAL  Include external account average balances
			(0 = no, 1 = yes, default = no)

		. POSBAL  Use absolute account balances value
			(0 = no, 1 = yes, default = no)

	INPUT:
		. %SystemDate

	RETURNS:
		. $$ Value of data item

	*/
	new RETURN

	if 'dep.exists() do {
		type RecordDEP tmpdep=Db.getRecord("DEP","CID",1)
		set RETURN=$$ZDIPROC(.tmpdep,COMPUTE,OPT,TYPES,OWNER,NOIRA,CLOSED,EXTERNAL,POSBAL)
	}
	else  set RETURN=$$ZDIPROC(.dep,COMPUTE,OPT,TYPES,OWNER,NOIRA,CLOSED,EXTERNAL,POSBAL)

	quit RETURN

ZDIPROC(RecordDEP dep,COMPUTE,OPT,TYPES,OWNER,NOIRA,CLOSED,EXTERNAL,POSBAL)
	// This is a private subroutine called from ZDI section.

	type Date %FD,NJD,ODT,%TD
	type Number ACN,ER="",CO,CTL
	type String ET,FRE,NV,UAVB,V,X,%ZTSEQ

	// Log MUMPs errors
	catch vError {
		set @COMPUTE=""
		do ZE^UTLERR
	}

	set CLOSED=$G(CLOSED)
	set POSBAL=$G(POSBAL)

	// Account Owner number
	set ACN=dep.acn
	if ACN="" set @COMPUTE="" quit ""

	// Open date
	set ODT=dep.odt

	set %TD=dep.scnd
	set %FD=dep.scld
	set FRE=dep.scfre
	if FRE="" set @COMPUTE="" quit ""

	// Calculate beginning date of the period (%FD)
	if %FD=""!(%FD=%SystemDate) do {  quit:ER
		set NJD=$$NJD^UFRE(%SystemDate,FRE,,1) quit:ER
		set %FD=ODT
		if (NJD+1)>%FD set %FD=NJD
	}

	if %FD'="",%FD'=ODT set %FD=%FD+1

	/*Don't want to add 1 if %FD equals the opening date,
	because opening date transactions will be skipped. */
	if %FD="" set @COMPUTE="" quit ""
	if %TD>%SystemDate set %TD=%SystemDate

	set TYPES=","_TYPES_","
	set OWNER=$G(OWNER)
	set NOIRA=$G(NOIRA)
	set CTL=$$CTL((OPT="%AVC"),CLOSED)
	set EXTERNAL=$G(EXTERNAL)
	set V=0

	type ResultSet rs=Db.select("CID","RELCIF","ACN=:ACN")
	if 'rs.isEmpty() while rs.next() do {
		new CID,CRCD,IRACLS

		set CID=rs.getCol(1)

		type RecordACN acn=Db.getRecord("ACN","CID",1)
		if 'acn.getMode() quit

		// Check that acct type is in computation
		if TYPES'[(","_acn.type_",") quit

		// Get currency of related account
		set CRCD=acn.crcd
		if 'CLOSED,dep.stat=4 quit

		// If NOIRA chosen and deposit class with RPA=1 quit
		if NOIRA,acn.cls="D",$$GETIRA(.acn) quit

		// Diff acct owner
		if OWNER,acn.acn'=ACN quit

		// Returns NV
		do INIT^UAVB(,CID,%FD,%TD,CTL) if ER do { quit
			do LOG^UTLEXC($T(+0),"*",$$^MSG(3467),CID,$G(%ZTSEQ),$G(ET),acn.bal)
			kill ET,%ZTSEQ
			}
		
		if OPT="%AGG" set NV=$P(UAVB(1),"|",1)
		else  if OPT="%AVB" set NV=$P(UAVB(1),"|",1)
		else  if OPT="%AVC" set NV=$P(UAVB(2),"|",3)
		else  if OPT="%LB" set NV=$P(UAVB(1),"|",5)
		else  if OPT="%LB1" set NV=$P(UAVB(1),"|",6)

		// If neg bal., make pos for fee
		if (NV<0)&(POSBAL) set NV=-NV
		// Convert acct bal to system base
		if CRCD'=%SystemCurrency do {
			set NV=$$CONV^CRCDUTL(NV,%SystemCurrency,CRCD,1)
			set NV=$$^SCARND(NV,0,,%SystemCurrency)
		}
		// Aggregate balance
		if OPT="%AGG" set V=V+NV
		// Highest balance
		else  if NV>V set V=NV
	}

	/* When using the EXTERNAL option the file ^CIFACCTS must be set up and
	maintained using an external interface to populate this file.  
	If the currency code or average external balance field is not defined 
	for an external account, the account will not be considered in 
	calculations.	*/

	if EXTERNAL do {
		new CRCD
		type ResultSet rs=Db.select("CRCD,AVGBAL","CIFACCTS","ACN=:ACN")
		if 'rs.isEmpty() while rs.next() do {
			set CRCD=rs.getCol("CRCD")
			// External account currency
			if CRCD="" quit
			set NV=rs.getCol("AVGBAL")
			// External account Avg balance
			if NV="" quit

			// If neg bal, make it positive
			if (NV<0)&(POSBAL) set NV=-NV
			if CRCD'=%SystemCurrency do {
				// Convert ext acct bal to system base
				set NV=$$CONV^CRCDUTL(NV,%SystemCurrency,CRCD,1)
				// Round to systembase
				set NV=$$^SCARND(NV,0,,%SystemCurrency)
			}
			//Aggregate Balance inclung External accounts
			if OPT="%AGG" set V=V+NV
			//Highest Balance External accounts
			else  if NV>V set V=NV
		}
	}
	set @COMPUTE=V
	quit V


GETIRA(RecordDEP dep)
	// Returns RPA Type
	quit dep.ira


Public BRREG
	/* Get region associated with an account, based on BOO

	Called by IRS* routines which have not been converted yet.
	Suggest removing this tag and add the coding in the IRS* routines.

	Input:
		. CID		Account number	/TYP=N
	Returns:
		. BRREG		Region		/TYP=T
	*/

	type Public String BRREG=""
	type Public Number CID
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
	if dep.boo="" quit

	type RecordUTBLBRCD ubrcd=Db.getRecord("UTBLBRCD",dep.boo,1)
	set BRREG=ubrcd.region

	quit


Public SIP
	/* ARS Status in period	

	Input: 
		. CID	Account number		/TYP=N
		. CKNO	Check number		/TYP=T
		. FDT	From Date, Included	/TYP=D
		. TDT	To Date, NOT Included 	/TYP=D

	Returns:
		. SIP	Status
	*/
	type Public Date FDT,TDT
	type Public Number CID,SIP
	type Public String CKNO

	// No Status
	set SIP=6

	type RecordARS ars=Db.getRecord("ARS","CID,CKNO",1)
	if 'ars.getMode() quit

	// Issued
	if ars.iactdt,ars.iactdt'<FDT,ars.iactdt<TDT set SIP=0
	// Paid
	if ars.iactdt,ars.iactdt<TDT,ars.pactdt,ars.pactdt'<FDT,ars.pactdt<TDT set SIP=4 quit
	// Void
	if ars.vactdt,ars.vactdt'<FDT,ars.vactdt<TDT set SIP=1
	// Paid, Not Issued
	if ars.pactdt,ars.pactdt'<FDT,ars.pactdt<TDT set SIP=3
	// Deleted
	if ars.ddt,ars.ddt'<FDT,ars.ddt<TDT set SIP=2
	
	quit


Public STRIP(NAME,VALUE,LT)	// Strip leading/trailing spaces from data items
	/* Parameters:
		NAME  - Name of variable to be returned
		VALUE - Raw data value to be stripped
		LT    - Strip L(eading) or T(railing) spaces
	   Called from reports: SCA345,SCA346,SCA347 and SCA349
	*/

	// Strip leading spaces
	if LT="L" set @NAME=$$LTRIM^%ZS(VALUE) quit
	// Strip trailing spaces
	if LT="T" set @NAME=$$RTRIM^%ZS(VALUE) quit

	set @NAME=""

	quit


Public EQV(BSE,AMT,SEC,CID)
	/* Convert AMT from BSE (account) currency to SEC (base or customer)
	   currency.

	ARGUMENTS:
		. BSE Account currency
		. AMT Amount to be converted to base currency
		. SEC Null if bank's base currency is to be used 
			ACN if customer's currency is to be used
		. CID Account number (need for loans only)
	OUTPUT:
		. $$ Equivalent value

	Called by computed data items.
	*/
	new CC,dp,T

	set BSE=$G(BSE)
	set AMT=$G(AMT)
	set SEC=$G(SEC)
	if SEC'="" do {
		type RecordCIF cif=Db.getRecord("CIF","SEC",1)
		set SEC=cif.crcd
	}

	if AMT="BALCMP" do {
		// Comes in to this "if" only if called from LN
		type RecordLN ln=Db.getRecord("LN","CID",1)
		if 'ln.getMode() quit

		if 'ln.aruf do {
			new LNTYPE
			set LNTYPE=ln.type
			type RecordPRODDFTL proddftl=Db.getRecord("PRODDFTL","TYPE=:LNTYPE",1)
			set ln.aruf=proddftl.aruf
		}

		set AMT=$S(ln.aruf=0:ln.bal,1:ln.bal-ln.udbal)
	}
	//Default currency code
	if BSE="" set BSE=%SystemCurrency
	if SEC="" set SEC=%SystemCurrency
	if SEC'=BSE do CAMT^CRCDUTL(BSE,SEC,.AMT)

	quit AMT


Public TCMT
	/* Expand teller comment
	
	Called by Reports SCA166, SCA310 and SCA662.  Also called by Procedure
	HISTP.

	Output:
		. TCMT		Teller comment	/TYP=T
		Format:  Description ":" old value ":" new value ":" comment
	*/
	type Number ER=""
	type String CMNT,DFID,DLIB,DDI,FID,I,LIB
	type public Number Z
	type public String DF(),DL(),%LIBS,MPLCT(,),TCMT
	
	for I=2,3 if $P(TCMT,":",I)="" set $P(TCMT,":",I)="Null"
	set DLIB="SYSDEV"
	set DFID=$P(TCMT,"[",2)
	set DFID=$P(DFID,"]",1)
	quit:DFID=""

	if DFID["," set DLIB=$P(DFID,",",1),DFID=$P(DFID,",",2)
	set LIB=DLIB
	set FID=DFID
		
	set MPLCT(DLIB,DFID)=LIB_"|"_FID
	if 'MPLCT(DLIB,DFID).get() do { 
		if 'DLIB.get() set DLIB="" if DLIB.isNull() set DLIB=%LIBS
		if 'LIB.get() set LIB="" if LIB.isNull() set LIB=DLIB
		set DL(0)=DLIB,DF(0)=DFID,Z=0
		}
	quit:ER
	if DFID="*" set TCMT=$TR(TCMT,"[]","<>") quit
	set DLIB=$P(MPLCT(DLIB,DFID),"|",1)
	set DFID=$P(MPLCT(DLIB,DFID),"|",2)

	set DDI=$P($P(TCMT,"]",2),":",1)

	type RecordDBTBL1D dbtbl1d=Db.getRecord("DBTBL1D","DLIB,DFID,DDI",1)
	if 'dbtbl1d.getMode() quit

	if dbtbl1d.typ="D" for I=2,3 if $P(TCMT,":",I) set $P(TCMT,":",I)=$$DAT^%ZM($P(TCMT,":",I))
	set CMNT=$P(TCMT,":",4)
	set TCMT=dbtbl1d.des_":"_$P(TCMT,":",2,3)
	if CMNT'="" set TCMT=TCMT_":"_CMNT

	quit


DINAM(str)	// Find out if this is an FM record or not
	// Private. Called from TCMT
	if '$F(str,"[") quit 0
	if '$F(str,"]") quit 0

	quit 1


Public STM
	/* Calculate Account Statement Information
	
	Called by Procedures LETSTINI and UARCHIST which should be changed
	to pass CID as a parameter.
	
	Inputs:
		CID		Account number

	Outputs:
		. SFRE		Statement frequency
		. SNDT		Statement next date
		. SLDT		Statement last date
		. STPR		Statement prior date
		. XCF01		Account Statement Information
	*/
	type Date SLDT,SNDT
	type Number ACN
	type String GRP,SFRE,STPR
	type Public Number CID
	type Public String XCF01
	

	// Get a customer number
	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	if 'acn.getMode() quit
	set ACN=acn.acn

	// Get a Statement Group
	type RecordCMBCID cmbcid=Db.getRecord("CMBCID","CID=:CID,ACN=:ACN",1)
	if 'cmbcid.getMode() quit
	set GRP=cmbcid.stmgrp

	// Get Statement - Next Date and Statement Frequency
	type RecordCMBGRP cmbgrp=Db.getRecord("CMBGRP","ACN=:ACN,STMGRP=:GRP",1)
	if 'cmbgrp.getMode() quit
	set SNDT=cmbgrp.sndt
	set SFRE=cmbgrp.sfre

	// Get Statement - Next Date and Statement Frequency
	type RecordCMBSTM cmbstm=Db.getRecord("CMBSTM","ACN=:ACN,STMGRP=:GRP,CID=:CID",1)
	if 'cmbstm.getMode() quit
	set SLDT=cmbstm.sltd
	set STPR=cmbstm.stpr

	set XCF01=SNDT_"|"_SLDT_"|"_STPR_"|"_SFRE

	quit


Public CNTD(FILEID,X)	//
	/*
	Parameters:   	FID - File Id e.g., LN for Loan Account Master file
			X   - Data item name

	Purpose:      This routine will check the data dictionary to make
		sure that the data item specified by the variable X
		exists in the file specified by the variable FILEID,
		and it is a logical data item.

	Called by:	UTBLCNTL - Closeout Notification Table - Loans
			UTBLCNTD - Closeout Notification Table - Deposits
	*/
	
	type public String RM=""
	type public Number ER=""
	
	if 'Db.isSchemaColumn(FILEID, X) do {
	
		set ER = 1
		// Invalid Data Item ~P1
		set RM = $$^MSG(1298, FILEID_"."_X)
	}
	
	else  do {
	
		type PSLColumn colrec = PSL.getPSLColumn(FILEID, X)
	
		if (colrec.dataType '= "L") do {
		
			set ER = 1
			// Data item selected is not a logical data item
			set RM = $$^MSG(734)
		}
	}

	quit


Public ODDEP(CID)	// Calculate the total available balance OD deposits

	type Number TOTBAL
	type Number ER=""

	set TOTBAL=0

	type ResultSet rs=Db.select("DEP.BALAVL","DEPODP,DEP","DEP.CID=DEPODP.ODACN AND DEPODP.CID=:CID")
	if rs.isEmpty() quit TOTBAL
	while rs.next() quit:ER  set TOTBAL=TOTBAL+rs.getCol(1)

	quit TOTBAL


Public ODLN(CID)	// Calculate the total available OD loan balance

	type Number TOTBAL
	type Number ER=""

	set TOTBAL=0

	// Select available balances of all
	type ResultSet rs=Db.select("LN.AVLBAL","DEPODP,LN","LN.CID=DEPODP.ODACN AND DEPODP.CID=:CID")
	if rs.isEmpty() quit TOTBAL
	while rs.next() quit:ER  set TOTBAL=TOTBAL+rs.getCol(1)

	quit TOTBAL


Public ODAVLF(CID,TCLS)	// Calculate the total available OD funds 

	new BALAVL,BCRCD,BCUSTCD,CC,CLS,CCODE,ODACCNTS
	
	type Public Number ER=""

	set TCLS=$G(TCLS)
	set BALAVL=0

	type RecordACN acn = Db.getRecord("ACN", "CID=:CID", 1)

	set BCRCD = acn.crcd
	set BCUSTCD = +acn.ccode      // Force default to zero

	if BCRCD.isNull() set BCRCD = %SystemCurrency

	type ResultSet rs=Db.select("ODACN","DEPODP","CID=:CID")
	if rs.isEmpty() quit BALAVL
	while rs.next() do { quit:ER
		new BAL,CRCD,ODACN
		set ODACN=rs.getCol(1)

		type RecordACN acn=Db.getRecord("ACN","ODACN")
		if 'acn.getMode() quit

		set CLS=acn.cls

		if TCLS="L"!(TCLS="D"),(TCLS'=CLS) quit

		/* Select available balance based on account type.
		 CRCD is needed for MC^TTXODC.  CRCD should at some
		 time should be passed to MC^TTXODC when the change is made to 
		 TTXODC.
		*/
		if CLS="L" do {
			type RecordLN ln=Db.getRecord("LN","ODACN",1)
			set BAL=ln.avlbal
			set CRCD=ln.crcd
		}
		if CLS="D" do {
			type RecordDEP dep=Db.getRecord("DEP","ODACN",1)
			set BAL=dep.balavl
			set CRCD=dep.crcd
		}
		quit:(BAL="")!(BAL'>0)

		set BALAVL=BALAVL+$$MC^TTXODC(.acn,BAL)
	}

	quit BALAVL


ODLBAL(CID)	// Calculate the total OD loan balance

	type Number ER,ODACN,ODLBAL,TOTBAL
	set ER=""
	set ODACN=0
	set ODLBAL=0
	set TOTBAL=0

	type ResultSet rs=Db.select("ODACN","DEPODP","CID=:CID")
	if rs.isEmpty() quit TOTBAL
	while rs.next() do { quit:ER

		set ODACN=rs.getCol(1)

		type RecordLN ln=Db.getRecord("LN","ODACN",1)
		
		if ln.stat=4 set ODLBAL=0
		else  set ODLBAL=$S('ln.aruf:ln.bal,1:ln.bal-ln.udbal)
		
		set TOTBAL=TOTBAL+ODLBAL
	}

	quit TOTBAL


Public INTPAID(CID,FD,TD)
	/* Called internally and from BCHFEEUTL.
	Inputs -
		CID - Account Number
		FD - Starting Date
		TD - Ending Date
	Returns -
		$$ total paid to account between starting and ending dates.

	Collate through History to get amounts paid
	*/
	new CRCD,DEFAULT,DONE,EFD,ETC,IPDTRN,PAID,TYPE

	if TD=""!(TD>%SystemDate) set TD=%SystemDate
	set DONE=0
	set PAID=0
	set DEFAULT=0

	type RecordDEP dep=Db.getRecord("DEP","CID")
	if 'dep.getMode() quit 0
	set TYPE=dep.type
	set CRCD=dep.crcd

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
	if 'prodctl.getMode() quit 0

	// Increase Interest PD Trn Code
	set IPDTRN=prodctl.crtrin
	// Default TRN Code
	if IPDTRN="" set IPDTRN=prodctl.crtrgp set DEFAULT=1

	// Select only last periods
	type ResultSet rs=Db.select("TJD,EFD,ETC,TSO,TAMT","HIST","CID=:CID AND TJD>=:FD","TSEQ DESC")
	if 'rs.isEmpty() while rs.next() do { quit:DONE
		set EFD=rs.getCol(2)
		if EFD="" set EFD=rs.getCol(1)

		// Only want if EFD is in that Period
		if %EffectiveDate<FD!(%EffectiveDate>TD) quit
		set ETC=rs.getCol(3)

		// only interested in the one tran code
		if ETC'=IPDTRN quit

		// Default Tran Code
		if DEFAULT,$E(rs.getCol(4),1,3)'="INT" quit

		// Just what went to Principle
		set PAID=PAID+rs.getCol(5)
	}

	quit PAID





Public SRV(CID,FD,TD,ARRAY,PLTP)
	/* Returns all Scheduled fees for accounts for the specified period
	
	Called by Procedure LETSTMTCMB which does not check for errors.  Suggest
	putting this code in the procedure and perhpas the procedure should quit
	if an error is defined.
	
	Inputs -
		CID - Account Number
		FD - Start Date
		TD - Stop Date
		ARRAY - Array to load data into
	        PLTP - Plan Type
	Returns -
		TOTFEE = Total Charge During Period
		ARRAY in following format:
	Piece		Description		Item

	1		Date   		[SRVD]SCND
	2		Fee Category  	[SRVD]FEECAT
	3		Fee Type  	[SRVD]FEETYPE
	4		Amount  	[SRVD]SRVCSTA
	5		Description  	[FEESRV]DESC
	*/
	new BASEAMT,DESC,FEECAT,FEETYP,MAXAMT,PLAN,SCND,SCNDBASE,SCNDNEXT,SRVCSTA,X
	
	type Public Number ER=""
	type Public String RM
	
	set SCND=""
	set FEECAT=""
	set FEETYP=""
	set PLTP=+$G(PLTP)

	type ResultSet rs=Db.select("PLTP,SCND","SRV","CID=:CID")
	if rs.isEmpty() quit

	set SCND=FD-1
	// Start at the Begining
	if SCND<0 set SCND=""
	if TD="" set TD=%SystemDate
	// Bad From or to Dates
	//Bad From or to Dates
	if TD<FD set ER=1 set RM=$$^MSG(7826) quit


	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
	// Invalid account ~p1
	if 'dep.getMode() do Runtime.setErrMSG("DEP",1259,CID) quit

	if 'PLTP set PLAN=dep.feepln
	// credit usage plan
	else  set PLAN=dep.uspl
	// No Service Plan Defined
	if PLAN="" set ER=1 set RM=$$^MSG(7830) quit

	type ResultSet rssrv=Db.select("SCND,FEEACT,SYSADJ","SRV","CID=:CID AND PLTP=:PLTP AND SCND>:SCND")
	if 'rssrv.isEmpty() while rssrv.next() do { quit:SCND>TD

		set FEECAT=""
		set FEETYP=""

		set SCND=rssrv.getCol(1)
		set SCNDNEXT=SCND+1
		type ResultSet rs = Db.select("MAX(SCND)", "SRVH", "FEEPLN=:PLAN AND SCND<:SCNDNEXT")
		quit:rs.isEmpty()
		if rs.next() set SCNDBASE = rs.getCol(1)
		quit:SCNDBASE.isNull()

		type RecordSRVH srvh=Db.getRecord("SRVH","FEEPLN=:PLAN,SCND=:SCNDBASE",1)
		set BASEAMT=srvh.base

		set MAXAMT=rssrv.getCol(2)

		// Base Fee
		set DESC=$$^MSG(7827)
		if MAXAMT<BASEAMT set BASEAMT=MAXAMT set DESC="*"_DESC
		set MAXAMT=MAXAMT-BASEAMT
		set SRVCSTA=BASEAMT
		set X=SCNDBASE_"|"_FEECAT_"|"_FEETYP_"|"_SRVCSTA_"|"_DESC
		if SRVCSTA set ARRAY($O(ARRAY(""),-1)+1)=X

		//Adjustment
		set DESC=$$^MSG(7832)
		set SRVCSTA=rssrv.getCol(3)
		set X=SCNDBASE_"|"_FEECAT_"|"_FEETYP_"|"_SRVCSTA_"|"_DESC
		if SRVCSTA>0 set ARRAY($O(ARRAY(""),-1)+1)=X

		type ResultSet rssrvd=Db.select("FEETYP,SRVCSTA,FEECAT","SRVD","CID=:CID AND PLTP=:PLTP AND SCND=:PLTP")
		if 'rssrvd.isEmpty() while rssrvd.next() do {
			set FEETYP=rssrvd.getCol(1)
			set SRVCSTA=rssrvd.getCol(2)
			set FEECAT=rssrvd.getCol(3)

			set DESC=$$DESC^SRVPLN(FEECAT,FEETYP,SCND)
			//Not Applicable
			if DESC="" set DESC=$$^MSG(7833)

			if MAXAMT<SRVCSTA set SRVCSTA=MAXAMT set DESC="*"_DESC
			set MAXAMT=MAXAMT-SRVCSTA
			// No Fee Charges
			if 'SRVCSTA quit

			set X=SCND_"|"_FEECAT_"|"_FEETYP_"|"_SRVCSTA_"|"_DESC
			set ARRAY($O(ARRAY(""),-1)+1)=X
		}
	}
	quit


Public ARMDT(CID)
	/* Returns the Anticipated Renewal Maturity Date for Deposit
	Accounts to comply with regualtion DD so that maturity notices
	can display this date for the next term should the depositor
	decide to renew the account.

	Calculation will be based on three methods.  The first method
	to succesfully provide a valid renewal maturity date or renewal
	term will be used to compute ARMDT.

	Inputs -
		CID - Account Number/REQ
	Returns -
		ARMDT - Anticipated Renewal Maturity Date
	*/
	type String ARMDT,BUSOPT,DFTGRP,MDT,NBDC,ROLL,ROLLMDT,ROLLTRM,TRM
	type Number ER=""

	set ARMDT=""

	type RecordDEP dep=Db.getRecord("DEP","CID",1)
	if 'dep.getMode() quit ARMDT

	if dep.mdt="",dep.trm="" quit ARMDT

	type RecordROLLOVR rollovr=Db.getRecord("ROLLOVR","CID=:CID",1)
	set ROLL=rollovr.trm_$C(9)_rollovr.mdt

	// Method 1 - check for MDT or TRM from rollover data on node 65.
	set BUSOPT=dep.busopt
	set NBDC=dep.nbdc
	set ROLLMDT=$P(ROLL,$C(9),2)
	// If MDT exist, then ARMDT=MDT
	if ROLLMDT?5N set ARMDT=ROLLMDT quit ARMDT

	set ROLLTRM=$P(ROLL,$C(9),1)
	// If TDR exists, calculate MDT
	if ROLLTRM'="" do { if ER quit ""
		// and set ARMDT from this MDT
		set TRM=ROLLTRM
		// should equal current MDT
		set MDT=$$EXT^UMDT(TRM,dep.mdt,0,BUSOPT,NBDC) if ER quit ""
		if MDT'?5N quit
		set ARMDT=MDT
	}
	if ARMDT'="" quit ARMDT

	// Method 2 - check for MDT or TRM from the default user group table
	// Renewal Default Group
	set DFTGRP=dep.dftmdt
	if DFTGRP'="" do {
		new DFTDI,DFTTYP,VALUE
		set DFTTYP="MDT"

		type ResultSet rs = Db.select("DINAM,VALUE","UTBLDFT","DFTTYP=:DFTTYP AND DFTGRP=:DFTGRP")
		while rs.next() do { quit:ARMDT'=""
			set DFTDI=rs.getCol(1)
			set VALUE=rs.getCol(2)

			if (DFTDI["MDT"),(VALUE?5N) set ARMDT=VALUE quit

			if DFTDI["TRM" do {
				set TRM=VALUE
				// maturity date.  ARMDT will
				set MDT=$$EXT^UMDT(TRM,dep.mdt,0,BUSOPT,NBDC) if ER quit
				// be the new term length +
				if MDT'?5N quit
				// current MDT.
				set ARMDT=MDT
			}
		}
	}

	if ARMDT'="" quit ARMDT

	// Method 3 - Use the current account term and add in onto the current
	//            maturity date
	set TRM=dep.trm
	set MDT=$$EXT^UMDT(TRM,dep.mdt,0,BUSOPT,NBDC) if ER quit ARMDT
	if MDT'?5N quit ""
	quit MDT


CTL(OPT,CLOSED)	//Set CTL for UAVB ... called from ZDI() above
	new CTL
	set OPT=+$G(OPT)
	set CLOSED=+$G(CLOSED)
	if 'OPT,'CLOSED quit ""

	set CTL="00"_OPT
	if CLOSED set CTL=CTL_"0001"
	if 'CTL quit ""
	quit CTL


public	NEGEFD(CID)	// Negative Effective Date

	/* 
	  Computes the date as of the end of day balance that the account
	  went negative if the current account balance is negative.

	  ARGUMENTS:
			. CID Account number
	  OUTPUT:
			. $$ Negative Effective Date
	*/
	
	type Date %EffectiveDate, EJD, OLDDT
	type Number BAL, DC, PRN, SAVBAL
	type String NEGEFD, TAMT

	set NEGEFD=""

	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	
	if 'acn.getMode() quit NEGEFD

	set (SAVBAL,BAL)=acn.bal

	if BAL'<0 quit NEGEFD
	
	set BAL(%SystemDate)="|"_BAL
	set OLDDT=%SystemDate

	// Select history records, excluding file maintenance and error correct
	// or reversal
	type ResultSet rs=Db.select("TAMT,ITC1,ITC6,ITC12,TJD,EFD","HIST","CID=:CID AND ITC IS NOT NULL","TJD DESC")

	if rs.isEmpty() quit NEGEFD

	while rs.next() do { quit:NEGEFD
		
		// Skip Reversal/Error Correct transactions
		if rs.getCol("ITC6") ! rs.getCol("ITC12") quit
		
		set DC=rs.getCol("ITC1")
		set TAMT=rs.getCol("TAMT")
		set EJD=rs.getCol("TJD")

		set PRN=+TAMT
		
		if TAMT["#" set PRN=TAMT.piece("#",2)
		
		set %EffectiveDate=rs.getCol("EFD")
		
		if %EffectiveDate.isNull() set %EffectiveDate=EJD
		
		if 'DC set PRN=-PRN
		
		if BAL(%EffectiveDate).get().isNull() set BAL(%EffectiveDate).piece("|",2)=BAL(BAL(%EffectiveDate).order()).piece("|",2)
		
		set BAL(%EffectiveDate).piece("|",1)=BAL(%EffectiveDate)+PRN
		
		if OLDDT'=EJD do CHECK(OLDDT,SAVBAL,.NEGEFD,.BAL)
		
		set OLDDT=EJD
		}

	if 'NEGEFD do {
		
		set OLDDT=""
		
		do CHECK(OLDDT,SAVBAL,.NEGEFD,.BAL)
		
		if 'NEGEFD set NEGEFD = BAL("").order()
		}

	quit NEGEFD
	

CHECK(OLDDT,SAVBAL,NEGEFD,BAL)	//

	type Date JD
	type Number PRN
	type String N=""
	
	set JD=""
	set PRN=0
	set BAL=SAVBAL
	for  set JD=$O(BAL(JD),-1) quit:JD=""  quit:JD<OLDDT  do {
		set BAL=BAL-PRN
		set $P(BAL(JD),"|",2)=BAL
		set PRN=+BAL(JD)
		if $P(BAL(JD),"|",2)<0 do {
			set N=$O(BAL(JD),-1) if N="" quit
			if 'NEGEFD,(BAL-PRN'<0) set NEGEFD=JD
		}
	}
	quit
	
public AEIA(Number CID,		// Account Number
	Number IPP,		// Interest Paid Last Staement Period
	Date SLDT,		 
	Date SNDT)		
	//Calculate Actual Earned Interest Acrrued
	/*
	Returns -
		AEIA - Actual Earned Interest Accrued
		[DEP]AEIA=[DEP]IPP+[DEP]ACR-[HIST0]ACRCF
	*/
	
	type public Boolean ER
	type Date ITJD
	type Number AEIA,EACR
	
	set EACR=0
	
	if SLDT.get().isNull() do STM,STMCHK
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
	
	if IPP.get().isNull() set IPP=$$IPP(CID,SLDT,SNDT)
	
	if SNDT<%SystemDate do {
		set ITJD=SNDT
		
		type RecordHIST0 hist0 = Db.getRecord("HIST0", "CID=:CID,JD=:ITJD", 1)
		
		set EACR = +hist0.acrcf
		}
	
	if SNDT'<%SystemDate set EACR=dep.posacr
	
	// No Ending Accrual figure
	if EACR.isNull() set ER=1 do Runtime.setErrMSG("DEP",7829) quit ""
	
	set AEIA=IPP+EACR
	if SLDT.get().isNull() quit IPP
	set ITJD=(SLDT-1)
	
	type RecordHIST0 hist0 = Db.getRecord("HIST0", "CID=:CID,JD=:ITJD", 1)
	
	set AEIA=AEIA - hist0.acrcf
	
	if AEIA<0 quit 0
	quit AEIA

public STMCHK
	// Check Values recieved from STM linetag
	
	type public Boolean ER
	type public Date SLDT,SNDT
	type public Number CID
	type public String SFRE
	
	if SLDT.get().isNull() do {
		set SLDT=$$NJD^UFRE(SNDT,SFRE,,1) quit:ER
		
		type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
		if SLDT<dep.odt set SLDT=dep.odt	// Take ODT if before date we've found	
		}
	
	if SNDT.get().isNull()!(SNDT.get()>%SystemDate) set SNDT=%SystemDate
	
	quit	

IPP(Number CID,
	Date SLDT,
	Date SNDT)	
	// Interest Paid This Period
	
	type Number IPP
	
	if SLDT.get().isNull() do STM,STMCHK	// Get statement date
	
	set IPP=$$INTPAID(CID,SLDT,SNDT)
	quit IPP
	
public HISTCHK(Number CID,	// Account Number
	Date FD,		// Start Date
	Date TD)		// End Date
	/*
	Pre-Processor to make sure SNDT and SLDT accrual figures 
	are stored somewhere. If not, we can not run Reg DD Statements.
	
	Returns -
		1 - Okay to run REG DD report
		0 - Not Okay to run REG DD report
	*/
	
	if CID.get().isNull() quit 0
	if '$$HISTCHK2(FD-1) quit 0	
	if '$$HISTCHK2(TD) quit 0	
	quit 1
	
HISTCHK2(Date DATE)	// Date to check in History	
	/*
	Returns -
		1 - Okay to run REG DD report (for this item)
		0 - Not Okay to run REG DD report (for this item)
	*/
	
	type public Number CID
		
	if DATE.get().isNull() quit 0	// Make sure all field defined
	if DATE=%SystemDate quit 1
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
	
	if DATE<dep.odt quit 1		// Accrual=0
	
	if dep.dtc,(DATE>dep.dtc) quit 1	// Accrual=0
	
	type RecordHIST0 hist0=Db.getRecord("HIST0","CID=:CID,JD=:DATE",1)
	
	if hist0.acrcf.isNull() quit 0
	quit 1
 #OPTION ResultClass ON
Public String vSIG()	quit "60746^62845^Dan Russell^25887"	// Signature - LTD^TIME^USER^SIZE
