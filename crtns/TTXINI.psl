TTXINI		//;Initialize TTX file for batch processing
	/*
	   ORIG: Michael Winigrad
	
	  ---- Revision History ------------------------------------------------
	   
	   08/21/07 - SATYANAS - 28013
	   	      Modified the CMP section to put the condition if CMPERR array
	   	      contains "PSL-E" then set ER=1.
	   
	   03/01/06 - SATYANAS - 19687
	   	      Changed the Code for the below sections to fix the
	   	      run time error while exectuing the Function TTXINI.

		EXEC	: Declared the MODE as a public String because of getting the runtime error.
		
		FILEDUMP: Declare the LOOKUP() as a String because of after executing @TTXINI, 
			  the lookup were not coming for Input RMS File Name Field. 
			  And also scoping the other variable correctly.
		  	  Set SPL=CUVAR.spldir because it is throwing the runtime error SPL.
		  	  Replaced $$DAT^%ZM by .toString() method.
		  	  In the line set %TAB("TDRV"), changed PP02^ZTTXINI to PP02^TTXINI.

		IODUMP	: Declare IO as public. In the line set %TAB("IODUMP"), changed 
			  S %EXT=1 to set %EXT=1.
		  	  Added set %READ="IODUMP/REQ",%NOPRMT="N", because if select the Filed
		  	  Perform File Dump to Y, then  File Dump Device Field was not coming.
		  	  
		CMP	: Changed the entire Code to load the code in procedure TTXFMT
	   	  	  into the CODEBASE array, then load either the code in the custom procedure
	   	  	  OR the standard procedure into CODEFMT, then merge the two into CODE, with 
	   	  	  CODEFMT being inserted into the section marked FMT in CODEBASE.

		PP00	: Declared the MODE as public.
		PP02	: Declared CNT as public.
		
		PP03	: Assigned the value of SPLDIR to X.
			  
		RECCHK	: Declared the LOOKUP array as public, because the lookup were not coming
			  for the filed Input RMS File Name.
	   
	   12/28/05 - PRAKASHJ - 17423
		      Removed depricated warnings and scoped variables. 
	
	   12/29/03 - CARROLLJ - CR7658
		      Added #ACCEPT prior to setting system variable.

	   01/28/02 - SCOTTC - 43583
		Convert to PSL.  Remove history prior to 2001.

	   02/26/01 - GALEONET - 43724
	        Modified post processor for log file to quit
	              if there's an error opening the file selected.
	
	  ----------------------------------------------------------------------
	*/
	do INIT	
	quit
	
INIT	

	type String ZPGM
	type public String %ED,%NODE,CONAM
	
	set ZPGM="TMP"_(%ProcessID#100000)
	if '%ED.get() set %ED="" 
	if '%InputTimeOut.get() set %InputTimeOut=60  
	if 'CONAM.get() set CONAM=""
	set %NODE=%NODE.get()
	set %ProcessMode=0
	do EXEC
	quit

EXEC
	
	type public Boolean ER
	type public Number OLNTB
	type String %TAB(),INPUT,SOURCE(),%PAGE,%PG,%READ,%NOPRMT,MODE
	type public String CMP,FILEDUMP,FDUMP,IODUMP,VFMQ
	
	set %TAB("SRC")=".SRC3/TBL=[CTBLINC]KEY"
	set %TAB("INPUT")=".INPUT1/TBL=SOURCE(/XPP=do PP00^TTXINI" 
	set INPUT="R"

	kill OLNTB

	set SOURCE("R")="RMS" 
	set SOURCE("T")="Tape"
	set %PAGE=2
	set %PG=1
	set %READ="@@%FN,,,SRC/REQ,INPUT/REQ"
	set %NOPRMT="N"
	
	do ^UTLREAD 
	if VFMQ="Q" quit 
	do CMP quit:ER
	do FILEDUMP 
	if VFMQ="Q" quit 

	if FDUMP do IODUMP 
	if VFMQ="Q" quit 
	do IO 
	quit 
	

FILEDUMP	// Define file name and determine if dump file is to be created

	type Number OLNTB,%PAGE,%PG
	type String DAT,LOOKUP(),%TAB,%MSKD,%NOPRMT,%READ,ZPGM
	type public String SPL,NOPRMT,SRC,VFMQ,INPUT,TDRV,Z,FDUMP
	
	set OLNTB=6000
	set %PAGE=2 
	set %PG=1

	do PP03(.SPL)
	set SPL=CUVAR.spldir
	set DAT=+%CurrentDate.toString(%MSKD.get())
	set DAT=DAT.translate("/")  
	set Z="INC_"_SRC_"-"_%CurrentDate.toString("MMDD")_".PBS"      
	set TDRV=$$FILE^%TRNLNM(Z,SPL)         
	set %TAB("TDRV")=".TDRV1/TBL=LOOKUP(/XPP=do PP02^TTXINI/LEN=60"
	set %TAB("FDUMP")=".FDUMP1" 
	set FDUMP="N"
	set %PAGE=2 
	set %PG=1
	
	if INPUT="R" set %READ="TDRV/REQ,FDUMP/REQ" 
	set %NOPRMT="N"
	else  do {
		set %READ="FDUMP/REQ" 
		set %NOPRMT="N"
		}
	
	do ^UTLREAD 
	if VFMQ="Q" do DEL^%ZRTNDEL(ZPGM) 
	quit 

IODUMP	// Prompt for dump file name

	type Number OLNTB,%PAGE,%PG
	type String IODUMP,%TAB
	type public String %NOPRMT,INPUT,IO,VFMQ,ZPGM
	kill IODUMP,%NOPRMT

	if INPUT="R" set OLNTB=8000
	else  set OLNTB=7000

	set %TAB("IODUMP")=".IODUMP1/XPP=set %EXT=1 do ^SCAIO"
	set %PAGE=2 
	set %PG=1
	set %READ="IODUMP/REQ",%NOPRMT="N"
	do ^UTLREAD
	if VFMQ="Q" do { quit
		if IO.exists() do CLOSE^SCAIO 
		if IODUMP.exists() set IO=IODUMP 
		do CLOSE^SCAIO
		do DEL^%ZRTNDEL(ZPGM) 
		}
	set IO=IODUMP
	do OPEN^SCAIO
	set IODUMP=IO
	quit 
	

IO	//

	type Number OLNTB,TAPENUM,%PG,%PAGE
	type String %READ,%TAB
	type public String IODUMP,IO,PROC,ZPGM,FDUMP,VFMQ,%NOPRMT,INPUT
	
	kill IO,%NOPRMT

	if ('FDUMP),(INPUT="T") set OLNTB=8000
	if (FDUMP)!(INPUT="R") set OLNTB=9000
	if (FDUMP),(INPUT="R") set OLNTB=10000

	set TAPENUM=""
	set TAPENUM=Db.nextVal("INCTAPE","TAPENUM")
	set %PAGE=1
	set %PG=1
	set %TAB("IO")=".IO3/XPP=do PP01^TTXINI"
	set %TAB("OPERCMT")=".OPERCMT1"
	set %READ="IO/REQ,OPERCMT/REQ"

	do ^UTLREAD 
	if VFMQ="Q" do {
		if IO.exists() do CLOSE^SCAIO 
		if IODUMP.exists() do {
			set IO=IODUMP 
			do CLOSE^SCAIO
			}
		do DEL^%ZRTNDEL(ZPGM) 
		}
	do PROC
	quit

PROC	//    

	type public String ZPGM
	do OPEN^SCAIO
	do ^@ZPGM
	do DEL^%ZRTNDEL(ZPGM)
	quit 
	

CMP	 // Compile Format into ^TTXFMT

	type public Boolean ER
	type public String RM, SRC, ZPGM	// Consider passing SRC and ZPGM as parameters
	
	type Number FMTLOC, NEWSEQ, SEQ
	type String CMPERR(), CODE(), CODEFMT(), CODEBASE(), PGMNAM, PROCNAME, TAGS()
	
	/* The approach here is to load the code in procedure TTXFMT
	   into the CODEBASE array, then load either the code in
	   the custom procedure OR the standard procedure into
	   CODEFMT, then merge the two into CODE, with CODEFMT
	   being inserted into the section marked FMT in CODEBASE.
	   
	   NOTE that all code being loaded is procedure code, is
	   expected to be in either [CTBLINC] or in DBTBL25D, and
	   must be in PSL format.
	*/
	
	set ER = 0

	kill CODEBASE

	// Load TTXFMT into array CODEBASE
	do ^ULODTMPL("TTXFMT","CODEBASE","",.TAGS())
	
	if 'TAGS("FMT").exists() do { quit
	
		set ER = 1
		// Compilation error - no FMT line tag
		do Runtime.setErrMSG("CTBLINC",586)
	}

	// Load standard or custom code into CODEFMT array
	type RecordCTBLINC ctblinc = Db.getRecord("CTBLINC", "KEY=:SRC")
	set PGMNAM = ctblinc.pgm
	set PROCNAME = PGMNAM.piece("^",2)
	
	if 'PROCNAME.isNull() do { quit:ER
	
		if PROCNAME.beginsWith("^") do {
	
			set ER = 1
			// Procedure name required	
			set RM = $$^MSG(8568)
		}
		
		else  if 'Db.isDefined("DBTBL25", "%LIBS='SYSDEV' AND PROCID=:PROCNAME") do { quit
	
			set ER = 1
			// No definition for Procedure ~p1
			set RM = $$^MSG(8610, PROCNAME)
		}
	}
	
	do ^ULODTMPL(PROCNAME, "CODEFMT")
	
	if ('CODEFMT.data() > 0) do { quit
	
		set ER = 1
		// Invalid format ~p1
		set RM = $$^MSG(1350)
	}
	
	// Merge the code at FMT tag
	set FMTLOC = TAGS("FMT")
	
	set CODE(1) = ZPGM_" // Inclearing formating for "_SRC_".  Built by TTXINI."
	set CODE(2) = " //"
	set NEWSEQ = 2
	
	// Add initial base code
	set SEQ = ""
	for  set SEQ = CODEBASE(SEQ).order() quit:(SEQ = FMTLOC)  do {
		
		set NEWSEQ = NEWSEQ + 1
		set CODE(NEWSEQ) = CODEBASE(SEQ)
	}
	
	// Add formatting code
	set SEQ = ""
	for  set SEQ = CODEFMT(SEQ).order() quit:SEQ.isNull()  do {
		
		set NEWSEQ = NEWSEQ + 1
		set CODE(NEWSEQ) = CODEFMT(SEQ)
	}
	
	// Add remaining base code
	set SEQ = FMTLOC
	for  set SEQ = CODEBASE(SEQ).order() quit:SEQ.isNull()  do {
		
		set NEWSEQ = NEWSEQ + 1
		set CODE(NEWSEQ) = CODEBASE(SEQ)
	}

	// Compile new routine
	do BUILDRTN^UCGM(.CODE, ZPGM, .CMPERR())

	if '(CMPERR("").order()).isNull() do {
	
		type Number N = ""

		for  set N = CMPERR(N).order() quit:N.isNull()  do {
		
			if CMPERR(N).beginsWith("%PSL-E") do {	
				
				if 'ER do {
					set ER = 1
					set RM = CMPERR(N)
					}
				}
				
			write CMPERR(N), !
			}
		}

	quit 


PP00	// RMS or tape post-processor

	type public Boolean ER
	type public String MODE,RM,X
	
	// Enter 'R' for RMS or 'T' for tape
	if X="R"!(X="T") set MODE=$S(X="R":"RMS",1:"TAPE") quit 

	set ER=1 do Runtime.setErrMSG("909")
	quit 
	
PP01	//
	
	type public Number TAPENUM
	type String %EXT
	type public String ER,RM

	set %EXT=1 
	do ^SCAIO

	if ER quit 
	// File number ~p1
	set ER="W" set RM=$$^MSG("1091",TAPENUM)
	quit 
	

PP02	// Post processor for RMS dump file

	/*
	   Select criteria is a numeric sequence, need to
	   translate the selection into the appropriate file name.
	
	*/
	
	type public Boolean ER
	type public Number CNT,HIT
	type String FIL
	type public String X,LOOKUP()
	
	quit:X.isNull() 
	if 'X do { quit 
		set X=X.piece(";",1)
		set CNT="" 
		for  set CNT=LOOKUP(CNT).order() quit:CNT.isNull()  do { quit:HIT.get() 
			set FIL=LOOKUP(CNT).piece(" ",1) 
			set FIL=FIL.piece(";",1)
			quit:X'=FIL 
			set HIT=1
			do CHANGE^DBSMACRO("TBL","")
			}
		// Invalid file specification
		if 'HIT.get() set ER=1 do Runtime.setErrMSG("CTBLINC",1343) quit:ER
		}
	
	// Invalid file specification
	if 'LOOKUP(X).exists() set ER=1 do Runtime.setErrMSG("CTBLINC",1343) quit:ER
	
	set X=LOOKUP(X).piece(" ",1)
	//Remove lookup
	do CHANGE^DBSMACRO("TBL","")
	quit 
	

PP03(String SPLDIR)	// Build table lookup of existing files

	type String IO,X,Z
	type public String REC,ET
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
	set SPLDIR=cuvar.spldir
	set X=SPLDIR
	set IO=$$FILE^%TRNLNM("ZDIR.TMP",SPLDIR)
	set Z=$$DIROUT^%OSSCRPT(IO,SPLDIR,"INC_*")  
	set Z=$$FILE^%ZOPEN(IO,"READ",5)

	for  set REC=$$^%ZREAD(IO,.ET) quit:+ET=1  do RECCHK
	do CLOSE^SCAIO
	set Z=$$DELETE^%OSSCRPT(IO_";*")
	use 0
	quit 

RECCHK	// If record meets pattern, add to lookup

	type public Number CNT
	type String FILNAM
	type public String LOOKUP(),REC,SPLDIR
	
	if (REC.isNull())!(REC.extract(1,4)'="INC_") quit 

	set CNT=CNT.get()+1
	set FILNAM=REC.piece(" ",1)
	set LOOKUP(CNT)=$$FILE^%TRNLNM(FILNAM,SPLDIR)
	quit 
	

EXT(SRC,TDRV,IO,OPERCMT,ERR,ERRMSG,PFILCNT,PFILDR,PFILCR)

	/*
	
	     INPUTS:
	                 SRC     - Valid source file type        /REQ
	                 TDRV    - RMS file name                 /REQ
	                 IO      - IO Device                     /REQ
	                 OPERCMT - Operator Comment              /Not REQ
	                 *** The following variables are input as values to
	                     be returned to the calling process ***
	                 ERR     - Error Flag
	                 ERRMSG  - Error Message
	                 PFILCNT  - Number of physical files
	                 PFILDR   - Physical Total Debits
	                 PFILCR   - Physical Total Credits
	  ----------------------------------------------------------------------
	*/

	type public Boolean ER
	type Number TAPENUM
	type String ZMSG,MODE,X,ZPGM
	type public String %EXT,CONAM,RM,%NODE,%LOGID
	
	// Init system variables
	do SYSVAR^SCADRV0()

	//Cannot locate required parameter
	set ZMSG=$$^MSG(3829)

	set (ERR,ERRMSG,PFILCNT,PFILDR,PFILCR)=""

	//I18N=OFF
	if SRC.get().isNull() do { quit
		set ERR=1 
		set ERRMSG=ZMSG_" SRC" 
		}

	if TDRV.get().isNull() do { quit
		set ERR=1 
		set ERRMSG=ZMSG_" TDRV" 
		}
	if IO.get().isNull() do { quit
		set ERR=1 
		set ERRMSG=ZMSG_" IO" 
		}
	//I18N=ON

	set OPERCMT=OPERCMT.get()
	set X=IO
	
	type ResultSet rs=Db.select("TAPENUM","INCTAPE","TAPENUM>:TAPENUM","TAPENUM DESC")
	if rs.next() do {
		set TAPENUM=rs.getCol("TAPENUM")
	}
	
	set %EXT=1 
	do ^SCAIO 

	if ER do { quit
		set ERR=1 
		set ERRMSG=RM
		}
	
	if 'Db.isDefined("CTBLINC","SRC") set ERR=2 quit 
	set ZPGM="TMP"_(%ProcessID#100000)
	set %ProcessMode=0
	set MODE="RMS"

	if '%InputTimeOut.get() set %InputTimeOut=60 
	if 'CONAM.get() set CONAM=""
	set %NODE=$G(%NODE)
	set %LOGID=$$LOGID^SCADRV
	do CMP
	do PROC
	close IO
	if ER=1,(+ERR=0) do { 
		set ERR=1 
		set:ERRMSG.isNull() ERRMSG=RM.get()
		}
	quit 
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60863^6141^Sethy, Satyanarayan^11260"	// Signature - LTD^TIME^USER^SIZE
