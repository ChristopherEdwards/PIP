public CHKBUMP	//;Bump (Change) check numbers in Check Register
	/*
	   ORIG: Marty Ronky - (3623) 04/07/91

	   This routine allows the moving of a single check
	   or group of checks to another check number or
	   check range.  This replaces routine CHK

	  ---- Revision History ------------------------------------------------

	   07/28/06 - KELLYP - CR 22048
	   	      Modified VPG01, INI1, & INI2 sections to eliminate 
	   	      PRECEDENCE warnings.

	   11/14/05 - PUTTASWH - CR17011
 	  	      Modified page control logic according to new standard.
	  	      Modified INIT section to contain the code of VPG and 
	  	      VPG0 sections. Removed VPG and VPG0 sections.
	  	      Modified section VPG01 to declare the variable TAG.
	  	     
	   12/02/03 - CARROLLJ - CR7239
		      Correct for loop in LOOKUP section to defined variable X.
	
	   07/16/03 - GRAY - 51351
		      Replaced use of file CHKREG3 with CHKREG1.

	   06/7/2002 - TELIV - 49794
		       Converted to PSL

	   01/03/01 - HALPINJ - 42989
	              Fetch generation of routine prior to SQL code.
	              SQL coding was inefficient and causing errors.
	  ------------------------------------------------------------------------
	*/

	do INIT
	
	quit

INIT	//
	set %ProcessMode=1
	set %PG=0
	set %PAGE=1
	kill OLNTB,VFMQ
	
	do VPG00
	
	if "DFQ"[VFMQ.get()!ER.get() do VER quit
	set %PG=%PG+1
	
	do VPG01
	do VER
	
	quit
	
VPG00	// Entry for page 1

	type ResultSet rs=Db.select("CO","CHKREG1",,"CO")
	if 'rs.isEmpty(),rs.next() set CO=rs.getCol(1)
	else  set CO=""

	set %TAB("CO")=".CO2/TBL=[CHKREG1]CO:DISTINCT:QU"
	set %TAB("CHKTYP")=".CHKTYP1/TBL=[UTBLCHKS]/XPP=D POS^CHKBUMP"

	set %READ="@@%FN,,,CO/REQ,CHKTYP/REQ" set %NOPRMT="N"
	do ^UTLREAD if VFMQ="Q" set ER=1
	quit


POS	// Check Type Post-Processor

	if X="" quit

	type RecordUTBLCHKS utblchks=Db.getRecord("UTBLCHKS","CHKS=:X")
	set GL=utblchks.cid

	// Type ~p1 has no G/L account in CHKS user table
	if GL="" set ER=1 set RM=$$^MSG(2770,X) quit

	// No checks in check register
	type ResultSet rs=Db.select("CKNO","CHKREG1","CO=:CO AND GL=:GL")
	if rs.isEmpty() do {
		set ER=1 set RM=$$^MSG(1912)
		}

	quit


VPG01	//  Check Range

	type String TAG

	// Bump Check Range for Type ~p1, G/L Account ~p2
	set HDG=$$^MSG(6603,CHKTYP,GL)
	set HDG=$J("",(80-HDG.length())\2)_HDG set %READ="@HDG,,"

	type RecordCHKTMP chktmp=Db.getRecord("CHKTMP","GL=:GL")
	set TAG=$S(chktmp.ftofst:"INI1",1:"INI2")

	do @TAG do ^UTLREAD if VFMQ="Q" set ER=1
	quit


INI1	// Intialize UTLREAD variables for a process that didn't finish.

	type RecordCHKTMP chktmp=Db.getRecord("CHKTMP","GL=:GL")
	set FTOFST=chktmp.ftofst

	type ResultSet rs=Db.select("CKNO","CHKTMPA","GL=:GL","CKNO")
	if rs.next() set CKNB=rs.getCol(1)

	type ResultSet rs=Db.select("CKNO","CHKTMPA","GL=:GL","CKNO DESC")
        if rs.next() set Y=rs.getCol(1)

	set CKB=CKNB-FTOFST 
	set CKE=Y-FTOFST

	// There is an existing Check Bump Process which did not file
	set HDG1=$$^MSG(6373)

	// to completion. Please file screen to complete the process.
	set HDG2=$$^MSG(6374)

	// Range to be Bumped
	set HDG3=$$^MSG(6375) set HDG3=$J("",(80-HDG3.length())\2)_HDG3

	// From Check Number : ~p1
	set HDG4=$$^MSG(6370,CKB)

	// Thru Check Number : ~p1
	set HDG5=$$^MSG(6371,CKE)

	// Range to be Created
	set HDG6=$$^MSG(6376) set HDG6=$J("",(80-HDG6.length())\2)_HDG6

	// Starting Check Number : ~p1
	set HDG7=$$^MSG(6372,CKNB)
	set %READ=%READ_",@HDG1,@HDG2,,,@HDG3,,@HDG4,@HDG5,,,@HDG6,,@HDG7"

	quit


INI2	// Initalize %TAB for a new bump.

	// Range to be Bumped
	set HDG1=$$^MSG(6375) set HDG1=$J("",(80-HDG1.length())\2)_HDG1

	// Range to be Created
	set HDG2=$$^MSG(6376) set HDG2=$J("",(80-HDG2.length())\2)_HDG2

	set %TAB("CKB")=".CKB2/TBL=[CHKREG1]CKNO,[CHKREG1]TAMT:DISTINCT:QU ""[CHKREG1]CO=<<CO>> AND [CHKREG1]GL=<<GL>>"""
	set %TAB("CKE")=".CKE2/TBL=[CHKREG1]CKNO,[CHKREG1]TAMT:DISTINCT:QU ""[CHKREG1]CO=<<CO>> AND [CHKREG1]GL=<<GL>>""/XPP=D POS1^CHKBUMP/MIN=<<CKB>>"
	set %TAB("CKNB")=".CKNB1/XPP=D POS2^CHKBUMP"

	set %READ=%READ_",@HDG1,,CKB/REQ,CKE/REQ,,,@HDG2,,CKNB/REQ"
	quit


POS1	// Ending Check post-processor


	new I,Y

	// Ending check number must be greater than or equal to starting check number
	if X<CKB set ER=1 set RM=$$^MSG(895) quit

	// Check number ~p1 must be moved first
	if X'=CKB do {
		set Y=CKB\1
		type ResultSet rs=Db.select("CKNO","CHKREG1","CO=:CO AND GL=:GL AND CKNO>:Y","CKNO")
		if 'rs.isEmpty() while rs.next() do { quit:rs.getCol(1)>X
			set Y=rs.getCol(1)
			// Check number ~p1 must be moved first
			if Y\1'=Y set ER=1,RM=$$^MSG(534,Y)		
			}
		}

	if ER.get() quit

	// Invalid range.  Check number ~p1 missing.
	for I=0:1 quit:CKB+I=X  do { 
		new CKBI
		set CKBI=CKB+I
		if 'Db.isDefined("CHKREG1","CO=:CO,GL=:GL,CKNO=:CKBI") do {
			set ER=1 
			// Invalid range.  Check number ~p1 missing.
			set RM=$$^MSG(1437,(CKB+I))
			}
		}

	if ER.get() quit
	
	// Set RNG (range) to 0 if bumping one check, otherwise set RNG to
	// the difference+1.

	set RNG=$S(X=CKB:0,1:X-CKB+1)

	quit


POS2	// To Check post-processor

	// Select new starting check number
	if X=CKB set ER=1 set RM=$$^MSG(2468) quit

	// If the old range and new range are disjoint, assure no checks exists
	// in the new range.

	new I,J,Z set ER=0

	type ResultSet rs=Db.select("CKNO","CHKREG1","CO=:CO AND GL=:GL AND CKNO<:X","CKNO DESC")
	if 'rs.isEmpty(),rs.next() set Z=rs.getCol(1)

	// Invalid, check number ~p1 exists
	if X>CKE!((X+RNG)<CKB) do {
		type ResultSet rs=Db.select("CKNO","CHKREG1","CO=:CO AND GL=:GL AND CKNO>:Z","CKNO")
		if 'rs.isEmpty(),rs.next() set I=rs.getCol(1)
		set:I&(I'>(X+RNG)) ER=1
		// Invalid, check number ~p1 exists
		set RM=$$^MSG(1516,I)
		}

	if ER.get() quit
	
	// Ranges overlap, check part of range that doesn't overlap for existing
	// checks, and give warning about overlap.

	set I=X-.01

	// Invalid, check number ~p1 exists
	type ResultSet rs=Db.select("CKNO","CHKREG1","CO=:CO AND GL=:GL AND CKNO>:I","CKNO")
	if 'rs.isEmpty() while rs.next() do { quit:(rs.getCol(1)>(X+RNG))

		// Invalid, check number ~p1 exists
		if I<CKB!(I>CKE) set ER=1 set RM=$$^MSG(1516,I)
		}

	if ER.get() quit

	// Warning - ranges overlap
	set ER="W" 
	set RM=$$^MSG(2969)_"|21000" 
	set OLNTB=22000

	quit


VER	//

	if ER!(VFMQ="Q") do END quit

	do FILE

	do END

	quit

FILE	// File data

	lock +CHKREG(CO,GL):2 else  set ET="RECLOC" do ERR quit
	lock +CHKTMP(GL):2 else  set ET="RECLOC" do ERR quit

	// Check # Bumped to
	set STATUS=2 set MEMO=$$^MSG(7425)

	// If only one check is being moved, don't bother setting up
	// the temporary file, just move one check to the other.

	if CKB=CKE set SINGLE=1 do SINGLE lock  quit

	// If there is no data at the GL level, then this is a new process.
	// If a process wasn't completed, file from existing CHKTMP.

	
	type RecordCHKTMP chktmp=Db.getRecord("CHKTMP","GL=:GL",1)
	
	if 'chktmp.getMode() do {		
		set FTOFST=CKNB-CKB
		set chktmp.ftofst=FTOFST
		do chktmp.bypassSave()
		do FILE1		
		}
		
	do FILE2		
	do Db.delete("CHKTMP","GL=:GL") 
		
	lock
	quit


SINGLE	// Move single check (Used for duplicate checks)


	new ckb,xckb

	type RecordCHKREG1 chkreg1=Db.getRecord("CHKREG1","CO=:CO,GL=:GL,CKNO=:CKB")
	if 'chkreg1.getMode() quit
	
	type RecordCHKREG1 ckb=Class.new("RecordCHKREG1")

	set ckb=chkreg1.copy()

	set ckb.ckno=CKNB

	do ckb.save()
	
	set PDOTJD=chkreg1.tjd

	set chkreg1.status=STATUS
	set chkreg1.memo=MEMO_CKNB

	do chkreg1.bypassSave()
	
	do PDOSEQ
	
	quit
	

PDOSEQ	//

	type ResultSet rs=Db.select("CKSEQ","XPDO","CKTYP=:CHKTYP AND CKNO=:CKB","CKSEQ")
	if rs.isEmpty() do { quit		
		type RecordCHKREG1 chkreg1=Db.getRecord("CHKREG1","CO=:CO,GL=:GL,CKNO=:CKB")
		set chkreg1.status=2 
		do chkreg1.bypassSave()
		}
	
	while rs.next() do {
	
		set PDOSEQ=rs.getCol(1)		

		type RecordXPDO xpdo=Db.getRecord("XPDO","TJD=:PDOTJD,CKTYP=:CHKTYP,CKSEQ=:PDOSEQ",1)
		if 'xpdo.getMode() set ER=1 quit

		set xpdo.ckno=CKNB
		do xpdo.bypassSave()

		if 'xpdo.cid set ER=1 quit
		}
	
	quit


FILE1	// 
	/* Take checks to be bumped, and set into CHKTMP file, to prevent
	   clobbering any data due to overlaps.
	*/

	set CKNO=CKB-1

	type ResultSet rs=Db.select("CKNO","CHKREG1","CO=:CO AND GL=:GL AND CKNO>:CKNO","CKNO")
	
	while rs.next() do { quit:CKNO>CKE
		set CKNO=rs.getCol(1) 
		quit:CKNO>CKE

		type RecordCHKTMPA chktmpa=Class.new("RecordCHKTMPA")
		type RecordCHKREG1 chkreg1=Db.getRecord("CHKREG1","CO=:CO,GL=:GL,CKNO=:CKNO")

		set chktmpa.gl=GL
		set chktmpa.ckno=CKNO+FTOFST
		set chktmpa.tjd=chkreg1.tjd
		set chktmpa.efd=chkreg1.efd
		set chktmpa.uid=chkreg1.uid
		set chktmpa.brcd=chkreg1.brcd
		set chktmpa.trc=chkreg1.trc
		set chktmpa.tamt=chkreg1.tamt
		set chktmpa.cid=chkreg1.cid
		set chktmpa.payee=chkreg1.payee
		set chktmpa.ctype=chkreg1.ctype
		set chktmpa.status=chkreg1.status
		set chktmpa.clear=chkreg1.clear
		set chktmpa.combined=chkreg1.combined
		set chktmpa.memo=chkreg1.memo

		do chktmpa.bypassSave()

		type ResultSet rs=Db.select("CKSEQ","XPDO","CKTYP=:CHKTYP AND CKNO=:CKNO","CKSEQ")
		while rs.next() do { 
			set SEQ=rs.getCol(1)
			set TXCHKREG(CHKTYP,CKNO,SEQ)=""			
			}
		}
	
	quit


FILE2	// Take CHKTMP file and file into CHKREG, killing off old check info


	set PDOSEQ=""
	
	for OPT="K","F" do FILE2A
	quit


FILE2A	//

	type RecordCHKREG1 chkreg1
	
	type ResultSet rs=Db.select("CKNO","CHKTMPA","GL=:GL","GL")	
	 
	while rs.next() do {
		set CKNO=rs.getCol(1)
	
		if OPT="K" do {
			set X=CKNO-FTOFST
			if 'Db.isDefined("CHKTMPA","GL=:GL,CKNO=:X") do {
				set chkreg1=Db.getRecord("CHKREG1","CO=:CO,GL=:GL,CKNO=:X",1)
				set chkreg1.status=STATUS
				set chkreg1.memo=MEMO_CKNO
				do chkreg1.bypassSave()
				}	
			
			set PDOTJD=chkreg1.tjd
			
			do PDOSEQ2
			}
		
	
		else  do {

			type RecordCHKTMPA chktmpa=Db.getRecord("CHKTMPA","GL=:GL,CKNO=:CKNO")
			type RecordCHKREG1 chkreg1=Class.new("RecordCHKREG1")
	
			set chkreg1.co=CO
			set chkreg1.gl=GL
			set chkreg1.ckno=CKNO
	       	 	set chkreg1.tjd=chktmpa.tjd
	        	set chkreg1.efd=chktmpa.efd
	        	set chkreg1.uid=chktmpa.uid
	       	 	set chkreg1.brcd=chktmpa.brcd
	        	set chkreg1.trc=chktmpa.trc
	        	set chkreg1.tamt=chktmpa.tamt
	        	set chkreg1.cid=chktmpa.cid
	        	set chkreg1.payee=chktmpa.payee
	        	set chkreg1.ctype=chktmpa.ctype
	        	set chkreg1.status=chktmpa.status
	        	set chkreg1.clear=chktmpa.clear
	        	set chkreg1.combined=chktmpa.combined
	        	set chkreg1.memo=chktmpa.memo
			do chkreg1.bypassSave()        	

			}
		}
	
	quit
	

PDOSEQ2	//

	for  set PDOSEQ=TXCHKREG(CHKTYP,X,PDOSEQ).order() quit:PDOSEQ=""  do {

		if 'Db.isDefined("CHKTMPA","GL=:GL,CKNO=:X") do { quit			
			type RecordCHKREG1 chkreg1=Db.getRecord("CHKREG1","CO=:CO,GL=:GL,CKNO=:X")
			set chkreg1.status=2 
			do chkreg1.bypassSave()
			}
	
		type RecordXPDO xpdo=Db.getRecord("XPDO","TJD=:PDOTJD,CKTYP=:CHKTYP,CKSEQ=:PDOSEQ",1)
		if 'xpdo.getMode() set ER=1 quit
		
		if xpdo.ckseq="" set ER=1 quit

		set PDOCID=xpdo.cid
		if 'PDOCID set ER=1 quit
	
		set xpdo.ckno=CKNO
		do xpdo.bypassSave()
        	
		}
	
	quit


END	// Clean up and exit

	kill %TAB
	lock
	quit:ER  

	set ER="W"
	
	// Check number not incremented
	if VFMQ="Q" set RM=$$^MSG(531) quit

	// Account ~p1, checks ~p2 thru ~p3 incremented to checks ~p4 thru ~p5
	// Chks ~p1 - ~p2 incremented to chks ~p3 - ~p4
	if CKE-CKB set RM=$$^MSG(8493,CKB,CKE,CKNB,(CKE+FTOFST))

	// Account ~p1, check ~p2 incremented to check ~p3
	else  set RM=$$^MSG(7223,GL,CKE,CKNB)
	quit


ERR	// Log error

	set ER=1 do ^UTLERR
	set VFMQ="Q"
	quit


public LOOKUP	//This uses the info in checkreg to get the XPDO info

	new I,X,XPDO,XCHKREG,LOOKUP
	for I=1:1:36 set CHKCID(I)=""

	if 'Db.isDefined("CHKREG1","CO=:CO,GL=:GL,CKNO=:CKNO") quit
	type RecordCHKREG1 chkreg1=Db.getRecord("CHKREG1","CO=:CO,GL=:GL,CKNO=:CKNO")

	type ResultSet rs=Db.select("CKSEQ","XPDO","CKTYP=:CTYPE AND CKNO=:CKNO","CKSEQ")
	if rs.isEmpty() quit
	for X=1:1:36 quit:rs.isEmpty()  do {
		set XCHKREG=rs.getCol(1)
		
		type RecordXPDO xpdo=Db.getRecord("XPDO","TJD=:TJD,CKTYP=:CTYPE,CKSEQ=:XCHKREG")
		set CHKCID(X).piece("|",1)=xpdo.cid
		set CHKCID(X).piece("|",2)=xpdo.tamt
		set CHKCID(X).piece("|",3)=chkreg1.payee
		}
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60477^65441^Pat Kelly^11678"	// Signature - LTD^TIME^USER^SIZE
