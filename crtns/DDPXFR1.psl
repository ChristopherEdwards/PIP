DDPXFR1  // Builds the RMS file for the schema and table data to transfer to a client

	/*
	DESC; - Schema and Data Transfers

	----- Revision History ------------------------------------------------
	07/06/07 - VanithaK - CR27796
		   Modified TRAN,STBL,UTBL,CTBL and MISC sections to declare
		   VFMQ as public variable for the same reason as CR 27215.
		
	05/29/07 - VanithaK - CR27215
		   Modified FID section to have VFMQ as public so that 
		   the FEP file with size zero will not be created when hit F11
		   when there is no files to be transferred.
	
	08/30/06 - KELLYP - CR 22808
		   Removed a line of code from the SETWEIG section that was
		   setting up the FIDLINK variable improperly because it was
		   using the FID name as a delimiter.  This caused truncation
		   of the linked table names when the names were similar (e.g.,
		   UTBLRELMAT, UTBLRELMAT1, UTBLRELMAT2) and resulted in RECNOFL
		   errors later in the process.
	
	07/13/06 - RussellDS - CR22121
		   Eliminate use of ^UCOLLATE to make Unicode compliant.
		   
		   Corrected PSL warnings.

	01/04/06 - KELLYP - CR 18761
		   Modified to declare FILE and GETQUE sections as public.

	10/17/05 - KELLYP - CR 17831
		   Modified FILE section to create a new DDPTQUE1 object for
		   every iteration of the loop.  This prevents a problem where
		   only the last FEP directory would have a DDPTQUE1 record
		   created for it when "*" was selected to send the FEP to all
		   FEP directories.

	05/11/05 - KELLYP - CR 13664
		   Modified TRAN section by making the TRAN1 array public. This
		   array is used as an output array to indicate which trancodes
		   should be transferred to the client.

	09/16/04 - RussellDS - CR8102
		   Modified call to ^DBSTBLM from LOADFILE to LOOKUP.
		   
		   Cleaned up scope errors (did not attempt to properly
		   type (Number vs. String) all variables.
		   
		   Removed old revision history.

	12/12/03 - spier 7403
		   psl compiler warning message cleanup
	*/
	
	quit		// No entry from top


public FID	// Request schema elements to send to client
	/*
	  
	 This label is called from the routine DDPXFR, it is used to prompt for
	 the tables that the user wishes to transfer schema/data to the client.
	  
	 The output from this label is the array FID1 and FLG(2)

	*/
	
	type public String FID1(), FLG(), VFMQ
	
	type String FID,FLIB,HDG,MISCFLAG,OLNTB,%READ,%TAB,X

	set MISCFLAG=0

	//Prompt for Table Definitions to Transfer
	set HDG=$$^MSG(3431)                   
	set FLIB="SYSDEV"
	set %TAB("FID")=".FID1/TBL=[DBTBL1]"
	set OLNTB=30	
	set %READ="@HDG/CEN/REV,,FID/REP=20"
	do ^UTLREAD if VFMQ="Q" quit 
	
	/*
	Based on data retrieved, build FID1 array keyed by the tables to be
	transferred.
	*/

	set X=""
	for  set X=$O(FID(X)) quit:X=""  if FID(X)'="" do {
		set FID=FID(X)
		do SETENTRY(FID,.FID1)
		}

	do RESETTAB(.FID1)

	if $D(FID1)<2 set FLG(2)=0
	quit 
	
	
public UTBL	// Request User Table elements to send to client
	
	/*
	
	This label is called from the DDPXFR procedure, its purpose is
	to prompt for the user table name for which the user wishes to send 
	data to a client.
	
	The output from this label is the array UTBL1 and FLG(14)
	*/

	type public String FLG(), UTBL1(), VFMQ

	type String HDG,%READ,%TAB,vtblutbl

	// create vtblutbl array with user table entries

	do LOOKUP^DBSTBLM("UTBL", .vtblutbl)
	do REMOVETAB
	set HDG=$$^MSG(3447)

	// Build prompts for User Tables to Transfer
	set %TAB("ARRAY")=".UTBL1/TBL=vtblutbl(:NOVAL/XPP=D ITCHK^DDPXFR1"

	do GETTABLE(.UTBL1)
	if $D(UTBL1)<2 set FLG(14)=0

	quit


	
public STBL	// Request system table elements to send to client
	
	/*
	This label is used to prompt for the system table names for which a user
	wishes to send the data of the table to a client.

	The output from this label is the array STBL1 and FLG(15)

	*/
	
	type public String FLG(), STBL1(), VFMQ
	
	type String HDG,%READ,STBL,%TAB,vtblutbl

	// BUILD vtblutbl entries for STBL tables
	do LOOKUP^DBSTBLM("STBL", .vtblutbl)
	do REMOVETAB	

	set HDG=$$^MSG(3444)
	// Build Prompt for System Tables to Transfer
	set %TAB("ARRAY")=".UTBL1/TBL=vtblutbl(:NOVAL/XPP=D ITCHK^DDPXFR1"

	do GETTABLE(.STBL1)
	if $D(STBL1)<2 set FLG(15)=0
	quit


	
	
public CTBL	// Request Common table elements to send to client

	/*
	This label is used to prompt for the common table for which the
	user wishes to send the data to a client.

	The output from this label is the array CTBL1 and FLG(16)


	*/
	
	type public String CTBL1(), FLG(), VFMQ
	
	type String CTBL,HDG,%READ,%TAB,vtblutbl

	//Build vtblutbl array for CTBL tables
	do LOOKUP^DBSTBLM("CTBL", .vtblutbl)
	do REMOVETAB	
	
	// Common Tables to Transfer
	set HDG=$$^MSG(3424)
	set %TAB("ARRAY")=".UTBL1/TBL=vtblutbl(:NOVAL/XPP=D ITCHK^DDPXFR1"
	do GETTABLE(.CTBL1)
	if $D(CTBL1)<2 set FLG(16)=0
	
	quit

REMOVETAB	// remove elements from vtblutbl array that are not allowed (CHKBIN tells us that)

	type Public String vtblutbl()

	type Number ER
	type String RM,Y
	
	set Y="" 
	for  set Y=$O(vtblutbl(Y)) quit:Y=""  if $$CHKBIN($P(vtblutbl(Y),"|",2)) kill vtblutbl(Y)

	quit
	
private MISC	// Private, Request Miscellaneous elements to transfer to client
	
	/*
	 This label is called from proecedure DDPXFR and is used to prompt for tables 
	 other then user,system and common for which the user wishes to send the data 
	 to a client.
	 
	 The output from this label is the array MISCT and FLG(18)
	*/
	
	type Public String FLG(), MISCT(), VFMQ
	
	type String HDG,MISCFLAG,MISCF,%READ,%TAB
	
	// Miscellaneous Globals to Transfer
	set MISCFLAG=1
	set HDG=$$^MSG(7494)
	
	set %TAB("ARRAY")=".UTBL1/TBL=[DBTBL1]:NOVAL/XPP=D MISCHK^DDPXFR1"
	do GETTABLE(.MISCT)
	if $D(MISCT)<2 set FLG(18)=0

 	quit

	
	
MISCHK	// Private, Review misc tables entries to see if the table is a valid table on the front end
	
	// This label is a post processor on the MISC table prompt
	
	type Public Boolean MISCFLAG
	type Public Number ER
	type Public String RM, X
	
	type String DATA,GLOBAL
	
	if X="" quit 
	if $E(X,$L(X))="*",MISCFLAG=1 do BLDTABLE quit 

	//Invalid file

	type ResultSet rs=Db.select("NETLOC,LOG,GLOBAL","DBTBL1","%LIBS='SYSDEV' AND FID=:X")
	if rs.isEmpty() set ER=1 set RM=$$^MSG(1332) quit
	set DATA=rs.next()
	
	// Not a valid table on the Front End
	if rs.getCol(1)=0 set ER=1 set RM=$$^MSG(7501) quit      
	if +rs.getCol(2)=0 S ER=1,RM=$$^MSG(7501) quit

	set GLOBAL=rs.getCol(3)

	if MISCFLAG=1 do {
		type String TABLE
		
		set TABLE=","_GLOBAL_","
		// Cannot transfer USER, SYSTEM, COMMON tables as Miscellaneous Tables
		if ",STBL,CTBL,UTBL,"[TABLE set ER=1 set RM=$$^MSG(8402) quit
	
		//just warning, not a error
		if GLOBAL="DBTBL" set RM=$$^MSG(877) quit      
		}

	if '$G(ER) set ER=$$CHKBIN(X)

	quit 
	
	
BLDTABLE	//Private, build MISCT for wildcard selections
	
	// This label is called from MISC label
	
	type Public Number ER
	type Public String MISCT(),RM, X
	
	type Number COUNT
	type String TABLE, WHERE
	
	set ER=0
	set COUNT=0
	set TABLE=$E(X,1,$L(X)-1)
	
	set WHERE = "%LIBS='SYSDEV' AND NETLOC NOT =0 AND FID LIKE '"_TABLE_"%' and GLOBAL NOT='UTBL' AND GLOBAL NOT='CTBL' AND GLOBAL NOT ='STBL' and GLOBAL NOT ='DBTBL'"

	#ACCEPT Date=07/13/06; Pgm=RussellDS; CR=22121
	type ResultSet misc=Db.select("FID","DBTBL1", WHERE)
	if misc.isEmpty() set ER=1 set RM=$$^MSG(1332) quit

	while misc.next() do {
		if $$CHKBIN(misc.getCol(1)) quit
		set COUNT=COUNT+1
		set MISCT(misc.getCol(1))="SYSDEV"
		}

	//Invalid file
	if COUNT=0 set ER=1 set RM=$$^MSG(1332)

	quit


GETTABLE(TABLE)	// Prompt for table names (user,system or common)

	/*

	The purpose of this function is to prompt for the table name of either 
	user,system and common table data to be shipped to a client. Once selected
	the array TABLE will be setup keyed by the table name with data containing
	tables related to this table through foreign keys.
	
	This label is called from label CTBL,MISC,STBL and UTBL to perform the common
	portions of prompting for tables.

	Arguments:
 
	. TABLE		Table Name		/TYP=T/REQ/MECH=VAL

	*/
	
	type Public String vtblutbl()
	
	type String ARRAY,DBTBL,FILE,OLNTB,%READ,REL,VFMQ,X

	set OLNTB=30
	set %READ="@HDG/CEN/REV,,,ARRAY/REP=20"	

	do ^UTLREAD if VFMQ="Q" quit 
	do BUILDVTBL
	
	set X=""
	for  set X=$O(ARRAY(X)) quit:X=""  do {
		if ARRAY(X)="" quit 
		if $D(vtblutbl),ARRAY(X)'="" set FILE=$P(vtblutbl(ARRAY(X)),"|",2)
		else  set FILE=ARRAY(X)
		if FILE="*" quit
		if $$LOGGING^DBSTLOAD(FILE)=0 quit
		do SETENTRY(FILE,.TABLE)
		} 
	do RESETTAB(.TABLE)
	quit 


	
SETENTRY(FILE,TABLE)	// Determine foreign keys for a table and add it the array 

	/*
	The purpose of this function is to build an array entry for a single table. The
	data portion of the array will contain the tables related to the table via foreign 
	keys in the proper order to allow dropping tables and ultimately the reinsertion
	of the records without causing errors with the loading of the data (foreign key
	restaints)
	
	This label is called from labels GETLABEL and FID

	Arguments: 
	. FILE		Table Name				/TYP=T/REQ/MECH=VAL
	. TABLE		Array of Table Names related to FILE	/TYP=T/REQ/MECH=REFARRAY:W

	*/

	type String GLOBAL,INDEX,REL

	set REL=$$FNDFKEYS(FILE)
	for INDEX=1:1:$L(REL,",") do {
		if $P(REL,",",INDEX)="" quit 
		set GLOBAL=$$LOCGBL($P(REL,",",INDEX))
		set $P(REL,",",INDEX)=$P(REL,",",INDEX)_"~"_GLOBAL
		}
	set GLOBAL=$$LOCGBL(FILE)
	set TABLE(FILE)="SYSDEV||"_REL_"|"_GLOBAL
	quit


RESETTAB(TABLE)	// Remove duplicate entries from the array in order to prevent duplication
	
	/*

	The purpose of this function is to remove duplicate entries from the TABLE array.
	Duplicate entries can occur when tables related through foreign keys are all entered
	by a user or function DDPXFRGU.

	This label is called from GETLABEL and FID
	
	Arguements:

	. TABLE		Table Name		/TYP=T/REQ/MECH=VAL

	*/

	type String FID,INDEX,REL

	set FID=""
	for  set FID=$O(TABLE(FID)) quit:FID=""  do {
		set REL=$P(TABLE(FID),"|",3)
		for INDEX=1:1:$L(REL,",") if FID'=$P($P(REL,",",INDEX),"~",1) kill TABLE($P($P(REL,",",INDEX),"~",1))
		}
	quit
	
	
public TRAN	// Tran Codes

	/*
	This label is used to prompt for transaction codes to transfer to a client

	The output from this label is the array TRAN1 and FLG(10)
	*/
	
	type public String FLG(),TRAN1(), VFMQ
	
	type String HDG,OLNTB,%READ,%TAB,TRAN,X
	
	// Prompt for Transaction Codes to Transfer
	set HDG=$$^MSG(3445)
	set %TAB("TRAN")=".TRN1/TBL=[TRN]"
	set OLNTB=30
	set %READ="@HDG/CEN/REV,,TRAN/REP=20"
	do ^UTLREAD if VFMQ="Q" quit 
	
	// loop through return from prompts and build array TRAN1 with valid tran codes
	set X=""
	for  set X=$O(TRAN(X)) quit:X=""  if TRAN(X)'="",TRAN(X)'?.E1L.E set TRAN1(TRAN(X))=""
	if $D(TRAN1)<2 set FLG(10)=0
	else  set FLG(10)=1

	quit 
		 
	
ITCHK	//Validate to see if the internal table is a valid table on the host/fep
	
	type Public Number ER
	type Public String RM, vtblutbl(), X
	
	if X="" quit 

	// Invalid Table Value
	if 'vtblutbl(""_X_"").exists() set ER=1 set RM=$$^MSG(7194) quit

	quit 
	
	
CHKBIN(FILENAME)	// Disallow transfer of data with memo and binary fields
	
	/*
	Binary and memo data items-data can not be transferred since we
	can not determine the end of the data stream. Therefore, gui branches
	must use sql selects to retrieve the fields.

	Arguments:
	. FILENAME		Table Name		/TYP=T/REQ/MECH=VAL

	*/

	type Public String RM, X

	type Number ER
	
	type ResultSet rsfid=Db.select("DI","DBTBL1D","FID=:FILENAME AND (TYP='M' OR TYP='B')")
	if rsfid.isEmpty() set ER=0
	//Table ~p1 contains memo or binary columns which cannot be transferred
	else  set RM=$$^MSG(2473,X),ER=1 

	quit ER


public GETQUE()	// Get the next queue number, also called by external interface

	// %QN is used by the calling label to build a output file
	
	type Public String DDP()
	
	type Number %QN

	lock +DDP("TQUE")
	type RecordDDPTQUENUM ddptque0=Db.getRecord("DDPTQUENUM")
	set %QN=ddptque0.quenum
	if +%QN=0 set %QN=1
	set ddptque0.quenum=%QN+1
	do ddptque0.bypassSave()
	lock -DDP("TQUE")

	quit %QN
	

XLOGINIT	// Set up header record for XLOG

	type Public Number IONUMB()

	type String VER

	type RecordDDPXLOG xlog=Class.new("RecordDDPXLOG")
	set xlog.tjd=%SystemDate
	set xlog.cdt=%CurrentDate
	set xlog.ctm=%CurrentTime
	set xlog.username=%UserName


	set VER=""
	for  set VER=$O(IONUMB(VER)) quit:VER=""  do {
		set xlog.%qn=IONUMB(VER)
		do xlog.bypassSave()
		}
	quit
	
	 
XLOG(DATA)	// Private;

	type Public Number IONUMB()
	type Public String DDPLOG()

	type String QN, VER

	set VER=""
	for  set VER=$O(DDPLOG(VER)) quit:VER=""  do {
		type RecordDDPXLOG1 xlog1=Class.new("RecordDDPXLOG1")
		set QN=IONUMB(VER)
		set xlog1.dataref=$P(DATA,"|",1)
		set xlog1.data=$TR($P(DATA,"|",2,300),"|",$C(28))
		set xlog1.tjd=%SystemDate
		set xlog1.%qn=QN
		set xlog1.seq=Db.nextVal("DDPXLOG1","%SystemDate,QN")
		do xlog1.bypassSave()
		}
	quit 

	
public FILE	// file Table DDPTQUE and DDPTQUE1 entries to allow retrieval from by client
	
	type public Date DATE
	type public Number IONUMB(),%QN,TIME
	type public String CLIENT(,),DDPDIR,FEP(),GLOFILE,HOSTDIR,IOLIST(),SAVELAST
	
	type String CLIENTNM,DISPLAYQ,FEPDIR,FILE,QINFO,VER

	set (DISPLAYQ, VER) = ""
	if $D(IOLIST) for  set VER=$O(IOLIST(VER)) quit:VER=""  do {
		set FILE=$P(IOLIST(VER),IONUMB(VER)_".FEP",1)
		set FILE=$E(FILE,$L(FILE))_IONUMB(VER)_".FEP"
		
		type RecordDDPTQUE tque=Class.new("RecordDDPTQUE")
		set tque.date=DATE
		set tque.time=TIME
		set tque.tblrms=FILE
		set tque.dirnam=DDPDIR
		if $G(SAVELAST)'="" set tque.savelast=SAVELAST
		set tque.%qn=IONUMB(VER)
		do tque.bypassSave()
		set DISPLAYQ=DISPLAYQ_","_IONUMB(VER)
		set CLIENTNM=""
		if $D(CLIENT(VER))'>1 quit

		for  set CLIENTNM=CLIENT(VER,CLIENTNM).order() quit:CLIENTNM.isNull()  do {
			type RecordDDPTQUE1 tque1=Class.new("RecordDDPTQUE1")
			set tque1.%qn=IONUMB(VER)
			set %QN=IONUMB(VER)
			set tque1.fepdir=CLIENTNM
			set tque1.hostdir=HOSTDIR
			set tque1.stat=0
			do tque1.bypassSave()
			}
		}
	set DISPLAYQ=$E($G(DISPLAYQ),2,100)
	if $G(GLOFILE)="" do WRTMSG(DISPLAYQ) quit

	/*

	GLOFILE will be defined only when called from FEPTFILE routine for branch
	related accounts. (label BRACNSND)

	*/
	type RecordDDPTQUE tque=Class.new("RecordDDPTQUE")
	set tque.%qn=%QN
	set tque.date=DATE
	set tque.time=TIME
	set tque.tblrms=$G(GLOFILE)
	set tque.dirnam=DDPDIR
	do tque.bypassSave()

	set FEPDIR=""

	type RecordDDPTQUE1 tque1=Class.new("RecordDDPTQUE1")
	set tque1.%qn=%QN
	for  set FEPDIR=$O(FEP(FEPDIR)) quit:FEPDIR=""  do {
		set tque1.fepdir=FEPDIR
		set tque1.hostdir=HOSTDIR
		set tque1.stat=0
		do tque1.bypassSave()
		}
	
	do WRTMSG(%QN)
	quit


WRTMSG(%QN)	// Private; write message to indicate success or failure

	type Public Number NOINT

	type String MSG

	//DDP network transfer queue ~p1 for tables filed
	set MSG=$$^MSG(7495,%QN)

	// I18N=OFF:

	if $G(NOINT) write !,$$MSG^%TRMVT(MSG,0,0) quit 
	write $$MSG^%TRMVT(MSG,0,1)

	// I18N=ON:

	quit
	
	
RESORT(WIDEFILE,SORTFID,FILENAME) //	Utility to redefine the table to be split
	
	/*
	 The SORTFID array is created from the wide table map, but is keyed by
	 the split table name. Each split file will also contain the keys in each table

	Parameters:
		WIDEFILE	unsorted map of how the wide table is split	/MECH=REFNAM/TYP=T/NOREQ
		SORTFID		Output from this label, sorted map of WIDEFILE	/MECH=REFNAM:W/TYP=T
		FILENAME	Table name corresponding to WIDEFILE		/MECH=VAL/TYP=N/REQ
	*/
		
	type String ACCKEYS,FID,JI,X,Y
	
	kill SORTFID
	set (X,Y)=""

	for  set X=$O(WIDEFILE(X)) quit:X=""  do {
		for  set Y=$O(WIDEFILE(X,Y)) quit:Y=""  do {
			set FID=WIDEFILE(X,Y)
			if FID'="" set SORTFID(FID,Y)=""
			}
		}
	
	type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:FILENAME")
	set ACCKEYS=dbtbl1.acckeys
	// Add the key structure into every split (subset) of the wide table

	for  set X=$O(SORTFID(X)) quit:X=""  do {
		set SORTFID(X)=FILENAME
		F JI=1:1 Q:$P(ACCKEYS,",",JI)=""  S SORTFID(X,$P(ACCKEYS,",",JI))=""
		}

	quit 

	
BUILDVTBL	//Private

	// build additional entries into vtblutbl based on table name which
	// is in piece 2 of the original entry
	
	type Public String vtblutbl()
	
	type String X,Y
	
	set X=""
	for  set X=$O(vtblutbl(X)) quit:X=""  do {
		if X["_" do {
			set Y=$P(vtblutbl(X),"|",2)
			set vtblutbl(Y)=vtblutbl(X)
			}
		}
	quit 
	

	
FNDFKEYS(FID,SCHEMA)	//Private, Build foreign key linkage to a table

	/*
	Build  foriegn key list in an order that will be prevent errors
	when data is dropped.  Errors could occur if tables related via foreign 
	keys are not dropped in a specific order.
	
	Beginning with the table being requested, work through tables that are linked to that file 
	through foreign key relationships. The table requested is assigned a weight of 1000, depending 
	on the relation defined in forign keys, the related tables will be assigned values greater
	then or less then 1000. Relationships for all tables realted to this first table are then
	traced and those tables will assigned a numeric value greater then or less then the new table 
	being reviewed. The number assigned to a table is based on the value of the table it is
	linked to, that value will either be 1/2 of the value or 1 1/2 times the value.
	
	Those tables with foreign keys that list the table in the related table field 
	will be assigned a weight greater then the primary account. 
	
	Those tables which are defined in the foreign key definition for this table as related 
	tables will be assigned a weight less then the table. 
	
	Tables with the highest weight value will have their data removed first during the 
	sync of the data. These tables are the lowest entity, no other tables are dependent on
	their data. BY dropping their data, the tables to which they are dependent no longer have
	data links that would prevent their data from being removed, so those tables can then be 
	removed.
	
	The order described above to delete data and schema must be reversed in order to recreate 
	the data. The lowest weighted tables are inserted first since their data must exist for
	the related tables records to be inserted.
	
	Arguments:
	. FID		Table Name		/TYP=T/REQ/MECH=VAL
	. SCHEMA	Transfer Schema	(?)	/TYP=L/NOREQ/MECH=VAL

	*/
	
	type Number WEIGHT
	type String FIDLIN,FIDLINK,FIDLIST,I,J,LINK,LIST,LINKFILE,NEWLINK,NL,NOMORE,SUBWGHT,X,XFIDLIN

	set FIDLIST(FID)=1000
	do SETLINKS(FID)
	
	/*
	 SETLINKS will assign weights for a individual table.  The LINKFILE array indicates that the
	 file has already been processed by SETLINKS.  SETLINKS adds all tables that this table has
	 assigned foreign keys that point to those tables. 
	 This process continues until LINKFILE contains no tables to process.
	*/  
	for  do { quit:NOMORE 
		set FIDLIN=""
		for  set FIDLIN=$O(LINKFILE(FIDLIN)) quit:FIDLIN=""  do SETLINKS(FIDLIN) set LINKFILE(FIDLIN)=1
		set NOMORE=1
		for  set FIDLIN=$O(LINKFILE(FIDLIN)) quit:FIDLIN=""  if LINKFILE(FIDLIN)'=1 set NOMORE=0
		}
		
	/*
	 The next section performs the same processing as the section above, except the keys it reviews
	 are for the tables that indicate that this table is realted to them.
	*/
	set X=""
	kill LINKFILE
	for  set X=$O(FIDLIST(X)) quit:X=""  do {
		set LIST=$$RELFID(X,1)
		for I=2:1:$L(LIST,",") do {
			set LINK=$P(LIST,",",I)
			if $G(FIDLIST(X))=$G(FIDLIST(LINK)) set FIDLIST(LINK)=FIDLIST(LINK)+1
			}
		}
		
	for  set X=$O(FIDLIST(X)) quit:X=""  set LINKFILE(FIDLIST(X),X)=""
	set WEIGHT=""
	set FIDLIST=""

	//convert array toa string of tables in the order they need to be removed/loaded
	for  set WEIGHT=$O(LINKFILE(WEIGHT)) quit:WEIGHT=""  do {
		for  set X=$O(LINKFILE(WEIGHT,X)) quit:X=""  set FIDLIST=FIDLIST_","_X
		}
	set FIDLIST=$E(FIDLIST,2,$L(FIDLIST))
	quit FIDLIST


SETLINKS(FID)	//Private, based on table determine other tables linked to it

	/*
	. FID		Table Name		/TYP=T/REQ/MECH=VAL

	*/
	
	type Public Number WEIGHT
	type Public String FIDLIST(),LINK,SCHEMA

	set LINK=$$FIDFKEYS(FID)
	set LINK=$E(LINK,2,$L(LINK))
	
	// some tables require some order to start the process
	if FID="PRODDFTD"!(FID="PRODDFTL")!(FID="PRODDFTC")!(FID="CIF") set LINK="PRODCTL"
	if LINK="PRODCTL" set LINK="PRODCTL,UTBLLLD"
	if FID="UTBLLLD" set LINK=LINK_",PRODCTL"
	
	set WEIGHT=FIDLIST(FID)\2
	do SETWEIG
	set LINK=$$RELFID(FID,.SCHEMA)
	set WEIGHT=(FIDLIST(FID)*3)\2
	do SETWEIG
	quit


SETWEIG	//Private, reset wight of tables listed in variable LINK

	type Public Number WEIGHT
	type Public String FID, FIDLIST(), LINK, LINKFILE()

	type String FIDLINK,I,J,SUBWGHT,X
	
	for I=1:1:$L(LINK,",") do {
		if $P(LINK,",",I)="" quit 
		set FIDLINK=$$RELFID($P(LINK,",",I))
		if $P(LINK,",",I)="PRODCTL" set FIDLINK="PRODDFTD,PRODDFTL,CIF,PRODDFTC"
		set X=","_$P(LINK,",",I)_","
		if 'LINKFILE($P(LINK,",",I)).exists() set LINKFILE($P(LINK,",",I))=""
		set X=+$G(FIDLIST($P(LINK,",",I)))
		if X=0!(X'>WEIGHT) set FIDLIST($P(LINK,",",I))=WEIGHT
		set SUBWGHT=(WEIGHT*3)\2
		for J=1:1:$L(FIDLINK,",") do {
			set X=$P(FIDLINK,",",J)
			if X="" quit 
			set X=","_X_","
			set X=+$G(FIDLIST($P(FIDLINK,",",J)))
			if X=0!(X'>SUBWGHT) set FIDLIST($P(FIDLINK,",",J))=SUBWGHT
			}
		}
	quit 
	
	
RELFID(FID,SCHEMA)	// Find tables linked to this table

	/*
	Description:
	Generate a list of tables that this table has pointers FROM that table for
	foreign keys realtionships

	Arguments:
	. FID		Table Name		/TYP=T/REQ/MECH=VAL
	. SCHEMA	Transfer Schema	(?)	/TYP=L/NOREQ/MECH=VAL

	*/

	type String LIST,NL,SFID,X,XFID
	
	set NL=$$LOGGING^DBSTLOAD(FID) if NL=0 quit ""
	set LIST=""

	type ResultSet rsfkeys=Db.select("FID","DBTBL1F","TBLREF=:FID and %LIBS='SYSDEV'")
	if rsfkeys.isEmpty() quit ""

	while rsfkeys.next() do {
		set XFID=rsfkeys.getCol(1)
		if $G(SCHEMA) set LIST=LIST_","_XFID
		else  do {
		
			type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:XFID")
			if +dbtbl1.netloc=0 quit
			if +dbtbl1.log=0 quit
			set LIST=LIST_","_XFID
			}
		}

	quit LIST


FIDFKEYS(FID)	// Find tables linked to this table

	/*
	Description:

	Generate a list of tables that this table has pointers to that table for
	foreign keys relationships

	Arguments:
	. FID		Table Name		/TYP=T/REQ/MECH=VAL

	*/
	
	type String LIST,TBLREF

	if $$LOGGING^DBSTLOAD(FID)=0 quit ""
	set LIST="" 

	type ResultSet rsfkeys=Db.select("TBLREF","DBTBL1F","FID=:FID AND %LIBS='SYSDEV'")
	if rsfkeys.isEmpty() quit ""
	
	while rsfkeys.next() do {
		set TBLREF=rsfkeys.getCol(1)
		type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:TBLREF")
		if +dbtbl1.netloc=0!(+dbtbl1.log=0) quit
		set LIST=LIST_","_TBLREF
		}

	quit LIST


LOCGBL(FID)	//
	/*
	Arguments:
	. FID		Table Name		/TYP=T/REQ/MECH=VAL
	*/
	
	type String GLOBKEY

	if FID="TRN"!(FID="TRNAUT") quit ""

	// do not send to GUI clients
	if Db.isDefined("STBLNOGUI","FID") quit ""

	type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:FID")
	// Log flag turned off
	if +dbtbl1.log=0 quit ""

	//NETWORK location set to 0
	if +dbtbl1.netloc=0 quit ""

	if dbtbl1.filetyp=4!(dbtbl1.filetyp="") quit "" 
	
	set GLOBKEY=dbtbl1.glref
	set GLOBKEY=$P(GLOBKEY,"(",2)
	set GLOBKEY=$P(GLOBKEY,",",1)
	set GLOBKEY=$E(GLOBKEY,2,$L(GLOBKEY)-1)

	if dbtbl1.global="UTBL" quit "UTBL-"_GLOBKEY
	if dbtbl1.global="STBL" quit "STBL-"_GLOBKEY
	if dbtbl1.global="CTBL" quit "CTBL-"_GLOBKEY
	                      
	if dbtbl1.global="DBTBL" quit ""

	quit "MISCT"_"-SYSDEV"
	

%EXT(BRANCH,FID,TRN,UTBL,STBL,CTBL,MISC)	//Build full load of data via script call
	
	/*
		Description:
		The code from this section was moved to procedure HSYNCFULLALL in order to move like 
		functionality into the same procedures. The line tag has been preserved since the unix scripts
		used to call it are not version dependent. 
	*/

	
	do EXT^HSYNCALL(.BRANCH,.FID,.TRN,.UTBL,.STBL,.CTBL,.MISC)
	
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60817^39258^Vanitha Krishnasamy^22828"	// Signature - LTD^TIME^USER^SIZE
