SWMQXFR	//Private;Mass SWIFT Message Relocating Routine
	/*
	   ORIG: YANGR - 05/19/94
	   DESC: SWIFT Message Relocating Routine
	   Remove message from anyone queue to another.
	   There are four cases considered:
	   1. From a non-date queue to a non-date queue
	   2. From a non-date queue to a dated queue
	   3. From a dated queue to a non-date queue
	   4. From a dated queue to a dated queue
	   There are a total of 6 queues:RTT(d), PND, REP, CMP(d), TLX(d), REV

	====================================================================
	I18N=OFF
	---Revision History---------------------------------------------

	10/17/05 - KUMARB - CR 17050
		   Modified the look up for %TAB("fSEQ") and %TAB("tSEQ")
		   in section VPG00. In section ACT added quit in the 
		   check (if "Q"[VFMQ).
	
	09/26/05 - KELLYP - CR 17050
		   Modified top level of procedure to call MAIN section.
		   The @SWMQXFR function calls the top-level so it was
		   quitting before doing anything.

	09/07/05 - KELLYP - CR 17118
		   Replaced references to MSG100DT with MSG103DT.  SWIFT
		   has obsoleted the MT100 and all references to it are
		   being removed from the system.  Also removed pre-2003
		   revision history.

        07/26/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.
	 
	01/12/04 - RussellDS - CR 7514
		   Replaced use of table SWIFTTMP (obsoleted) and SWRTTRMV
		   (obsoleted) with the single table TMPRPT1.
	   
	06/13/03 - BHANGALEV - 51351
		   Converted to PSL
	------------------------------------------------------------------
	*/

	do MAIN
	
	quit

public MAIN	//

	type Public String VFMQ
	
	set VFMQ=0

	//set to display mode
	do INIT(2)
	
	quit
	
	
INIT(Number %ProcessMode)
	
	/*
	  ARGUMENTS:
	  	. %ProcessMode		Process mode	/REQ/MECH=VAL
	*/

	type public Boolean ER
		
	set ER=0
	do VPG00
	
	quit

	
VPG00	//set up

	type public String %NOPRMT,%NOPRMPT,%ProcessID,%READ,%TAB,ER,FROMQ,RM,VFMQ
	type public Number count,PID,loopn
	type Number OLNTB,fSEQ,tSEQ

	set PID=%ProcessID
	
	//%READ-data to be prompted; %TAB-data type,length,prompted
	set %TAB("FROMQ")=".FROMQ/REQ/TBL=[STBLSWQNAM]KEY:DISTINCT/XPP=D CHECKFR^SWRTTRMV"
	set %TAB("TOQ")=".TOQ/REQ/TBL=[STBLSWQNAM]KEY:DISTINCT/XPP=D CHECKTO^SWRTTRMV"
	set %TAB("IO")=$$IO^SCATAB($I)
	set %READ="@@%FN,,FROMQ,,TOQ"
	set %NOPRMT="F"
	
	do ^UTLREAD

	//No Message Relocation Performed"
	if "Q"[VFMQ do {
		set ER="W"
		set RM=$$^MSG(7359)
		do Db.fastDelete("TMPRPT1","PID=:PID")
		}
	if ER quit
	
	//init for new prompt
	kill %TAB,%READ
	
	if ((FROMQ="RTT")!(FROMQ="TLX")) do {
		set %TAB("fSWDATE")=".SWDATE/REQ/TBL=[SWQCNTD]DT:DISTINCT:QU [SWQCNTD]QUE=FROMQ"
		set %TAB("fSEQ")=".FSEQ/TBL=[TMPRPT1]KEY1:QU ""[TMPRPT1]PID=<<PID>>""/REQ/XPR=D MOVEFROM^SWMQXFR(FROMQ,fSWDATE)"
		set %TAB("tSEQ")=".TSEQ/TBL=[TMPRPT1]KEY1:QU ""[TMPRPT1]PID=<<PID>>""/REQ/XPP=D TSEQ^SWMQXFR"
		}

	if ((FROMQ="PND")!(FROMQ="REP")!(FROMQ="REV")) do {
		do MOVEFROM(FROMQ)
		set %TAB("fSEQ")=".FSEQ/TBL=[TMPRPT1]KEY1:QU ""[TMPRPT1]PID=<<PID>>""/REQ"
		set %TAB("tSEQ")=".TSEQ/TBL=[TMPRPT1]KEY1:QU ""[TMPRPT1]PID=<<PID>>""/REQ/XPP=D TSEQ^SWMQXFR"
		}

	//Now prompt for SEQ for swift REP queue
	if ((FROMQ="RTT")!(FROMQ="TLX")) set %READ=",,fSWDATE,fSEQ,tSEQ"
	else  set %READ=",,fSEQ,tSEQ,"

	set %NOPRMPT="N"

	//set prompt position on the screen LLCCC
	set OLNTB=06030

	do ^UTLREAD

	if VFMQ="Q" do ACT quit

	//Now collate thru each sequence and move it to new queue
	set loopn=""
	set count=tSEQ-fSEQ

	for loopn=fSEQ:1:tSEQ do XFR(loopn)
	
	do END
	
	quit


XFR(Number SEQ)	//
	
	/*
	  ARGUMENTS:
	  	. SEQ		Sequence number		/REQ/MECH=VAL
	*/	
	type Public Number PID,QUESEQ
	type Public String ER,FROMQ,MSG,RM,SWDIRECT,TRREFNO,VFMQ
	type Public Date SWDATE
	type String SWIFT()
	type String SWIFTQ()
	
	type RecordTMPRPT1 tmprpt1=Db.getRecord("TMPRPT1","PID=:PID,KEY1=:SEQ",1)

	set SWDIRECT="OUT"
	set SWDATE=tmprpt1.data.curVal.piece("|",1)
	set TRREFNO=tmprpt1.data.curVal.piece("|",2)
	set MSG=tmprpt1.data.curVal.piece("|",3)
	set QUESEQ=tmprpt1.data.curVal.piece("|",4)

		
	//lock the record before the change.
	lock +SWIFT(SWDIRECT,TRREFNO,MSG):2 else  set ER=1,RM=$$^MSG(2333),VFMQ="Q" do ACT
	
	// Record locked by another user
	lock +SWIFTQ(FROMQ):2 else  set ER=1,RM=$$^MSG(2333) quit
	
	do ACT
	
	quit	


ACT	//display the SWIFT Msg (one of 103,202,210,300),prompt for FILE or QUIT

	type Public String ER,FROMQ,MSG,RM,SWDIRECT,TOQ,TRREFNO,VFMQ
	type Public Date SWDATE
	type String noint,NEWSTAT,OLDSTAT,SWIFTQ(),SWIFT()
	type Date OLDDATE
	type Number cid,seq
	type Public Number PID
	
	//No Message Relocation Performed
	if "Q"[VFMQ do { quit
		set ER="W"
		set RM=$$^MSG(7357)
		do Db.fastDelete("TMPRPT1","PID=:PID")
		}
		
	// for another locking
	if ER quit
	
	if "DF"[VFMQ do {
		type RecordSWIFT fSWIFT=Db.getRecord("SWIFT","SWDIRECT=:SWDIRECT,TRREFNO=:TRREFNO,MSG=:MSG",1)
		
		//old status
		set OLDSTAT=fSWIFT.status
		
		//old date 
		set OLDDATE=fSWIFT.date
		
		set NEWSTAT=$S(TOQ="RTT":0,TOQ="PND":1,TOQ="REP":2,TOQ="CMP":3,TOQ="REV":6,TOQ="TLX":7,1:"")
		
		//set UX array
		do fSWIFT.setAuditFlag(1)
		
		//update to new del status
		set fSWIFT.status=NEWSTAT
		
		//update to new response date
		set fSWIFT.date=%SystemDate
		
		do fSWIFT.save()
		
		//find source Global EFTPAY
		type ResultSet rs=Db.select("CID,SEQ","EFTREF","REFNO=:TRREFNO")
		while rs.next() do {
			set cid=rs.getCol("CID")
			set seq=rs.getCol("SEQ")
			}
		
		type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:cid,SEQ=:seq")
		if MSG=103 set eftpay.msg103dt=%SystemDate
		if MSG=202 set eftpay.msg202dt=%SystemDate
		
		//find source Global DEAL1
		else  do {
			set noint=fSWIFT.noint
			if noint="" quit
		
			type RecordDEAL1 deal1=Db.getRecord("DEAL1","NOINT=:noint")
			if MSG=202 set deal1.msg202dt=%SystemDate
			if MSG=210 set deal1.msg210dt=%SystemDate
			if MSG=300 set deal1.msg300dt=%SystemDate
			}
			
		if ((FROMQ="RTT")!(FROMQ="TLX")) do {
			
			//kill from DATED que
			do Db.delete("SWIFTQ1","QUE=:FROMQ AND DT=:SWDATE AND SEQ=:QUESEQ AND TRREFNO=:TRREFNO AND TYPE=:MSG")
	
			type RecordSWQCNTD swqcntd=Db.getRecord("SWQCNTD","QUE=:FROMQ,DT=:SWDATE",1)
			
			//decrease total num in FROMQ que
			set swqcntd.tot=+swqcntd.tot-1
			do swqcntd.bypassSave()
			
			}
			
		if ((FROMQ="PND")!(FROMQ="REP")!(FROMQ="REV")) do {
			
			//kill from NON-DATED que
			do Db.delete("SWIFTQ2","QUE=:FROMQ AND SEQ=:QUESEQ AND TRREFNO=:TRREFNO AND TYPE=:MSG")
			type RecordSWQCNT swqcnt=Db.getRecord("SWQCNT","QUE=:FROMQ")
			
			//decrease total num in FROMQ que
			set swqcnt.tot=+swqcnt.tot-1
			do swqcnt.bypassSave()
			
			}
		if ((TOQ="RTT")!(TOQ="CMP")!(TOQ="TLX")) do MOVETOD(TOQ,.fSWIFT)
		if ((TOQ="PND")!(TOQ="REP")!(TOQ="REV")) do MOVETON(TOQ)
		
		//p1_" "_p2_" "_"Relocated From "_p3_" Queue To "_p4_" Queue"
		set ER="W"
		set RM=$$^MSG(7361,TRREFNO,MSG,FROMQ,TOQ)
		}
	
	//unlock the record
	lock -SWIFT("OUT",TRREFNO,MSG)
	lock -SWIFTQ(FROMQ)
	
	quit


MOVETON(String TOQ)	//
	/*
	  ARGUMENTS;
	  	. TOQ	SWIFT Queue Name	/REQ/MECH=VAL
	  	
	   case1 relocate msg from non-date que to non-date que.
	   From: PND,REP To: PND,REP,REV
	*/

	type Number QSEQ
	type Public String MSG,TRREFNO

	type RecordSWQCNT swqcnt=Db.getRecord("SWQCNT","QUE=:TOQ",1)

	if swqcnt.getMode()=1 do {
		set swqcnt.nseq=+swqcnt.nseq+1
		set swqcnt.tot=+swqcnt.tot+1
		set swqcnt.ptoday=+swqcnt.ptoday+1
		}
	
	else  do {
		set swqcnt.nseq=1
		set swqcnt.tot=1
		set swqcnt.ptoday=1
		}
		
	//set the next sequence
	set QSEQ=swqcnt.nseq
	do swqcnt.bypassSave()
	
	type RecordSWIFTQ2 swiftq2=Db.getRecord("SWIFTQ2","QUE=:TOQ,SEQ=:QSEQ,TRREFNO=:TRREFNO,TYPE=:MSG",1)
	do swiftq2.bypassSave()
	
	quit


MOVETOD(String TOQ,RecordSWIFT fSWIFT)

	/*
	  ARGUMENTS;
	  	. TOQ		SWIFT Queue Name	/REQ/MECH=VAL
	  	.fSWIFT		SWIFT Object		/REQ/MECH=REF
	  	
	  case2 relocate msg from non-date que to dated que
	   From: PND,REP,REV To: RTT,CMP,TLX
	  if TOQ="CMP", DATE is set to TJD
	  if TOQ="RTT" or "TLX",DATE is set to $P(^SWIFT("OUT",TRREFNO,MSG,1),"|",52)

	*/
	
	type Public String MSG,TRREFNO
	type Public Number QSEQ
	type Public Date SWDATE
	
	set SWDATE=fSWIFT.swftdt
	
	type RecordSWQCNTD swqcntd=Db.getRecord("SWQCNTD","QUE=:TOQ,DT=:SWDATE",1)
	
	if swqcntd.getMode()=1 do {
		set swqcntd.nseq=+swqcntd.nseq+1
		set swqcntd.tot=+swqcntd.tot+1
		set swqcntd.ptoday=+swqcntd.ptoday+1
		}
		
	else  do {
		set swqcntd.nseq=1
		set swqcntd.tot=1
		set swqcntd.ptoday=1
		}
		
	set QSEQ=swqcntd.nseq
	
	do swqcntd.bypassSave()
	
	type RecordSWIFTQ1 swiftq1=Db.getRecord("SWIFTQ1","QUE=:TOQ,DT=:SWDATE,SEQ=:QSEQ,TRREFNO=:TRREFNO,TYPE=:MSG",1)
	do swiftq1.save()
	
	quit


MOVEFROM(String FROMQ,Date SWDATE)	//

	/*
	  ARGUMENTS:
	  	. FROMQ		Queue Type	/REQ/MECH=VAL
	  	. SWDATE	Date		/REQ/MECH=VAL
	  		
	  Build the temporary global TMP($J,SEQ)=SWDATE|TRREFNO|MSG|QUESEQ
	  in order to display the complete list of messages in FROMQ
	  $J is the processor ID, the global TMP can only be deleted by the owner.
	*/

	type Public Number PID,QUESEQ
	type Public String MSG,TRREFNO
	type Number SEQ
	
	//clear tmp global TMP
	do Db.fastDelete("TMPRPT1","PID=:PID")
	
	//init temp global sequence number
	set SEQ=0
	
	//DATE element exists
	if ((FROMQ="RTT")!(FROMQ="TLX")) do {
		type ResultSet rs=Db.select("SEQ,TRREFNO,TYPE","SWIFTQ1","QUE=:FROMQ AND DT=:SWDATE")
		while rs.next() do {
			set SEQ=SEQ+1
			
			// to set the TMP GLOBAL
			type RecordTMPRPT1 tmprpt1=Db.getRecord("TMPRPT1","PID=:PID,KEY1=:SEQ",1)
			
			set tmprpt1.data=SWDATE_"|"_TRREFNO_"|"_MSG_"|"_QUESEQ
			
			do tmprpt1.bypassSave()
			
			}
		}

	//No DATE element
	if ((FROMQ="PND")!(FROMQ="REP")!(FROMQ="REV")) do {
		type ResultSet rs=Db.select("SEQ,TRREFNO,TYPE","SWIFTQ2","QUE=:FROMQ","SEQ,TRREFNO,TYPE")
		while rs.next() do {
			set SEQ=SEQ+1
			
			// to set the TMP GLOBAL
			type RecordTMPRPT1 tmprpt1=Db.getRecord("TMPRPT1","PID=:PID,KEY1=:SEQ",1)
			
			set tmprpt1.data="|"_TRREFNO_"|"_MSG_"|"_QUESEQ
			
			do tmprpt1.bypassSave()
			
			}
		}
	quit


CHECKFR	//check "from queue" name
	
	type Public String ER,RM,X
	set RM=""
	
	//No message should be moved from CMP queue
	if X="CMP" set ER=1,RM=$$^MSG(7358)
	
	quit


CHECKTO	//check "to queue" name

	type Public String ER,FROMQ,RM,X
	
	set RM=""

	//To queue may not be From queue
	// Must be a different queue
	if X=FROMQ set ER=1,RM=$$^MSG(7360)

	quit


TSEQ	// Post processor on To Sequence
	
	type Public String fSEQ,ER,RM,X
	
	//TO sequence must be greater than or equal to FROM sequence
	if X<fSEQ set ER=1,RM=$$^MSG(8282)

	quit

END
	type Public String ER,FROMQ,RM,VFMQ,TOQ
	type Public Number count

	if VFMQ="Q" quit
	
	//$G(count)+1_" messages moved from "_$G(FROMQ)_" to "_$G(TOQ)
	set ER="W"
	set RM=$$^MSG(8283,count.get()+1,FROMQ.get(),TOQ.get())
	
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60190^41522^Balasubramonian Sankar^10300"	// Signature - LTD^TIME^USER^SIZE
