CIFCDI		/* This procedure definition replaces [.MRTNS]CIFCDI.M
	
	   ORIG: FSANCHEZ - 01/17/94
	   DESC: Customer Information File Computed Data Item library
	
	
	   LIBRARY:
	   . $$ADDRESS  - Address Array
	   . $$AGE      - Customer age
	   . $$CARDUF   - Card Use Flag
	   . $$CIFCLCD  - CIF Customer Last Contact Date
	   . $$CMPACN   - CRD ACN value
	   . $$DLC      - Date Last Contact
	   . $$DOODCUR  - Days out of debt current year
	   . $$DOODYTD  - Days out of debt year to date
	   . $$EMDATE   - Elig/man Date
	   . $$IRAEM    - Elig/man Disb
	   . $$RESTAVL  - Statement group available
	   . $$XCIFO1   - Balance Accumulations
	   . $$IRA      - IRA Flag
	   . $$NOTES    - Customer Notes on File Flag
	   . $$SICGRP   - Standard Industry Group
	   . $$UIDCIF   - User's Own Account
	   . $$TCV      - Total Collateral Value
	   . $$PML      - Send Promotional Mail
	   . $$LIMIT    - Limit
	   . $$BALPCD   - Returns Total Balance of CD for the Primary Owner of the Account
	   . $$MCSZ     - Mailing City, State Zip
	   . $$PCSZ     - Permanent City, State Zip
	   . $$MADDR	- Mailing Address Flag
	   . $$PADDR	- Permanent Address Flag
	   . $$SCRTWRD	- Secret Word
	   . $$PZIP9	- Permanent Zip Code (9 digits)
	   . $$TCUSTBAL - Total Customer Balance
	   . $$THHBAL   - Total Household Balance		
	
	---------------- Revision History -----------------------------------
	  
	  06/12/07 - GIRIDHAL - CR 27597
	  	     Modified section DOODYTD to fix a problem where the 
	  	     DOODYTD was getting calculated from last financial
	  	     year end even if account opening date was later than
	  	     that.	  

	  04/11/07 - GIRIDHAL - CR 26443
	  	     Modified DOODYTD section to take into account negative
	  	     balances when calculating Days Out of Debt Year to Date
	  	     
	  08/19/06 - GIRIDHAL - CR 22612
	  	     Modified DOODYTD section to skip running through the
	  	     DTARRAY if no revolving accounts were found for a 
	  	     given customer. 
	  	     
	  	     Modified DOODYTD section to calculate Days Out of Debt 
	  	     from the account opening date if the account was opened
	  	     after the beginning of the current year.
	  
	  07/26/06 - KELLYP - CR 22135
	  	     Modified THHBAL, TCUSTBAL, C3, and FINDCID to be more
	  	     efficient and to conform to current PSL standards.
	  	     Also removed pre-2004 revision history.

	  05/18/06 - GIRIDHAL - CR 21207
	  	     Added new sections DOODCUR and DOODYTD for computed 
	  	     columns used to implement BASEL II
	  	     
	  02/01/06 - TELIV - CR 19314
	  	     Modified Coulmns to correct names for Table CRD
	  
	  01/23/06 - TELIV - CR 19186
	  	     Replaced Table refrences of CIFCRD with CRD. 
	  	     CIFCRD was a Index table and is no longer used.
	  
	  12/13/05 - DHANALAKSHMI R - CR 16851
	  	     Modified the section EMDATE by changing the scope of
	  	     the section and the variable IRAEM to public as the
	  	     same are used by the report SCA060.

	  10/07/05 - KumarSS - CR 16667
	  	     Modified THHBAL section to return 0 if ER is set to 1.
	  	     
	  10/04/05 - DHANALAKSHMI R - CR 16851
	  	     Modified the section EMDATE by including one more
	  	     argument ACN in the call to the section IRAEM.
	   
	  02/09/04 - RussellDS - CR 7798
	  	     Removed DELINQ.  Table LNDELA has been obsoleted
	  	     and this function was not called from anywhere.
	   
	  01/15/04 - RussellDS - CR 7514
	  	     Modified NOTES section to eliminate use of table
	  	     NOTESCIF (obsoleted) and replace with table NOTES.
	*/
	
	quit

AGE(ACN,DOB)	// Calculate age of customer as of CUVAR.TJD
	/*
	   The function is used to compute [CIF]AGE field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	   . DOB                   Date of Birth  /TYP=D/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Age As of System Date /TYP=N
	
	   EXAMPLE:
	   W $$AGE^CIFCDI(100,'12/10/65')
	*/
	
	new AGE,X,Y
	
	if '$G(DOB) set DOB=$$DOB(.ACN) if 'DOB quit ""
	
	set X=$$DAT^%ZM(DOB,"MM/DD/YEAR")
	set Y=$$DAT^%ZM(%SystemDate,"MM/DD/YEAR")
	
	set AGE=$P(Y,"/",3)-$P(X,"/",3)
	if $P(X,"/",1)_$P(X,"/",2)>($P(Y,"/",1)_$P(Y,"/",2)) set AGE=AGE-1
	quit AGE
	
CARDUF(ACN)	// Determines whether or not a card is linked to the customer
	/*
	   The function is used to compute [CIF]CARDUF field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Card Use Flag /TYP=L
	
	   EXAMPLE:
	   W $$CARDUF^CIFCDI(100)
	*/
	
	new CRDTYP,CRDNUM,CARDUF,STAT,X
	set (CRDTYP,CRDNUM,CREC)="" set CARDUF=0
	
	new rs 
	type ResultSet rs=Db.select("CRDTYP,CRDNUM","CRD","ACN=:ACN") 
	if rs.isEmpty() quit CARDUF
	while rs.next() do {  quit:CARDUF 
		set CRDTYP=rs.getCol(1) 
		set CRDNUM=rs.getCol(2)
		set STAT=Db.getOneRow("STAT","CRD","CRDTYP,CRDNUM")
		if STAT'="",STAT'=5 set CARDUF=1
		if STAT="" do {
			new rs 
			type ResultSet rs=Db.select("STAT","CRDMEM","CRDTYP=:CRDTYP AND CRDNUM=:CRDNUM") 
			if rs.isEmpty() quit
			while rs.next() do {  quit:CARDUF 
	       			set STAT=rs.getCol(1)
				if STAT'=5 set CARDUF=1
				}
			}
		}
	
	quit CARDUF
	
	
CIFCLCD(ACN)	// Last customer contact date across all accounts
	/*
	   The function is used to compute [CIF]CIFCLCD field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ CIF Customer Last Contact Date /TYP=D
	
	   EXAMPLE:
	   W $$CIFCLCD^CIFCDI(100)
	*/
	
	new CID,CIFCLCD,X
	
	set (CID,CIFCLCD)=""
	
	new rs 
	type ResultSet rs=Db.select("CID","RELCIF","ACN=:ACN") 
	while rs.next() do { 
		set CID=rs.getCol(1) 
		set X=Db.getOneRow("STAT,CCLD,ODT","ACN","CID")
		if $P(X,$C(9),1)=4 quit               // Account closed
		if $P(X,$C(9),2)>CIFCLCD set CIFCLCD=$P(X,$C(9),2) quit 
		if $P(X,$C(9),2) quit 
		if $P(X,$C(9),3)>CIFCLCD set CIFCLCD=$P(X,$C(9),3)
		}
	
	quit CIFCLCD
	
	
CMPACN(CRDTYP,CRDNUM)	// return ACN of the CRD, used from related files
	/*
	   The function is used to compute [CRDGRP]ACN,[CRDMEM]ACN,[CRDNOT]ACN
	   field
	
	   ARGUMENTS:
	   . CRDTYP                Card Type  /TYP=T/REQ/MECH=VAL
	   . CRDNUM                Card Number  /TYP=T/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Customer Number  /TYP=N
	
	   EXAMPLE:
	   W $$CMPACN^CIFCDI([CRDGRP]CRDTYP,[CRDGRP]CRDNUM)
	*/

	new x
	set x=Db.getOneRow("ACN","CRD","CRDTYP,CRDNUM")
	quit x

		
DLC(ACN)	// Date of Last Customer Contact
	/*
	   The function is used to compute [CIF]DLC field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Date Last Contact /TYP=D
	
	   EXAMPLE:
	   W $$DLC^CIFCDI(100)
	*/
	
	new CID,DLC,X
	
	set (CID,DLC)=""
	
	new rs 
	type ResultSet rs=Db.select("CID,ROLE","RELCIF","ACN=:ACN") 
 	while rs.next() do { 
		set CID=rs.getCol(1)
		set ROLE=rs.getCol(2)
		if ROLE'=1 quit                       // Not an owner rel.
		set X=Db.getOneRow("TLD","ACN","CID")
		if X>DLC set DLC=X                    // TLD
		set X=Db.getOneRow("CNFLD","DEP","CID")
		if X>DLC set DLC=X                    // CNFLD
		}
	
	quit DLC
	
	
public EMDATE(ACN,DOB)	// Eligible/Mandatory date
	/*
	   The function is used to compute [CIF]EMDATE field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	   . DOB                   Date of Birth  /TYP=D/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Elig/man Date  /TYP=D
	
	   EXAMPLE:
	   W $$EMDATE^CIFCDI(100,'12/10/87')
	*/

	type public String IRAEM
	
	if '$G(DOB) set DOB=$$DOB(.ACN) if 'DOB quit ""
	
	type String ANE,ANM,ANNE,ANNM
	set IRAEM=$$IRAEM(ACN,DOB)
	do ANN
	quit $S(IRAEM="E":ANNE,IRAEM="M":ANNM,1:"")
	
	
IRAEM(ACN,DOB)	// IRA Eligibile/Mandatory indicator
	/*
	   The function is used to compute [CIF]IRAEM field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	   . DOB                   Date of Birth  /TYP=D/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Elig/man Disb  /TYP=T
	
	   EXAMPLE:
	   W $$IRAEM^CIFCDI(100,'12/10/87')
	*/
	
	if '$G(DOB) set DOB=$$DOB(.ACN) if 'DOB quit ""
	
	new X
	
	set X=$J((+$H-DOB)/365.25,5,2)           // Age
	
	quit $S(X>70.499:"M",X>59.499:"E",1:"")
	
ANN	/*
	   CALCULATE ANNIVERSARY OF DATE OF BIRTH (DATE OF BIRTH + 1/2 YEAR)
	   Determine anniversary of date of birth by adding six months to DOB
	   If this falls on invalid date (June 31, Feb 30), set to the first
	   day of the following month.
	
	   Input:  DOB  - Date of birth (Julian)
	
	   Output:  ANE  - Eligible date (MM/DD/YY)
	    ANM  - Mandatory date (MM/DD/YY)
	    ANNE - Eligible date (Julian)
	    ANNM - Mandatory date (Julian)
	*/

	new %JD,%DS,X,MO,DAY,YR
	set X=$$DAT^%ZM(DOB,"MM/DD/YEAR")
	set MO=$P(X,"/",1) 
	set DAY=$P(X,"/",2)
	set YR=$P(X,"/",3)
	set MO=MO+6
	if MO>12 set MO=MO-12,YR=YR+1
	if MO=2,DAY>28 set MO=3,DAY=1
	
	if MO=9!(MO=4)!(MO=6)!(MO=11) if DAY=31 set MO=MO+1 set DAY=1
	set ANE=MO_"/"_DAY_"/"_(YR+59)
	set %DS=ANE
	set ANNE=$$^SCAJD(%DS)
	set ANM=$P(ANE,"/",1,2)_"/"_(YR+70)
	set %DS=ANM
	set ANNM=$$^SCAJD(%DS)
	quit 
	
XCIF01(ACN)	// TDB|TDY|TLB|TLY|BALCD|BALDDA|BALSAV|BALCOM|BALDM|BALLN|BALMTG|BALRC|BALESC|BALPCD
	/*
	   The function is used to compute [CIF]XCIF01 field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ System Use (Class, Group Balances) /TYP=T
	
	   EXAMPLE:
	   W $$XCIF01^CIFCDI(100)
	*/
	
	new BAL,CID,CLS,GRP,IRN,X,XCIF01,BALP,crcd
	set crcd=Db.getOneRow("CRCD","CIF","ACN")
	
	if (crcd=0)!(crcd="") set crcd=%SystemCurrency
		
	set CID="" set XCIF01="|||" do C1      
	for GRP="CD","DDA","SAV" set XCIF01=XCIF01_"|"_$G(BAL(GRP))
	for GRP="COM","DM","LN","MTG","RC","ESC" set XCIF01=XCIF01_"|"_$G(BAL(GRP))
	set $P(XCIF01,"|",14)=$G(BALP("CD"))
	if $P(XCIF01,"|",1) set $P(XCIF01,"|",2)=$P(XCIF01,"|",2)/$P(XCIF01,"|",1)
	if $P(XCIF01,"|",3) set $P(XCIF01,"|",4)=$P(XCIF01,"|",4)/$P(XCIF01,"|",3)
	quit XCIF01
	
C1	
	new DATA,CLS,GRP,IRN,BSE,PACN
	new rs 
	type ResultSet rs=Db.select("CID","RELCIF","ACN=:ACN") 
	while rs.next() do { 
		set CID=rs.getCol(1) 
		if 'Db.isDefined("ACN","CID") quit
		set DATA=Db.getOneRow("CLS,GRP,BAL,IRN,CRCD,ACN,TYPE","ACN","CID")
		set CLS=$P(DATA,$C(9),1)
		set GRP=$P(DATA,$C(9),2)
		set BAL=$P(DATA,$C(9),3)
		set IRN=$P(DATA,$C(9),4)
		set BSE=$P(DATA,$C(9),5)
		set PACN=$P(DATA,$C(9),6)
		set TYPE=$P(DATA,$C(9),7)
		if (CLS=""),(GRP="") quit 
                set NONPA=Db.getOneRow("NONPA","PRODCTL","TYPE")
        	if NONPA=1 quit 
		if (BSE="")!(BSE="") set BSE=%SystemCurrency
		if BSE'=crcd do CAMT^CRCDUTL(BSE,crcd,.BAL)
	
		set BAL(GRP)=$G(BAL(GRP))+BAL
		if ACN=PACN set BALP(GRP)=$G(BALP(GRP))+BAL
		if CLS="D" set $P(XCIF01,"|",1)=$P(XCIF01,"|",1)+BAL,$P(XCIF01,"|",2)=$P(XCIF01,"|",2)+(BAL*IRN)
		else  set $P(XCIF01,"|",3)=$P(XCIF01,"|",3)+BAL,$P(XCIF01,"|",4)=$P(XCIF01,"|",4)+(BAL*IRN)
		}
	
	quit 
CRCD()	// Customer currency code
	
	new CRCD
	
	set CRCD=Db.getOneRow("CRCD","CIF","ACN")
	if (CRCD="")!(CRCD=0) set CRCD=%SystemCurrency
	quit CRCD
	
CRCDDSC()	// Currency code - description

	new CRCD,CO,DESC
	set CRCD=$$CRCD
	set CO=Db.getOneRow("CO","CUVAR")
	set DESC=Db.getOneRow("DESC","CRCD","CO,CRCD")
	quit CRCD_" - "_DESC
	
	
ZDI(ACN,DINAM,TYPES,OWNER)	// Custom computed data items
	
	quit ""
	
DOB(ACN)	// Return the Date of birth
	/*
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Date of Birth  /TYP=D
	
	   EXAMPLE:
	   W $$DOB^CIFCDI(100)
	*/
	
	new DOB
	if $G(ACN)="" quit "" 
	set DOB=Db.getOneRow("DOB","CIF","ACN")
	quit DOB
	

ADDRESS(ACN,ADOPT)	// Populate the array.  Return ER.
	/*
	   The function is used to compute [CIF]ADDRESS field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	   . ADOPT
	
	   RETURNS:
	   . $$ Address Conversion /TYP=T
	
	   EXAMPLE:
	   W $$ADDRESS^CIFCDI(100)
	*/
	
	do ^UTLADDR(ADOPT,.ADDR,5,0,"CIF",ACN)
	if ER quit 0
	quit 1
	

BOO(ACN)	// Return the Branch of ownership
	/*
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Branch of Ownership /TYP=N
	
	   EXAMPLE:
	   W $$BOO^CIFCDI(100)
	*/
	
	new BOO
	if $G(ACN)="" quit ""
	set BOO=Db.getOneRow("BOO","CIF","ACN")
	quit BOO
	
	
IRA(ACN)	// Return the IRA Flag
	/*
	   The function is used to compute [CIF]IRA field
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ IRA Flag /TYP=L
	
	   EXAMPLE:
	   W $$IRA^CIFCDI(100)
	*/

	type ResultSet rs=Db.select("ACN","IRA","ACN=:ACN")
	if rs.isEmpty() quit 0
	quit 1

NOTES(ACN)	// Return the customer's note flag ;
	/*
	   The function is used to compute [CIF]NOTES field
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Customer Notes on File Flag /TYP=L
	
	   EXAMPLE:
	   W $$NOTES^CIFCDI(100)
	*/

	type ResultSet rs=Db.select("ACN","NOTES","FILE='CIF' AND CID=:ACN")
	if rs.isEmpty() quit 0
	quit 1

	
RESTAVL(ACN,GRP,REST)	// restricted statement group available.
	/*
	   The function is used to compute [CMBGRP]RESTAVL field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	   . GRP                   Statement Group /TYP=N/REQ/MECH=VAL
	   . REST                   Restricted Statement Group /TYP=L/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ restricted statement group available
	
	   EXAMPLE:
	   $$RESTAVL^CIFCDI([CMBGRP]ACN,[CMBGRP]STMGRP,[CMBGRP]REST)
	*/
	
	if GRP=1!(+REST=0) quit 1
	
	type ResultSet rs=Db.select("STMGRP","CMBSTM","ACN=:ACN and STMGRP=:GRP")
	if rs.isEmpty() quit 1
	quit 0

	
SICGRP(SIC)	// Return Standard Industry Group
	/*
	   The function is used to compute [CIF]SICGRP field
	
	   ARGUMENTS:
	   . SIC                   Standard Industry Code /TYP=T/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Standard Industry Group  /TYP=T
	
	   EXAMPLE:
	   W $$SICGRP^CIFCDI([CIF]SIC)
	*/
	
	if $G(SIC)="" quit ""
	new SICGRP
	set SICGRP=Db.getOneRow("SICGRP","UTBLSIC","SIC")
	quit $S(SIC'="?":SICGRP,1:"")
	
	
	
UIDCIF(ACN)	// Return User Own Account
	/*
	   The function is used to compute [CIF]UIDCIF field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ User's Own Account /TYP=L
	
	   EXAMPLE:
	   W $$UIDCID^CIFCDI(100)
	*/

	new XACN
	set XUID=%UserID
	set XACN=Db.getOneRow("ACN","SCAU","XUID")
	quit $S($G(%UserID)="":0,1:ACN=XACN)

TCV(ACN)	// Return Total Collateral Value
	/*
	   The function is used to compute [CIF]TCV field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Total Collateral Value /TYP=$
	
	   EXAMPLE:
	   W $$TCV^CIFCDI(100)
	*/
	
	new COLNUM,CID,COLAMT,COLCRCD,COLBAL,LNCRCD,TMP,X,SQLCNT,SQLCNT1
	set (COLNUM,CID,COLBAL)=""
	
	new rs 
	type ResultSet rs=Db.select("CID","RELCIF","ACN=:ACN") 
	while rs.next() do { 
		set CID=rs.getCol(1) 
		set X=Db.getOneRow("CLS,CRCD","ACN","CID")
		if $P(X,$C(9),1)="D" quit             //ln or dep? dep? quit!
		set LNCRCD=$P(X,$C(9),2)              //get the loan currency code
		new rs 
		type ResultSet rs=Db.select("COLL","LNCOL","CID=:CID") 
		while rs.next() do { 
	       		set COLNUM=rs.getCol(1) 
			if $D(TMP(COLNUM)) quit 
			set TMP(COLNUM)=COLNUM
			set COL=Db.getOneRow("COLVAL,CRCD","COL","COLNUM")
			set COLAMT=$P(COL,$C(9),1) quit:COLAMT="" 
			set COLCRCD=$P(COL,$C(9),2) if COLCRCD="" set COLCRCD=LNCRCD
			if %SystemCurrency'=COLCRCD do CAMT^CRCDUTL(COLCRCD,%SystemCurrency,.COLAMT)
			set COLBAL=COLAMT+COLBAL             //converted to base
			}
		}
	quit COLBAL
	
PML(ACN)	// Public; Send Promotional Mail
	/*
	   The function is used to compute [CIF]PML field
	
	   ARGUMENTS:
	   . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Send Promotional Mail /TYP=L
	
	   EXAMPLE:
	   W $$PML^CIFCDI(100)
	*/

	new MF,PML
	set MF=Db.getOneRow("MF","CIF","ACN")
	if MF="" quit 0
	set PML=Db.getOneRow("PROMO","UTBLMF","MF")
	quit PML
	
LIMIT(PLAN,AMT)	//
	/*
	   The function is used to compute [CIF]LIMIT field
	
	   ARGUMENTS:
	   . PLAN                  Limit Plan  /TYP=T/REQ/MECH=VAL
	   . CUSAMT                Customer Limit Amount /TYP=$/REQ/MECH=VAL
	
	   RETURNS:
	   
	
	   EXAMPLE:
	   W $$LIMIT^CIFCDI(100)
	*/

	if $G(PLAN)!($G(AMT)) quit 1
	quit 0


BALPCD(ACN)	//  Returns Total Balance of CD for the Primary Owner of the Account
	/*
	
	   ARGUMENTS:
	   . ACN     Customer Number /TYP=N/REQ/MECH=VAL
	
	
	   RETURNS:
	   . $$  Returns Total Balance of CD for the Primary Owner
	   of the Account.
	*/
	
	quit $P($$XCIF01(ACN),"|",14)

MCSZ(XACN)      //  Returns Mailing City, State Zip value
        /*
	   The function is used to concatenate the [CIF]MSCZ field.
        
           ARGUMENTS:
           . XACN                  Customer Number        /TYP=N/REQ/MECH=VAL
        
           RETURNS:
           . $$ Mailing City, State Zip  /TYP=T
        
           EXAMPLE:
           W $$MCSZ^CIFCDI(100)
        */

        new CITY,STATE,X,ZIP
        
        set X=Db.getOneRow("MCITY,MSTATE,MZIP","CIF","XACN")
        set CITY=$E($P(X,$C(9),1),1,25)
        set STATE=$P(X,$C(9),2)
        set ZIP=$P(X,$C(9),3)
        quit CITY_", "_STATE_" "_ZIP
        
PCSZ(XACN)      //  Returns Permanent City, State Zip value
	/*        
	   The function is used to concatenate the [CIF]PSCZ field.
        
           ARGUMENTS:
           . XACN                  Customer Number        /TYP=N/REQ/MECH=VAL
        
           RETURNS:
           . $$ Permanent City, State Zip  /TYP=T
        
           EXAMPLE:
           W $$PCSZ^CIFCDI(100)
        */

        new CITY,STATE,X,ZIP
        
        set X=Db.getOneRow("PCITY,PSTATE,PZIP","CIF","XACN")
        set CITY=$E($P(X,$C(9),1),1,25)
        set STATE=$P(X,$C(9),2)
        set ZIP=$P(X,$C(9),3)
        quit CITY_", "_STATE_" "_ZIP
        
MADDR(XACN)     //Mailing Address Flag
        /*
        This function is used to copute [CIF]MADDR
 
        ARGUMENTS:
         . ACN     Customer Number     /TYP=N/REQ/MECH=VAL
 
        RETURNS:
         . $$    Returns       1 - Mailing Address Journal is defined
                               0 - Mailing Address Journal not defined
        */
 
        new XKEY,XTJD
        set XTJD=%SystemDate
        set XKEY=5
        if Db.isDefined("DTJADDRCHG","XTJD,XACN,XKEY") quit 1
        quit 0

PADDR(XACN)     //Permanent Address Flag
        /*
        This function is used to compute [CIF]PADDR
 
        ARGUMENTS:
         . ACN     Customer Number     /TYP=N/REQ/MECH=VAL
 
        RETURNS:
         . $$    Returns       1 - Permanent Address Journal is defined
                               0 - Permanent Address Journal not defined
        */
 
        new XKEY,XTJD
        set XTJD=%SystemDate
        set XKEY=6
        if Db.isDefined("DTJADDRCHG","XTJD,XACN,XKEY") quit 1
        quit 0
 
SCRTWRD(XACN)	// Secret Word
	/*
	ARGUMENTS:
         . ACN         Customer Number /TYP=N/REQ/MECH=VAL
        
        RETURNS:
         . $$          Returns Secret Word from CIFAUTH
	*/

        new SCRT
        set SCRT=Db.getOneRow("SCRTWRD","CIFAUTH","XACN")
        quit SCRT

PZIP9(XACN)
	/*
	 ARGUMENTS:
	 . ACN         Customer Number /TYP=N/REQ/MECH=VAL
 
	 RETURNS:
	 . $$          Returns nnnnn-nnnn formatted zip code
        */

	new PZIP,PZIP9
	set PZIP=Db.getOneRow("PZIP","CIF","XACN")

	set PZIP9=$S(PZIP?5N:PZIP_"-0000",1:PZIP)
	quit PZIP9

public TCUSTBAL(Number ACN,String XCLS,Boolean XINDIR,String HHTYP,String RTSTRN())   //Total Customer Balance

	   /*
           The function is used to compute [CIF]TCUSTBAL field
	   and to build strings for datawindows. 

           ARGUMENTS:

           . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
 
	   . XCLS		   Product Class /TYP=T/NOREQ/MECH=VAL

	   . XINDIR		   Indirect Indicator /TYP=N/NOREQ/MECH=VAL 	
				   1 = Indirect Records
				  
	   . HHTYP 	           Household type /TYP=T/NOREQ/	

	   . RTSTRN 		   Return string
		
	
           RETURNS:
           Total Customer Balance
 
           EXAMPLE:
           W $$TCUSTBAL^CIFCDI(100)
        */
	
	type public Cache %CACHE()
	
	type Number BAL,CID,TCUSTBAL
	type String BSE,CRCD
	
	// Initialize variables
	set TCUSTBAL=0
	set RTSTRN("D")=""
	set RTSTRN("L")=""
	set XINDIR=XINDIR.get()
	
	if ACN.isNull() quit 0

	type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN",1)
	if 'cif.getMode() quit 0

	// Get the customer
        set CRCD=cif.crcd
        if CRCD.isNull() set CRCD=%SystemCurrency
 
	// Loop through all accounts for this customer
	type DbSet ds=Db.selectDbSet("RELCIF","ACN=:ACN")
        while ds.next() do {
        	
        	type RecordRELCIF relcif=ds.getRecord("RELCIF")
        	
                set CID=relcif.cid
                
                type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
                if 'acn.getMode() quit
                
                set BSE=acn.crcd
                set BAL=acn.bal
                
		// Convert currency
                if BSE.isNull() set BSE=%SystemCurrency
                if BSE'=CRCD do CAMT^CRCDUTL(BSE,CRCD,.BAL)
             
		// If Class is specified, only select that class
                if XCLS.get()="D",acn.cls'="D" quit
                else  if XCLS.get()="L",acn.cls'="L" quit

		// Determine liability: direct or indirect ownership
		type RecordRELCODE relcode=%CACHE("RELCODE").getRecord("RELCODE","REL=:acn.acnrelc,ROLE=:relcif.role")
		if 'relcode.dl,'XINDIR quit
		if relcode.dl,XINDIR quit

		// Non Profile Account
		type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:acn.type")

                set BAL=$$C3(CID,acn.cls,BAL,prodctl.nonpa)
                
		/*
		If household type is given, then build a return string
		with a breakdown of data.  This string will be
		used to populate a householding datawindow.
		Data includes the description of the product group,
		the account number, the primary owner, the relationsthip to
		the head of household (if any), the balance, the class, and a
		direct/indirect indicator for each account
		Seperate Deposit and Loan strings are built for proper output.
		*/
		if 'HHTYP.get().isNull() do {
			
			type Number TMPCID
			type String RELDES = ""
			
			// Primary owner of this account
			type RecordCIF cifprim=Db.getRecord("CIF","ACN=:acn.acn")
			
			type RecordCIFHH cifhh=Db.getRecord("CIFHH","ACN=:acn.acn,HHTYP=:HHTYP,HEADACN=:ACN",1)
			if cifhh.getMode(),('cifhh.relate.isNull()) do {
				type RecordUTBLHRC utblhrc=Db.getRecord("UTBLHRC","HRCODE=:cifhh.relate",1)
				set RELDES=utblhrc.hrcdesc
				}

			type RecordSTBLGRP stblgrp=Db.getRecord("STBLGRP","CLS=:acn.cls,GRP=:acn.grp")
                         
                        /*
			 If this is a non-profile account, use the converted 
			 account number. If none exists, use regular account number.
			*/
			if prodctl.nonpa,acn.convacn.length() set TMPCID=acn.convacn
			else  set TMPCID=CID

			if acn.cls="D" set RTSTRN("D")=RTSTRN("D")_stblgrp.des_$C(9)_TMPCID_$C(9)_cifprim.nam_$C(9)_RELDES_$C(9)_BAL_$C(9)_acn.cls_$C(9)_(XINDIR+1)_$C(13,10)
		     	if acn.cls="L" set RTSTRN("L")=RTSTRN("L")_stblgrp.des_$C(9)_TMPCID_$C(9)_cifprim.nam_$C(9)_RELDES_$C(9)_BAL_$C(9)_acn.cls_$C(9)_(XINDIR+1)_$C(13,10)
			}

		// Accumulate balance
                set TCUSTBAL=TCUSTBAL+BAL
		}

        quit TCUSTBAL

C3(Number CID,String CLS,Number BAL,Boolean NONPA)
        
        type public Boolean ER
        type public String RM
        
        type Number RETVAL = 0
        
 	// Return balance based on household balance type
	if CUVAR.HBTYPE = 1 quit BAL

        if CLS="D" do {
                type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
                if NONPA set RETVAL=dep.npiaab
                else  if CUVAR.HBTYPE=2 set RETVAL=dep.adbm1
                else  if CUVAR.HBTYPE=3 set RETVAL=dep.adbm2
                else  if CUVAR.HBTYPE=4 set RETVAL=dep.ambcur

		/* Reset ER,RM here in case an error occurs while fetching
		computed column (ex: closed account) so that the code continues
	        to loop through the remaining accounts for this customer
		mee 48424 */
		if ER.get() set ER=0,RM=""			
        	}
        else  do {
                type RecordLN ln=Db.getRecord("LN","CID=:CID")
                if NONPA set RETVAL=ln.npiaab
                else  if CUVAR.HBTYPE=2 set RETVAL=ln.adbm1
                else  if CUVAR.HBTYPE=3 set RETVAL=ln.adbm2
                else  if CUVAR.HBTYPE=4 set RETVAL=ln.ambcur
 
                /* Reset ER,RM here in case an error occurs while fetching
                computed column (ex: closed account) so that the code continues
                to loop through the remaining accounts for this customer
                mee 48424 */
                if ER.get() set ER=0,RM=""
        	}

        quit RETVAL


public THHBAL(Number ACN,String XCLS,String XHHTYP,String RTSTRN())     // Total Household Balance
         /*
           The function is used to compute [CIF]THHBAL field
 	   and to build strings to import into datawindows.
	
           ARGUMENTS:

           . ACN                   Customer Number /TYP=N/REQ/MECH=VAL
	
	   . XCLS                  Product Class /TYP=T/NOREQ/MECH=VAL
	
	   . XHHTYP 		   Household Type /TYP=T/NOREQ/MECH=VAL 

  	   . RTSTRN		   Return String /TYP=T/NOREQ

           RETURNS:
           Total Household Balance
 
           EXAMPLE:
           W $$THHBAL^CIFCDI(100)
        */

	type public Boolean ER

	type Number BAL,BAL1,FNDCID(),HEADACN,HHTYP,THHBAL

	if ACN.isNull() quit 0
        
	// Initialize variables
	set BAL1=0
	set RTSTRN("D")=""
	set RTSTRN("L")=""
	set XHHTYP=XHHTYP.get()
	set XCLS=XCLS.get()
			
	// Store the head of household parameter     
	set HEADACN=ACN

	type DbSet ds=Db.selectDbSet("CIFHH0","ACN=:ACN","ACN,HHTYP,MACN")
	while ds.next() do {
		type RecordCIFHH0 cifhh0=ds.getRecord("CIFHH0")

		// If we are looking for a specific household type,
		// make sure this one is it.
		set HHTYP=cifhh0.hhtyp
		if ('XHHTYP.isNull()),(HHTYP'=XHHTYP) quit

		// For each member in this household, get balance of all
		// accounts for this customer
		set BAL=$$FINDCID(cifhh0.macn) quit:ER.get()
		set BAL1=BAL+BAL1
		}
	
        set BAL=0

	/* 
	 If we didn't specify a household type, include the accounts 
	 under the head of household. Specifying the household type 
	 means we are getting information for MRPC117 for 'related' 
	 accounts only, which do not include those owned by the head 
	 of household.
	*/
	if XHHTYP.isNull() set BAL=$$FINDCID(ACN) if ER quit 0
        
        set THHBAL=BAL1+BAL
	if 'BAL1 set THHBAL=0
	
        quit THHBAL


FINDCID(Number ACN)

	type public Cache %CACHE()
	type public Number FNDCID(),HEADACN
	type public String HHTYP,RTSTRN(),XCLS,XHHTYP

	type Number BAL,CID,SAVEBAL,XBAL
	type String BSE,CRCD
        
        type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN")
        
        set CRCD=cif.crcd
        if CRCD.isNull() set CRCD=%SystemCurrency

        set SAVEBAL=0
        set BAL=0

        type DbSet ds=Db.selectDbSet("RELCIF","ACN=:ACN")
        while ds.next() do {
		
		type RecordRELCIF relcif=ds.getRecord("RELCIF")
		
		set CID=relcif.cid

		if FNDCID(CID).exists() quit
		
		type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
		if 'acn.getMode() quit
		
		set FNDCID(CID)=1
		set XBAL=acn.bal
                set BSE=acn.crcd
                if BSE.isNull() set BSE=%SystemCurrency
	
		// Check for non-profile account
		type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:acn.type")

		// Verify account class against parameter from THHBAL
                if (XCLS="D"),(acn.cls'="D") quit
                if (XCLS="L"),(acn.cls'="L") quit  

		if BSE'=CRCD do CAMT^CRCDUTL(BSE,CRCD,.XBAL)
		set BAL=$$C3(CID,acn.cls,XBAL,prodctl.nonpa)

		/* 
		If household type is given, then build return strings
                with a breakdown of data.
                Data should include the description of the product group,
                the account number, the primary owner, the relationship to
		the head of household,  the balance, the class, and a 
                direct/indirect indicator for each account.
		Deposit and loan return strings are used for proper output.
		*/
		if 'XHHTYP.isNull() do {

			type Number TMPCID
			type String RELDES = ""

			// Do not include any accounts that are owned by 
			// the head of household.
			if Db.isDefined("RELCIF","ACN=:HEADACN,CID=:CID") set BAL=0 quit

			// CIF record of primary owner of account
			type RecordCIF cifprim=Db.getRecord("CIF","ACN=:acn.acn")

			type RecordCIFHH cifhh=Db.getRecord("CIFHH","ACN=:acn.acn,HHTYP=:HHTYP,HEADACN=:HEADACN",1)
			if cifhh.getMode(),('cifhh.relate.isNull()) do {
				type RecordUTBLHRC utblhrc=Db.getRecord("UTBLHRC","HRCODE=:cifhh.relate",1)
				set RELDES=utblhrc.hrcdesc
        			}

			type RecordSTBLGRP stblgrp=%CACHE("STBLGRP").getRecord("STBLGRP","CLS=:acn.cls,GRP=:acn.grp")

			/*	
			 If this is a non-profile account, use the converted
			 account number. If non exists, use regular account number.
			*/
			if prodctl.nonpa,acn.convacn.length() set TMPCID=acn.convacn
			else  set TMPCID=CID
	
			if acn.cls="D" set RTSTRN("D")=RTSTRN("D")_stblgrp.des_$C(9)_TMPCID_$C(9)_cifprim.nam_$C(9)_RELDES_$C(9)_BAL_$C(9)_acn.cls_$C(9)_3_$C(13,10)
			if acn.cls="L" set RTSTRN("L")=RTSTRN("L")_stblgrp.des_$C(9)_TMPCID_$C(9)_cifprim.nam_$C(9)_RELDES_$C(9)_BAL_$C(9)_acn.cls_$C(9)_3_$C(13,10)
			}

                set SAVEBAL=SAVEBAL+BAL
                }

        quit SAVEBAL

       
public DOODCUR(Number ACN)
	/*
	   The function is used to compute current days out of debt.
	   The current number of days that have elapsed since the last 
	   time the customer's balance to pay off all open/active 
	   revolving loans was less than or equal to zero.
	*/
	type Boolean STOP, STOP1
	type Date TMPDT 
	type Number NUMDAYS = ""
	type Number CID
	type ResultSet relcifrs = Db.select("CID","RELCIF","ACN=:ACN")
	set STOP1 = 0
	if relcifrs.isEmpty() quit ""
	while relcifrs.next() do { quit:STOP1
		set STOP = 0
		set TMPDT = %SystemDate
		set CID = relcifrs.getCol("CID")
		
		type RecordACN acn = Db.getRecord("ACN","CID=:CID")
                if acn.cls '= "L" quit		
		
		type RecordLN ln = Db.getRecord("LN","CID=:CID")
		if 'ln.revf quit
		if ln.stat = 4 quit
		type ResultSet histrs = Db.select("ENDBAL,TJD","HIST","CID = :CID AND TJD < :TMPDT AND ETC IS NOT NULL","TSEQ DESC")
		if histrs.isEmpty() do {
			if ln.hisctf > ln.odt set TMPDT = ln.hisctf 
			else  set TMPDT = ln.odt
			}
		while histrs.next() do { quit:STOP
			if TMPDT = histrs.getCol("TJD") quit
			if histrs.getCol("ENDBAL") '> 0 set TMPDT = histrs.getCol("TJD")
			else  set STOP = 1
			}
		if TMPDT > NUMDAYS set NUMDAYS = TMPDT
		if (NUMDAYS = %SystemDate) set STOP1 = 1
		}
	quit:STOP1 0
	if 'NUMDAYS.isNull() set NUMDAYS = %SystemDate - NUMDAYS
	
	quit NUMDAYS
	
public DOODYTD(Number ACN)
	/*Total Days Out of Debt Year-to-Date 
	The aggregate number of days that the customer's balance to pay off 
	all open/active revolving loans was less than or equal to zero 
	during the current financial year.  This value will be used to 
	define the Total Days Out of Debt Last Year (CIF.DOODPROR) during 
	the financial year-end reset.  
	*/
	type Boolean foundrevf
	type Date END
	type Date DTARRAY()
	type Date OPENDT = ""
	type Date STARTDT = ""
	type Number CID
	type Number i
	type Number LASTBAL = ""
	type Number NUMYTD = ""
	type Number ZEROCNT = ""

	if (CUVAR.finyel + 1) = %SystemDate quit ""	
	type RecordCIFBAL0 cifbrec = Db.getRecord("CIFBAL0","ACN=:ACN",1)
	if cifbrec.accumto = (%SystemDate - 1) quit cifbrec.ytdcnt
	if cifbrec.accumto set STARTDT = (cifbrec.accumto + 1) 
	else  set STARTDT = (CUVAR.finyel + 1)
	type ResultSet relcifrs = Db.select("CID","RELCIF","ACN=:ACN")
	set foundrevf = 0

	for i = STARTDT:1:(%SystemDate-1) set DTARRAY(i)= ""

	while relcifrs.next() do {
		type Number BAL()
		set CID = relcifrs.getCol("CID")		

		type RecordACN acn = Db.getRecord("ACN","CID=:CID")
                if acn.cls '= "L" quit		
		
		type RecordLN ln = Db.getRecord("LN","CID=:CID")
		if 'ln.revf quit

		set foundrevf = 1
		set OPENDT = STARTDT

		if ln.odt > OPENDT set OPENDT = ln.odt
		do INIT^UAVB(.ln,ln.cid,OPENDT,%SystemDate - 1,"10000100000000100001",,.BAL)
		if ln.dtc do {
			set END = BAL("").order(-1)			
			for i = (ln.dtc + 1):1:END do {
				if BAL(i) = 0 set BAL(i) = ""
				}
			}
		set i=OPENDT-1
		for  set i=DTARRAY(i).order() quit:i.isNull()  do {
			if DTARRAY(i) > 0 quit
			set LASTBAL = BAL(i+1).order(-1)
			set LASTBAL = BAL(LASTBAL)
			if LASTBAL > 0 set DTARRAY(i) = LASTBAL
			else  if DTARRAY(i).isNull() set DTARRAY(i) = LASTBAL
			}
		}
	if foundrevf do {
		set i=OPENDT-1	
		for  set i = DTARRAY(i).order() quit:i.isNull()  do {
			if DTARRAY(i) '> 0 set ZEROCNT = ZEROCNT + 1
			}
		}
	if (cifbrec.accumto + 1) = STARTDT set NUMYTD = ZEROCNT + cifbrec.ytdcnt 
	else  set NUMYTD = ZEROCNT
	
	set cifbrec.accumto = (%SystemDate - 1)
	set cifbrec.ytdcnt = NUMYTD
	do cifbrec.save()
	quit NUMYTD
 #OPTION ResultClass ON
Public String vSIG()	quit "60863^35115^Lakshmi Giridharan^31819"	// Signature - LTD^TIME^USER^SIZE
