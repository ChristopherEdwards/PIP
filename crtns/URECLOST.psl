URECLOST(dir,jourfile,oldvrsn)	//
	/*
	ORIG: chhabris - 08/09/2005
	DESC: Non-replicated Transactions

	---- Comments --------------------------------------------------------
	 desc:	non-replicated transactions

	 keywords: 
	 		non-replicated
	 		batch transaction	
	 		character interface updates
			on-line finacial transaction

	 description:

	 transactions will not have been replicated on failover if:

	 . they are in the replication queue and do not make it to the
 	   secondary system prior to the secondary assuming primary status

	 in either case , the transaction have been committed to the 
	 primary database. if the updates were based on an on-line 
	 transaction , a response may or may not have been sent to 
	 the client prior to failure of the primary system. these 
	 transaction are refereed to as non-replicated transactions 
	 throughout the remainder of this specification.

	 the routine will be used to handle non-replicated transactions

	 input:
		dir		journal file directory		/req/string
		jourfile	journal file 			/req/string
		oldvrsn		journal file version		/req/string

	 example:
		d ^URECLOST("/v60rec","v61.mjl","6.0")

	---- Revision History ------------------------------------------------
	03/08/06 - RussellDS - CR19962
		   Remove references to obsoleted routine CGMSSRV - and use of
		   ELF format.  This was all Citibank specific.
		     
		   Eliminated a number of PSL warning situations.
		     
	01/04/06 - chhabris - CR18749
		   Code clean up.

	08/19/05 - Chhabris - CR16677
		   Converted to PSL. 

	05/24/05 - RussellDS - CR16071
		   Added "BA" transaction ID to tstart.	   
		   Removed old revision history
	----------------------------------------------------------------------

	*/

	type public String ET,io2,pid
	type public Number ER,norepd,verdiff
	type public Date timeseq

	if (dir.get().isNull()) ! (jourfile.get().isNull()) ! (oldvrsn.get().isNull()) quit

	// Define system variables
	do SYSVAR^SCADRV0()
	set timeseq=%SystemDate

	// Ensure only one process active
	lock +norepd:5
	else  set ER=1,ET="RECLOC" do ^UTLERR quit

	set pid=""

	// Journal file has been processed
	type RecordURECD urecd=Db.getRecord("URECD","TIMESEQ=:timeseq,JRNLFILE=:jourfile",1)
	if urecd.getMode() set pid=urecd.pid

	if pid="complete" Lock -norepd quit

	if 'pid.isNull() , $$VALID^%ZPID(pid) Lock -norepd quit

	set urecd.pid=%ProcessID
	do urecd.bypassSave()

	Lock -norepd

	catch vERROR {
		type String ET,RM
		set ET=vERROR.type
		if ET["%GTM-" do {
			do ZE^UTLERR
			}
		else  do {
			set ET=ET_"-"_vERROR.thrownAt
			set RM=vERROR.description
			do ^UTLERR
			}
		}

	// create array for no-replication global
	// global that no need to use $ZQGBLMOD to check,
	do notable

	/* verdiff=0 => new to old
		=1 => old to new
		=2 => same version	
	*/

	if oldvrsn=%VersionID set verdiff=2
	else  if oldvrsn>%VersionID set verdiff=0
	else  if oldvrsn<%VersionID set verdiff=1 

	// create TMPRPT3 and TMPRPT4 for global to file definition index
	// Having a check for TMPRPT3 as tmpgbl^URECREP builds TMPRPT3 and TMPRPT4.
	type ResultSet rs=Db.select("DATA","TMPRPT3","PID=:%ProcessID")
	if rs.isEmpty() do tmpgbl^URECREP

	if $ZVERSION["VMS" set io2=dir_":"_jourfile		// VMS
	else  set io2=dir_"/"_jourfile			// UNIX


	// auto recovery, create ^norepd global
	do recovery(.urecd)
	quit


	//-------------------------------------------------------------------
recovery(RecordURECD urecd)	// recover non-replication transaction
	//-------------------------------------------------------------------

	type public String global,io2,jourfile,pointer,tpid,transid,type
	type public Number ER,ok
	type public Date timeseq
	type Public IO io
	type Number ET,seqr
	type String RM,x

	set seqr=1
	set io=Class.new("IO")
	set io.fileName=io2
	set io.openParams="READ/APPEND"
	do io.open()

	catch ERROR {
		set ET=ERROR.type
		set RM=$$^MSG(1334,io2)
		}
	if ER quit

	// check if the non-replicated journal file has been re-post
	if 'urecd.transid.isNull() do toptr(.urecd)

	// clear old report
	do Db.fastDelete("URECL1","DATE1=:timeseq,FILE=jourfile")

	// read transaction from gtm journal file
	for  set x=io.read(ET) quit:+ET=1  do {

		if 'pointer.get().isNull() , x.piece("\",1,4)=pointer quit
	 	set type=x.piece("\",1)
	 	set tpid=x.piece("\",5)
		set transid=x.piece("\",1,4)

		if type'="04" , type'="05" , type'="08" , type'="09" quit
		set global=x.piece("^",2,99)
		if global["(" set global=global.piece("(",1)
		if $$noapp(global) quit

		do Runtime.start("BA", "*")
		do update
		do Runtime.commit()
		}

	set urecd.pid="complete"
	do urecd.bypassSave()

	do io.close()
	quit


	//---------------------------------------------------------------------
update	// Apply updates
	//---------------------------------------------------------------------
	type public String tpid,type,x

	catch vERROR {
		type String ET,RM
		set ET=vERROR.type              
		if ET["%GTM-" do {              
			do ZE^UTLERR
			}
		else  do {
			set ET=ET_"-"_vERROR.thrownAt
			set RM=vERROR.description
			do ^UTLERR
			}
		}

	// type 08 is a start of transaction (tstart)
 	// on-line transaction
	if type="08",tpid="CS" do typecs quit

	// batch transaction
	if type="08",tpid="BA" do typebc quit

	// host transaction with tp
	if type="08" do type8 quit

	// type 04 is a kill
	// type 05 is a set
	if type'="04",type'="05" quit
	if type="05" set x=$$UNZWR(x)

	// character update
	do charup
	quit


	//-------------------------------------------------------------------
toptr(RecordURECD urecd) /* to last point of re-reprocess 
	------------------------------------------------------------------ 
	 If new primary system was crashed during the recovery process,
	 re-process non-replication will start from last crashed point . 
	--------------------------------------------------------------------
	*/
	type public String jourfile,type
	type public Date timeseq
	type public Number pointer
	type Number ET
	type String x
	type public IO io
	
	set ET=0
	set pointer=urecd.transid
	for  set x=io.read(ET) quit:+ET=1  set type=x.piece("\",1,4) quit:type=pointer

	quit


	//------------------------------------------------------------------
charup	// recovery for character interface updates without tp
	//------------------------------------------------------------------

	type String fid,glo,global,in,notable(),p3,rvalue,statem,value
	type Number ifupdate
	type public String auapp(),x

	set ifupdate=0
	set value=x.piece("\",6,9999)
	do SPLIT(value,.glo,.rvalue)

	if glo'["(" set global=glo.extract(2,999)
	else  set global=glo.extract(2,99).piece("(",1)

	// no-reapplicated global
	if $$noapp(global) quit

	// global not need use $zdatamod to check
	if auapp(global).exists() do uplostc quit

	// use gtm function to check potential transaction conflict, ifupdate=1
	// conflict ifupdate=0 no-conflict

	#ACCEPT CR=16677;DATE=09/12/05;PGM=Sanjay Chhabria
	#BYPASS

	s ifupdate=$ZQGBLMOD(@glo)   
	;
	; chech if the file has relationship with ACN,DEP or CIF
	i ifupdate=0,(glo["(") d
	.	s p3=$p(glo,"(",2,999)
	.	s p3=$e(p3,1,$l(p3)-1)
	.	; get file definition
	.	d getfid^URECREP(global,p3,,"")
	.	i fid="" d getfid^URECREP(global,p3,1,"")
	.	i fid="" q
	.	; tabel have relationship with ACN,DEP,CIF
	.	i $d(notable(fid))>0 s ifupdate=1 q

	#ENDBYPASS

	do uplostc
	quit


uplostc	//
	type public Number ifupdate,subseq,seqr,transid,verdiff
	type public String in(),jourfile,value,v1,v2,statem,type,x
	type public Date timeseq
	type String lseq

	// two system versions are same
	if verdiff=2 do {
		if type="05" do {
			do SPLIT(value,.v1,.v2)
			set statem="s "_v1_"="_""""_v2_""""
			}
		else  if type="04" set statem="k "_x.piece("\",6)

		// back to disk
		if ifupdate=0 do set(statem) quit

		// non-replicated for report
		set subseq=1
		do setsub(statem)
		set seqr=seqr+1
		}

	// system versions are different
	// 1-- old to new, 0 -- new to old
	else  do {
		set in(0)=x
		if ifupdate=0 do { quit

			// call filter for scheme change
			do LOST^URECFIL(.in,verdiff)

			set lseq=""
			for  set lseq=in(lseq).order() quit:lseq.isNull()  do {
				if in(lseq).piece("\",1)="04" set statem="k "_in(lseq).piece("\",6)
				else  if in(lseq).piece("\",1)="05" do {
					set value=in(lseq).piece("\",6)
					do SPLIT(value,.v1,.v2)
					set statem="s "_v1_"="_""""_v2_""""
					}
				do set(statem)
				}
			}
		else  do {

			// call filter for scheme change
			do LOST^URECFIL(.in,verdiff)

			set lseq=""
			for  set lseq=in(lseq).order() quit:lseq.isNull()  do {
				
				if in(lseq).piece("\",1)="04" set statem="k "_in(lseq).piece("\",6)
				else  if in(lseq).piece("\",1)="05" do {
					set value=in(lseq).piece("\",6)
					do SPLIT(value,.v1,.v2)
					set statem="s "_v1_"="_""""_v2_"""" 
					}
				
				set subseq=1
				do setsub(statem)
				set seqr=seqr+1
				}
			}
		}

	// pointer to re-process trans id
	type RecordURECD urecd=Db.getRecord("URECD","TIMESEQ=:timeseq,JRNLFILE=:jourfile",1)
	set urecd.transid=transid
	do urecd.bypassSave()

	quit


	//-------------------------------------------------------------------
typebc	// skip over batch transaction
	//---------------------------------------------------------------------
	type public IO io
	type String type,x
	type Number ET
	set ET=0

	for  set x=io.read(ET) quit:+ET=1  set type=x.piece("\",1) quit:type="09"
	quit


	//-------------------------------------------------------------------
typecs	// cs transaction , PBSSRV
	//---------------------------------------------------------------------

	type public Number glo,subs()
	type public String header,rvalue,request(),cs(),server,sclass,x
	type public IO io
	type String global,stype,value,posi,head,status,reply,type
	type Number seq,ET
	set ET=0

	set header="",seq=0,server="",sclass=""

	for  set x=io.read(ET) quit:+ET=1  do { quit:type="09"

		set type=x.piece("\",1)
		if (type'="04") , (type'="05") , (type'="09") quit
		if type="05" set x=$$UNZWR(x)
		if type="09" do ssrv quit
		set value=x.piece("\",6,9999) , subs=""
		do SPLIT(value,.global,.rvalue,.subs)

		if global["(" set glo=global.piece("(",1).extract(2,9)
		else  set glo=global.extract(2,999)

		if glo="MSGLOG" , subs>1 do { quit
			if subs=2 set header=rvalue quit
			else  if subs(3).get()=1 set request(subs(4))=rvalue quit
			else  if subs(3).get()=2 set reply(subs(4))=rvalue quit
			}
		else  if $$noapp(global) quit

		if (type="04")!(type="05") do {
			if type="04" set cs(seq)="k "_value,seq=seq+1
			else  if type="05" do {
				set cs(seq)="s "_global_"="_""""_rvalue_""""
				set seq=seq+1
				}
			}
		}
	quit


	//--------------------------------------------------------------------
ssrv	// online transaction recovery
	//--------------------------------------------------------------------

	type Number ifupdate,seq,vzptr,zseq
	type String global,header,ttt,type,vvv,vzermsg,vzpkt,vzsevcls,xgl,xmrpc
	type String change,fid,notable(),p3,skip,x
	type public String cs(),glo,message,request(),scalss,server,status,subs,vzermsg,vzx
	type public String header,jourfile,oldtok,sclass,tkn,transid,v1,v2,vzsrvcls
	type public Number find
	type public Date timeseq

	set status=header.piece("|",3),sclass=header.piece("|",4),server=header.piece("|",5)	

	// if original post is failed or the server calss is FSSP , skip over
	if (status.get()=1) ! (sclass=2) quit

	set ifupdate=0,skip=0

	if request.data() do {
		set vzpkt=""

		set zseq=""
		for  set zseq=request(zseq).order() quit:zseq.isNull()  set vzpkt=vzpkt_request(zseq)
		set request=vzpkt

		set vzptr=$$LV2V^MSG(vzpkt,.vvv)		
		set vzermsg=$$HDR^PBSSRV(vvv(1).get()),sclass=vzsrvcls.get()

		// msql
		if sclass=5,(vzpkt'?.e1"UPDATE".e),(vzpkt'?.e1"INSERT".e),(vzpkt'?.e1"DELETE".e),(vzpkt'?.e1"COMMIT".e),(vzpkt'?.e1"update".e),(vzpkt'?.e1"insert".e),(vzpkt'?.e1"delete".e),(vzpkt'?.e1"commit".e) set skip=1

		// if server class is MRPC, treat it as character based update
		if sclass=3 do {
			type String v1

			// skip over mrpc67,mrpc20,mrpc3 which only do query
			if ((vvv(1).get()=67) ! (vvv(1).get()=20) ! (vvv(1).get()=3)) set skip=1 quit
			set seq=""
			for  set seq=cs(seq).order() quit:seq.isNull()!(ifupdate=1)  do {
				do SPLIT(cs(seq),.v1)
				if cs(seq)["(" set glo=cs(seq).piece("(",1).extract(4,999)
				else  set glo=v1.extract(4,999)
				if glo="MSGLOG" quit
				set change=1

				#ACCEPT CR=16677;DATE=09/12/05;PGM=Sanjay Chhabria
				#BYPASS
				if $ZQGBLMOD(@glo) set ifupdate=1 quit
				if glo'["(" quit
				#ENDBYPASS

				// check if it is DEP,CIF,LN file relative
				set p3=v1.piece("(",2,999)
				set p3=p3.extract(1,(p3.length()-1))
				do getfid^URECREP(glo,p3,,"")

				if notable(fid).exists() set ifupdate=1
				if change.get().isNull() set skip=1
			}
		}
	}

	set seq=""
	for  set seq=cs(seq).order() quit:seq.isNull()  do SPLIT(cs(seq),.v1)

	if (request.data()=0) ! (skip=1) quit
	set vzpkt=request

	// Set token and/or STF flag
	if sclass=3 , ifupdate=1 do cgif 
	else  if server["PBSSRV" do PBSSRV(request)  

	// pointer to re-process trans id
	type RecordURECD urecd=Db.getRecord("URECD","TIMESEQ=:timeseq,JRNLFILE=:jourfile",1)
	set urecd.transid=transid
	do urecd.bypassSave()
	quit


	//-------------------------------------------------------------------
PBSSRV(vzpkt)	// call to PBSSRV server	
	//------------------------------------------------------------------
	type public String oldrep,vzclid,vzlogmsg,vzsav,vzsrvcls,xreply(),xrequest,xseq
	type public Number ifupdate,sclass,seqr,transid,vzptr
	type public String header,jourfile,message,reply(),request,tkn,vzreply
	type public Date timeseq
	type String oreply,vzlogrep
	type Number i,subseq

	// don't re-post MRPC if there is conflict on the new primary sys.
	if sclass=3,ifupdate=1 quit

	set vzlogmsg=1,vzlogrep=1,vzclid=""
	do {
		type Number seqr,transid
		type String header,jourfile,message,request,reply,tkn
		type Date timeseq

		set vzreply=$$PROC^PBSSRV(vzpkt,"","",.vzsav,"")
		}

	// parse pbssrv to pre P/A format
	// parse p/a client request message
	set vzptr=$$LV2V^MSG(vzpkt,.xrequest)

	// parse new p/a reply message
	if vzreply.exists() set vzptr=$$LV2V^MSG(vzreply,.xreply)

	// parse original p/a reply
	set oreply="",xseq=""
	for  set xseq=reply(xseq).order() quit:xseq.isNull()  set oreply=oreply_reply(xseq)
	set vzptr=$$LV2V^MSG(oreply,.oldrep)

	// record the messages to file URECD for report
	set subseq=1
	do setsub("08CS"_"|"_vzsrvcls.get()_"||"_transid)
	for i=2:1:xrequest("").order(-1) do break("request",xrequest(i))

	for i=2:1:oldrep("").order(-1) do break("oldreply",oldrep(i))

	if xreply.data() for i=2:1:xreply("").order(-1) do break("newreply",xreply(i))

	// add "tcommit" indicator
	do setsub("09")
	set seqr=seqr+1
	quit


	//-----------------------------------------------------------------
cgif	// create CGIF messages except 6403 to ^norepd for 
	// non-replicated report
	//------------------------------------------------------------------
	type public Number subseq,seqr,seq
	type public String message,p3,reply(),request(),sclass,type,vzreply
	type Number xseq,zseq

	set subseq=1
	do setsub("08CS"_"|"_sclass.get()_"|"_message.get())

	set zseq=""
	for  set zseq=request(zseq).order() quit:zseq.isNull()  do setsub("request|"_request(zseq))

	if vzreply.exists() do break("newreply",vzreply)

	set xseq=""
	for  set xseq=reply(xseq).order() quit:xseq.isNull()  do setsub("oldreply|"_reply(xseq))

	do setsub("09")
	set seqr=seqr+1
	quit


	//-------------------------------------------------------------------
type8	// host character interface updates with tp
	//---------------------------------------------------------------------
	type public Number iix,lseq,seq,seqr,subseq,verdiff
	type public String message,notable(),p3,reply(),request(),sclass,vzreply
	type public String fid,in(),statem,type,v1,v2
	type Number ifupdate,ET
	type String filetyp,glo,global,in,mainfile,rvalue,tras,value,x,zt
	type public IO io

	set seq=0,ifupdate=0,mainfile=0
	set ET=0

	for  set x=io.read(ET) quit:+ET=1  do { quit:type="09"

		set type=x.piece("\",1)
		if type="09" do array(.tras) quit
		if type'="04",type'="05" quit
		if type="05" set x=$$UNZWR(x)
		set value=x.piece("\",6,$l(x))
		do SPLIT(value,.glo,.rvalue)

		if glo["(" set global=glo.extract(2,99).piece("(",1)
		else  set global=glo.extract(2,999)

		if $$noapp(global) quit

		// use G.T.M function to check if any confilct to update to disk
		#ACCEPT CR=16677;DATE=09/12/05;PGM=Sanjay Chhabria
		#BYPASS
	.	s ifupdate=$ZQGBLMOD(@glo)  
	.	i ifupdate=1 s mainfile=1	
	.	; check if the global has relationship with DEP,ACN or CIF
	.	e  i ifupdate=0,glo["(" d
	..		s p3=$p(glo,"(",2,999)
	..      	s p3=$e(p3,1,$l(p3)-1)
	..		d getfid^URECREP(global,p3,,"")
	..		i fid="" d getfid^URECREP(global,p3,1,"")
	..		i fid="" q
	..		i $d(notable(fid))>0 s mainfile=1 q
	.	;
		#ENDBYPASS

		//two versions are same
		if verdiff=2 do {
			if type="05" do {
				set value=x.piece("\",6,9999)
				do SPLIT(value,.v1,.v2)
				set value="s "_v1_"="_""""_v2_""""
				set tras(seq+1)=value
				}
			else  if type="04" set tras(seq+1)="k "_x.piece("\",6)
			set seq=seq+1
			}

		// two versions are different
		else  set tras(seq+1)=x,seq=seq+1
		}
	quit


	//---------------------------------------------------------------------
array(tras)	// Re-apply TP-based character updates
	//---------------------------------------------------------------------
	type public Number lseq,mainfile,subseq,seqr,transid,verdiff
	type public String fid,in(),jourfile,type,statem,v1,v2,value
	type public Date timeseq
	type Number iix,seq

	// two versions are same
	if verdiff=2 do {

		// if no conflict for updating, update to disk 
		if mainfile=0 do {
			set seq=""
			for  set seq=tras(seq).order() quit:seq.isNull()  do set(tras(seq))
			}

		// can not be update to disk directly
		else  if mainfile>0 do {
			set subseq=1
			do setsub("08")

			set seq=""
			for  set seq=tras(seq).order() quit:seq.isNull()  do setsub(tras(seq))
			do setsub("09")
			set seqr=seqr+1
			}
		}

	// two versions are different
	else  do {

		// if no conflict call FILTER for scheme change, then update
		if mainfile=0 do {
			set in(0)="08"
			set iix=1
			set seq=""
			for  set seq=tras(seq).order() quit:seq.isNull()  set in(iix)=tras(seq),iix=iix+1
			set in(iix)="09"
			
			// call to filter
			do LOST^URECFIL(.in,verdiff)

			set lseq=""
			for  set lseq=in(lseq).order() quit:lseq.isNull()  do {
				set type=in(lseq).extract(1,2)
				if type'="04",type'="05" quit

				if type="04" set statem="k "_in(lseq).piece("\",6)
				else  if type="05" do {
					set value=in(lseq).piece("\",6,$l(in(lseq)))
					do SPLIT(value,.v1,.v2)
					set statem="s "_v1_"="_""""_v2_""""
					}
				do set(statem)
				}
			}

		// can not be update directly, recorded to file URECD for report
		else  if mainfile>0 do {
			set subseq=1
			set in(0)="08"
			set iix=1
			set seq=""
			for  set seq=tras(seq).order() quit:seq.isNull()  set in(iix)=tras(seq),iix=iix+1
			set in(iix)="09"
			do LOST^URECFIL(.in,verdiff)
			set lseq=""

			for  set lseq=in(lseq).order() quit:lseq.isNull()  do {
				if in(lseq).piece("\",1)="04" set statem="k "_in(lseq).piece("\",6)
				else  if in(lseq).piece("\",1)="05" do {
					set value=in(lseq).piece("\",6,in(lseq).length())
					do SPLIT(value,.v1,.v2)
					set statem="set "_v1_"="_""""_v2_""""
					}
				else  set statem=in(lseq)
				do setsub(statem)
				}
			set seqr=seqr+1
			}
		}

	// pointer to re-process trans id
	type RecordURECD urecd=Db.getRecord("URECD","TIMESEQ=:timeseq,JRNLFILE=:jourfile",1)
	set urecd.transid=transid
	do urecd.bypassSave()

	quit


	//---------------------------------------------------------------------
set(data)	// save info back to disk, automatically recovery
	//---------------------------------------------------------------------

	type Number n
	type String glob,value,x

	if data.extract(data.length())=13.char() set data=data.extract(1,data.length()-1)

	#ACCEPT Date=09/01/05;PGM=Sanjay Chhabria
	if data.extract()="k" xecute data quit
	set data=data.extract(3,9999)
	do SPLIT(data,.glob,.value)
	set x=glob_"="_value.extract(2,value.length()-1)
	set x=$$SETZWR(x)
	set x="set "_x

	#ACCEPT Date=09/01/05;PGM=Sanjay Chhabria
	xecute x
	quit


	//------------------------------------------------------------------
UNZWR(X)	// Change journal format from ZWR to string
	//-----------------------------------------------------------------
	type String data,p1,p2,x

	if X.extract(X.length())=13.char() set X=X.extract(1,X.length()-1)
	set data=X.piece("\",6,9999)
	do SPLIT(data,.p1,.p2)

	#ACCEPT Date=09/01/05;PGM=Sanjay Chhabria"
	if p2.length("_")<250 set x="x="_p2 xecute x

	// If maximum concatenation operations exceeded, do this in two parts
	else  do {
		type Number i
		type String a,b

		for i=200:1 set a=p2.piece("_",1,i) if a.length(34.char())#2 set b=p2.piece("_",i+1,999) quit
		set a="a="_a,b="b="_b

		#ACCEPT Date=09/01/05;PGM=Sanjay Chhabria"
		xecute a,b
		set x=a_b
		}

	set X.piece("\",6,9999)=p1_"="_x
	quit X


	//-----------------------------------------------------------------
SETZWR(X)	// Change journal format from string to ZWR
	//-----------------------------------------------------------------
	// Note:  Make sure that no variable name preceeds A, since we
	//	want A to be the first variable in the symbol table in
	//	order to be in position 1 after the ZSH

	type public String A,var()
	type String p1,p2

	do SPLIT(X,.p1,.A)
	zsh "v":var
	set p2=var("V",1).piece("=",2,9999)
	quit p1_"="_p2


	//-----------------------------------------------------------------
SPLIT(String X, String p1, String p2, String subs())  // Split journal record correctly at =
	/*
	-----------------------------------------------------------------
	 Arguments:
	       . X     Journal record	  /TYP=T/MECH=VAL
	
	       . p1    Piece one - returned    /TYP=T/MECH=REFNAM:W
	
	       . p2    Piece two - returned    /TYP=T/MECH=REFNAM:W
	
		. subs	Subscripts		/TYP=ARR/MECH=REFNAM:RW/OPT
			If subs="", return global and subscripts
			in subs() array, subscipted 1-n, and
			subs=number of subscripts
	
	 Example:
	
	       x = 05\57718,62312\19442\652\752014\^ABC(1)="test"
	       d SPLIT(x,.p1,.p2)
	
	       p1 =  05\57718,62312\19442\652\752014\^ABC(1)
	       p2 = "test"
	-----------------------------------------------------------------
	*/

	type Number cindex,eq,i,ii,j,ptr,seq
	type String remains,val,var
	type public String t2,temp

	if X'["=" set p1=X,p2="" quit

	if subs.get() kill subs set subs=1

	set ptr=0,eq=0
	for  do { quit:'ptr
		set ptr=X.find("=",ptr) quit:'ptr
		set p1=X.extract(1,ptr-2)
		if (p1.length(34.char())-1)#2'=0 quit
		set p2=X.extract(ptr,99999)
		set ptr=0,eq=1
		}

	if eq=0 set p1=X,p2="" set:subs.data() subs=0 quit
	quit:'subs.data()

	// Break global reference into subscripts
	set ptr=0
	set remains=p1.piece("(",2,9999),remains=remains.extract(1,remains.length()-1)
	set cindex=0,j=0,var=""

	for  do { quit:'cindex
		set cindex=remains.find("$C",cindex)
		if cindex>0 do {
			set t2=remains.find(")",cindex)
			set temp="$C"_remains.extract(cindex,t2-1)
			set var("abcde"_j)=temp
			set remains=remains.extract(1,cindex-3)_"abcde"_j_remains.extract(t2,remains.length())
			set j=j+1
			}
		}

	for i=1:1 set val=$$NPC^%ZS(remains,.ptr,",") quit:'ptr  set subs(i)=val
	if j>0 do {
		set seq=""
		for  set seq=subs(seq).order() do { quit:seq.isNull()
			if subs(seq).get().isNull() quit
			set ii=""
			for  set ii=var(ii).order() quit:ii.isNull()  do {
				if subs(seq)[ii set subs(seq)=subs(seq).piece(ii,1)_var(ii)_subs(seq).piece(ii,2)
				}
			if 'var(subs(seq)).get().isNull() set subs(seq)=var(subs(seq))	
			}
		}
	set subs=i-1
	quit


	//--------------------------------------------------------------------
notable	/* create refrence array
	--------------------------------------------------------------------
	 noapp		no replicated files
	 notable	array for CIF,ACN,DEP,LN or table related to them
	 auapp		array that do not need to use $zdatamod to check
	--------------------------------------------------------------------
	*/

	type public String auapp(),noapp(),notable()

	kill noapp,auapp,notable

	// array that do need to use $zdatamod to check
	set auapp("SYSLOG")=""

	// no replicated files
	set noapp("ACHTMP")=""
	set noapp("CHKINT")=""
	set noapp("CHKTMP")=""
	set noapp("DBBUF")=""
	set noapp("DBTMP")=""
	set noapp("ERROR")=""
	set noapp("ITNOSOL")=""
	set noapp("JSCTRL")=""
	set noapp("POSITION")=""
	set noapp("QUECTRL")=""
	set noapp("SVCTRL")=""
	set noapp("SVSTAT")=""
	set noapp("SVTRAP")=""
	set noapp("T")=""
	set noapp("TGLMON")=""
	set noapp("SQLCUR")=""
	set noapp("XDBREF")=""
	set noapp("ZACHTMP")=""

	// notable array for CIF,ACN,DEP,LN or table related to them
	set notable("CIF")="",notable("ACN")="",notable("DEP")="",notable("LN")=""

	type ResultSet rs=Db.select("FID","DBTBL1F","TBLREF='CIF' OR TBLREF='ACN' OR TBLREF='DEP' OR TBLREF='LN'")
	while rs.next() set notable(rs.getCol("FID"))=""

	quit


	//--------------------------------------------------------------
noapp(glob)	// Check to see if non-replicated global
	//--------------------------------------------------------------
	// Return 1 if non-replicated, 0 if replicated

	type public String noapp()

	if glob?1"TMP".e quit 1
	if glob?1"TEMP".e quit 1
	if glob?1"tmp".e quit 1
	if glob?1"ZTMP".e quit 1
	if noapp(glob).exists() quit 1
	quit 0


	//--------------------------------------------------------------
break(type,data)	// Break into 450 byte pieces
	/*-------------------------------------------------------------
	 Arguments:
		. type		data type		/typ=T
				first piece of saved data
	
		. data		string to break		/typ=T/req
	---------------------------------------------------------------
	*/
	type Number i

	for i=1:450:data.length() do setsub(type_"|"_data.extract(i,i+449))
	quit


	//---------------------------------------------------------------------
setsub(data)	// Set subseq level of ^norepd
	//---------------------------------------------------------------------
	
	type public Date timeseq
	type public Number seqr,subseq
	type public String jourfile
	
	type RecordURECDSEQ urecdseq=Db.getRecord("URECDSEQ","TIMESEQ=:timeseq,JRNLFILE=:jourfile,SEQR=:seqr,SUBSEQ=:subseq",1)
	set urecdseq.data1=data
	do urecdseq.bypassSave()

	set subseq=subseq+1
	quit 
 #OPTION ResultClass ON
Public String vSIG()	quit "60332^70046^Dan Russell^25364"	// Signature - LTD^TIME^USER^SIZE
