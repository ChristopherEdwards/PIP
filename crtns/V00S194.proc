V00S194(%ProcessMode,RecordINDEX1 INDEX1,RecordINDEX fINDEX)   // -  - SID= <INDEX1> Interest Index Rate - Tiered
 ;;Copyright(c)2006 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/24/2006 11:19 - kini
  /*
ORIG: CHENARDP - 03/03/2003
DESC: PSL Screen Compiler Template

---- Comments --------------------------------------------------------
	This procedure is used as the base template for the PSL screen compiler.
	It is referenced by the PSL screen compiler - procedure DBS2PSL4
	
	
---- Revision History ------------------------------------------------
	02/23/06 - Pete Chenard - CR19551
		   Fixed routine label.
		   
	05/19/05 - Pete Chenard - CR 14146
		   Modified to type variables.
		   
	12/1/03 - Spier -cr7178
	   	     Modifications to correct dead code warnings and
	   	     other issues that occurred during mass compile of screens.

	09/24/03 - Pete Chenard - 45497
		       Created screen template for compiler.
----------------------------------------------------------------------

 */

 #WARN SCOPE OFF
	type Public String %MODS,%PAGE,%PG,%REPEAT,ER,RM
	type String KEYS(),KVAR,VFSN(),VO,VODFT,VPGM,vPSL,VSID,VSNAME

	// %O (0-Create  1-Modify  2-Inquiry  3-Delete  4-Print  5-Blank screen)

	set:'$D(%ProcessMode) %ProcessMode=5
 set KVAR="kill %TAB,VFSN,VO,VPTBL,vtab,RATE",VSID="INDEX1",VPGM=$T(+0),VSNAME="Interest Index Rate - Tiered"
 set VFSN("INDEX")="zfINDEX",VFSN("INDEX1")="zINDEX1"
 set vPSL=1
 set KEYS(1)=fINDEX.INDEX
 //
	// ==================== Display blank screen         (%O=5)

 if %ProcessMode=5 set %MODS=1,%REPEAT=11 do VPR(.INDEX1,.fINDEX),VDA1(.INDEX1,.fINDEX),V5^DBSPNT quit

 set ER=0 do VSCRPRE(.INDEX1,.fINDEX) if ER quit  // Screen Pre-Processor
 
 if '%ProcessMode do VNEW(.INDEX1,.fINDEX),VPR(.INDEX1,.fINDEX),VDA1(.INDEX1,.fINDEX)
 if %ProcessMode do VLOD(.INDEX1,.fINDEX) quit:$G(ER)  do VPR(.INDEX1,.fINDEX),VDA1(.INDEX1,.fINDEX)

	// ====================  Display Form
	do ^DBSPNT()
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	if %ProcessMode=2!(%ProcessMode=3) do ^DBSCRT8A X:'$D(%PAGE) KVAR quit  // Inquiry/Delete
	// ====================  Set up data entry control table


 if %ProcessMode<2 do VTAB(.INDEX1,.fINDEX)
	quit


VNEW(RecordINDEX1 INDEX1,RecordINDEX fINDEX) // Initialize arrays if %O=0
 
 do VLOD(.INDEX1,.fINDEX)
 do VDEF(.INDEX1,.fINDEX)
 do VLOD(.INDEX1,.fINDEX)
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
	
VDEF(RecordINDEX1 INDEX1,RecordINDEX fINDEX)
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
VNEWDQ(RecordINDEX1 INDEX1,RecordINDEX fINDEX) // Original VNEW section
 
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
VLOD(RecordINDEX1 INDEX1,RecordINDEX fINDEX) // User defined access section
 //
 if '$D(%REPEAT) set %REPEAT=11
 if '$D(%MODS) set %MODS=1
 ;
 #ACCEPT date=11/05/03;pgm=Screen compiler
 quit
VLODDQ(RecordINDEX1 INDEX1,RecordINDEX fINDEX) //Original VLOD section
 
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


	type Public String %MODS,%REPEAT
	quit
	

VPR(RecordINDEX1 INDEX1,RecordINDEX fINDEX) // Display screen prompts
 set VO="10||13|"
 set VO(0)="|0"
 set VO(1)=$C(1,12,12,0,0,0,0,0,0,0)_"01T Index Name:"
 set VO(2)=$C(2,11,13,0,0,0,0,0,0,0)_"01T Description:"
 set VO(3)=$C(4,30,23,1,0,0,0,0,0,0)_"01T Tiered Interest Index "
 set VO(4)=$C(6,27,14,0,0,0,0,0,0,0)_"01TTiered Option:"
 set VO(5)=$C(7,25,16,0,0,0,0,0,0,0)_"01T Effective Date:"
 set VO(6)=$C(8,22,19,0,0,0,0,0,0,0)_"01TSch CMR Index Code:"
 set VO(7)=$C(10,1,10,2,0,0,0,0,0,0)_"01T   Level  "
 set VO(8)=$C(10,12,12,2,0,0,0,0,0,0)_"01TBalance Tier"
 set VO(9)=$C(10,32,21,2,0,0,0,0,0,0)_"01TNominal Rate or Index"
 set VO(10)=$C(10,56,15,2,0,0,0,0,0,0)_"01TExpiration Date"
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VDA1(RecordINDEX1 INDEX1,RecordINDEX fINDEX)  // Display screen data
 new V
 s RATE=$G(RATE)
 //
 set VO="15|11|13|"
 set VO(11)=$C(1,25,6,2,0,0,0,0,0,0)_"01T"_$E(INDEX1.INDEX,1,6)
 set VO(12)=$C(2,25,40,2,0,0,0,0,0,0)_"01T"_$E(fINDEX.DES,1,40)
 set VO(13)=$C(6,42,1,2,0,0,0,0,0,0)_"01T"_$E(fINDEX.INDTYP,1,1)
 set VO(14)=$C(7,42,10,2,0,0,0,0,0,0)_"01D"_$$DAT^%ZM(INDEX1.EFD)
 set VO(15)=$C(8,42,3,2,0,0,0,0,0,0)_"01N"_fINDEX.CMRINDEX
  
 set:'$D(%MODS) %MODS=1 set VX=$P(VO,"|",2)+4,DY=12 for I=%MODS:1:%REPEAT+%MODS-1 do VRDA(.INDEX1,.fINDEX)
 set $piece(VO,"|",1)=VX quit  // EOD pointer
 
VRDA(RecordINDEX1 INDEX1,RecordINDEX fINDEX)  // Display data %REPEAT times
 //instantiate new object if necessary
 if %ProcessMode=5 new v1
 if  set (v1)=""
 else  new v1
 else  set (v1,RATE(I))=$G(RATE(I))
 
 set VO(VX+1)=$C(DY,6,2,2,0,0,0,0,0,0)_"01N"_$P(v1,"|",3)
 set VO(VX+2)=$C(DY,12,18,2,0,0,0,0,0,0)_"00T"_$P(v1,"|",1)
 set VO(VX+3)=$C(DY,32,20,2,0,0,0,0,0,0)_"00T"_$P(v1,"|",2)
 set VO(VX+4)=$C(DY,56,20,2,0,0,0,0,0,0)_"00T"_$P(v1,"|",5)
 set DY=DY+1,VX=VX+4
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
	
	
VTAB(RecordINDEX1 INDEX1,RecordINDEX fINDEX)
 
 kill VSCRPP,REQ,%TAB,%MOD,%MODOFF,%MODGRP,%REPREQ,vtab set %REPREQ=9 set %MODGRP=1
 set %MODOFF=5,%MOD=4,%MAX=(%MOD*%REPEAT)+%MODOFF,VPT=1,VPB=11+%REPEAT,BLKSIZ=(60*%REPEAT)+60,PGM=$T(+0),DLIB="SYSDEV",DFID="INDEX1,INDEX",VSCRPP=1,VSCRPP=1
 set OLNTB=VPB*1000
 
 set VFSN("INDEX")="zfINDEX",VFSN("INDEX1")="zINDEX1"
 //
 for I=10:1:%MAX set %TAB(I)=""
	
	
 set %TAB(1)=$C(0,24,6)_"21T12401|1|[INDEX1]INDEX|[INDEX]"
 set %TAB(2)=$C(1,24,40)_"21T12401||[INDEX]DES"
 set %TAB(3)=$C(5,41,1)_"20T12402||[INDEX]INDTYP|[STBLINDTYP]"
 set %TAB(4)=$C(6,41,10)_"21D12402|1|[INDEX1]EFD"
 set %TAB(5)=$C(7,41,3)_"20N12413||[INDEX]CMRINDEX|[STBLCMRINDEX]"
 set %TAB(6)=$C(11,5,2)_"20N12403|*RATE(1)|[*]@RATE"
 set %TAB(7)=$C(11,11,18)_"00T12401|*RATE(1)|[*]@TIER|||do VP1^V00S194(.INDEX1,.fINDEX)||||2"
 set %TAB(8)=$C(11,31,20)_"00T12402|*RATE(1)|[*]@RATE1|||do VP2^V00S194(.INDEX1,.fINDEX)"
 set %TAB(9)=$C(11,55,20)_"00T12405|*RATE(1)|[*]@EXPDATE1|||do VP3^V00S194(.INDEX1,.fINDEX)"
 do VTBL(.INDEX1,.fINDEX)
	do ^DBSCRT8 	// data entry
	quit


VREQ   // Create REQ() array
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VTBL(RecordINDEX1 INDEX1,RecordINDEX fINDEX) //Create %TAB(array)
 	// 1 2 3  4 5   6   7-9 10-11
 	// DY,DX,SZ PT REQ TYPE DEL POS |NODE|ITEM NAME|TBL|FMT|PP|PRE|MIN|MAX|DEC

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VSPP   // screen post proc
 type Public RecordINDEX1 INDEX1
 type Public RecordINDEX fINDEX
 do VSPP1(.INDEX1,.fINDEX)
 #ACCEPT Date=11/05/03; pgm=Screen Compilerxxx
 quit
VSPP1(RecordINDEX1 INDEX1,RecordINDEX fINDEX)
 D VSPPREQ(.INDEX1,.fINDEX) I ER Q
 ;
 // Authorized Overdraft & Index Tier data item search.
 
 new A,DIFLAG,I,IT,J,TI,ZEROBAL
 set TI=""
 set DIFLAG=0
 set ZEROBAL=0
 for  set TI=$O(RATE(TI)) quit:TI=""  do { quit:ER 
 	if RATE(TI)["OD" do { quit:ER 
 	
		// Authorized Overdraft data items cannot be used with Index Tier data items.
 		if DIFLAG=2 set ER=1,RM=$$^MSG(901) quit      
 		else  set DIFLAG=1
 		}

 	if RATE(TI)["INTR" do { quit:ER 

		// Authorized Overdraft data items cannot be used with Index Tier data items
 		if DIFLAG=1 set ER=1,RM=$$^MSG(901) quit       
 		else  set DIFLAG=2
 		}

 	set IT=TI
 	for  set IT=$O(RATE(IT)) quit:IT=""  do { quit:ER 
 		if $P(RATE(TI),"|",1)="" quit 
 	
		// Balance tiers may not be repeated
 		if $TR($TR($P(RATE(TI),"|",1),"[",""),"]",".")=$TR($TR($P(RATE(IT),"|",1),"[",""),"]",".") set ER=1,RM=$$^MSG(317) quit
 		}

 	if +$P(RATE(TI),"|",1)=0 set ZEROBAL=1
 	if '($P(RATE(TI),"|",5)=""!$D(VALIDEXP($P(RATE(TI),"|",5)))) set $P(RATE(TI),"|",5)=$$^SCAJD($P(RATE(TI),"|",5))
 	if $P(RATE(TI),"|",1)?1"-".N1".".N!($P(RATE(TI),"|",1)?.N1".".N) set $P(RATE(TI),"|",1)=+$P(RATE(TI),"|",1)

 	}

 if ER quit 

 // Index must have a zero balance tier
 if 'ZEROBAL set ER=1 set RM=$$^MSG(1217)      
 
 // Re-sequence Index tiers.
 for I=1:1:%REPEAT-1 for TI=1:1:%REPEAT-1 if $P(RATE(TI),"|",1)="" set RATE(TI)=RATE(TI+1),RATE(TI+1)=""

 // Re-number piece #3 in tier to match tier level.
 for TI=1:1:%REPEAT set $P(RATE(TI),"|",3)=TI

 quit

 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit

VSPPREQ(RecordINDEX1 INDEX1,RecordINDEX fINDEX) 
 //_______________________________________________________
 //  User Defined Required Data Item Definitions
 //_______________________________________________________

 set ER=0

 for I=%MODS:1:%REPEAT+%MODS-1 do VR1(.INDEX1,.fINDEX) if ER set NI=((I-1)*4)+(1+%MODOFF) quit
 quit

VR1(RecordINDEX1 INDEX1,RecordINDEX fINDEX) 

 // (@TIER,@RATE1)

 I ($P(RATE(I),"|",1)'=""),($P(RATE(I),"|",2)'="") quit


 // (@TIER-,@RATE1-)

 I ($P(RATE(I),"|",1)=""),($P(RATE(I),"|",2)="") quit

 do VR99 quit

VR99 
 set RM="Missing required field(s)/data item set definition error"
 set ER=1 quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


  //user-defined post procs
 //
VP1(RecordINDEX1 INDEX1,RecordINDEX fINDEX) //
 // Update current RATE tier
 new DEC,TEMPX
 if X="" do DEL1 quit

 if $E(X)="-" set TEMPX=$E(X,2,99)
 else  set TEMPX=X
 set DEC=$$LOAD^SCARND(%CRCD,.dp)

 if TEMPX?.N!(TEMPX?.N1".".N) set X=$$^SCARND(+X,DEC) quit 

 // Invalid entry
 if 'fINDEX.DIAUTH set ER=1 set RM=$$^MSG(5791,X) quit

 // Invalid data item name
 if '$D(VALIDBAL(TEMPX)) set ER=1 set RM=$$^MSG(1300,X) quit
 quit 
 
DEL1	//
 do DELETE^DBSMACRO("@RATE1","1","0")

 do DELETE^DBSMACRO("@EXPDATE1","1","0")
 
GOTO1	//
 do GOTO^DBSMACRO("NEXT") quit 
 
 quit

VP2(RecordINDEX1 INDEX1,RecordINDEX fINDEX) //
 // Update current RATE tier
 
 new DINUM
 if $D(VALIDRT(X)) do {

 	// Invalid entry
	if 'fINDEX.DIAUTH set ER=1 set RM=$$^MSG(5791,X) quit
 	set DINUM=$P(RATE(z1),"|",1)

 	// Authorized Overdraft data items cannot be used with Index Tier data items
 	if DINUM["ODLIM" set ER=1 set RM=$$^MSG(901) quit 
 	if DINUM["INTR" do {

 		// All items on same tier must end in same number
 		if '($E(DINUM,($F(DINUM,"INTR")+3))=$E(X,($F(X,"INTR")+3))) set ER=1 set RM=$$^MSG(1794)
 		}
 	}
 else  do {
 	do VPO1(.INDEX1,.fINDEX)

 	// Must have an index or rate with each tier
 	if X="",$P(RATE(z1),"|",1)'="" set ER=1 set RM=$$^MSG(1836) quit
 	}
 quit 

VPO1(RecordINDEX1 INDEX1,RecordINDEX fINDEX)  // user library INDEX_RATE
 /*   Revision History
  04/03/06 - SmithCD - CR 20366
	     Fixed undefined error created by last change when a non-index 
	     rate is specified by moving code to re-format number rates for 
	     diplay and check for "Rate exceeds conventional limits" to 
	     before the call to VALTIER. Fixed infinite loop situation in 
	     POST1 section.
  03/27/06 - SmithCD - CR 20396
	     Modified "Index ~p1 links back to this index" check to check on 
	     just the first piece of the input string (X) so it will work 
	     even if there is a spread / rounding method. Cleaned up code, 
	     including creation of VALTIER section to protect the input 
	     string. Moved in POST1 section from INDX1.
  04/12/05 - JERUCHIMC - 14822
             Modify code for DBI II.  Replace direct global references
             with PSL. 
 
 */
 type public String X
 type public Boolean ER
 
 if X.isNull() quit
 type Boolean INDEXDF
 type String INDNAME
 set INDNAME = X.piece(" ", 1)
 set INDEXDF = Db.isDefined("INDEX", "INDEX=:INDNAME")
 // Check for 99.9.. (number and decimal only) format
 if X?.N.1".".N do { quit
	// Re-format for display
	set X = X.toNumber().roundDec(5, , 5)
	set X = X.translate(" ", "")
	// Rate exceeds conventional limits
	if X '< 100  do Runtime.setErrMSG("INDEX", 2310) quit
	}
 
 do VALTIER(X) quit:ER
 quit
VALTIER(String INPUTSTR)		// Protect input string
 // Validate index tier string
 type public Boolean ER
 type public String INDEX, INDNAME
 type public Boolean INDEXDF
 type String EXTRA, ROUND, SPREAD, X
 set SPREAD = INPUTSTR.piece(" ", 2)
 set ROUND = INPUTSTR.piece(" ", 3)
 if 'SPREAD.isNull(), "RUD".isLike("%"_SPREAD.extract(1)_"%")  do {
	// Rounding method w/no spread
	set ROUND = SPREAD
	set SPREAD = ""
	}
 set X = INDNAME
 do EDT^UINDX quit:ER
 set X = SPREAD
 do SPRPP^UINDX quit:ER
 if 'ROUND.isNull() do { quit:ER
	set X = ROUND
	do RNDPP^UINDX
	}
 // Index ~p1 links back to this index
 if INDNAME = INDEX do Runtime.setErrMSG("INDEX", 1223, INDNAME) quit
 
 if INDEXDF do POST1(INDNAME) quit
 
 // Entry must have a valid index
 do Runtime.setErrMSG("INDEX", 971) quit
 
 quit
 
POST1(String INDNAME)			// Index name
	// Set up check index loop
	type public Boolean ER
	type Date NEFD, JD, ZJD
	type String EFDSTR, RATEIND
	type Boolean DONE = 0
	if INDNAME.isNull() quit
	type RecordINDEX index = Db.getRecord("INDEX", "INDEX=:INDNAME")
	set NEFD = %EffectiveDate + 1
	type ResultSet rs = Db.select("EFD", "INDEX1", "INDEX=:INDNAME AND EFD<:NEFD")
	if rs.isEmpty(), index.basrel '= 3 do { quit
		set EFDSTR = %EffectiveDate.toString()
		// Index ~p1 not set up for ~p2
		do Runtime.setErrMSG("INDEX1", 1228, "N~EFDSTR") quit
		}
	set JD = %EffectiveDate
	
	set ZJD = JD + 1
		
	type ResultSet rs = Db.select("EFD,RATE", "INDEX1", "INDEX=:INDNAME AND EFD<:ZJD", "EFD DESC,RMIN ASC")
	while rs.next() do { quit:DONE
		set JD = rs.getCol("EFD")
			
		// Rate field may contain an index reference
		set RATEIND = rs.getCol("RATE").piece(" ", 1)
		// Index ~p1 contains link back to this index
		if RATEIND = INDNAME do Runtime.setErrMSG("INDEX1", 1220, RATEIND) quit
		// Found lowest level (contains numeric rate)
		if RATEIND?1N.N ! (RATEIND?.N1".".N) set DONE = 1 quit
	
		// Links back to non-existent index (~p1)
		if 'Db.isDefined("INDEX", "INDEX=:RATEIND") do Runtime.setErrMSG("INDEX", 1223, RATEIND) quit
		// Index ~p1 links back to this index
		if RATEIND = INDEX do Runtime.setErrMSG("INDEX", 1223, INDNAME) quit
		}
	quit
 #ACCEPT DATE=11/05/03;pgm=screen compiler
 quit
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
VP3(RecordINDEX1 INDEX1,RecordINDEX fINDEX) //
 // Update rate data
 
 new DIBAL,DICURR,DINUM1,DINUM2,DIRAT,TEMPX
 if X="" quit 

 if $D(VALIDEXP(X)) do { quit:ER 

 	// Invalid entry
	if 'fINDEX.DIAUTH set ER=1 set RM=$$^MSG(5791,X)
 	set DIBAL=$P(RATE(z1),"|",1)
 	set DIRAT=$P(RATE(z1),"|",2)

 	// Authorized Overdraft data items cannot be used with Index Tier data items
 	if X["INTR"&(DIBAL["ODLIM") set ER=1 set RM=$$^MSG(901)
 	if X["ODEXP"&(DIRAT["INTR"!(DIBAL["INTR")) set ER=1 set RM=$$^MSG(901)
 	if X["INTR" do { quit:ER 
 		set DINUM1=$E(DIBAL,($F(DIBAL,"INTR")+3))
 		set DINUM2=$E(DIRAT,($F(DIRAT,"INTR")+3))
 		set DICURR=$E(X,($F(X,"INTR")+3))

 		// All items on same tier must end in same number
 		if (DIBAL["INTR")&(DICURR'=DINUM1) set ER=1 set RM=$$^MSG(1794) quit
 		if (DIRAT["INTR")&(DICURR'=DINUM2) set ER=1 set RM=$$^MSG(1794) quit
 		}
 	}

 // Check valid date
 else  set TEMPX=$$DSJD^SCADAT(X)
 quit 

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit								// User defined post processor's


VRV(V,L) quit V_$J("",L-$L(V))
VREPRNT
 type Public RecordINDEX1 INDEX1
 type Public RecordINDEX fINDEX
 do VPR(.INDEX1,.fINDEX)
 do VDA1(.INDEX1,.fINDEX)
 do ^DBSPNT()
 quit

VW(RecordINDEX1 INDEX1,RecordINDEX fINDEX)
 do VDA1(.INDEX1,.fINDEX)
 do ^DBSPNT(10)
 quit

VDAPNT(RecordINDEX1 INDEX1,RecordINDEX fINDEX)
 do VDA1(.INDEX1,.fINDEX)
 do ^DBSPNT(0,2)
 quit

VDA
 type Public RecordINDEX1 INDEX1
 type Public RecordINDEX fINDEX
 do VDA1(.INDEX1,.fINDEX)
 quit

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
 
vSET(sn,di,X)
 type Public RecordINDEX1 INDEX1
 if sn="INDEX1" do vSET1(.INDEX1,di,X)
 type Public RecordINDEX fINDEX
 if sn="INDEX" do vSET2(.fINDEX,di,X)
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
vSET1(RecordINDEX1 INDEX1,di,X)
 do INDEX1.setAuditFlag(1)
 set INDEX1.@di=X
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
vSET2(RecordINDEX fINDEX,di,X)
 do fINDEX.setAuditFlag(1)
 set fINDEX.@di=X
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
vREAD(fid,di)
 type Public RecordINDEX1 INDEX1
 if fid="INDEX1" quit $$vREAD1(.INDEX1,di)
 type Public RecordINDEX fINDEX
 if fid="INDEX" quit $$vREAD2(.fINDEX,di)
 quit ""
vREAD1(RecordINDEX1 INDEX1,di)
 quit INDEX1.@di
vREAD2(RecordINDEX fINDEX,di)
 quit fINDEX.@di
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
 //
VSCRPRE(RecordINDEX1 INDEX1,RecordINDEX fINDEX)  // Screen Pre-Processor
 new %TAB,vtab // Disable .MACRO. references to %TAB()
 //
 // Create an array of valid data items.
 
 for I="DEP.ODLIM","DEP.ODLIM" set VALIDBAL(I)=""
 for I="DEP.INTRAMT1","DEP.INTRAMT1" set VALIDBAL(I)=""
 for I="DEP.INTRAMT2","DEP.INTRAMT2" set VALIDBAL(I)=""
 for I="DEP.INTRAMT3","DEP.INTRAMT3" set VALIDBAL(I)=""
 for I="DEP.INTRRAT1","DEP.INTRRAT1" set VALIDRT(I)=""
 for I="DEP.INTRRAT2","DEP.INTRRAT2" set VALIDRT(I)=""
 for I="DEP.INTRRAT3","DEP.INTRRAT3" set VALIDRT(I)=""
 for I="DEP.ODEXP","DEP.ODEXP" set VALIDEXP(I)=""
 for I="DEP.INTREXP1","DEP.INTREXP1" set VALIDEXP(I)=""
 for I="DEP.INTREXP2","DEP.INTREXP2" set VALIDEXP(I)=""
 for I="DEP.INTREXP3","DEP.INTREXP3" set VALIDEXP(I)=""
 
 new dp,DEC,TI
 set TI=""
 set DEC=$$LOAD^SCARND(%CRCD,.dp)
 for  set TI=$O(RATE(TI)) quit:TI=""  do {
 	if +$P(RATE(TI),"|",1)!($P(RATE(TI),"|",1)=0) set $P(RATE(TI),"|",1)=$$^SCARND($P(RATE(TI),"|",1),DEC)
 	}
 quit

 #ACCEPT date=11/05/03;PGM=Screen Compiler
 quit
