HLDREV	
	/*
	Check/Float Hold Reversal

	       ORIG:  MATTSON -  9 MAY 1991

	---- Revision History -----------------------------------------------
	
	11/23/06 - DHANALAKSHMI R - CR 23554
		   Modified the Error Correct process in the section REV to
		   pass TSEQ for TTX.TRC instead of TTX.TSEQ in the TTX 
		   fetch condition, since the variable TSEQ holds the value 
		   of Trace Number and not the Transaction Sequence Number. 
		   Modified the section REV to update the settings of the 
		   variable REV, inside if block, to set TSEQ instead of 
		   ttx.trc.

	08/28/06 - KUMARB - CR 22464
		   Modify section BCKOUT, in the beginning of the "for" 
		   loop to add conditional quit if KEY=8 and Check Hold
		   is not defined in Available Calculation Formula, to 
		   suppress the Check Hold record creation.
		   
	05/17/06 - SmithCD - CR 20855
		   . Made SEFD public in CHREV section to prevent undefined 
		     error when posting a regular reversal transaction
		   . Added .dep as second parameter in call to UPD^CRTHLD 
		     in CHECK section
		   . Pass missing parameters in section calls
		   . Minor cleanup
	  
	  11/29/05 - NATRAJAH - 13734
	  	     . Modified BCKOUT section, to reflect DEP file changes.
	  	     . Modified KEY8 section, to avoid the FILER call while 
	  	       deleting the record in HLD8 table.
	  	     . Modified SEQ section, to get correct format value for X.
	  	     . General DBI3 Cleanup.
	  	     
	  09/21/05 - RussellDS - CR16911
	  	     Replace reference to undefined ITC in CHREV section with
	  	     ttx.itc.
	  	     
	  	     Removed old revision history.

	   01/03/05 - TITOVE - CR 13734
		Cleaned up logic as part of DBI2 project.
	*/

	quit


public	REV(RecordTTX ttx,		// Transaction			/REF:R
	    RecordDEP dep)		// Deposit account		/REF:R

	// Called by TRNDRV when error correcting/reversing a transaction

	type public String TRID
	
	type String ETC,H,ID,ITC,UID,UTSO
	type Date EFD,EXPDAT,HEFD,SEFD
	type Number AGGAMT,AMT,BR,CID,CNT,COFLG,DEPAMT,HIT,HLDAMT,I,NEWAMT
	type Number OLDAMT,OPT,RCCREC,REV,SEQ,SQ,UPDAMT

	set CID=ttx.cid
	set (EFD,HEFD)=ttx.efd
	if HEFD.isNull() set HEFD=%SystemDate
	set (COFLG,DEPAMT)=0

	set ETC=ttx.etc
	type RecordTRN trn=Db.getRecord("TRN","ETC")

	// Obtain correct sequence and correct effective date
	do OUT^UTSO(.UTSO,ttx.tso)
	set ITC=ttx.itc
	if ITC.extract(6),UTSO("EC").exists() do {
		
		type Number BRCD,TSEQ
		set EFD = %SystemDate
		set SEFD = %SystemDate + ITC.extract(8)
		set BRCD=ttx.brcd
		set TSEQ=UTSO("EC")
		if Db.isDefined("TTX","TJD=:SEFD,BRCD=:BRCD,UID=:%UserID,TRC=:TSEQ") do {
			set REV=TSEQ
			if 'TRID.exists(),REV.get() do CHREV(.ttx,.dep,.trn)
			}
		else  set REV=UTSO("EC").get()
		set ID=ttx.brcd_"|"_REV_"|"_%UserID
		}
	else  if ITC.extract(12),UTSO("REV").exists() do {

		type Number TSEQ
		set TSEQ=UTSO("REV").get()
		if Db.isDefined("HIST","CID,TSEQ") do {
			type RecordHIST hist=Db.getRecord("HIST","CID=:CID,TSEQ=:TSEQ")
			type Number BRCD,TSEQ
			type String ITC,UID
			set ITC=hist.itc
			set SEFD = hist.tjd + ITC.extract(8)
			set BR=hist.brcd
			
			set TSEQ=hist.trc
			if TSEQ.isNull() set ID="|0" quit

			set UID=hist.uid
			type ResultSet rs=Db.select("TRC","TTX","TJD=:TJD AND BRCD=:BR AND UID=:UID and TSEQ=:TSEQ")
			if rs.isEmpty() set REV=hist.trc
			else  if rs.next() do {
				set REV=rs.getCol(1)
				// TRC might not be present in the TTX record
				if REV.isNull() set REV=TSEQ
				if REV.get() do CHREV(.ttx,.dep,.trn)
				}
			if 'TRID.exists()!(TRID.get()=0) set ID=BR_"|"_REV_"|"_UID
			}
		}	
	// If there is not a transaction sequence number then quit
	else  quit

	if ID.get().piece("|",2)=0 quit

	// Call from HLDREV^RECALC1 - do not proceed beyond this point
	if TRID.get()=0 set TRID=ID quit
	if 'TRID.get().isNull() quit
	
	do CHECK(.ttx,.dep,.trn)
	
	quit
	

CHECK(RecordTTX ttx,		// Transaction			/REF:R
      RecordDEP dep,		// Deposit account		/REF:R
      RecordTRN trn)		// Transaction code		/REF:R
	
	/*
	Check if the transaction being reversed had any associated check
	or float holds.  If so, reverse the holds, reconstruct the check
	amounts allocated to the account and reapply.  This methodology
	is necessary for Reg CC check hold requirements.
	*/
	
	type public Number AGGAMT,AMT,CID,COFLG,DEPAMT,HIT,HLDAMT,NEWAMT
	type public Number OLDAMT,OPT,SEQ,SQ
	type public String H,TRID

	type Number AGG,ONE,RCCREC,UPDAMT
	type String CHTRN

	#IF CUVAR.DFTCHTRN.isNull() set CHTRN="CH"
	#IF CUVAR.DFTCKTRN.isNull() set CHTRN="CK"

	// For split (cash back) hold transactions, set deposit amount
	if COFLG set DEPAMT=ttx.tamt
	if DEPAMT<0 set DEPAMT=-DEPAMT

	set (HIT,HLDAMT,SEQ,SQ)=""
	
	do SEQ(.ttx)
	if 'HIT quit

	/*
	Backout check/float holds and flag detail entries as having been
	error corrected.  New detail entries will be created that reflect
	the re-allocation of holds in program ^CRTHLD.
	*/

	do BCKOUT(.dep,.ttx)

	// Call from HLDREV^RECALC1 - do not proceed beyond this point
	if TRID.exists() quit
	
	// Skip processing for transaction types of 1, 2 and 3
	if trn.trntyp'=0 quit

	// Aggregate check amounts by customer (CIF) or account (CID)
	#IF CUVAR.REGCCOPT
		set OPT=dep.acn
	#ELSE
		set OPT=CID
	#ENDIF

	// Get the aggregate record of check amounts on effective date
	type RecordDAYENDRCC0 rcc0=Db.getRecord("DAYENDRCC0","TJD=:%EffectiveDate,OPT=:OPT",1)
	if rcc0.getMode() do {
		set AGG=rcc0.agg
		set ONE=rcc0.one
		set RCCREC=AGG+ONE
		}

	// Reset AMT for split (cash back) hold transactions
	if DEPAMT set AMT=DEPAMT

	if RCCREC.get() do {
		// Aggregate check amount
		set AGGAMT=AGG
		// REGCC (next day avail.) amount
		set OLDAMT=ONE
		// Decrease by reversal amount
		set NEWAMT=AGGAMT-AMT

		// Other check deposits/holds exist for this date
		if NEWAMT>0 do {
			/* 
			New aggregate amount more than REGCC (100) amount,
			only update the aggregate amount in DAYEND file
			*/
			if NEWAMT>100!(NEWAMT=100) set UPDAMT=OLDAMT
			/* 
			New aggregate amount less than REGCC (100) amount,
			update both aggregate and REGCC amounts in DAYEND file
			*/
			else  set UPDAMT=NEWAMT
			set rcc0.agg=NEWAMT
			set rcc0.one=UPDAMT
			do rcc0.bypassSave()
			}
		// No more check deposits/holds for this date - delete the REGCC
		// DAYEND file
		else  do Db.fastDelete("DAYENDRCC0","TJD=:%EffectiveDate,OPT=:OPT")
		}

	do INIT^CRTHLD(.ttx,.H)

	do UPD^CRTHLD(.ttx,.dep,.H)

	quit


SEQ(RecordTTX ttx)		// Transaction				/REF:R

	// Collate through the hold detail file

	type public Boolean ER
	type public Number AMT,CID,HIT,HLDAMT,REV,SEQ
	type public String ID

	type String X

        type ResultSet rs=Db.select("HLDSEQ","HLDDTL","SPD=:%EffectiveDate AND CID=:CID")
        while rs.next() do { quit:ER
                set SEQ=rs.getCol(1)
		type RecordHLDDTL hlddtl=Db.getRecord("HLDDTL","SPD=:%EffectiveDate,CID=:CID,HLDSEQ=:SEQ")
		// Already reversed
		if hlddtl.revflg quit
		set X=hlddtl.brcd_"|"_hlddtl.trc_"|"_hlddtl.uid
		if X'=ID quit
		set HIT=SEQ
		set HLDAMT=0
		
		type ResultSet rs=Db.select("HLDAMT,CHKFLT","HLDD","TJD=:%EffectiveDate and CID=:CID and HLDSEQ=:SEQ")
        	if rs.isEmpty() quit
        	while rs.next() do { quit:ER
  			// Amount allocated
			set AMT=rs.getCol(1)
			set REV(REV("").order(-1)+1)=rs.getCol(2)
			set HLDAMT=HLDAMT+AMT
			}
		set hlddtl.revflg=1
		do hlddtl.bypassSave()
		}

	quit


BCKOUT(RecordDEP dep,		// Deposit account			/REF:RW
       RecordTTX ttx)		// Transaction				/REF:R

	// Back out holds applied that day and update account information

	type public Number CID,CNT,REV
	type public Date HEFD

	type Date EXPDAT
	type Number HLDAMT,HLDTYP,KEY,I
	type String BALAVLCALCFO,X

	set CNT=""
	for  set CNT=REV(CNT).order() quit:CNT.isNull()  do {
		for I=1:1 set X=REV(CNT).piece("~",I) quit:X.isNull()  do {
			do dep.setAuditFlag()

			set HLDTYP=X.piece("#",1)
			set EXPDAT=X.piece("#",2)
			set HLDAMT=X.piece("#",3)
			set KEY=$select(HLDTYP="FLT":7,1:8)
			
			set BALAVLCALCFO = $$BALAVLFO^DEPCDI(CID)
				
			// Suppress check hold if Available Balance Calculation Formula
			// does not include check holds
			if (KEY=8),(BALAVLCALCFO.extract(4)'=1) quit
			
			if KEY=7 do {
				type RecordHLD7 hld=Db.getRecord("HLD7","CID,EXPDAT")
				if HLDAMT>hld.amt set HLDAMT=hld.amt
				// Decrement expiring amount on expiration date
				if '(hld.amt-HLDAMT) set hld.amt=0
				else  set hld.amt=hld.amt-HLDAMT
				do hld.bypassSave()
				// Decrement HLD7.TOT by reversal amount
				do KEY7
				}
			if KEY=8 do {				
				type RecordHLD8 hld=Db.getRecord("HLD8","CID,EXPDAT")	
				if HLDAMT>hld.amt set HLDAMT=hld.amt
				// Decrement expiring amount on expiration date
				if '(hld.amt-HLDAMT) set hld.amt=0
				else  set hld.amt=hld.amt-HLDAMT
				do hld.bypassSave()
				// Decrement HLD8.TOT by reversal amount
				do KEY8
				}

			// Expired on a previous day
			if EXPDAT<%SystemDate quit
			// Expired today
			if EXPDAT=%SystemDate,%EffectiveDate<%SystemDate quit
			// Back-dated ttx expired today
			if EXPDAT=%SystemDate,HEFD<%SystemDate quit

			// Increase collected balance ([DEP]BALCOL) by float hold
			if KEY=7 set dep.balcol=dep.balcol+HLDAMT

			// Decrease check hold amount ([DEP]CHKHLD) by 
			// check hold amount
			if KEY=8 set dep.chkhld=dep.chkhld-HLDAMT
		}
	}

	quit


KEY7

	/*
	 Decrement the Float Hold table's Total Hold Amount (HLD7.TOT) by
	 reversal amount for all entries that fall between hold's expiration
	 date and the date the hold went into effect.
	*/

	type public Number CID,HLDAMT
	
	type Date HDT
	
	type ResultSet rs=Db.select("EXPDT","HLD7","CID=:CID AND (EXPDT>:HEFD-1 AND EXPDT<:EXPDAT)")
	while rs.next() do {
		set HDT=rs.getCol(1)
		type RecordHLD7 hld7=Db.getRecord("HLD7","CID=:CID,EXPDT=:HDT")	

		if '(hld7.totamt) quit
		
		if '(hld7.totamt - HLDAMT) set hld7.totamt = 0
		else  set hld7.totamt = hld7.totamt - HLDAMT

		do hld7.bypassSave()
		}
		
	quit


KEY8

	/*
	 Decrement the Check Hold table's Total Hold Amount (HLD8.TOT) by
	 reversal amount for all entries that fall between hold's expiration
	 date and the date the hold went into effect.
	*/

	type public Number CID,HLDAMT
	type public Date HEFD
	
	type Date HDT
	
	type ResultSet rs=Db.select("EXPDT","HLD8","CID=:CID AND (EXPDT>:HEFD-1 AND EXPDT<:EXPDAT)","EXPDT DESC")

	while rs.next() do {
		set HDT=rs.getCol("EXPDT")
		type RecordHLD8 hld8=Db.getRecord("HLD8","CID=:CID,EXPDT=:HDT")

		if '(hld8.totamt) quit
		
		if '(hld8.totamt - HLDAMT) set hld8.totamt = 0
		else  set hld8.totamt = hld8.totamt - HLDAMT
		
		// Delete entries in HLD8 table, containing no useful data
		if '(hld8.totamt),'(hld8.amt) do Db.fastDelete("HLD8","CID=:CID,EXPDT=:HDT") quit

		do hld8.bypassSave()
		}
		
	quit


public	CHREV(RecordTTX ttx,		// Transaction			/REF:R
	      RecordDEP dep,		// Deposit account		/REF:R
	      RecordTRN trn)		// Transaction code		/REF:R

	// Reverse any CH associated with CK

	type public Number REV
	type public Date SEFD,TPD

	type Number END,PASS,SAVREV,TRS,TTXP
	type Date SFD
	type String ETC,ID

	set (PASS,TTXP)=0

	// Skip processing for transaction types of 1, 2 and 3
	quit:trn.trntyp'=0

	// Call from transaction driver
	if ttx.itc.extract(6) do { quit:PASS
		type Number AMT,BR,CHSEQ,CID,CNT,H,HEFD,HIT,HLDAMT,I
		type Date EFD,EXPDAT
		type String ITC,UID
		type Number OPT,SEQ,SQ
		
		set UID=%UserID
		set BR=ttx.brcd
		set TTXP=1
		set CID=ttx.cid
		set ITC=ttx.itc
		set HEFD=ttx.efd
		if HEFD.isNull() set HEFD=%SystemDate
		set EFD=%SystemDate
		if 'TPD.exists() set SFD=%SystemDate+ITC.extract(8)
		else  set SFD=TPD
		set SEQ=$$FIELD^UTSO(ttx.tso,"EC")
		if SEQ.isNull() set PASS=1 quit
		set (SAVREV,TRS)=SEQ
		set END=((TRS\1000)*1000)+999
		do IDBLD(.ttx,.dep,.trn)
		}

	// Call from REV^HLDREV
	else  do {
		set (TRS,SAVREV)=REV
		set END=((TRS\1000)*1000)+999
		set SFD=SEFD
		do IDBLD(.ttx,.dep,.trn)
		}

	quit


IDBLD(RecordTTX ttx,		// Transaction			/REF:R
      RecordDEP dep,		// Deposit account		/REF:R
      RecordTRN trn)		// Transaction code		/REF:R

	// Build ID array and process the reversal/error correction

	type public Number BR,CID,COFLG,END,REV,SAVREV,TRS
	type public String TRID,UID
	type public Date SEFD,SFD
	type public Boolean PASS,TTXP
	
	type Number CASHTR,QT,REVFLG,XCID
	type String ID
	
	set (CASHTR,QT) = 0

	// Find associated CH transaction, if any, skipping currency exchanges
	type ResultSet rs=Db.select("TSEQ","TTX","TJD=:SFD AND BRCD=:BR AND UID=:UID AND (TSEQ>:TRS AND TSEQ<:END+1) AND ETC <>'EXC'")
	if rs.next() do { quit:QT
		type Number CHSEQ,TRTYP,TS
		type String CURR
		set REVFLG=0
		set TS = rs.getCol("TSEQ")
		
		type RecordTTX ttx1 = Db.getRecord("TTX","TJD=:SFD,BRCD=:BR,UID=:UID,TSEQ=:TS")
		
		// Check for split (cash back) hold transactions
		if 'PASS,trn.trntyp=1 do { quit:REVFLG
			// Cash-out transaction - back to the top
			if ttx.itc1 do {
				set CASHTR=ttx1.tamt
				set REVFLG=1
				}
			// Cash-in transaction - exit processing
			else  do {
				set QT = 1
				set REVFLG=1
				}
			}
		// CK transaction expected, but not found - exit processing
		if 'PASS,'CASHTR,trn.trntyp'=2 set QT = 1 quit

		// Check transaction, back to the top to get the next record
		if trn.trntyp=2 set PASS=1 quit

		// CH transaction expected, but not found - exit processing
		if '(trn.trntyp=3) set QT = 1 quit

		// Account numbers do not match - exit processing
		if ttx1.cid'=CID set QT = 1 quit

		// For cash-out transactions, make sure that CO = CH
		if CASHTR,(ttx1.tamt'=CASHTR) set QT = 1 quit

		// For cash-out transactions, set the flag
		if CASHTR set COFLG=1

		// REV could be undefined at this point
		if REV.exists() set REV=SAVREV

		/*
		Transaction amounts do not match - quit processing, unless cash or
		multiple currencies are involved
		*/
		if Db.isDefined("TTX","SFD,BR,UID,REV") do { quit:QT
			type RecordTTX ttx2=Db.getRecord("TTX","TJD=:SFD,BRCD=:BR,UID=:UID,TSEQ=:REV")
			set CURR=$$FIELD^UTSO(ttx2.tso,"TCUR")
			if '(CASHTR),(CURR.isNull()),(ttx2.tamt'=ttx1.tamt) set QT = 1 quit
			}
		else  quit

		// Delete REV() left over from previous loop
		type Number REV
		set CHSEQ=ttx1.trc

		// Set match criteria for HLDD file
		set ID=BR_"|"_CHSEQ_"|"_UID

		// Call from HLDREV^RECALC1 - do not proceed beyond this point
		if TRID.exists() do { quit
			set TRID=ID
			set QT = 1
			}

		do CHECK(.ttx,.dep,.trn)
		
		// Quit processing, if not called from transaction driver
		if 'TTXP set QT = 1 quit
		}

	quit

vSIG()	quit "60592^21218^Dhanalakshmi R^13926"	// Signature - LTD^TIME^USER^SIZE
