EFTGIRO2 // Incoming GIRO Interface
	/*
	 ORIG: PrakashJ - 31/01/2006
	 DESC: Incoming GIRO Interface

	---- Comments --------------------------------------------------------

	---- Revision History ------------------------------------------------
	
	02/07/06 - KUMARB - 19055
		In section FINDEFT, modified the reference of
		EFTINDX to EFTPAY.
	
	01/18/06 - PRAKASHJ - 17423
		Converted to PSL. 

	-----------------------------------------------------------------------

	 ****** Consider using setAuditFlag for all objects in this procedure
	   example :do dep.setAuditFlag(1)

	 Incoming GIRO File (File Type: 020) has 5 record types:
	
		'01' - Heading Record		(1 record in each file)
		'02' - Heading of M1		(block max. 10 trans. records)
		'03' - Transaction Record	(10 in a block)
		'04' - Ending of M1
		'05' - Ending Record		(1 record in each file)
	
	*/

	do PREOPEN

	quit

PREOPEN	// Process to be run before we OPEN the input file 
	
	type public Boolean ER
	type public String %DIR,%FN,%LIBS,RM,TDRV
	
	type Date DATE,EFD
	type Number BCHCNT,ORGCUS,RESEFT,RESEXC,RESOUT,RESTART,RESTTX
	type String %CRCD,%INST,MSG
	
	set %LIBS="SYSDEV"
	do INT^%DIR set %INST=%DIR
	
	set EFD=%SystemDate
	
	type ResultSet rs=Db.select("TJD,SEQ","EFTIN","FILENAME=:TDRV","TJD")
	while rs.next() do {
		set DATE=rs.getCol("TJD")
		// Input file already processed
		if rs.getCol("SEQ")=1 do Runtime.setErrMSG("EFTIN",3091) quit
		set RESTART=1,(RESTTX,RESEFT,RESEXC,RESOUT)=0
		set MSG=$$^MSG(1032,%FN)
		use 0 write !!,$$MSG^%TRMVT(MSG)
		}
	
	/* Incoming file is a custom file, so must use custom output file
	  EFTCUS for any outgoing responses, not EFTOUT
	*/
	set ORGCUS=0
	if TDRV.get()'["GIRO" set ORGCUS=1
	set %CRCD=CUVAR.%crcd
	set BCHCNT=0
	
	quit
	 
PREREAD	// Process to be run before we go into the read loop 

	quit 
	
ALLREC	// Process to be run for every record read regardless of type 

	type public Boolean ER
	type public Number ERR,RECCNT
	type public String RECTYPE,RM,%MCP

	// First record is not header - bad file.	
	if RECCNT=1,RECTYPE'="01" set ERR=11 do RECERR(1)
	set RM="",ERR=0,ER=0,%MCP=CUVAR.%mcp
	
	do KILLS
	
	quit
	
RECCALL	// Process control for the diffrent record types 
	
	type public Boolean ER
	type public String RECTYPE
	
	if ER.get() quit
	
	if RECTYPE="01" do HEAD quit
	if RECTYPE="02" do HEADM1 quit
	if RECTYPE="03" do TRREC quit
	if RECTYPE="04" do TAILM1 quit
	if RECTYPE="05" do TAIL quit
	
	//Invalid record type
	do Runtime.setErrMSG("EFTIN",3093) do EXC
	
	quit
 
POSTREAD // Process to be run after EOF
 
	type public Number RESTART,RESTTX,RESEFT,RESEXC,RESOUT
	type public String TDRV
	
	type String FILE
	
	if '(TDRV.get()).isNull() do {
		kill RESTART,RESTTX,RESEFT,RESEXC,RESOUT
		set FILE=TDRV do ENDX
		}
	quit
 
UBCHINIT //
	
	quit
 
UBCHEND  //

	quit
 
UFILINIT // Initialize variables

	type public Boolean ER
	
	type Number OCC,TYPEPOS1,TYPEPOS2,NUMTRAN,TOTAMT
	type String %UID,BRCD,CCRJ(),CODE,TLO,TYPE,TYPES()
	
	set TYPEPOS1=1,TYPEPOS2=2 
	set NUMTRAN=0,TOTAMT=0
	
	set TLO=$$TLO^UTLO
	type RecordUTBLSRC utblsrc=Db.getRecord("UTBLSRC","SRCTYP='BOFF',KEY='EFT'",1)
	if 'utblsrc.getMode() set ER=1 quit
	set BRCD=utblsrc.brcd
	set %UID=utblsrc.uid
	set OCC=0
	
	// Load payment type common table
	type ResultSet rs=Db.select("KEY,DESC","CTBLEFTTYPE",,"KEY")
	while rs.next() do {
		set TYPE=rs.getCol("KEY")
		set TYPES(TYPE)=rs.getCol("DESC")
		}
	
	type ResultSet rs1=Db.select("RJCODE,RJDESC","UTBLCCRJ",,"RJCODE")
	while rs1.next() do {
		set CODE=rs1.getCol("RJCODE")
		set CCRJ(CODE)=rs1.getCol("RJDESC")
		}
		
	do GMA
	
	quit	
 
GMA	// GIRO Messages Supported

	type public String GM()

	// In case we receive a message that is not supported by this routine	
	set GM("001")=1
	set GM("201")=1
	set GM("002")=1
	set GM("202")=1
	set GM("007")=1
	set GM("207")=1
	set GM("092")=1
	set GM("292")=1
	set GM("094")=1
	set GM("294")=1
	
	quit
 
HEAD	// Interpret File Header

	/*-----------------------------------------------------------------------
		1-2	item code
		3-5	file type
		6-13	date of creation
		14-17	sequence
		18-23	time of creation
		24-24	duplicated code
		25-48	reserved for future use
	-----------------------------------------------------------------------
	*/
  
  	type public Boolean ER
  	type public Number ERR,TCHDDA,TDDA
	type public String REC,RM
  
	type String FTYP
	
	do BCHINIT
 
	set FTYP=REC.extract(3,5)
	
	//Invalid file type 
	if FTYP'="020" set ERR=11 do Runtime.setErrMSG("EFTIN",3092,FTYP) quit
 
	// technical DDA to use in place of GIRO suspense
	set TDDA=0
	if REC.length()>49 do {
		set TCHDDA=REC.extract(53,64)
		type RecordACN acn=Db.getRecord("ACN","CID=:TCHDDA",1)
		if 'acn.getMode() quit
		set TDDA=1
		}
	quit
 
HEADM1	// Interpret Header of M1 - Transaction Batch Header

	/*-----------------------------------------------------------------------
		1-2	item code
		3-3	sending bank qualifier
		4-9	sending bank code
		10-14	sending bank branch code
		15-22	remittance entry date
		23-26	remittance sequence number
		27-29	message seq number
		30-33	orig sending GID number
		34-37	actual sending GID number
		38-41	original receiving GID number
		42-45	actual receiving CID number
		46-59	date & time of exchange
		60-60	debit/credit code
		61-63	currency code
		64-64	decimal
		65-65	beneficiary qualifier
		66-66	doubled code
		67-74	settlement date
		75-75	indicator of settelment date modification
		76-76	priority code
		77-77	emergency code
		78-87	reserved for future use
	  -----------------------------------------------------------------------
 	*/
 	
	type public Number BCHAMT,BCHCNT,M1BCHCNT
		
	set BCHCNT=BCHCNT+1
	set BCHAMT=0
	set M1BCHCNT=0
	
	quit

TAILM1	// Interpret End of M1 - Transaction Batch Trailer

	/*-----------------------------------------------------------------------
		1-2	"04"
		3-6	number of transactions in M1 batch
		7-26	total amount in M1 batch
		27-30	reserved for future use
	  -----------------------------------------------------------------------
 	*/
 	
 	type public Boolean ER
	type public Number BCHAMT,M1BCHCNT
	type public String REC,RM
	
	type Number TBCHAMT,TM1BCNT
	
	set TBCHAMT=REC.extract(7,26)
	set TBCHAMT=$$NOZRO(TBCHAMT)/100		
	
	// Batch amount ~p1 does not equal trailer ~p2
	if TBCHAMT'=(BCHAMT/100) do Runtime.setErrMSG("EFTIN",3094,(BCHAMT/100)_"~"_TBCHAMT) do EXC
	
	set TM1BCNT=+REC.extract(3,6)
	
	//Batch count ~p1 does not equal trailer ~p2
	if TM1BCNT'=M1BCHCNT do Runtime.setErrMSG("EFTIN",3095,M1BCHCNT_"~"_TM1BCNT) do EXC
	
	quit

TAIL	// Interpret File Trailer

	/*-----------------------------------------------------------------------
		1-2	"05"
		3-5	batch count (number of M1 batches)
	-----------------------------------------------------------------------
	*/
	
	type public Boolean ER
	type public Number BCHCNT
	type public String REC,RM
	
	type Number TBCHCNT
	
	// Compare Trailer/Batch Count to Batch Count
	set TBCHCNT=REC.extract(3,6)
	if TBCHCNT=BCHCNT quit
	
	//Batch count ~p1 does not equal trailer ~p2
	do Runtime.setErrMSG("EFTIN",3095,BCHCNT_"~"_TBCHCNT) do EXC
	
	quit

TRREC	// Interpret transaction record & react accordingly
 
	type public Number FILCNT,RECCNT
	type public String GMSG,IN3,IN4,IN5,REC,RESULT,TDRV
	
	type Number TMPAMT
	type String BANK,GIRO
	
	set GIRO=REC.extract(1,95)	//interpret GIRO section
	do GIROA(GIRO)

	set BANK=REC.extract(96,355)	//interpret BANK section
	do BANKA(BANK)
 
	type RecordEFTIN eftin=Db.getRecord("EFTIN","TJD=:%SystemDate,FILENAME=:TDRV,SEQ=:RECCNT",1)
	set eftin.rectype=GMSG.get()
	set eftin.result=RESULT.get()
	set eftin.cid=IN3.get()
	set eftin.pseq=IN4.get()
	set eftin.status=IN5.get()
	set eftin.record=REC.get()
	do eftin.save()
	
	set FILCNT=FILCNT+1
	
	quit

GIROA(String REC) // Interpret GIRO area of incoming message
 
 	type public Number G5,G7,G9,M1BCHCNT
	type public String BCHAMT,G1,G10,G11,G12,G13,G14,G2,G3,G4,TMPAMT
	type public String G41,G42,G43,G6,G8,G8DEC,%CRCD
	
	type String GBR
	
	set G1=REC.extract(1,2)			//item code
	set G2=REC.extract(3,5)			//transaction code/message type
 
	set GBR=+REC.extract(44,48)			
	if G2="007" do G007 quit 		//MPO GIRO area mappings
	if G2="094" do G094 quit 

	set G3=REC.extract(6,7)			//transaction subcode
	set G4=REC.extract(8,19)		//originator bank reference
	set G41=G4.extract(1)			//qualifier
	set G42=G4.extract(2,7)			//bank code - EFTINST check
	set G42=$$NOSPC(G42)
	set G43=G4.extract(8,12)		//branch
	set G5=REC.extract(20,36)		//transaction number
	set G6=REC.extract(37,48)		//beneficiary bank
 
	set (G7,TMPAMT)=REC.extract(49,66)		//settlement amount
	if 'BCHAMT.get() set BCHAMT=0
	set BCHAMT=BCHAMT+G7
	if 'M1BCHCNT.get() set M1BCHCNT=0
	set M1BCHCNT=M1BCHCNT+1		 
	set G7=$$AMCNV(G7)			//strip off leading & trailing 0s
	set G8=%CRCD				//currency code
	set G8DEC=REC.extract(70,70)		//currency code decimals
	set G9=REC.extract(71,78)		//settlement date
	set G9=$$DTCNV(G9)			//convert to julien
 
	set G10=REC.extract(79,79)		//priority code
	set G11=REC.extract(80,80)		//emergency code
	set G12=REC.extract(81,83)		//charges
	set G13=REC.extract(84,93)		//reserved for future use
	set G14=REC.extract(94,95)		//error code
	
	quit

BANKA(String REC) // Interpret bank area of message
	
	type public Boolean ER
	type public String G2,G3,GM(),RESULT,RM
	
	type String GMSG
	
	/* If the transaction code is 001, use Giro Message 001. 
	   If the tran code is 002 and the subcode is 00, use Giro Message 002.
	*/
	if G2="001" set GMSG=G2
	if G2="002" set GMSG=G2

	// For tran code 002 and subcode 01 or 03, use Giro Message 00201.
	if ((G2="002")&((G3="01")!(G3="03"))) set GMSG="00201"

	// For any other transaction codes, use the Giro Message of same name.
	if (GMSG.get()).isNull() set GMSG=G2

	// Invalid input
	if (GM(GMSG).get()).isNull() do Runtime.setErrMSG("EFTIN",1379) quit
	
	do @GMSG
	
	quit

001 // Incoming Transfer (Payment) Order - PO - Payment Order w/Value

	type public Boolean ER
	type public String CCRJ(),EFTTYPE,ETC,G4,G42,G43
	type public String G5,G9,GBR,REC,TCHDDA,TDDA,TTDA

	type Number B1,B2,B31,B51,B6,B7,CID,G7,GL
	type String A50,B10,B11,B12,B32,B4,B52,B8,B9,CRCD
	type String GSUSP,GSUSPX,RJC,TAMT,TCMT,TSO,TYPE
	
	// Interpret message
	set B1=REC.extract(1,9)		//initiating bank reference no.
	set B2=REC.extract(10,15)	//payment order sequence
					//originator (dr) customer
	set B31=REC.extract(16,31)	//account number
	set B31=$$NOSPC(B31)
	set B31=$$ACCNV(B31)
	set B32=REC.extract(32,63)	//identifier
	set B32=$$NOSPC(B32)
	
	set B4=REC.extract(64,67)	//payment indicator
					//addressee (cr) customer
	set B51=+REC.extract(68,83)	//account number
	set B51=$$ACCNV(B51,GBR)
	set B51=$$NOSPC(B51)
	set B52=REC.extract(84,115)	//identifier
	set B52=$$NOSPC(B52)
	
	set B6=REC.extract(116,123)	//initiation date
	set B6=$$DTCNV(B6)		//julien format
	set B7=REC.extract(124,155)	//word zone 1
	set B8=REC.extract(156,187)	//word zone 2
	set B9=REC.extract(188,219)	//word zone 3
	set B7=$$NOSPC(B7)
	set B8=$$NOSPC(B8)
	set B9=$$NOSPC(B9)
	set B10=REC.extract(220,223)	//origintor (dr) customer's add acct no.
	set B11=REC.extract(224,227)	//addressee (cr) customer's add acct no.
	set B12=REC.extract(228,260)	//free area
	
	/*-----------------------------------------------------------------------
	   Set up variables CID, TAMT, ETC for posting via TTXFMT
	  -----------------------------------------------------------------------
		DR  GIRO Suspense Account (Accumulation)
		CR  Profile Account
	  -----------------------------------------------------------------------
	  -----------------------------------------------------------------------
	   Check for errors in the message.  If errors, then check CCRJ table and
	   determine if we want to attempt to repair the message or reject it
	   outright.  Either way, we will still post the transactions, only
	   if there is an error, we post back to the GIRO suspense and the funds
	   remain there until either given to the Profile account or sent back
	   to the sending party.
	  -----------------------------------------------------------------------
	   If we want to attempt repair, then build the EFTPAY record w/status 
	   "PR" for pending review.  If we do not want to attempt repair, build 
	   rejection message 2xx and place into EFTOUT for next send to CC. 
	  -----------------------------------------------------------------------
	*/
	
	set CID=B51
	set GSUSPX=$$GLOFF("PO")
	if GSUSPX.isNull() set GSUSPX=CUVAR.glts
	if TDDA set GSUSPX=TCHDDA
	
	set GSUSP=(CUVAR.penrevgl).toString()
	if GSUSP.isNull() set GSUSP=CUVAR.glts
	
	set RJC=$$ACCCHK(B51,B52)		//check for account errors
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR"
	
	if RJC.isNull() set RJC=$$INSCHK(G42_G43)	//check for institution errors
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR"
	
	// We got a reject reason, so either repair or reject
	if 'RJC.isNull() do {
		if CCRJ(RJC).piece("|",2) do BLDEFT(.CID,B31,G7,"PO",B7,B8,B9,RJC) quit
		do REJOUT(B51,B31,B32,G4,G5,G9,RJC,B7,"201",,1)
		set CID=$$ETCGL("EFTOUT"),GL=1,ETC="EFTOUT"
		}
	
	// Build & post TRs
	if RJC.isNull() do {
		type RecordACN acn=Db.getRecord("ACN","CID=:CID")
		set TYPE=acn.type 
		set CRCD=acn.crcd
	 	set EFTTYPE="PO"
	 	type RecordCTBLEFTPROD eftprod=Db.getRecord("CTBLEFTPROD","TYPE=:TYPE,EFTTYPE=:EFTTYPE",1)
		set ETC=eftprod.ictc
		if ETC.isNull() do {
			type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE",1)
			set ETC=prodctl.crtrgp
			}
		}
	
	if ER quit  
	set TAMT=G7 
	set TCMT=B7                                       //wording zone 1 
	set TSO=$$BLDTSO(CID,G42_G43_B31,"",B1)
	do CRETTX
	
	quit
	
00201 // Immediate Collections 00201 and 00203
	
 	type public String GBR,REC
 	
	type String B10,B11,B12,B32,B4,B52,B6,B8,B9
	type Number B1,B2,B31,B51,B7
	
	// Interpret Message
	
	set B1=REC.extract(1,9)        	//initiating bank reference no. 
	set B2=REC.extract(10,15)       //payment order sequence 
	                                //originator (dr) customer 
	set B31=REC.extract(16,31)      //account number 
	set B31=$$NOSPC(B31)
	set B31=$$ACCNV(B31)
	set B32=REC.extract(32,63)      //identifier 
	set B32=$$NOSPC(B32)
	
	set B4=REC.extract(64,67)       //payment indicator 
	                                //addressee (cr) customer 
	set B51=+REC.extract(68,83)     //account number 
	set B52=REC.extract(84,115)     //identifier 
	set B52=$$NOSPC(B52)
	
	set B6=REC.extract(116,123)     //initiation date 
	set B6=$$DTCNV(B6)
	set B7=REC.extract(124,155)     //word zone 1 
	set B8=REC.extract(156,187)     //word zone 2 
	set B9=REC.extract(188,219)     //word zone 3 
	set B7=$$NOSPC(B7) 
	set B8=$$NOSPC(B8) 
	set B9=$$NOSPC(B9) 
	set B10=REC.extract(220,229)    //unique ID of the check. 
	set B11=REC.extract(230,233)    //debtor customer's "additional" account 
	set B12=REC.extract(234,237)  	//addresee (creditor) customer's 
					//additional account number
	set B12=REC.extract(238,260)	//Free area
	
	do IN002			//treat as 002 message
	
	quit 
	
002 // Incoming Collection Order 00200
	//	- Collection Order w/Value
	
	/*-----------------------------------------------------------------------
	  We sent out an 092 requesting funds, and now an 002 came back with
	  the funds for our customer, so credit him.
	  -----------------------------------------------------------------------
	  Interpret Message
	  -----------------------------------------------------------------------
	*/
	
	type public String GBR,REC
		
	type Number B1,B2,B31,B32,B7
	type String B10,B11,B12,B4,B51,B52,B6,B8,B9

	set B1=REC.extract(1,9)		//initiating bank reference no.
	set B2=REC.extract(10,15)	//payment order sequence
					//originator (dr) customer
	set B31=REC.extract(16,31)	//account number
	set B31=$$NOSPC(B31)
	set B31=$$ACCNV(B31)
	set B32=REC.extract(32,63)	//identifier
	set B32=$$NOSPC(B32)
	
	set B4=REC.extract(64,67)	//payment indicator
					//addressee (cr) customer
	set B51=+REC.extract(68,83)	//account number
	set B52=REC.extract(84,115)	//identifier
	set B52=$$NOSPC(B52)
	
	set B6=REC.extract(116,123)	//initiation date
	set B6=$$DTCNV(B6)
	set B7=REC.extract(124,155)	//word zone 1
	set B8=REC.extract(156,187)	//word zone 2
	set B9=REC.extract(188,219)	//word zone 3
	set B7=$$NOSPC(B7) 
	set B8=$$NOSPC(B8) 
	set B9=$$NOSPC(B9) 
	set B10=REC.extract(220,223)	//origintor (dr) customer's add acct no.
	set B11=REC.extract(224,227)	//addressee (cr) customer's add acct no.
	set B12=REC.extract(228,260)	//free area
	
	quit
	
IN002	/* Find original CO we sent out in an 092, in which we requested the
	  funds, which now we've received back in this 002.
	  -----------------------------------------------------------------------
	   Set up variables CID, TAMT, ETC for posting via TTXFMT 
	  -----------------------------------------------------------------------
	       DR  GIRO Suspense Account (Accumulation) 
	       CR  Profile Account 
	  -----------------------------------------------------------------------
	*/
	
	type public Number B1,B31,B51,B7,G7,RESTART,TAMT,TCHDDA,TDDA
	type public String B52,B8,B9,G42,G43,TSO
	
	type Number CID,match
	type String ETC,GL,GSUSP,GSUSPX,msgamount,msgefttype,msgrecacct,msgrecinst,msgstatus,RJC,TCMT
		
	set CID=B51                       // account
	set match=0
	
	set GSUSPX=$$GLOFF("PO") 
	if GSUSPX.isNull() set GSUSPX=CUVAR.glts
	if TDDA set GSUSPX=TCHDDA 
	 
	set GSUSP=(CUVAR.penrevgl).toString()
	if GSUSP.isNull() set GSUSP=CUVAR.GLTS
	
	set RJC=$$ACCCHK(B51,B52)         //check for account errors 
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR" 
	
	if RJC.isNull() do {
		set msgrecinst=G42_G43 		// originating bank
		set msgrecacct=B31 		// originating account
		set msgamount=G7 		// amount
		set msgefttype="CO"             // Efttype/status resulting in 
		set msgstatus=$S(RESTART.get()=1:"",1:"S")	// this incom msg. 
		do MATCHEFT
		}
	
	/* If we found the original CO, post TRs to credit Profile account
	  from this COVAL, then update CO from Submitted to Completed.
	*/
	if match.get()=1 do OK002 quit
	
	/* If we could not find the original CO, then we assume that we
	  want to review why we received these funds, so post TRs back to
	  GIRO suspense and place into review file.
	*/
	set GL=1
	if RJC.get().isNull() set RJC=99			 
	
	do BLDEFT(.GSUSP,B31,G7,"PO",B7,B8,B9,RJC)
	
	set CID=GSUSP,ETC="MCR",TCMT="No match for incoming transaction 002" 
	set TAMT=G7
	set TSO=$$BLDTSO(B51,G42_G43_B31,"",B1) 
	do CRETTX 
	
	quit
	
OK002	// Post credit to Profile account and update original CO w/"C"
	
	type public Number B1,B31,B32,B51,B7,CID,G7,SEQ,TCHDDA,TDDA
	type public String A50,B52,B8,B9,CCRJ(),EFTTYPE,G4,G42
	type public String G43,G5,G9,RESTART,TAMT,TCMT,TSO,type
	
	type Boolean ogl,ER
	type Number QUIT,RESEFT
	type String CRCD,ETC,GL,GSUSP,GSUSPX,RJC,TYPE
	
	type public RecordEFTPAY eftpay
	
	set GSUSPX=$$GLOFF("CO") 
	if GSUSPX.isNull() set GSUSPX=CUVAR.glts
	if TDDA set GSUSPX=TCHDDA 
	 
	set GSUSP=(CUVAR.penrevgl).toString()
	if GSUSP.isNull() set GSUSP=CUVAR.glts
	
	set RJC=$$ACCCHK(B51,B52)		//check for account errors
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR"
	
	if RJC.isNull() set RJC=$$INSCHK(G42_G43)	//check for institution errors
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR"
	
	if 'RJC.isNull() do {
		if CCRJ(RJC).piece("|",2)  do BLDEFT(.CID,B31,G7,"PO",B7,B8,B9,RJC) quit
		do REJOUT(B51,B31,B32,G4,G5,G9,RJC,B7,"202",,1)
		set CID=$$ETCGL("EFTOUT"),GL=1,ETC="EFTOUT"
		}
	
	// Build & post TRs
	if RJC.isNull() do {
		type RecordACN acn=Db.getRecord("ACN","CID=:CID")
		set TYPE=acn.type
		set CRCD=acn.crcd
		set EFTTYPE="COVAL"
		type RecordCTBLEFTPROD eftprod=Db.getRecord("CTBLEFTPROD","TYPE=:TYPE,EFTTYPE=:EFTTYPE",1)
		set ETC=eftprod.ictc
		if ETC.isNull() do {
			type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE",1)
			set ETC=prodctl.crtrgp
			}
		}
	
	if ER quit  	
	set TAMT=G7 
	set TCMT=B7 
	set TSO=$$BLDTSO(CID,G42_G43_B31,"",B1) 
	
	type RecordEFTPAY fEFTPAY=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ",1)
	set fEFTPAY=eftpay.copy(0)
	
	set CRCD=fEFTPAY.crcd 
	do CRETTX 
	if 'RJC.isNull() quit  
	 
	// update original CO we sent as now "C" - completed 
	set fEFTPAY.status="C"
	set EFTTYPE=fEFTPAY.efttype 
	if GL.get() set ogl=1,type="G/L" 
	
	// PAR RESTART
	set QUIT=0
	if RESTART.get()=1&(RESEFT.get()=0)&('G5.get().isNull()) do FINDEFT(CID,G5)
	if QUIT=1 quit
	set RESEFT=1
	
	// File to the database
	do fEFTPAY.save()
	
	quit
	
G007	// Giro area 007
	
	type public Number BCHAMT,M1BCHCNT
	type public String REC,%CRCD
	
	type Number G5,G52,G7
	type Date G51,G9
	type String G1,G10,G11,G121,G122,G13,G14,G2,G3,G4
	type String G41,G42,G43,G53,G61,G62,G63,G8,G81,G82,GBR
		
	set G1=REC.extract(1,2)		//02
	set G2=REC.extract(3,5)		//tran code 007
	set G3=REC.extract(6,7)		//sub-code 01
	
	set G4=REC.extract(8,19)
	set G41=REC.extract(8,8)		//qualifier
	set G42=REC.extract(9,14)		//bank of initiator's contra account
	set G42=$$NOSPC(G42)
	set G43=REC.extract(15,19)		//branch and CDV
	set G5=REC.extract(20,36)		//transaction number
	set G51=REC.extract(20,27)		//entry date
	set G52=REC.extract(28,34)		//serial number
	set G53=REC.extract(35,36)		//00
	set G61=REC.extract(37,37)		//qualifier
	set G62=REC.extract(38,43)		//bank of beneficiary
	set G62=$$NOSPC(G62)
	set G63=+REC.extract(44,48)		//branch and CDV
	set GBR=G63
	set G7=REC.extract(49,66)		//amount	cannot be zero
	set G7=$$AMCNV(G7)
	if 'BCHAMT.get() set BCHAMT=0
	set BCHAMT=BCHAMT+G7		
	if 'M1BCHCNT.get() set M1BCHCNT=0
	set M1BCHCNT=M1BCHCNT+1		
	set G81=REC.extract(67,69)		//currency HUF
	set G8=%CRCD				//currency code
	set G82=REC.extract(70,70)		//2
	set G9=REC.extract(71,78)		//date of settlement
	set G9=$$DTCNV(G9)
	set G10=REC.extract(79,79)		//priority
	set G11=REC.extract(80,80)		//emergency
	set G121=REC.extract(81,81)		//fee
	set G122=REC.extract(82,83)		//only spaces
	set G13=REC.extract(84,93)		//RFU only spaces
	set G14=REC.extract(94,95)		//error code
	
	quit
 
007 // Group Transfer (e.g. Payroll)

	type public Boolean ER
	type public String B10,B11,B32,B4,CCRJ(),EFTTYPE,ETC,FTTYPE,GBR,GL,REC,TDDA
	
 	type Number B1,B2,B31,B51,B8,ID,RCID
 	type String A50,B52,B6,B7,B9,CID,CRCD,G4,G42,G43,G5,G6,G7,G9
 	type String GSUSP,GSUSPX,RJC,TAMT,TCHDDA,TCMT,TSMT,TSO,TVMT,TYPE
 	
	// A group of incoming 001s to credit our customers.
	
	set B1=REC.extract(1,9)			//internal reference number
	set B2=REC.extract(10,15)		//serial number of order
	set B31=REC.extract(16,31)		//initiator's acct
	set B31=$$NOSPC(B31)
	set B31=$$ACCNV(B31)
	set B32=REC.extract(32,63)		//initiator's name
	set B32=$$NOSPC(B32)
	set B4=REC.extract(64,67)		//transaction purpose	//remove last sp
	set B51=REC.extract(68,83)		//addressee/bene acct
	set B51=$$NOSPC(B51)
	set B51=$$ACCNV(B51,GBR)
	set B52=REC.extract(84,115)		//addressee/bene name
	set B52=$$NOSPC(B52)
	set B6=REC.extract(116,123)		//date of crediting
	set B6=$$DTCNV(B6)
	set B7=REC.extract(124,154)		//basis identifier
	set B8=REC.extract(155,178)		//customer id
	set B9=REC.extract(179,210)		//name of customer
	set B9=$$NOSPC(B9)
	set B10=REC.extract(211,242)		//address of customer
	set B10=$$NOSPC(B10)
	set B11=REC.extract(243,260)		//notice
	
	set CID=B51
	set GSUSPX=$$GLOFF("PO") 
	if GSUSPX.isNull() set GSUSPX=CUVAR.glts
	if TDDA set GSUSPX=TCHDDA 
	 
	set GSUSP=(CUVAR.penrevgl).toString()
	if GSUSP.isNull() set GSUSP=CUVAR.glts
	
	set RJC=$$ACCCHK(B51,B52)		//check for account errors
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR"
	
	if RJC.isNull() set RJC=$$INSCHK(G42_G43)	//check for institution errors
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR"
	
	// We got a reject reason, so either repair or reject
	if 'RJC.isNull() do {
		if CCRJ(RJC).piece("|",2) do { quit
			if TDDA set RCID=TCHDDA	
			else  set RCID=B31			
			do BLDEFT(.CID,RCID,G7,"PO",B7,B8,B9,RJC)
			}
		do REJOUT(B51,B31,B32,G4,G5,G9,RJC,B7,"207",B8,1)
		set CID=$$ETCGL("EFTOUT"),GL=1,ETC="EFTOUT"
		}
	
	// Build & post TRs
	if RJC.isNull() do {
		type RecordACN acn=Db.getRecord("ACN","CID=:CID")
		set TYPE=acn.type
		set CRCD=acn.crcd
		set EFTTYPE="PO"
		type RecordCTBLEFTPROD eftprod=Db.getRecord("CTBLEFTPROD","TYPE=:TYPE,EFTTYPE=:EFTTYPE",1)
		set ETC=eftprod.ictc
		if ETC.isNull() do {
			type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE",1)
			set ETC=prodctl.crtrgp
			}
		}
		
	if ER quit  					 
	set TAMT=G7.get() 
	set TCMT=B7.get() 
	set TSO=$$BLDTSO(B51,G42_G43_B31,"",B1) 
	do CRETTX
	
	quit
	
092 // Immediate Collection Order (Non-Financial Request)

	/*-----------------------------------------------------------------------
	   Must check for debit authorization// if request is unauthorized,
	   check CCRJ to determine if we put to review file or reject outright.
	  -----------------------------------------------------------------------
	   If a valid collection, then build COVAL record to send funds back to
	   requestor by DR Profile acct and credit GIRO G/L and put it into
	   EFTPAY for next run of @QUE068 to send out.
	  -----------------------------------------------------------------------
	*/
		
	type public Boolean ER
	type public Number ACN,BALAVL
	type public String AUT,REC,RM
	
	type Number B1,B11,B2,B31,B51
	type Date B6
	type String B10,B10,B11,B12,B32,B4,B52,B7,B8,B9,CCRJ,CID,ETC,G13,G2,G4
	type String G42,G42,G43,G5,G8,G9,GBR,GL,GSUSP,GSUSPX,RJC,TCHDDA,TDDA
	
	// Interpret message
	
	set B1=REC.extract(1,9)        	//initiating bank reference no.
	set B2=REC.extract(10,15)	//payment order sequence 
	                                //originator (cr) customer 
	set B31=REC.extract(16,31)      //account number 
	set B31=$$NOSPC(B31)
	set B31=$$ACCNV(B31)
	set B32=REC.extract(32,63)      //identifier 
	set B32=$$NOSPC(B32)
	
	set B4=REC.extract(64,67)       //payment indicator 
	                                //addressee (dr) customer 
	set B51=+REC.extract(68,83)      //account number 
	set B52=REC.extract(84,115)     //identifier 
	set B52=$$NOSPC(B52)
	
	set B6=REC.extract(116,123)     //initiation date 
	set B6=$$DTCNV(B6)
	set B7=REC.extract(124,155)     //word zone 1 
	set B8=REC.extract(156,187)     //word zone 2 
	set B9=REC.extract(188,219)     //word zone 3 
	set B7=$$NOSPC(B7) 
	set B8=$$NOSPC(B8) 
	set B9=$$NOSPC(B9) 
	set B10=REC.extract(220,239)    //reason of presentation/collection 
	set B11=REC.extract(240,257)    //amount to be collected 
	set B11=$$AMCNV(B11)
	set B12=REC.extract(258,260)    //Free area 
	 
	// Check for valid debit authorization 
	set CID=B51
	set GSUSPX=$$GLOFF("COVAL") 
	if GSUSPX.isNull()  set GSUSPX=CUVAR.glts
	if TDDA set GSUSPX=TCHDDA 
	 
	set GSUSP=(CUVAR.penrevgl).toString()
	if GSUSP.isNull() set GSUSP=CUVAR.glts
	 
	set RJC=$$ACCCHK(B51,B52)       //check for account errors 
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR" 
	
	if RJC.isNull() set RJC=$$INSCHK(G42_G43)      //check for institution errors 
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR" 
	if RJC.isNull() do {
		set BALAVL=$$BALAVL^DEPCDI(CID)
		if BALAVL<G13.get() set RJC="50"
		kill BALAVL 
		}
	
	// We got a reject reason, so either repair or reject 
	if 'RJC.isNull() do { quit
		if CCRJ(RJC).piece("|",2) do BLDEFT(.CID,B31,B11,"COVAL",B7,B8,B9,RJC) quit
		do REJOUT(B51,B31,G42_G43,G4,G5,G9,RJC,B7,"292") 
		} 
	
	// Passed normal checks// now, is it authorized ?
	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	set ACN=acn.acn
	
	//Customer number not defined on PROFILE account ~p1
	if ACN.isNull() do Runtime.setErrMSG("ACN",3100,CID) do EXC quit
	
	set AUT=$$DEBCHK("C",ACN,B31,G42_G43,"",G9,B11,G8,"","")
	
	// Authorized// build and file COVAL w/status "A"
	if AUT do BLDEFT(.B51,B31,B11,"COVAL",B7,B8,B9,RJC) quit
	
	// Not authorized; review COVAL w/status "PR", or send rejection
	set GL=1
	if RJC.get()'="65" set RJC="51"
	if CCRJ(RJC).piece("|",2) do BLDEFT(.GSUSP,B31,B11,"COVAL",B7,B8,B9,RJC) quit
	do REJOUT(B51,B31,B32,G4,G5,G9,RJC,B7,"292")
	
	quit
	
G094	// Giro area 094
	
	type public String %CRCD,REC
	
	type Date G51
	type Number B11,BCHAMT,G10,G11,G12,G121,G122,G13,G52,G7,G81,G82,M1BCHCNT
	type String G1,G14,G2,G3,G4,G41,G42,G43,G5,G52,G53,G6,G61,G62,G63,G8,G9,GBR

	set G1=REC.extract(1,2)		//02
	set G2=REC.extract(3,5)		//tran code
	set G3=REC.extract(6,7)		//sub-code 00
	set G4=REC.extract(8,19)
	set G41=REC.extract(8,8)	//qualifier
	set G42=REC.extract(9,14)	//bank of initiator's contra account
	set G42=$$NOSPC(G42)
	set G43=REC.extract(15,19)	//branch code and CDV
	set G5=REC.extract(20,36)
	set G51=REC.extract(20,27)	//entry date
	set G52=REC.extract(28,34)	//serial number
	set G53=REC.extract(35,36)	//00
	set G6=REC.extract(37,48)
	set G61=REC.extract(37,37)	
	set G62=REC.extract(38,43)	//bank of beneficiary
	set G62=$$NOSPC(G62)
	set G63=+REC.extract(44,48)
	set GBR=G63
	set G7=REC.extract(49,66)	//amount	//must be 0s !
	if 'BCHAMT.get() set BCHAMT=0
	set BCHAMT=BCHAMT+G7		 
	if 'M1BCHCNT.get() set M1BCHCNT=0
	set M1BCHCNT=M1BCHCNT+1		 
	set G81=REC.extract(67,69)	//currency HUF
	set G82=REC.extract(70,70)	//2
	set G8=%CRCD			//currency code
	set G9=REC.extract(71,78)	//date of settlement
	set G9=$$DTCNV(G9)
	set G10=REC.extract(79,79)	//priority	//zero
	set G11=REC.extract(80,80)	//emergency	//zero
	set G12=REC.extract(81,83)
	set G121=REC.extract(81,81)	//fee		//spaces
	set G122=REC.extract(82,83)	//		//spaces
	set G13=REC.extract(84,93)	//amount to be collected
	set G13=G13*100
	set G13=$$AMCNV(G13)		//must be numeric and positive
	set G14=REC.extract(94,95)	//error code
	
	quit
	
094 // Incoming Group Collection (e.g. Direct Debits)

	/*-----------------------------------------------------------------------
	   A group of incoming 092s to debit our customers.  A debit
	   authorization check is necessary for each debit.
	  -----------------------------------------------------------------------
	*/

	type public Boolean ER
	type public String ACN,G42,G43,G81,GBR,REC,RJC,RM
	
	type Number B1,B2,B31,B8,BALAVL,CID,G13,IBSCID
	type String B10,B11,B32,B4,B51,B52,B6,B7,B9,ETC,G4
	type String G5,G9,GL,GSUSP,GSUSPX,TCHDDA,TDDA,UTID
	
	set B1=REC.extract(1,9)		//internal reference number
	set B2=REC.extract(10,15)	//serial number of order
	set B31=REC.extract(16,31)	//initiator's acct
	set B31=$$NOSPC(B31)
	set B32=REC.extract(32,63)	//initiator's name
	set B32=$$NOSPC(B32)
	set B4=REC.extract(64,67)	//transaction purpose
	set B51=REC.extract(68,83)	//addressee/obliger acct
	set B52=REC.extract(84,115)	//addressee/obliger name
	set B52=$$NOSPC(B52)
	set B6=REC.extract(116,123)	//time of debiting
	set B6=$$DTCNV(B6)		
	set B7=REC.extract(124,154)	//basis identifier
	set UTID=REC.extract(124,136)	//utility id
	set UTID=$$NOSPC(UTID)
	set B8=REC.extract(155,178)	//customer id
	set B8=$$NOSPC(B8)
	set B9=REC.extract(179,210)	//name of customer
	set B9=$$NOSPC(B9)
	set B10=REC.extract(211,242)	//address of customer
	set B10=$$NOSPC(B10)
	set B11=REC.extract(243,260)	//notice

	// Check for valid debit authorization 
	set CID=B51 
	set CID=$$NOSPC(CID)
	set CID=$$ACCNV(CID,GBR)
	set IBSCID=CID			//PROFILE account
	set GSUSPX=$$GLOFF("COVAL") 
	if GSUSPX.isNull() set GSUSPX=CUVAR.glts
	if TDDA set GSUSPX=TCHDDA 

	set GSUSP=(CUVAR.penrevgl).toString()
	if GSUSP.isNull() set GSUSP=CUVAR.glts
	
	set RJC=$$ACCCHK(CID,B52)         //check for account errors 
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR" 
	if RJC.isNull() set RJC=$$INSCHK(G42_G43)    //check for institution errors 
	if 'RJC.isNull() set CID=GSUSP,GL=1,ETC="MCR" 
	
	if RJC.isNull() do {
		set BALAVL=$$BALAVL^DEPCDI(CID)
		if BALAVL<G13.get() set RJC="50"
		kill BALAVL
		}
	
	// We got a reject reason, so reject outright, as direct debits 
	// do not go into review file
	if 'RJC.isNull() do REJOUT(IBSCID,B31,B32,G4,G5,G9,RJC,B7,"294",B8) quit
	
	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	set ACN=acn.acn
	
	//Customer number not defined on PROFILE account ~p1
	if ACN.isNull() do Runtime.setErrMSG("ACN",3100,CID) do EXC quit

	if $$AUT094("C",ACN,UTID,G9,G13,G81,1,B8) do { quit    
		do BLDEFT(IBSCID,B31,G13,"COVAL",B7,B8,B9,RJC)
		}
	
	// Not authorized// send rejection 
	if RJC.get()'="65" set RJC="51"			
	do REJOUT(IBSCID,B31,B32,G4,G5,G9,RJC,B7,"294",B8)
	
	quit

201 // Payment Order Rejection

	quit

202 // Collection Order w/Value Rejection

	/*-----------------------------------------------------------------------
	   We sent out an 001/002, and for some reason, it did not pay the
	   recipient and was rejected, ergo the incoming 201/202.
	  -----------------------------------------------------------------------
	   Handle via inclearing, allowing CR to Profile account to repay
	   our client, the sender, the funds that he sent out.  The DR is part
	   of the accumulation to the GIRO suspense.
	  -----------------------------------------------------------------------
 	*/
 	
 	type public Boolean ER
	type public Number G7,TAMT,TCMT,TCHDDA,TDDA
	type public String A50,B32,B6,EFTTYPE,ETC,G2,G5,G8,GL,GSUSP,GSUSPX,ORGEFT,REC,TSO,TYPE
 	
	type Number CID
	type String CRCD,SEQ
	
	do REJINC(REC)

	set GSUSPX=$$GLOFF("PO")
	if GSUSPX.isNull() set GSUSP=CUVAR.glts		//define the GL suspense, or
	if TDDA set GSUSPX=TCHDDA			//the technical DDA
	
	type RecordEFTREFG eftrefg=Db.getRecord("EFTREFG","TRNO=:B32",1)
	if 'eftrefg.getMode() do { quit
		set CID=(CUVAR.penrevgl).toString()
		set GL=1
		set ETC="MCR"
		set TAMT=G7.get()
		set TCMT=B6.get()
		set CRCD=G8.get()
		set TSO=$$BLDTSO(CID,"","",B32.get())
		do CRETTX
		do BLDEFT(CID,CID,G7,"PO",B6.get(),"","",99)
		}
	
	set CID=eftrefg.cid 
	set SEQ=eftrefg.seq
	
	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1) 	
	set TYPE=acn.type
	set CRCD=acn.crcd
	
	set EFTTYPE=$S(G2.get()=202:"COVAL",1:"PO") 
	type RecordCTBLEFTPROD eftprod=Db.getRecord("CTBLEFTPROD","TYPE=:TYPE,EFTTYPE=:EFTTYPE",1)
	set ETC=eftprod.ictc
	if ETC.isNull() do {
		type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE",1)
		set ETC=prodctl.crtrgp
		}
	
	set TAMT=G7
	set TSO=$$BLDTSO(CID,"","",B32)
	do CRETTX
	kill ORGEFT,CID,SEQ
	
	quit
 
292 // Collection Order Rejection

	/*-----------------------------------------------------------------------
	  We sent out an 092, and the request was rejected by the 
	  recipient bank.
	  -----------------------------------------------------------------------
	*/
 
	type public Boolean ER,ogl
	type public Number CID,SEQ,REJDR,RESTART,TMPAMT
 	type public String B32,B5,EFTTYPE,G5,G9,GL,ORGEFT,REC,RM,type
 	
	type Number RESEFT,QUIT

	set REJDR=REJDR+TMPAMT
	
	do REJINC(REC) 
	
	type RecordEFTREFG eftrefg=Db.getRecord("EFTREFG","TRNO=:B32",1)
	
	// 292 received. No original 092: ~p1.
	if 'eftrefg.getMode() do Runtime.setErrMSG("EFTREFG",3118,B32.get()) do EXC quit
	
	// update original CO we sent as now "R" - rejected
	set CID=eftrefg.cid 
	set SEQ=eftrefg.seq
	
	type RecordEFTPAY fEFTPAY=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ",1)
	set fEFTPAY.status="R"
	set fEFTPAY.rejreas=B5.get()
	set fEFTPAY.rtndt=G9.get()
	set EFTTYPE=fEFTPAY.efttype 
	if GL.get() set ogl=1,type="G/L"
 
	// PAR RESTART
	set QUIT=0
	if RESTART.get()=1&(RESEFT.get()=0)&('G5.get().isNull()) do FINDEFT(CID,G5)
	if QUIT=1 quit
	set RESEFT=1
 
	// File to the database
	do fEFTPAY.save()
 
	kill ORGEFT,CID,SEQ  //,fEFTPAY 
	
	quit
 
REJOUT(Number FCID,Number RCID,String RINS,String B31,String B32,Date B4,String B5,String B6,String REJMSG,String B8,String POST)
	/*-----------------------------------------------------------------------
	   Build Rejection Message (2xx where xx represents original message)//
	   place into ^EFTOUT to be sent out by EFTGIRO1.
	  -----------------------------------------------------------------------
	    B1	01-09    init bank internal ref #
	    B2	10-15    payment ord seq #
	    B31	16-27    original bank ID
	    B32	28-44    original trans number
	    B4	45-52    settlement date of original tr
	    B5	53-54    reason of reject
	    B6	55-86    wording zone/basis id
	    B7	86-109   customer id 	(207/294 only) (from original B8)
	    B8   110-141  notices	(207/294 only)
	    B99	87-260   unused
	  -----------------------------------------------------------------------
	   In cases (207, 294), the GIRO area is identical w/structure of
	   the initiating transaction.
	  -----------------------------------------------------------------------
	*/

	type public String B1,B11,B2,B3,CID,G10,G11,G12,G13,G14,G4,G5,G6,G7,G8,G9
	type public String GMSG,REJ,RESOUT,RESTART,RESULT,RJC(),SAVTRC,SEQ,TRC,TSO

	type Number QUIT,tamt,TSEQ,ORGCUS
	type String EFT61

	// PAR RESTART
	set QUIT=0
	if RESTART.get()=1&(RESOUT.get()=0)&('B32.get().isNull()) do FINDOUT
	if QUIT=1 quit
	set RESOUT=1 
	set B1=$$REFGEN
	if 'B2.get() set B2=1
 
	if B1.length()'=9 set B1=$$ZEROS(B1,9)
	if B2.length()'=6 set B2=$$ZEROS(B2,6)
	 
	if B31?8N set B31="1"_B31.extract(1,3)_"   "_B31.extract(4,8)
	
	if REJMSG=294 set B3=G4.get()_G5.get()
	if REJMSG=292 set B3=G4.get()		
	
	set B3=B31.get()_B32.get() 			
	if B3.length()'=29  set B3=$$SPACE(B3,29)
	
	if B4.toString().length()'=8  set B4=B4.toString("YEARMMDD")     
	if B4.toString().length()'=8  set B4=$$ZEROS(B4,8)
	
	if B5.length()'=2  set B5=$$ZEROS(B5,2)
	
	if (GMSG.get()'="007"),(GMSG.get()'="094") do {
		type RecordUTBLCCRJ ccrj=Db.getRecord("UTBLCCRJ","RJCODE=:B5")
		set B6=ccrj.rjdesc
		}
	if (B6.get()).length()'=31 set B6=$$SPACE($G(B6),31)
	
	if REJMSG=294 do {
		set REJ("G4")=G6.get()
		set REJ("G6")=G4.get()
		set REJ("G7")=G7.get()
		set REJ("G8")=G8.get()
		set REJ("G9")=G9.get()
		set REJ("G10")=G10.get()
		set REJ("G11")=G11.get()
		set REJ("G12")=G12.get()
		set REJ("G13")=G13.get()
		set REJ("G14")=G14.get()
		set REJ("RJC")=RJC.get()
		}
	set REJ("G7")=G7.get()				// rejected amount
	set REJ("G10")=G10.get()_G11.get()		// country code
	set REJ("FCID")=FCID				// our customer
	set REJ("RINS")=RINS				// sender bank
	set REJ("RCID")=RCID				// sender acct
	set REJ("SEQ")=SEQ.get()
	// PAR RESTART
	set REJ("ORIGTRNO")=B32.get()
	
	set REJ("REJMSG")=REJMSG			// reject msg code
	set REJ("REJREC")=B1_B2_B3_B4_B5_B6 		// reject msg bank area
	
	if (GMSG.get()="007")!(GMSG.get()="094") do {
		if (B8.get()).length()'=24 set B8=$$SPACE(B8.get(),24)
		set REJ("REJREC")=REJ("REJREC")_B8.get()
		}

	do IN^UTSO(.REJ,.TSO)
	set tamt=G7.get()
	if (GMSG)="092" set tamt=B11.get()
	
	// if originated from a custom file, then the responses must not 
	// go to the GIRO, so put into ^EFTCUS to be put into a separate 
	// output file, rather than ^EFTOUT which is sent to GIRO. 
	if 'ORGCUS.get() do {
		set ORGCUS=0
		type RecordEFTPAY reftpay=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ")
		set EFT61=reftpay.origfile
		if ('EFT61.isNull())&(EFT61'["GIRO") set ORGCUS=1
		}
	
	if (ORGCUS.get()=1)&((REJMSG="207")!(REJMSG="294")) do { quit
		type ResultSet rs=Db.select("TSEQ","EFTCUS","SJD=:%SystemDate","TSEQ DESC")
		if rs.next() set TSEQ=rs.getCol("TSEQ")
		type RecordEFTCUS eftcus=Db.getRecord("EFTCUS","SJD=:%SystemDate,TSEQ=:TSEQ+1",1)
		set eftcus.tso=TSO
		set eftcus.cid=FCID
		set eftcus.tamt=tamt
		do eftcus.save()
		set RESULT=$$^MSG(3122,REJMSG)
	        kill B3,REJ,TSO
		}
	
	type ResultSet rs=Db.select("TSEQ","EFTOUT","TJD=:%SystemDate","TSEQ DESC")
	if rs.next() set TSEQ=rs.getCol("TSEQ")
	type RecordEFTOUT eftout=Db.getRecord("EFTOUT","TJD=:%SystemDate,TSEQ=:TSEQ+1",1)
	set eftout.tso=TSO
	set eftout.cid=FCID
	set eftout.tamt=tamt
	do eftout.save()
	set RESULT=$$^MSG(3123,REJMSG)
	
	set SAVTRC=TRC.get()
	if POST.get() do REJTR
	set TRC=SAVTRC
	
	kill B3,REJ,TSO
	
	quit
	
REJTR	/* Build TRs to post a direct rejection; no EFTPAY record exists to
	   rely upon.  None is necessary.  This is for T+1.
	*/
	
	type public Date TPD
	type public Number CID
	type public String brcd,cc,G7,G8,par,TCMT,TR,TSO,type,uid
	
	type RecordUTBLSRC utblsrc=Db.getRecord("UTBLSRC","SRCTYP='BOFF',KEY='FUTURE'",1)
	set brcd=utblsrc.brcd
	set uid=utblsrc.uid
	
	type RecordTTX ttx()
	
	set ttx(1)=Class.new("RecordTTX")	

	set ttx(1).cid=$$ETCGL("EFTOUT")
	set ttx(1).itc="0"
	set ttx(1).etc="MDR"
	set ttx(1).tamt=G7
	set ttx(1).efd=%SystemDate+1
	set ttx(1).crcd=G8.get()

	set ttx(2)=Class.new("RecordTTX")	

	set ttx(2).cid=$$GLOUT("PO")
	set ttx(2).itc="1"
	set ttx(2).etc="MCR"
	set ttx(2).tamt=G7
	set ttx(2).efd=%SystemDate+1
	set ttx(2).crcd=G8.get()

	do TRNSET^TRNDRV(.ttx(),%SystemDate+1,brcd,0)

	quit
	
REJINC(String REC) // Parse out incoming rejection message
	
	type public String BRCD
		
	type Number B1,B2,OSEQ
	type Date B4,ODATE
	type String B32,B5,B6,B99,INSTX,OBRCD,OFLIO,OINST
	
	set B1=REC.extract(1,9)		// init bank internal reference #
	set B2=REC.extract(10,15) 	// payment order sequence (serial) #
	 				// original transaction ref. code
	set OINST=REC.extract(17,19)	// original bank ID
	set OBRCD=REC.extract(23,27)
	set INSTX=OINST_BRCD
	
	/* the following is from the G5 field on our outgoing message
	   coming back as B3 on the rejection
	*/
	set ODATE=REC.extract(28,35) 	// original transaction number dt
	set OSEQ=REC.extract(36,42)	// original sequence
	set OFLIO=REC.extract(43,44)	// folio
	set B32=REC.extract(28,44)
	
	set B4=REC.extract(45,52) 	// settlement date
	set B5=REC.extract(53,54) 	// reason of reject
	set B6=REC.extract(55,86)	// wording zone
	set B99=REC.extract(87,260)	// unused
	
	quit
	 
MATCHEFT // Routine to match received msg against existing EFTPAY record 
	
	type public Number CID,match,SEQ
	type public String EFTTYPE,malpha,msgamount,msgefttype
	type public String msgrecacct,msgrecinst,msgstatus,sgefttype
	
	set match=0,SEQ=0
	// 
	type ResultSet rs=Db.select("SEQ","EFTPAY","CID=:CID AND EFTTYPE=:msgefttype","SEQ") 
	while rs.next() do { quit:match
		set SEQ=rs.getCol("SEQ")
		type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ")
		if 'msgstatus.length()!(eftpay.status=msgstatus) do {
			if '+msgamount!(eftpay.amount=+msgamount) do {
				if 'msgrecacct!(eftpay.recacct=msgrecacct) do {
					if 'msgrecinst.length()!(eftpay.recinst=msgrecinst) do {
						set match=1
						set EFTTYPE=eftpay.efttype
						}
					}
				}
			}
		}
		
	kill malpha,sgefttype,msgstatus,msgamount,msgrecacct,msgrecinst 
	
	quit
	
CRETTX	// Mapping the TTX record with needed fields

	type public Number CID
	type public String CROFF,DROFF,ETC,GSUSPX,IN3,RESULT,TCMT

	type Date EFD
	
	set (DROFF,CROFF)=GSUSPX.get()
	if DROFF.isNull() set DROFF=CUVAR.glts 
	if CROFF.isNull() set CROFF=CUVAR.glts
	
	set EFD=%SystemDate
	set TCMT=TCMT.get()
	do TTXFILE
	
	if 'RESULT.get().isNull() set RESULT=$$^MSG(3125,RESULT.get(),ETC)
	else  set RESULT=$$^MSG(3126,ETC)
	
	set IN3=CID.get()
	kill TCMT
	
	quit
		 
	/*-----------------------------------------------------------------------
	  -----------------   Error handling routines	------------------------
	  -----------------------------------------------------------------------
	*/
RECERR(ABORT)	// Record Error 
	 
	/* Error numbers below 100 is errors without dependence of record type 
	   Errors from 100 to 999 is recordtype related errors wich never 
	   cause a complete abortion 
	*/
	
	type public Number ERR
	type public String TDRV
	
	type String ERRMSG
	
	set ABORT=ABORT.get() 
	 
	if ERR=11 set ERRMSG=$$^MSG(989,TDRV)
	if ERR=12 set ERRMSG=$$^MSG(2785,TDRV)
	 
	// Process error 
	if ABORT do ABORT^TPINERR
	else  if 'ERRMSG.get() set ERRMSG=$$^MSG(979,ERR) do ^TPINERR
	
	quit
	
BLDEFT(Number CID,Number RCID,Number TAMT,Number TYPE,String MSG1,String MSG2,String MSG3,String RJC) // Build EFTPAY record
	
	type public Boolean ER
	type public Number ORGCUS,SEQ
	type public String B10,B32,B51,B52,B6,B8,BRCD,G10,G11,G2,G3,G42,G43,G5,G8,G9,GBR,GL,GMSG,IN3
	type public String IN4,IN5,OCC,onus,recinst,RESEFT,RESTART,RM,TDRV,TYPES(),UTID
	
	type Number QUIT
	type String RESULT,EFTTYPE
	
	// add check, if onus inst, add inst branch code on front of RCID
	
	type RecordEFTPAY fEFTPAY=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ",1)
	set fEFTPAY.cid=RCID		
	set fEFTPAY.recinst=G42_G43	
	set fEFTPAY.efttype=GBR.get()	
	
	set recinst=fEFTPAY.recinst		                  
	type RecordUTBLEFTINST eftinst=Db.getRecord("UTBLEFTINST","KEY=:recinst",1)
	set onus=eftinst.onus           
	if (onus),((RCID.toString()).length()<12) set fEFTPAY.recacct=recinst.extract(5,8)_RCID 
	
	set fEFTPAY.amount=TAMT				//amount
	set fEFTPAY.crcd=G8				//crcd
	if G2.get()="094" set fEFTPAY.efd=B6.get()  	//
	else  set fEFTPAY.efd=G9		 	//efd
	set fEFTPAY.cc=OCC.get()		//cc
	set fEFTPAY.status="A"			//status - added
	set fEFTPAY.met="CC"			//met
	set fEFTPAY.procdt=G9			//procdt
	set fEFTPAY.amttyp=1			//amttyp
	set fEFTPAY.efttype=TYPE		//efttype
	set fEFTPAY.pri=""			//pri
	set fEFTPAY.brcd=BRCD.get()		//brcd
	set fEFTPAY.lnm=""			//lnm
	set fEFTPAY.ttype=1			//ttype
	if GL.get()=1 set fEFTPAY.ttype=2       //GL type
	
	if ('GL.get()),(onus) set fEFTPAY.ttype=0
	if ('GL.get()),('onus) set fEFTPAY.ttype=1
	if (GL.get()),(onus) set fEFTPAY.ttype=2
	if (GL.get()),('onus) set fEFTPAY.ttype=2
	
	set fEFTPAY.subcode=G3.get()		//sub code
	
	if TYPE="COVAL" do {
		set fEFTPAY.utilityid=UTID.get()	//Utility ID
		set fEFTPAY.custid=B8.get()		//customer id
		set fEFTPAY.recacct=B32.get()		//recipient id
		if ORGCUS=1 set fEFTPAY.eftsrcdd=2	
		else  set fEFTPAY.eftsrcdd=3	
		}
	
	if 'RJC.get().isNull() do {
		set fEFTPAY.status="PR"		//status - pending review
		set fEFTPAY.rejreas=RJC		//reject code/reason
		}
	
	set fEFTPAY.benname=B32.get()
	if (G10_G11)?2U set fEFTPAY.varndpo=G10_G11	// country code
	set fEFTPAY.subcid=B51.get()		//submitted (bene) account
	set fEFTPAY.subnam=B52.get()		//submitted name
	set fEFTPAY.origfile=TDRV.get()		//filename
	set fEFTPAY.origtrno=G5.get()		//orig trans number
	set fEFTPAY.origmtyp=G2.get()		//orig message type
	
	set fEFTPAY.msg1=MSG1		//eftmsg1
	set fEFTPAY.msg2=MSG2		//eftmsg2
	set fEFTPAY.msg3=MSG3		//eftmsg3
	if GMSG.get()="092" set fEFTPAY.msg4=B10.get()		//legal
	
	type ResultSet rs=Db.select("SEQ","EFTPAY","CID=:CID","SEQ DESC")
	if rs.next() set SEQ=rs.getCol("SEQ")+1
	set RESULT=$$^MSG(3127,TYPE)		//built EFTPAY record type TYPE
	
	set EFTTYPE=fEFTPAY.efttype
	
	// PAR RESTART
	set QUIT=0
	if RESTART.get()=1&(RESEFT.get()=0)&('G5.get().isNull()) do FINDEFT(CID,G5)
	if QUIT=1 quit
	set RESEFT=1
	
	// File to the database
	do fEFTPAY.save()
	
	if ER do { quit
		set RESULT=$$^MSG(3128,RM)	//error, no record created
		do EXC
		}
	
	set IN3=CID.get()
	set IN4=SEQ.get()
	set IN5=fEFTPAY.status
	
	quit
	
BLDETC(Number TYPE) // Returns miscellaneous ETC for payment type passed in
	
	type public String TYPES
	
	quit TYPES(TYPE).piece("|",23)
	
	
ETCGL(String TRN)	//
	//-----------------------------------------------------------------------
	// Returns default account from the tran code passed in
	//-----------------------------------------------------------------------
	
	type RecordTRN trn=Db.getRecord("TRN","ETC=:TRN")
	
	quit trn.acn
	
	
BLDTSO(String FCID,String RCID,String EFT,Number REFNO)	// Build TSO for transaction array
	
	type public String B31,B32,B7,B8,B9,G42,G43,G5,GMSG
	
	type String TSO,x()
	
	// Set up x array for TSO 	
	// PAR RESTART
	set x("ORIGTRNO")=G5.get()		// transaction number for restart
	set x("FCID")=FCID 
	set x("RCID")=RCID 
	set x("EFT")=EFT 
	set x("REFNO")=REFNO
	
	set x("RCID")=G42.get()_G43.get()_B31.get()
	set x("SNDR")=B32.get()
	set x("70-1")=B7.get()
	if GMSG.get()=007 set x("70-1")=B8.get()_B9.get()
	set x("70-2")=B8.get()
	set x("70-3")=B9.get()

	// place "x" array into source (TSO) field
	set TSO="" 
	do IN^UTSO(.x,.TSO) 
	kill x
	
	quit TSO

	/* Modified parameter list below to accept CUSTIDOPT and CUSTID
	   Needed for some calls to ^DEBAUT 
	*/
DEBCHK(String ATYP,Number ACN,Number CID,String INST,Number GL,Date EFD,Number AMOUNT,String CRCD,String CUSTIDOPT,String CUSTID)	//
	/*-----------------------------------------------------------------------
	  Debit Authorization check
	  -----------------------------------------------------------------------
	   An incoming collection order and/or direct debit may fail due to
	   lack of proper debit authorization in ^DEBAUT.  If so, and this is
	   flagged as a reason to manually review it, then generate an EFTPAY
	   record.
	  -----------------------------------------------------------------------
	*/
	
	quit $$AUT^DEBAUT(ATYP,ACN,CID,INST,GL,EFD,AMOUNT,CUSTIDOPT,CUSTID,CRCD,,,1)
	
KILLS	// Kill locals before read next record so no values are "laying around"
	
	type public Number CID,ACN
	
	type public String %A,A,B1,B10,B11,B12,B2,B3,B4,B5,B6,B7,B8,B9,BANK
	type public String fEFTPAY,G1,G10,G11,G12,G2,G3,G4,G5,G6,G7,G8,G9
	type public String GIRO,GL,GMSG,IN1,IN2,IN3,IN4,IN5,RESULT,RJC,TSO
	
	kill %A,A,ACN,B1,B10,B11,B12,B2,B3,B4,B5,B6,B7,B8,B9,BANK
	kill CID,G1,G10,G11,G12,G2,G3,G4,G5,G6,G7,G8,G9,GIRO,GL
	kill GMSG,IN1,IN2,IN3,IN4,IN5,RESULT,RJC
	
	quit
 
ERR(String S)	// ERROR - Internal error section 
 
	type public Boolean ER
	type public String ET
	
	set ER=1 
	if S.get() set S=S_"-" 
	set ET=S.get()_ET 
	do EXC 
	
	quit

REFGEN() // Generate reference number for outgoing messages

	type Number REFNO
	
	type RecordTRREF tref=Db.getRecord("TRREF","TYPE=5",1)
	set REFNO=(tref.refno).toNumber()+1
	set tref.refno=REFNO.toString()
	do tref.save()
	
	quit
	
ZEROS(String VAL,Number N) // Pad on left with zeroes 
	
	type public String X
	
	type Number I
	
	if VAL.length()>N quit VAL.extract(1,N)
	
	for I=1:1:N set X=X.get()_0
	
	quit X.extract(1,N-VAL.length())_VAL
	
SPACE(String VAL,Number N) // Pad on right with spaces 
	
	if VAL.length()>N quit VAL.extract(1,N)	
	
	quit VAL_$J(" ",N).extract(1,N-VAL.length())
	
NOSPC(String VAL) // Remove trailing spaces
	
	quit $$TRIM^%ZS(VAL)
	 
NOZRO(String VAL) // Remove leading zeroes
	 
	type String CHAR,I,NVAL 
	
	set NVAL="" 
	 
	for I=1:1:VAL.length() do { quit:CHAR'=0 
		set CHAR=VAL.extract(I) quit:CHAR'="0" 
		set NVAL=VAL.extract(I+1,VAL.length()) 
		}
	
	quit NVAL 

RCHAR(STR,S,F,NCHAR) // Replace char in string with replacement char
	
	type Number I
	type String NVAL,CHAR
	
	set NVAL=""
	
	for I=1:1:STR.length() do {
		set CHAR=STR.extract(I)
		if I<S set NVAL=NVAL_CHAR quit
		if I>F set NVAL=NVAL_CHAR quit
		set NVAL=NVAL_NCHAR
		}
	
	quit NVAL

EXC	// Log error into DAYEND 

	type public String %FN,%ZTSEQ,ET,FCID,G5,RESEXC,RESTART,RM
	
	type Number QUIT
	type String DESC

	type RecordSCATBL scatbl=Db.getRecord("SCATBL","FN=:%FN")
	set DESC=scatbl.desc
	if 'G5.get().isNull() set RM=RM.get()_"#"_G5
	set QUIT=0
	if RESTART.get()=1&(RESEXC.get()=0)&('G5.get().isNull()) do FINDEXC(G5)
	if QUIT=1 quit
	set RESEXC=1
	set ET=RM.get()
	do LOG^UTLEXC($T(+0),"*",DESC,FCID.get(),%ZTSEQ.get(),ET.get()) 
	kill ET,%ZTSEQ 
	
	quit

ENDX	// END execution - close outfile, archive it, and quit. 

	type public String FILE
	
	close FILE 
	 
	// copy file to archive directory then finish 
	do ARCH 
	
	quit
	
ARCH	// Copies the file to the archive directory 
	
	type public String X,FILE
	
	type String ARCHDIR
	
	set ARCHDIR=CUVAR.eftarcdir         //archive directory 
	if ARCHDIR.isNull() quit
	set X=$$COPYFIL^%OSSCRPT(FILE,ARCHDIR)
	
	quit
	 
	/*=======================================================================
	   Extrinsics
	  =======================================================================
	*/
ACCNV(String AC,String PRE) // Strip off 4 digit GIRO number and trailing spaces
	
	type public String CHX
	
	type Number LEN
	type Number X
	
	if PRE.get()="0" quit AC
	// remove trailing spaces
	set LEN=AC.length()
	for X=1:1:LEN do { quit:CHX=" "
		set CHX=AC.extract(X) quit:CHX=" "
		}
	set AC=AC.extract(1,X)
	
	quit +AC
	
AMCNV(String AM) // Strip off leading & trailing zeroes from amount field

	type public String CHX,DONE
	
	type Number LEN,X

	set DONE=0
	set LEN=AM.length()
	for X=1:1:LEN do { quit:DONE
		set CHX=AM.extract(X) if CHX'="0" set DONE=1	
		}
	set AM=AM.extract(X,AM.length()-2)
	
	quit AM

DTCNV(String DT) // Date conversion from YYYYMMDD to Julien format
	
	type Number DD,MM,YYYY
 
	set YYYY=DT.extract(1,4)
	set MM=DT.extract(5,6)
	set DD=DT.extract(7,8)
	set DT=MM_DD_YYYY
	set DT=$$DSJD^SCADAT(DT)
	
	quit DT
	
ACCCHK(Number CID,String NAME) // Check if this is a valid Profile account, if its open, etc. 
	
	type public Number ER
	type public String %CRCD
	
	if CID.isNull() quit "05"				//account missing
	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	if 'acn.getMode() quit "02"
	if acn.acn.isNull() quit "02"
	if acn.stat=4 quit "03" 		//account closed
	if 'CUVAR.resproc quit ""	
	if (acn.restyp=1),(acn.cnvtyp=0),(acn.crcd=%CRCD) quit "101"
	
	quit ""
	 
INSCHK(String INST) //
	/*-----------------------------------------------------------------------
	   Check if this is a valid institution in UTBLEFTINST - if not, quit
	   with error code 99 "other error", as no "invalid institution" error
	   code exists.
	  -----------------------------------------------------------------------
	*/
	
	type RecordUTBLEFTINST eftinst=Db.getRecord("UTBLEFTINST","KEY=:INST",1)
	
	if 'eftinst.getMode() quit ""
	
	quit "99"
	
GLOFF(String x) // Return clearing center G/L number for offset, based on priority
	
	type public String TYPES
	
	quit TYPES(x).piece("|",5)       // Incoming offset
	
GLOUT(String x) //
	 
	type public String TYPES
	
	quit TYPES(x).piece("|",6)	// Outgoing offset
	
AUT094(String ACNTYPE,Number ACN,String UTID,Date EFD,Number AMOUNT,String CRCD,Number CUSTIDOPT,String CUSTID,Boolean ER,String RM)	
	/* Debit Authorization for 094 transactions - Basically a copy
	   of AUT2^DEBAUT, but with CUSTID checks necessary for 094
	*/
	
	type String CONVERTED,DSEQ,RESP
	
	set DSEQ=""
	set RESP=0
	set CONVERTED=0
	
	type ResultSet rs=Db.select("SEQ","DEBAUT2","ACNTYPE=:ACNTYPE and ACN=:ACN and AUTUTID=:UTID","SEQ")
	while rs.next() do {
		set DSEQ=rs.getCol("SEQ")
		set RESP=$$CHECKS2^DEBAUT
		if RESP=1 quit
		}
		
	if RESP set ER=0,RM=""
	//No debit authorization
	else  if +ER.get()=0 do Runtime.setErrMSG("DEBAUT2",1925)
	
	quit RESP
	
FINDEFT(Number CID,Number TRNO)	//
	/* PAR - RESTART build a cross reference of EFTPAY records sorted by 
	   account number and the GIRO transaction number. If the record exists,
	   don't file a new one.
	*/
	
	type public Number QUIT
	type public String EFTXREF
	type String ORIGTRNO,XCID
	
	if EFTXREF.get() do {
		type ResultSet rs=Db.select("CID,ORIGTRNO","EFTPAY","EFD=:EFD")
		while rs.next() do {
			set XCID=rs.getCol("CID")
			set ORIGTRNO=rs.getCol("ORIGTRNO")
			if ORIGTRNO.isNull() quit
			set EFTXREF(XCID,ORIGTRNO)=""
			}
		}
	
	if EFTXREF(CID,TRNO).get() set QUIT=1
	
	quit
	
FINDEXC(Number TRNO) //

	/* PAR - RESTART build a cross reference of EXC records sorted by the 
	   GIRO transaction number, for the current date. If the record exists, 
	   don't file a new one.
	*/
	
	type public String EXCXREF,XREC
	
	type String ORIGTRNO
	type Number QUIT
	
	if 'EXCXREF.get() do {
		type ResultSet rs=Db.select("MISC","DAYENDEXC","TJD=:EFD and RTN='EFTGIRO2' and SORT='*'","SEQ")
		if rs.next() do {
			set XREC=rs.getCol("MISC")
			set ORIGTRNO=XREC.piece("#",2)
			if ORIGTRNO.isNull() quit
			set EXCXREF(ORIGTRNO)=""
			}
		}
	
	if EXCXREF(TRNO).exists() set QUIT=1
	
	quit

FINDOUT	/* PAR - RESTART build a cross reference of EFTOUT and EFTCUS records 
	   sorted by the GIRO transaction number. 
	*/

	type public Date EFD
	type public String B32,ORGCUS,OUTXREC,OUTTSO,OUTXREF()
	
	type Number QUIT,SEQ
	
	if 'OUTXREC.get() do {
		if ORGCUS.get()=0 do {
			set SEQ=""
			type ResultSet rs=Db.select("TJD,TSEQ,TSO","EFTOUT","TJD=:EFD","TSEQ")
			while rs.next() do {
				
				type String OUTTSO
				
				set SEQ=rs.getCol("TSEQ")
				do OUT^UTSO(.OUTTSO,rs.getCol("TSO"))
				if OUTTSO("ORIGTRNO").get().isNull() quit
				set OUTXREF(OUTTSO("ORIGTRNO"))=""
				}
			}
		if ORGCUS.get()=1 do {
			set SEQ=""
			type ResultSet rs1=Db.select("SJD,TSEQ,TSO","EFTCUS","SJD=:EFD","TSEQ")
			while rs1.next() do {
				
				type String OUTTSO
				
				set SEQ=rs1.getCol("TSEQ")
				do OUT^UTSO(.OUTTSO,rs1.getCol("TSO"))
				if OUTTSO("ORIGTRNO").get().isNull() quit
				set OUTXREF(OUTTSO("ORIGTRNO"))=""
				}
			}
		}
	
	if OUTXREF(B32.get()).data() set QUIT=1
	
	quit
	
%STOPLOD // Stop %ZRTNLOD from this point on down 

	do BCHINIT
	
	quit
	
BCHINIT	// Dummy line reference for GT.M 

	do BCHEND
	
	quit
	
BCHEND	// Dummy line reference for GT.M 

	do TTXFILE
	
	quit
	
TTXFILE	// Dummy line reference for GT.M 

	do %UID
	
	quit
	
%UID	// Dummy line reference for GT.M  
	
	quit
	
END	//

	do END
	
	quit
	
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60304^17390^Balasubramonian Sankar^54426"	// Signature - LTD^TIME^USER^SIZE
