public ZUCTBTS()	// PSL Test Set, class ByteString, all methods
	/*
	ORIG: Frans S.C. Witte - 2006-08-16
	DESC: PSL Test Set, class ByteString

	Module that tests the behaviour of the ByteString class.

	All functions use the following character sequence (using HTML escapes
	to indicate the non-ASCII characters:
	- Kn&auml;ckebr&ouml;d
	- &0u0132;sbrand

	With
	. &auml;   = $C(228) and UTF-8 representation $ZC(195,164)
	. &ouml;   = $C(246) and UTF-8 representation $ZC(195,182)
	. &0u0132; = $C(306) and UTF-8 representation $ZC(196,178)

	To validate the code generated for compile time constants however, only
	pure ASCII literals can be used, because constants with $C() will not be
	recognized as such by the compiler.
	
	---- Revision History --------------------------------------------------
	2006-08-29, Frans S.C. Witte - CR 22843
		Implemented validations for all ByteString methods

	2006-09-21, Frans S.C. Witte - CR 22843
		added $$toAscii() to produce concatenation of .ascii() values to
		validate the output, and modified all validatoins to call it to
		display ByteString occurrences.
	*/
	#ACCEPT CR=22843; DATE=2006-08-29; PGM=Frans S.C. Witte;GROUP=XECUTE
	xecute "zprint"

	write !,"Validate ByteString method calls",!
	do ascii()	// method ByteString.ascii(Number)
	do extr()	// method ByteString.extract(Number,Number)
	do find()	// method ByteString.find(ByteString,Number)
	do just()	// method ByteString.justify(Number)
	do length()	// method ByteString.length(ByteString)
	do piece()	// method ByteString.piece(ByteString,Number,Number)
	do toPSL()	// method ByteString.toPSLExpression()
	do trans()	// method ByteString.translate(ByteString,ByteString)
	quit

	// #####################################################################
	// Test functions ByteString.ascii(Number)
	// #####################################################################

	// =====================================================================
public ascii()	// Validate ByteString.ascii(Number)
	/* ---------------------------------------------------------------------
	Procedure that validates code relating to ByteString.ascii().
	Validation values (see ZUCT for meaning of Cn and Rn):
	C0/R0: "", "Kn"_$C(228)_"ckebr"_$C(246)_"d", $C(306)_"sbrand"
	C1/R1: absent, "", 3, 10
	calls:
	* public ascii()		// test ByteString.ascii( Number P1)
	* public ascii0()		// test C0.ascii(C1)
	* public ascii1(R0)		// test R0.ascii(C1
	* public ascii2(R1)		// test C0.ascii(R1)
	* public ascii3(R0,R1)		// test R0.ascii(R1)

	NOTES:
	. For Runtime.charset="M":
		- "Kn"_$C(228)_"ckebr"_$C(246)_"d".ascii(3) shall return 228
			(i.e. the umlaut character)
		- "Kn"_$C(228)_"ckebr"_$C(246)_"d".ascii(10) shall return the
			ascii value of "d" (10th character)
		- $C(306) maps into "", thus the .ascii(3) method will return
			$A("r"), and .ascii() shall return $A("s")
	. For Runtime.charset = "UTF-8":
		- "Kn"_$C(228)_"ckebr"_$C(246)_"d".ascii(3) shall return 192
		- "Kn"_$C(228)_"ckebr"_$C(246)_"d".ascii(10) shall return 182
		- "$C(306)_"sbrand".acii(3) shall return $A("s"), and .ascii()
			shall return 196.
	*/
	type ByteString R0
	type Number R1

	do ascii0()
	for R0 = "".toByteString(), ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), ($C(306)_"sbrand").toByteString() do {
		do ascii1( R0)
		for R1 = "", 3, 10 do {
			if R0.isNull() do ascii2(R1)
			do ascii3(R0,R1)
		}
	}
	quit

	// =====================================================================
public toAscii( ByteString r)	//
	/* ---------------------------------------------------------------------
	Support function that writes the argument using bytstring.ascii()
	The byte values are separated by '/'
	*/
	type Number b
	type String s = r.ascii()
	for b=2:1:r.length() set s = s_ "/"_ r.ascii( b)
	quit s

	// =====================================================================
public ascii0()
	// validate C0.ascii(C1)
	//
	// This subroutine also contains the code to check whether the compiler
	// correctly interprets a literal String as ByteString: The first three
	// test cases with Runtime.charsetName = "UTF-8" shall all generate
	// $ZASCII(). If the literal incorrectly ends up as String, then the
	// generated code will contain $ASCII().
	// Testing this case here prevents compile time errors if the compiler
	// incorrectly treats the literal as a String, because String and
	// ByteString both have a .ascii() method.
	//
	type Number rRes

	set rRes = "".toByteString().ascii()	// C0="".toByteString(), C1 absent
	write "ascii0().EA:"""".toByteString().ascii()="_rRes,!

	set rRes = ("").toByteString().ascii()	// C0=("").toByteString(), C1 absent
	write "ascii0().EA:("""").toByteString().ascii()="_rRes,!

	set rRes = ("".toByteString()).ascii()	// C0=("".toByteString()), C1 absent
	write "ascii0().EA:("""".toByteString()).ascii()="_rRes,!



	set rRes = ("".toByteString()).ascii("")	// C0="", C1=""
	write "ascii0().EE:"""".ascii("""")="_rRes,!

	set rRes = ("".toByteString()).ascii(3)		// C0="", C1=3
	write "ascii0().EV:"""".ascii(3)="_rRes,!



	set rRes = ("Knaeckebroed").toByteString().ascii()	// C0="Knaeckebroed", C1 absent
	write "ascii0().VA:""Knaeckebroed"".ascii()="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().ascii("")	// C0="Knaeckebroed", C1=""
	write "ascii0().VE:""Knaeckebroed"".ascii("""")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().ascii(3)	// C0="Knaeckebroed", C1=3
	write "ascii0().VV:""Knaeckebroed"".ascii(3)="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().ascii(15)	// C0="Knaeckebroed", C1=15
	write "ascii0().VW:""Knaeckebroed"".ascii(15)="_rRes,!
	quit

	// =====================================================================
public ascii1( ByteString R0)
	// validate R0.ascii(C1) -- 3 combinations
	//
	type Number rRes

	set rRes = R0.ascii()			// C1 absent
	write "ascii1(R0).A:<"_$$toAscii(R0)_">.ascii()="_rRes,!

	set rRes = R0.ascii("")			// C1=""
	write "ascii1(R0).E:<"_$$toAscii(R0)_">.ascii("""")="_rRes,!

	set rRes = R0.ascii(3)			// C1=3
	write "ascii1(R0).V:<"_$$toAscii(R0)_">.ascii(3)="_rRes,!
	quit


	// =====================================================================
public ascii2( Number R1)
	// =====================================================================
	// validate C0.ascii(R1) -- 2 combinations
	//
	type Number rRes

	set rRes = ("".toByteString()).ascii( R1)	// C0=""
	write "ascii2(R1).E:"""".ascii(<"_R1_">)="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().ascii( R1)	// C0="Knaeckebroed"
	write "ascii2(R1).V:""Knaeckebroed"".ascii(<"_R1_">)="_rRes,!
	quit

	// =====================================================================
public ascii3( ByteString R0, Number R1)
	// =====================================================================
	// validate R0.ascii(R1) -- 1 "combination"
	//
	type Number rRes

	set rRes = R0.ascii( R1)
	write "ascii3(R0,R1):<"_$$toAscii(R0)_">.ascii(<"_R1_">)="_rRes,!
	quit

	// #####################################################################
	// Test functions ByteString.extract(Number,Number)
	// #####################################################################

	// =====================================================================
public extr()	// Validate ByteString.extr(Number,Number)
	/* ---------------------------------------------------------------------
	Procedure that validates code relating to ByteString.extract().
	Validation values (see ZUCT for meaning of Cn and Rn):
	C0/R0: "", "Kn"_$C(228)_"ckebr"_$C(246)_"d", $C(306)_"sbrand"
	C1/R1: absent, "", 3, 10
	C2/R2: absent, "", 11, 5
	calls:
	* public extr()			// test ByteString.extract( Number P1, Number P2)
	* public extr0()		// test C0.extract(C1,C2)
	* public extr1(R0)		// test R0.extract(C1,C2)
	* public extr2(R1)		// test C0.extract(R1,C2)
	* public extr3(R2)		// test C0.extract(C1,R2)
	* public extr4(R0,R1)		// test R0.extract(R1,C2)
	* public extr5(R0,R2)		// test R0.extract(C1,R2)
	* public extr6(R1,R2)		// test C0.extract(R1,R2)
	* public extr7(R0,R1,R2)	// test R0.extract(R1,R2)
	*/
	type ByteString R0
	type Number R1
	type Number R2

	do extr0()
	for R0 = "".toByteString(), ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), ($C(306)_"sbrand").toByteString() do {
		do extr1( R0)
		for R1 = "", 3, 10 do {
			if R0.isNull() do extr2(R1)
			do extr4(R0,R1)
			for R2 = "", 11, 5 do {
				if R0.isNull(),R1.isNull() do extr3(R2)
				if R1.isNull() do extr5(R0,R2)
				if R0.isNull() do extr6(R1,R2)
				do extr7(R0,R1,R2)
			}
		}
	}
	quit

	// =====================================================================
public extr0()
	// validate C0.extract(C1,C2)
	//
	type ByteString rRes

	set rRes = ("".toByteString()).extract()	// C0="", C1 absent, C2 absent
	write "extr0().EAA:"""".extract()="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).extract(,"")	// C0="", C1 absent, C2=""
	write "extr0().EAE:"""".extract(,"""")="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).extract(,5)	// C0="",  C1 absent, C2=5
	write "extr0().EAV:"""".extract(,5)="_$$toAscii(rRes),!



	set rRes = ("".toByteString()).extract("")	// C0="", C1="", C2 absent
	write "extr0().EEA:"""".extract("""")="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).extract("","")	// C0="", C1="", C2=""
	write "extr0().EEE:"""".extract("""","""")="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).extract("",5)	// C0="", C1="", C2=5
	write "extr0().EEV:"""".extract("""",5)="_$$toAscii(rRes),!



	set rRes = ("".toByteString()).extract(3)	// C0="", C1=3, C2 absent
	write "extr0().EVA:"""".extract(3)="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).extract(3,"")	// C0="", C1=3, C2=""
	write "extr0().EVE:"""".extract(3,"""")="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).extract(3,11)	// C0="", C1=3, C2=11
	write "extr0().EVV:"""".extract(3,11)="_$$toAscii(rRes),!



	set rRes = ("Knaeckebroed").toByteString().extract()	// C0="Knaeckebroed", C1 absent, C2 absent
	write "extr0().VAA:""Knaeckebroed"".extract()="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract(,"")	// C0="Knaeckebroed", C1 absent, C2=""
	write "extr0().VAE:""Knaeckebroed"".extract(,"""")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract(,5)	// C0="Knaeckebroed", C1 absent, C2=5
	write "extr0().VAV:""Knaeckebroed"".extract(,5)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract(,20)	//C0="Knaeckebroed",  C1 absent, C2=20
	write "extr0().VAW:""Knaeckebroed"".extract(,20)="_$$toAscii(rRes),!



	set rRes = ("Knaeckebroed").toByteString().extract("")		// C0="Knaeckebroed", C1="", C2 absent
	write "extr0().VEA:""Knaeckebroed"".extract("""")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract("","")	// C0="Knaeckebroed", C1="", C2=""
	write "extr0().VEE:""Knaeckebroed"".extract("""","""")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract("",11)	// C0="Knaeckebroed", C1="", C2=11
	write "extr0().VEV:""Knaeckebroed"".extract("""",11)="_$$toAscii(rRes),!



	set rRes = ("Knaeckebroed").toByteString().extract(3)		// C0="Knaeckebroed", C1=3, C2 absent
	write "extr0().VVA:""Knaeckebroed"".extract(3)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract(3,"")	// C0="Knaeckebroed", C1=3, C2=""
	write "extr0().VVE:""Knaeckebroed"".extract(3,"""")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract(3,11)	// C0="Knaeckebroed", C1=3, C2=11
	write "extr0().VVV:""Knaeckebroed"".extract(3,11)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract(10,5)	// C0="Knaeckebroed", C1=10, C2=5
	write "extr0().VWW:""Knaeckebroed"".extract(10,5)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public extr1( ByteString R0)
	// validate R0.extract(C1,C2) -- 4 * 4 = 16 combinations
	//
	type ByteString rRes

	set rRes = R0.extract()			// C1 absent, C2 absent
	write "extr1(R0).AA:<"_$$toAscii(R0)_">.extract()="_$$toAscii(rRes),!

	set rRes = R0.extract(,"")	// C1 absent, C2=""
	write "extr1(R0).AE:<"_$$toAscii(R0)_">.extract(,"""")="_$$toAscii(rRes),!

	set rRes = R0.extract(,5)	// C1 absent, C2=5
	write "extr1(R0).AW:<"_$$toAscii(R0)_">.extract(,5)="_$$toAscii(rRes),!



	set rRes = R0.extract("")			// C1="", C2 absent
	write "extr1(R0).EA:<"_$$toAscii(R0)_">.extract("""")="_$$toAscii(rRes),!

	set rRes = R0.extract("","")	// C1="", C2=""
	write "extr1(R0).EE:<"_$$toAscii(R0)_">.extract("""","""")="_$$toAscii(rRes),!

	set rRes = R0.extract("",11)	// C1="", C2=11
	write "extr1(R0).EV:<"_$$toAscii(R0)_">.extract("""",11)="_$$toAscii(rRes),!



	set rRes = R0.extract(3)			// C1=3, C2 absent
	write "extr1(R0).VA:<"_$$toAscii(R0)_">.extract(3)="_$$toAscii(rRes),!

	set rRes = R0.extract(3,"")	// C1=3, C2=""
	write "extr1(R0).VE:<"_$$toAscii(R0)_">.extract(3,"""")="_$$toAscii(rRes),!

	set rRes = R0.extract(3,11)	// C1=3, C2=11
	write "extr1(R0).VV:<"_$$toAscii(R0)_">.extract(3,11)="_$$toAscii(rRes),!

	set rRes = R0.extract(10,5)	// C1=10, C2=5
	write "extr1(R0).WW:<"_$$toAscii(R0)_">.extract(10,5)="_$$toAscii(rRes),!
	quit


	// =====================================================================
public extr2( Number R1)
	// =====================================================================
	// validate C0.extract(R1,C2)
	//
	type ByteString rRes

	set rRes = ("".toByteString()).extract( R1)	// C0="", C2 absent
	write "extr2(R1).EA:"""".extract(<"_R1_">)="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).extract( R1, "")	// C0="", C2=""
	write "extr2(R1).EE:"""".extract(<"_R1_">,"""")="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).extract( R1, 5)	// C0="", C2=5
	write "extr2(R1).EV:"""".extract(<"_R1_">,5)="_$$toAscii(rRes),!



	set rRes = ("Knaeckebroed").toByteString().extract( R1)	// C0="Knaeckebroed", C2 absent
	write "extr2(R1).VA:""Knaeckebroed"".extract(<"_R1_">)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract( R1, "")	// C0="Knaeckebroed", C2=""
	write "extr2(R1).VE:""Knaeckebroed"".extract(<"_R1_">,"""")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract( R1, 5)	// C0="Knaeckebroed", C2=5
	write "extr2(R1).VW:""Knaeckebroed"".extract(<"_R1_">,5)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public extr3( Number R2)
	// =====================================================================
	// validate C0.extract(C1,R2) -- 3 *4 = 12 combinations
	//
	type ByteString rRes

	set rRes = ("".toByteString()).extract( , R2)	// C0="", C1 absent
	write "extr3(R2).EA:"""".extract(,<"_R2_">)="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).extract("", R2)	// C0="", C1=""
	write "extr3(R2).EE:"""".extract("""",<"_R2_">)="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).extract( 3, R2)	// C0="", C1=3
	write "extr3(R2).EV:"""".extract(3,<"_R2_">)="_$$toAscii(rRes),!


	set rRes = ("Knaeckebroed").toByteString().extract( , R2)	// C0="Knaeckebroed", C1 absent
	write "extr3(R2).VA:""Knaeckebroed"".extract(,<"_R2_">)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract( "", R2)	// C0="Knaeckebroed", C1=""
	write "extr3(R2).VE:""Knaeckebroed"".extract("""",<"_R2_">)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract( 3, R2)	// C0="Knaeckebroed", C1=3
	write "extr3(R2).VV:""Knaeckebroed"".extract(3,<"_R2_">)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract( 15, R2)	// C0="Knaeckebroed", C1=15
	write "extr3(R2).VW:""Knaeckebroed"".extract(15,<"_R2_">)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public extr4( ByteString R0, Number R1)
	// =====================================================================
	// validate R0.extract(R1,C2)
	//
	type ByteString rRes

	set rRes = R0.extract( R1)	// C2 absent
	write "extr4(R0,R1).A:<"_$$toAscii(R0)_">.extract(<"_R1_">)="_$$toAscii(rRes),!

	set rRes = R0.extract( R1, "")	// C2=""
	write "extr4(R1,R2).E:<"_$$toAscii(R0)_">.extract(<"_R1_">,"""")="_$$toAscii(rRes),!

	set rRes = R0.extract( R1, 5)	// C2=5
	write "extr4(R1,R2).W:<"_$$toAscii(R0)_">.extract(<"_R1_">,5)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public extr5( ByteString R0, Number R2)
	// =====================================================================
	// validate R0.extract(C1,R2)
	//
	type ByteString rRes

	set rRes = R0.extract( , R2)	//  C1 absent
	write "extr5(R0,R2).A:<"_$$toAscii(R0)_">.extract(,<"_R2_">)="_$$toAscii(rRes),!

	set rRes = R0.extract( "", R2)	// C1=""
	write "extr5(R0,R2).E:<"_$$toAscii(R0)_">.extract("""",<"_R2_">)="_$$toAscii(rRes),!

	set rRes = R0.extract( 8, R2)	// C1=8
	write "extr5(R0,R2).V:<"_$$toAscii(R0)_">.extract(8,<"_R2_">)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public extr6( Number R1, Number R2)
	// =====================================================================
	// validate C0.extr(R1,R2) -- 3 combinations
	//
	type ByteString rRes

	set rRes = ("".toByteString()).extract( R1, R2)			// C0=""
	write "extr6(R1,R2).E:"""".extract(<"_R1_">,<"_R2_">)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().extract( R1, R2)	// C0="Knaeckebroed"
	write "extr6(R1,R2).V:""Knaeckebroed"".extract(<"_R1_">,<"_R2_">)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public extr7( ByteString R0, Number R1, Number R2)
	// =====================================================================
	// validate R0.mtd4p(R1,R2) -- 1 "combination"
	//
	type ByteString rRes

	set rRes = R0.extract( R1, R2)
	write "extr7(R0,R1,R2):<"_$$toAscii(R0)_">.extract(<"_R1_">,<"_R2_">)="_$$toAscii(rRes),!
	quit

	// #####################################################################
	// Test functions ByteString.find(ByteString,Number)
	// #####################################################################

	// =====================================================================
public find()	// Validate ByteString.find(ByteString,Number)
	/* ---------------------------------------------------------------------
	Procedure that validates code relating to ByteString.find().
	Validation values (see ZUCT for meaning of Cn and Rn):
	C0/R0: "", "Kn"_$C(228)_"ckebr"_$C(246)_"d", $C(306)_"sbrand"
	C1/R1: "", 228.byte(), 178.byte()
	C2/R2: absent, "", 2, 7
	calls:
	* public find()		// test ByteString.find( ByteString. P1, ByteString P2)
	* public find0()		// test C0.find(C1,C2)
	* public find1(R0)		// test R0.find(C1,C2)
	* public find2(R1)		// test C0.find(R1,C2)
	* public find3(R2)		// test C0.find(C1,R2)
	* public find4(R0,R1)		// test R0.find(R1,C2)
	* public find5(R0,R2)		// test R0.find(C1,R2)
	* public find6(R1,R2)		// test C0.find(R1,R2)
	* public find7(R0,R1,R2)	// test R0.find(R1,R2)

	NOTES:
	. The current implementation of ByteString.find() either calls the
		equivalent String method or calls psl2m(1,2) to generate the
		M code directly from the arguments. Because psl2m does not allow
		missing arguments other than at the end, there is need to
		include patterns that have missing arguments "in the middle".
		Furthermore psl2m(1,2) implies that an absent first argument is
		not allowed.
	*/
	type ByteString R0
	type ByteString R1
	type Number R2

	do find0()
	for R0 = "".toByteString(), ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), ($C(306)_"sbrand").toByteString() do {
		do find1( R0)
		for R1 = "", 228.byte(), 178.byte() do {
			if R0.isNull() do find2(R1)
			do find4(R0,R1)
			for R2 = "", 2, 7 do {
				if R0.isNull(),R1.isNull() do find3(R2)
				if R1.isNull() do find5(R0,R2)
				if R0.isNull() do find6(R1,R2)
				do find7(R0,R1,R2)
			}
		}
	}
	quit

	// =====================================================================
public find0()
	// validate C0.find(C1,C2)
	//
	type Number rRes

	set rRes = ("".toByteString()).find("")	// C0="", C1="", C2 absent
	write "find0().EEA:"""".find("""")="_rRes,!

	set rRes = ("".toByteString()).find("","")	// C0="", C1="", C2=""
	write "find0().EEE:"""".find("""","""")="_rRes,!

	set rRes = ("".toByteString()).find("",2)	// C0="", C1="", C2=2
	write "find0().EEV:"""".find("""",2)="_rRes,!



	set rRes = ("Knaeckebroed").toByteString().find("")	// C0="Knaeckebroed", C1="", C2 absent
	write "find0().VEA:""Knaeckebroed"".find("""")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find("","")	// C0="Knaeckebroed", C1="", C2=""
	write "find0().VEE:""Knaeckebroed"".find("""","""")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find("",2)	// C0="Knaeckebroed", C1="", C2=2
	write "find0().VEV:""Knaeckebroed"".find("""",2)="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find("",15)	// C0="Knaeckebroed", C1="", C2=15
	write "find0().VEW:""Knaeckebroed"".find("""",15)="_rRes,!



	set rRes = ("Knaeckebroed").toByteString().find("e")	// C0="Knaeckebroed", C1="e", C2 absent
	write "find0().VVA:""Knaeckebroed"".find(""e"")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find("e","")	// C0="Knaeckebroed", C1="e", C2=""
	write "find0().VVE:""Knaeckebroed"".find(""e"","""")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find("e",2)	// C0="Knaeckebroed", C1="e", C2=2
	write "find0().VVV:""Knaeckebroed"".find(""e"",2)="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find("e",7)	// C0="Knaeckebroed", C1="e", C2=7
	write "find0().VVW:""Knaeckebroed"".find(""e"",7)="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find("e",20)	// C0="Knaeckebroed", C1="e", C2=20
	write "find0().VVW:""Knaeckebroed"".find(""e"",20)="_rRes,!
	quit

	// =====================================================================
public find1( ByteString R0)
	// validate R0.find(C1,C2)
	//
	type Number rRes

	set rRes = R0.find("")		// C1="", C2 absent
	write "find1(R0).EA:<"_$$toAscii(R0)_">.find("""")="_rRes,!

	set rRes = R0.find("","")	// C1="", C2=""
	write "find1(R0).EE:<"_$$toAscii(R0)_">.find("""","""")="_rRes,!

	set rRes = R0.find("",2)	// C1="", C2=2
	write "find1(R0).EV:<"_$$toAscii(R0)_">.find("""",2)="_rRes,!



	set rRes = R0.find("e")		// C1="e", C2 absent
	write "find1(R0).VA:<"_$$toAscii(R0)_">.find(""e"")="_rRes,!

	set rRes = R0.find("e","")	// C1="e", C2=""
	write "find1(R0).VE:<"_$$toAscii(R0)_">.find(""e"","""")="_rRes,!

	set rRes = R0.find("e",5)	// C1="e", C2=5
	write "find1(R0).VV:<"_$$toAscii(R0)_">.find(""e"",2)="_rRes,!

	set rRes = R0.find("e",7)	// C1="e", C2=7
	write "find1(R0).VW:<"_$$toAscii(R0)_">.find(""e"",7)="_rRes,!
	quit


	// =====================================================================
public find2( ByteString R1)
	// =====================================================================
	// validate C0.find(R1,C2) -- 3 * 4 = 12 combinations
	//
	type Number rRes

	set rRes = ("".toByteString()).find( R1)	// C0="", C2 absent
	write "find2(R1).EA:"""".find(<"_$$toAscii(R1)_">)="_rRes,!

	set rRes = ("".toByteString()).find( R1, "")	// C0="", C2=""
	write "find2(R1).EE:"""".find(<"_$$toAscii(R1)_">,"""")="_rRes,!

	set rRes = ("".toByteString()).find( R1, 2)	// C0="", C2=2
	write "find2(R1).EV:"""".find(<"_$$toAscii(R1)_">,2)="_rRes,!

	set rRes = ("".toByteString()).find( R1, 7)	// C0="", C2=7
	write "find2(R1).EW:"""".find(<"_$$toAscii(R1)_">,7)="_rRes,!



	set rRes = ("Knaeckebroed").toByteString().find( R1)	// C0="Knaeckebroed", C2 absent
	write "find2(R1).VA:""Knaeckebroed"".find(<"_$$toAscii(R1)_">)="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find( R1, "")	// C0="Knaeckebroed", C2=""
	write "find2(R1).VE:""Knaeckebroed"".find(<"_$$toAscii(R1)_">,"""")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find( R1, 3)	// C0="Knaeckebroed", C2=3
	write "find2(R1).VV:""Knaeckebroed"".find(<"_$$toAscii(R1)_">,3)="_rRes,!
	quit

	// =====================================================================
public find3( Number R2)
	// =====================================================================
	// validate C0.find(C1,R2)
	//
	type Number rRes

	set rRes = ("".toByteString()).find("", R2)			// C0="", C1=""
	write "find3(R2).EE:"""".find("""",<"_R2_">)="_rRes,!

	set rRes = ("".toByteString()).find( "e", R2)	// C0="", C1="e"
	write "find3(R2).EV:"""".find(""e"",<"_R2_">)="_rRes,!



	set rRes = ("Knaeckebroed").toByteString().find( "", R2)	// C0="Knaeckebroed", C1=""
	write "find3(R2).VE:""Knaeckebroed"".find("""",<"_R2_">)="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find( "e", R2)	// C0="Knaeckebroed", C1="e"
	write "find3(R2).VV:""Knaeckebroed"".find(""e"",<"_R2_">)="_rRes,!
	quit

	// =====================================================================
public find4( ByteString R0, ByteString R1)
	// =====================================================================
	// validate R0.find(R1,C2)
	//
	type Number rRes

	set rRes = R0.find( R1)	// C2 absent
	write "find4(R0,R1).A:<"_$$toAscii(R0)_">.find(<"_$$toAscii(R1)_">)="_rRes,!

	set rRes = R0.find( R1, "")	// C2=""
	write "find4(R0,R1).E:<"_$$toAscii(R0)_">.find(<"_$$toAscii(R1)_">,"""")="_rRes,!

	set rRes = R0.find( R1, 7)	// C2=7
	write "find4(R0,R1).W:<"_$$toAscii(R0)_">.find(<"_$$toAscii(R1)_">,7)="_rRes,!
	quit

	// =====================================================================
public find5( ByteString R0, Number R2)
	// =====================================================================
	// validate R0.find(C1,R2) -- 3 combinations
	//
	type Number rRes

	set rRes = R0.find( "", R2)	// C1=""
	write "find5(R0,R2).E:<"_$$toAscii(R0)_">.find("""",<"_R2_">)="_rRes,!

	set rRes = R0.find( "e", R2)	// C1="e"
	write "find5(R0,R2).V:<"_$$toAscii(R0)_">.find(""e"",<"_R2_">)="_rRes,!
	quit

	// =====================================================================
public find6( ByteString R1, Number R2)
	// =====================================================================
	// validate C0.find(R1,R2) -- 3 combinations
	//
	type Number rRes

	set rRes = ("".toByteString()).find( R1, R2)	// C0=""
	write "find6(R1,R2).E:"""".find(<"_$$toAscii(R1)_">,<"_R2_">)="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().find( R1, R2)	// C0="Knaeckebroed"
	write "find6(R1,R2).V:""Knaeckebroed"".find(<"_$$toAscii(R1)_">,<"_R2_">)="_rRes,!
	quit

	// =====================================================================
public find7( ByteString R0, ByteString R1, Number R2)
	// =====================================================================
	// validate R0.find(R1,R2) -- 1 "combination"
	//
	type Number rRes

	set rRes = R0.find( R1, R2)
	write "find7(R0,R1,R2):<"_$$toAscii(R0)_">.find(<"_$$toAscii(R1)_">,<"_R2_">)="_rRes,!
	quit

	// #####################################################################
	// Test functions ByteString.justify(Number)
	// #####################################################################

	// =====================================================================
public just()	// Validate ByteString.justify(Number)
	/* ---------------------------------------------------------------------
	Procedure that validates code relating to ByteString.justify().
	Validation values (see ZUCT for meaning of Cn and Rn):
	C0/R0: "", "Kn"_$C(228)_"ckebr"_$C(246)_"d", $C(306)_"sbrand"
	C1/R1: "", 15, 7
	calls:
	* public just()		// test ByteString.justify( ByteString. P1)
	* public just0()		// test C0.justify(C1)
	* public just1(R0)		// test R0.justify(C1
	* public just2(R1)		// test C0.justify(R1)
	* public just3(R0,R1)		// test R0.justify(R1)
	*/
	type ByteString R0
	type Number R1

	do just0()
	for R0 = "".toByteString(), ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), ($C(306)_"sbrand").toByteString() do {
		do just1( R0)
		for R1 = "", 15, 7 do {
			if R0.isNull() do just2(R1)
			do just3(R0,R1)
		}
	}
	quit

	// =====================================================================
public just0()
	// validate C0.justify(C1)
	//
	type ByteString rRes

	set rRes = ("".toByteString()).justify()	// C0="", C1 absent
	write "just0().EA:"""".justify()="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).justify("")	// C0="", C1=""
	write "just0().EE:"""".justify("""")="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).justify(15)	// C0="", C1=15
	write "just0().EV:"""".justify(15)="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).justify(7)	// C0="", C1=7
	write "just0().EW:"""".justify(7)="_$$toAscii(rRes),!



	set rRes = ("Knaeckebroed").toByteString().justify()	// C0="Knaeckebroed", C1 absent
	write "just0().VE:""Knaeckebroed"".justify()="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().justify("")	// C0="Knaeckebroed", C1=""
	write "just0().VE:""Knaeckebroed"".justify("""")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().justify(15)	// C0="Knaeckebroed", C1=15
	write "just0().VV:""Knaeckebroed"".justify(15)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().justify(7)	// C0="Knaeckebroed", C1=7
	write "just0().VW:""Knaeckebroed"".justify(7)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public just1( ByteString R0)
	// validate R0.justify(C1)
	//
	type ByteString rRes

	set rRes = R0.justify()			// C1 absent
	write "just1(R0).E:<"_$$toAscii(R0)_">.justify()="_$$toAscii(rRes),!

	set rRes = R0.justify("")		// C1=""
	write "just1(R0).E:<"_$$toAscii(R0)_">.justify("""")="_$$toAscii(rRes),!

	set rRes = R0.justify(15)		// C1=15
	write "just1(R0).V:<"_$$toAscii(R0)_">.justify(15)="_$$toAscii(rRes),!

	set rRes = R0.justify(7)		// C1=7
	write "just1(R0).W:<"_$$toAscii(R0)_">.justify(7)="_$$toAscii(rRes),!
	quit


	// =====================================================================
public just2( Number R1)
	// =====================================================================
	// validate C0.justify(R1)
	//
	type ByteString rRes

	set rRes = ("".toByteString()).justify( R1)	// C0=""
	write "just2(R1).E:"""".justify(<"_R1_">)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().justify( R1)	// C0="Knaeckebroed"
	write "just2(R1).V:""Knaeckebroed"".justify(<"_R1_">)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public just3( ByteString R0, Number R1)
	// =====================================================================
	// validate R0.justify(R1) -- 1 "combination"
	//
	type ByteString rRes

	set rRes = R0.justify( R1)
	write "just3(R0,R1):<"_$$toAscii(R0)_">.justify(<"_R1_">)="_$$toAscii(rRes),!
	quit

	// #####################################################################
	// Test functions ByteString.length(Number)
	// #####################################################################

	// =====================================================================
public length()	// Validate ByteString.length(ByteString)
	/* ---------------------------------------------------------------------
	Procedure that validates code relating to ByteString.length().
	Validation values (see ZUCT for meaning of Cn and Rn):
	C0/R0: "", "Kn"_$C(228)_"ckebr"_$C(246)_"d", $C(306)_"sbrand"
	C1/R1: absent, "", 195.byte(), 178.byte()
	calls:
	* public length()		// test ByteString.length( ByteString P1)
	* public length0()		// test C0.length(C1)
	* public length1(R0)		// test R0.length(C1
	* public length2(R1)		// test C0.length(R1)
	* public length3(R0,R1)		// test R0.length(R1)
	*/
	type ByteString R0
	type ByteString R1

	do length0()
	for R0 = "".toByteString(), ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), ($C(306)_"sbrand").toByteString() do {
		do length1( R0)
		for R1 = "", 195.byte(), 178.byte() do {
			if R0.isNull() do length2(R1)
			do length3(R0,R1)
		}
	}
	
	// some additional test cases:
	do length3( "Kn"_$C(228)_"ckebr"_$C(246)_"d", 228.char())
	do length3( "Kn"_$C(228)_"ckebr"_$C(246)_"d", 228.byte())
	do length3( "Kn"_$C(228)_"ckebr"_$C(246)_"d", 228.char()_"c")
	do length3( "Kn"_$C(228)_"ckebr"_$C(246)_"d", 228.byte()_"c")

	do length3( $C(306)_"sbrand", 306.char())
	do length3( $C(306)_"sbrand", 306.char()_"s")
	quit

	// =====================================================================
public length0()
	// validate C0.length(C1)
	//
	type Number rRes

	set rRes = ("".toByteString()).length()			// C0="", C1 absent
	write "length0().EA:"""".length()="_rRes,!

	set rRes = ("".toByteString()).length("")		// C0="", C1=""
	write "length0().EE:"""".length("""")="_rRes,!

	set rRes = ("".toByteString()).length("e")		// C0="", C1="e"
	write "length0().EV:"""".length(""e"")="_rRes,!



	set rRes = ("Knaeckebroed").toByteString().length()	// C0="Knaeckebroed", C1 absent
	write "length0().VA:""Knaeckebroed"".length()="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().length("")	// C0="Knaeckebroed", C1=""
	write "length0().VE:""Knaeckebroed"".length("""")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().length("e")	// C0="Knaeckebroed", C1="e"
	write "length0().VV:""Knaeckebroed"".length(""e"")="_rRes,!
	quit

	// =====================================================================
public length1( ByteString R0)
	// validate R0.length(C1)
	//
	type Number rRes

	set rRes = R0.length()					// C1 absent
	write "length1(R0).A:<"_$$toAscii(R0)_">.length()="_rRes,!

	set rRes = R0.length("")				// C1=""
	write "length1(R0).E:<"_$$toAscii(R0)_">.length("""")="_rRes,!

	set rRes = R0.length("e")				// C1="e"
	write "length1(R0).V:<"_$$toAscii(R0)_">.length(""e"")="_rRes,!
	quit


	// =====================================================================
public length2( ByteString R1)
	// =====================================================================
	// validate C0.length(R1)
	//
	type Number rRes

	set rRes = ("".toByteString()).length( R1)	// C0=""
	write "length2(R1).E:"""".length(<"_$$toAscii(R1)_">)="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().length( R1)	// C0="Knaeckebroed"
	write "length2(R1).V:""Knaeckebroed"".length(<"_$$toAscii(R1)_">)="_rRes,!
	quit

	// =====================================================================
public length3( ByteString R0, Number R1)
	// =====================================================================
	// validate R0.length(R1) -- 1 "combination"
	//
	type Number rRes

	set rRes = R0.length( R1)
	write "length3(R0,R1):<"_$$toAscii(R0)_">.length(<"_$$toAscii(R1)_">)="_rRes,!
	quit

	// #####################################################################
	// Test functions ByteString.piece(ByteString,Number,Number)
	// #####################################################################

	// =====================================================================
public piece()	// Validate ByteString.piece(ByteString,Number,Number)
	/* ---------------------------------------------------------------------
	Procedure that validates code relating to ByteString.piece().
	Validation values (see ZUCT for meaning of Cn and Rn):
	C0/R0: "", ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString()
	C1/R1: "", 228.char(), 195.byte()
	C2/R2: absent, "", 2
	C3/R3: absent, "", 3
	calls:
	* public piece00()		// validate C0.piece(C1,C2,C3)
	* public piece01(R0)		// validate R0.piece(C1,C2,C3)
	* public piece02(R1)		// validate C0.piece(R1,C2,C3)
	* public piece03(R2)		// validate C0.piece(C1,R2,C3)
	* public piece04(R3)		// validate C0.piece(C1,C2,R3)
	* public piece05(R0,R1)		// validate R0.piece(R1,C2,C3)
	* public piece06(R0,R2)		// validate R0.piece(C1,R2,C3)
	* public piece07(R0,R3)		// validate R0.piece(C1,C2,R3)
	* public piece08(R1,R2)		// validate C0.piece(R1,R2,C3)
	* public piece09(R1,R3)		// validate C0.piece(R1,C2,R3)
	* public piece10(R2,R3)		// validate C0.piece(C1,R2,R3)
	* public piece11(R0,R1,R2)	// validate R0.piece(R1,R2,C3)
	* public piece12(R0,R1,R3)	// validate R0.piece(R1,C2,R3)
	* public piece13(R0,R2,R3)	// validate R0.piece(C1,R2,R3)
	* public piece14(R1,R2,R3)	// validate C0.piece(R1,R2,R3)
	* public piece15(R0,R1,R2,R3)	// validate R0.piece(R1,R2,R3)

	NOTES:
	. The current implementation of ByteString.piece() either calls the
		equivalent String method or calls psl2m(1,3) to generate the
		M code directly from the arguments. Because psl2m does not allow
		missing arguments other than at the end, there is need to
		include patterns that have missing arguments "in the middle".
		Furthermore psl2m(1,3) implies that an absent first argument is
		not allowed.
	*/
	type ByteString R0
	type ByteString R1
	type Number R2
	type Number R3

	do piece00()
	for R0 = "", "Kn"_$C(228)_"ckebr"_$C(246)_"d" do {
		do piece01( R0)
		for R1 = "", 228.char(), 195.byte() do {
			if R0.isNull() do piece02(R1)
			do piece05(R0,R1)
			for R2 = "", 2 do {
				if R0.isNull(),R1.isNull() do piece03(R2)
				if R1.isNull() do piece06(R0,R2)
				if R0.isNull() do piece08(R1,R2)
				do piece11(R0,R1,R2)
				for R3 = "", 3 do {
					if R0.isNull(),R1.isNull(),R2.isNull() do piece04(R3)
					if R1.isNull(),R2.isNull() do piece07(R0,R3)
					if R0.isNull(),R2.isNull() do piece09(R1,R3)
					if R0.isNull(),R1.isNull() do piece10(R2,R3)
					if R2.isNull() do piece12(R0,R1,R3)
					if R1.isNull() do piece13(R0,R2,R3)
					if R0.isNull() do piece14(R1,R2,R3)
					do piece15(R0,R1,R2,R3)
				}
			}
		}
	}
	quit

	// =====================================================================
public piece00()
	// =====================================================================
	// validate ({ByteString}C0).piece(C1,C2,C3)
	//
	//
	type ByteString rRes

	set rRes = ("").toByteString().piece( "")			// C0="", C1="", C2 absent, C3 absent
	write "piece00().EEAA:"""".piece("""","""")="_rRes,!

	set rRes = ("").toByteString().piece( "", "")			// C0="", C1="", C2="", C3 absent
	write "piece00().EEEA:"""".piece("""","""")="_rRes,!

	set rRes = ("").toByteString().piece( "", "", "")		// C0="", C1="", C2="", C3=""
	write "piece00().EEEE:"""".piece("""","""")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().piece( "e")		// C0="Knaeckebroed", C1="e", C2 absent, C3 absent
	write "piece00().VVAA:""Knaeckebroed"".piece(""e"")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().piece( "e", "")	// C0="Knaeckebroed", C1="e", C2="", C3 absent
	write "piece00().VVEA:""Knaeckebroed"".piece(""e"","""")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().piece( "e", "", "")	// C0="Knaeckebroed", C1="e", C2="", C3=""
	write "piece00().VVEE:""Knaeckebroed"".piece(""e"","""","""")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().piece( "e", 2)	// C0="Knaeckebroed", C1="e", C2=2, C3 absent
	write "piece00().VVVA:""Knaeckebroed"".piece(""e"",2)="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().piece( "e", 2, "")	// C0="Knaeckebroed", C1="e", C2=2, C3=""
	write "piece00().VVVE:""Knaeckebroed"".piece(""e"",2,"""")="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().piece( "e", 2, 3)	// C0="Knaeckebroed", C1="e", C2=2, C3=3
	write "piece00().VVVV:""Knaeckebroed"".piece(""e"",2,3)="_rRes,!
	quit

	// =====================================================================
public piece01( ByteString R0)
	// validate R0.piece(C1,C2,C3)
	//
	type ByteString rRes
  
	set rRes = R0.piece( "")		// C1="", C2 absent, C3 absent
	write "piece01(R0).EAA:<"_$$toAscii(R0)_">.piece("""")="_$$toAscii(rRes),!
  
	set rRes = R0.piece( "", "")		// C1="", C2="", C3 absent
	write "piece01(R0).EEA:<"_$$toAscii(R0)_">.piece("""","""")="_$$toAscii(rRes),!
  
	set rRes = R0.piece( "", "", "")	// C1="", C2="", C3=""
	write "piece01(R0).EEE:<"_$$toAscii(R0)_">.piece("""","""","""")="_$$toAscii(rRes),!
  
	set rRes = R0.piece( "e")		// C1="e", C2 absent, C3 absent
	write "piece01(R0).VAA:<"_$$toAscii(R0)_">.piece(""e"")="_$$toAscii(rRes),!
  
	set rRes = R0.piece( "e", "")		// C1="e", C2="", C3 absent
	write "piece01(R0).VEA:<"_$$toAscii(R0)_">.piece(""e"","""")="_$$toAscii(rRes),!
  
	set rRes = R0.piece( "e", "", "")	// C1="e", C2="", C3=""
	write "piece01(R0).VEE:<"_$$toAscii(R0)_">.piece(""e"","""","""")="_$$toAscii(rRes),!
  
	set rRes = R0.piece("e", 2)	// C1="e", C2=2, C3 absent
	write "piece01(R0).VVA:<"_$$toAscii(R0)_">.piece(""e"",2)="_$$toAscii(rRes),!
  
	set rRes = R0.piece("e", 2, "")	// C1="e", C2=2, C3=""
	write "piece01(R0).VVE:<"_$$toAscii(R0)_">.piece(""e"",2,"""")="_$$toAscii(rRes),!

	set rRes = R0.piece("e", 2, 3)	// C1="e", C2=2, C3=3
	write "piece01(R0).VVV:<"_$$toAscii(R0)_">.piece(""e"",2,3)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public piece02( ByteString R1)
	// =====================================================================
	// validate C0.piece(R1,C2,C3)
	//
	type ByteString rRes

	set rRes = ("Knaeckebroed").toByteString().piece( R1, 2, 3)	// C0="Knaeckebroed", C2=2, C3=3
	write "piece02().VVV:""Knaeckebroed"".piece(<"_$$toAscii(R1)_">,2,3)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().piece( R1, 3, 2)	// C0="Knaeckebroed", C2=3, C3=2
	write "piece02().VVV:""Knaeckebroed"".piece(<"_$$toAscii(R1)_">,3,2)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public piece03( Number R2)
	// =====================================================================
	// validate C0.piece(C1,R2,C3)
	//
	type ByteString rRes

	set rRes = ("Knaeckebroed").toByteString().piece( "e", R2, 3)	// C0="Knaeckebroed", C1="e", C3=3
	write "piece03().VVV:""Knaeckebroed"".piece(""e"",<"_R2_">,3)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public piece04( Number R3)
	// =====================================================================
	// validate C0.piece(C1,C2,R3)
	//
	type ByteString rRes

	set rRes = ("Knaeckebroed").toByteString().piece( "e", 2, R3)	// C0="Knaeckebroed", C1="e", C2=2
	write "piece04().VVV:""Knaeckebroed"".piece(""e"",2,<"_R3_">)="_$$toAscii(rRes),!
	quit

	// ====================================================================
public piece05( ByteString R0, ByteString R1)
	// ====================================================================
	// validate R0.piece(R1,C2,C3)
	//
	type ByteString rRes

	set rRes = R0.piece( R1)		// C2 absent, C3 absent
	write "piece05().VV:<"_$$toAscii(R0)_">.piece(<"_$$toAscii(R1)_">)="_$$toAscii(rRes),!

	set rRes = R0.piece( R1, "")		// C2="", C3 absent
	write "piece05().VV:<"_$$toAscii(R0)_">.piece(<"_$$toAscii(R1)_">,"""")="_$$toAscii(rRes),!

	set rRes = R0.piece( R1, "", "")	// C2="", C3=""
	write "piece05().VV:<"_$$toAscii(R0)_">.piece(<"_$$toAscii(R1)_">,"""","""")="_$$toAscii(rRes),!

	set rRes = R0.piece( R1, 2)	// C2=2, C3 absent
	write "piece05().VV:<"_$$toAscii(R0)_">.piece(<"_$$toAscii(R1)_">,2)="_$$toAscii(rRes),!

	set rRes = R0.piece( R1, 2, "")	// C2=2, C3=""
	write "piece05().VV:<"_$$toAscii(R0)_">.piece(<"_$$toAscii(R1)_">,2,"""")="_$$toAscii(rRes),!

	set rRes = R0.piece( R1, 2, 3)	// C2=2, C3=3
	write "piece05().VV:<"_$$toAscii(R0)_">.piece(<"_$$toAscii(R1)_">,2,3)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public piece06( ByteString R0, Number R2)
	// =====================================================================
	// validate R0.piece(C1,R2,C3)
	//
	// combinations with C3 absent are tested in piece11()
	//
	quit

	// =====================================================================
public piece07( ByteString R0, Number R3)
	// =====================================================================
	// validate R0.piece(C1,C2,R3)
	//
	// no new testcases will be introduced by the combination C1,C2.
	//
	quit

	// =====================================================================
public piece08( ByteString R1, Number R2)
	// =====================================================================
	// validate C0.piece(R1,R2,C3)
	//
	// combinations with C3 absent are tested in piece11()
	//
	quit

	// =====================================================================
public piece09( ByteString R1, Number R3)
	// =====================================================================
	// validate C0.piece(R1,C2,R3)
	//
	// no new testcases will be introduced by the combination C1,C2.
	//
	quit

	// =====================================================================
public piece10( Number R2, Number R3)
	// =====================================================================
	// validate C0.piece(C1,R2,R3)
	//
	// no new testcases will be introduced by the combination C1,C2.
	//
	quit

	// =====================================================================
public piece11( ByteString R0, ByteString R1, Number R2)
	// =====================================================================
	// validate R0.piece(R1,R2,C3)
	//
	// the only combination that cannot be tested otherwise is C3 absent
	//
	type ByteString rRes

	set rRes = R0.piece( R1, R2)		// C3 absent
	write "piece11(R0,R1,R2).V:<"_$$toAscii(R0)_">.piece(<"_$$toAscii(R1)_">,<"_R2_">,3)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public piece12( ByteString R0, ByteString R1, Number R3)
	// =====================================================================
	// validate R0.piece(R1,C2,R3)
	//
	// no new testcases will be introduced by C2
	//
	quit

	// =====================================================================
public piece13( ByteString R0, Number R2, Number R3)
	// =====================================================================
	// validate R0.piece(C1,R2,R3)
	//
	// no new testcases will be introduced by C1.
	//
	quit

	// =====================================================================
public piece14( ByteString R1, Number R2, Number R3)
	// =====================================================================
	// validate C0.piece(R1,R2,R3)
	//
	// no new testcases will be introduced by C0.
	//
	quit

	// =====================================================================
public piece15( ByteString R0, ByteString R1, Number R2, Number R3)
	// =====================================================================
	// validate R0.piece(R1,R2,R3) -- 1 "combination"
	//
	type ByteString rRes

	set rRes = R0.piece( R1, R2, R3)
	write "piece15(R0,R1,R2,R3):<"_$$toAscii(R0)_">.piece(<"_$$toAscii(R1)_">,<"_R2_">,<"_R3_">)="_$$toAscii(rRes),!
	quit

	// #####################################################################
	// Test functions ByteString.toPSLExpression()
	// #####################################################################

	// =====================================================================
public toPSL()	// Validate ByteString.toPSLExpression()
	/* ---------------------------------------------------------------------
	Procedure that validates code relating to ByteString.toPSLExpression().
	Validation values (see ZUCT for meaning of Cn and Rn):
	C0/R0: "", "Kn"_$C(228)_"ckebr"_$C(246)_"d", $C(306)_"sbrand"
	calls:
	* public toPSLEx()		// test ByteString.toPSLExpression()
	* public toPSLEx0()		// test C0.toPSLExpression()
	* public toPSLEx1(R0)		// test R0.toPSLExpression()
	*/
	type ByteString R0

	do toPSL0()
	for R0 = "".toByteString(), ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), ($C(306)_"sbrand").toByteString() do {
		do toPSL1( R0)
	}
	do toPSL1( "ABCD"_9.char()_"efgh"_13.char()_10.char()_"ijkl")
	quit

	// =====================================================================
public toPSL0()
	// validate C0.toPSLExpression() -- 3 combinations
	//
	type PSLExpression rRes
	set rRes = ("".toByteString()).toPSLExpression()	// C0=""
	write "toPSL0().E:"""".toPSLExpression()="_rRes,!

	set rRes = ("Knaeckebroed").toByteString().toPSLExpression()	// C0="Knaeckebroed"
	write "toPSL0().V:""Knaeckebroed"".toPSLExpression()="_rRes,!
	quit

	// =====================================================================
public toPSL1( ByteString R0)
	// validate R0.toPSLExpression() -- 1 "combination"
	//
	type PSLExpression rRes

	set rRes = R0.toPSLExpression()
	write "toPSL1(R0):<"_$$toAscii(R0)_">.toPSLExpression()="_rRes,!
	quit

	// #####################################################################
	// Test functions ByteString.translate(ByteString,ByteString)
	// #####################################################################

	// =====================================================================
public trans()	// Validate ByteString.translate(ByteString,ByteString)
	/* ---------------------------------------------------------------------
	Procedure that validates code relating to ByteString.translate().
	Validation values (see ZUCT for meaning of Cn and Rn):
	C0/R0: "", ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), ($C(306)_"sbrand").toByteString()
	C1/R1: "", "r", "J"
	C2/R2: absent, "", "R", "j"
	calls:
	* public trans()		// test ByteString.translate( ByteString P1, ByteString P2)
	* public trans0()		// test C0.translate(C1,C2)
	* public trans1(R0)		// test R0.translate(C1,C2) (see NOTES)
	* public trans2(R1)		// test C0.translate(R1,C2) (see NOTES)
	* public trans3(R2)		// test C0.translate(C1,R2)
	* public trans4(R0,R1)		// test R0.translate(R1,C2) (see NOTES)
	* public trans5(R0,R2)		// test R0.translate(C1,R2) (see NOTES)
	* public trans6(R1,R2)		// test C0.translate(R1,R2) (see NOTES)
	* public trans7(R0,R1,R2)	// test R0.translate(R1,R2)

	NOTES:
	. The compiler can hardly optimize the .translate() method. Only the
		following cases are optimizable:
		- C0.translate(C1,C2): Could be resolved at compile time
		- C0.translate(C1,R2): If C0.translate(C1) = C0, then the result
			will always be C0, regardless of the value of C2/R2. A
			clever compiler could detect this.
		Even for these patterns, there is a limited number of meaningful
		combinations: The compiler relies on the call to the underlying
		M function to produce the result.
	. Similarly, combining arbitrary P0, P1 and P2 values is useless:
		If R0/C0 has no bytes in common with R1/C1, then the result will
		be R0/C0. This makes a number of the test cases largely
		irrelevant:
		- R0.translate(C1,C2): Only relevant if R0 shares characters
			with C0. Provides no additional test cases.
		- C0.translate(R1,C2): Only relevant if C0 shares characters
			with R1. Provides no additional test cases.
		- R0.translate(R1,C2): Only relevant if R0 shares characters
			with R1. It will only be used for the following cases:
			- C2 absent
			- C2 empty
		- R0.translate(C1,R2): Only relevant if R0 shares characters
			with C1. Provides no additional test cases.
		- C0.translate(R1,R2): Only relevant if C0 shares characters
			with R1. Provides no additional test cases.
		The irrelevant cases are transformed into no-ops (label + quit).
	. To validate the cases C2 absent and C2 empty, test code is inserted
		directly into this procedure.
	. Even for target languages other than M the remaining test functions
		should be sufficient.
	*/
	type ByteString R0
	type ByteString R1
	type ByteString R2

	do trans0()
	for R0 = "".toByteString(), ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), ($C(306)_"sbrand").toByteString() do {
		for R1 = "", "r", "J" do {
			for R2 = "", "R", "j" do {
				if R0.isNull(),R1.isNull() do trans3(R2)
				do trans7(R0,R1,R2)
			}
		}
	}
	// Only combinations with "Kn"_$C(228)_"ckebr"_$C(246)_"d"
	do trans7( ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), 228.char().toByteString(), {ByteString}"a")
	do trans7( ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), 228.byte(), {ByteString}"a")

	// The following example will work for M, and seems to work for UTF-8,
	// but the second and third example demonstrate what really happens for UTF-8.
	do trans7( ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), 228.char().toByteString(), 246.char().toByteString())
	do trans7( ("Kn"_$C(164)_"ckebr"_$C(246)_"d").toByteString(), 228.char().toByteString(), 246.char().toByteString())
	do trans7( ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), 228.char().toByteString(), 306.char().toByteString())

	do trans7( ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), 195.byte(), 196.byte())

	// C2 absent and C2=""
	do trans4( ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), 228.char().toByteString())
	do trans4( ("Kn"_$C(228)_"ckebr"_$C(246)_"d").toByteString(), 195.byte())

	quit

	// =====================================================================
public trans0()
	// validate C0.translate(C1,C2) -- limited number of testcases
	//
	/* NOTES:
	. The current version of the compiler does not consider 228.char() a
		literal value. This further limits the number of testcases to
		either ASCII only cases or cases that are not portable across
		different CharacterSet environments.
	. Because the sole purpose of this subroutine is to validate possibly
		optimized code, the restriction to ASCII only provides
		sufficient indication of the correctness of the compiler
	*/
	type ByteString rRes

	set rRes = ("".toByteString()).translate("")	// C0="", C1="", C2 absent
	write "trans0().EEA:"""".translate("""")="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).translate("","")	// C0="", C1="", C2=""
	write "trans0().EEE:"""".translate("""","""")="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).translate("","R")	// C0="", C1="", C2="R"
	write "trans0().EEV:"""".translate("""",""R"")="_$$toAscii(rRes),!



	set rRes = ("".toByteString()).translate("r")	// C0="", C1="r", C2 absent
	write "trans0().EVA:"""".translate(""r"")="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).translate("r","")	// C0="", C1="r", C2=""
	write "trans0().EVE:"""".translate(""r"","""")="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).translate("r","R")	// C0="", C1="r", C2="R"
	write "trans0().EVV:"""".translate(""r"",""R"")="_$$toAscii(rRes),!



	set rRes = ("Knaeckebroed").toByteString().translate("")	// C0=("Knaeckebroed").toByteString(), C1="", C2 absent
	write "trans0().VEA""Knaeckebroed"".translate("""")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate("","")	// C0=("Knaeckebroed").toByteString(), C1="", C2=""
	write "trans0().VEE""Knaeckebroed"".translate("""","""")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate("","R")	// C0=("Knaeckebroed").toByteString(), C1="", C2="R"
	write "trans0().VEV""Knaeckebroed"".translate("""",""R"")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate("","j")	// C0=("Knaeckebroed").toByteString(), C1="", C2="j"
	write "trans0().VEW""Knaeckebroed"".translate("""",""j"")="_$$toAscii(rRes),!



	set rRes = ("Knaeckebroed").toByteString().translate("r")	// C0=("Knaeckebroed").toByteString(), C1="r", C2 absent
	write "trans0().VVA""Knaeckebroed"".translate(""r"")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate("r","")	// C0=("Knaeckebroed").toByteString(), C1="r", C2=""
	write "trans0().VVE""Knaeckebroed"".translate(""r"","""")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate("r","R")	// C0=("Knaeckebroed").toByteString(), C1="r", C2="R"
	write "trans0().VVV""Knaeckebroed"".translate(""r"",""R"")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate("r","j")	// C0=("Knaeckebroed").toByteString(), C1="r", C2="j"
	write "trans0().VVW""Knaeckebroed"".translate(""r"",""j"")="_$$toAscii(rRes),!



	set rRes = ("Knaeckebroed").toByteString().translate("J")	// C0=("Knaeckebroed").toByteString(), C1="J", C2 absent
	write "trans0().VWA""Knaeckebroed"".translate(""J"")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate("J","")	// C0=("Knaeckebroed").toByteString(), C1="J", C2=""
	write "trans0().VWE""Knaeckebroed"".translate(""J"","""")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate("J","R")	// C0=("Knaeckebroed").toByteString(), C1="J", C2="R"
	write "trans0().VWV""Knaeckebroed"".translate(""J"",""R"")="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate("J","j")	// C0=("Knaeckebroed").toByteString(), C1="J", C2="j"
	write "trans0().VWW""Knaeckebroed"".translate(""J"",""j"")="_$$toAscii(rRes),!



	set rRes ="IJsbrand".toByteString().translate("")	// C0=($C(306)_"sbrand").toByteString(), C1="", C2 absent
	write "trans0().WEA:""IJsbrand"".translate("""")="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate("","")	// C0=($C(306)_"sbrand").toByteString(), C1="", C2=""
	write "trans0().WEE:""IJsbrand"".translate("""","""")="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate("","R")	// C0=($C(306)_"sbrand").toByteString(), C1="", C2="R"
	write "trans0().WEV:""IJsbrand"".translate("""",""R"")="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate("","j")	// C0=($C(306)_"sbrand").toByteString(), C1="", C2="j"
	write "trans0().WEW:""IJsbrand"".translate("""",""j"")="_$$toAscii(rRes),!



	set rRes ="IJsbrand".toByteString().translate("r")	// C0=($C(306)_"sbrand").toByteString(), C1="r", C2 absent
	write "trans0().WVA:""IJsbrand"".translate(""r"")="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate("r","")	// C0=($C(306)_"sbrand").toByteString(), C1="r", C2=""
	write "trans0().WVE:""IJsbrand"".translate(""r"","""")="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate("r","R")	// C0=($C(306)_"sbrand").toByteString(), C1="r", C2="R"
	write "trans0().WVV:""IJsbrand"".translate(""r"",""R"")="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate("r","j")	// C0=($C(306)_"sbrand").toByteString(), C1="r", C2="j"
	write "trans0().WVW:""IJsbrand"".translate(""r"",""j"")="_$$toAscii(rRes),!



	set rRes ="IJsbrand".toByteString().translate("J")	// C0=($C(306)_"sbrand").toByteString(), C1="J", C2 absent
	write "trans0().WWA:""IJsbrand"".translate(""J"")="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate("J","")	// C0=($C(306)_"sbrand").toByteString(), C1="J", C2=""
	write "trans0().WWE:""IJsbrand"".translate(""J"","""")="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate("J","R")	// C0=($C(306)_"sbrand").toByteString(), C1="J", C2="R"
	write "trans0().WWV:""IJsbrand"".translate(""J"",""R"")="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate("J","j")	// C0=($C(306)_"sbrand").toByteString(), C1="J", C2="j"
	write "trans0().WWW:""IJsbrand"".translate(""J"",""j"")="_$$toAscii(rRes),!
	quit

	// =====================================================================
public trans1( ByteString R0)
	// validate R0.translate(C1,C2) -- no-op, see NOTES for trans()
	//
	quit


	// =====================================================================
public trans2( ByteString R1)
	// =====================================================================
	// validate C0.translate(R1,C2) -- no-op, see NOTES for trans()
	//
	quit

	// =====================================================================
public trans3( ByteString R2)
	// =====================================================================
	// validate C0.translate(C1,R2) -- 3 * 3 = 9 combinations
	//
	type ByteString rRes

	set rRes = ("".toByteString()).translate("", R2)	// C0="", C1=""
	write "trans3(R2).EE:"""".translate("""",<"_$$toAscii(R2)_">)="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).translate( R2, "r")	// C0="", C1="r"
	write "trans3(R2).EV:"""".translate(""r"",<"_$$toAscii(R2)_">)="_$$toAscii(rRes),!

	set rRes = ("".toByteString()).translate( R2, "J")	// C0="", C1="J"
	write "trans3(R2).EW:"""".translate(""J"",<"_$$toAscii(R2)_">)="_$$toAscii(rRes),!



	set rRes = ("Knaeckebroed").toByteString().translate( "", R2)	// C0=("Knaeckebroed").toByteString(), C1=""
	write "trans3(R2).VE:""Knaeckebroed"".translate("""",<"_$$toAscii(R2)_">)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate( "r", R2)	// C0=("Knaeckebroed").toByteString(), C1="r"
	write "trans3(R2).VV:""Knaeckebroed"".translate(""r"",<"_$$toAscii(R2)_">)="_$$toAscii(rRes),!

	set rRes = ("Knaeckebroed").toByteString().translate( "J", R2)	// C0=("Knaeckebroed").toByteString(), C1="J"
	write "trans3(R2).VW:""Knaeckebroed"".translate(""J"",<"_$$toAscii(R2)_">)="_$$toAscii(rRes),!



	set rRes ="IJsbrand".toByteString().translate( "", R2)	// C0=($C(306)_"sbrand").toByteString(), C1=""
	write "trans3(R2).WE:""IJsbrand"".translate("""",<"_$$toAscii(R2)_">)="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate( "r", R2)	// C0=($C(306)_"sbrand").toByteString(), C1="r"
	write "trans3(R2).WV:""IJsbrand"".translate(""r"",<"_$$toAscii(R2)_">)="_$$toAscii(rRes),!

	set rRes ="IJsbrand".toByteString().translate( "J",  R2)	// C0=($C(306)_"sbrand").toByteString(), C1="J"
	write "trans3(R2).WW:""IJsbrand"".translate(""J"",<"_$$toAscii(R2)_">)="_$$toAscii(rRes),!
	quit

	// =====================================================================
public trans4( ByteString R0, ByteString R1)
	// =====================================================================
	// validate R0.translate(R1,C2) -- only C2 absent and C2=""
	//
	type ByteString rRes

	set rRes = R0.translate( R1)	// C2 absent
	write "trans4(R0,R1).A:<"_$$toAscii(R0)_">.translate(<"_$$toAscii(R1)_">)="_$$toAscii(rRes),!

	set rRes = R0.translate( R1, "")	// C2=""
	write "trans4(R0,R1).E:<"_$$toAscii(R0)_">.translate(<"_$$toAscii(R1)_">,"""")="_$$toAscii(rRes),!
	quit

	// =====================================================================
public trans5( ByteString R0, ByteString R2)
	// =====================================================================
	// validate R0.translate(C1,R2) -- no-op, see NOTES for trans()
	//
	quit

	// =====================================================================
public trans6( ByteString R1, ByteString R2)
	// =====================================================================
	// validate C0.translate(R1,R2) -- no-op, see NOTES for trans()
	//
	quit

	// =====================================================================
public trans7( ByteString R0, ByteString R1, ByteString R2)
	// =====================================================================
	// validate R0.translate(R1,R2) -- 1 "combination"
	//
	type ByteString rRes

	set rRes = R0.translate( R1, R2)
	write "trans7(R0,R1,R2):<"_$$toAscii(R0)_">.translate(<"_$$toAscii(R1)_">,<"_$$toAscii(R2)_">)="_$$toAscii(rRes),!
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60529^64279^Frans S.C. Witte^60524"	// Signature - LTD^TIME^USER^SIZE
