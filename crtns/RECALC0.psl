private	RECALC0(RecordDEP dep,		// Deposit account		/REF:RW
		RecordTTX prittx)	// Primary transaction		/REF:RW

	/*
	ORIG: Vitaliy Antonov - 5/8/2002
        DESC: File accrual/interest adjustments
        PROCEDURE ID: RECALC0
        
	Called by ^RECALC to adjust interest accrued and paid with the
	appropriate G/L offsets.

	Inputs:
		. MASSCHG - Mass change (int index, int matrix or tax index)
		. ADJACR - Total positive interest accrued adjustment
		. ADJAWT - Total accrued withholding tax adjustment
		. ADJINT - Total positive interest posted adjustment
		. NEGADJ - Total negative interest accrued adjustment
		. NEGPST - Total negative interest posted adjustment
		. NEGUNA - Total negative interest unauthorized
		. ADJRES - Total residual interest posted (no prin) adjustment
		. RATE	 - Interest rate
		. RESPST - Total residual interest posted (principal) adjustment
		. ADJUNC - Total uncollected interest accrued adjustment
		. UNCPST - Total uncollected interest posted adjustment
		. ADJBWA - Total backup withholding paid
		. DEFINADJ - Defer posting interest adjust
		. %TRNHSEQ - Primary transaction history sequence number

	. RATECHG()  Array that contains interest rate changes on effective 
		dates. This array is populated by RECALC.

		pieces:
		1. Old rate value
		2. New rate value
		3. hist.tso (Transaction Source of Funds) field value. It also 
		   contains primary transaction history number for reference.
		4. Rate change date (Effective Date).
		
		example:
		RATECHG(CID,DINAME,SEQ)=OLDRATE|NEWRATE|TSO|EFD

	---- Revision History ------------------------------------------------
	
	04/10/07 - SmithCD - CR 24945
		   Modified the updating of TAMT for NTAX to update principal, 
		   and to flip the sign of NTAX, if applicable, in NEGINT and 
		   POSINT sections.
	
	03/26/07 - Natrajah/Chaithra - CR 24945
		   Modified INTADJ, NEGINT and POSINT sections to adjust TAMT 
		   with NTAX.		  
	
	07/19/06 - DESHPANDE S K - CR 20748
		   Replaced Transaction Variable with Transaction Stored Value.
		   	
	07/06/06 - SWARNALP - CR 21774
		   Modified EXPENSE and INCOME sections to include a line 
		   which rounds the transaction amount to two decimal places 
		   as DIAD and IIAD transactions Offsets transaction amount 
		   more than 2 decimals which is incorrect.
		   
	05/03/06 - SmithCD - CR 21007
		   Replaced saving of hist record in RATECHG section with call 
		   to HISTBLD^ACNFUNCS so DTJFM journal gets updated, as in 
		   prior versions (^RECALCFS relies on DTJFM records).
	
	04/05/06 - SANTHUMS - CR 20436
		   Added SPV(Supervisory array) parameter while calling 
		   TRNSINGL^TRNDRV in CRT section since value of SPV was 
		   getting lost and hence system generated restrictions were
		   not appearing.
		   
	03/24/06 - SmithCD - CR 20109
		   Moved rounding of TAMT to 2 (currency) decimal places from 
		   ESCTRN section to each of the accrual adjustment sections 
		   (ACR, NEGACR, ADJUNC, NEGUNA) just after setting EXACTACR 
		   into TSO so correct rounding will take place for non-escrow 
		   accrual adjustments as well as for escrow.
	
	03/24/06 - SmithCD - CR 20109
		   Modified accrual adjustment sections to 
	
	03/06/06 - Sreeram P - CR 19872
		   CRT^RECALC0 modified to pass MCEFD to $$TCMT calls instead 
		   of %EffectiveDate.
	
	02/23/06 - SmithCD - CR 19168
		   . Removed code to set GLOFST for mass changes (no longer 
		     needed - offsets for mass changes will now file like any 
		     other call to RECALC0)
		   . Modified CRT to set index / matrix change not into TCMT 
		     for mass changes
		   . Moved RATECHG call to before ADJ so they show up in 
		     history before interest adjustments
		   . Modified CRT section to return "Invalid transaction code"
		     error if the transaction code is not defined in TRN table
		   . Peformed some additional cleanup, in particular in the 
		     ESCTRN section

	02/03/06 - Hillanbrand - CR19168
	        Corrected undefine on BRCD.  In section CRT removed the 
	        ' from if 'BRCD.get().isNull() set BRCD = dep.boo.
	*/

	type public Number ADJACR, ADJAWT, ADJBWA, ADJINT, ADJRES, ADJUNC
	type public Number MASSCHG, NEGADJ, NEGPST, NEGUNA, RESPST, UNCPST
	type public Boolean ER
	type public String RATECHG(), %UserStation

	type Number INTADJ
	type String CRCD, TSO, UTLO
	type Date EFDATE

	set ER = 0

	set TSO = ""

	/*
	Primary account currency code
	May be different from interest transfer recipient account
	*/
	set CRCD = dep.crcd

	if 'MASSCHG if prittx.tso.isLike("%INTADJ%") set INTADJ = 1
	else  set INTADJ = ""

	set EFDATE = %SystemDate
	if %UserStation.get().isNull() set %UserStation = $$TLO^UTLO()

	do RATECHG(dep.cid)

	do ADJ(.dep, .prittx)

	quit


ADJ(RecordDEP dep,		// Deposit account		/REF:RW
    RecordTTX prittx)		// Primary transaction		/REF:R

	// Adjust interest paid and / or accrued

	type public Number ADJACR,  ADJAWT, ADJBWA, ADJINT, ADJRES, ADJUNC, ER
	type public Number NEGADJ, NEGPST, NEGUNA, RESPST, UNCPST
	type public Date EFDATE
	type public String NNT()
	type public Cache %CACHE()

	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:dep.type")

	// Do Positive Accrual Adjustment transaction
	if ADJACR do ACR(.dep, .prodctl, ADJACR, .prittx) quit:ER

	// Do Negative Accrual Adjustment transaction
	if NEGADJ do NEGACR(.dep, .prodctl, NEGADJ, .prittx) quit:ER

	// Do Negative Interest Unauthorized adjustment transaction
	if NEGUNA do NEGUNA(.dep, .prodctl, NEGUNA, .prittx) quit:ER

	// Do Uncollected Interest Adjustment transaction
	if ADJUNC do ADJUNC(.dep, .prodctl, ADJUNC, .prittx) quit:ER

	// Adjust Accrued Withholding Tax (no transaction)
	if ADJAWT set dep.awt = dep.awt + ADJAWT

	set ADJINT = ADJINT.get().roundDec(5)
	set NEGPST = NEGPST.get().roundDec(5)
	set ADJRES = ADJRES.get().roundDec(5)
	set RESPST = RESPST.get().roundDec(5)
	set UNCPST = UNCPST.get().roundDec(5)

	if 'ADJINT, 'NEGPST, 'ADJRES, 'RESPST, 'UNCPST, 'ADJBWA quit

	// Create secondary interest posted adjustments by date
	set EFDATE = ""
	for  set EFDATE = NNT(EFDATE).order() quit:EFDATE.isNull() ! (ER)  do INTADJ(.dep, .prodctl, prittx.getStoredValue("HistSeq"))
	quit:ER

	quit


INTADJ(RecordDEP dep,			// Deposit account		/REF:RW
       RecordPRODCTL prodctl,		// Product type			/REF:R
       Number THSEQ)			// Transaction Sequence
       
	// Create secondary interest posted adjustments by date

	type public Date EFDATE
	type public String NNT()
	type public Boolean ER
	
	type Number BWA, NEGINT, POSINT, RESINT, RESPST, TFRINT
	type Number NTAX, TFRNINT, UNCINT
	
	set POSINT = NNT(EFDATE).piece("|", 1) - NNT(EFDATE).piece("|", 2)
	set NEGINT = NNT(EFDATE).piece("|", 3) - NNT(EFDATE).piece("|", 4)
	set NEGINT = NEGINT + NNT(EFDATE).piece("|", 5) - NNT(EFDATE).piece("|", 6)
	set RESINT = NNT(EFDATE).piece("|", 7) - NNT(EFDATE).piece("|", 8)
	set RESPST = NNT(EFDATE).piece("|", 9) - NNT(EFDATE).piece("|", 10)
	set TFRINT = NNT(EFDATE).piece("|", 11) - NNT(EFDATE).piece("|", 12)
	set TFRNINT = NNT(EFDATE).piece("|", 13) - NNT(EFDATE).piece("|", 14)
	set UNCINT = NNT(EFDATE).piece("|", 17) - NNT(EFDATE).piece("|", 18)
	set BWA = NNT(EFDATE).piece("|", 19) - NNT(EFDATE).piece("|", 20)
	set NTAX = NNT(EFDATE).piece("|", 21) - NNT(EFDATE).piece("|", 22)

	// Post net accrued
	if dep.negipo < 2 set POSINT = (POSINT - NEGINT), NEGINT = 0

	// Defer Posting Interest Adjustment
	if dep.definadj, (POSINT ! (NEGINT)) do DEFINADJ(dep.cid, EFDATE, POSINT, NEGINT, BWA, THSEQ)

	if (POSINT ! (BWA)), 'dep.definadj do { quit:ER
		do POSINT(.dep, .prodctl, POSINT, 1) quit:ER
		do EXPENSE(.dep, POSINT)
		}

	if TFRINT do { quit:ER
		type Number TFRCID
		do DISBURSE(.dep, .prodctl, .TFRCID, TFRINT, "POSINT-") quit:ER
		do ITRFOFF(.dep, TFRCID, TFRINT) quit:ER
		}

	if (NEGINT ! (NTAX)), 'dep.definadj do { quit:ER
		do NEGINT(.dep, .prodctl, NEGINT, 1) quit:ER
		do INCOME(.dep, NEGINT)
		}

	// Uncollected interest was posted
	if UNCINT do { quit:ER
		do UNCINT(.dep, .prodctl, UNCINT) quit:ER
		do INCOME(.dep, UNCINT)
		}

	if TFRNINT do { quit:ER
		type Number TFRCID
		do DISBURSE(.dep, .prodctl, .TFRCID, TFRNINT, "NEGINT-") quit:ER
		do ITRFOFF(.dep, TFRCID, TFRNINT) quit:ER
		}

	if RESINT do { quit:ER
		// Residual interest was posted (on a posting date)
		do RESINT(.dep, .prodctl, RESINT, 1) quit:ER
		if 'dep.negacrpo do EXPENSE(.dep, RESINT) quit
		if dep.negacrpo do INCOME(.dep, RESINT)
		}

	if RESPST do { quit:ER
		// Residual interest was paid (not on a posting date)
		do RESINT(.dep, .prodctl, RESPST, 0) quit:ER
		if 'dep.negacrpo do POSINT(.dep ,.prodctl, RESPST, 0) quit
		if dep.negacrpo do NEGINT(.dep, .prodctl, -RESPST, 0)
		}
					
	quit


ACR(RecordDEP dep,		// Deposit account		/REF:RW
    RecordPRODCTL prodctl,	// Product type			/REF:R
    Number ADJACR,		// Total pos accrual adjustment
    RecordTTX prittx)		// Primary transaction		/REF:R
    
	// Post positive interest accrual adjustment transaction

	type public Boolean ER

	type String ETC, TCMT, TSO
	type Number TAMT
	type Boolean DRCR

	if ADJACR < 0 set TAMT = -ADJACR, DRCR = 0
	else  set TAMT = ADJACR, DRCR = 1

	set (TCMT, TSO) = ""
	set TSO = $$FIELDIN^UTSO(TSO, "EXACTACR", TAMT)
	
	/*
	Round according to currency even if it will result in a 0 transaction 
	amount - exact amount in TSO will be used to update the appropriate 
	accrual field in the accrual posting program.
	*/
	set TAMT = TAMT.roundCur(dep.crcd)
		
	if dep.grp '= "ESC" do { quit:ER
		// DR Adj Accrued Int/Div Tran Code
		if ADJACR < 0 set ETC = prodctl.dradin
		// CR Adj Int/Div Accrued Tran Code
		else  set ETC = prodctl.cradin

		if ETC.isNull() do ETCERR^TTXEXT(prodctl.type, $select(ADJACR < 0:"DRADIN", 1:"CRADIN")) quit

		// Process adjustment transaction
		do CRT(.dep, ETC, dep.cid, 0) quit:ER
		}
	else  do ESCTRN(.dep , .prittx, TAMT, 1, DRCR) quit:ER

	do EXPENSE(.dep, ADJACR)

	quit


NEGACR(RecordDEP dep,		// Deposit account		/REF:RW
       RecordPRODCTL prodctl,	// Product type			/REF:R
       Number NEGADJ,		// Total neg accrual adjustment
       RecordTTX prittx)	// Primary transaction		/REF:R
       
	// Post negative interest accrual adjustment transaction

	type public Boolean ER

	type String ETC, TCMT, TSO
	type Boolean DRCR
	type Number TAMT

	set NEGADJ = NEGADJ.roundDec(5) if 'NEGADJ quit

	if NEGADJ < 0 set TAMT = -NEGADJ, DRCR = 0
	else  set TAMT = NEGADJ, DRCR = 1

	set (TCMT, TSO) = ""
	set TSO = $$FIELDIN^UTSO(TSO, "EXACTACR", TAMT)
	
	/*
	Round according to currency even if it will result in a 0 transaction 
	amount - exact amount in TSO will be used to update the appropriate 
	accrual field in the accrual posting program.
	*/
	set TAMT = TAMT.roundCur(dep.crcd)

	if dep.grp '= "ESC" do { quit:ER
		// CR Adj Neg Accrued Interest Tran Code
		if NEGADJ < 0 set ETC = prodctl.cradna
		// DR Adj Neg Accrued Interest Tran Code
		else  set ETC = prodctl.dradna

		if ETC.isNull() do ETCERR^TTXEXT(prodctl.type, $select(NEGADJ < 0:"CRADNA", 1:"DRADNA")) quit
		
		// Process adjustment transaction
		do CRT(.dep, ETC, dep.cid, 0) quit:ER
		}
	else  do ESCTRN(.dep, .prittx, TAMT, 4, DRCR)

	do INCOME(.dep, NEGADJ)
	
	quit


ADJUNC(RecordDEP dep,		// Deposit account		/REF:RW
       RecordPRODCTL prodctl,	// Product type			/REF:R
       Number ADJUNC,		// Total uncollected accrual adj
       RecordTTX prittx)	// Primary transaction		/REF:R
       
	// Post uncollected interest accrual adjustment transaction

	type public Boolean ER
	
	type String ETC, TCMT, TSO
	type Number TAMT
	type Boolean DRCR
	
	set ADJUNC = ADJUNC.roundDec(5) if 'ADJUNC quit

	// CR Accrued Interest on Uncollected Funds
	if ADJUNC < 0 set TAMT = -ADJUNC, DRCR = 0
	// DR Accrued Interest on Uncollected Funds
	else  set TAMT = ADJUNC, DRCR = 1

	set (TCMT, TSO) = ""
	set TSO = $$FIELDIN^UTSO(TSO, "EXACTACR", TAMT)
	
	/*
	Round according to currency even if it will result in a 0 transaction 
	amount - exact amount in TSO will be used to update the appropriate 
	accrual field in the accrual posting program.
	*/
	set TAMT = TAMT.roundCur(dep.crcd)
	
	if dep.grp '= "ESC" do { quit:ER
		// CR Accrued Interest on Uncollected Funds
		if ADJUNC < 0 set ETC = prodctl.craiuc
		// DR Accrued Interest on Uncollected Funds
		else  set ETC = prodctl.draiud
	
		if ETC.isNull() do ETCERR^TTXEXT(prodctl.type, $select(ADJUNC < 0:"CRAIUC", 1:"DRAIUD")) quit
		
		// Process adjustment transaction
		do CRT(.dep, ETC, dep.cid, 0) quit:ER
		}
	else  do ESCTRN(.dep, .prittx, TAMT, 7, DRCR) quit:ER

	do INCOME(.dep, ADJUNC)

	quit


NEGUNA(RecordDEP dep,		// Deposit account		/REF:RW
       RecordPRODCTL prodctl,	// Product type			/REF:R
       Number NEGUNA,		// Total neg unauth accrued adj
       RecordTTX prittx)	// Primary transaction		/REF:R

	// Post negative interest accrual unauthorized adjustment transaction

	type public Boolean ER
		
	type Boolean DRCR
	type String ETC, TCMT, TSO
	type Number TAMT

	set NEGUNA = NEGUNA.roundDec(5) if 'NEGUNA quit

	if NEGUNA < 0 set TAMT = -NEGUNA, DRCR = 0
	else  set TAMT = NEGUNA, DRCR = 1

	set (TCMT, TSO) = ""
	set TSO = $$FIELDIN^UTSO(TSO, "EXACTACR", TAMT)

	/*
	Round according to currency even if it will result in a 0 transaction 
	amount - exact amount in TSO will be used to update the appropriate 
	accrual field in the accrual posting program.
	*/
	set TAMT = TAMT.roundCur(dep.crcd)
	
	if dep.grp '= "ESC" do {
		// DR ADJ Neg Accrued Unauth Tran Code
		if NEGUNA < 0 set ETC = prodctl.crnegacrua
		// CR ADJ Neg Accrued Unauth Tran Code
		else  set ETC = prodctl.drnegacrua
		
		if ETC.isNull() do ETCERR^TTXEXT(prodctl.type, $select(NEGUNA < 0:"CRNEGACRUA", 1:"DRNEGACRUA")) quit
		
		// Process adjustment transaction
		do CRT(.dep, ETC, dep.cid, 0) quit:ER
		}
	else  do ESCTRN(.dep, .prittx, TAMT, 6, DRCR) quit:ER

	do INCOME(.dep, NEGUNA)

	quit

 
ESCTRN(RecordDEP dep,		// Deposit account		/REF:RW
       RecordTTX prittx,	// Primary transaction		/REF:R
       Number TAMT,		// Transaction amount
       Number TCCTL,		// Transaction control
       Boolean DRCR)		// Debit / Credit indicator

	/*
	Post interest adjustments to escrow accounts through loan
	
	Processes accrual adjustments to escrow accounts for Mass 
	Index Changes. Does not make interest posted adjustments 
	for escrow accounts (interest adjustments from prior periods 
	are accumulated into the current period accrual adjustment).

	Additional nots on ARGUMENTS:
        . TCCTL
		0 - Post (positive) interest/dividend
		1 - Adjust (positive) interest/dividend accrual
		2 - Adjust (positive) interest/dividend paid
		3 - Post negative interest
		4 - Adjust negative (authorized) interest accrual
		5 - Adjust negative (authorized /unauthorized) interest charged
		6 - Adjust negative unauthorized interest accrual
		7 - Adjust negative uncollected interest accrual
		8 - Adjust negative uncollected interest charged
	
	Format:
		do ESCTRN(.dep, .prittx, TAMT, TCCTL, DRCR) quit:ER
	
	*/

	type public Boolean ER
	type public String TCMT, TSO
		
	type String ETC
	type Number ZAMT
	
	/*
	Loan account number, to which escrow account linked... use acn here 
	instead of ln object only b/c POST^LNTRB looks at acn to load the 
	object of the account of the transaction. W/o this measure, the 
	deposit object would get overlaid by the acn object.
	*/
	
	type RecordLN ln = Db.getRecord("LN", "CID=:dep.aref")
	
	// Invalid account number (account does not exist)
	if 'ln.getMode() do Runtime.setErrMSG("LN", 7822) quit

	set ETC = $$LETC^ESCFUNCS(ln.type, TCCTL, DRCR) quit:ER
	
	set TSO = $$FIELDIN^UTSO(TSO, "ESC#"_dep.esc)
	set ZAMT = TAMT
			
	// Process and post escrow adjustment transaction
	do POST^LNTRB(.prittx, dep.aref, ETC, TAMT, %SystemDate, %UserStation, TSO, TCMT, ln.crcd)
				
	quit
	
	
POSINT(RecordDEP dep,			// Deposit account		/REF:RW
       RecordPRODCTL prodctl,		// Product type			/REF:R
       Number ADJ,			// Adjustment
       Number ITC4)			// Interest posting byte

	// Post positive interest paid adjustment transaction

	type public Number BWA, ER, NTAX
	type String ETC, TAMT, TCMT, TSO
		
	type RecordTTX ttx = Class.new("RecordTTX")
	
	// DR Adj Int/Div Expense Tran Code
	if ADJ < 0 set ETC = prodctl.dradie, TAMT = -ADJ, BWA = -BWA, NTAX = -NTAX
	// CR Adj Int/Div Expense Tran Code
	else  set ETC = prodctl.cradie, TAMT = ADJ

	if ETC.isNull() do ETCERR^TTXEXT(prodctl.type, $select(ADJ < 0:"DRADIE", 1:"CRADIE")) quit

	set TSO = "NOADJ#1"
	set TCMT = ""

	// Int/Div Available Not Credited
	if dep.iaf = 2 set TAMT.piece("#", 8) = TAMT - BWA
	else  do {
		// Principal
		set TAMT.piece("#", 2) = TAMT - BWA
		
		// Backup Withholding
		set TAMT.piece("#", 5) = BWA
		
		if NTAX do {
			/*
			Example:
			Neg int posting amount: 50
			Neg tax anount:5
			TTX.TAMT = "50#55#######-5
			50 = 55 + (-5)
			*/
		
			// Principal (TTX.PRIN)
			set TAMT.piece("#", 2) = TAMT + NTAX
		
			// Tran Detail: D:N I Tax L:Una Funds (TTX.UNAPL)
			set TAMT.piece("#", 9) = -NTAX
			}
		}
	
	// Process adjustment transaction
	do CRT(.dep, ETC, dep.cid, ITC4) quit:ER

	quit


NEGINT(RecordDEP dep,			// Deposit account		/REF:RW
       RecordPRODCTL prodctl,		// Product type			/REF:R
       Number ADJ,			// Adjustment
       Number ITC4)			// Interest posting byte
       
	// Post negative interest charged adjustment transaction

	type public Boolean ER
	type public Number NTAX
	
	type String ETC, TAMT, TCMT, TSO
	
	type RecordTTX ttx = Class.new("RecordTTX")
	
	// CR Adj Neg Interest Posted Tran Code
	if ADJ < 0 set ETC = prodctl.cradni, TAMT = -ADJ, NTAX = -NTAX
	// DR Adj Neg Interest Posted Tran Code
	else  set ETC = prodctl.dradni, TAMT = ADJ

	if ETC.isNull() do ETCERR^TTXEXT(prodctl.type, $select(ADJ < 0:"DRADNI", 1:"CRADNI")) quit

	set TSO = "NOADJ#1"
	set TCMT = ""

	if NTAX do {
		/*
		Example:
		Neg int posting amount: 50
		Neg tax anount:5
		TTX.TAMT = "50#55#######-5
		50 = 55 + (-5)
		*/
		
		// Principal (TTX.PRIN)
		set TAMT.piece("#", 2) = TAMT + NTAX
		
		// Tran Detail: D:N I Tax L:Una Funds (TTX.UNAPL)
		set TAMT.piece("#", 9) = -NTAX
		}
	
	// Process adjustment transaction
	do CRT(.dep, ETC, dep.cid, ITC4) quit:ER

	quit


UNCINT(RecordDEP dep,			// Deposit account 		/REF:RW
       RecordPRODCTL prodctl,		// Product type			/REF:R
       Number ADJ)			// Adjustment

	// Post uncollected interest charged adjustment transaction

	type public Boolean ER
	type public Number TYPE

	type String ETC, TCMT, TSO
	type Number TAMT

	// CR Interest on Uncollected Funds
	if ADJ < 0 set ETC = prodctl.criufc, TAMT = -ADJ
	// DR Interest on Uncollected Funds
	else  set ETC = prodctl.driufd, TAMT = ADJ

	if ETC.isNull() do ETCERR^TTXEXT(TYPE, $select(ADJ < 0:"CRIUFC", 1:"DRIUFD")) quit

	set TSO = "NOADJ#1"
	set TCMT = ""

	// Process adjustment transaction
	do CRT(.dep, ETC, dep.cid, 0) quit:ER

	quit


RESINT(RecordDEP dep,			// Deposit account		/REF:RW
       RecordPRODCTL prodctl,		// Product type			/REF:R
       Number ADJ,			// Adjustment
       Number ITC4)			// Interest posting byte
       
	// Post residual interest adjustment transaction

	type public Boolean ER

	type String ETC, TCMT, TSO
	type Number TAMT

	// CR ADJ Residual Interest
	if ADJ < 0 set ETC = prodctl.cradres,TAMT = -ADJ
	// DR ADJ Residual Interest
	else  set ETC = prodctl.dradres, TAMT = ADJ

	if ETC.isNull() do ETCERR^TTXEXT(prodctl.type, $select(ADJ < 0:"CRADRES", 1:"DRADRES")) quit

	set TSO = "NOADJ#1"
	set TCMT = ""

	// Process adjustment transaction
	do CRT(.dep, ETC, dep.cid, ITC4) quit:ER

	quit


INCOME(RecordDEP dep,		// Account number			/REF:R
       Number ADJ)		// Adjustment

	// Offset negative interest charged / accrual adjustments to income G/L

	type public Boolean ER
	type public Cache %CACHE()

	type String ETC
	type Number DC, TAMT, TCMT

	// General Ledger Set Code
	type RecordUTBLGLSC utblglsc = %CACHE("UTBLGLSC").getRecord("UTBLGLSC", "GLSC=:dep.glsc")

	// Dep G/L # (O/D Interest Income)
	// Invalid bank number.  No G/L number found.
	if utblglsc.dglii.isNull() do Runtime.setErrMSG("UTBLGLSC", 1270) quit

	set TCMT = ""

	// If Transaction to Reduce Balance
	if 'dep.trb do {
		if ADJ < 0 do {
			set ETC = "MDR"
			set TAMT = -ADJ
			set DC = 0
			}
		else  do {
			set ETC = "MCR"
			set TAMT = ADJ
			set DC = 1
			}
		}
	else  do {
		if ADJ < 0 do {
			set ETC = "MCR"
			set TAMT = -ADJ
			set DC = 1
			}
		else  do {
			set ETC = "MDR"
			set TAMT = ADJ
			set DC = 0
			}
		}
	
	set TAMT = TAMT.get().roundDec(2)
	
	// Create and post GL offset transaction
	do CRT(.dep, ETC, utblglsc.dglii, 0) quit:ER

	quit


EXPENSE(RecordDEP dep,		// Deposit account			/REF:R
	Number ADJ)		// Adjustment

	// Offset interest paid / accrual adjustments to expense G/L

	type public Boolean ER
	type public Cache %CACHE()

	type String ETC
	type Number DC, TAMT, TCMT

	// General Ledger Set Code
	type RecordUTBLGLSC utblglsc = %CACHE("UTBLGLSC").getRecord("UTBLGLSC", "GLSC=:dep.glsc")

	// Dep G/L # (Interest Expense)
	// Invalid bank number.  No G/L number found.
	if utblglsc.dgli.isNull() do Runtime.setErrMSG("UTBLGLSC", 1270) quit

	set TCMT = ""

	// If Transaction to Reduce Balance
	if 'dep.trb do {
		if ADJ < 0 do {
			set ETC = "MCR"
			set TAMT = -ADJ
			set DC = 1
			}
		else  do {
			set ETC = "MDR"
			set TAMT = ADJ
			set DC = 0
			}
		}
	else  do {
		if ADJ<0 do {
			set ETC = "MDR"
			set TAMT = -ADJ
			set DC = 0
			}
		else  do {
			set ETC = "MCR"
			set TAMT = ADJ
			set DC = 1
			}
		}
		
	set TAMT = TAMT.get().roundDec(2)

	// Create and post GL offset transaction
	do CRT(.dep, ETC, utblglsc.dgli, 0) quit:ER

	quit


CRT(RecordDEP dep,		// Deposit account		/REF:RW
    String ETC,			// Transaction code
    Number CID,			// Account number
    Number ITC4)		// Interest posting byte

	// Build and post interest adjustment transaction

	type public Cache %CACHE()
	type public Boolean ER, EXCH
	type public Date EFDATE,MCEFD
	type public Number BRCD, RATE
	type public String CRCD, FCRCD, INTADJ, MASSCHG, RM, SPV(),TAMT, TCMT, TSO

	type RecordTTX ttx = Class.new("RecordTTX")
	
	// Invalid transaction code
	if 'Db.isDefined("TRN", "ETC=:ETC") do { quit
		do Runtime.setErrMSG("TRN", 3592)
		set RM = RM_" "_ETC
		}
	
	// Adjustment transaction code
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")

	if INTADJ set trn.itc = $$ITC^TTXEXT(trn.itc, 4, 1)
	
	if MASSCHG, TCMT.isNull() do {
		type public Number DTL
		type public String AWTI, IND, MAT
		
		// Interest index mass change
		if DTL = 3 set TCMT = $$TCMT^INDEXMC(IND,MCEFD.toString())
		// Interest matrix mass change
		else  if DTL = 9 set TCMT = $$TCMT^MATRIXMC(MAT,MCEFD.toString())
		// Tax index mass change
		else  if DTL = 10 set TCMT = $$TCMT^INDEXMC(AWTI,MCEFD.toString())
		}

	set ttx.cid = CID
	set ttx.itc = trn.itc
	set ttx.etc = trn.etc
	set ttx.tamt = TAMT
	set ttx.efd = $select((EFDATE - %SystemDate):EFDATE, 1:"")
	set ttx.tlo = %UserStation
	set ttx.tso = TSO
	set ttx.tcmt = TCMT
	if trn.cls = "M" set ttx.cc = dep.cc

	#IF CUVAR.%MCP if dep.crcd '= %SystemCurrency set ttx.crcd = dep.crcd, ttx.custcd = dep.ccode

	if EXCH.get() do {
		/* If we're transfering to a different currency, then the
		transfer amount must be converted so that the transfer
		recipient's account balance is updated correct when
		posting. */

		type Number TRNTYP, EXCAMT

		set TRNTYP = $select(trn.itc.extract(1):0, 1:1)
		do EXC^CRCDUTL(FCRCD, CRCD, TAMT, 1, TRNTYP, "00", dep.ccode, %EffectiveDate,1)

		set ttx.bseamt = TAMT
		set ttx.rate = RATE
		set ttx.bcrcd = FCRCD
		set ttx.custcd = dep.ccode
		set ttx.tamt = EXCAMT.roundCur(CRCD)
		}

	/*
	Use the standard transaction processing program to apply the accrual
	adjustment to 5 decimal place accuracy taken from TSO("EXACTACR").
	*/

	if BRCD.get().isNull() set BRCD = dep.boo

	if ITC4 set ttx.itc = $$ITC^TTXEXT(trn.itc, 4, 1)

	// Calculate/update dollar day balance for each transaction
	do DDB^RECALC(.dep, .ttx) quit:ER

	// Post transaction
	do TRNSINGL^TRNDRV(.ttx,.dep,%SystemDate,BRCD,4,,.SPV)

	quit


DISBURSE(RecordDEP dep,			// Deposit account		/REF:RW
	 RecordPRODCTL prodctl,		// Product type			/REF:R
	 Number TFRCID,			// Transfer account number	/REF:W
	 Number ADJ,			// Adjustment
	 String TCMT)			// Teller comment

	// Interest adjustment disbursement (transfer)

	type public Date EFDATE
	type public String NNT()
	type public Boolean ER
	type public Cache %CACHE()
	
	type String ETC, TSO
	type Number TAMT

	// CR Int/Div Transfer Tran Code
	if ADJ < 0 set ETC = prodctl.crtrit, TAMT = -ADJ
	// DR Int/Div Transfer Tran Code
	else  set ETC = prodctl.drtrit, TAMT = ADJ

	if ETC.isNull() do ETCERR^TTXEXT(prodctl.type, $select(ADJ < 0:"CRTRIT", 1:"DRTRIT")) quit

	/*
	TCMT in combination with DR/CR indicator determines whether the
	transaction is a transfer or a backing out of a transfer.  This is
	applicaple to the disbursing account only.
	Pos int trfr account
	*/
	if TCMT.isLike("%POSINT-%") set TFRCID = NNT(EFDATE).piece("|",15)
	else  do {
		// Neg int trfr account
		set TFRCID = NNT(EFDATE).piece("|", 16)
		if TFRCID.isNull() set TFRCID = NNT(EFDATE).piece("|", 15)
		}

	set TCMT = TCMT_"TFR-"_TFRCID

	/* NOADJ indicates no recursion into RECALC during processing
	of the interest disbursement transaction. */
	set TSO = "NOADJ#1"
	set TSO = $$FIELDIN^UTSO(TSO, "INTTRFADJ")

	// Process transaction
	do CRT(.dep, ETC, dep.cid, 0) quit:ER

	quit


ITRFOFF(RecordDEP dep,		// Deposit account		/REF:RW
	Number TFRCID,		// Transfer account number
	Number ADJ)		// Adjustment

	/*
	Interest transfer recipient account offset

	Note this transaction may spawn an indirect recursion back into
	RECALC to adjustments adjustments to the recipient account based
	on this back-dated transaction. This is allowed because the
	NOADJ TSO field is not indicated for this transaction.
	*/
	
	type public Cache %CACHE()

	type String ETC, FCRCD, TCMT, TSO
	type Boolean ER
	type Number EXCH, TAMT

	set TCMT = "TFR-"_dep.cid

	type RecordDEP deptfr = Db.getRecord("DEP", "CID=:TFRCID", 1)
	if 'deptfr.getMode() quit

	// Tfr account ~p1 closed
	if deptfr.stat = 4 do Runtime.setErrMSG("DEP", 5816, deptfr.cid) quit

	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:deptfr.type")

	// DR Int/Div Transfer Tran Code
	if ADJ < 0 set ETC = prodctl.drtrit, TAMT = -ADJ
	// CR Int/Div Transfer Tran Code
	else  set ETC = prodctl.crtrit, TAMT = ADJ

	if ETC.isNull() do ETCERR^TTXEXT(deptfr.type, $select(ADJ < 0:"DRTRIT", 1:"CRTRIT")) quit

	set TSO = $$FIELDIN^UTSO("","INTTRFADJ")

	if deptfr.crcd '= dep.crcd do {
		set EXCH = 1
		set FCRCD = dep.crcd
		}
	else  set EXCH = 0

	// Process adjustment transaction 
	do CRT(.dep, ETC, dep.cid, 0) quit:ER

	quit


DEFINADJ(Number CID,		// Account number
	 Date EFDATE,		// Effective date
	 Number POSINT,		// Positive deferred interest
	 Number NEGINT,		// Negative deferred interest
	 Number BWA,		// Deferred backup withholding
	 Number THSEQ)		// Transaction Sequence

	// Update Defer Posting Interest Adjustments tables
	// Do not create transactions for deferred adjustments, just update DB

	// Update Deposits Deferred Interest
	type RecordDEFINP definp = Db.getRecord("DEFINP", "CID=:CID,INP=:EFDATE", 1)

	// Update Current Deferred Interest
	if POSINT set definp.dcur = definp.dcur + POSINT
	// Update Negative Current Deferred Interest
	if NEGINT set definp.dcurneg = definp.dcurneg + NEGINT
	// Update Current Deferred Accrued Withholding
	if BWA set definp.awcd = definp.awcd + BWA
	
	do definp.bypassSave()

	// Update Deposits Deferred Interest Detail
	type RecordDEFDTL defdtl = Db.getRecord("DEFDTL", "CID=:CID,INP=:EFDATE,SEQ=:THSEQ", 1)

	// Positive Deferred Interest Adjustment
	set defdtl.posint = POSINT
	// Negative Deferred Interest Adjustment
	set defdtl.negint = NEGINT
	// Deferred Accrued Withholding Adjustment
	set defdtl.dawa = BWA

	do defdtl.bypassSave()

	quit


RATECHG(Number CID)		// Account number

	/*
	File interest rate changes to account history

	Input:
		. RATECHG()  Array containing interest rate changes on 
			     effective dates
			pieces:
			1. Old rate value
			2. New rate value
			3. hist.tso (Transaction Source of Funds) field value
			It also contains primary transaction history number for 
			reference.
			4. Rate change date (Effective Date)
			Example: RATECHG(CID,DINAME,SEQ)=OLDRATE|NEWRATE|TSO|EFD
	*/

	type public Boolean ER
	type public String RATECHG(,,)

	if 'RATECHG(CID).data() quit
	
	type Date %EffectiveDate
	type String DINAME = "", TCMT, TSO
	type Number SEQ = ""

	for  set DINAME = RATECHG(CID, DINAME).order() quit:DINAME.isNull()  do { quit:ER
		for  set SEQ = RATECHG(CID, DINAME, SEQ).order() quit:SEQ.isNull()  do { quit:ER
			set %EffectiveDate = RATECHG(CID,DINAME,SEQ).piece("|",4)
			set TSO = RATECHG(CID, DINAME, SEQ).piece("|", 3)
			set TCMT = CID_"[DEP]"_DINAME_":"_RATECHG(CID, DINAME, SEQ).piece("|", 1)_":"_RATECHG(CID, DINAME, SEQ).piece("|", 2)
			
			do HISTBLD^ACNFUNCS(TCMT, , TSO)
			}
		}

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60789^30517^Hari Natrajan^27947"	// Signature - LTD^TIME^USER^SIZE
