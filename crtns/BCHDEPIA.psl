BCHDEPIA //Batch BCHDEPIA - Deposit Int/Div Adjustment Index
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/30/2007 15:07 - joynerd
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHDEPIA Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit quit
 do JOBMGR^BCHUTL(%FN,"BCHDEPIA",.vINPUT)
 do ^JOBMGR(.vINPUT)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(DATETIME,CID) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHDEPIA","*","",DATETIME.get()_","_CID.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,DATETIME,CID)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHDEPIA","*","",DATETIME.get()_","_CID.get(),"",et)
 }
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,DATETIME,CID) //
	if 'Db.isDefined("DEP","CID") quit      // Not a deposit account

	new LPSEQ
	set LPSEQ=""

	type ResultSet rs=Db.select("TSEQ","DTJ","TJD=:XTJD AND CID=:CID AND DATETIME=:DATETIME")
	if rs.isEmpty() quit
	while rs.next() do {

		new dtj,TSEQ,REVFLG

		set TSEQ=rs.getCol(1)
		set REVFLG=0

		type RecordDTJ dtj=Db.getRecord("DTJ","XTJD,DATETIME,CID,TSEQ")
		if Db.isDefined("HISTR","CID,TSEQ") do {
			type RecordHISTR histr=Db.getRecord("HISTR","CID,TSEQ")
			set REVFLG=histr.revflg
			}

		do INDEX(.dtj,.LPSEQ,REVFLG)

		}

	quit

	//---------------------------------------------------------------------
Public INDEX(RecordDTJ dtj,LPSEQ,REVFLG) 
	//
	// Build Int/Div adj. transactions relationship
	//---------------------------------------------------------------------
 
	/*

	This is a public function that will build Int/Div adjustments
	relationship tables DEPIA (Deposit Int/Div Adj Relationship -
	Primary) and DEPIAS (Deposit Int/Div Adj Relationship - Secondary)
 
	INPUTS:

		XTJD		/TYP=D
		System Processing Date
 
		CID		/TYP=N
		Account number
 
		TSEQ		/TYP=N
		Transaction Sequence Number

		REVFLG		/TYP=N
		Reversal/Error Correct Flag
		0 - Not Error Corrected/Reversed
		1 - Error Corrected
		2 - Reversed
	FORMAT:
 
		INDEX(RecordDTJ dtj,LPSEQ,REVFLG)
 
	ARGUMENTS:

		dtj		/TYP=O/REQ/MECH=REF:R
		Daily Transaction Journal object
 
		LPSEQ		/TYP=N/REQ/MECH=REF:RW
		Last Primary Transaction Sequence for the current set of DTJ
		records. The calling routine must initialize this variable to
		null prior to calling this function when the CID level changes.

	*/
 
	// Check if it is a Primary backdated Transaction - update LPSEQ.
	if ('dtj.itc7),(dtj.efd'=""),(dtj.efd<XTJD) do {  quit

		// if it is an error correct do not create a DEPIA record
		if dtj.itc6=1 set LPSEQ="" quit
		if REVFLG=1 set LPSEQ="" quit 
		set LPSEQ=dtj.tseq 
		} 

	// Check if it is a Secondary Transaction
	if 'dtj.itc7 quit 

	// No primary transaction associated with secondary
	if LPSEQ="" quit

	new SECOND
	set SECOND=0

	// Check if it is a secondary int/div accrual adj
	if (dtj.tso'["ACRADJ"),((dtj.int>0)!(dtj.misc>0)!(dtj.rec>0)!(dtj.uncint>0)!(dtj.negpb>0)) set SECOND=1

	// Check if it is a secondary int/div posting adj
	if 'SECOND,(dtj.itc4=1),(dtj.tso["NOADJ") set SECOND=1

	// Not a secondary int/div adjustment
	if 'SECOND quit

	// Create a new DEPIAS record

	type RecordDEPIAS depias

	set depias=Class.new("RecordDEPIAS")

	set depias.trnjd=XTJD
	set depias.cid=CID
	set depias.tseq=LPSEQ
	set depias.sseq=TSEQ
 
	do depias.bypassSave()
	
	// If primary record does not exist - create a new DEPIA
	
	type RecordDEPIA depia = Db.getRecord("DEPIA","TRNJD=:XTJD,CID=:CID,TSEQ=:LPSEQ",1)
 	if depia.getMode() quit

	do depia.bypassSave()

	quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
 type String vRECORD,DATETIME,CID
 for  set vRECORD=vINPUT.piece("|",1),vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD.isNull()  do {
 set DATETIME=vRECORD.piece($C(9),1)
 set CID=vRECORD.piece($C(9),2)
 do vPROC(DATETIME,CID)
 }
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
 type public String vBUFOVFL
 type String vRECORD,vrow,DATETIME,CID
 type Number vcur,vlen
 set vINPUT=vBUFOVFL.get()
 set vBUFOVFL="",vlen=0
 type public ResultSet vRESULT
 for  do { quit:'vcur
 set vcur=vRESULT.next() if 'vcur quit
 set vrow=vRESULT.getRow()_"|",vlen=vlen+vrow.length()
 if vlen>32000 set vBUFOVFL=vrow,vcur=0 quit
 set vINPUT=vINPUT_vrow if vlen+24>32000 set vcur=0 quit
 }
 set vINPUT=vINPUT.extract(1,vINPUT.length()-1)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	if $$INTRACT^%ZFUNC do {	// In interactive mode

		new CDATE,%READ,%TAB,VFMQ
		type RecordCUVAR cuvar=Db.getRecord("CUVAR")		
		set CDATE=cuvar.tjd-1
	
		if '$G(CDATE) set CDATE=%SystemDate-1

		set %TAB("XTJD")=".DATE7/MAX="_CDATE
		S %READ="@@%FN,,,XTJD/REQ"

		do ^UTLREAD if VFMQ="Q" set %BatchExit=1 quit
		#accept pgm=spier;date=12/8/03
		set %SystemDate=XTJD+1

		}

	if %BatchExit quit
	set XTJD=%SystemDate-1
	
	// If there are no records in DTJ for selected date - quit
	do checkit(.%BatchExit)
	if %BatchExit quit
	

 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("DISTINCT DATETIME,CID","DTJ","DTJ.TJD=:XTJD")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
	quit

checkit(%BatchExit)
	type ResultSet rs=Db.select("DISTINCT CID","DTJ","TJD=:XTJD")
	if rs.isEmpty() set %BatchExit=1
	quit 
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
	// Delete existing entries from DEPIA and DEPIAS for processing date
 
	type ResultSet rs=Db.select("CID","DEPIA","TRNJD=:XTJD")
	if rs.isEmpty() quit
	while rs.next() do {
 
		new CID
		set CID=rs.getCol(1)
 
		do Db.fastDelete("DEPIA","CID=:CID,TRNJD=:XTJD")
		do Db.fastDelete("DEPIAS","CID=:CID,TRNJD=:XTJD")
 
		}

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
