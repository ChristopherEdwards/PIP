SWIFTMON	//;Private;SWIFT Queue Monitoring Routine
	/*
	   ORIG: YANGR - 03/28/94
	   DESC: SWIFT Server Status Monitoring Routine
	   This monitoring routine will monitor the following varibles:
	   1. Output Server Status: Active or Non-Active
	   2. Input Server Status:  Active or Non-Active
	   . Queue_Name Total_in_que today_que
	      RTT  xx  xx
	      PND  xx  xx
	      REP  xx  xx
	      CMP  xx  xx
	      REC  xx  xx
	   4. There is a timeout period for each cycle of data display.

	   INPUTS:
	   . System

	   . Data [ddfile]di

	   . v1 desc of variable /TYP=T

	   RETURNS:
	   . XX desc of return  /TYP=T

	   EXAMPLE:
	   Text of example (line one)

	  ---- Revision History ------------------------------------------------

	   09/26/05 - KELLYP - CR 17050
	   	      Modified PIDCHK section not to define OPID and IPID from
	   	      ST400CTLSV.  This table has been obsoleted as SWIFT has 
	   	      obsoleted support for the ST400 VMS interface.  No other
	   	      core SWIFT interface is available at this time, so the
	   	      screen will always read "non-active".  Also removed pre-
	   	      2003 revision history.

	   12/29/03 - CARROLLJ - CR7658
		      Added #ACCEPT prior to setting %SystemDate.

	  ---------------------------------------------------------------------

	*/

	do MAIN
	
	quit

MAIN	//

	/*
	   Main routine, infinite loop, Q or q to stop the loop and quit.
	   need to unlock screen before quit this routine
	*/

	do INIT

	//I18N=OFF
	/*
	   Read user's keyboard entry every 4 seconds, QUIT the routine only when
	   entry is "Q" (81) or "q" (113).
	*/
	for  read X:4 quit:(X="Q")!(X="q")  do {
		do DATAREC
		do CALC

		//Ctrl/W(23) to refresh the screen
		if X=23 do INIT
		if OUTPUTS1'=OUTPUTS do DISPLAY^DBSMACRO("@OUTPUTS",$J(OUTPUTS,10))
		if INPUTS1'=INPUTS do DISPLAY^DBSMACRO("@INPUTS",$J(INPUTS,10))
		if NRTT1'=NRTT do DISPLAY^DBSMACRO("@NRTT",$J(NRTT,10))
		if TNRTT1'=TNRTT do DISPLAY^DBSMACRO("@TNRTT",$J(TNRTT,10))
		if PRCMSG1'=PRCMSG do DISPLAY^DBSMACRO("@PRCMSG",$J(PRCMSG,21))
		if TNPRC1'=TNPRC do DISPLAY^DBSMACRO("@TNPRC",$J(TNPRC,10))
		if NREP1'=NREP do DISPLAY^DBSMACRO("@NREP",$J(NREP,10))
		if TNREP1'=TNREP do DISPLAY^DBSMACRO("@TNREP",$J(TNREP,10))
		if NPND1'=NPND do DISPLAY^DBSMACRO("@NPND",$J(NPND,10))
		if TNPND1'=TNPND do DISPLAY^DBSMACRO("@TNPND",$J(TNPND,10))
		if NCMP1'=NCMP do DISPLAY^DBSMACRO("@NCMP",$J(NCMP,10))
		if TNCMP1'=TNCMP do DISPLAY^DBSMACRO("@TNCMP",$J(TNCMP,10))
		if NREC1'=NREC do DISPLAY^DBSMACRO("@NREC",$J(NREC,10))
		if TNREC1'=TNREC do DISPLAY^DBSMACRO("@TNREC",$J(TNREC,10))
		if DATE1'=DATE do DISPLAY^DBSMACRO("@DATE",$J(DATE,10))

		//always display
		do DISPLAY^DBSMACRO("@TIME",$J(TIME,8))
		}

	//I18N=ON

	quit


INIT	//

	//Set up parameters
	#ACCEPT DATE=12/29/03;PGM=John Carroll
	set %SystemDate=CUVAR.tjd

	//Set up %O=2 for display only
	set %ProcessMode=2

	// calculate the values before display
	do CALC

	// get the text (label)/data for the screen
	do DRV^USID(%ProcessMode,"SWIFTMON")

	// total prompt numbers
	set %MAX=$O(%TAB(""),-1)

	quit


CALC	//
	/*
	   Calculate the data for the monitoring screen.
	   There are total 15 screen data items:
	   NRTT,NPND,NREP,NCMP,NRTT; PRTT,PPND,PREP,PCMP,NRTT;
	   NTOTAL; OUTPUTS,INPUTS,DATE,TIME

	*/
	set (NPND,TNPND,NREP,TNREP,TNPRC,NRTT,TNRTT,NCMP,TNCMP,NREC,TNREC)=0

	do PND

	quit


	// There is no date field in queue PND,REP
PND	//Pending queue

	type RecordSWQCNT swqcnt=Db.getRecord("SWQCNT","QUE='PND'",1)
	if swqcnt.getMode()=1 do { quit
		
		//+$P to fet the NUMERICAL value
		set NPND=swqcnt.tot

		//+$P to fet the NUMERICAL value
		set TNPND=swqcnt.ptoday
		}
	
	do REP
	
	quit


REP	//Repair queue

	type RecordSWQCNT swqcnt=Db.getRecord("SWQCNT","QUE='REP'",1)
	if swqcnt.getMode()=1 do { quit
		set NREP=swqcnt.tot
		set TNREP=swqcnt.ptoday
		}
		
	do PRC
	
	quit


PRC	//
	/* 
	  Write message on screen with MTxxx REFNO for the last PRC record
	  first, check if there is any record in "PRC" queue
	*/
	
	set SEQ=""

	//check the first non-nul seq value
	type ResultSet rs=Db.select("SEQ","SWIFTQ2","QUE='PRC'","SEQ")
	if rs.next() set SEQ=rs.getCol("SEQ")

	//init the PRC record message
	if SEQ="" set PRCMSG="None"
	else  do {
		new REFNO,TYPE
		
		type ResultSet rs1=Db.select("TRREFNO,TYPE","SWIFTQ2","SEQ=:SEQ","TRREFNO,TYPE")
		if rs1.next() do {
			set REFNO=rs1.getCol("TRREFNO")
			set TYPE=rs1.getCol("TYPE")
			set PRCMSG="MT"_TYPE_"  "_REFNO
			}
		}

	//PRC processed today
	type RecordSWQCNT swqcnt=Db.getRecord("SWQCNT","QUE='PRC'",1)
	set TNPRC=swqcnt.ptoday

	if 'TNPRC set TNPRC=0

	do CMP

	quit


CMP	//
	/*
	 The date field exists in queue RTT and CMP
	 CMP queue takes TJD as date; RTT queue takes date<=TJD
	 today's total record in Completed queue
	*/
	
	type RecordSWQCNTD swqcntd=Db.getRecord("SWQCNTD","QUE='CMP',DT=:%SystemDate",1)
	if swqcntd.getMode()=1 do { quit
		set NCMP=swqcntd.tot
		set TNCMP=swqcntd.ptoday
		}

	do RTT
	
	quit
	

RTT	//Ready to transmit queue

	new swqcntd
	set QDATE=""
	set (NRTT,TNRTT)=0

	type ResultSet rs=Db.select("DT,TOT,PTODAY","SWQCNTD","QUE='RTT'")

	type RecordSWQCNTD swqcntd
	type DbSet rs=Db.selectDbSet("SWQCNTD","QUE='RTT'")
	if 'rs.isEmpty() while rs.next() do {
		set swqcntd=rs.getRecord()
		set QDATE=swqcntd.dt

		//processed today
		if QDATE=%SystemDate set TNRTT=swqcntd.ptoday

		//total in RTT queue
		if QDATE'>%SystemDate set NRTT=NRTT+swqcntd.tot
		}

	do REC

	quit


REC	//Received queue for incoming message
	/*
	  Only calculate the number in the queue for today similar to CMP queue TT 06.13.94
	*/

	type RecordSWQCNTD swqcntd=Db.getRecord("SWQCNTD","QUE='REC',DT=:%SystemDate",1)
	
	// total in REC queue
	set NREC=swqcntd.tot

	// processed today
	set TNREC=swqcntd.ptoday

	// date and time. time format 15:34:26
	set TIME=$$TIM^%ZM(%CurrentTime,"24:60:SS")
	set DATE=$$DAT^%ZM(%SystemDate,$G(%MSKD))

	do PIDCHK

	quit


PIDCHK
	/* 
	  Checking process ID for INPUT, OUTPUT AND EFT server.
	  get INPUTS,OUTPUTS,EFTS
	*/

	set OPID=""
	set IPID=""

	do OUT

	quit


	// Display Output Server,Input Server and EFT payment Server Status.
OUT	//
	
	set $ZT="G OUTERR^SWIFTMON"
	if OPID="" set OUTPUTS="Non-active"
	else  set OUTPUTS=$S($$VALID^%ZPID(OPID,1):"Active",1:"Non-active")

	do IN

	quit


OUTERR	//
	
	//Non priv to see process
	set OUTPUTS="Non-active"

	do IN

	quit


IN	//

	set $ZT="G INERR^SWIFTMON"

	if IPID="" set INPUTS="Non-active"
	else  set INPUTS=$S($$VALID^%ZPID(IPID,1):"Active",1:"Non-active")

	quit


INERR	//

	//non-existence process
	if (+$ZS=2280)!(+$ZS=268437736) set INPUTS="Non-active"
	else  set INPUTS="Active"

	quit


DATAREC	//
	/*
	   Record the current data value to old_value before the recalculaton.
	   put 1 on the original value as the old value,total 13 items
	   This subroutine is made for repaint screen.
	*/
	
	set NRTT1=$G(NRTT)
	set TNRTT1=$G(TNRTT)
	set NPND1=$G(NPND)
	set TNPND1=$G(TNPND)
	set NREP1=$G(NREP)
	set TNREP1=$G(TNREP)
	set NCMP1=$G(NCMP)
	set TNCMP1=$G(TNCMP)
	set PRCMSG1=$G(PRCMSG)
	set TNPRC1=$G(TNPRC)
	set NREC1=$G(NREC)
	set TNREC1=$G(TNREC)
	set OUTPUTS1=$G(OUTPUTS)
	set INPUTS1=$G(INPUTS)
	set DATE1=$G(DATE)

	quit

vSIG()	quit "60169^53956^Pat Kelly^6806"	// Signature - LTD^TIME^USER^SIZE
