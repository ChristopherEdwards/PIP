public I18NEXT //Batch Extraction
  /*
	ORIG: kumarb - 11/03/2005
	DESC: Batch Extraction

	 I18N=QUIT	No checking for I18N standards
	 DESC:		This program reads through DBTBL and extracts
			all fields that are valid for extraction (translation)
			into the ^I18NEXT global.
	
			DBTBL has to have been previously set up, in the
			proper file definition, with the val4ext flag turned
			on.  If the val4ext flag is on, then the corresponding
			data is extracted into ^I18NEXT.
	
 	                Each phrase is classified into a phrase type. The
			phrase type determines how the phrase is to be
			normalized.
	
			Each phrase is normalized before it is put into
			the I18NEXT file. This normalized phrase is stored
			together with counters on how many phrases of each
			phrase type is actually organized underneath it.
			The normalized level is also metioned as the header 
			level. The original phrase is then stored under this 
			normalized phrase using the global reference as a 
			unique key. The global reference is later used
			so that the phrase can be replaced back into
			the exact place it was extracted from.  Words are
			indentified from the normalized phrase, and also
			written out to I18NEXT's header level.
	
	 
	 CALLED BY:	Menusystem. No other routines.
	 CALL TO:      $$DI^SCATAB
			UTLREAD
			POS^I18NUTL
			VALKEY^I18NUTL
			$$PHRTYP^I18NNRM
			$$NRMPHR^I18NNRM
			PHRSPLIT^I18NUTL
	 GLOBALS READ:
			DBTBL and globals defined by files set valid
			for extraction
	 GLOBALS SET:
			I18NEXT
	 ARGUMENTS:
	 INPUTS:
	
	 RETURNS:
	 EXAMPLE:
	 LIBRARY:
	
	---Revision History-------------------------------------------
	
	07/31/06 - KELLYP - CR 22048
		   Modified FILE section to eliminate DYNAMIC warning.
	
	10/21/05 - KUMARB - CR 16921
        	   Converted to PSL.
	
	--------------------------------------------------------------
	*/

	do START
	
	quit	
	
START	// Initializing Counters and Controlling variables
	
	// New variables just used by I18NEXT

	type Date EXTDT
	type Number badcnt,et,i,phrtyp,WC
	type String %NOPRMT,%READ,%TAB(),CNT(,),dx,dy,HDG,L1,L2,L3,L4,L5,nrmphr,OK,phrword,VFMQ
	
	// Initialize internal variables
	
	set badcnt=0
	set WC=0
	set EXTDT=%CurrentDate
	set HDG=$$^MSG(5894)
	set HDG=$J("",40-(HDG.length()/2))_HDG
	
	set %TAB("OK")=$$DI^SCATAB("","Continue",1,"","","","L")
	
	set %READ="@HDG,,OK/REQ"
	set %NOPRMT="C"
	do ^UTLREAD
	if ("Q"[VFMQ)!('OK) do END quit

	do MAIN

	quit

MAIN	// Main Read Loop
	// Reading through DBTBL by level

	type public String L1
	
	set L1="SYSDEV"

	type RecordDBTBL1 dbtbl11=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID='DBTBL1'",1)
	if dbtbl11.val4ext do FILE
	type RecordDBTBL1 dbtbl12=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID='DBTBL2'",1)
	if dbtbl12.val4ext do SCREEN
	type RecordDBTBL1 dbtbl15=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID='DBTBL5H'",1)
	if dbtbl15.val4ext do REPORT
	
	do END

	quit
	
FILE	// Extractions from Filedefinition
	
	type public String L1,L2,L3,L4,L5

	type Number P,piece
	type String gblref,POS(),rec,varlist
	
	// Get position table
	do POS^I18NUTL("SYSDEV","1","DBTBL1D",.POS())

	// Init collating varialbles
	set L2="1",L3=""

	type DbSet ds=Db.selectDbSet("DBTBL1","%LIBS='SYSDEV'","FID")
	while ds.next() do {
		type RecordDBTBL1 dbtbl1=ds.getRecord("DBTBL1")
		set L3=dbtbl1.fid
		set L4=9
		do WRTPHR(dbtbl1.des,"^DBTBL("_L1_","_L2_","_L3_")",1,1,"DBTBL1","DES")
		type DbSet ds1=Db.selectDbSet("DBTBL1D","%LIBS='SYSDEV' AND FID=:L3","DI")
		while ds1.next() do {
			type RecordDBTBL1D dbtbl1d=ds1.getRecord("DBTBL1D")
			set L5=dbtbl1d.di
			set P=""
			for  set P=POS(P).order() quit:P=""  do {
				if P=10 do WRTPHR(dbtbl1d.des,"^DBTBL("_L1_","_L2_","_L3_","_L4_","_L5_")",P,1,"DBTBL1D","DES")
				if P=22 do WRTPHR(dbtbl1d.rhd,"^DBTBL("_L1_","_L2_","_L3_","_L4_","_L5_")",P,1,"DBTBL1D","RHD")
				}
			
			// Test if this file is valid for extraction-MJZ-Added &(L3'="DBTBL1D")
			if (dbtbl1.val4ext),(dbtbl1d.val4ext),(L3'="DBTBL1"),(L3'="DBTBL2"),(L3'="DBTBL5H"),(L3'="DBTBL1D") do {
				set piece=dbtbl1d.pos
				set varlist=$$GetKeys(dbtbl1.acckeys)
				if varlist'="" set varlist=L5_","_varlist
				else  set varlist=L5
				
				#ACCEPT DATE=07/31/06;PGM=KELLYP;CR=unknown
				type ResultSet rs=Db.select(varlist,L3)
				while rs.next() do {
					type String values
					set rec=rs.getRow()
					set rec=rec.translate($C(9),"|")
					set values=rec.piece("|",2,999)
					set gblref=$$GLOBAL(L1,L2,L3,values)
					do WRTPHR(rec.piece("|",1),gblref,piece,99,L3,L5)
					}
				}
			}
		}

	quit

GLOBAL(String lib,String lvl,String fid,String values) //  Build global reference for DBTBL entries

	type Number i,newpos,pos
	type String global,gblkeys,keynam,position(),val,var,varkeys,x
	
	if lvl'=1 quit ""
	
	type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:fid",1)
	set global=dbtbl1.glref
	set gblkeys=global.piece("(",2)
	set varkeys=$$GetKeys(dbtbl1.acckeys)
	if varkeys="" quit ""
	
	for pos=1:1:gblkeys.length(",") do {
		set keynam=gblkeys.piece(",",pos)
		if keynam.isNull() quit
		set position(keynam)=pos
		}

	for pos=1:1:varkeys.length(",") do {
		set var=varkeys.piece(",",pos)
		if var.isNull() quit
		if 'position(var).data() quit
		set newpos=position(var)
		set val=values.piece("|",pos)
		set gblkeys.piece(",",newpos)=val
		}
		
	for i=1:1:gblkeys.length(",") do {
		// If hard quoted key, delete quotes
		set x=gblkeys.piece(",",i)
		if (x.extract(1)=""""),(x.extract(x.length())="""") set x=x.extract(2,x.length()-1)
		set gblkeys.piece(",",i)=x
		}
		
	set global=global.piece("(",1)_"("_gblkeys_")"

	quit global
	
SCREEN // Extract Screens and screen prompts

	type public String L1,L2,L3,L4

	type Number et,P
	type String dx,dy,POS()

	// Get position table for screens
	do POS^I18NUTL("SYSDEV","1","DBTBL2D",.POS())
	
	// Init collating variable
	set L2=2,L3="" 
	
	// Collate thru Screens
	type DbSet ds=Db.selectDbSet("DBTBL2","LIBS='SYSDEV'","SID")
	while ds.next() do {
		type RecordDBTBL2 dbtbl2=ds.getRecord("DBTBL2")
		set L3=dbtbl2.sid
		// Write out screen description
		do WRTPHR(dbtbl2.desc,"^DBTBL("_L1_","_L2_","_L3_")",1,2,"DBTBL2","DESC")
		set L4=0
		do WRTPHR(dbtbl2.desc,"^DBTBL("_L1_","_L2_","_L3_","_L4_")",9,2,"DBTBL2","DESC")

		type DbSet ds1=Db.selectDbSet("DBTBL2D","LIBS='SYSDEV' AND SID=:L3","SEQ")
		while ds1.next() do {
			type RecordDBTBL2D dbtbl2d=ds1.getRecord("DBTBL2D")
			set L4=dbtbl2d.seq
			set P=""
			for  set P=POS(P).order() quit:P=""  do {
				type String OK
				
				set OK="F"
				// Get extractable elements for this DI
				if (dbtbl2d.dtype="*"),(dbtbl2d.name["@ooe") set OK="T"
				if (dbtbl2d.dtype="*"),(dbtbl2d.name["@H") set OK="T"
				if OK="F" quit
				
				// Get column number and graphical mode
				set dy=dbtbl2d.status\1000,dx=(dbtbl2d.status+0)#1000,et=((dbtbl2d.status).piece(",",1)).piece("#",2)
				
				// Write out nongraphical phrase
				if (et'=192) do WRTPHR(dbtbl2d.prompt,"^DBTBL("_L1_","_L2_","_L3_","_L4_")",11,2,"DBTBL2D","PROMPT",dy,dx)
				}
			}
		}

	quit
	
REPORT // Extract Reports and report prompts
	
	type public String L1,L2,L3,L4,L5

	type Number P
	type String dx,dy,POS()
	
	// Get position table for reports
	do POS^I18NUTL("SYSDEV","1","DBTBL5D",.POS()) 
	
	// Init collating variable
	set L2=5,L3="" 
	
	// Collate thru Reports
	type DbSet ds=Db.selectDbSet("DBTBL5H","LIBS='SYSDEV'","RID")
	while ds.next() do {
		type RecordDBTBL5H dbtbl5h=ds.getRecord("DBTBL5H")
		set L3=dbtbl5h.rid
		// Write out screen description
		do WRTPHR(dbtbl5h.desc,"^DBTBL("_L1_","_L2_","_L3_")",1,5,"DBTBL5H","DESC")
		do EXTPRMT^I18NPRMT

		type ResultSet rs=Db.select("GRP","DBTBL5DGC","LIBS='SYSDEV' AND RID=:L3","GRP")
		while rs.next() do {
			set L4=rs.getCol("GRP")
			type DbSet ds1=Db.selectDbSet("DBTBL5D","LIBS='SYSDEV' AND RID=:L3 AND GRP=:L4 AND ITMSEQ>100","ITMSEQ")
			while ds1.next() do {
				type RecordDBTBL5D dbtbl5d=ds1.getRecord("DBTBL5D")
				set L5=dbtbl5d.itmseq
				set P=""
				for  set P=POS(P).order() quit:P=""  do {
					// Get column number and graphical mode
					set dy=dbtbl5d.status\1000,dx=(dbtbl5d.status+0)#1000
					
					// Write out Report phrase
					do WRTPHR(dbtbl5d.prompt,"^DBTBL("_L1_","_L2_","_L3_","_L4_","_L5_")",7,5,"DBTBL5D","PROMPT",dy,dx)
					}
				}
			}
		}

	quit

WRTPHR(String phr,String globref,Number piece,Number dbtbltype,String uxfi,String uxdi,String orgln,String orgtb) //
	// Write out extracted  phrase to I18NEXT database

	type public Number WC

	type Boolean detex
	type Number phrtyp
	type String nrmphr
	
	set globref=globref.get()
	// Get phrasetype
	set phrtyp=$$PHRTYP^I18NNRM(phr,dbtbltype,uxfi,uxdi)
	if (phrtyp=4),(phr["/DES") set phr=$$getdes^I18NNRM(phr)
	
	// Calculate counters organized by dbtbltyp and phrasetype 
	do CALCNT
	if phrtyp=0 quit

	// if no global reference, make one
	if globref.isNull() set globref=$$getref(uxfi)

	// Noramlize based on phrtyp
	set nrmphr=$$NRMPHR^I18NNRM(phr,phrtyp)   
	if (nrmphr=" ")!(nrmphr="") quit
	
	// Internal record counter
	set WC=WC+1
	if WC#1000=0 write $$MSG^%TRMVT(WC_" Records Processed")
	
	// To protect us from the impossible
	set globref=globref_piece			
	
	// Write our detail phrase
	do DETPHR
	// Write out normalized phrase
	if 'detex do HDRPHR
	// Write our tech split words
	if (phrtyp<6),('detex) do HDRWRD

	quit
	
DETPHR // Write out a phrase rec to DataQwik filedef I18NEXTD(Detail)

	type public Boolean detex
	type public Date EXTDT
	type public Number dbtbltype,phrtyp
	type public String globref,nrmphr,orgtb,phr,uxdi,uxfi
	
	type RecordI18NEXTD i18nextd=Db.getRecord("I18NEXTD","EXTDT=:EXTDT,NORMPHR=:nrmphr,GLOBREF=:globref",1)
	set detex=i18nextd.getMode()
	if detex quit

	// Build detail phrase record
	set i18nextd.origphr=phr
	set i18nextd.ptype=phrtyp
	set i18nextd.ttype=0
	set i18nextd.orgtb=$S(orgtb.exists():orgtb,1:"")
	set i18nextd.dbtyp=dbtbltype
	set i18nextd.uxfi=uxfi
	set i18nextd.uxdi=uxdi
	do i18nextd.bypassSave()
	
	quit

HDRPHR // Write out a phrase rec to DataQwik filedef I18NEXTH(Header)
	
	type public Date EXTDT
	type public Number phrtyp
	type public String nrmphr

	type Boolean headex
	type Number PTcnt
	type String PT
	
	type RecordI18NEXTH i18nexth=Db.getRecord("I18NEXTH","EXTDT=:EXTDT,NORMPHR=:nrmphr",1)
	set headex=i18nexth.getMode()

	set i18nexth.phrcnt=$S(headex:i18nexth.phrcnt+1,1:1)
	set i18nexth.ttype=$S(headex:i18nexth.ttype,1:0)
	
	set PT=i18nexth.ptcnts
	set PTcnt=PT.piece(",",phrtyp)
	set PT.piece(",",phrtyp)=$S(PTcnt:PTcnt+1,1:1)  
	set i18nexth.ptcnts=PT	
	
	do i18nexth.bypassSave()
	
	quit
	
HDRWRD // Write out a word rec to DataQwik filedef I18NEXTH(Header)
	
	type public Date EXTDT
	type public String nrmphr,phrword()

	type Boolean exist
	type Number PTcnt
	type String phrw,PT

	set phrw=""
	kill phrword
	
	// Divide phrase into an array
	do WRDSPLIT(nrmphr,.phrword())
	
	// Collate thru word array just with valid words
	for  set phrw=phrword(phrw).order() quit:phrw=""  do:(phrw'?.NP_" "_$C(9)) {
		type RecordI18NEXTH i18nexth=Db.getRecord("I18NEXTH","EXTDT=:EXTDT,NORMPHR=:phrw",1)
		set exist=i18nexth.getMode()
		if 'exist set i18nexth.ttype=0
		set PT=i18nexth.ptcnts
		set PTcnt=PT.piece(",",10)
		set PT.piece(",",10)=PTcnt+1
		set i18nexth.ptcnts=PT
		do i18nexth.bypassSave()
		}
	
	quit
	
WRDSPLIT(String phr,String pw()) // Split incoming phrase into array 

	type Number i
	
	if (phr.get()).isNull() quit
 
	kill pw 
	set pw="" 
	
	// Cre arr pw(word)=piece in orig phrase 
	for i=1:1:phr.length(" ") set:phr.piece(" ",i)'="" pw(phr.piece(" ",i))=i 
	 
	quit
	 
CALCNT // Calculate counts

	type public Number dbtbltype,phrtyp
	type public String CNT(,)
	
	set CNT(dbtbltype,phrtyp)=CNT(dbtbltype,phrtyp).get()+1

	quit
	
cnt(Number i) // Internal array counter
	
	type public String CNT(,)

	type Number j,k

	set (j,k)=0	

	for  set j=CNT(i,j).order() quit:j=""  set k=k+CNT(i,j).get() 

	quit k
	 
getref(String uxfi) // Build global reference from the file id name
	
	type String globref

	if 'uxfi.exists() quit ""

	type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:uxfi",1)
	if dbtbl1.global.isNull() quit ""
	// seting the name of the global
	set globref=dbtbl1.glref_")"

	quit globref

END	// Build return message and hit the road

	type public Number WC
	type public String %DEBUG,CNT(,),ER,RM
	
	// displays counters
	if %DEBUG.exists() if %DEBUG ZWR CNT  write !,"Total= "_WC,!
	// Extracted: files ~p1, screens ~p2, reports ~p3, and tables ~p4
	set ER="W",RM=$$^MSG(5451,$$cnt(1),$$cnt(2),$$cnt(5),$$cnt(99))

	quit
	
GetKeys(String keys) //  private // Get non literal/numeric Keys

	type Number i
	type String list,x
	
	if keys.isNull() quit ""
	
	set list=""
	for i=1:1:keys.length(",") do {
		set x=keys.piece(",",i)
		//  Literal
		if x.extract()=$C(34) quit
		//  numeric
		if x=+x quit
		//  bad list value
		if x="" quit
		set list=list_","_x
		}

	quit list.extract(2,999)
	

vSIG()	quit "60477^65446^Pat Kelly^12395"	// Signature - LTD^TIME^USER^SIZE
