ACHIN		//;PBS -  - V2.0 - ACH Incoming processing software
	/*
	       ORIG:  Mike Winigrad (6969) - 12/05/86
	  CALLED BY:
	      CALLS:
	   PROJ #'S:  1628
	       DESC:  ACH formatting


	                    THIS ROUTINE IS TO BE COMPILED WITH TTXFMT
	                        DO NOT RUN THIS ROUTINE STANDALONE
	   GLOBALS -
	       READ:
	        SET:

	      INPUT:
	     OUTPUT:


	  ---- Revision History ------------------------------------------------
		
	   03/29/05 - Satyanas - 19687
	   	      Changed the Code for the below sections to fix the run time error 
	   	      while exectuing the Function TTXINI.

			RECCALL	: Declare IO and RECTYPE because of getting the undefined runtime error.
			
			UFILINIT: Removed the deprecated features.
			REC1	: Removed deprecated features.
			REC5	: Removed deprecated features.
			UBCHINIT: Removed the new declaration and changed Type to type.
			
			REC6	: Declare ACHSEC,REC because of getting the undefined run time error.
		  		  Added .get() method for the variable BCHHASH, because of it is throwing
		  		  the undefined runtime error.
		  		  
			REC7	: Removed the new declaration of achincda,A,DOD. Removed the deprecated
				  features of $$SCAJD.
				  
			REC8	: Removed the new declaration of X and redeclare as String. 
				  Added the .getMode() condition for getting the record of ACHINCB table.
				  
			REC9	: Declare CTL=0 at the end of this section.
			
			SETETC	: Removed the commented line and also removed the new declaration of rs.
			
			RECERR	: Changed the $G(CID) to CID.get().
	   
	   09/14/05 - Satyanas - 16675
	   	      Removed the Unscoped and deprecated methods Warnings and 
	   	      converted to PSL Standard.
	   	      	
	   12/02/03 - CARROLLJ - CR7239
		      Remove trn object from being passed to TTXFILE.

	   09/26/03 - CARROLLJ - 51630
		      Modified REC1 section to remove toArray.

	   02/28/02 - SCOTTC - 43583
			Convert to PSL.  Remove history prior to 2002.

	   01/15/02 - EDWARDSM - 48662
	              In UBCHINIT section, removed "+" before the $E in
	              "S TLO=+$E(REC,41,50)" and changed line to
	              "S TLO=$$RTB^%ZFUNC($E(REC,41,50))". Per NACHA document,
	              the in-clearing file may contain alpha or numeric
	              characters in this REC range, but the "+$E" will not read
	              alpha characters correctly. An "E" is read as an exponent
	              and causes an "%GTM-E-NUMOFLOW, Numeric overflow". Also
	              changed evaluation, "I 'TLO" to "I TLO=""". If "E" appears,
	              'TLO evaluation returns same Numeric overflow error.

	  ----------------------------------------------------------------------

	*/
	
	do RECCALL
	quit
	
	
RECCALL	// Record menu section

	// RECTYPE is defined in TTXFMT
		
	if RECTYPE=1 do REC1 quit
	if RECTYPE=5 do REC5 quit
	if RECTYPE=6 do REC6 quit
	if RECTYPE=7 do REC7 quit
	if RECTYPE=8 do REC8 quit
	if RECTYPE=9 do REC9 quit
	set ERR=10 do RECERR(1)
	quit

ALLREC	// All records section
	
	
	if RECCNT=1,RECTYPE'=1 do {
		set ERR=11 
		do RECERR(1)
		}
	quit
	

UFILINIT	// File intialization
	
	type public String BLOCK,EBCASC,KEY,LABEL,REC,RECORD
	
	set KEY="ACN.INC"

	type RecordUTBLTAPEFMT tapefmt=Db.getRecord("UTBLTAPEFMT","KEY=:KEY",1)
	if 'tapefmt.getMode() quit

	set (RECORD,TREC)=tapefmt.rsiz
	set (BLOCK,TBLCK)=tapefmt.bsiz

	if tapefmt.lab="L" set LABEL="LABEL"
	else  set LABEL="UNLABEL"

	if tapefmt.dtype="A" set EBCASC="ASCII"
	else  set EBCASC="EBCDIC"

	set TFMT=EBCASC_"/FIXED/"_LABEL_"/RECORD="_RECORD_"/BLOCK="_BLOCK
	quit
	

REC1	// File header record
	
	type String INCF
	
	set %DS=REC.extract(26,27)_"/"_REC.extract(28,29)_"/"_REC.extract(24,25)
	set TRANTIME=REC.extract(30,33)
	set TRANDATE=(%DS).toDate("MM/DD/YEAR")
	set CTL=1

	// Key 1 of [ACHINCD(A)]
	set FILEID=REC.extract(24,33)

	// Key 2 of [ACHINCD(A)]
	set BCHSEQ=0

	// Init totals
	set (FILHASH,FILCNT,FILCR,FILDR)=0
	
	// Set [ACHINCF]
	set INCF=$$FILE^ACHINC(REC,.FILEID)

	// Put record into ACHINCF 
	type RecordACHINCF existsfid=Db.getRecord("ACHINCF","FILEID=:FILEID",1)
	if 'existsfid.getMode() do {
	
		type RecordACHINCF achincf=Class.new("RecordACHINCF")
		set achincf.fileid=FILEID
		set achincf.fdesc=INCF.piece("|",1)
		set achincf.rectype=INCF.piece("|",2)
		set achincf.prio=INCF.piece("|",3)
		set achincf.immdest=INCF.piece("|",4)
		set achincf.immorig=INCF.piece("|",5)
		set achincf.trndate=INCF.piece("|",6)
		set achincf.trntime=INCF.piece("|",7)
		set achincf.fidmod=INCF.piece("|",8)
		set achincf.recsize=INCF.piece("|",9)
		set achincf.block=INCF.piece("|",10)
		set achincf.format=INCF.piece("|",11)
		set achincf.immdestnm=INCF.piece("|",12)
		set achincf.immorignm=INCF.piece("|",13)
		set achincf.refcode=INCF.piece("|",14)
		do achincf.bypassSave()
		}
		
	set UTBLETC=SRC.get()_"ETC"
		
	type RecordUTBLACHETC utblachetc=Db.getRecord("UTBLACHETC","KEY=:UTBLETC",1)
	if 'utblachetc.getMode() set UTBLETC="ACHETC"

	// First logical file
	if 'ORECTYPE.get() quit
	
	if ORECTYPE'=9 do {
		set ERR=12 
		do RECERR(1)
		}
	quit
	

REC5	// Set first section of ACHINCB
	
	set ACHINCB=$$BATCH^ACHINC(REC)
	
	// Batch header record
	if ORECTYPE'=1,ORECTYPE'=8 do {
		set ERR=51 
		do RECERR(1)
		}

	do INT^%DIR
	set %INST=%DIR
	
	set %DS=REC.extract(72,73)_"/"_REC.extract(74,75)_"/"_REC.extract(70,71) 
	set %JD=%DS.toDate("MM/DD/YEAR")
	if %JD<0 do {
		set ERR=52 
		do RECERR(1)
		}
		
	set EFD=%JD

	// Company ID
	set BCHID=REC.extract(41,50)
	do BCHINIT
	set BCHEFD=""
	set BCHSEQ=BCHSEQ+1

	// Key 3 of [ACHINCD(A)]
	set DTLSEQ=0

	quit
	

UBCHINIT	// User batch initialization
 	
	// Batch Hash Total
	set BCHHASH=0

	/* 
	The following variables preceded with ACH will be stored
	in the TSO field of following transactions.
	Company Discretionary Data
	*/

	set ACHCODIS=$$RTB^%ZFUNC(REC.extract(21,40))

	// Company ID
	set TLO=$$RTB^%ZFUNC(REC.extract(41,50))

	// Standard Entry Class
	set ACHSEC=$$RTB^%ZFUNC(REC.extract(51,53))
	
	// Company Entry Description
	set ACHCED=$$RTB^%ZFUNC(REC.extract(54,63))
	
	// Company Descriptive Date  
	set ACHCDD=$$RTB^%ZFUNC(REC.extract(64,69))
	
	// Originating DFI ID
	set ACHODFI=$$RTB^%ZFUNC(REC.extract(80,87))

	if (TLO.get() ="")!(Db.isDefined("CTBLACHID","ID=:TLO")) set TLO="ACH-"_TLO

	else  do {
		
		type RecordCTBLACHID achid=Class.new("RecordCTBLACHID")
		set achid.cname=REC.extract(5,20)
		set achid.id=TLO
		do achid.save()

		set TLO="ACH-"_%UserStation
		}

	/* 
	Set base TSO to be used for all transactions in this batch.
	Avoid UTSO here for efficiency.
	Company Name
	*/

	set ACHCO=$$RTB^%ZFUNC(REC.extract(5,20))
	set BCHTSO="ACHCO#"_ACHCO_"~ACHCODIS#"_ACHCODIS_"~ACHSEC#"_ACHSEC
	set BCHTSO=BCHTSO_"~ACHCDD#"_ACHCDD_"~ACHCED#"_ACHCED_"~ACHODFI#"_ACHODFI

	quit
	

UBCHEND	// User batch end

	quit
	

REC6	//
	
	type public String ACHSEC,REC
	
	// Standard Entry Class
	set ACHSEC=$$RTB^%ZFUNC(REC.extract(51,53))
	
	if ACHSEC'="DNE" do SETETC
	
	/* 
	ACH Death Notifications come in exactly like pre-notes, however
	the standard entry class on the batch header record is DNE.
	On PROFILE, death notices will be set up as a transaction which
	will reject (i.e. the posting program is line tag DNE^ACHIN,
	which just sets ER=1, RM to 'ACH Death Notification Received',
	and quits).  This will make these notices appear in EXC, so the
	bank is notified and can handle as they wish.
	*/
	
	else  set ETC=$S(REC.extract(2)=2:"DDNE",1:"SDNE")

	set CID=REC.extract(13,29)
	set TAMT=REC.extract(30,39)
	set TCMT=""

	// Receiving Bank ABA
	set ACHABA=$$RTB^%ZFUNC(REC.extract(4,12))

	if ACHSEC="POP" do {
		set ACHID=$$RTB^%ZFUNC(REC.extract(40,48))
		set POPC=$$RTB^%ZFUNC(REC.extract(49,52))
		set POPS=$$RTB^%ZFUNC(REC.extract(53,54))
		set TCMT=POPC_" "_POPS
		if (POPC="")!(POPS="") do {
			set ERR=63 
			do RECERR(0)
			}
		}
		
	// ID Number
	else  set ACHID=$$RTB^%ZFUNC(REC.extract(40,54))

	// Receiving Co.
	set ACHRCN=$$RTB^%ZFUNC(REC.extract(55,76))
	
	// Discretionary
	set ACHDD=$$RTB^%ZFUNC(REC.extract(77,78))
	
	// Trace No.
	set SPR=+REC.extract(80,94)

	set DTLSEQ=DTLSEQ+1

	set TSO=BCHTSO.get()_"~ACHID#"_ACHID_"~ACHRCN#"_ACHRCN_"~ACHDD#"_ACHDD
	
	if ACHSEC="POP" set TSO=TSO.get()_"~POPC#"_POPC_"~POPS#"_POPS
	
	set TSO=TSO_"~ACHABA#"_ACHABA_"~SIF#"_FILEID_"^"_BCHSEQ_"^"_DTLSEQ
	set FILCNT=FILCNT+1 
	set BCHCNT=BCHCNT+1

	/* 
	For batch and file hash totals, sum the Receiving DFI
	ID in each 6 record, maintaining only the lowest order
	10 digits (i.e. 1111222233334444 should be 2233334444)
	*/

	set BCHHASH=BCHHASH.get()+REC.extract(4,11)
	set FILHASH=FILHASH+REC.extract(4,11)
	set BCHHASH=BCHHASH.extract(BCHHASH.length()-9,BCHHASH.length())
	set FILHASH=FILHASH.extract(FILHASH.length()-9,FILHASH.length())

	// Credits
	if (REC.extract(3)=1)!(REC.extract(3)=2) do {
		set BCHCR=BCHCR+TAMT 
		set FILCR=FILCR+TAMT
		}
		
	// Debits
	if (REC.extract(3)=6)!(REC.extract(3)=7) do {
		set BCHDR=BCHDR+TAMT
		set FILDR=FILDR+TAMT
		}
	
	set AMT=TAMT/100
	set TAMT=AMT.roundDec(0,"")
	
	// File detail data to [ACHINCD]
	
	type RecordACHINCD existfbd=Db.getRecord("ACHINCD","FILEID=:FILEID,BCHSEQ=:BCHSEQ,DTLSEQ=:DTLSEQ",1)
	if 'existfbd.getMode() do {
	
		type RecordACHINCD achd=Class.new("RecordACHINCD")
		set achd.fileid=FILEID
		set achd.bchseq=BCHSEQ
		set achd.dtlseq=DTLSEQ
		set achd.rectype=6
		set achd.trncd=REC.extract(2,3)
		set achd.dfiid=REC.extract(4,11)
		set achd.ckd=REC.extract(12)
		set achd.acctno=CID
		set achd.amount=TAMT
		set achd.idno=ACHID
		set achd.name=ACHRCN
		set achd.discdata=ACHDD
		set achd.addenda=REC.extract(79)
		set achd.trace=SPR

		do achd.save()
		}

	set ADNDACNT=0
	
	/*
	If there are no addenda records, then file.  Otherwise,
	wait until the first 7 is processed.
	*/

	// No addenda records
	if 'REC.extract(79) do TTXFILE
	quit
	

REC7	// Addendum record
	
	if ORECTYPE'=6,ORECTYPE'=7 do {
		set ERR=12 
		do RECERR(1)
		}

	set FILCNT=FILCNT+1
	set BCHCNT=BCHCNT+1
	set ADNDACNT=ADNDACNT+1

	// Only file 9999
	if ADNDACNT>9999 quit

	// Addenda type code
	set ACHFIC=REC.extract(2,3)

	// First 7 rec used in TTX
	if ADNDACNT=1 do REC7A

	// File addendum data to [ACHINCDA]
	// Normal
	if ACHFIC="05" do { quit
		
		// Use addenda sequence # as key 4 of [ACHINCDA]
		
		type RecordACHINCDA achincda=Class.new("RecordACHINCDA")
		set achincda.fileid=FILEID
		set achincda.bchseq=BCHSEQ
		set achincda.dtlseq=DTLSEQ
		set achincda.aseq=+ REC.extract(84,87)
		set achincda.arectype=7
		set achincda.atc=ACHFIC
		set achincda.ainfo=$$RTB^%ZFUNC(REC.extract(4,83))

		do achincda.save()
		}

	// Return
	if ACHFIC=99 do {
		type String A
		set A=$$RTB^%ZFUNC(REC.extract(36,79))
		
		// Use addenda sequence # as key 4 of [ACHINCDA]
			
		type RecordACHINCDA achincda=Class.new("RecordACHINCDA")
		set achincda.fileid=FILEID
		set achincda.bchseq=BCHSEQ
		set achincda.dtlseq=DTLSEQ
		set achincda.aseq=ADNDACNT
		set achincda.arectype=7
		set achincda.atc=ACHFIC
		set achincda.ainfo=A
		set achincda.aretres=REC.extract(4,6)
		set achincda.aorigtrace=+REC.extract(7,21)
		
		if REC.extract(22,27) do {
			type String DOD
			
			set DOD=REC.extract(24,25)_"/"_REC.extract(26,27)_"/"_REC.extract(22,23)
			set achincda.adod=DOD.toDate("MM/DD/YEAR")
			}
			
		set achincda.art=REC.extract(28,35)

		do achincda.save()
		}

	quit
	

REC7A	/* 
	Set TCMT for the TTX record based on the last 6 record and file.
	Based on the file addenda code, the record layout changes.
	For addenda code 02, file Reg E information in teller comment.
	*/
	
	if ACHFIC="02" do {
		
		// terminal location
		set TCMT=$$RTB^%ZFUNC(REC.extract(36,62)_",")
		
		// terminal city
		set TCMT=TCMT_$$RTB^%ZFUNC(REC.extract(63,77)_",")
		
		// terminal state
		set TCMT=TCMT_$$RTB^%ZFUNC(REC.extract(78,79))
		}

	if ACHFIC="05" do {
		
		// pmt related
		set TCMT=$$RTB^%ZFUNC(REC.extract(4,83))
		}

	do TTXFILE
	quit
	

REC8	// Batch control record
	
	type String X
	
	if ORECTYPE '= 6,ORECTYPE '= 7 do {
		set ERR = 81 
		do RECERR(1)
		}
		
	if +REC.extract(5,10)' = BCHCNT do {
		set ERR = 82 
		do RECERR(0)
		}
		
	if +REC.extract(21,32)' = BCHDR do {
		set ERR = 83 
		do RECERR(0)
		}
		
	if +REC.extract(33,44)' = BCHCR do {
		set ERR = 84 
		do RECERR(0)
		}
		
	if +REC.extract(11,20)' = +BCHHASH do {
		set ERR = 85 
		do RECERR(0)
		}
		
	// Set DR & CR in ACHINCB
		
	set X = $$BATCHTR^ACHINC(REC,ACHINCB)
	set DRTOT = X.piece("|",14)
	set CRTOT = X.piece("|",15)
		
	type RecordACHINCB achincb = Db.getRecord("ACHINCB","FILEID = :FILEID,BCHSEQ = :BCHSEQ",1)
	if achincb.getMode() do {
		set achincb.drtot = DRTOT
		set achincb.crtot = CRTOT
		do achincb.save()
		}
		
	do BCHEND
	quit
	

REC9	// File control record
	

	if ORECTYPE=9 quit
	
	if ORECTYPE '= 8 do {
		set ERR = 91 
		do RECERR(1)
		}
		
	if +REC.extract(14,21)' = FILCNT do {
		set ERR = 92 
		do RECERR(1)
		}
		
	if +REC.extract(32,43)' = FILDR do {
		set ERR = 93 
		do RECERR(1)
		}
		
	if +REC.extract(44,55)' = FILCR do {
		set ERR = 94 
		do RECERR(1)
		}
		
	if +REC.extract(22,31)' = +FILHASH do {
		set ERR = 95 
		do RECERR(0)
		}
		
	
	/* Set totals for phyiscal file counts (one phyiscal file
	may have multiple logical files.) . */

	set PFILCNT = PFILCNT.get() + FILCNT
	set PFILDR = PFILDR.get() + FILDR
	set PFILCR = PFILCR.get() + FILCR
	set CTL = 0
		
	quit
	
	
SETETC		// Detail record
	
	if ORECTYPE '= 5,ORECTYPE '= 6,ORECTYPE '= 7 do {
		set ERR = 61 
		do RECERR(1)
		}

	set ETC = ""
	set KEY = REC.extract(2,3)
	
	type ResultSet rs = Db.select("DESC","UTBLACHETC","KEY = :KEY")
	if rs.next() set ETC = rs.getCol(1)

	// Invalid transaction code
	if ETC = "" do {
		set RM = $$^MSG("3592")
		set ER = 1
		}

	// Make sure it is defined in the Transaction code table.	
	else  if 'Db.isDefined("TRN","ETC") do {
		set RM = $$^MSG("3592")
		set ER = 1
		}

	quit
	

RECERR(ABORT)	// Record error
	
	set ABORT = ABORT.get()

	if ERR.get() do {
			
		// Invalid record type code
		if ERR = 10 set ERRMSG = $$^MSG("5136") quit
		
		// Missing file header record
		if ERR = 11 set ERRMSG = $$^MSG("3038") quit
		
		// Improperly sequenced records
		if ERR = 12 set ERRMSG = $$^MSG("5137") quit
	
		// Missing batch control record
		if ERR = 51 set ERRMSG = $$^MSG("5138") quit
		
		// Invalid batch effective date
		if ERR = 52 set ERRMSG = $$^MSG("5139") quit

		// Detail record errors
		// MISSING BATCH HEADER RECORD"
		if ERR = 61 set ERRMSG = $$^MSG("5140") quit
		
		// DEATH NOTICE RECEIVED ACCOUNT p~
		if ERR = 62 set ERRMSG = $$^MSG("5141",CID.get()) quit
		
		// MISSING POP TERMINAL CITY OR STATE p~
		if ERR = 63 set ERRMSG = $$^MSG("5142",CID.get()) quit
	
		// Batch control record errors
		// MISSING DETAIL RECORDS
		if ERR = 81 set ERRMSG = $$^MSG("5143") quit
		
		// BATCH ITEM COUNT DOES NOT MATCH CONTROL RECORD
		if ERR = 82 set ERRMSG = $$^MSG("5144") quit
		
		// BATCH DEBITS DO NOT MATCH CONTROL RECORD
		if ERR = 83 set ERRMSG = $$^MSG("5145") quit
		
		// BATCH CREDITS DO NOT MATCH CONTROL RECORD
		if ERR = 84 set ERRMSG = $$^MSG("5146") quit
		
		// BATCH HASH TOTALS DO NOT MATCH CONTROL RECORD
		if ERR = 85 set ERRMSG = $$^MSG("5147") quit
	
		// File control record errors
		// MISSING BATCH CONTROL RECORD
		if ERR = 91 set ERRMSG = $$^MSG("5138") quit
		
		// FILE ITEM COUNT DOES NOT MATCH CONTROL RECORD
		if ERR = 92 set ERRMSG = $$^MSG("5144") quit
		
		// FILE DEBITS DO NOT MATCH CONTROL RECORD
		if ERR = 93 set ERRMSG = $$^MSG("5145") quit
		
		// FILE CREDITS DO NOT MATCH CONTROL RECORD
		if ERR = 94 set ERRMSG = $$^MSG("5146") quit
		
		// FILE HASH TOTALS DO NOT MATCH CONTROL RECORD
		if ERR = 95 set ERRMSG = $$^MSG("5147") quit
	}
	
	// Process error
	if ABORT do ABORT^TPINERR quit
	
	do ^TPINERR
	quit
	

DNE	// Death Notification 'posting' program
	/*
	   This line tag serves as a 'posting' program to reject
	   death notices transactions so they appear in the exception report.
	   Tran codes DDNE and SDNE will call this line tag.
	*/
	
	set ER = 1
	set RM = $$^MSG("5141","ACH")
	quit
	

PREOPEN	//

	quit
	
POSTREAD //
	quit

	// * Do not delete dummy line tags*

%STOPLOD	// Stop ^ULODTMPL from this point on down

	do BCHINIT
	quit
	
		
BCHINIT		// Dummy line reference for GT.M

	do BCHEND
	quit
	
	
BCHEND		// Dummy line reference for GT.M

	quit
	

TTXFILE		// Dummy line reference for GT.M

	quit
	
	

vSIG()	quit "60354^39355^Sethy, Satyanarayan^15562"	// Signature - LTD^TIME^USER^SIZE
