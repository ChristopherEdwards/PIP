SWFTEDIT	
	/*
		ORIG: YANGR - 03/17/94
		Procedure ID: SWFTEDIT
		DESC: SWIFT Character Checking & Editing Routine
	
	  ---- Revision History -------------------------------------------------

	02/10/03 - GRAY - 51349
		Corrected problem found by PSL compiler.

	11/11/02 - YENDAPALLIS -43583
                PSL conversion clean up.
	
	01/09/01 - YENDAPALLIS - 43583
		Converted the routine to PSL

	03/05/01 - Allan Mattson - 44179
		Modified subroutine CHECK to use $TR[ranslate] to determine
		if there are illegal characters in the input string.

		Restructured the program to allow the string of acceptable
		characters ('VALID') to be returned to the calling routine
		so it does not have to be constructed each time.  Note
		that labels CHECKUP, BUILDST, MSG1 amd MSG2 are called
		externally.
	-----------------------------------------------------------------------
	*/
	quit


Public CHECKUP	    //Public; External entry point to check single field

	do CHECK(X)

	quit 
	


Public CHECK(X,VALID)	//Public; External entry point if called multiple times

	/*
	   1.Check the first character in the user entered field
	     It MUST NOT BE BE "-" or ":"
	   2.Build the VALID character string, it is made by two parts:
	     VALID1: are these standard SWIFT characters.
	     VALID2: are these translatable characters from ^UTBL("TRANSLATED")
	     VALID=VALID1+VALID2
	   3.Compare the input string with the VALID string, the input will be
	     rejected if the characters of input are not from the VALID string.
	
	*/

	set ER=0
	if X="" quit 
	
	// The first character must not be ~p1 or ~p2
	if ($E(X,1)="-")!($E(X,1,1)=":") do Runtime.setErrMSG("SWIFT",7299,"-~:") quit   

	if $G(VALID)="" do {
		new INVALID,VALID1,VALID2
		
		do BUILDST 
		do VALID2
		set VALID=VALID1_VALID2
		}
	
	new Y
	set Y=$TR(X,VALID,"")

	//Invalid Input Character
	if $L(Y) do Runtime.setErrMSG("SWIFT",7239) set RM=RM_" "_Y quit   

	//Input can not contain only spaces
	if $TR(X," ","")="" do Runtime.setErrMSG("SWIFT",7241) quit       
	quit 
	


Public MSG1(X,VALID)	//Public; Called by EFT filer to validate message format
	
	
	/*

	Validate foreign payment message format (first message MSGFP1)
	
	Position 1      /
	Position 2-9    Text (1 to 8 characters)
	Position 10+    / then text or numeric
	
	Valid format: 	/abc
			/abcdefgh/1234
			/OCMT/INC100000,/
	*/
	
	if X="" quit 
	do CHECK(X,.VALID) quit:ER 
	

	/*
	Check to see if code OCMT fits one of the two formats:
		/OCMT/CUR9999,99/
		/OCMT/CUR9999,99//CHGS/CUR9999,99/
	*/

	if X["/OCMT/" do { quit             
		if $L(X,"/")=4,X?1"/OCMT/"3U.E1"/" quit 
		if $L(X,"/")=7,X?1"/OCMT/"3U.E1"/"1"/CHGS/"3U.E1"/" quit 
		do ERR
		}
	
	// has more than 2 of "/"
	if $L(X,"/")>3 do ERR quit             

	// /text/...
	if '(X?1"/"1.8A1"/".E) do ERR quit   
	quit 
	


Public MSG2(X,VALID)	//Public; Called by EFT filer to validate message format
	
	/*
	
	Validate foreign payment message format (messages MSGFP2-MSGFP6)
	
	Position 1 	/
	Position 2-9 	Text (0 to 8 characters)
	Position 10+ 	/ then text or numeric
	
	Valid format:   /abc/
			/abcdefgh/1234
			//ABC
	*/
	

	if X="" quit 
	
	do CHECK(X,.VALID) quit:ER 
	
	/*
	Check to see if code OCMT fits one of the two formats:
		/OCMT/CUR9999,99/
		/OCMT/CUR9999,99//CHGS/CUR9999,99/
	*/

	if X["/OCMT/" do { quit               
		if $L(X,"/")=4,X?1"/OCMT/"3U.E1"/" quit 
		if $L(X,"/")=7,X?1"/OCMT/"3U.E1"/"1"/CHGS/"3U.E1"/" quit 
		do ERR
		}

	/*
	Check to see if code CHGS fits the format:
		/CHGS/CUR9999,99/
	*/

	if X["/CHGS/" do { quit               
		if $L(X,"/")=4,X?1"/CHGS/"3U.E1"/" quit 
		do ERR
		}
	
	// More than 2 of /
	if $L(X,"/")>3 do ERR quit             
	
	// has "/" after 10th character
	if $E(X,11,999)["/" do ERR quit 
	
	// if neither "/xxx/" nor "//"
	if '((X?1"/".8A1"/".E)!(X?2"/".E)) do ERR quit 
	
	quit 



Public BUILDST	//

	/*
	   1. Build up the standard SWIFT character string VALID1.
	   2. Build up the SWIFT fatal error string INVALID.
	
	  I18N=OFF
	*/

	set VALID1="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/-?:().,'+ "
	
	set INVALID="!""#$%&*;<=>@[\]^-`"
	//I18N=ON

	quit 
	

VALID2	//

	/*
	Build up the acceptable character string VALID2 by go through
	the global ^UTBL("TRANSLATE")
	*/
	
	new P,X
	
	set VALID2=""

	// type ResultSet rs=Db.select("TRANS","UTBLSWCHTR")   SPG 02/10/03
	type ResultSet rs=Db.select("SEQ","UTBLSWCHTR")	     //SPG 02/10/03
	if 'rs.isEmpty() while rs.next() do {
		set X=rs.getCol(1)
		
		/*
		This line of code existed in the original code but during
		conversion we could'nt see how pieces 2-15 would exist in db ( they have no
		column name so UTBL001 users couldn't enter data for them.) The line of code
		that we will use will be set VALID2=VALID2_rs.getCol(1) since it will be
		returned in the result set.
		*/

		//for P=1:2:15 set VALID2=VALID2_$P(X,"|",P)
		}


	quit 
	
ERR	// Invalid format ~p1
	
	set ER=1 do Runtime.setErrMSG("SWIFT",1350,X) 

	quit 
 #OPTION ResultClass ON
Public String vSIG()	quit "59886^43613^Sanchez SCM Administrator^4740"	// Signature - LTD^TIME^USER^SIZE
