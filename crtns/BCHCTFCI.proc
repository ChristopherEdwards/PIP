BCHCTFCI //Batch BCHCTFCID - The CTF Dayend Assessment
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 12:45 - shetyes
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHCTFCID Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 set vBCHSTS=$$STATUS^BCHUTL("BCHCTFCID")
 if vBCHSTS=1 set ER=1,RM=$$^MSG(3410) quit
 if vBCHSTS=2 set ER=1,RM=$$^MSG(3414) quit
 if vBCHSTS=0 set %BatchRestart=1
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit do EXIT^BCHUTL("BCHCTFCID") quit
 do JOBMGR^BCHUTL(%FN,"BCHCTFCID",.vINPUT)
 do ^JOBMGR(.vINPUT)
 do EXIT^BCHUTL("BCHCTFCID")
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(CTFPLN) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHCTFCID","*","",CTFPLN.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 if %BatchRestart,$$CHKLOG^BCHUTL(%SystemDate,%FN,"BCHCTFCID",CTFPLN.get()) do { quit
 do LOG^BCHUTL(%SystemDate,%FN,"BCHCTFCID",CTFPLN.get(),"Record already processed")
 }
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,CTFPLN)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHCTFCID","*","",CTFPLN.get(),"",et)
 }
 do UPDLOG^BCHUTL(%SystemDate,%FN,"BCHCTFCID",CTFPLN.get(),vCONTEXT)
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,CTFPLN) //
	// Process the account 
	new rs,AMOUNT,CMTH,DATA,EXC,NPLIF,NPYTD,OCALC,OCALCF,OCOA,OCCFOA,ORGAMT,OPYTD,OPLIF,PAMT

	set CID=CTFPLN.piece("|",2)
	set CTFPLN=CTFPLN.piece("|",1)

	set DATA=Db.getOneRow("DAYCALC,DAYCALCF,DCOA,DCCFOA,PYTD,PLIF","CTFPLNCID","CID,CTFPLN")

	set EXC=0
	set ER=0
	set OCALC=$P(DATA,$C(9),1)
	set OCALCF=$P(DATA,$C(9),2)
	set OCOA=$P(DATA,$C(9),3)
	set OCCFOA=$P(DATA,$C(9),4)
	set OPYTD=$P(DATA,$C(9),5)
	set OPLIF=$P(DATA,$C(9),6)

	set CMTH=Db.getOneRow("CMTH","UTBLCTFPLN","CTFPLN")

	if OCALC<0 do { quit:ER
		set ER=0
		do Db.update("CTFPLNCID","DAYCALC=0,DCOA=0","CID=:CID AND CTFPLN=:CTFPLN") 
		set RM=$$^MSG(4821,OCALC) do EXC 	//DAYCALC value is negative, no fee assessed
		}

	if OCALCF<0 do { quit:ER
		set ER=0 	
		do Db.update("CTFPLNCID","DAYCALCF=0,DCCFOA=0","CID=:CID AND CTFPLN=:CTFPLN")
		set RM=$$^MSG(4822,OCALCF) do EXC 	//DAYCALCF is negative
		}

	if (OCALCF'>0)&(OCALC>0) do { quit:ER
		set ER=0
		set AMOUNT=OCALC
		set ORGAMT=OCOA
		if ORGAMT<0 set ORGAMT=ORGAMT*(-1)
		do TRANSPOST(AMOUNT) quit:EXC
		if 'CMTH do Db.update("CTFPLNCID","DAYCALC=0,DCOA=0","CID=:CID AND CTFPLN=:CTFPLN")		
		if CMTH do {
			set NPYTD=AMOUNT+OPYTD
			set NPLIF=AMOUNT+OPLIF
			do Db.update("CTFPLNCID","DAYCALC=0,DCOA=0,PYTD=:NPYTD,PLIF=:NPLIF","CID=:CID AND CTFPLN=:CTFPLN")
			quit
			}
		}

	if (OCALC>0)&(OCALCF>0) do { quit:ER
		set ER=0
		set AMOUNT=OCALC-OCALCF
		if OCOA<0 set OCOA=OCOA*(-1) 	
		set ORGAMT=OCOA-OCCFOA
		if ORGAMT<0 set ORGAMT=ORGAMT*(-1)
		if AMOUNT'>0 do { quit:ER
			if 'CMTH do Db.update("CTFPLNCID","DAYCALC=0,DAYCALCF=0,DCOA=0,DCCFOA=0","CID=:CID AND CTFPLN=:CTFPLN")
			if CMTH do { quit:ER
				set PAMT=AMOUNT*(-1)	
				do Db.update("CTFPLNCID","DAYCALC=0,DCOA=0,DCCFOA=:ORGAMT,DAYCALCF=:PAMT","CID=:CID AND CTFPLN=:CTFPLN")
				}
			}
		if AMOUNT>0 do { quit:ER
			do TRANSPOST(AMOUNT) quit:EXC	 
			if 'CMTH do Db.update("CTFPLNCID","DAYCALC=0,DAYCALCF=0,DCOA=0,DCCFOA=0","CID=:CID AND CTFPLN=:CTFPLN")
			if CMTH do { quit:ER 	
				set NPYTD=AMOUNT+OPYTD
				set NPLIF=AMOUNT+OPLIF
				do Db.update("CTFPLNCID","DAYCALC=0,DAYCALCF=0,DCOA=0,DCCFOA=0,PYTD=:NPYTD,PLIF=:NPLIF","CID=:CID and CTFPLN=:CTFPLN")
				quit
				}	
			}
		} 
		quit

TRANSPOST(AMOUNT)	// Post transaction

	new offtso,prodctl,rec,tamt,ts,tso,DRETC,ETC,EXPGL,GLCR,GLDR,MTS,MTSP,MTSPROCF,PAYGL,PLANID,SUSGL,TYPE

	set tamt=AMOUNT
	type TranSet ts=Class.new("TranSet")

	set rec=Db.getOneRow("EXPGL,PAYGL,SUSGL,MTSPROCF","UTBLCTFPLN","CTFPLN")
	set EXPGL=$P(rec,$C(9),1)
	set PAYGL=$P(rec,$C(9),2)
	set SUSGL=$P(rec,$C(9),3)
	set MTSPROCF=$P(rec,$C(9),4)

	type RecordDEP dep
	set dep=Db.getRecord("DEP","CID")
	set TYPE=dep.type 
	set CRCD=dep.crcd
	set BRCD=dep.boo
	set ACN=dep.acn

	/*
	Get MTS from CIF. Process transaction based on MTSPROCF	and customer's
	Miscellaneous Tax Status
	*/

	set MTS=Db.getOneRow("MTS","CIF","ACN")
	if $g(MTS)="" set MTSP=""	
	else  set MTSP=Db.getOneRow("MTSP","UTBLMTSO","MTS")

	if MTSP'="",MTSPROCF=1 do {
		if MTSP'=1 set UTSO("CTFPLN")=CTFPLN_"#"_OCALC_"#"_tamt_"#"_ORGAMT  //standard or petitioning
		else  set UTSO("CTFPLN")=CTFPLN_"#"_OCALC_"#"_0_"#"_ORGAMT  	 //exempt
		}
	else  set UTSO("CTFPLN")=CTFPLN

	do IN^UTSO(.UTSO,.tso)
	set offtso=$p(tso,"#",1,2) 	//Save TSO for G/L offsets

	if tamt<0 set tamt=tamt*-1
	set TCMT=$G(TCMT)


	/*
	Determine how CTF's will be assessed based on the Collection Method
	(CMTH) on the plan. If CMTH=0, Debit the Expense G/L account and credit
	appropriate G/L.  If CMTH=1, Debit account balance.
	*/

	if MTSPROCF,MTSP=1 quit  	//Exepmt customer, HIST journal entry

	if CMTH=0 do {
		//Debit EXPGL
		set PLANID=CTFPLN
		set ETC="",DRETC="MDR"	  
		set GLDR=EXPGL,GLCR=""
		set DRCR=0
		do BLDTOT(.dep)
		}
	else  do {			
		type RecordPRODCTL prodctl 	
		set prodctl=Db.getRecord("PRODCTL","TYPE")

		set ETC=prodctl.drctfpln	  
		do CRTTX(.ts,ETC,tamt,CID,tso,TCMT)

		}

	if CMTH,ETC="" do { quit
		new par,%LIBS,FID,DI

		set %LIBS="SYSDEV"
		set FID="PRODCTL"
		set DI="DRCTFPLN"
		set par=TYPE_"~"_Db.getOneRow("DES","DBTBL1D","%LIBS,FID,DI")
		do Runtime.setErrMSG("DEP",2268,par)
		do EXC
		}

	/*
	Set G/L offsets. For the petitioning customer, funds will be credited 
	to a Suspense G/L account when MTSPROCF is set.
	*/

	if MTSPROCF,MTSP=2 do {		//Petitioning
		set GLCR=SUSGL	
		set PLANID=CTFPLN_"_S" 
		}
	else  do {			//Process any other transactions
		set GLCR=PAYGL		
		set PLANID=CTFPLN_"_P"
		}
	set ETC="MCR"
	set (GLDR,DRETC)=""
	set DRCR=1

	do BLDTOT(.dep)

	set par("OPTION")=2    // Process transactions; update database
	set par("IPMODE")=3     // System generated
	do ts.postTSet(%SystemDate,BRCD,.par) 
	
	//Check status of transaction.  Log all errors/exceptions in DAYENDEXC
	if ts.status["1" set EXC=1 do EXC quit

	quit


CRTTX(TranSet ts,ETC,tamt,CID,tso,TCMT)

	/*
 
	Create TTX Global
 
	ETC   -   External Transaction Code.
	tamt  -   Transaction Amount.
	CID   -   Account Number.
	tso   -   Transaction Source.
	TCMT  -   Transaction Comment.
 
	*/
 
	new ITC
	new trn
	type RecordTRN trn
	set trn=Db.getRecord("TRN","ETC")
	set ITC=trn.itc
 
	new ttx
	type RecordTTX ttx=Class.new("RecordTTX")
 
	set ttx.cid=CID
	set ttx.itc=ITC
	set ttx.etc=ETC
	set ttx.tamt=tamt
	set ttx.efd=%SystemDate
	set ttx.tlo=%UserStation
	set ttx.tso=tso
	set ttx.tcmt=TCMT
	set ttx.crcd=CRCD
 
	set x=ts.copyTran(ttx)
 
	quit

BLDTOT(RecordDEP dep) 	//For G/L offsets 

	/*
	Build TMPBCHOFF record with standard information for posting a G/L 
	offset.  Update the record with the amount of the transaction.  If 
	the record already exists, update it with appropriate transaction
	amount.
	*/

	new tso,BCHID,CC,CRCD,GLSC,JOB,TYPE

	set tso=offtso
	set BCHID="BCHCTFCID"
	set CC=dep.CC
	set CRCD=dep.CRCD
	set GLSC=dep.GLSC
	set JOB=%ProcessID
	set TYPE=dep.TYPE

	 //Build new G/L offset if one does not exist 
	if 'Db.isDefined("TMPBCHOFF","TJD,BCHID,JOB,PLANID,CRCD,TYPE,GLSC,CC") do {
 
		do BDOFFSET^BCHSOURC("BCHCTFCID",PLANID,CRCD,TYPE,GLSC,CC,GLDR,GLCR,DRETC,ETC,TCMT,tso)
		}
	//Update record with the amount from this transaction
	do UPOFFSET^BCHSOURC("BCHCTFCID",PLANID,CRCD,TYPE,GLSC,CC,DRCR,tamt)
 
	quit

JNLQRY(CTFPLN,CID)	// determine whether hist journal entry for exempt
			// customers is necessary
	
	new dep,rec,ACN,AMOUNT,CMTH,MTS,MTSP,MTSPROCF

	if '$D(OCALC)!('$D(OCALCF)) quit 0

	if OCALC<0 quit 0		// daycalc amount is less than 0

	set AMOUNT=OCALC-OCALCF
	if AMOUNT'>0 quit 0		// carry forward credit exceed daycalc

	set rec=Db.getOneRow("CMTH,MTSPROCF","UTBLCTFPLN","CTFPLN")
	set CMTH=$P(rec,$C(9),1)
	set MTSPROCF=$P(rec,$C(9),2)
	
	if MTSPROCF'=1 quit 0		// The CTF plan's mtsprocf flag is off
	if CMTH=0 quit 0		// The CTF plan collects from an expense G/L

	type RecordDEP dep
	set dep=Db.getRecord("DEP","CID")
	set ACN=dep.acn

	set MTS=Db.getOneRow("MTS","CIF","ACN")
	if $g(MTS)="" quit 0		// cif.mts not set on customer

	set MTSP=Db.getOneRow("MTSP","UTBLMTSO","MTS")

	if MTSP'=1 quit 0		// UTBLMTSO.MTSP value is not exempt

	quit 1		// plan is set to process MTS, and customer MTS value 
			// is set for exempt processing

JNLTSO(CTFPLN)

	new tso,ORGAMT,UTSO

	if (OCALCF'>0)&(OCALC>0) do { quit:ER
		set ORGAMT=OCOA
		if ORGAMT<0 set ORGAMT=ORGAMT*(-1)
		}

	if (OCALC>0)&(OCALCF>0) do { quit:ER
		if OCOA<0 set OCOA=OCOA*(-1) 	
		set ORGAMT=OCOA-OCCFOA
		if ORGAMT<0 set ORGAMT=ORGAMT*(-1)
		} 

	else  set UTSO("CTFPLN")=CTFPLN_"#"_OCALC_"#"_0_"#"_ORGAMT

	do IN^UTSO(.UTSO,.tso)

	quit tso

EXC	// Log error to DAYENDEXC

	// reset ER to prevent batch "catch" from rolling back transaction
	set ER=0

	if $G(ET)="" set ET=$G(RM)
	do LOG^UTLEXC($T(+0),"*",,$G(CID)_","_$G(CTFPLN),$G(%ZTSEQ),$G(ET))
	kill ET,%ZTSEQ
	quit
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
	// Loop through vINPUT and get each record to pass to vPROC
	new CID,CTFPLN,DATA,THRREC

	set THRREC=1
	set DATA=vINPUT.piece($C(9),THRREC)
	
	while (DATA'="") do { quit:ER
		do vPROC(DATA) if ER quit
		//next record
		set THRREC=THRREC+1
		set DATA=vINPUT.piece($C(9),THRREC)
	}

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
	/*
	The scheduler controls the flow of data to the threads based the 
	DAYENDCTFPLN and XCTFPLNCID indexes.  It loops through DAYENDCTFPLN
	for a plan, and through XCTFPLNCID to fetch accounts under each plan.
	With this data, it builds the vINPUT string to pass to the threads.  

 	Within each record in vINPUT:
	Piece 1: CTFPLN  Piece 2: CID
	vINPUT is limited to 32000 bytes.  The last record not processed will
	be stored in vBUFOVFL for the next thread.
	*/

	new CID,CTFPLN,DAMND,LEN

	set LEN=0
	set vINPUT=""
	set DAMND=%SystemDate

	//Get previous record if overflow occured
	set vBUFOVFL=$G(vBUFOVFL)
	if (vBUFOVFL=""),('FIRST) quit	
	set FIRST=0

	set CTFPLN=$P(vBUFOVFL,"|",1)
	set CID=$P(vBUFOVFL,"|",2)

	//Get next CTF plan
	type Public ResultSet vRESULT
	if '$D(keylist) while vRESULT.next() set keylist(vRESULT.getCol(1))=""
	if vBUFOVFL="" set CTFPLN=keylist(CTFPLN).order()
	while (CTFPLN'="") do {  quit:(vBUFOVFL'="")	
	
		// Get all accounts under plan
		type ResultSet ctfpln=Db.select("CID","CTFPLNCID","CTFPLN=:CTFPLN AND DAYCALC>0 AND CID>:CID")
		while ctfpln.next() do { quit:CID=""!(vBUFOVFL'="")
			set CID=ctfpln.getCol("CID")
			new ROW
		 	set vBUFOVFL=""
			set ROW=CTFPLN_"|"_CID_$C(9)
			set LEN=LEN+$L(ROW)
			if LEN>32000 set vBUFOVFL=ROW quit
			set vINPUT=vINPUT_ROW
			}

		if vBUFOVFL="" set CTFPLN=keylist(CTFPLN).order()

		}

	set vINPUT=$E(vINPUT,1,$L(vINPUT)-1)
	quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	//Initialize batch teller
	do SOURCE^BCHSOURC("BOFF","CTFTL",.%UserID,.BRCD,.%UserClass)
	if ER set %BatchExit=1 quit
	set XTJD=%SystemDate


 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("DISTINCT CTFPLN","UTBLCTFPLN","DAMND=:XTJD")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	do SOURCE^BCHSOURC("BOFF","CTFTL",.%UserID,.BRCD,.%UserClass)
	if ER set %BatchExit=1 quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
	set FIRST=1

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
	// Update dates on CTF plans.

	new CTFPLN,DAMND,FRE,LDT,NDT

	set CTFPLN=""
	set DAMND=%SystemDate
	set LDT=%SystemDate
	type DbSet ds=Db.selectDbSet("UTBLCTFPLN","DAMND=DAMND AND AMTH='2'")
	while ds.next() do {
		type RecordUTBLCTFPLN ctfpln=ds.getRecord("UTBLCTFPLN")
		if 'ctfpln.damfreQ quit
		set NDT=$$NJD^UFRE(LDT,ctfpln.damfreq)
		set ctfpln.damld=LDT
		set ctfpln.damnd=NDT
		do ctfpln.save()
	}

	//Post offset transaction. 
	do OFFSET^TTXBLD(%SystemDate,BRCD,%UserID,"BCHCTFCID")

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
