LNPO2
	/*
	   Calculates components of loan payoff amounts
	        ORIG:  Chuck Hardy (6721) - 02/25/86
	       DESC: Calculates components of loan payoff amounts.
	             Part 1 of 2 routines... see ^LNPO2A for
	             remaining calculations
	
	
	----- Revision History -----------------------------------------------
	
	11/28/06 - PUTTASWH - CR 24235
		   Modified RB1 section to set AOB to %AMT if %AMT is not
		   the same as AOB. The code in RB1 section calculates the 
		   amount of unamortized miscellaneous cycled items that are to 
		   be rebated to the customer at payoff, and slight differences
		   in rounding within LNCYCMET causes the rebated amount to be 
		   different from the unamortized amount. This change fixes 
		   this issue.
		   
	10/25/06 - KELLYP - CR 23485
		   Modified POFFACT section to subtract LCHG (the amount of 
		   late charges due before future-dated payoff modeling) from
		   ln.lchg (the value after modeling).  This fixes a problem
		   in the PFW Payoff Status report where the late charge
		   adjustment value was negative when not anticipating payments.
	
	09/14/06 - KELLYP - CR 22920
		   Modified RB1 section to check for 'rebate instead of
		   rebate.  This resolves a problem where G/L transactions
		   were not being generated for unamortized FASB fees and is
		   consistent with how P01 works.  Also modified the PAYOFF1
		   section to remove the CALTD value from the payoff amount.
		   The PREREB value will now contain the appropriate rebate
		   amount due to the RB1 change made so CALTD does not need to
		   be considered in the payoff calculation (correction to CR 
		   22234 below).
	
	08/02/06 - KELLYP - CR 22234
		   Modified PAYOFF1 section to instantiate the CALTD variable
		   and to use it in the payoff calculation.  Modified PREREB
		   section to initialize CALTD.  This corrects a problem where
		   the "amortized-to-date" amount for cycled items wasn't being
		   included in the payoff figure.
	
	07/31/06 - KELLYP - CR 22048
		   Modified LNFEE section to eliminate PRECEDENCE warning.
	
	05/12/06 - KELLYP - CR 21187
		   Modified PAYOFF1 section to remove code for Recalculate 
		   Final Payment Option (LN.RFP).  RFP should only be used for
		   calculating bill amounts and should not be considered when 
		   determining the amount required to pay off a loan.
	
	04/07/06 - KELLYP - CR 20520
		   . Modified PAYOFF section for FUPO call to save off a copy
		   of the ln object, pass the original ln object to FUPO,
		   and then restore the ln object from the copy after the
		   PAYOFF1 call.  This prevents problems with future-dated 
		   payoff projections where the wrong ln object was used (due
		   to public variable scoping in LNTRB) which led to incorrect
		   data being returned for the loan payoff status report.
		   
		   . Added a TP fence with rollback in the PAYOFF section around
		   the FUPO call to prevent the loan from being accidentally 
		   updated when projecting future activity.
		   
		   . Modified FUPO section to save off ln.acr before calling 
		   UANTIC and to use that value in the %ACR calculation.  This 
		   prevents doubling of projected accrued interest when a 
		   future-dated payoff projection is performed without 
		   anticipated payments.
	
	03/08/06 - TITOVE - CR 19832
		   Modified IPFEES section to pass correct arguments to
		   SETTR^LNFEEU.

	03/02/06 - TITOVE - CR 19733
		   Modified IPFEES section to instantiate an LNFEEP object with
		   a "create-if-needed" qualifier.

	02/13/06 - KELLYP - CR 19532
		   Modified to replace references to LNPOPT.MAX and LNPOPT.MIN
		   with LNPOPT.MAXLC and LNPOPT.MINLC.  The MAX and MIN columns
		   are being obsoleted as they're reserved SQL keywords.
	
	02/03/06 - KELLYP - CR 19343
		   Modified IPFEES section to plus BSEQ and SCHSEQ (to prevent
		   an "insufficient values" error when they're null) and also
		   modified the SQL statement in that section to use 
		   SCHSEQ>:SCHSEQ instead of SCHSEQ>SCHSEQ (apparent typo).
	
	12/10/05 - SmithCD - CR 16885
		   Scoped ESCBAL and INTESC locally in PAYOFF section instead 
		   of P section, to prevent doubling when called multiple times 
		   from EXEC^UANTIC (and postentially other elements that call 
		   into it.
	
	12/14/05 - Hillanbrand - CR 17932
	           Made IPFEES section public to load ln object for node 4
	           to correct undefined on object at IPFEES+6^LNPO2.  Also
	           defined several other sections as public as they should be.
	
	12/02/05 - Satyanas - CR 16994
		   Modified R1 section as set $P(X,"|",2,3)="" is not setting 
		   the Null values to 3rd piece of X.
	
	11/29/05 - MbuiM - CR 16994
		   Modified RBX section to check if TY ="PTS" set PDBY=0. This 
		   eliminates the issue where CALTD is always set to 0 when
		   TY = "MSC","INS" and "DLD". This was not the case prior to
		   PSL conversion.

	10/07/05 - SmithCD - CR 16885
		   . Removed 4th and 5th parameters in call to EXEC^UANTIC
		   . Replaced ttxinq(,) use with code that uses the 
		     future HIST table entries generated by ^UANTIC, to 
		     retrieve the transaction information needed (NOTE: 
		     when the Escrow Processing system area is done for 
		     DBI 3, a more efficient means calculation (i.e., use 
		     before and after loan and deposit objects).
		   . Removed old revision history

	07/11/05 - KinI	- 16566
		Modified LNFEE section to add third parameter "1" to LNFEEP
		getRecord to avoid "Record not on file" error when trying to
		retrieve "*" fee from LNFEEP file.

	06/13/05 - Carol Scott - CR 15816
		Added an argument to the quit:ER comments in
		POFFACT sections.

	06/06/05 - Carol Scott - CR 15816
		Added quit:ER in section FUPO after call to 
		UANTIC.
		
	05/05/05 - Carol Scott - CR 15816
		Getting undefined error for %EffectiveDate when 
		PAYOFF^LNPO2  is being called by the payoff tab in PFW. 
		Used ".get" around the %Effective Date and set it equal 
		to TJD if it was not defined.
		Added a quit on ER to section FUPO after call to UANTIC.

		Different places throughout routine assume that TYPE will 
		be defined. When it comes in via PFW, it is not defined so 
		I define and new it in the P^LNPO2 section and in the OPCHG section. 

		Modified the call to UANTIC in the FUPO section. 
		The ttxinq(,) array was being passed as .ttxinq(), and
		it was being defined as single level array (.ttxinq(,)).

		In section POFFACT, remove the "if rs.isEmpty() quit". 
		It doesn't need to quit out if the array is empty, it can 
		still continue and determine the XLN028 value.

		Added %EffectiveDate in parameters passed to FUPO so it can 
		be passed to UANTIC.

	*/

	quit


public P(RecordLN ln,RecordTTX ttx)	// Call by computed data items

	type public String TYPE	
	new %ACR,%NOLOCK,BL,EPPEN,INF
	new OPCHG,PAYOFF,PO,PONPT,PREREB,RB,RB1,VALDATE
	
	set PO=""
	set %NOLOCK=1
	
	set TYPE=ln.type
	do PAYOFF(.ln,$G(IGNOREPO),.ttx)
	
	quit 
	

LCHG(RecordLN ln,RecordTTX ttx) // Calculate Late Charge Balance

	// Late Charge Due
	set LCHG=ln.lchg

	// Late Charge Calc Method not defined
	if ln.popt="" quit
	
	// Calculate pre-transaction late charge as of effective date (in past)
	if %EffectiveDate<%SystemDate set LCHG=$$PRELCHG^LNUEFD(.ln,.ttx) quit:ER

	// Check min/max amounts
	set LCHG=$$LCHGADJ(.ln,CID,LCHG)
	quit 

	
public PAYACR(RecordLN	ln) // Calculate Payoff Accrual
	
	do ^LNPTS22(.ln) quit:ER 
	set AMODT=ln.amodt
	do INF(.ln)
	set INF=%INF
	
	quit 
	

public INF(RecordLN ln) // Daily interest factor (called by PAYACR - s/n/b called directly)
	
	
	new IM,IR,TYPE
	set TYPE=ln.type

	// Use teaser in place of nominal rate if in teaser period
	if ln.trate,%EffectiveDate<ln.trexd set IR=ln.trate
	else  set IR=ln.irn
	
	// Use odd-days interest accrual method in place of IACM if in odd period
	if %EffectiveDate<ln.amodt do {
		Type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
		set IM=prodctl.ppico
		}	
	// Use 31/365 day basis if payoff accrual method is equal to 4
	if ln.payacm=4 set IM="13"
	
	if $G(IM)="" set IM=ln.iacm
	
	set %INF=$$^UIC(ln.balint,%EffectiveDate,%EffectiveDate,IM,IR,"",ln.dist1af,ln.dist1fre,ln.icpf,ln.schnd,ln.schld)
	set %INF=$$^SCARND(%INF,0,"","",5)

	quit 

	
PREREB(RecordLN	ln) // Calculate rebate of add-on items

	/*
	
	   Rebates imply a refund to the customer, however in certain cases
	   the institution is amortizing an amount for its benefit ("PTS")
	   and it receives the balance at payoff.
	
	   The following add-on types require:
	
	   Insurance:  If there's a rebate program in ^STBL("LNINS", then
	               it will calculate the rebate.  If not, then the re-
	               rebate method (SL,ACT,R78,DB) may be used.  If
	               there's no rebate method, or rebate program, then
	               nothing will be rebated.  Rebates will always be
	               applied as a credit to the loan balance, unless
	               the paid-by flag is zero.
	
	   Miscellaneous  If a rebate method is specified, then it will be
	   and Dealer:    used.  If not, and there's a paid-by flag=0 then
	                  the entire balance will become the rebate amount.
	                  As with insurance the paid-by flag will determine
	                  whether the borrower (flags 1 and 2) or the in-
	                  stitution (paid-by=0) receives the rebate.
	
	   Deferred Fees: Paid-by flag will always be zero.  There should be
	                  no rebate method.  Therefore the institution will
	                  always receive the balance of fees.
	
	*/
	
	type public Number CALTD
	
	new %AMT,AMT,AO,AOB,AOC,AOI,AOT,BE,DESC,IRO,LCITEM,LT,PDBY,PMTPI,REB
	new RTN,TY,VFR,XPGM,Y

	set PREREB=0
	set CNT=0
	
	type DbSet dsdld=Db.selectDbSet("LNCYCDLD","CID=:CID")
	while dsdld.next() do {
		type RecordLNCYCDLD lncycdld=dsdld.getRecord()
		set CALTD=lncycdld.caltd
		do RBX(.ln,"DLD",lncycdld.typ,lncycdld.amt,lncycdld.caltd,lncycdld.reb,lncycdld.payee,lncycdld.plan,lncycdld.pdby,"",lncycdld.term,lncycdld.cntr,lncycdld.freq)
		}

	type DbSet dsins=Db.selectDbSet("LNCYCINS","CID=:CID")
	while dsins.next() do {
		type RecordLNCYCINS lncycins=dsins.getRecord()
		set CALTD=lncycins.caltd
		do RBX(.ln,"INS",lncycins.typ,lncycins.amt,lncycins.caltd,lncycins.reb,lncycins.payee,lncycins.plan,lncycins.pdby,lncycins.irla,lncycins.term,lncycins.cntr,lncycins.freq)
		}

	type DbSet dsmsc=Db.selectDbSet("LNCYCMSC","CID=:CID")
	while dsmsc.next() do {
		type RecordLNCYCMSC lncycmsc=dsmsc.getRecord()
		set CALTD=lncycmsc.caltd
		do RBX(.ln,"MSC",lncycmsc.typ,lncycmsc.amt,lncycmsc.caltd,lncycmsc.reb,lncycmsc.payee,lncycmsc.plan,lncycmsc.pdby,"",lncycmsc.term,lncycmsc.cntr,lncycmsc.freq)
		}

	type DbSet dspts=Db.selectDbSet("LNCYCPTS","CID=:CID")
	while dspts.next() do {
		type RecordLNCYCPTS lncycpts=dspts.getRecord()
		set CALTD=lncycpts.caltd
		do RBX(.ln,"PTS",lncycpts.typ,lncycpts.amt,lncycpts.caltd,lncycpts.reb,lncycpts.payee,lncycpts.plan,lncycpts.pdby,"",lncycpts.term,lncycpts.cntr,lncycpts.freq)
		}
		
	do RB3(.ln)

	quit


public RBX(RecordLN ln,		// Loan Record
	String LCITEM,		// Remaining parameters are LNCYC* Record columns
	String TY,
	Number AMT,
	Number CALTD,
	Number REB,
	String PAYEE,
	String PLAN,
	Number PDBY,
	Number IRLA,
	Number TERM,
	Number CNTR,
	String FREQ) 
	
	if 'AMT quit
	if REB quit
	if PAYEE="" quit
	if PLAN="" quit

	if TY="PTS" set PDBY=0

	if %SystemDate>ln.paylkto set IRLA=""

	type RecordAOAMO aoamo=Db.getRecord("AOAMO","TYP=:TY,PAYEE=:PAYEE,PLAN=:PLAN")
	type RecordSTBLIPDBY stblipdby=Db.getRecord("STBLIPDBY","KEY=:PDBY")
	set rebate=stblipdby.rebate
	if $E(TY)'="I" do RB1(.ln,.aoamo) quit
	if PDBY="" quit 

	if 'rebate quit

	set GLD=aoamo.gld
	set DCID=aoamo.dgl
	set PL=aoamo.cmet if PL="" do REMTRM(.ln) do RB1(.ln,.aoamo) quit

	if Db.isDefined("LNINS","TY,PAYEE,PLAN") do R(.ln,.aoamo) quit
	quit


public R(RecordLN ln,RecordAOAMO aoamo)

	new DESC,XPGM

	Type RecordLNINS lnins=Db.getRecord("LNINS","TYPE=:TY,PAYEE=:PAYEE,PLAN=:PLAN")
	set DESC=lnins.desc
	set XPGM=lnins.rpgm
	if IRLA'="",'$D(%GRBF) do RBF quit
	
	// Rebate status requires calculated and lockout amounts (%GRBF defined)
	if XPGM="" do REMTRM(.ln) do RB1(.ln,.aoamo) quit
	set XPGM=XPGM_"(.ln)"
	do @XPGM
	if ER quit
	
	do RBF
	
	quit
	
RBF	

	set Y=X if IRLA'="" set X=IRLA
	set CNT=CNT+1 set RB1(CID,1)=X_"|"_DESC_"|"_PAYEE_"|"_AMT_"|"_TY_"|"_DESC_"|"_rebate
	set RB(CID,TY)=X_"|||"_GLD_"|"_DCID_"|"_PAYEE_"|"_rebate_"|||"_CNT
	set PREREB=PREREB+RB(CID,TY)
	quit 

	
public RB1(RecordLN ln,RecordAOAMO aoamo) // Rebate other non-insurance items

	new NR

	set DESC=aoamo.pdes
	set MET=aoamo.met
	set DBF=aoamo.decline
	set BE=aoamo.bes
	set TCD=aoamo.dtran
	set DCID=aoamo.dgl
	set GLD=aoamo.gld
	set TCC=aoamo.ctran
	set CCID=aoamo.cgl
	set GLC=aoamo.gld
	set VFR=aoamo.vfrate
	
	if DCID="" do {
		Type RecordTRN trn=Db.getRecord("TRN","ETC=:TCD")
		set DCID=trn.acn
		set GLD=1
		}

	if CCID="" do {
		Type RecordTRN trn=Db.getRecord("TRN","ETC=:TCC")
		set CCID=trn.acn
		set GLC=1
		}

	set AO=AMT 
	set NEG=AO<0
	set AOB=AO-CALTD 
	set AOT=TERM

	// Capture balance of add-on item if rebate flag=0 or PDBY is null
	if PDBY="" set %AMT=AOB do R1 quit
	if 'rebate set %AMT=AOB do R1 quit

	if MET="" quit 
	
	// Nominal Int/Div Rate
	set AOI=ln.irn

	// Distribution 1 Annual Factor
	set AF=ln.dist1af
	set AOF=FREQ 
	if AOF="" set AOF=ln.dist1fre
	set FRE(AOF)="|"_AF
	set AOC=CNTR
	set AOC=AOC+BE
	set (%AMT,X,CALC)=""
	// Number of remaining Months
	set NR=AOT-AOC 
	if NR<0 quit
	
	do START^LNCYCMET(.ln,MET) quit:ER 

	if (%AMT'=AOB) set %AMT=AOB
	
	do R1

	quit
	

R1	

	set Y=%AMT 
	if IRLA'="" set %AMT=IRLA
	set CNT=CNT+1
	set RB1(CID,CNT)=(+%AMT)_"|"_DESC_"|"_PAYEE_"|"_+AMT_"|"_TY_"|"_(+Y)_"||"_TCD_"|"_TCC
	if %AMT>0 set X=%AMT_"|"_GLC_"|"_CCID_"|"_GLD_"|"_DCID_"|"_PAYEE_"||"_TCD_"|"_TCC_"|"_CNT
	else  set X=(%AMT*-1)_"|"_GLD_"|"_DCID_"|"_GLC_"|"_CCID_"|"_PAYEE_"||"_TCD_"|"_TCC_"|"_CNT
	
	if $E(TY)="I" set $P(X,"|",2)="", $P(X,"|",3)=""
	set RB(CID,TY)=X
	if PDBY="" quit 
	set $P(RB(CID,TY),"|",7)=rebate
	set $P(RB1(CID,CNT),"|",7)=rebate

	if 'rebate quit 

	set PREREB=PREREB+RB(CID,TY)

	quit 
	
	
public RB3(RecordLN ln) // Rebate add-on or discount interest

	Type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
	// Int Rebate Method (Add-on)
	set LT=ln.irb
	if 'LT do RB4(.prodctl) quit
	Type RecordSTBLGRPI stblgrpi=Db.getRecord("STBLGRPI","METH=:ln.irb")
	set BE=stblgrpi.bes
	
	if 'ln.cntdr do RB4(.prodctl) quit
	
	set AF=ln.dist1af
	// Distribution 1 Frequency
	set (AOF,FRE)=ln.dist1fre
	set %SCHLD=ln.schld

	if %EffectiveDate'=%SystemDate set JD=%SystemDate do SCNM(.ln) quit:ER 
	
	if ln.dist1fre="" do RB4(.prodctl) quit
	
	set FRE(AOF)="|"_ln.dist1af
	set AO=ln.iun 
	set AOT=ln.onp 
	set AOI=ln.irn 
	set AOC=ln.schnum
	if $E(ln.iam)=1 set AOB=(ln.iun-(ln.ipl-ln.extamt))
	set NEG=AO<0
	set CRCD=ln.crcd
	
	// Check grace days and if within free day period
	if AOC,%SCHLD+prodctl.irgd'>%EffectiveDate set AOC=AOC+1
	if 'AOC,%EffectiveDate>(prodctl.fredy+ln.odd-1),$E(ln.iam)=1 set AOC=1
	
	set CALC="" set AOC=$S('AOC:$S(BE:1,1:0),1:AOC)
	set %AMT=0

	/* 
	This call checks the interest rebate methods.  Previously the call
	was to batch BCHLNAMOAO.  The code was taken out of the batch and 
	moved into LNCYCMET.
	*/
	do START^LNCYCMET(.ln,LT) quit:ER
	if %AMT<0 set %AMT=0
	set CNT=CNT+1
	set PREREB=PREREB+%AMT
	set RB1(CID,CNT)=+%AMT_"|"_stblgrpi.desc_"|N/A|"_$$^SCARND(ln.iun,0,CID)_"|I|"_+%AMT_"|1"
	set RB(CID,"UNINT")=%AMT_"||||||1"

	do RB4(.prodctl)

	quit


RB4(RecordPRODCTL prodctl)	//

	if 'PREREB quit 
	if PREREB'<prodctl.minrb quit 
	
	// Rebate amount is less than minimum, set amounts to zero
	set PREREB=0 set N=""
	for  set N=$O(RB1(CID,N)) quit:N=""  if $P(RB1(CID,N),"|",7)  for J=1,6 set $P(RB1(CID,N),"|",J)=0
	for  set N=$O(RB(CID,N)) quit:N=""  if $P(RB(CID,N),"|",7)  for J=1,6 set $P(RB(CID,N),"|",J)=0

	quit 

	
public OPCHG(RecordLN ln) // Other payoff charges

	type public String TYPE

	set OPCHGSV=ln.opchg
	if OPCHGSV'="" set OPCHG=OPCHGSV quit 
	set CRCD=ln.crcd
	set TYPE=ln.type

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
	set OPCHG=prodctl.pchgo
	set (OPCHG,OPCHGSV)=OPCHG

	quit 

	
public PAYOFF(RecordLN ln,CTL,RecordTTX ttx)

	/*
	
	   ARGUMENTS:
	   . ln   LN object             /TYP=RecordLN/REQ/MECH=REF:R	

	   . CTL   Control			/NOREQ/MECH=VAL
	
	      Position 1 - 0) Include payoff fees, and "I","P" fees
	            1) Include only "I","P" fees (for RPOO)
	
	      Position 2 - null) Not Applicable - bypass ^UANTIC
	            0) Do not anticipate pending payments
	            1) Anticipate pending payments
	
	   . ttx   TTX object			/TYP=RecordTTX/REQ/MECH=REF:R	

	*/
	
	new %ACM,%ACRS,%BAL,%CID,%DAYS,%DY,%ICDD,%ICPP,%ICTD,%INF
	
	new AMT,ANTPMT,BALLAMT,CALC,CCID,CNT,DESC,DCID,ECID,FEEAMT,FUPO,GLC,GLD,JD
	new INF,INQ,LCHGADJ,NEG,NGFRE,NPGEN,PAMT,PCE,PDBY,POMISC,POFEES,TCC
	new TCD,TY,X,XPGM
	
	type Number ESCBAL,INTESC
	
	set CTL=CTL.get()
	if '(%EffectiveDate.get()) set %EffectiveDate=%SystemDate
	do CHKHIST 
	if ER set (XLN09,XLN28)="" quit
	set (XLN09,XLN28)=""

	// Anticipate payments flag
	set ANTPMT=$E(CTL,2)

	// Not future-dated
	if %EffectiveDate'>%SystemDate,ANTPMT set ANTPMT=0
	
	// Future-dated via UANTIC
	if %EffectiveDate>%SystemDate,ANTPMT'="" set FUPO=1

	// Bypass UANTIC
	else  set FUPO=0
	
	// Current total escrow accrual
	set INTESC=$$INTESC(%SystemDate,.ln) quit:ER
	
	// Future-dated amounts
	if FUPO do { quit
		// Set up TP fence so we can roll back proj. activity
		do Runtime.start("CS",,"PTR")
		
		// Save off a copy of ln so we can restore it later
		type RecordLN ln1=ln.copy()
		
		do FUPO(.ln,ANTPMT,.ttx,%EffectiveDate)
		
		// Can't quit with an active transaction so 
		// rollback then quit when an error occurs
		if ER do {  quit
			// Restore original ln
			set ln=ln1.copy()
			do Runtime.rollback("PTR")
			}
		
		do PAYOFF1(.ln,.ttx)
		
		// Restore original ln
		set ln=ln1.copy()
		
		// Rollback any projected activity
		do Runtime.rollback("PTR")
		}
	// Payoff accrual
	do PAYACR(.ln) quit:ER

	// Late charges
	do LCHG(.ln,.ttx) quit:ER
	do PAYOFF1(.ln,.ttx) 

	quit


public PAYOFF1(RecordLN ln,RecordTTX ttx)	

	type Number CALTD = 0

	// Loan fees due
	set POFEES=$$FEES(.ln,CID,.FEEAMT,$E(CTL,1),.ttx) quit:ER

	// Net Miscellaneous Charges
	set POMISC=POFEES-ln.unapf
	if POMISC<0 set POMISC=0
	
	// Early payoff penalty amount
	do EPPEN^LNPO2A(.ln) quit:ER

	// Other payoff charges
	do OPCHG(.ln) quit:ER

	// Total escrow accrual
	if %EffectiveDate<%SystemDate set INTESC=$$INTESC(%EffectiveDate,.ln) quit:ER

	// Rebate of add-on items
	do PREREB(.ln) quit:ER
	
	if '$D(VALDATE) set VALDATE=%EffectiveDate
	set %ACR=$$^SCARND(%ACR,0,CID)
	
	if %EffectiveDate=%SystemDate,ln.pldf set $P(XLN28,"|",2)=INF
	
	set PRNINT=ln.bal+%ACR
	
	// Calculate Net Payoff Amount
	set PAYOFF=PRNINT+LCHG+EPPEN+OPCHG+POFEES-ESCBAL-INTESC-PREREB-ln.unapf

	// Advances to Reduce Undisbursed Flag is set - subtract Unadvanced Bal
	if ln.aruf set PAYOFF=PAYOFF-ln.udbal
	
	set PONPT=PAYOFF-ln.coa+ln.rec
	
	// account closed
	if ln.stat=4 set (PAYOFF,PONPT)=0
	
	// System Use - Payoff (computed data items)
	set $P(XLN09,"|",1)=PAYOFF             // Net Payoff Amount
	set $P(XLN09,"|",2)=INTESC             // Escrow Interest Accrued
	set $P(XLN09,"|",3)=INF                // Daily Interest Amount
	set $P(XLN09,"|",4)=%ACR               // Interest Accrual
	set $P(XLN09,"|",5)=EPPEN              // Early Payoff Penalty
	set $P(XLN09,"|",6)=PREREB             // Rebate of Amounts Prepaid
	set $P(XLN09,"|",7)=OPCHG              // Payoff Charges
	set $P(XLN09,"|",8)=%EffectiveDate     // Effective Date Used to Calc
	set $P(XLN09,"|",9)=VALDATE            // Payoff Valid Date
	set $P(XLN09,"|",10)=+$G(RB(CID,"ID"))         // Disability Insurance Rebate
	set $P(XLN09,"|",11)=+$G(RB(CID,"IL"))         // Life Insurance Rebate
	set $P(XLN09,"|",12)=+$G(RB(CID,"MSC"))        // Miscellaneous Add-On Rebate

	// Multiple Miscellaneous Add-On Rebate
	for X=1:1:9 set $P(XLN09,"|",12)=$P(XLN09,"|",12)+$G(RB(CID,"MSC"_X))
	set $P(XLN09,"|",13)=+$G(RB(CID,"IH"))         // Health Insurance Rebate
	set $P(XLN09,"|",14)=+$G(RB(CID,"DLD"))        // Dealer Discount Rebate
	set $P(XLN09,"|",15)=+$G(RB(CID,"UNINT"))      // Unearned Interest Rebate
	set $P(XLN09,"|",16)=POMISC            // Net Miscellaneous Charges
	set $P(XLN09,"|",17)=ESCBAL            // Escrow Balance
	set $P(XLN09,"|",18)=PONPT             // Net Payoff Transaction
	set $P(XLN09,"|",19)=LCHG              // Late Charge Due
	set $P(XLN09,"|",21)=POFEES            // Loan Fees Due
	
	quit 

	
public REMTRM(RecordLN	ln)

	// Calculate a loan's remaining term for generic insurance rebate
	
	new CNT,JD,FRE,NJD
	
	set ER=0
	
	if '%EffectiveDate set %EffectiveDate=%SystemDate
	
	// We're in the beginning.
	if %EffectiveDate<ln.dfp set CNTR=0 quit
	set JD=ln.dfp
	
	// Count the  payment between DFP and EFD.
	// Counts DFP as #1
	set CNT=1
	for  set NJD=$$NJD^UFRE(JD,ln.dist1fre) quit:ER  quit:NJD>%EffectiveDate  set CNT=CNT+1 set JD=NJD
	if ER quit 
	
	set CNTR=CNT
	quit 
	

public SCNM(RecordLN ln)	// Values %SCHLD,SCHNUM have been obtained from ^ACN

	set JD=%SCHLD 
	set K=1
	if %EffectiveDate>%SCHLD for  set NJD=$$NJD^UFRE(JD,FRE) quit:ER  quit:NJD>%EffectiveDate  set JD=NJD set K=K+1
	if ER quit 
	if %EffectiveDate>%SCHLD set ln.schnum=ln.schnum+(K-1) set JD=NJD set NJD=$$NJD^UFRE(JD,FRE,,1) quit:ER  set %SCHLD=NJD quit 
	
	if %EffectiveDate=%SCHLD quit 
	
	set K=1
	for  set NJD=$$NJD^UFRE(JD,FRE,,1) quit:ER  quit:NJD'>%EffectiveDate  set JD=NJD set K=K+1
	if ER quit 

	set ln.schnum=ln.schnum-(K-1) set %SCHLD=NJD
	if NJD<%EffectiveDate set JD=NJD set NJD=$$NJD^UFRE(JD,FRE) quit:ER  set %SCHLD=NJD

	quit 
	
	
public LNFEE(RecordLN ln,	// Loan Record
      Number CTL,	// Control Variable
      String FEEAMT,	// Fee Amount Array
      RecordTTX ttx)	// Transaction Object

	/*	
	   ARGUMENTS:	
	   . CTL     Control   /NOREQ/MECH=VAL	
	                   Position 1 - 0) Do not include fee if collected
	                                   from target account.	
	                                1) Include fee even if collected
	                                   from target account.
	
	                            2 - 0) Include payoff fees, and "I","P" fees
	                                1) Include only "I","P" fees (for RPOO)
	
	   . FEEAMT  Fee amount array  /TYP=REFARR/MECH=REF/NOREQ	
	                   Pass array name if fee amounts by type required.
	                   Otherwise, ignore and array will not be returned.		
	*/
	
	type public Boolean ER
	type Number BALCMP,X
	
	set CTL=CTL.get()
	set FEEAMT=FEEAMT.get()

	set BALCMP=ln.bal
	if ln.aruf set BALCMP=BALCMP-ln.udbal
	
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:ln.type")
	
	if 'CTL.extract(2) do {
		type String FEETYP
	
		type ResultSet rs=Db.select("FEETYP","LNFEE","CID=:CID")
		while rs.next() do {
			set FEETYP=rs.getCol("FEETYP")
			
			type RecordLNFEEP lnfeep=Db.getRecord("LNFEEP","FEETYP=:FEETYP",1)
			
			if lnfeep.lfee quit  	// Linked fee	
			
			if 'lnfeep.fpoff quit	// Assess w/ payoff
	
			if CTL.extract()=0,lnfeep.cfwa&(lnfeep.desc'="")!(lnfeep.dtst'="") quit
			
			do CALC^LNFEEU(.ln,.ttx,CID,lnfeep.lfee,"","",.FEEAMT)
			}
		}	
		
	do FEEDUE^LNFEEU(.ln,.ttx,CID,2,"00"_('CTL.extract()),%EffectiveDate,,,,prodctl.crtrci,.FEEAMT) quit:ER FEEAMT
	
	// Calculate "at billing" fees based on interest and principal
	set X=ln.cuin set:X<0 X=0 set X=X+ln.unin
	set X=%ACR-X	
	do FEEDUE^LNFEEU(.ln,.ttx,CID,3,"001",%EffectiveDate,"",X,"I","",.FEEAMT) quit:ER FEEAMT

	set X=ln.cupr set:X<0 X=0 set X=X+ln.unpr
	set X=BALCMP-X
	do FEEDUE^LNFEEU(.ln,.ttx,CID,3,"001",%EffectiveDate,"",X,"P","",.FEEAMT) quit:ER FEEAMT
	
	// Subtract fees that are based upon "I" or "P", are part of a
	// due amount, have already been generated, but are not yet due.
	do IPFEES(.ln,0) quit:ER FEEAMT
	
	quit FEEAMT

	
public IPFEES(RecordLN ln,
	      Number mode)

	/*
	   Subtract fees that are based upon "I" or "P", are part of a	
	   due amount, have already been generated, but are not yet due.
	
	   ARGUMENTS:
	   
	   	 . ln		Loan Account Record	/TYP=RecordLN/REQ
	         . mode 	processing mode  	/TYP=N/NOREQ
	
	                 0 - inquiry mode - sets up array FEEAMT
	                 1 - txn processing mode - generates txns
	
	*/
	
	set mode = mode.get()
	
	type public Number BSEQ, CID, ER, FEEAMT, FEEAMT(), SCHSEQ
	type public String ETC
	
	type Number X
	type String FEE
	
	set SCHSEQ = +ln.schseq
	set BSEQ = +ln.bseq
	
	type ResultSet rs = Db.select("FEETYP,BRFAMT","LNBIL5","CID=:CID AND SCHSEQ>:SCHSEQ AND SCHSEQ<=:BSEQ AND DUEAMT=1")

	while rs.next() do { quit:ER
		
		set FEE = rs.getCol("FEETYP")
		
		type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP = :FEE", 1)
		
		if (lnfeep.basis = "I") ! (lnfeep.basis = "P") do { quit:ER
			
			set X = rs.getCol("BRFAMT")
			
			if 'mode do {
			
				set FEEAMT = FEEAMT - X
				
				set FEEAMT(FEE) = FEEAMT(FEE).get() - X
				}

			if mode do SETTR^LNFEEU( .ln, , .lnfeep, CID, "011", .ETC, X, FEE, 1, %EffectiveDate.get()) quit:ER
			}
		}

	quit 


FEES(RecordLN ln,CID,FEEAMT,CTL,RecordTTX ttx)	// Return current loan fees due
	
	set FEEAMT=$G(FEEAMT)
	set CTL=$G(CTL)
	set FEEAMT=$$LNFEE(.ln,0_$E(CTL),.FEEAMT,.ttx) quit:ER FEEAMT

	type ResultSet rs=Db.select("FEETYP,FEEREM","LNFEE","CID=:CID")
	if rs.isEmpty() quit FEEAMT
	while rs.next() do {
		set FEETYP=rs.getCol(1)
		set FEEAMT=FEEAMT+rs.getCol(2)
		set FEEAMT(FEETYP)=$G(FEEAMT(FEETYP))+rs.getCol(2)
		}
	quit FEEAMT


public LCHGADJ(RecordLN ln,CID,LCHG)

	/*
	
	   Returns a value for LCHG based upon minimum and maximum limits
	   specified in [LNPOPT].
	
	   KEYWORDS: Late Charge, Limits
	
	   ARGUMENTS:
	   . CID Account number   /TYP=N/REQ/MECH=VAL
	
	   . LCHG Late charge amount  /TYP=N/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ Adjusted late charge amount /TYP=N
	
	   EXAMPLE:
	   S LCHG=$$LCHGADJ^LNPO2(CID,LCHG)
	
	*/
	
	new %POPT
	
	if ln.popt="" quit LCHG
	
	Type RecordLNPOPT lnpopt=Db.getRecord("LNPOPT","GRP=:ln.grp,POPT=:ln.popt")
	set %POPT=lnpopt.mmcol

	// Min/Max Checking at Collection
	if 'lnpopt.mmcol quit LCHG
	
	set LCHG=$$MIN^BCHLNLAT(LCHG,lnpopt.minlc,lnpopt.mlco)
	set LCHG=$$MAX^BCHLNLAT(LCHG,lnpopt.maxlc)

	quit LCHG
	

INTESC(EFD,RecordLN ln)	// Accumulate total escrow interest accrued

	new INTESC
	
	// Total Escrow accrual, balance
	do INTESC^LNPO2A(.ln) quit:ER 0

	quit INTESC
	

FUPO(RecordLN ln,ANTPMT,RecordTTX ttx,%EffectiveDate)


	/*
	   ANTPMT = 0 - Do not assume payments
	      1 - Anticipate (assume) regularly scheduled payments
	
	*/
	
	// Late Charge Due
	set LCHG=ln.lchg
	
	type String ETC
	type Number CURACR,TSEQ

	set CURACR=ln.acr

	if '(%EffectiveDate.get()) set %EffectiveDate=%SystemDate
	
	// Save original transaction sequence
	set TSEQ=Db.nextVal("HIST","CID")-1
	
	// Project into future
	do EXEC^UANTIC(.ln,.ttx,,%EffectiveDate,,'ANTPMT) quit:ER

	set XLN28=$$POFFACT(.ln,TSEQ) quit:ER
	
	// Current Accrual + (Anticipated Accrual - Interest Payments)
	set %ACR=CURACR+($P(XLN28,"|",2)-$P(XLN28,"|",7))

	// Current Escrow Balance + Payments to Escrow
	set ESCBAL=ESCBAL+$P(XLN28,"|",9)


	// Current Escrow Accrual + (Escrow Accrual + Escrow Interest Payments)
	set INTESC=INTESC+$P(XLN28,"|",5)+$P(XLN28,"|",10)

	// Anticipated Late Charge
	set LCHG=ln.lchg
	
	quit 
	

public POFFACT(RecordLN ln, Number OTSEQ)
	
	type String DATA
	type Number SEQ,CRTOT(),DRTOT(),ECRTOT(),EDRTOT()
	type Boolean TRB
	
	// Initialize credit and debit totals for loan and escrow
	set (CRTOT("PRIN"),CRTOT("INT"),CRTOT("MISC"))=0
	set (DRTOT("PRIN"),DRTOT("INT"),DRTOT("MISC"))=0
	set (ECRTOT("PRIN"),ECRTOT("INT"),ECRTOT("MISC"))=0
	set (EDRTOT("PRIN"),EDRTOT("INT"),EDRTOT("MISC"))=0

	set TRB=ln.trb		
	set SEQ=""
	set BRCD=ln.boo
	set DATA=""
	
	// Process all HIST records created by ^UANTIC
	type DbSet ds=Db.selectDbSet("HIST","CID=:CID AND TSEQ>:OTSEQ")
	while ds.next() do { quit:ER
		type RecordHIST hist=ds.getRecord("HIST")
		do LDTAMT(.hist) 
		}
	if ER quit DATA
	
	type Date %SystemDate
	#ACCEPT DATE=08/17/01;PGM=John Carroll
	set %SystemDate=%EffectiveDate

	// Calculate possible accrual for payoff date only
	do PAYACR(.ln) 
	if ER quit DATA
	
	// System Use - Anticipated Payoff (computed data items)
	set $P(DATA,"|",1)=INTESC		// Current Escrow Int Accrued
	set $P(DATA,"|",2)=DRTOT("INT")+ADJ	// Accrued Interest
	set $P(DATA,"|",3)=ln.lchg-LCHG		// Late Charges (due after modeling - due before modeling)
	set $P(DATA,"|",4)=DRTOT("MISC")	// Miscellaneous Charges
	set $P(DATA,"|",5)=EDRTOT("INT")	// Escrow Interest Accrued
	set $P(DATA,"|",6)=CRTOT("PRIN")	// Principal Payments
	set $P(DATA,"|",7)=CRTOT("INT")		// Interest Payments
	set $P(DATA,"|",8)=CRTOT("MISC")	// Miscellaneous Charge Payments
	set $P(DATA,"|",9)=ECRTOT("PRIN")	// Total Escrow Balance
	set $P(DATA,"|",10)=ECRTOT("INT")	// Total Escrow Interest
	set $P(DATA,"|",11)=DRTOT("PRIN")	// Principal Adjustment

	quit DATA

	
LDTAMT(RecordHIST hist)

	// Break down TAMT and load CR, DR, ECR, EDR arrays
	
	type public Cache %CACHE()
	
	type Boolean DC
	type String ETC

	set DC=hist.itc.extract(1)

	set ETC=hist.etc
	if ETC.isNull() quit
	
	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")
	
	if trn.grp'="ESC" do {
		if (TRB-DC)=0 do INC(.CRTOT(),.hist)
		else  do INC(.DRTOT(),.hist)
		}
	else  do { 
		if (TRB-DC)=0 do INC(.ECRTOT(),.hist)
		else  do INC(.EDRTOT(),.hist)
		}

	quit
	

INC(Number TOT(), RecordHIST hist)	// Updates CR,DR,ECR, and EDR arrays

	set TOT("PRIN")=TOT("PRIN")+hist.prin
	set TOT("INT")=TOT("INT")+hist.int
	set TOT("MISC")=TOT("MISC")+hist.misc

	quit


CHKHIST	// Check history for intervening transactions
	
	new TSEQ

	if %EffectiveDate=%SystemDate quit 

	Type ResultSet rs2=Db.select("TSEQ","HIST","CID=:CID AND EFD>:%EffectiveDate AND EFD<=:%SystemDate")
	if rs2.isEmpty() quit
	set TSEQ=rs2.next(),TSEQ=rs2.getCol(1)
	if TSEQ set ER=1 set ET="PAYOFFEFD" do ^UTLERR

	quit 

vSIG()	quit "60597^33104^Hema Puttaswamy^29087"	// Signature - LTD^TIME^USER^SIZE
