LNFEEC0		/*
	PROCEDURE:  LNFEEC0
	ORIG: Tom Locke - 02/26/93
	DESC: Loan Fee Compiler

	---- Comments --------------------------------------------------------

	This procedure builds the run time routine, LNFEECMP.

	RETURNS:
		. ER		Error flag	/TYP=L

		. RM		Error message	/TYP=T

 	---- Revision History ------------------------------------------------

	05/22/06 - TITOVE - CR 21289
		   Modified to call LINK^PBSUTL to link the compiled routine
		   to servers, to prevent Host errors in PFW when creating
		   an account with a new fee plan without bouncing servers.
		   Brought up to standards.

	03/30/06 - TITOVE - CR 20367
		   Modified to check whether %FN is defined and use the
		   procedure name in LOG^UTLEXC call if it is not. Restored
		   call to TBL1^LNFEEU and added ELEMENT IS NOT NULL
		   condition to select from LNFEEP, to prevent null subscript
		   errors.

	05/01/02 - Dan Russell
		   Rewrote from M to PSL.  Modified to generate PSL code
		   and compile that to M, instead of going directly to M.

		   Removed old change history.
	*/
	type public String %MSKD
	type Number ER = 0
	type literal String TAB = $char(9)
	type String CODE(), TBL()
	
	// Build a reference array
	do TBL1^LNFEEU(.TBL())
	
	kill RM

	// I18N=OFF

	do addline("LNFEECMP"_TAB_"// "_%CurrentDate.toString(%MSKD.get())_" "_$$TIM^%ZM_" - "_%UserID)
	do addline(TAB_"// Loan fee program compiled by LNFEEC0")
	do addline("")
	do addline(TAB_"quit // Do not call from the top")

	type DbSet feepds = Db.selectDbSet("LNFEEP")
	
	while feepds.next() do { quit:ER
	
		type Number SEQ = 1
		type String CALC(), FEETYP, QRY = ""

		type RecordLNFEEP lnfeep = feepds.getRecord("LNFEEP")

		set FEETYP = lnfeep.feetyp
		
		do addline("")
		do addline("public "_FEETYP_"(RecordLN ln)"_TAB_"// "_lnfeep.desc)
		do addline("")

		do addline(TAB_"type public Number AMT")
		do addline("")
		
		// Initialize tamt to zero
		do addline(TAB_"type Number TAMT = 0")

		// Fixed amount
		if 'lnfeep.famt.isNull() do addline(TAB_"set TAMT = TAMT + "_lnfeep.famt)

		// Extrinsic function call
		if 'lnfeep.cfunc.isNull() do {
		
			type String LINE
			
			do addline(TAB_"type public Date EFD")
			do addline(TAB_"type public Number CID")
			do addline(TAB_"type public String BIL, ELMNT")
			do addline("")
			do addline(TAB_"// Custom extrinsic function")
			
			set LINE = "set TAMT = TAMT + "_lnfeep.cfunc
			
			if 'lnfeep.cfunc.isLike("%(%") set LINE = LINE_"(CID,EFD,BIL,AMT,ELMNT)"
			
			do addline(TAB_LINE)
			}

		type ResultSet feepsrs = Db.select("OP,PERC,ELEMENT", "LNFEEPS", "FEETYP=:FEETYP AND ELEMENT IS NOT NULL", "SEQ")

		/* 
		   For elements that are columns, or column expressions, such
		   as $S(), determine the elements, construct a bogus query
		   to pass to UCQRYBLD to generate the required object loading,
		   and convert the reference to lower case to act as an
		   object reference in the compiled code.
		*/

		if 'feepsrs.isEmpty() while feepsrs.next() do { quit:ER
		
			type String ELEMENT, X

			set ELEMENT = feepsrs.getCol("ELEMENT")
			
			// Basis elements
			if TBL(ELEMENT).exists() do {
				
				set X = "set TAMT = TAMT"_feepsrs.getCol("OP")_"("_(feepsrs.getCol("PERC") / 100)_" * AMT)"
				do addline(TAB_X)
				}

			// Columns or column-related expressions.  Turn into
			// bogus QRY for UCQRYBLD and final expression.
			else  do {
				
				type String COL, DELIMS, ITEM, NEWFORM, TABLE
				type Number PTR

				set PTR = 0
				set DELIMS = "<>#\'?=:,+-*/_()!&"
				set NEWFORM = ""
				for  set ITEM = $$ATOM^%ZS(ELEMENT, .PTR, DELIMS) do { quit:ER!(PTR = 0)

					// Old [TABLE]COL format
					if ITEM?1"["1A.AN1"]"1A.AN do {
						
						set TABLE = ITEM.piece("[",2).piece("]",1)
						set COL = ITEM.piece("]",2)
						}
						
					// New TABLE.COL format
					else  if ITEM?1A.AN1"."1A.AN do {
						
						set TABLE = ITEM.piece(".",1)
						set COL = ITEM.piece(".",2)
						}
						
					// Not TABLE.COL reference
					else  set NEWFORM = NEWFORM_ITEM quit

					// Make reference lower case to treat as object
					set NEWFORM = NEWFORM_(TABLE_"."_COL).lowerCase()

					// Add reference to QRY to build bogus QRY
					if 'QRY.isNull() set QRY = QRY_" AND "
					set QRY = QRY_TABLE_"."_COL_">0"
					}

				set CALC(SEQ) = feepsrs.getCol("OP")_"("_(feepsrs.getCol("PERC") / 100)_" * ("_NEWFORM_"))"
				set SEQ = SEQ + 1
				}	
			}

		quit:ER

		// Build data loading section and add calculation lines
		if 'QRY.isNull() do {
		
			type String INPUT, PSLOBJ(,)
			type Number OBJ, SEQ

			do addline("")
			do addline(TAB_"// Calculate based on columns entered by user")
	
			set INPUT("WHERE") = QRY
			
			do ^UCQRYBLD(.INPUT, "LN=ln", , .PSLOBJ(,)) quit:ER
			
			set (OBJ,SEQ) = ""
			for  set OBJ = PSLOBJ(OBJ).order() quit:OBJ.isNull()  do {
				
				type String OBJNAME = PSLOBJ(OBJ).piece("|",1).lowerCase()
				
				for  set SEQ = PSLOBJ(OBJ,SEQ).order() quit:SEQ.isNull()  do {
					
					type String X = PSLOBJ(OBJ,SEQ)
					
					/* 
					   Replace PSL vobj reference with table name as object
					   X="type RecordCIF xobj2=Db.getRecord(""CIF"",""ACN=:ln.acn"")"
					   will become
					   X="type RecordCIF cif=Db.getRecord(""CIF"",""ACN=:ln.acn"")"
					*/
					set X = X.piece(" ",1,2)_" "_OBJNAME_"="_X.piece("=",2,99)
					do addline(TAB_X)
					}
				}

			do addline("")

			set SEQ = ""
			for  set SEQ = CALC(SEQ).order() quit:SEQ.isNull()  do addline(TAB_"set TAMT = TAMT"_CALC(SEQ))
			}

		quit:ER

		// Check rounding option
		if 'lnfeep.rnd.isNull() do {
		
			do addline(TAB_"// Rounding option")
			
			do addline(TAB_"set TAMT = $$RND^UINDX(TAMT, """_lnfeep.rnd_""")")
			}

		do addline(TAB_"if TAMT set TAMT = TAMT.roundCur(ln.crcd)")

		// Minimum fee amount
		if 'lnfeep.feemin.isNull() do {
		
			type Number X
			
			do addline(TAB_"// Minimum fee amount")
			
			if lnfeep.fminop set X = lnfeep.feemin
			else  set X = 0 
			
			do addline(TAB_"if TAMT < "_lnfeep.feemin_" set TAMT = "_X)
			} 

		// Maximum fee amount
		if 'lnfeep.feemax.isNull() do {
		
			type String X
			
			do addline(TAB_"// Maximum fee amount")
			
			set X = "if TAMT > "_lnfeep.feemax
			
			if lnfeep.fmaxop set X = X_" do maxer(TAMT, "_lnfeep.feemax_")"
			set X = X_" set TAMT = "_lnfeep.feemax
			
			do addline(TAB_X)
			}

		do addline(TAB_"quit TAMT")
		}

	quit:ER

	// Build code to log message that exceeds max
	do addline("")
	do addline("maxer(Number tamt,Number max)"_TAB_"// Log exceeds max message")
	do addline("")
	do addline(TAB_"type public String %FN, FEE")
	do addline(TAB_"type public Number CID")
	do addline("")
	do addline(TAB_"type String RM")
	do addline(TAB_"// Calculated fee ~p1 of ~p2 exceeds maximum amount of ~p3")
	do addline(TAB_"set RM = $$^MSG(""401"", FEE, tamt, max)")
	do addline(TAB_"// Loan Fees")
	do addline(TAB_"do LOG^UTLEXC($select('%FN.get().isNull():%FN,1:""LNFEECMP""), ""*"", $$^MSG(""4099""), CID, , RM)")
	do addline(TAB_"quit")
	do addline("")

	// Build run-time loan fees routine
	do BUILDRTN^UCGM(.CODE(), "LNFEECMP", .RM())
	
	// Report compile errors
	if RM.data() do {

		type Number N = ""
		
		for  set N = RM(N).order() quit:N.isNull()  write RM(N),!
		
		set ER = 1
		}
	// Compile successful - link the new version of loan fees routine to servers
	else  do { quit:ER
		
		type ResultSet rs = Db.select("DISTINCT SVTYP", "SVCTRLT")
		
		while rs.next() do LINK^PBSUTL(rs.getCol("SVTYP"), "LNFEECMP") quit:ER
		}

	quit


addline(String DATA)	// Private - add line to end of code

	type public String CODE()
	
	set CODE(CODE("").order(-1) + 1) = DATA
	
	quit

vSIG()	quit "60407^55822^Eugene Titov^7294"	// Signature - LTD^TIME^USER^SIZE
