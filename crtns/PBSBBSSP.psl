PBSBBSSP(reply,stfflg,record,vzfrn,context)	//Private;Browser-Based Service Class Driver
	/*
	   ORIG: CHENARD - 08/22/96

	   This HTML browser-based driver is called by
	   the SCA$IBS server as service class 6, BBSSP.

	   This routine is responsible for servicing HTML requests
	   of the PROFILE application.

	   ARGUMENTS:
	    	. reply  - Reply message  		/TYP=T/REQ/MECH=REFNAM

	   	. stfflg - Store & forward flag  	/TYP=N/REQ/MECH=VAL
	       		   0 - On-line
	       		   1 - Uncertain off-line status
	        	   2 - Off-line

	   	. record - Input Message  		/TYP=T/REQ/MECH=VAL

	  	 . context - Context about the client's access to
	                     the system.  Used for defaulting values for
	                     parameters and attributes. /TYP=T/NOREQ/MECH=VAL

	   RETURNS:
	   	. $$  - Error status   			/TYP=N/REQ

	  ---------------------------------------------------------------------------------------------------------
	
	   Before processing any client requests under this service class, we
	   need to initialize a user ID and branch code, posting date, and
	   potentially other variables to establish the identity of the batch
	   user for stand-in of browser-based client requests.

	   The Browser-based service class driver must accomplish the following.
	   First, the message received is converted from its Length-Value format.
	   This should resolve to a single field, containing the entire message.

	   Next, the message needs to be parsed to discover the name of the page
	   that is being processed.  Within each of the web pages in our domain,
	   an identifier will be incorporated into its construction as a hidden
	   field.  This form ID, named SCA_FORMID,  is then used by this driver
	   to look-up information on the form, including the procedure to execute
	   for processing and the specific HTML form name that will need to be
	   served as part of the reply.  Aside from the form-id, all value pairs
	   will be parsed and placed into an input array that will be fed to either
	   a specific sub-routine for this particular page or a shell that will then
	   call another public function.

	   Next, call the designated tag, passing the input array and expecting an
	   output array in return.  This sub-routine tag will use the input to define
	   appropriate local variables and execute procedural code to process the re-
	   quest.  Based on the success of this procedure, an output array will be
	   built that either changes the values of existing pairs or adds new entries
	   to the control name pairs that may be used by the HTML merge facility to
	   create the reply HTML document.

	   Next, the associated routine to the default page will be called, which
	   constructs the HTML code for the next page to be served back to the
	   browser.  Any variable insertion will occur during the execution of
	   this routine and result in a page populated with this data.
	  
	---- Revision History ------------------------------------------------

	   12/17/03 - CARROLLJ - CR7239
		      Added #ACCEPT prior to xecute command.

           04/18/2002 - SRIVASTAVAN - 49794
           		Converted to PSL

	*/


	catch vERROR {
                new ET,RM
                set ET=vERROR.type
 
                if ET["%GTM-" do { quit
                        do ZE^UTLERR
			set reply=$$RM($$^MSG(6747,$G(%ZTSEQ)),1)
			}
 
                set ET=ET_"-"_vERROR.thrownAt
                set RM=vERROR.description
                do ^UTLERR
                }

	do INIT
 
	new dftpage,fld,msg,ptr,vzfunc,vzin,vzout,x
	set ER=0 
	set reply=""

	set ptr=$$LV2V^MSG(record,.fld)
	set fld(1)=$G(fld(1))

	if fld(1)="" do { quit ER
		set ER=1 
		set reply=$$RM("No message found",1) 
		}

	// Parse message for form id and build input array
	set ER=$$PARSE(fld(1),.vzin) if ER do { quit ER
		set reply=$$RM($G(RM),1)
		}

	// Form must have a control name SCA_FORMID for identification
	if '$D(vzin("SCA_FORMID")) do { quit ER
		set ER=1 
		set reply=$$RM("Invalid form",1) 
		}

	// Based on FORM ID, get the procedural call and HTML document
	// name from table

	set ER=$$GETFORM(vzin("SCA_FORMID"),.vzfunc,.dftpage)
	if ER set reply=$$RM($G(RM),1) quit ER

	if $G(vzin("SCA_REF_CTX"))'="" do {
		new CTX,i,n,nam,x
		set CTX=vzin("SCA_REF_CTX")
		set %token=%SessionID_"_"_CTX

		type RecordPBSBBSSP pbsbbssp=Db.getRecord("PBSBBSSP","TOKEN=:%token",1)
		if pbsbbssp.getMode()=0 quit
		set x=pbsbbssp.ctx
		for i=1:1:$L(x,$C(28)) set nam=$P(x,$C(28),i) do {
			quit:nam=""  quit:nam'["="
			set key=$P(nam,"=",1) quit:$D(vzin(key))
			set vzin(key)=$P(nam,"=",2)
			set @$P(nam,"=",1)=$P(nam,"=",2)
			}
		}

	// Load local variables from SCA_REF_lvn
	new lvn,ref
	set ref="" 
	for  set ref=$O(vzin(ref)) quit:ref=""  do {
		if $E(ref,1,7)'="SCA_REF" quit
		set lvn=$P(ref,"_",3,999)
		if lvn="CTX" quit
		set @lvn=vzin(ref)
		}

	// Process the message
	do PROC(vzfunc,.vzin,dftpage,.reply,.vzout) if ER quit ER

	// Store context
	new ctx,i
	if '$D(%token) do {
		new X
		set %token=""
		set X=$G(vzin("SCA_REF_CTX")) quit:X=""
		set %token=%SessionID_"_"_X
		}

	if %token="" quit 0

	type RecordPBSBBSSP pbsbbssp=Db.getRecord("PBSBBSSP","TOKEN=:%token",1)
        set CTX=pbsbbssp.ctx
	
	if CTX'="" for i=1:1:$L(CTX,$C(28)) do {
		set nam=$P(CTX,$C(28),i) quit:nam=""
		quit:$D(vzout($P(nam,"=",1)))
		set vzout($P(nam,"=",1))=$P(nam,"=",2)
		}

	set (CTX,ctx)=""
	for i=1:1 set ctx=$O(vzout(ctx)) quit:ctx=""  do {
		if ctx="DEFPAGE" quit
		set $P(CTX,$C(28),i)=ctx_"="_vzout(ctx)
		set @ctx=vzout(ctx)
		}
	

	set pbsbbssp.token=%token
	set pbsbbssp.ctx=CTX

	do pbsbbssp.bypassSave()

	quit ER


PROC(sub,vzin,dftpage,reply,vzout)	//Private; Calls the sub-routine and returns the output

	/*

	   ARGUMENTS:
	   	. sub - Sub-routine call for processing request
	       				  	/TYP=T/REQ/MECH=VAL

	   	. vzin - Input array of control names
	       				    	/TYP=T/REQ/MECH=REFARRAY

	   	. dftpage - Default page to load and serve back to
	      		    client.  	   	/TYP=T/MECH=REFNAM

	   	. reply - HTML Document generated by the compiled code
	      		  established for the default page.
	       				  	/TYP=T/REQ/MECH=REFNAM

	   	. vzout - Output array based on the processing of the
	      		  sub-routine.   	/TYP=T/REQ/MECH=REFARRAY

  	*/

	catch vERROR {
                new ET,RM
                set ET=vERROR.type
 
                if ET["%GTM-" do { quit
                        do ZE^UTLERR
			set reply=$$RM($$^MSG(6747,$G(%ZTSEQ)),1)
                        }
 
                set ET=ET_"-"_vERROR.thrownAt
                set RM=vERROR.description
                do ^UTLERR
                }
	new vzx

	// No function included, call HTML routine directly
	if sub="" do { quit

		type RecordHTML html=Db.getRecord("HTML","PAGE=:dftpage")
		set vzx=html.vpgm

		if vzx="" set ER=1 set RM="Page not found" set reply=$$RM(RM,ER) quit
		set vzx="S reply=$$^"_vzx
		#ACCEPT DATE=12/17/03;PGM=John Carroll
		xecute vzx
		}

	// Execute function, passing the default pagename
	set vzout("DEFPAGE")=dftpage
	set vzx=sub_"(.vzin,.vzout)"
	if $E(sub,1,2)'="$$" set vzx="D "_vzx
	else  set vzx="S ER="_vzx

	#ACCEPT DATE=12/17/03;PGM=John Carroll
	xecute vzx

	if ER set vzout("DEFPAGE")="ERROR"

	set ctx=""
	for i=1:1 set ctx=$O(vzout(ctx)) quit:ctx=""  do {
		if ctx="DEFPAGE" quit
		set @ctx=vzout(ctx)
		}


	set dftpage=vzout("DEFPAGE") 
	set vzx=""

	if dftpage'="" do {
		type RecordHTML html=Db.getRecord("HTML","PAGE=:dftpage")
                set vzx=html.vpgm
		}

	if vzx="" set RM="Page not found" set reply=$$RM(RM,1) quit

	set vzx="S reply=$$^"_vzx

	#ACCEPT DATE=12/17/03;PGM=John Carroll
	xecute vzx

	quit


GETFORM(formid,sub,html)		//Private; Return the executable sub-routine

	/*

	   ARGUMENTS:
	   	. formid  - Name of the form id associated with the HTML
	        	    document.  		/TYP=T/REQ/MECH=VAL

	   	.sub   - Sub-routine or shell to call for processing
	                 this request 		/TYP=T/REQ/MECH=REFNAM

	   	. html    - HTML default page
	       					/TYP=T/REQ/MECH=VAL

	   RETURNS:
	   	. $$   - Error status

	----------------------------------------------------------------------------

	   Go to the browser document table to retrieve information about this
	   particular form id.  This function will return the name of the MUMPS
	   procedural call to execute the request as well as the actual HTML
	   document name.

	*/
	new ER,pagename
	set ER=0
	set formid=$$UPPER^%ZFUNC(formid)
	set pagename=$P(formid,"_",1) 
	set formid=$P(formid,"_",2,999)
	type RecordHTML1 html1=Db.getRecord("HTML1","PAGE=:pagename,FORMID=:formid",1)

	if html1.getMode()=0 set ER=1

        else  set sub=html1.func set html=html1.nxtpage
		
	quit ER


PARSE(msg,control)	// Private; Parse message and return control names

	/*
	   Parse the HTML message to build the control name array from the
	   named pairs in the record.

	   ARGUMENTS:
	   	. msg   - Complete, unformatted message to be parsed
	       				/TYP=T/REQ/MECH=VAL

	   	. control - Control names as found in the message
	       				/TYP=T/REQ/MECH=REFNAM

	   RETURNS:
	   	. $$   -  Error status /TYP=N/REQ

	----------------------------------------------------------------------------------------------
	*/

	set ER=0

	for i=1:1:$L(msg,"&") do {
		set str=$P(msg,"&",i)
		set tag=$P(str,"=",1)
		set dat=$P(str,"=",2)
		if dat'="" set dat=$$trnslat(dat)

		set control(tag)=dat quit
		
		if tag set control(tag)=dat
		else  do {
			set tag1="set control("_$$trnslat(tag)_")=dat"
			#ACCEPT DATE=12/17/03;PGM=John Carroll
			xecute tag1
			}
		}

	quit ER


trnslat(str)	//Translate "unsafe" characters

	new chr,hex,x

	set x=0
	for  set x=$F(str,"%",x) quit:x=0  do {
		set hex=$E(str,x,x+1)
		set chr=$C($$HEXDEC^%ZHEX(hex))
		set str=$E(str,1,x-2)_chr_$E(str,x+2,999999)
		}

	set str=$TR(str,"+"," ")
	quit str


INIT	//Private; Initialize variables

	set %UserID=1 
	set %UserClass="SCA" 
	set BRCD=99 
	set %UserStation="Internet" 
	set PASSWD="XXX"
	set %MASKE=".,"
	
	quit

RM(rm,er)	// Format HTML error message


	new x

	set x="<HTML><BODY>"_$S(er:"<H3>"_rm_"</H3>",1:rm)_"</BODY></HTML>"
	if er set x=$$ERRMSG^PBSUTL(x)
	quit x
 #OPTION ResultClass ON
Public String vSIG()	quit "59886^43595^Sanchez SCM Administrator^9740"	// Signature - LTD^TIME^USER^SIZE
