LNIC		// - Loan Account Integrity Check
	/*
	       ORIG:  Neal E. Gorman
	       DESC:  Accessed by functions: LNI01, LNI02
	
	
	---- Revision History ------------------------------------------------
	
	10/26/05 - RussellDS - CR17834
 		   Replaced calls to EXT^DBSFILER with direct calls to the
 		   filers.
	
	03/12/03 - Dan Russell - 51351
		   Removed call to obsolete executive ^LNEXEC, replaced with
		   VERIFY section in this procedure. 
	
	01/08/03 - Dan Russell - 51349
		   Correct #Accept syntax.

	08/06/02 - Dan Russell - 49794
		   Converted to PSL.  Removed old change history.
	----------------------------------------------------------------------
	*/

	// Single account if called from the top

	type Public String ER,RM
	type Date DATE
	type Number CID,OLNTB
	type String IO,%READ(),%TAB(),VFMQ

	new CID,DATE,IO,%NOPRMT,OLNTB,%READ,%TAB,VFMQ

	set %TAB("CID")=".CID3/XPP=S %EXT=1 D ^UACN/XPR=S (CLS,ZCLS)=""L"""
	set %TAB("IO")=$$IO^SCATAB($I)
	set %READ="@@%FN,,,CID/REQ,IO/REQ"

	do ^UTLREAD quit:VFMQ="Q"

	// Delete old entries
	set DATE=%SystemDate
	do Db.delete("XBAD","AKEYS=:CID AND TDATE=:DATE AND TABLE='LN'")
	do Db.delete("XBAD","AKEYS=:CID AND TDATE=:DATE AND TABLE='LNBIL0'")
	// files where AKEYS contain more then just the primary key
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:DATE AND TABLE='LNFEE'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:DATE AND TABLE='LNPS1'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:DATE AND TABLE='LNDS1'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:DATE AND TABLE='LNCYCPTS'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:DATE AND TABLE='LNCYCMSC'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:DATE AND TABLE='LNCYCINS'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:DATE AND TABLE='LNCYCDLD'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:DATE AND TABLE='LNADV'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:DATE AND TABLE='LNCOL'")
	
	type RecordLN ln=Db.getRecord("LN","CID=:CID")
	do EXEC(.ln) quit:ER

	do DSPERR^DBSEXECU(CID,IO)

	// No file integrity problems found
	if '$D(verrors) set ER="W",RM=$$^MSG(1938)
	else  do DSPERR^DBSEXECU(CID,IO)

	quit
	

XCLS(String TYPELIST)	/* Class/group/type    (Called by function CIFVER1)

	ARGUMENTS:
		. TYPELIST	List of types	/NOREQ/MECH=REFARR:R
				to check.

	If called externally (%EXT=1), and no TYPELIST, do all types.
	If not called externally, prompt for types.
	*/

	type Number ER,%EXT
	type Public String RM
	type Date DATE
	type Number QUIT
	type String GRP,TYPELIST,VFMQ,WHERE

	if '$D(%EXT) do QRY(.TYPELIST) quit:ER!(VFMQ="Q")

	set DATE=%SystemDate
	// Delete old entries
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LN'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LNADV'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LNBIL0'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LNCOL'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LNCYCDLD'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LNCYCINS'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LNCYCMSC'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LNCYCPTS'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LNDS1'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LNFEE'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='LNPS1'")

	// Build select list for types in TYPELIST
	set WHERE=""
	if $D(TYPELIST) do {
		new IN,N
		set IN="(",N=""
		for  set N=$O(TYPELIST(N)) quit:N=""  set IN=IN_N_","
		set WHERE="TYPE IN "_$E(IN,1,$L(IN)-1)_")"
	}

	#ACCEPT DATE=8/12/02; PGM=Dan Russell; CR=Allan Mattson
	type DbSet lnds=Db.selectDbSet("LN",WHERE)

	set QUIT=0
	while lnds.next() do { quit:QUIT
		type RecordLN ln=lnds.getRecord("LN")
		do EXEC(.ln)
	}

	quit
	

QRY(String TYPELIST)	//Private - Query

	type String GRP,N

	do ^QRYGRP("L",.GRPLIST) quit:ER!(VFMQ="Q")

	set (GRP,N)=""
	for  set N=$O(GRPLIST(N)) quit:N=""  set GRP=GRP_N_","
	set GRP=$E(GRP,1,$L(GRP)-1)

	do ^QRYTYPE("L",GRP,.TYPELIST)

	quit
	

EXEC(RecordLN ln) // Execute the integrity
	/*
	   OUTPUT:
	   . RM		Return message
	*/

	type Number CID
	type String MFRE,SVFRE,verrors,vfkey

	set CID=ln.cid

	if ln.stat=4 do {			// Closed account
		
		type Number SAVEMODE
		
		set SAVEMODE = ln.getMode()
		
		do ln.setMode(2)
		do ^LNFILE(.ln, "/NOVALDD/NOINDEX/NOVALREQ")

		do ln.setMode(SAVEMODE)
		}     

	else  do VERIFY(CID)

	if $D(verrors) do XBAD^DBSEXECU(.verrors)

	quit
	

VERIFY(Number CID)	/* Public - run integity check on one LN record

	ARGUMENTS:
		. CID		LN Number	/REQ/NONULL/MECH=VAL
		
	RETURNS:
		. ER		Error flag	/TYP=L

		. RM		Error message	/TYP=T
		
		. verrors()	Error array	/TYP=T
	*/
	
	type Public Number ER=0
	type Public String RM,verrors()
	
	type RecordLN ln = Db.getRecord("LN", "CID=:CID")
	
	do ln.setMode(2)
	do ^LNFILE(.ln)		// Validate a single LN record

	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0", "CID=:CID", 1)
	
	if (lnbil0.getMode() > 0) do {
	
		do lnbil0.setMode(2)
		do ^LNBIL0FL(.lnbil0)		// Validate LNBIL0 table
	}
	
	// Validate RELCIF table
	do { quit:ER
		type ResultSet rs=Db.select("ACN","RELCIF","CID=:CID")
		
		while rs.next() do { quit:ER
			type Number ACN

			set ACN=rs.getCol("ACN")
			
			type RecordRELCIF relcif = Db.getRecord("RELCIF", "ACN=:ACN,CID=:CID")
			
			do relcif.setMode(2)
			do ^RCIFFILE(.relcif)
			}
		}

	// Validate TIKLACN table
	do { quit:ER
		type ResultSet rs=Db.select("TKS","TIKLACN","CID=:CID")
		
		while rs.next() do { quit:ER
			type Number TKS

			set TKS=rs.getCol("TKS")
			
			type RecordTIKLACN tiklacn = Db.getRecord("TIKLACN", "CID=:CID,TKS=:TKS")
			
			do tiklacn.setMode(2)
			do ^TIKLACNF(.tiklacn)
			}
		}

	// Validate LNFEE table
	do { quit:ER
		type ResultSet rs=Db.select("FEETYP","LNFEE","CID=:CID")
		
		while rs.next() do { quit:ER
			type String FEETYP

			set FEETYP=rs.getCol("FEETYP")
			
			type RecordLNFEE lnfee = Db.getRecord("LNFEE", "CID=:CID,FEETYP=:FEETYP")
			
			do lnfee.setMode(2)
			do ^LNFEEFL(.lnfee)
			}
		}

	// Validate LNPS1 table
	do { quit:ER
		type ResultSet rs=Db.select("PDD","LNPS1","CID=:CID")
		
		while rs.next() do { quit:ER
			type Date PDD

			set PDD=rs.getCol("PDD")
			
			type RecordLNPS1 lnps1 = Db.getRecord("LNPS1", "CID=:CID,PDD=:PDD")
			
			do lnps1.setMode(2)
			do ^LNPS1FL(.lnps1)
			}
		}

	// Validate LNDS1 table
	do { quit:ER
		type ResultSet rs=Db.select("SDD","LNDS1","CID=:CID")
		
		while rs.next() do { quit:ER
			type Date SDD

			set SDD=rs.getCol("SDD")
			
			type RecordLNDS1 lnds1 = Db.getRecord("LNDS1", "CID=:CID,SDD=:SDD")
			
			do lnds1.setMode(2)
			do ^LNDS1FIL(.lnds1)
			}
		}

	// Validate LNCYCPTS table
	do { quit:ER
		type ResultSet rs=Db.select("TYP","LNCYCPTS","CID=:CID")
		
		while rs.next() do { quit:ER
			type String TYP

			set TYP=rs.getCol("TYP")
			
			type RecordLNCYCPTS lncycpts = Db.getRecord("LNCYCPTS", "CID=:CID,TYP=:TYP")
			
			do lncycpts.setMode(2)
			do ^LNCPTSFL(.lncycpts)
			}
		}		

	// Validate LNCYCMSC table
	do { quit:ER
		type ResultSet rs=Db.select("TYP","LNCYCMSC","CID=:CID")
		
		while rs.next() do { quit:ER
			type String TYP

			set TYP=rs.getCol("TYP")
			
			type RecordLNCYCMSC lncycmsc = Db.getRecord("LNCYCMSC", "CID=:CID,TYP=:TYP")
			
			do lncycmsc.setMode(2)
			do ^LNCMSCFL(.lncycmsc)
			}
		}		

	// Validate LNCYCINS table
	do { quit:ER
		type ResultSet rs=Db.select("TYP","LNCYCINS","CID=:CID")
		
		while rs.next() do { quit:ER
			type String TYP

			set TYP=rs.getCol("TYP")
			
			type RecordLNCYCINS lncycins = Db.getRecord("LNCYCINS", "CID=:CID,TYP=:TYP")
			
			do lncycins.setMode(2)
			do ^LNCINSFL(.lncycins)
			}
		}		

	// Validate LNCYCDLD table
	do { quit:ER
		type ResultSet rs=Db.select("TYP","LNCYCDLD","CID=:CID")
		
		while rs.next() do { quit:ER
			type String TYP

			set TYP=rs.getCol("TYP")
			
			type RecordLNCYCDLD lncycdld = Db.getRecord("LNCYCDLD", "CID=:CID,TYP=:TYP")
			
			do lncycdld.setMode(2)
			do ^LNCDLDFL(.lncycdld)
			}
		}

	// Validate LNADV table
	do { quit:ER
		type ResultSet rs=Db.select("ADV","LNADV","CID=:CID")
		
		while rs.next() do { quit:ER
			type Number ADV

			set ADV=rs.getCol("ADV")
			
			type RecordLNADV lnadv = Db.getRecord("LNADV", "CID=:CID,ADV=:ADV")
			
			do lnadv.setMode(2)
			do ^LNADVFL(.lnadv)
			}
		}

	// Validate LNCOL table
	do { quit:ER
		type ResultSet rs=Db.select("COLL","LNCOL","CID=:CID")
		
		while rs.next() do { quit:ER
			type Number COLL

			set COLL=rs.getCol("COLL")
			
			type RecordLNCOL lncol = Db.getRecord("LNCOL", "CID=:CID,COLL=:COLL")
			
			do lncol.setMode(2)
			do ^LNCOLFL(.lncol)
			}
		}


	do CMBSTMVF^MSCFUNCS(CID)		// Validate combined statements
	
	quit

vSIG()	quit "60211^58788^Dan Russell^8147"	// Signature - LTD^TIME^USER^SIZE
