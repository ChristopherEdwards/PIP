LNEAB1(RecordLN ln,EABL,EABE)	// Part 2 Escrow Analysis
	/*


	---- Revision History ------------------------------------------------
	03/30/06 - Srinivar - CR 20188
		   Modified the ODM section by rounding-off the Variable
		   WAE which will prevent the error "Error 
		   LNAPCHG.AELAP field length 8 Exceeded".
		
	02/14/06 - Srinivar - CR 19137
	           Modified the sections LNEAB1,NXE,ODM,LN to accept
	           EABE,EABL as a parameters to save back the Re analysis
	           changes.
        		
        07/26/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.
	              	
	01/12/04 - CARROLLJ - CR7901
		   Corrected precedence errors.

	05/12/03 - GRAY - 51351
		   Converted to PSL.  Removed old revision history.


	*/

	
	type Boolean AFLG,RFLG
	type Date APCLD,DIST1ND,DIST2ND,DIST3ND,DIST4ND,FROMDT,ICHND
	type Date JD,LBDD,NJD,ODD,PCHND,SCHND,THRUDT
	type Number AF,ANAF,BR,COLL,DIST1AF,EC,ECID,ELENUM,IAM,IRN,IRNC=0
	type Number LBAL,NPMTTRS,OSEQ,PINC=0,PMT,PMTPI,PMTTRS,ROPT,TBA,TEB,TYP,X
	type String ACN(),ANFRE,BIL0,BIL1,DIST1FRE,DIST2FRE,DIST3FRE,DIST4FRE
	type String E,EA,EBAL,ETYP,FRE,LERR,P,RND,TD,TL,TP
	type Public Date APCND
	type Public Number %EXT,ER=0,LCID,AL1Y
	type Public String LED
	type Public Cache %CACHE()

	catch vERROR {
		catch vERROR1 {
			}
		type Number %ZHALT,%ZTDY,%ZTSEQ
		type String E,ET
		type Public Number ER,ERRL,SING

		if 'SING.data() set SING=1

		// log MUMPS error
		set %ZHALT=0 set %ZTDY=-1 do ZE^UTLERR

		set E="E0" set ER=1 set ET=ERRL(E)_%ZTSEQ.get()

		do EXD

		do NX
		}

	lock +ACN(LCID):2 else  do { quit
		set ER=1 
		set LERR(1)="E1" 
		do KILL() 
		do NX 
		}

	set PMTTRS=ln.pmttrs
	set PMT=ln.pmt

	set NPMTTRS=0
	if '%EXT.get() set APCND=ln.apcnd

	if ln.stat=4 do KILL() do NX quit
	
	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID=:LCID")
	
	set TYP=ln.type
	set BR=ln.boo
	set LBAL=ln.bal
	
	if ln.aruf set LBAL=LBAL-ln.udbal

	if 'LBAL set ER=1 set LERR(2)="E2" do KILL(.lnbil0) do NX quit

	set ODD=ln.odd

	// Check to see if the loan is less than one year old and no analysis
	if APCND-365<ODD if AL1Y=2 set LERR(4)="O2" do KILL(.lnbil0) do NX quit

	// Set period to analyze (project)
	do { if ER do NX quit
		set (JD,FROMDT)=APCND set FRE=ln.anfre
		if FRE="" set ER=1 set LERR(8)="O4" quit
		set NJD=$$NJD^UFRE(JD,FRE) quit:ER
		set THRUDT=NJD-1
		if $$NJD^UFRE(JD,"1YA")-1>THRUDT quit:ER  set THRUDT=$$NJD^UFRE(JD,"1YA")-1
		}


	// Initialize loan variables
	set IAM=ln.icm
	set TEB=ln.teb
	set PMTPI=ln.pmtpi
	set PCHND=ln.pchnd
	set ICHND=ln.ichnd
	
	if PCHND do {
		type RecordLNPTCHG lnptchg=Db.getRecord("LNPTCHG","PCHND=:PCHND,CID=:LCID",1)
		set PINC=lnptchg.npmt
		}

	if ICHND do { 
		type RecordLNVRCHG lnvrchg=Db.getRecord("LNVRCHG","ICHND=:ICHND,CID=:LCID",1)
		set IRNC=lnvrchg.nrate
		}

	set IRN=ln.irn
	set DIST1FRE=ln.dist1fre
	set DIST1ND=ln.dist1nd
	set DIST1AF=ln.dist1af
	set COLL=ln.coll
	set LBDD=ln.lbdd
	if 'LBDD.length() set LBDD=ln.schld

	// Check for new P+I and IRN
	if ICHND,IRNC,APCND'<ICHND set IRN=IRNC
	if PCHND,PINC,IAM,APCND'<PCHND set PMTPI=PINC
	else  if PCHND,PINC,'IAM,APCND'<PCHND do { if ER.get() do NX quit
		set FRE=DIST1FRE 
		set JD=PCHND 
		do UFRE quit:ER  
		if APCND'<NJD set PMTPI=PINC
		}

	set RFLG=ln.rflg
	set SCHND=ln.schnd
	set RND=ln.rnd
	set OSEQ=ln.oseq
	set TBA=ln.tba
	set DIST2ND=ln.dist2nd
	set DIST2FRE=ln.dist2fre
	set DIST3ND=ln.dist3nd
	set DIST3FRE=ln.dist3fre
	set DIST4ND=ln.dist4nd
	set DIST4FRE=ln.dist4fre
	set ANFRE=ln.anfre
	set APCLD=ln.apcld

	// These are the data items which may be overlayed.
	set ROPT=ln.ropt
	set AFLG=ln.aflg

	// Overlay loan account data with new values
	if LED(0).data() set LERR(99)="W3" do LN^LNEABPD

	// Conduct No Analysis, set up [PCBD]
	if 'AFLG set LERR(3)="O1" do KILL(.lnbil0) do EAB(.ln) quit

	// Check to see if the loan is less than one year old and produce coupon
	// book
	if APCND-365<ODD,AL1Y=3 set LERR(5)="O3" do KILL(.lnbil0) do LN(.ln) quit

	set FRE=ANFRE set JD=APCND do UFRE quit:ER
	set ANAF=AF

	/*	   
	Set up arrays containing transfer amounts (TP), escrow amounts in ^BIL
	(EBAL), transfer distribution # (TD), lump payment (TL)
	*/
	
	set ELENUM=0
	for  set EA=$$ESCACT^BILFUNCS(.lnbil0,.ELENUM) quit:EA=""  do {
		set P=EA.piece($C(9),2)
		if P.length()<2 quit
		set ETYP=P.translate("0123456789")
		if '$$ESC^LNU(ETYP) quit

		type RecordLNTRS lntrs=%CACHE("LNTRS").getRecord("LNTRS","TRTYPE=:ETYP")
		// non-escrow processing
		if lntrs.nepf quit
		set ECID=EA.piece($C(9),1)

		type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
		if dep.stat=4 quit

		set E(ELENUM)=ECID
		set EBAL(ECID)=P
		set TP(ECID)=dep.curramt

		set NPMTTRS=NPMTTRS+TP(ECID)
	
		set BIL0=$$BIL0^BILFUNCS(.lnbil0,P)

		set TD(ECID)=BIL0.piece("#",4) if 'TD(ECID) quit

		set TL(ECID)=BIL0.piece("#",5)

		if TD(ECID)=1 set FRE=DIST1FRE
		if TD(ECID)=2 set FRE=DIST2FRE
		if TD(ECID)=3 set FRE=DIST3FRE
		if TD(ECID)=4 set FRE=DIST4FRE
	
		if FRE="*" set TD(ECID).piece("|",2)=$$^SCARND($$PSAF^LNCO2(LCID,TD(ECID),APCLD,APCND),0,"","",0) quit
		set JD=APCND do UFRE quit:ER
		set TD(ECID).piece("|",2)=(AF/ANAF).justify(0,0)
		}


	if TBA=0 do NXE(.ln,.lnbil0,.EABL,.EABE) quit
	
	set X=""

	type DbSet bil1ds=Db.selectDbSet("LNBIL1","CID=:LCID AND SCHSEQ>:OSEQ")
	while bil1ds.next() do {
		type RecordLNBIL1 lnbil1=bil1ds.getRecord("LNBIL1")
		for  set X=E(X).order() quit:X=""  do {
			set EC=E(X)
			set BIL1=$$GETFIELD^BILFUNCS(X,.lnbil1)
			set EBAL(EC).piece("|",2)=EBAL(EC).piece("|",2)+BIL1.piece("#",4)
			}
		}

	do NXE(.ln,.lnbil0,.EABL,.EABE)

	quit


NXE(RecordLN ln,RecordLNBIL0 lnbil0,EABL,EABE)	// Call LNEAB2 to collate through each escrow account.

	type Number AEBAL,CEBAL,E,ESREQ,LRBAS,NTRS,POVSH,SVCTL,SVCUSH,SVECID
	type Number TAMTB,TAMTD,TAMTC,TAMTL,TAMTS,TDIS,TEAF
	type String ESC
	type Public Number CTL,CUSH,ECID,LCID
	type Public String EAB(,)

	set SVECID=ECID.get() 
	set ECID="" 
	set SVCUSH=CUSH.get() 
	set SVCTL=CTL.get() 
	do ^LNEAB2(.ln) 
	set CTL=SVCTL set ECID=SVECID

	// Collate through escrow EAB levels to accumulate loan totals
	set (AEBAL,CEBAL,ESREQ,LRBAS,NTRS,POVSH,TAMTB,TAMTD,TAMTC,TAMTL,TAMTS,TDIS,TEAF)=0

	set E=""
	for  set E=EAB(LCID,E).order() quit:E=""  do { 
		set ESC=EAB(LCID,E)
		set NTRS=NTRS+ESC.piece("|",2) set CEBAL=CEBAL+ESC.piece("|",9)
		set AEBAL=AEBAL+ESC.piece("|",8) set TDIS=TDIS+ESC.piece("|",12)
		set POVSH=POVSH+ESC.piece("|",14) set ESREQ=ESREQ+ESC.piece("|",10)
		set LRBAS=$$^SCARND(LRBAS+ESC.piece("|",3),0,LCID)
		set TEAF=TEAF+ESC.piece("|",5)
		set TAMTB=TAMTB+ESC.piece("|",23) set TAMTD=TAMTD+ESC.piece("|",22)
		set TAMTL=TAMTL+ESC.piece("|",24) set TAMTS=TAMTS+ESC.piece("|",25)
		set TAMTC=TAMTC+ESC.piece("|",27)
		}

	do ODM(.ln,.lnbil0,.EABL,.EABE)

	quit


ODM(RecordLN ln,RecordLNBIL0 lnbil0,EABL,EABE)	// Check Overage Disposition Method

	type Number AEAF,E="",R,WAE
	type String X
	type Public Date DIST1ND
	type Public Number AEBAL,CEBAL,COLL,DIST1AF,ER,ESREQ,DIST1AF
	type Public Number LBAL,LCID,LRBAS,NPMTTRS,NTRS,PMT,PMTPI,PMTTRS
	type Public Number PROBAS,POVSH,ROPT,TAMTB,TAMTC,TAMTD,TAMTL,TAMTS
	type Public Number TEB,TDIS
	type Public String DIST1FRE,EAB,EAB(,),EBAL,LERR,RND

	set ln.pmt=PMT-PMTTRS+NPMTTRS
	set ln.pmttrs=NPMTTRS
	
	set WAE=$select(ESREQ:(CEBAL/ESREQ).roundDec(4),1:0)
	if 'ESREQ set AEAF=DIST1AF 
	else  set AEAF=LRBAS/ESREQ.roundDec(5)
	if 'POVSH set PROBAS=AEAF 
	else  set PROBAS=(TAMTS/POVSH).roundDec(5)
	if PROBAS<0 set PROBAS=-PROBAS

	/*
	Removed all code related to the variable TOL and the arrays TSH and
	TOVR.  The C1 section used to set up the values for TSH and TOVR, but
	stopped doing so when the new escrow project was developed in 1995.
	Also removed the O3 sub-routine.			SPG 05/12/03 
	*/
	
	do SPREAD(.lnbil0) 

	if ER do { quit
		do ln.save()
		do NX 
		}

	if 'AEAF.data() do {
		if 'ESREQ set AEAF=DIST1AF
		else  set AEAF=(LRBAS/ESREQ).roundDec(5)
		}

	if 'POVSH set PROBAS=AEAF 
	else  set PROBAS=(TAMTS/POVSH).roundDec(5)

	// Check rounding options
	set R=0
	if 'EAB.data() do KILL(.lnbil0) do EAB(.ln) quit

	// No new calculated transfer amount (escrow payment amount)
	if 'NTRS set LERR(6)="W1"

	// If escrow-to-round is not set, set it to first escrow acct
	if RND="" set RND="ESC1"

	// Round if there is an escrow payment amount and appropriate ROPT
	if NTRS,ROPT<2 do {
		for  set E=EBAL(E).order() quit:E=""  quit:EBAL(E).piece("|",1)=RND
		if E="" quit

		// ROPT=1 - round total escrow as required by loan
		if ROPT=1 set R=NTRS set R=(1-(R-(R\1)))#1

		// ROPT=0 - round total loan payment
		if 'ROPT set R=PMTPI+NTRS set R=(1-(R-(R\1)))#1

		set EAB(LCID,E).piece("|",2)=EAB(LCID,E).piece("|",2)+R
		set EAB(LCID,E).piece("|",16)=EAB(LCID,E).piece("|",16)+R
		set NTRS=NTRS+R
		}

	set X=(+NTRS)_"|"_DIST1ND_"|"_DIST1FRE_"|"_DIST1AF_"|"_(+PMTTRS)_"|"_(+LBAL)
	set X=X_"|"_(+TEB)_"|"_(+CEBAL)_"|"_(+AEBAL)_"|"_(+TDIS)_"|"_(+POVSH)_"|"_(+ESREQ)
	set X=X_"|"_COLL_"|"_(+LRBAS)_"|"_ROPT_"|"_(+PMTPI)_"|"_PROBAS_"||"_(+R)_"|"
	set X=X_AEAF_"|"_WAE_"|"_(+TAMTD)_"|"_(+TAMTB)_"|"_(+TAMTL)_"|"_(+TAMTS)_"||"
	set X=X_TAMTC

	set EAB(LCID)=X

	do LN(.ln,.EABL,.EABE)
	
	quit


LN(RecordLN ln,EABL,EABE)	// Set up loan level EAB, set in ^PCBD
	
	type Date PND
	type Public Date APCND
	type Public Number AL1Y,LCID,NTRS,PMTPI,PMTTRS,SVECID,CTL
	type Public String EAB,EAB(,)

	if 'CTL.get() do { do NX quit
		set EABL=EAB(LCID).get()
		set EABE=EAB(LCID,SVECID).get()
		}

	if 'NTRS.data() set NTRS=0

	type RecordLNAPCHG lnapchg=Db.getRecord("LNAPCHG","CID=:LCID,APCND=:APCND",1)
	if AL1Y=3 set lnapchg.ntrs=PMTTRS
	set lnapchg.lnd=EAB(LCID).piece("|",2)
	set lnapchg.lfre=EAB(LCID).piece("|",3)
	set lnapchg.laf=EAB(LCID).piece("|",4)
	set lnapchg.otrs=EAB(LCID).piece("|",5)
	set lnapchg.olbal=EAB(LCID).piece("|",6)
	set lnapchg.oebal=EAB(LCID).piece("|",7)
	set lnapchg.cebal=EAB(LCID).piece("|",8)
	set lnapchg.aebal=EAB(LCID).piece("|",9)
	set lnapchg.tdis=EAB(LCID).piece("|",10)
	set lnapchg.povsh=EAB(LCID).piece("|",11)
	set lnapchg.esreq=EAB(LCID).piece("|",12)
	set lnapchg.coll=EAB(LCID).piece("|",13)
	set lnapchg.lrbas=EAB(LCID).piece("|",14)
	set lnapchg.rndi=EAB(LCID).piece("|",15)
	set lnapchg.cpi=EAB(LCID).piece("|",16)
	set lnapchg.probas=EAB(LCID).piece("|",17)
	set lnapchg.rnda=EAB(LCID).piece("|",19)
	set lnapchg.aeaf=EAB(LCID).piece("|",20)
	set lnapchg.aelap=EAB(LCID).piece("|",21)
	set lnapchg.tamtd=EAB(LCID).piece("|",22)
	set lnapchg.tamtb=EAB(LCID).piece("|",23)
	set lnapchg.tamtl=EAB(LCID).piece("|",24)
	set lnapchg.tamts=EAB(LCID).piece("|",25)

	do lnapchg.save()

	// Update coupon production data for loans with CBMET equal to 2
	
	if ln.cbmet'=2 do LN1(.ln) quit
	
	set PND=APCND-ln.cboff

	type RecordLNCPN lncpn=Db.getRecord("LNCPN","PND=:PND,PMET=2,CID=:LCID",1)
	set lncpn.pcb=APCND
	set lncpn.ncn=1
	set lncpn.ndd=APCND
	set lncpn.tpt=PMTPI+NTRS
	set lncpn.pmtpi=PMTPI
	set lncpn.pmttrs=NTRS

	do lncpn.save()

	set ln.cbond=ln.cbpnd
	set ln.cbpld=ln.cbpnd

	set ln.cbpnd=APCND-ln.cboff
	
	do LN1(.ln)

	quit


LN1(RecordLN ln)	//

	type Number E=""
	type Date XTJD=""
	type Public Boolean RERUN
	type Public Date APCND,SVTJD,TJD
	type Public Number ARRCNT,LCID,S
	type Public String %FN,%MSKD,%UserID,EAB(,)

	if RERUN.get() do {
		if SVTJD.get(),SVTJD'=TJD do {
			set XTJD=TJD
			set TJD=SVTJD
			}

		type Date %EffectiveDate
		set %EffectiveDate=%SystemDate
		type RecordHIST hist=Class.new("RecordHIST")
		set hist.cid=LCID
		set hist.tseq=Db.nextVal("HIST","CID=:LCID")
		// Function ~p1 used for ~p2
		set hist.tcmt=$$^MSG(5524,%FN.get(),$$DAT^%ZM(%EffectiveDate,%MSKD.get()))
		set hist.uid=%UserID.get()
		do hist.save()

		if XTJD set TJD=XTJD

		set ARRCNT=ARRCNT+1
		}

	for  set E=EAB(LCID,E).order() quit:E=""  do {
		type RecordLNAPCHGE chge=Db.getRecord("LNAPCHGE","APCND=:APCND,CID=:LCID,ECID=:E",1)

		set chge.ept=EAB(LCID,E).piece("|",1)
		set chge.epmt=EAB(LCID,E).piece("|",2)
		set chge.eaf=EAB(LCID,E).piece("|",5)
		set chge.cbal=EAB(LCID,E).piece("|",7)
		set chge.abal=EAB(LCID,E).piece("|",8)
		set chge.clbal=EAB(LCID,E).piece("|",9)
		set chge.ereq=EAB(LCID,E).piece("|",10)
		set chge.pdis=EAB(LCID,E).piece("|",14)
		set chge.rnda=EAB(LCID,E).piece("|",16)
		set chge.opmt=EAB(LCID,E).piece("|",19)
		set chge.proper=EAB(LCID,E).piece("|",20)
		set chge.amtd=EAB(LCID,E).piece("|",22)
		set chge.amtb=EAB(LCID,E).piece("|",23)
		set chge.amtl=EAB(LCID,E).piece("|",24)
		set chge.amts=EAB(LCID,E).piece("|",25)
		set chge.amtc=EAB(LCID,E).piece("|",27)
		set chge.cush=EAB(LCID,E).piece("|",28)
		set chge.lowbala=EAB(LCID,E).piece("|",29)
		set chge.ebal=EAB(LCID,E).piece("|",30)
		set chge.ovg=EAB(LCID,E).piece("|",31)
		set chge.shtg=EAB(LCID,E).piece("|",32)
		set chge.def=EAB(LCID,E).piece("|",33)
		set chge.odm=EAB(LCID,E).piece("|",34)
		set chge.sdm=EAB(LCID,E).piece("|",35)
		set chge.ddm=EAB(LCID,E).piece("|",36)
		set chge.remtot=EAB(LCID,E).piece("|",37)

		do chge.save()
		}
	
	do ln.save()
	
	do NX

	quit


KILL(RecordLNBIL0 lnbil0)	// kill ^PCBD entry
	
	type Number I,XCID
	type String BIL0,N,T
	type Public Date APCND
	type Public Number LCID,PMTTRS
	type Public Cache %CACHE()

	do Db.delete("LNAPCHG","APCND=:APCND AND CID=:LCID")
	if 'lnbil0.getPointer() quit
	
	type RecordLNAPCHG lnapchg=Class.new("RecordLNAPCHG")
	set lnapchg.apcnd=APCND
	set lnapchg.cid=LCID
	set lnapchg.ntrs=PMTTRS

	do lnapchg.save()	

	set BIL0=$$BIL0ELE^BILFUNCS(.lnbil0)
	
	for I=1:1 set N=BIL0.piece($C(9),I) quit:'N.length()  do {
		// check for non-escrow processing
		set T=N.piece("#",1) if T.length()<2 quit

		set T=T.translate("0123456789")
		if '$$ESC^LNU(T) quit

		set XCID=N.piece("#",2)
		
		type RecordDEP dep=Db.getRecord("DEP","CID=:XCID",1)
		if dep.stat=4 quit

		type RecordLNTRS lntrs=%CACHE("LNTRS").getRecord("LNTRS","TRTYPE=:T")
		if lntrs.nepf quit

		type RecordLNAPCHGE chge=Db.getRecord("LNAPCHGE","APCND=:APCND,CID=:LCID,ECID=:XCID",1)
		set chge.ept=N.piece("#",1)
		set chge.epmt=N.piece("#",3)

		do chge.save()
		}

	quit



UFRE	//

	type Public Date JD,NJD
	type Public Number AF,ER,LCID
	type Public String FRE

	if FRE["*" do { quit
		type Number CID
		set CID=LCID
		set NJD=$$NJD^UFRE(JD,FRE,.AF) quit:ER
		}

	set NJD=$$NJD^UFRE(JD,FRE,.AF) quit:ER

	quit


NX	//
	
	type Public Number ER,N
	type String E,ET

	type Public Number LCID
	type Public String ACN(),ERRL,LERR

	lock -ACN(LCID)

	if LERR.data() do {
		set N=""
		for  set N=LERR(N).order() quit:N=""!(N>98)  do {
			set E=LERR(N) 
			set ET=ERRL(E) 
			do EXD
			}
		}

	set (ER,ET)=""

	quit


EXD	// File Dayend exceptions

	type Public Number %EXT,LCID,RSEQ
	type Public String E,ET,RM()
	
	if '%EXT.get() do {
		type RecordDAYENDEAEXC eaexc=Class.new("RecordDAYENDEAEXC")
		set eaexc.efd=%SystemDate
		set eaexc.etyp=E.extract()
		set eaexc.cid=LCID
		set eaexc.ecid=0
		set eaexc.eer=E
		set eaexc.desc=ET
		do eaexc.bypassSave()
		}
	
	else  do {
		set RSEQ=RSEQ.get()+1 
		if RSEQ>20 quit
		// Loan:  ~p1
		set RM(RSEQ)=$$^MSG(1655,ET)
		}

	quit


EAB(RecordLN ln)	// Allow entry to ^PCBD for loans which have no analysis flag set

	type String X
	type Public Date DIST1ND	
	type Public Number COLL,DIST1AF,DIST1AF,E,LBAL,LCID,PMTPI,PMTTRS
	type Public Number ROPT,TEB
	type Public String DIST1FRE,EAB()

	set X=PMTTRS_"|"_DIST1ND_"|"_DIST1FRE_"|"_DIST1AF_"|"_PMTTRS_"|"_LBAL_"|"
	set X=X_TEB_"|"_TEB_"|"_TEB_"|0|0|"_PMTTRS_"|"_COLL_"|0|"_ROPT_"|"_PMTPI

	set EAB(LCID)=X set E=""

	do LN(.ln)

	quit


SPREAD(RecordLNBIL0 lnbil0)	// Spread escrows


	type Number AMT,AMTS,E,PB
	type String X
	type Public Number ER,LCID,NTRS,POVSH,PMTPI,REJFLG
	type Public String EAB(,),LERR

	set E="" set POVSH=0

	for  set E=EAB(LCID,E).order() quit:E=""  do { 
		set X=EAB(LCID,E)
		set AMTS=X.piece("|",25) if 'AMTS quit
		// proration basis
		set PB=X.piece("|",20) if 'PB set PB=X.piece("|",5)
		// amt to be add/sub
		set AMT=$$^SCARND(AMTS/PB,0,E)
		// PDIS
		set X.piece("|",14)=AMT
		// new escrow pmt
		set X.piece("|",2)=X.piece("|",2)+AMT
		set NTRS=NTRS+AMT
		// don't allow neg pmt
		if X.piece("|",2)<0 set X.piece("|",2)=0

		set EAB(LCID,E)=X

		if NTRS+PMTPI<PMTPI do { quit
			set REJFLG=1 
			set LERR(7)="W4" 
			set ER=1 
			do KILL(.lnbil0) 
			do NX
			}
		}

	quit

vSIG()	quit "60355^29470^Srinivasan, Rajesh^15569"	// Signature - LTD^TIME^USER^SIZE
