UCIF
	// CIF Number Lookup Utility
	/*
	   ORIG: CHIANG 04 APR 1992 (New Version)
	
	   Determine CIF Number Based Upon User Input.
	   The input of a partially matching name, a social security number, or
	   federal tax ID number will return either the account number or a
	   list of possible CIF numbers.
	
	   KEYWORDS: CIF, Validation
	
	   INPUTS:
	       . %EXT External interface flag  		/TYP=L/NOREQ
	
	       . X Input variable   			/TYP=T/COND
	    	 (if variable %EXT set)
	
	   RETURNS:
	       . ACN   Valid CIF Number
	       . ER    Error Flag
	       . RM    Error Message
	
	   EXAMPLE:
	       S X="ABC",%EXT=1 D ^UCIF
	
			  X - Pattern to match
	
			      X may consist of several patterns:
	
				nnnn...      A CIF number (^UCIF will edit
					     check).
	
				"A"-nnnn...  An account number
					     Will list customer name, customer
					     number and the Tax ID number of the
					     primary account owner.
	
				nn-nnnnnnn   Will provide a list of customers
					     with a matching federal tax ID
					     number.
	
				nnn-nn-nnnn  Will provide a list of customers
					     with a matching social security
					     number.
	
				aaaa...      An alpha string which will be
					     matched against other names and
					     provide a list of customers.
	
	---- Revision History ------------------------------------------------
	
	07/10/06 - RussellDS - CR22121
		   Modified code in ALPHA and TAXID sections to eliminate use
		   of MAX character and replace with use of LIKE in SELECT.
		   
	03/21/05 - RussellDS - CR14908
		   Modified call to EXT^UPID to pass account object.
		   
	01/23/05 - RussellDS - CR14643
		   Corrected PSL warnings.
		   
		   Removed old revision history.
	
	12/06/04 - RussellDS - CR13258
		   Removed references to CUVAR.UCIF1M, UCIF2M.  Replace data
		   formatting with use of new DBSTBL.
		   
		   Warnings were cleaned up, and some significant changes made
		   to get this thing to work.  However, the code is still not
		   in particularly good shape and this could stand a major
		   rewrite to restructure the code.
	*/

	// Create temporary tables used within the procedure
	
	type Public Boolean %EXT
	type Public Number ACN, ER, OLNTB
	type Public String %fkey, COLS(), grp, HDG, SELECT, TABLES, RM, X

	type Boolean SQLCODE
	type Number COUNT, CUR, I, LOOKUPPG
	type String KEY(), LKUPFMT, uciflist(), VFMQ, vinput, XACN

	do Db.fastDelete("TMPRPT2","PID=:%ProcessID")

	// Screen/UTLREAD input
	if $D(%EXT),$G(X)="" set ACN="" quit

	// Define keyboard function map
	if '$D(%fkey) do ZBINIT^%TRMVT()

	// Current cursor position
	if $D(OLNTB) set CUR=OLNTB

	// Calculate based on CRT status
	else  set CUR=$$CURPOS
	
	// Default to column 30
	if CUR#1000=0 set CUR=CUR+30

	// If line>16, clear screen and use full screen for display
	if CUR>16000 set CUR=30 write $$CLEAR^%TRMVT
	
	type RecordACN acn

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

	set ACN="" 
	// Build prompts for Account
	set ER=0
     
	if '$D(%EXT) do { if ER quit 
		do ACCOUNT
		if VFMQ="Q" set ER=1,X="" quit 
		set X=ACN 
		set CUR=CUR+3000
		}
	
	// IC# Lookup BBMB
	if $E(X)="*" do { quit:XACN'="TAXID"  quit:ER

		type Number %MAX, CID
		type String file			     

		set XACN=cuvar.xacn
		quit:XACN="" 
		set file="ACN"
		
		if XACN="TAXID" set file="CIF"
		set CID=$$^XACN(XACN,file), X=CID
		if VFMQ="Q" set ER=1,X="" quit
		   
		// Invalid conversion account
		if CID="" set ER=1,RM=$$^MSG(1291)       
		
		if $G(grp)="" quit 
		if XACN'="TAXID" do {
			set acn=Db.getRecord("ACN","CID")
			// Account is not in group ~p1
			if acn.grp'=grp set ER=1,RM=$$^MSG(8228,grp)  
			}
		}
	
	// VALID	
	if (X?1N.N)!($G(XACN)="TAXID")  do { do EXIT quit 
		set ACN=X
		if $G(XACN)="TAXID" do {
			type ResultSet rs=Db.select("NAM","CIF","TAXID=:X")

			if 'rs.isEmpty(),rs.next() set (ACN,X)=rs.getCol(1)	 
			}
		// Account has been purged
		if ACN'="",Db.isDefined("PURGDCIF","ACN") do Runtime.setErrMSG("PURGDCIF",3841) quit:ER 
		if ACN'="",Db.isDefined("CIF","ACN") do PROT quit 
	
		// Invalid customer number
		do Runtime.setErrMSG("CIF",1295) quit:ER	  
		}
	
	// Init access keys
	for I=1:1:2 set KEY(I)=""
	
	// COUNT/page
	set COUNT=22-(CUR\1000)
	
      	// SSN 
      	if X?2N1"-"7N!(X?3N1"-"2N1"-"4N) set KEY(1)="T"

	// TAXID 
	if X?3N1"-"4N!(X?3N1"-"3N1"-"4N) set KEY(1)="T"

	// IC# BBMB
	if $G(XACN)="TAXID" set KEY(1)="T"

	// Alpha Name convert to
	if KEY(1)="" set KEY(1)="A" set X=$$UPPER^%ZFUNC(X)
	
	// Add DISTINCT to avoid having DBSTBL add bottom key - remove when done
	// CIF Name
	set LKUPFMT = "/LEN=20/RH="_$$^MSG(6815)_","_cuvar.UCIF1F_":DISTINCT"
	if KEY(1) = "A" set LKUPFMT = "[CIF]XNAME"_LKUPFMT
	else  set LKUPFMT = "[CIF]NAM"_LKUPFMT
	
	do UACN^DBSTBL(LKUPFMT, .SELECT, .TABLES, .COLS(), .HDG)
	
	set SELECT = SELECT.piece(" ", 2)
	set HDG = "    "_HDG
	
	set LOOKUPPG=1

	set vinput=X

	do OPEN(.KEY)
	
	if ER do {
		set ACN = 0
		// No matches found
		if RM.get().isNull() do Runtime.setErrMSG("CIF",1955) quit:ER
	}
	
	quit
	

CURPOS()	// Calculate current cursor position
	
	type Number X, Y
	
	do CPOS^%TRMVT(.X,.Y)
	if Y<1!(Y>24) quit ""

	quit (((Y - 1) * 1000) + 30)
	
ACCOUNT	// Build prompts for cif number

	type Public Boolean %EXT
	type Public Number ACN, CUR
	
	type Number %MAX, %PAGE, %PG, NI, OLNTB, vni
	type String %MOD, %NOPRMT, %OSAVE, %READ, %TAB(), KVAR, PGM, VO, VSCRPP, X

	set OLNTB=CUR 
	set %TAB("ACN")=".ACN2/XPP=D PP^UCIF"
	set %READ="@@%FN,,,ACN/REQ"
	set %NOPRMT="F"
 	do ^UTLREAD

	quit 

	
OPEN(KEY)	// Request from client/server to return initial access keys
	
	type Public Boolean ER, SQLCODE
	type Public String vinput, uciflist()

	set SQLCODE=0

	// A-CID
	if vinput?1"A-"1N.N do { set SQLCODE=1 quit
		
		type Number CID
		
		set CID=$E(vinput,3,20)+0
		// Primary CIF number
		type ResultSet rs=Db.select("ACN","RELCIF","CID=:CID")
		
		if rs.isEmpty() set ER = 1 quit

		while rs.next() do { quit:(SQLCODE = 1)
		
			do DSPMC(rs.getCol("ACN"))
			if SQLCODE do { quit
				set SQLCODE = 0
				kill uciflist
			}
		}
		
		if $D(uciflist) do NEXTPG1
	}

	if KEY(1)="A" do ALPHA quit

	if KEY(1)="T" do TAXID

	quit


ALPHA	// Alpha Lookup Name

	type Public Boolean ER, SQLCODE
	type Public String KEY(), vinput, uciflist()

	type Boolean EXIT
	type String WHERE

	set EXIT=0
	
	set WHERE = "XNAME LIKE '"_vinput_"%'"

	#ACCEPT DATE=12/06/04;PGM=RussellDS;CR=22121
	type ResultSet rs=Db.select("XNAME,ACN","CIF", WHERE, "XNAME")

	if rs.isEmpty() set ER = 1 quit

	while rs.next() do { quit:EXIT
	
		do FORMAT(rs.getCol("ACN"))
		
		if SQLCODE do {
			do NEXTPG1
			set SQLCODE=0 
			kill uciflist
		}
	}
	   	
	if (uciflist.data() > 0) do NEXTPG1
	   	
	do EXIT

	quit
	

TAXID	// Tax ID Lookup
	
	type Public Boolean ER, SQLCODE
	type Public String KEY(), vinput, uciflist()

	type Boolean EXIT
	type String WHERE
	
	set EXIT=0
	
	set WHERE = "TAXID LIKE '"_vinput_"%'"

	#ACCEPT DATE=12/06/04;PGM=RussellDS;CR=22121
	type ResultSet rs=Db.select("XNAME,ACN","CIF", WHERE)
       
	if rs.isEmpty() set ER = 1 quit

	while rs.next() do { quit:(SQLCODE ! EXIT)

		do FORMAT(rs.getCol("ACN"))
		
		if SQLCODE do {
			do NEXTPG1
			set SQLCODE=0 
			kill uciflist
		}
	}
	       	
	if (uciflist.data() > 0) do NEXTPG1
	
	do EXIT

	quit
	

NEXTPG1	
	type Public Boolean EXIT
	type Public Number ACN, ER, LOOKUPPG
	type Public String %fkey, COLS(), uciflist(), X
	
	type Boolean DONE
	type Number I, J, JOB, K, PAGE, Z2, ZACN, ZDATA
	type String Z, Z1

	// Number of columns
	set K=COLS("").order(-1)

	// Format data
	for I=1:1 quit:'$D(uciflist(I))  do {
	
		set ZACN = uciflist(I).piece($C(1), 2)
		set ZDATA = uciflist(I).piece($C(1), 1)
	
		set Z="" 
		for J=1:1:K  do {

			set Z1 = ZDATA.piece("|",J)
			set Z2 = COLS(J).piece($C(9), 3)
			set Z1 = Z1.extract(1, Z2)
			// Right Justify
			if "N$"[COLS(J).piece($C(9), 2) set Z=Z_$J(Z1,Z2)

			// Left Justifiy
			else  set Z=Z_Z1_$J("",Z2-$L(Z1))

			// column space
			if J'=K set Z=Z_"  "
			}
		set uciflist(I)=Z_$C(1)_ZACN
	}
	     
	set JOB=%ProcessID
	set PAGE=LOOKUPPG
	
	set DONE=0
	
	for  do { quit:DONE
		do DISPLAY
		set PAGE = LOOKUPPG
		type DbSet ds=Db.selectDbSet("TMPRPT2","PID=:%ProcessID AND KEY1=:PAGE")
		if 'X,(%fkey="PDN"!(%fkey="PUP")),'ds.isEmpty() do {  
			kill uciflist

			while ds.next() do {
				
				type Number SEQ
				type String REC
				
				type RecordTMPRPT2 tmprpt2=ds.getRecord("TMPRPT2")
				set SEQ=tmprpt2.key2
				set REC=tmprpt2.data

				set uciflist(SEQ)=REC
				}
			}
		else  set DONE=1
		}  
	
	if 'X,$G(%fkey)="PDN" kill uciflist
	
	if %fkey = "ESC" do {
		
		set ACN = ""
		set EXIT = 1
	}
	
	if 'X.isNull() do {
		set ACN = uciflist(X).piece($C(1), 2)	// Get CIF number
		set X = ACN
		set EXIT = 1
		kill uciflist
	}

	quit

DISPLAY	// Display Lookup Page

	type Public Boolean EXIT
	type Public Number COUNT, CUR, ER, LOOKUPPG, PAGE
	type Public String %fkey, HDG, RM, uciflist(), X
	
	type Number N, OLNTB, E67
	type String ucifxlst()
	
	// Calculate starting location
	set OLNTB=CUR

	// Set option (1-20) to length 2
	set E67=2
	
	// No matches found
	if '$D(uciflist) do { quit
		set ER=1 
		set RM=$$^MSG(1955) 
		set EXIT=1	
		}	

	set X="" 
	if $O(uciflist(""),-1)=COUNT set X="PDN"
	if LOOKUPPG'=1 set X=$S(X="":"PUP",1:X_",PUP")
	
	// Save CIF number from uciflist
	set N = ""
	for  set N = uciflist(N).order() quit:N.isNull()  do {
		
		set ucifxlst(N) = uciflist(N).piece($C(1), 2)
		set uciflist(N) = uciflist(N).piece($C(1), 1)
	}
	
	set X=$$^DBSTBL("uciflist(","","N","","","","","",HDG,X)
	
	// Put account number back into uacnlist
	set N = ""
	for  set N = uciflist(N).order() quit:N.isNull()  set uciflist(N) = uciflist(N)_$C(1)_ucifxlst(N)

	// Save what we just looked at for page up/page down
	if 'X do {
	
		type Number I
		
		type ResultSet rs=Db.select("KEY1","TMPRPT2","PID=:%ProcessID AND KEY1=:PAGE")
		if 'rs.isEmpty() quit

 		for I=1:1 quit:'$D(uciflist(I))  do {
				     
			type RecordTMPRPT2 tmprpt2=Class.new("RecordTMPRPT2")

			set tmprpt2.pid=%ProcessID
			set tmprpt2.key1=LOOKUPPG
			set tmprpt2.key2=I
			set tmprpt2.data=uciflist(I)
			do tmprpt2.bypassSave()
			}	
		}

	// next screen or last screen and we displayed that page already.
	set LOOKUPPG=LOOKUPPG+$S(%fkey="PUP":-1,%fkey="PDN":1,1:"")
	
	quit
	
 
DSPMC(Number ACN)	// Set up the information to display cif's linked to "M"embership

	type RecordCIF cif=Db.getRecord("CIF","ACN",1)
	
	if (cif.getMode() <> 0) do FORMAT(ACN)

	quit
	

FORMAT(Number ACN)	// Access display format definition

	type Public Boolean SQLCODE
	type Public Number COUNT
	type Public String COLS(), SELECT, TABLES, uciflist(), vinput
	
	type Number Z
	type String WHERE

	if ACN="" set SQLCODE=1 quit 
	
	set WHERE = "CIF.ACN=:ACN"
	if TABLES.isLike("%PRODDFTC%") set WHERE = WHERE_" AND CIF.TYPE=PRODDFTC.TYPE"
	
	#ACCEPT DATE=12/06/04;PGM=RussellDS;CR=13258
	type ResultSet rs = Db.select(SELECT, TABLES, WHERE)
	
	if rs.next() do {
		
		type Number CNT, I
		type String row
		
		set CNT = COLS("").order(-1)
		
		set row = rs.getRow()
		
		// Format elements
		for I = 1:1:CNT do {
			
			type Number dec, len
			type String data, fmt
			
			set data = row.piece($C(9), I)
			set fmt = COLS(I).piece($C(9), 2)
			
			if '((fmt = "T") !(fmt = "U") ! (fmt = "F")) do {
			
				set dec = COLS(I).piece($C(9), 4)
				
				if (fmt = "$"), dec.isNull() set dec = 2
				
				set data = $$EXT^%ZM(data, fmt, dec)
				
				set row.piece($C(9), I) = data
			}
		}
		
		// Store in lookup() table
		set Z=$O(uciflist(""),-1)+1 

		set uciflist(Z)=row.translate($C(9), "|")_$C(1)_ACN
	}
	

	if vinput?1A1"-".E quit		

	// Allow 20 entries/request
	if Z=COUNT set SQLCODE=1

	quit 

EXIT	// Clean-up and quit

	type Public Number ACN, ER
	type Public String %DUP(), %fkey
	
	do Db.fastDelete("TMPRPT2","PID=:%ProcessID")

	if (ER > 0) quit
	
	// Set ER to avoid DBSCRT8 display a validation message on data type
	if (ACN.get().isNull() ! (%fkey = "ESC")) set ER = 1 quit 
	
	do:$G(ACN) PROT
 	
	if 'ER,ACN'="" set %DUP("ACN")=ACN
	
	quit
	

Public PP	// Post-processor for cif prompt

	type Public Number ER
	type Public String X

	if X'?1N.N quit 

	// Account has been purged
	if Db.isDefined("PURGDCIF","X") do Runtime.setErrMSG("PURGDCIF",3841) quit:ER 
	
	// Invalid cif
	if 'Db.isDefined("CIF","X") do Runtime.setErrMSG("CIF",1295) quit:ER
	
	quit 
	

Public PROT	// Record Level Protection

	type Public Number ACN, CRT, ER
	type Public String %OSAVE, RM
	
	type String VP
	
	if %ProcessMode=0,'$D(%OSAVE) quit 
	
	set %OSAVE=$G(%OSAVE)
	
	type RecordCIF cif = Db.getRecord("CIF", "ACN=:ACN")
	
	set VP="" 
	do EXT^UPID("CIF", .cif)

	// Record protected
	if $G(VP("*"))=2 do {
		set ER=2 
		set RM=$$^MSG(2336)
		}  
		
	// Record protected
	if $G(%OSAVE)'=2,$G(VP("*"))=1 do {
		set ER=2 
		set RM=$$^MSG(2336)
		}  
	
	/*
	   If the account is being accessed through a file maintenance function
	   check the account record for customer restrictions that may require
	   override.
	*/
	quit:(ER!($G(CRT))) 
	if Db.isDefined("CIF","ACN") do {	    	
		type String CLS 

		set CLS="*"
		if (($G(%OSAVE)=0)!($G(%OSAVE)=1)!($G(%OSAVE)=3)) do CIFFRFLG^FRFLG(ACN)
		}

	quit

vSIG()	quit "60461^55122^Dan Russell^12560"	// Signature - LTD^TIME^USER^SIZE
