LETSTMTL		/*


	  7/2000  - myersk

	  	    This procedure is a utility package for producing
		    standardize statements to be packaged in a daily extract.
		    The functions are called from generated routines base
		    on entries made in the tables STBLBCHFORM, STBLFORM,
		    STBLFORM0, and UTBLFORMVAR.

		    LNTRIG  - creates the entire statement for one loan.
	
		    Any Form Variations set up for form STMLNBILL must
		    have LNTRIG^LETSTMTL in the Custom Routine Field
		    and Y in the parameter field of UTBLFORMVAR

        ---- Revision History------------------------------------------------

	12/22/06 - PUTTASWH - CR 24538
		   Modified to assign the correct value to PCF and removed
		   compilation errors.
		   
	01/30/06 Radhika - CR 17423
		 .Eliminated PSL deprecated features and warnings.
		 .Removed revision history prior to 2004.
	*/
	
	quit

LNTRIG(String AGRP,String FORM,Number VAR)	
	
	// The following values are set in Batch BCHLETSTMBIL
	//
	// 	CID	Account Number
	//	TYPE	Product Type for Account
	//	BILDT	Billing Date (Ending Date of Statement Period)
	//	BDATE	Beginning Date of Statement Period

	// quit if Parmraters not passed or CID not set
	type public Number ACN,CID,TYPE
	type public Date BILDT,BDATE,TJD
	type public String CO
	type Boolean LNSKIP
	type Date TLD
	type Number AFLG,cnt,i,PCRAMT,PDBAMT,AVGBC,TCRAMT,TDBAMT
	type Number BEGTBAL,BEGPBAL,SCNT,SGRP,QFLG,XSEQ
	type String F710,F711,F712,SKIP()
	type String BAL,CLS,DDATA,LDATA,pkeys,RECORDS,REC,SCO,SCD,UAVB(),x,XREC()

	
	quit:AGRP.get().isNull()
	quit:FORM.get().isNull()
	quit:VAR.get().isNull()
	quit:CID.get().isNull()
 	
	// set error trap
        catch vERROR {
                type public String ET,RM
                set ET=vERROR.type
                if ET["%GTM-" do ZE^UTLERR quit
 
                set ET=ET_"-"_vERROR.thrownAt
                set RM=vERROR.description
                do ^UTLERR
                }

	set SCNT=0
	set SGRP=0			// Statement Groups not used for LNBIL

	set LNSKIP=CUVAR.stmtlnskip
	set QFLG=0

 	if CID.get()'=0 do {
 		type RecordACN acnn=Db.getRecord("ACN","CID=:CID")
		set CLS=acnn.cls
		set TLD=acnn.tld
		set BAL=acnn.bal
		if LNSKIP&(BAL=0)&(TLD'>BDATE) set QFLG=1 quit
		if CLS="D" do {
			set SCD=$$XDEP08^DEPCDI(CID)
			set DDATA=SCD.piece("|",1)_$C(9)_SCD.piece("|",2)_$C(9)_SCD.piece("|",3)
			}
		else  do {  
			set SCD=$$XLN14^LNCDI(CID)
                        set LDATA=SCD.piece("|",1)_$C(9)_SCD.piece("|",2)_$C(9)_SCD.piece("|",3)	
			}
		}
	
	quit:QFLG

	// Determine which Record Types Need to be created and process
	// all of them up to the 700's.  Everything above requires
	// special processing
	type RecordUTBLFORMVAR utblform = Db.getRecord("UTBLFORMVAR","CO=:AGRP,FORM=:FORM,VAR=:VAR")
	set RECORDS=utblform.rectypes
	set AFLG=utblform.addrflg

	set REC=$$TRN^LETTERU(CID.get(),ACN.get(),AFLG,FORM,VAR)
	set XSEQ=+Db.currVal("LETSTMT","TJD,AGRP,FORM,VAR,ACN,SGRP")+1
	do FILESTM^LETTERU(ACN,CID,FORM,AGRP,VAR,"TRN",XSEQ,SGRP,REC)

	set i=""
	for cnt=1:1:RECORDS.length(",") set XREC(RECORDS.piece(",",cnt))=""
	for  set i=XREC(i).order() quit:i.isNull()  do {
		type RecordSTBLFORM0 stblform0=Db.getRecord("STBLFORM0","RECTYPE=:i")
		set pkeys=stblform0.acckeys
		if i=201!(i=202) do {  quit
			if i=201 set SCNT=SCNT+1
			if CLS.get()="D" set pkeys=DDATA.piece($C(9),SCNT)
			else  set pkeys=LDATA.get().piece($C(9),SCNT)
			if pkeys.isNull() quit
			set XSEQ=XSEQ+1
			set x="set REC=$$"_i_"^LETTERF("_pkeys_")"
			#ACCEPT DATE=12/08/03;PGM=John Carroll
			xecute x
			do FILESTM^LETTERU(ACN.get(),CID.get(0),FORM,AGRP,VAR,i,XSEQ,SGRP,REC)
			} 
		if ((i=300)!(i=301)) quit
		if ((i=400)!(i=401)),'CLS.get()="L" quit
		
		quit:i'<700
		set x="set REC=$$"_i_"^LETTERF("_pkeys_")"
		#ACCEPT DATE=12/08/03;PGM=John Carroll
		xecute x
		set XSEQ=XSEQ+1
		do FILESTM^LETTERU(ACN.get(),CID,FORM,AGRP,VAR,i,XSEQ,SGRP,REC)
		}

	set BEGTBAL=$$BEGTBAL(BILDT,TYPE,CID)

	// 09/20/00 MYERSK - kill CO to avoid error in EUREQV^CRCDUTL
	set SCO=CO
	kill CO
	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)	
	do INIT^UAVB(acn,CID,BDATE+1,BILDT,"1000000100000111")
	set CO=SCO

	set BEGPBAL=UAVB(1).piece("|",21)
	set PCRAMT=UAVB(1).piece("|",8)
	set PDBAMT=UAVB(1).piece("|",9)
	set AVGBC=UAVB(1).piece("|",1)

	set (TCRAMT,TDBAMT)=0

	// Create the Detail, Summary, and Trailer Records if Required
	set F710=XREC(710).exists()
	set F711=XREC(711).exists()
	set F712=XREC(712).exists()
	if ((F710)!(F711)!(F712)) do DETAIL(CID,F710,F711,F712)	
	if XREC(730).exists() do REC730		// myersk 43728
	if XREC(790).exists() do SUMMARY
	if XREC(798).exists() do TRAILER

	quit
	
DETAIL(Number XCID,String F710,String F711,String F712)  // Write all Detail Records for Statement Period

	type public Cache %CACHE()
	type public Date BDATE,BILDT
	type public Number ACN,CID,BEGTBAL,BEGPBAL,TDBAMT,TCRAMT,VAR,XSEQ
	type public String AGRP,CO,FORM,R730(),SGRP
	type Date efdcmp,PRIORDT,POSTDT
	type Number COA,QFLAG,ENTRIES,HIT,I,NITUF,RSEQ,RUNBAL,RUNBALP,TOT,TSEQ,XTRANCNT,ZQUIT
	type Number CRAMT,DBAMT,ETC,ESCSUS,INT,MISC,p,PRN,PENALTY,SPR,STACK(),UNC,WHLD
	type String CHKNUM,DETCATCD,DETCATDS,REC,SKIP(),SUMCATCD,SUMCATDS,TSO,TAMT,vsql,XITC
	type String ATMMAX,DESC3,ITC1,RTSO,RREV,SEQIND,SCO,SUMCAT,TDES,TRNDESC,TRNDSC
	
	#if $$VALID^%ZRTNS("ZLSTMLB") set ZQUIT=0 do DETAIL^ZLSTMLB quit:ZQUIT
	
	set RUNBAL=BEGTBAL
	set RUNBALP=BEGPBAL
	set XTRANCNT=0

        // Using UHFETCH incase history is archived and desending order
 
        set (HIT,ENTRIES)=0
        type ResultSet rs1=Db.select("TJD,ITC,TSO","HIST","CID=:CID")
	if rs1.isEmpty() quit
	while rs1.next() do {
 
                set POSTDT=rs1.getCol("TJD")
                if POSTDT'>BDATE set HIT=1 quit
                if POSTDT>BILDT quit
 		
		set XITC=rs1.getCol("ITC")
                
		// Exclude if no ITC or Skip Statement Print Flag is set
		if XITC.isNull() quit
		if XITC.extract(5) quit

		// Exclude Error Corrects and Same Day Reversals
		set QFLAG=0
		if (XITC.extract(6))!(XITC.extract(12)) do {
			type ResultSet rs=Db.select("TSEQ","HISTR","CID=:CID AND RSEQ=:TSEQ")
        		if rs.isEmpty() quit
			if 'rs.next() quit
			set RSEQ=rs.getCol("TSEQ")
			// only exlude reversals if reversed transaction was
			// on the same day
			if XITC.extract(12) do {
				type RecordHIST hity=Db.getRecord("HIST","CID=:CID,TSEQ=:RSEQ")
				set PRIORDT=hity.tjd
				if PRIORDT=POSTDT set QFLAG=1,SKIP(RSEQ)=""
				}
			// always exclude error corrects
			else  set QFLAG=1,SKIP(RSEQ)=""
			}
		quit:QFLAG
		
		// Exclude if this tran was reversed or error-corrected
		quit:SKIP(TSEQ).exists()

		// Exclude transactions that were reapplied after a
		// payment reversal
		set TSO=rs1.getCol("TSO")
		quit:TSO["ADJAVCR"

		// myersk - 43728
		// exclude transactions reversed due to the backing out
		// of payments for a reversal transaction
		do OUT^UTSO(.RTSO,TSO)
		set RREV=RTSO("REV").get()
		if RTSO("REAPPLY").get(),RREV set SKIP(RREV)="" quit

                set ENTRIES=ENTRIES+1
                set STACK(ENTRIES)=TSEQ
		}
		
        // Now process in reverse (i.e. chronological) order
        for I=ENTRIES:-1:1 do {
		set TSEQ=STACK(I)
		type RecordHIST hist=Db.getRecord("HIST","CID=:XCID,TSEQ=:TSEQ")

                set XITC=hist.itc
                if XITC.isNull() quit
 
                set ETC=hist.etc
                set TSO=hist.tso
                set TAMT=hist.tamt
		set PRN=hist.prn
		set ITC1=hist.itc1
                if ITC1 do {
                        set TCRAMT=TCRAMT+TAMT  //total credit amount
                        set RUNBAL=RUNBAL-TAMT  //update running bal
			set RUNBALP=RUNBALP-PRN //update running principal bal
                        set CRAMT=TAMT
			set DBAMT=0
			}
                else  do {
                        set TDBAMT=TDBAMT+TAMT  //total debit amount
                        set RUNBAL=RUNBAL+TAMT  //update running bal
			set RUNBALP=RUNBALP+PRN //update running principal bal
                        set DBAMT=TAMT
			set CRAMT=0
			}
		if F710 do {
			set DETCATCD=hist.stmtrd
			set DETCATDS=hist.stmtrdds
			set SUMCATCD=hist.stmtrs
			set SUMCATDS=hist.stmtrsds
			set TOT=hist.tot

                       // create summary information
			set SUMCAT=$S(SUMCATCD="":" ",1:SUMCATCD)
			set R730(SUMCAT).piece("|",1)=R730(SUMCAT).get()+TOT
			set R730(SUMCAT).piece("|",2)=R730(SUMCAT).get().piece("|",2)+1
			set R730(SUMCAT).piece("|",3)=SUMCATDS
			if ITC1 set p=4
			else  set p=6
			set R730(SUMCAT).piece("|",p)=R730(SUMCAT).piece("|",p)+TOT
			set R730(SUMCAT).piece("|",p+1)=R730(SUMCAT).piece("|",p+1)+1

			// kph 10/04/00
			set TDES=$$TDES(ETC)
			//set TDES=hist.tdes

			// MYERSK - kill CO to avoid errors in EUREQV^CRCDUTL
			set SCO=CO
			kill CO

        		// prevent TRNDESC --> set Payment for ~p1  ~p2
			if SCO=870 do {
				type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")				
				if trn.pcfl9=1 set trn.pcf=trn.pcf.extract(1,8)_0_trn.pcf.extract(10,99)
				}

			set TRNDSC=""
			set TRNDESC=hist.trndsc

			set DESC3=""
			if XITC.extract(12) do REVDES^LETSTCMB	//myersk 43728
			set efdcmp=hist.efdcmp
			if efdcmp'=hist.tjd do {
				type String DESC
				// MSG 4752: " - Effective "
				set DESC=$$^MSG(4752)_efdcmp.toString("MM/DD")
				if TDES=TRNDESC set TRNDESC=TDES_DESC 
				set TDES=TDES_DESC
				}
	
			set CO=SCO
			set CHKNUM=hist.chknum
			set SPR=hist.spr
			set SEQIND=""
			set ATMMAX=""
			set REC=$$710^LETTERF(XCID,TSEQ)
			set XSEQ=XSEQ+1
			do FILESTM^LETTERU(ACN.get(),XCID,FORM,AGRP,VAR,710,XSEQ,SGRP,REC)
			}
		if F711 do {
			set TAMT=hist.tot
			set INT=hist.int
			set PENALTY=hist.penalty
			set WHLD=hist.whld
			set MISC=hist.misc
			set ESCSUS=hist.escsus
			set UNC=hist.unc
			set NITUF=hist.nituf
			set COA=hist.coa
			set REC=$$711^LETTERF(XCID,TSEQ)
			set XSEQ=XSEQ+1
			do FILESTM^LETTERU(ACN.get(),XCID,FORM,AGRP,VAR,711,XSEQ,SGRP,REC)
			}
		if F712 do {
			set REC=$$712^LETTERF(XCID,TSEQ)
			set XSEQ=XSEQ+1
			do FILESTM^LETTERU(ACN.get(),XCID,FORM,AGRP,VAR,712,XSEQ,SGRP,REC)
			}
		set XTRANCNT=XTRANCNT+1
		}
		
	quit
	
SUMMARY	
	
	// Create LNBIL Summary Record (790)
	
	type public Date BILDT,BDATE
	type public Number ACN,BEGTBAL,CID,ENDTBAL,FORM,TDBAMT,TCRAMT,TYPE,VAR,XSEQ
	type public String AGRP,SGRP
	type String CPBDP,PMT,REC,XLNBLP01
	type Number FINCHG,TDBAMTFC
	
	#if $$VALID^%ZRTNS("ZLSTMLB") set ZQUIT=0 do SUMMARY^ZLSTMLB quit:ZQUIT
		
	type RecordLNBLP blp=Db.getRecord("LNBLP","BILDT=:BILDT,TYPE=:TYPE,CID=:CID")
	
	set XLNBLP01=blp.xlnblp01
	set FINCHG=XLNBLP01.piece($C(124),1)

	// ofaltr 03/12/02
	set CPBDP=XLNBLP01.piece($C(124),2)
	set PMT=XLNBLP01.piece($C(124),5)

	// 11/16/00 myersk - BEGPBAL,PCRAMT,PDBAMT, and AVGBC now set in LNTRIG
	set TDBAMTFC=TDBAMT+FINCHG
	set ENDTBAL=BEGTBAL+TDBAMTFC-TCRAMT
	set BDATE=BDATE+1			// myersk 43728
	set REC=$$790^LETTERF(BILDT,TYPE,CID)
	set XSEQ=XSEQ+1
	do FILESTM^LETTERU(ACN,CID,FORM,AGRP,VAR,790,XSEQ,SGRP,REC)
	quit

TRAILER	

	// Create LNBIL Trailer Record (798)

	type public Number ACN,CID,VAR,XSEQ
	type public String AGRP,CO,FORM,SGRP
	type Number TOTACCT,TOTTRAN
	type Number XTRANCNT
	type String REC,STMGRP
	
	#if $$VALID^%ZRTNS("ZLSTMLB") set ZQUIT=0 do TRAILER^ZLSTMLB quit:ZQUIT
	set CO=AGRP
	set STMGRP=SGRP
	set TOTACCT=1		// We only wrote 1 acct record
	set TOTTRAN=XTRANCNT
	set REC=$$798^LETTERF()
	set XSEQ=XSEQ+1
			
	do FILESTM^LETTERU(ACN,CID,FORM,AGRP,VAR,798,XSEQ,SGRP,REC)
	quit

TDES(String ETC)	
	
	// Set Transaction Description
	
	type public String DES()
	type String PRDES
	type RecordTRN tr
	
	if 'DES(ETC).exists() do {
		set tr=Db.getRecord("TRN","ETC=:ETC")
		set DES(ETC)=tr.prdes_"|"_tr.des
		}
	set PRDES=DES(ETC).piece("|",1)
	if PRDES.isNull() set PRDES=DES(ETC).piece("|",2)
	quit PRDES
	
public BEGTBAL(Date BILDT,Number TYPE,Number CID)	

	// Returns Beginning Total Balance
	
	/*
	Gets the previous lnblp record and calulates the Beginning Total Bal
	for this period as the Principle Balance on the Last Bill Date +
	Total Due on the Last Bill - Undispursed Principal on the last bill
	- Previously Billed Not Due Principal on the last bill - Current
	Principal Due on the last Bill.
	*/
	
	type Date BLD
	type Number I,LBLB,PBNDP,SCHSEQ,UNPR,TOTDUE
	type String DATA,XLNBLP01
	type Number CPRIN
	
	type RecordLNBLP lnblp=Db.getRecord("LNBLP","BILDT=:BILDT,TYPE=:TYPE,CID=:CID",1)
	if 'lnblp.getMode() quit
	set BLD=lnblp.bld
	set SCHSEQ=lnblp.schseq
	set LBLB=lnblp.lblb
	set XLNBLP01=$$XLNBLP01^LNCDI(CID,SCHSEQ)
	set TOTDUE=XLNBLP01.piece("|",5) 
	for I=3:1:5 set TOTDUE=TOTDUE+lnblp.apd+lnblp.lchg+lnblp.mchg
	set PBNDP=lnblp.pbndp
	set UNPR=lnblp.unpr

	// LNBLP.CPRIN is computed, and won't return the value we need, so
	// we calculate it:
	set DATA=$$GETBILPE^ESCFUNCS(CID,SCHSEQ,"EA,AB")
	for I=1:2:42 if DATA.piece($C(9),I)="P" set CPRIN=+DATA.piece($C(9),I+1) quit

	quit (LBLB+TOTDUE-PBNDP-UNPR-CPRIN)

	
REC730  

	// Create 730 records (transaction summary information)
	//	
	// R730(summary category code) array:
	//      total sum|total count|desc|credit sum|credit count|debit
	//      sum|debit count
                
	type public Number ACN,CID,VAR,XSEQ
	type public String AGRP,CO,FORM,SGRP
	type String CRCNT,CRSUM,DBCNT,DBSUM,data,RECCNT,RECSUM,TRNSUMCD,TRNSUMDS
	type String REC,R730()
	
	set TRNSUMCD=""
	for  set TRNSUMCD=R730(TRNSUMCD).order() quit:TRNSUMCD.isNull()  do {
		set data=R730(TRNSUMCD)
                set TRNSUMDS=data.piece("|",3)
		set RECCNT=data.piece("|",2)
		set RECSUM=data.piece("|",1)
		set CRSUM=data.piece("|",4)
		set CRCNT=data.piece("|",5)
		set DBSUM=data.piece("|",6)
		set DBCNT=data.piece("|",7)
		set REC=$$730^LETTERF
		set XSEQ=XSEQ+1
		do FILESTM^LETTERU(ACN,CID,FORM,AGRP,VAR,730,XSEQ,SGRP,REC)
		}
	quit

	

vSIG()	quit "60627^18489^Hema Puttaswamy^13301"	// Signature - LTD^TIME^USER^SIZE
