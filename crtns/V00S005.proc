V00S005(%ProcessMode,RecordACH2 fACH2,RecordACH1 fACH1)   //PBS - DEP - SID= <ACHDTL> ACH Entry Detail Record Maintenance
 ;;Copyright(c)2006 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/24/2006 11:04 - kini
  /*
ORIG: CHENARDP - 03/03/2003
DESC: PSL Screen Compiler Template

---- Comments --------------------------------------------------------
	This procedure is used as the base template for the PSL screen compiler.
	It is referenced by the PSL screen compiler - procedure DBS2PSL4
	
	
---- Revision History ------------------------------------------------
	02/23/06 - Pete Chenard - CR19551
		   Fixed routine label.
		   
	05/19/05 - Pete Chenard - CR 14146
		   Modified to type variables.
		   
	12/1/03 - Spier -cr7178
	   	     Modifications to correct dead code warnings and
	   	     other issues that occurred during mass compile of screens.

	09/24/03 - Pete Chenard - 45497
		       Created screen template for compiler.
----------------------------------------------------------------------

 */

 #WARN SCOPE OFF
	type Public String %MODS,%PAGE,%PG,%REPEAT,ER,RM
	type String KEYS(),KVAR,VFSN(),VO,VODFT,VPGM,vPSL,VSID,VSNAME

	// %O (0-Create  1-Modify  2-Inquiry  3-Delete  4-Print  5-Blank screen)

	set:'$D(%ProcessMode) %ProcessMode=5
 set KVAR="kill %TAB,VFSN,VO,VPTBL,vtab",VSID="ACHDTL",VPGM=$T(+0),VSNAME="ACH Entry Detail Record Maintenance"
 set VFSN("ACH1")="zfACH1",VFSN("ACH2")="zfACH2"
 set vPSL=1
 set KEYS(1)=fACH1.COID
 set KEYS(2)=fACH1.PTYPE
 //
	// ==================== Display blank screen         (%O=5)

 if %ProcessMode=5 do VPR(.fACH2,.fACH1),VDA1(.fACH2,.fACH1),^DBSPNT()

 set ER=0 do VSCRPRE(.fACH2,.fACH1) if ER quit  // Screen Pre-Processor
 
 if '%ProcessMode do VNEW(.fACH2,.fACH1),VPR(.fACH2,.fACH1),VDA1(.fACH2,.fACH1)
 if %ProcessMode do VLOD(.fACH2,.fACH1) quit:$G(ER)  do VPR(.fACH2,.fACH1),VDA1(.fACH2,.fACH1)

	// ====================  Display Form
	do ^DBSPNT()
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	if %ProcessMode=2!(%ProcessMode=3) do ^DBSCRT8A X:'$D(%PAGE) KVAR quit  // Inquiry/Delete
	// ====================  Set up data entry control table


 if %ProcessMode<2 do VTAB(.fACH2,.fACH1)
	quit


VNEW(RecordACH2 fACH2,RecordACH1 fACH1) // Initialize arrays if %O=0
 
 do VDEF(.fACH2,.fACH1)
 do VLOD(.fACH2,.fACH1)
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
	
VDEF(RecordACH2 fACH2,RecordACH1 fACH1)
 if fACH2.CIDGLFLG="" set fACH2.CIDGLFLG=0
 if fACH2.OFFGLFLG="" set fACH2.OFFGLFLG=0
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
 ;
VLOD(RecordACH2 fACH2,RecordACH1 fACH1) // Load data from disc - %O = (1-5)
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


	type Public String %MODS,%REPEAT
	quit
	

VPR(RecordACH2 fACH2,RecordACH1 fACH1) // Display screen prompts
 set VO="27||13|"
 set VO(0)="|0"
 set VO(1)=$C(1,26,30,1,0,0,0,0,0,0)_"01T ACH Entry Detail Information "
 set VO(2)=$C(3,5,19,0,0,0,0,0,0,0)_"01T Company ID Number:"
 set VO(3)=$C(3,50,14,0,0,0,0,0,0,0)_"01T Payment Type:"
 set VO(4)=$C(4,10,14,0,0,0,0,0,0,0)_"01T Company Name:"
 set VO(5)=$C(4,54,10,0,0,0,0,0,0,0)_"01T Sequence:"
 set VO(6)=$C(5,13,11,0,0,0,0,0,0,0)_"01TEntry Desc:"
 set VO(7)=$C(7,1,23,1,0,0,0,0,0,0)_"01T Receiving Institution:"
 set VO(8)=$C(7,55,9,0,0,0,0,0,0,0)_"01TG/L Acct:"
 set VO(9)=$C(8,8,16,1,0,0,0,0,0,0)_"01T Account Number:"
 set VO(10)=$C(9,7,17,1,0,0,0,0,0,0)_"01T Individual Name:"
 set VO(11)=$C(10,9,15,0,0,0,0,0,0,0)_"01T Individual ID:"
 set VO(12)=$C(10,44,20,0,0,0,0,0,0,0)_"01T Discretionary Data:"
 set VO(13)=$C(12,2,22,0,0,0,0,0,0,0)_"01T IBS Transaction Code:"
 set VO(14)=$C(12,42,22,0,0,0,0,0,0,0)_"01T ACH Transaction Code:"
 set VO(15)=$C(13,4,20,1,0,0,0,0,0,0)_"01T Transaction Amount:"
 set VO(16)=$C(13,55,9,0,0,0,0,0,0,0)_"01TRPA Code:"
 set VO(17)=$C(14,5,19,0,0,0,0,0,0,0)_"01T Posting Frequency:"
 set VO(18)=$C(14,46,18,1,0,0,0,0,0,0)_"01T Date Next Posted:"
 set VO(19)=$C(16,8,16,0,0,0,0,0,0,0)_"01TG/L Offset Acct:"
 set VO(20)=$C(16,51,13,0,0,0,0,0,0,0)_"01TPrenote Date:"
 set VO(21)=$C(17,9,15,0,0,0,0,0,0,0)_"01TOffset Account:"
 set VO(22)=$C(17,47,17,0,0,0,0,0,0,0)_"01TOffset Tran Code:"
 set VO(23)=$C(19,8,16,0,0,0,0,0,0,0)_"01TOffset RPA Code:"
 set VO(24)=$C(19,44,20,0,0,0,0,0,0,0)_"01T Amount Last Posted:"
 set VO(25)=$C(20,8,16,0,0,0,0,0,0,0)_"01TExpiration Date:"
 set VO(26)=$C(20,46,18,0,0,0,0,0,0,0)_"01T Date Last Posted:"
 set VO(27)=$C(22,32,15,2,0,0,0,0,0,0)_"01TAddendum Record"
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VDA1(RecordACH2 fACH2,RecordACH1 fACH1)  // Display screen data
 new V
 //
 set VO="53|28|13|"
 set VO(28)=$C(3,25,10,2,0,0,0,0,0,0)_"01T"_$E(fACH2.COID,1,10)
 set VO(29)=$C(3,65,10,2,0,0,0,0,0,0)_"01T"_$E(fACH2.PTYPE,1,10)
 set VO(30)=$C(4,25,16,2,0,0,0,0,0,0)_"01T"_$E(fACH1.CNAME,1,16)
 set VO(31)=$C(4,65,6,2,0,0,0,0,0,0)_"01N"_fACH2.SEQ
 set VO(32)=$C(5,25,10,2,0,0,0,0,0,0)_"01T"_$E(fACH1.CED,1,10)
 set VO(33)=$C(7,25,9,2,0,0,0,0,0,0)_"00T"_$E(fACH2.RTNUM,1,9)
 set VO(34)=$C(7,65,1,2,0,0,0,0,0,0)_"00L"_$S(fACH2.CIDGLFLG:"Y",1:"N")
 set VO(35)=$C(8,25,17,2,0,0,0,0,0,0)_"00T"_$E(fACH2.CID,1,17)
 set VO(36)=$C(9,25,22,2,0,0,0,0,0,0)_"00T"_$E(fACH2.INDNAM,1,22)
 set VO(37)=$C(10,25,15,2,0,0,0,0,0,0)_"00T"_$E(fACH2.INDID,1,15)
 set VO(38)=$C(10,65,2,2,0,0,0,0,0,0)_"00T"_$E(fACH2.DISD,1,2)
 set VO(39)=$C(12,25,12,2,0,0,0,0,0,0)_"00T"_$E(fACH2.IBSTC,1,12)
 set VO(40)=$C(12,65,2,2,0,0,0,0,0,0)_"00T"_$E(fACH2.ACHTC,1,2)
 set VO(41)=$C(13,25,12,2,0,0,0,0,0,0)_"00T"_$E(fACH2.TAMT,1,12)
 set VO(42)=$C(13,65,10,2,0,0,0,0,0,0)_"00N"_fACH2.CIDRPA
 set VO(43)=$C(14,25,12,2,0,0,0,0,0,0)_"00F"_$E(fACH2.FRE,1,12)
 set VO(44)=$C(14,65,10,2,0,0,0,0,0,0)_"00D"_$$DAT^%ZM(fACH2.DATNP)
 set VO(45)=$C(16,25,1,2,0,0,0,0,0,0)_"00L"_$S(fACH2.OFFGLFLG:"Y",1:"N")
 set VO(46)=$C(16,65,10,2,0,0,0,0,0,0)_"01D"_$$DAT^%ZM(fACH2.PDATE)
 set VO(47)=$C(17,25,12,2,0,0,0,0,0,0)_"00N"_fACH2.OFFCID
 set VO(48)=$C(17,65,12,2,0,0,0,0,0,0)_"00T"_$E(fACH2.OFFTC,1,12)
 set VO(49)=$C(19,25,10,2,0,0,0,0,0,0)_"00N"_fACH2.OFFRPA
 set V=$S(fACH2.AMTLP="":"",1:$J(fACH2.AMTLP,0,2)) set VO(50)=$C(19,65,12,2,0,0,0,0,0,0)_"01$"_$S(fACH2.AMTLP="":"",1:$J(fACH2.AMTLP,0,2))
 set VO(51)=$C(20,25,10,2,0,0,0,0,0,0)_"00D"_$$DAT^%ZM(fACH2.EDATE)
 set VO(52)=$C(20,65,10,2,0,0,0,0,0,0)_"01D"_$$DAT^%ZM(fACH2.DATLP)
 set VO(53)=$C(23,1,80,2,0,0,0,0,0,0)_"00T"_$E(fACH2.ADDREC,1,80)
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
	
	
VTAB(RecordACH2 fACH2,RecordACH1 fACH1)
 
 kill VSCRPP,REQ,%TAB,%MOD,%MODOFF,%MODGRP,%REPREQ,vtab
 set %MAX=26,VPT=1,VPB=23,PGM=$T(+0),DLIB="SYSDEV",DFID="ACH2",VSCRPP=1,VSCRPP=1
 set OLNTB=23001
 
 set VFSN("ACH1")="zfACH1",VFSN("ACH2")="zfACH2"
 //
 // 
	
	
 set %TAB(1)=$C(2,24,10)_"21T12401|1|[ACH2]COID|[ACH]|if X?1""1""9N!(X?1""3""9N)!(X?1""9""9AN)"
 set %TAB(2)=$C(2,64,10)_"21T12402|1|[ACH2]PTYPE"
 set %TAB(3)=$C(3,24,16)_"20T12423|1|[ACH1]CNAME"
 set %TAB(4)=$C(3,64,6)_"21N12403|1|[ACH2]SEQ"
 set %TAB(5)=$C(4,24,10)_"21T12405|1|[ACH1]CED"
 set %TAB(6)=$C(6,24,9)_"01T12415|1|[ACH2]RTNUM|[UTBLACHRT]||do VP1^V00S005(.fACH2,.fACH1)"
 set %TAB(7)=$C(6,64,1)_"00L12419|1|[ACH2]CIDGLFLG"
 set %TAB(8)=$C(7,24,17)_"01T12416|1|[ACH2]CID|||do VP2^V00S005(.fACH2,.fACH1)"
 set %TAB(9)=$C(8,24,22)_"01T12413|1|[ACH2]INDNAM"
 set %TAB(10)=$C(9,24,15)_"00T12412|1|[ACH2]INDID"
 set %TAB(11)=$C(9,64,2)_"00T12414|1|[ACH2]DISD|||do VP3^V00S005(.fACH2,.fACH1)"
 set %TAB(12)=$C(11,24,12)_"00T12408|1|[ACH2]IBSTC|[TRN]||do VP4^V00S005(.fACH2,.fACH1)|do VP5^V00S005(.fACH2,.fACH1)"
 set %TAB(13)=$C(11,64,2)_"00T12406|1|[ACH2]ACHTC|[STBLACHTC]||do VP6^V00S005(.fACH2,.fACH1)"
 set %TAB(14)=$C(12,24,12)_"01T12401|1|[ACH2]TAMT|||do VP7^V00S005(.fACH2,.fACH1)|do VP8^V00S005(.fACH2,.fACH1)"
 set %TAB(15)=$C(12,64,10)_"00N12421|1|[ACH2]CIDRPA|||do VP9^V00S005(.fACH2,.fACH1)|do VP10^V00S005(.fACH2,.fACH1)"
 set %TAB(16)=$C(13,24,12)_"00F12402|1|[ACH2]FRE|||do VP11^V00S005(.fACH2,.fACH1)|do VP12^V00S005(.fACH2,.fACH1)"
 set %TAB(17)=$C(13,64,10)_"01D12403|1|[ACH2]DATNP|||do VP13^V00S005(.fACH2,.fACH1)"
 set %TAB(18)=$C(15,24,1)_"00L12420|1|[ACH2]OFFGLFLG|||do VP14^V00S005(.fACH2,.fACH1)"
 set %TAB(19)=$C(15,64,10)_"20D12411|1|[ACH2]PDATE"
 set %TAB(20)=$C(16,24,12)_"00N12409|1|[ACH2]OFFCID|||do VP15^V00S005(.fACH2,.fACH1)"
 set %TAB(21)=$C(16,64,12)_"00T12410|1|[ACH2]OFFTC|[TRN]||do VP16^V00S005(.fACH2,.fACH1)|do VP17^V00S005(.fACH2,.fACH1)"
 set %TAB(22)=$C(18,24,10)_"00N12422|1|[ACH2]OFFRPA|||do VP18^V00S005(.fACH2,.fACH1)|do VP19^V00S005(.fACH2,.fACH1)"
 set %TAB(23)=$C(18,64,12)_"20$12405|1|[ACH2]AMTLP|||||||2"
 set %TAB(24)=$C(19,24,10)_"00D12417|1|[ACH2]EDATE|||do VP20^V00S005(.fACH2,.fACH1)|do VP21^V00S005(.fACH2,.fACH1)"
 set %TAB(25)=$C(19,64,10)_"20D12404|1|[ACH2]DATLP"
 set %TAB(26)=$C(22,0,80)_"00T12418|1|[ACH2]ADDREC"
 do VTBL(.fACH2,.fACH1)
	do ^DBSCRT8 	// data entry
	quit


VREQ   // Create REQ() array
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VTBL(RecordACH2 fACH2,RecordACH1 fACH1) //Create %TAB(array)
 	// 1 2 3  4 5   6   7-9 10-11
 	// DY,DX,SZ PT REQ TYPE DEL POS |NODE|ITEM NAME|TBL|FMT|PP|PRE|MIN|MAX|DEC

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VSPP   // screen post proc
 type Public RecordACH2 fACH2
 type Public RecordACH1 fACH1
 do VSPP1(.fACH2,.fACH1)
 #ACCEPT Date=11/05/03; pgm=Screen Compilerxxx
 quit
VSPP1(RecordACH2 fACH2,RecordACH1 fACH1)
 D VSPPREQ(.fACH2,.fACH1) I ER Q
 ;
 type String X
 set X=fACH2.TAMT
 type RecordSTBLPAT stblpat=Db.getRecord("STBLPAT","OPT=:X",1)
 if stblpat.getMode() do {
	
	// Chosen amount option requires offset account
 	if fACH2.OFFCID.isNull() do Runtime.setErrMSG("STBLPAT",546) quit
	
	type RecordACN acn=Db.getRecord("ACN","CID=:fACH2.OFFCID")
	// Specified amount option requires a loan account as an offset
	if acn.cls'="L" do Runtime.setErrMSG("ACN",2530) quit
 	}
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit

VSPPREQ(RecordACH2 fACH2,RecordACH1 fACH1) 
 //_______________________________________________________
 //  User Defined Required Data Item Definitions
 //_______________________________________________________

 set ER=0

 do VR1(.fACH2,.fACH1) if ER set NI=20 quit
 quit

VR1(RecordACH2 fACH2,RecordACH1 fACH1) 

 // ([ACH2]OFFCID,[ACH2]OFFTC)

 I (fACH2.OFFCID'=""),(fACH2.OFFTC'="") quit


 // ([ACH2]OFFCID-,[ACH2]OFFTC-)

 I (fACH2.OFFCID=""),(fACH2.OFFTC="") quit

 do VR99 quit

VR99 
 set RM="Missing required field(s)/data item set definition error"
 set ER=1 quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


  //user-defined post procs
 //
VP1(RecordACH2 fACH2,RecordACH1 fACH1) //
 // Define the variable ONUS (0 = not on-us, 1 = on-us) for use with data
 // item [ACH2]CID.  If the institution is "on-us", data item [ACH2]IBSTC
 // is required.  If the institution is not on-us, the reverse is true.
 
 type public String ONUS,X
 type String KEY

 quit:X.isNull()

 type RecordUTBLACHRT utblachrt=Db.getRecord("UTBLACHRT","KEY=:X",1)

 if 'utblachrt.getMode() quit

 set KEY=utblachrt.key
 set ONUS=utblachrt.onus

 if ONUS do DELETE^DBSMACRO("ACH2.ACHTC","1","0")

 if 'ONUS do DELETE^DBSMACRO("ACH2.IBSTC","1","0")
VP2(RecordACH2 fACH2,RecordACH1 fACH1) //
 /*

   ---- Revision History------------------------------------------------
  
  	06/01/06 - MBUIM - CR 21547
		   Modified check for variable ONUS to check for 1 or 0
		   not null. This was an issue as invalid account was
		   not processed when ONUS is 0.

	06/01/06 - MBUIM - CR 21548
		   Modified to remove the default of account name from 
		   within the loop so that it's displayed for all 
		   conditions.
   ---------------------------------------------------------------------
 */	

 // If the account is on-us, ensure the account is a valid IBS or GL 
 // account and default the customer or GL account name.

 type public Boolean ER
 type public String NAM,ONUS,X

 quit:X.isNull()

 if ONUS=0 quit  

 if fACH2.CIDGLFLG do { quit:ER

	type RecordGLAD glad=Db.getRecord("GLAD","ACN=:X",1)

	//Invalid bank G/L account number
	if 'glad.getMode() do Runtime.setErrMSG("GLAD",1268) quit
	}

 else  do CID^UACN1

 if 'fACH2.CIDGLFLG do {

	type RecordACN acn=Db.getRecord("ACN","CID=:X",1)

	if 'acn.getMode() quit

	type RecordCIF cif=Db.getRecord("CIF","ACN=:acn.acn",1)

	if 'cif.getMode() quit

	set NAM=cif.nam
	set NAM=NAM.extract(1,22)
 	
	}

 else  do {

	type RecordGLAD glad=Db.getRecord("GLAD","ACN=:X",1)

	if 'glad.getMode() quit

	set NAM=glad.desc1
	set NAM=NAM.extract(1,22)
	
	// do DEFAULT^DBSMACRO("ACH2.INDNAM",NAM)
	}
 do DEFAULT^DBSMACRO("ACH2.INDNAM",NAM)


VP3(RecordACH2 fACH2,RecordACH1 fACH1) //
 //Skip field [ACH2]IBSTC if the RDFI R & T is not on-us.

 type public String ONUS

 if 'ONUS do GOTO^DBSMACRO("ACH2.ACHTC")

VP4(RecordACH2 fACH2,RecordACH1 fACH1) //
 // Define the variable ITC (internal tran code) for use with data
 // item [ACH2]TAMT.  This field is required if the RDFI is ONUS.

 type public String ITC,ONUS,X

 if X.isNull(),'ONUS quit  

 //Data required
 if X.isNull(),ONUS do Runtime.setErrMSG("TRN",741) quit

 //Not an on-us account
 if 'ONUS do Runtime.setErrMSG("TRN",2031) quit  

 type RecordTRN trn=Db.getRecord("TRN","ETC=:X",1)

 //Invalid transaction code ~p1
 if 'trn.getMode() do Runtime.setErrMSG("TRN",1498) quit

 // Lowercase transaction codes protected
 if X?.E1L.E do Runtime.setErrMSG("TRN",1663) quit

 set ITC=trn.itc

 do GOTO^DBSMACRO("ACH2.TAMT")
 
VP5(RecordACH2 fACH2,RecordACH1 fACH1) //
 /*
   ---- Revision History------------------------------------------------

	06/01/06 - MBUIM - CR 21548 
		   The column trn.ucls is a computed that expects a
		   system variable (%UCLS) to be around. This is no
		   longer feasible in an oracle environment. Column will
		   be obsolete and hence direct reference to the function.

	06/23/06 - Mugilvannan - CR 21759
		   Initialized the variable ETC to avoid undefined error.
   ---------------------------------------------------------------------

 */
 // If not a GL account (based on GL account flag (CIDGLFLG)), set class and
 // group and build lookup table.  If GL account, set class to "M" and loop
 // through XTRN to build lookup table.

 type public String ONUS
 type String CLS,ETC,GRP,XETC()

 quit:'ONUS

 if 'fACH2.CIDGLFLG do { quit
	type RecordACN acn=Db.getRecord("ACN","CID=:fACH2.CID",1)
	if 'acn.getMode() quit
	
	set CLS=acn.cls
	set GRP=acn.grp
	do CHANGE^DBSMACRO("TBL","[TRN]")
 	}

 type ResultSet rs=Db.select("ETC,SGT","TRN","CLS='M'")

 while rs.next() do {
	set ETC=rs.getCol("ETC")
 	set XETC(ETC)=rs.getCol("SGT")_"|"_$$XTRNUCLS^PROCOMP(ETC)
 	}

 do CHANGE^DBSMACRO("TBL","XETC(")
VP6(RecordACH2 fACH2,RecordACH1 fACH1) //
 // Restrict the input to only those ACH tran codes currently supported
 // (DDA, Saving account, and GL deposits and withdrawals and LN account credits
 // - 22, 27, 32, 37, 42, 47, 52).  Define the variable ITC (internal
 // transaction code) for use with data item [ACH2]TAMT.  This field is
 // required in the RDFI R & T is not on-us.

 type public String ITC,ONUS,X
 type public Boolean ER

 //Data required
 if X.isNull(),'ONUS do Runtime.setErrMSG("TRN",741) quit  

 //On-us account
 if X.length(),ONUS do Runtime.setErrMSG("TRN",2093) quit  

 quit:X.isNull()

 type RecordSTBLACHTC stblachtc=Db.getRecord("STBLACHTC","ACHTC=:X",1)
 if 'stblachtc.getMode() quit	

 set ITC=stblachtc.dc

 if (fACH1.SEC="WEB")!(fACH1.SEC="TEL") do { quit:ER

	if (X=27)!(X=37) quit     

	//Limited to 27 or 37
	do Runtime.setErrMSG("STBLACHTC",5096)
 	}

 if fACH1.SEC="ARC" do { quit:ER
	
	 if X=27 quit  
	
	 // Limited to transaction code 27
	 do Runtime.setErrMSG("STBLACHTC",5102)
 	}
	
 if (X=22)!(X=27)!(X=32)!(X=37)!(X=42)!(X=47)!(X=52) quit  

 // Limited to 22, 27, 32, 37, 42, 47, or 52
 do Runtime.setErrMSG("STBLACHTC",1608) quit
 
VP7(RecordACH2 fACH2,RecordACH1 fACH1) //
 // Ensure the transaction amount does not exceed the maximum amount
 // defined for the ACH batch ([ACH1]MAXAMTD or [ACH1]MAXAMTC, de-
 // pending upon the type of transaction - debit or credit).

 type public Boolean ER
 type public Number X
 type public String ITC
 type Number MAXAMT,IRA,XCID
 type String CLASS,I()

 quit:X.isNull()

 set I(3)=""

 type RecordSTBLPAT stblpat=Db.getRecord("STBLPAT","OPT=:X",1)
 if stblpat.getMode() quit

 if fACH2.CIDGLFLG=1 quit  

 if X?.N!(X?.N1".".N) do { quit:ER
	set MAXAMT=0
	if ITC.extract()=0 set MAXAMT=fACH1.MAXAMTD
	if ITC.extract()=1 set MAXAMT=fACH1.MAXAMTC

	// Maximum amount = ~p1
	if MAXAMT,X>MAXAMT do Runtime.setErrMSG("STBLPAT",1682,MAXAMT.roundDec()) quit

	set X=X.roundDec(2)
 	}

 // Enter amount option or numeric value
 else  do Runtime.setErrMSG("STBLPAT",929) quit 

 if ONUS do {

	type RecordACN acn=Db.getRecord("ACN","CID=:fACH2.CID",1)

	if 'acn.getMode() quit
	set CLASS=acn.cls
 	}

 type RecordDEP dep=Db.getRecord("DEP","CID=:fACH2.CID",1)
 if 'dep.getMode() quit

 set IRA=dep.ira

 if ('ONUS)!(ONUS&'IRA)!(CLASS'="D") do {
 	do DELETE^DBSMACRO("ACH2.CIDRPA","1","0")
	do GOTO^DBSMACRO("ACH2.FRE")
 	}

 // If 'ONUS recieving institution or if not RPA type skip RPA code go to FRE
 // and account is class deposit dms 12/07/01

 if ONUS,IRA,(CLASS="D") do CHANGE^DBSMACRO("REQ","ACH2.CIDRPA")

VP8(RecordACH2 fACH2,RecordACH1 fACH1) //
 type public String TBL()
 type String I(),N 

 set I(3)="TBL("
 set N="*"
 type ResultSet rs=Db.select("OPT,DESC,TYPE","STBLPAT","OPT=:N")

 while rs.next() do {
	set TBL(rs.getCol("OPT"))=rs.getCol("DESC")_"|"_rs.getCol("TYPE")
 	}
 
VP9(RecordACH2 fACH2,RecordACH1 fACH1) //
 type public String ONUS,X

 if fACH2.CIDGLFLG=1 quit

 type RecordDEP dep=Db.getRecord("DEP","CID=:fACH2.CID",1)
 if 'dep.getMode() quit

 // Not a retirement plan account
 if ONUS,'dep.ira.extract() do Runtime.setErrMSG("DEP",2030) quit

 type RecordACN acn=Db.getRecord("ACN","CID=:fACH2.CID",1)
 if 'acn.getMode() quit

 // Data required
 if ONUS,X.isNull(),acn.cls="D",dep.ira.extract() do Runtime.setErrMSG("ACN",741) quit
VP10(RecordACH2 fACH2,RecordACH1 fACH1) //
 // If the recieving institution account is ONUS with a valid acct # then the
 // IBS tran code must be verified to check if it is an RPA (retirement)
 // account,then the RPA Code becomes a required field.
 // added check for deposit class account and G/L flag -DMS 12/07/01 ARQ44366:04

 type public String ITC,ONUS
 type Number RPACD

 quit:'ONUS

 if fACH2.CIDGLFLG=1 quit

 type RecordACN acn=Db.getRecord("ACN","CID=:fACH2.CID",1)
 if 'acn.getMode() quit

 if acn.cls="D" do {

	type RecordDEP dep=Db.getRecord("DEP","CID=:fACH2.CID",1)
	set RPACD=dep.ira
 	}

 if RPACD.exists() do CHANGE^DBSMACRO("REQ","ACH2.CIDRPA")

 else  do {
	do DELETE^DBSMACRO("ACH2.CIDRPA","1","0")
	do GOTO^DBSMACRO("ACH2.FRE")
 	}

 // The IBS account tran code must be check to see if the transaction is a 
 // disbursement (withdrawal=0) or contribution (deposit=1) and then correct 
 // RPA table can be referenced.

 type RecordTRN trn=Db.getRecord("TRN","ETC=:fACH2.IBSTC",1)
 set ITC=trn.itc
 
 if ITC.extract(1) do CHANGE^DBSMACRO("TBL","[UTBLIRACON]KEY")
 
 if ITC.extract(1) do CHANGE^DBSMACRO("TBL","[UTBLIRADIS]KEY")
VP11(RecordACH2 fACH2,RecordACH1 fACH1) //
 // Frequency must be contained in payment type freq list ([ACH1]VFREQ)
 // If VFREQ="*", any valid PROFILE frequency is acceptable except when
 // ACH1.SEC(Standard Entry Class) is equal to "TEL" or "ARC"

 type public String ONUS,X
 type Date NBDT,NJD
 type String FRE,VFREQ
 type Number LEAD,PRO

 // Null frequency is not valid with prenote option of ~p1
 if X.isNull(),fACH1.PREOPT'=0 do Runtime.setErrMSG("ACH1",5101,fACH1.PREOPT) quit
 quit:X.isNull()

 // Frequency not allowed for ~p1 Standard Entry Class
 if ((fACH1.SEC="TEL")!(fACH1.SEC="ARC")),fACH1.VFREQ="*" do Runtime.setErrMSG("ACH1",5097,fACH1.SEC) quit  
 set VFREQ=fACH1.VFREQ if VFREQ="*" set VFREQ=X

 for I=1:1 set FRE=VFREQ.piece(",",I) quit:FRE.isNull()  if X=FRE quit

 // Valid frequencies - ~p1
 if FRE.isNull() do Runtime.setErrMSG("ACH1",2914,VFREQ) quit

 do EDT^UFRE
 quit:ER

 set LEAD=fACH1.LEAD

 if ONUS set LEAD=0
 quit:%ProcessMode
 
 // Default next date for new detail records (%O=0) ; ; TITOVE - 49394 
 // Set reference date (NJD) to batch beginning date (BDATE) or next 
 // business date (counting from TJD) according to FED calendar, whichever is greater

 set NBDT=(%SystemDate).nextBusDate(1,"FED")
 set NJD=$S(fACH1.BDATE>NBDT:fACH1.BDATE,1:NBDT)
 set PRO=0

 if fACH1.PREOPT=1,'ONUS do PRE1(.fACH1) set PRO=1

 if fACH1.PREOPT=2,'ONUS do PRE2(.fACH1) set PRO=1

 if 'PRO do FINDFIRST(.fACH1)
 do DEFAULT^DBSMACRO("ACH2.DATNP",NJD)
 quit

PRE1(RecordACH1 fACH1) // If PREOPT is 1, set next posting date (NJD) to second valid 

 do FINDFIRST(.fACH1)

 // Find next valid posting date after a minimum of 6 business days
 type public Date NJD
 type Date I,FIRST,JD
 type Number CNT

 set CNT=0,(JD,FIRST)=NJD

 for  quit:CNT'<6  set CNT=0,NJD=JD.nextFreqDate(X) quit:ER  do {
	 for I=FIRST+1:1 quit:I'<NJD  if I.isBusDate("FED") set CNT=CNT+1
	 set JD=NJD 
 	}
 
PRE2(RecordACH1 fACH1) // If PREOPT is 2, set next posting date (NJD) to first valid 
 //frequency with a minimum of PRENOTE business days available prior to it

 type public Date NJD
 type Date I
 type Number PREDTMP

 set PREDTMP=fACH1.PREDAYS

 for I=%SystemDate+1:1 if I.isBusDate("FED") set PREDTMP=PREDTMP-1  quit:PREDTMP'>0

 set NJD=NJD+(I-%SystemDate)

 do FINDFIRST(.fACH1)
 
FINDFIRST(RecordACH1 fACH1) // Find first valid posting date
 // Confirm there is sufficient lead time based on LEAD--if not, continue
 // to calculate next valid posting date from reference date until true.

 type public Number LEAD,PRO
 type public Date NJD

 if PRO,(LEAD'>fACH1.PREDAYS) set LEAD=0

 for  set NJD=NJD.nextFreqDate(X)  quit:NJD'<(%SystemDate+LEAD)
VP12(RecordACH2 fACH2,RecordACH1 fACH1) //
 // Build a table look-up of valid frequencies based upon data item
 // [ACH1]VFREQ.  If [ACH1]VFREQ="*", any valid frequency is accept-
 // able and the look-up table remains ^UTBL("FRE".

 type String I(),TBL,VFREQ,TBL()
 type Number I

 if fACH1.SEC="PPD" do CHANGE^DBSMACRO("REQ","ACH2.FRE")

 if fACH1.SEC="WEB",fACH1.VFREQ'="*" do CHANGE^DBSMACRO("REQ","ACH2.FRE")

 if fACH1.SEC="WEB",fACH1.VFREQ="*" do GOTO^DBSMACRO("ACH2.DATNP")

 set VFREQ=fACH1.VFREQ quit:VFREQ="*"  set I(3)="TBL("
 
 for I=1:1 set TBL=VFREQ.piece(",",I) quit:TBL.isNull()  set TBL(TBL)=""
VP13(RecordACH2 fACH2,RecordACH1 fACH1) //
 /* ---- Revision History------------------------------------------------
 
 06/26/06 - MBUIM - CR 21461
 	    Modified NBDATE not to add an extra day.

 ---------------------------------------------------------------------
 */
 // Date next posted cannot be prior to batch beginning date ([ACH1]BDATE)
 // or after the batch end date ([ACH1]EDATE).

 type public String ER,X
 type public Date %JD
 type Date DTNP,NBDATE
 type String RM

 quit:X.isNull()

 set DTNP=X

 // Date entered is a non-business day

 //Date is non-business day

 if 'X.isBusDate() set ER="W",RM=$$^MSG(745)

 set %JD=X.toDate("MM/DD/YEAR") quit:ER

 // Must be the same as or after the batch start date - ~p1
 if %JD<fACH1.BDATE do Runtime.setErrMSG("ACH1",1819,fACH1.BDATE.toString("MM/DD/YEAR")) quit

 // Must be the same as or before the batch end date - ~p1
 if fACH1.EDATE,%JD>fACH1.EDATE do Runtime.setErrMSG("ACH1",1823,fACH1.EDATE.toString("MM/DD/YEAR")) quit

 set NBDATE=(%SystemDate).nextBusDate(1,"FED")

 // Value below minimum range ~p1
 if DTNP<NBDATE do Runtime.setErrMSG("ACH1",2920,NBDATE.toString("MM/DD/YEAR")) quit  
 
VP14(RecordACH2 fACH2,RecordACH1 fACH1) //
 // If the offset account is a general ledger flag Y then no RPA dist code
 // should be entered - only on G/L accounts with N flag.
 
 type public String X

 if X do DELETE^DBSMACRO("ACH2.OFFRPA","1","0")
VP15(RecordACH2 fACH2,RecordACH1 fACH1) //
 type public Boolean ER
 type public String X
 type Number CID
 type String RM

 quit:X.isNull()

 set CID=""

 if fACH2.OFFGLFLG do { quit

	type RecordGLAD glad=Db.getRecord("GLAD","ACN=:X",1)

	// Invalid bank G/L account number
 	if 'glad.getMode() do Runtime.setErrMSG("GLAD",1268) quit

	//Set GL Acct Title
	set RM=glad.desc1
 	}

 else  do {

	do CID^UACN1 quit:ER

 	type RecordACN acn=Db.getRecord("ACN","CID=:X",1)
        if 'acn.getMode() quit

	set RM=acn.title1

	// Account ~p1 closed
	if acn.stat="4" do Runtime.setErrMSG("ACN",55) quit
 	}

VP16(RecordACH2 fACH2,RecordACH1 fACH1) //
 type public Boolean ER
 type public String ITC,X
 type String DC,RM

 do ZOFFSET(.fACH2) if ER quit  

 // If OFFTC null and offset account null, batch offsets used,
 // go to AMTLP no RPA code needed

 if X.isNull(),(fACH2.OFFCID).isNull() do { quit
	do DELETE^DBSMACRO("ACH2.OFFRPA","1","0")
	do GOTO^DBSMACRO("ACH2.AMTLP")
 	}

 // Check trancodes to verify they are not both debits or both credits

 type RecordTRN trn=Db.getRecord("TRN","ETC=:X",1)
 if 'trn.getMode() quit

 set ITC=trn.itc

 if ONUS do {

 	type RecordTRN trn=Db.getRecord("TRN","ETC=:fACH2.IBSTC",1)
        if 'trn.getMode() quit

	set DC=trn.itc
	set DC=DC.extract()
 	}

 if 'ONUS do {

	type RecordSTBLACHTC stblachtc=Db.getRecord("STBLACHTC","ACHTC=:fACH2.ACHTC",1)
	if 'stblachtc.getMode() quit

	set DC=stblachtc.dc
	set DC=DC.extract()
 	}

 if DC-ITC.extract()=0 set ER=1

 if  set RM=$S(DC:$$^MSG(368),1:$$^MSG(369)) quit

 // Quit if account is GL to prevent undefined error
 if fACH2.OFFGLFLG quit

 // If no offset account or it is not RPA type go to AMTLP no RPA code needed.
 // If OFFCID is RPA type account then RPA Code is required field.

 type RecordDEP dep=Db.getRecord("DEP","CID=:fACH2.OFFCID",1)
 if 'dep.getMode() quit

 if dep.ira do CHANGE^DBSMACRO("REQ","ACH2.OFFRPA") quit

 //If offset account is not RPA type skip RPA code go to amount last posted.

 if 'dep.ira do { quit
	do DELETE^DBSMACRO("ACH2.OFFRPA","1","0")
	do GOTO^DBSMACRO("ACH2.AMTLP")
 	}

 do ZOFFSET(.fACH2)

 quit

ZOFFSET(RecordACH2 fACH2)

 type public String X

 // Transaction code requires an offset account
 if X.length(),(fACH2.OFFCID).isNull() do Runtime.setErrMSG("ACH2",2701) quit

 // Transaction code required with offset account
 if X.isNull(),'(fACH2.OFFCID).isNull() do Runtime.setErrMSG("ACH2",2700) quit
 quit
 
VP17(RecordACH2 fACH2,RecordACH1 fACH1) //
 /*
   ---- Revision History------------------------------------------------
  
 	06/01/06 - MBUIM - CR 21548
 		   The column trn.ucls is a computed that expects a
		   system variable (%UCLS) to be around. This is no
		   longer feasible in an oracle environment. Column will
		   be obsolete and hence direct reference to the function.

	06/23/06 - Mugilvannan - CR 21759
		   Intialized the variable ETC to avoid undefined error.
  ---------------------------------------------------------------------

 */

 // If not a GL account (based on GL account flag (OFFGLFLG)), set class and
 // group and build lookup table.  If GL account, set class to "M" and loop
 // through XTRN to build lookup table.

 type String CLS,ETC,GRP,XETC(),quot,QRY

 quit:(fACH2.OFFCID).isNull()

 if 'fACH2.OFFGLFLG do { quit

	type RecordACN acn=Db.getRecord("ACN","CID=:fACH2.OFFCID",1)
	if 'acn.getMode() quit

	set GRP=acn.grp
	set CLS=acn.cls
	set quot=$CHAR(34)
	set QRY="[TRN]CLS="_quot_CLS_quot_"&([TRN]GRP="_quot_GRP_quot_")"

 	do CHANGE^DBSMACRO("TBL","[TRN]:QUERY QRY")
 	}
	
 type ResultSet rs=Db.select("ETC,SGT","TRN","CLS='M'")

 while rs.next() do {
	set ETC=rs.getCol("ETC")
	set XETC(ETC)=rs.getCol("SGT")_"|"_$$XTRNUCLS^PROCOMP(ETC)
 	do CHANGE^DBSMACRO("TBL","XETC(")
 	}
VP18(RecordACH2 fACH2,RecordACH1 fACH1) //
 // If the offset account is GL type Quit to prevent undefined error.

 type public String X

 if fACH2.OFFGLFLG quit

 // If the offset account is RPA type and no value entered set mssg
 // Data required.

 type RecordDEP dep=Db.getRecord("DEP","CID=:fACH2.OFFCID",1)
 if 'dep.getMode() quit

 type RecordACN acn=Db.getRecord("ACN","CID=:fACH2.OFFCID",1)
 if 'acn.getMode() quit

 // Data required
 if acn.cls="D",X.isNull(),dep.ira.extract() do Runtime.setErrMSG("ACN",741) quit
VP19(RecordACH2 fACH2,RecordACH1 fACH1) //
 // If there is no offset acccount the account will default to the batch offset
 // account. The offset RPA code field is deleted.

 type public String ITC

 if (fACH2.OFFCID).isNull() do DELETE^DBSMACRO("ACH2.OFFRPA","1","0") do GOTO^DBSMACRO("ACH2.AMTLP")

 // Quit if GL account to prevent undefined error dms 01/07/02
 if fACH2.OFFGLFLG quit

 // If there is an offset account entered and it is an RPA (retirement)
 //account,then the Offset RPA Code becomes a required field.
 
 type RecordDEP dep=Db.getRecord("DEP","CID=:fACH2.OFFCID",1)
 if 'dep.getMode() quit

 type RecordACN acn=Db.getRecord("ACN","CID=:fACH2.OFFCID",1)
 if 'acn.getMode() quit

 if acn.cls="D",dep.ira.extract() do CHANGE^DBSMACRO("REQ")

 type RecordTRN trn=Db.getRecord("TRN","ETC=:fACH2.OFFTC",1)
 if 'trn.getMode() quit

 set ITC=trn.itc

 // The offset account tran code must be checked to see if the transaction is
 // a disbursement (withdrawal=0) or contribution (deposit=1) and then correct
 // RPA table can be referenced.

 if ITC.extract(1) do CHANGE^DBSMACRO("TBL","[UTBLIRACON]KEY")

 if ITC.extract(1) do CHANGE^DBSMACRO("TBL","[UTBLIRADIS]KEY")
VP20(RecordACH2 fACH2,RecordACH1 fACH1) //
 type public String X
 type public Date %JD

 quit:X.isNull()  set %JD=X.toDate("MM/DD/YEAR") quit:%JD<0

 quit:fACH1.EDATE.isNull() 

 // Batch expiration date is ~p1
 if %JD>fACH1.EDATE do Runtime.setErrMSG("ACH1",324,fACH1.EDATE.toString("MM/DD/YEAR")) quit
 
VP21(RecordACH2 fACH2,RecordACH1 fACH1) //
 // Minimum value for the expiration date is system date (TJD) plus the
 //file creation lead time ([ACH1]LEAD) plus one.

 type String I()

 set I(7)=%SystemDate+fACH1.LEAD+1
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit								// User defined post processor's


VRV(V,L) quit V_$J("",L-$L(V))
VREPRNT
 type Public RecordACH2 fACH2
 type Public RecordACH1 fACH1
 do VPR(.fACH2,.fACH1)
 do VDA1(.fACH2,.fACH1)
 do ^DBSPNT()
 quit

VW(RecordACH2 fACH2,RecordACH1 fACH1)
 do VDA1(.fACH2,.fACH1)
 do ^DBSPNT(10)
 quit

VDAPNT(RecordACH2 fACH2,RecordACH1 fACH1)
 do VDA1(.fACH2,.fACH1)
 do ^DBSPNT(0,2)
 quit

VDA
 type Public RecordACH2 fACH2
 type Public RecordACH1 fACH1
 do VDA1(.fACH2,.fACH1)
 quit

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
 
vSET(sn,di,X)
 type Public RecordACH2 fACH2
 if sn="ACH2" do vSET1(.fACH2,di,X)
 type Public RecordACH1 fACH1
 if sn="ACH1" do vSET2(.fACH1,di,X)
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
vSET1(RecordACH2 fACH2,di,X)
 do fACH2.setAuditFlag(1)
 set fACH2.@di=X
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
vSET2(RecordACH1 fACH1,di,X)
 do fACH1.setAuditFlag(1)
 set fACH1.@di=X
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
vREAD(fid,di)
 type Public RecordACH2 fACH2
 if fid="ACH2" quit $$vREAD1(.fACH2,di)
 type Public RecordACH1 fACH1
 if fid="ACH1" quit $$vREAD2(.fACH1,di)
 quit ""
vREAD1(RecordACH2 fACH2,di)
 quit fACH2.@di
vREAD2(RecordACH1 fACH1,di)
 quit fACH1.@di
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
 //
VSCRPRE(RecordACH2 fACH2,RecordACH1 fACH1)  // Screen Pre-Processor
 new %TAB,vtab // Disable .MACRO. references to %TAB()
 //
 type String FRE
 quit:%ProcessMode
 // Default posting frequency ([ACH1]VFREQ) if only one frequency is valid.
 set FRE=fACH1.VFREQ if FRE.piece(",",1)=FRE,FRE'="*" set fACH2.FRE=FRE
 #ACCEPT date=11/05/03;PGM=Screen Compiler
 quit
