CMSCMIN	//
	/*
	       ORIG:  Carrie Baildon - 10 DEC 1997
	  CALLED BY:  Dayend Function (QUE090)
	      CALLS:  ^CARDFILE,CIFFILE,DEPFILE,^UTLO
	   PROJ #'S:  ARQ 25272
	       DESC:  This file reads incoming card management files and
		      copies any records with errors to a log file.

	  ---- Revision History -----------------------------------------------
	  07/25/06 - Pete Chenard - 22385
	  	Modified occurances of .close() method to not pass any parameters.  The
	  	method does not accept them.
	  
	   12/12/05 - SPR - 18555
		      Card Management - General DBI3 system area cleanup.
	
	  ---------------------------------------------------------------------

	*/

	type public String ER,ET,RM

	set ER=0

	// Init runtime variables
	do INIVAR

	if ER quit

	catch vERROR {
		set ET=vERROR.type

		if ET["%GTM-" do ZE^UTLERR quit

		set ET=ET_"-"_vERROR.thrownAt
		set RM=vERROR.description

		do ^UTLERR
		}

	quit
	
	
	//-----------------------------------------------------------------------
LAYOUT	/* This sets up the arrays that hold the qualifiers that define the file
	   layout.  There are three types of records and three record arrays.

	    Record Type Description Array
	    ==================================
	    FH  File Header HDR
	    DR  Detail Record DET
	    FT  File Trailer TRL
	-----------------------------------------------------------------------
	*/

	type public Number STPPOS
	type public String DET(),HDR(),TRL()
	type String RECTYP
	type Number ORD

	set (RECTYP,ORD)=""
	set STPPOS=0

	type ResultSet rs=Db.select("RECTYP,ORD","UTBLCMSFILE2","FLTYP=:FLTYP","RECTYP,ORD")
	while rs.next() do {
		set RECTYP=rs.getCol("RECTYP")
		set ORD=rs.getCol("ORD")
		if RECTYP="FH" set HDR(ORD)=$$VAL(ORD)
		if RECTYP="DR" set DET(ORD)=$$VAL(ORD)
		if RECTYP="FT" set TRL(ORD)=$$VAL(ORD)
		}

	do BEGIN

	quit


VAL(Number ORD)	/* Returns the qualifiers for the piece of data at the position
		   defined by ORD.  These parameters are set up on the CMSFILE user
		   table.
		*/

	type public String FILLER,FLTYP,RECTYP,VAL,VALUE
	type public Number CONV,LENGTH,LFTJUST,STPPOS,STRTPOS,VALTYP

	type RecordUTBLCMSFILE2 cmsfile2=Db.getRecord("UTBLCMSFILE2","FLTYP=:FLTYP,RECTYP=:RECTYP,ORD=:ORD")

	set LENGTH=cmsfile2.length
	set STRTPOS=STPPOS+1
	set STPPOS=STRTPOS+LENGTH-1
	set FILLER=cmsfile2.filler
	if FILLER.get()="" set FILLER=" "
	set LFTJUST=cmsfile2.lftjust
	set CONV=cmsfile2.cnv
	set VALTYP=cmsfile2.valtyp
	set VALUE=cmsfile2.value
	set VAL=VALTYP_"|"_VALUE_"|"_STRTPOS_"|"_STPPOS_"|"_FILLER_"|"_LFTJUST_"|"_CONV

	quit VAL


BEGIN	//  Opens the file that will contain the card management information
	//  written to it and establishes the initial conditions.

	type public Number FLNUM,INCFL
	type public String ARCH,DELIM,ER,FILENM,FLTYP,IO,LOGFL,RDLM,RECDELIM,RM,TBL(),ULDIR
	type public Date DATE,TIME
	type Number I
	
	set ER=0

	type RecordUTBLCMSFILE cmsfile=Db.getRecord("UTBLCMSFILE","FLTYP=:FLTYP",1)

	// Data item delimiter if one is used
	set DELIM=cmsfile.delim
	set ULDIR=cmsfile.uldir
	set ARCH=cmsfile.archivedir

	// The delimiter used to separate records
	set RECDELIM=cmsfile.recdelim
	if RECDELIM["$C(" do {

		set RECDELIM=RECDELIM.piece("(",2)
		set RECDELIM=RECDELIM.piece(")",1)
		set RDLM=""
		for I=1:1:RECDELIM.length(",") set RDLM=RDLM_$C(RECDELIM.piece(",",I))
		set RECDELIM=RDLM
		}

	set DATE=$$DAT^%ZM(+%CurrentDate,"MMDD")
	set TIME=$$TIM^%ZM(%CurrentTime,"2460")

	set FILENM="STATIN_"_DATE_"_"_TIME_".LOG"
	set LOGFL=ARCH_FILENM

	catch vERROR {
		set ER=1
                do EXC
                }

	type IO logfl=Class.new("IO")
	set logfl.fileName=LOGFL
	set logfl.openParams="WRITE/NEWV"
	do logfl.open()

	//Table of files in the upload directory ULDIR
	do BLDTBL

	// Directory ~p1 does not contain incoming card management files
	if 'TBL(1).exists() set ER=1 set RM=$$^MSG(3132,ULDIR) do EXC do END(.logfl) quit

	set FLNUM=""
	for  set FLNUM=TBL(FLNUM).order() quit:FLNUM=""  do {
		set IO=ULDIR_TBL(FLNUM)
		do OPEN(IO,.logfl) do RENAME(IO) quit:ER
		}
	set INCFL=0
	do END(.logfl)

	quit


BLDTBL	/* This builds the table of files found in a directory
	   The files are put into array TBL.
	*/
	type public Number ET,X
	type Number CNT
        type public String ER,FILE,LOGICAL,REC,RM,TBL(),ULDIR
        type String IO1
        
	set CNT=0
	set LOGICAL=$$SCAU^%TRNLNM(ULDIR)

	set IO1=$S(LOGICAL.get()'="":$$SCAU^%TRNLNM(ULDIR,"ZDIR.TMP"),1:ULDIR_"ZDIR.TMP")

	set X=$$DIROUT^%OSSCRPT(IO1,ULDIR,"*.*")

	catch vERROR {
		set ER=1
		do ZT1(FILE)
		}

	type IO io=Class.new("IO")
	set io.fileName=IO1
	set io.openParams="READ"
	do io.open()
	
	
	
	
	for  set REC=io.read() do {
	
		if REC="" quit
		if REC'["STAT" quit
		if (REC["Directory")!(REC["ZDIR")!(REC["Total") quit
	
		set CNT=CNT+1

		/*This is making sure it is a status change file for processing.
		  This test may change according to how the file is named
		*/
		if REC.piece(" ",1)["STAT" set TBL(CNT)=REC.piece(" ",1)

		}

	do io.close()

	set X=$$DELETE^%OSSCRPT(IO1)

	quit


OPEN(String FILE,IO logfl)	// This opens a file and puts the records into the REC array.

	/*
	   The array FLCONT will hold the individual lines of information in the
	   file.  The complete records will be determined from this array and
	   stored in the REC array.
	*/

	type public String ER,REC(),TITLE
	type public Number CID,EOF
	type Number NUM

	kill REC

	catch vERROR {
		do ZT1(FILE)
		}

	type IO io=Class.new("IO")
	set io.fileName=FILE
	set io.timeout=5
	set io.openParams="READ"
	do io.open()

	for  set REC=io.read() do {

		set CID=REC.extract(1,12)
		set TITLE=REC.extract(13,42)
		}

	//close FILE
	do io.close()
	
	set NUM=""
	for  set NUM=REC(NUM).order() quit:NUM=""  do {
		if (REC(NUM).extract(1,2)="DR")!(REC(NUM).extract(1,2)="DT") do PARSE(.logfl)
		}

	quit


PARSE(IO logfl)	/* This is used to break apart the record based on the user defined
	   table of file layouts.  This uses the parameters set on the CMSFILE
	   user table to determine how to use the contents of the file.

	   The file is comprised of fixed values, computed values, empty values,
	   and PROFILE data items.  Based on the start and stop position, a
	   single piece of data is extracted from the file.

	*/
	
	type public String DELIM,ORD

	if DELIM.get()'="" do PARSEDLM quit

	// The table that qualifies each piece of data in a record is stored in
	// the array DET.
	set ORD=""
	do DATA(.logfl)

	quit



DATA(IO logfl)	// This is for non-PROFILE Data Item Values

	type public Number CONV,END,NUM,STPPOS,STRTPOS
	type public String DATA(),DET(),FILLER,LFTJUST,REC(),VALUE
	type Number ORD


	for ORD=20,30,40,50,60,70 do {

		set VALUE=DET(ORD).piece("|",2)
		set STRTPOS=DET(ORD).piece("|",3)
		set STPPOS=DET(ORD).piece("|",4)
		set FILLER=DET(ORD).piece("|",5)
		set LFTJUST=DET(ORD).piece("|",6)
		set CONV=DET(ORD).piece("|",7)
		set DATA=REC(NUM).extract(STRTPOS,STPPOS)

		// Remove the filler
		type Number I
		if LFTJUST do {
			/* Find the last valid character in the data item and remove the
			   remaining filler.
			*/
			for I=1:1:DATA.length() set:DATA.extract(I,I)'=FILLER END=I
			set DATA(ORD)=$S(END:DATA.extract(1,END),1:DATA)
			}
		else  do {
			set DATA(ORD)=DATA
			for I=1:1 quit:('$F(DATA(ORD),FILLER))!(DATA(ORD).length()=0)  set DATA(ORD)=DATA(ORD).extract($F(DATA(ORD),FILLER),DATA(ORD).length())
			}
		}

	if DATA(20).get()'="" do CLSTAT(.logfl)
	if DATA(40).get()'="" do ALSTAT(.logfl)
	if DATA(60).get()'="" do CRDSTAT(.logfl)

	quit


CLSTAT(IO logfl)	// For problems processing customer information, copy to a log file

	type public String DATA(),ERRTYP,LOGFL

	if DATA(30).get()=100 do { quit

		// COPY THIS TO A LOG FILE
		set ERRTYP="STATCLIN"
		do LOG(.logfl)
		}

	if DATA(20).get()="CN" do {
		if "101,102,103,104,105,111,115,909,911"[DATA(30).get() do {

			// COPY THIS TO A LOG FILE
			set ERRTYP="STATCLCN"
			do LOG(.logfl)
			}
		}

	if DATA(20).get()="AE" do {
		if "201,102,103,104,105,808"[DATA(30).get() do {

			// COPY THIS TO A LOG FILE
			set ERRTYP="STATCLAE"
			do LOG(.logfl)
			}
		}

	quit


ALSTAT(IO logfl)	// For problems processing account information, copy to a log file

	type public String DATA(),ERRTYP

	if DATA(50).get()=300 do { quit

		// COPY THIS TO A LOG FILE
		set ERRTYP="STATALIN"
		do LOG(.logfl)
		}

	if DATA(40).get()="CN" do {
		if "201,301,302,303,304,305,309,311,313,912"[DATA(50).get() do {

			// COPY THIS TO A LOG FILE
			set ERRTYP="STATALCN"
			do LOG(.logfl)
			}
		}

	if DATA(40).get()="AE" do {
		if "303,304,305,401,823,824,912,919"[DATA(50).get() do {

			// COPY THIS TO A LOG FILE
			set ERRTYP="STATALAE"
			do LOG(.logfl)
			}
		}

	quit


CRDSTAT(IO logfl)	// For problems processing card information, copy to a log file

	type public String DATA(),ERRTYP

	if DATA(70).get()=500 do { quit

		// COPY THIS TO A LOG FILE
		set ERRTYP="STATCRDIN"
		do LOG(.logfl)
		}

	if DATA(60).get()="CN" do {
		if "201,401,501,502,503,507,509,510,511,512,513,514,515,516,519,522,712,713,714,717"[DATA(70).get() do {

			// COPY THIS TO A LOG FILE
			set ERRTYP="STATCRDCN"
			do LOG(.logfl)
			}
		}

	if DATA(60).get()="AE" do {
		if "201,401,503,504,516,601,712,713,714,717"[DATA(70).get() do {

			// COPY THIS TO A LOG FILE
			set ERRTYP="STATCRDAE"
			do LOG(.logfl)
			}
		}

	quit


LOG(IO logfl)	// This will copy the record to a log file.

	type public Number LOGFLAG,NUM
	type public String REC()

	//I18N OFF
	set LOGFLAG=1

	do logfl.write(.REC(NUM))	
	do logfl.write("")

	//I18N ON

	quit


END(IO logfl)	// This closes the log file

	type public Number LOGFLAG
	
	if LOGFLAG.get()'=1 do logfl.close() quit

	do logfl.close()

	quit


PARSEDLM	// This will be coded if the file uses a data item delimiter

	quit


HEADER	// Nothing needs to be done in here for now.

	quit


TRAILER	/* This is very specific to CMSSTCH.  It is used to locate the number of
	   records.  The number of records indicated in the trailer
	   should be equal to the number of detail records received.
	*/

	quit


RENAME(String FILE)	// Moves the file to the archive directory
	/*
	         This renames the file with the file type prefix and a date and
	         time stamp.
	*/

	type String FILENM
	type public String ARCH,TBL(),NEWFL,PATH
	type public Number FLNUM,X

	set FILENM=TBL(FLNUM)
	set NEWFL=ARCH_FILENM
	
	set X=$$COPYFIL^%OSSCRPT(FILE,NEWFL)
	
	set PATH=FILE.extract(FILENM,1)
	set PATH=PATH.extract(1,PATH.length()-1)
	
	set X=$$DELETE^%OSSCRPT(FILENM,PATH)
	
	quit
	

INIVAR	// Init runtime variables

	type public String %LOGID,ER,FLTYP
	type public Number %ProcessMode,INCFL

	if '%LOGID.exists() set %LOGID=$$LOGID^SCADRV
	
	set ER=0
	set FLTYP="STAT"
	set %ProcessMode=1
	set INCFL=1
	quit


public FILE(RecordCRD crd,Number %ProcessMode)	// File to disk

	/*

	ARGUMENTS:

	. crd Object for File CRD	/REQ/NONULL/MECH=REF
	. %ProcessMode Process Mode	/REQ/NONULL/MECH=VAL

	*/

	type String CRDNUM,CRDTYP

	if (%ProcessMode=0)!(%ProcessMode=1) do {
		do crd.save()
		}
	if %ProcessMode=3 do {
		set CRDTYP=crd.crdtyp
		set CRDNUM=crd.crdnum
		do Db.delete("CRD","CRDTYP=:CRDTYP AND CRDNUM=:CRDNUM")
		}

	quit


LOCK(String CRDTYP,String CRDNUM,String %LOCK)	//

	/*

	   This sub-routine will incrementally LOCK the card record
	   specified if it is not already contained in %LOCK.  If the
	   lock is successful, %LOCK is updated to include the card
	   number.

	   ARGUMENTS:
	       . CRDTYP    Card Type of Card to lock             /TYP=T/REQ
	                                                         /MECH=VAL

	       . CRDNUM    Card to lock                          /TYP=T/REQ
	                                                         /MECH=VAL

	       . %LOCK  Record lock string                       /TYP=T/NOREQ
	                                                         /MECH=REFNAM

	   EXAMPLE:
	       I '$$LOCK("DEBIT",123456,.%LOCK) S ER=1,ET="RECLOC" Q

	*/

	type public String CARD(,)

	set %LOCK=%LOCK.get()

	if ","_%LOCK_","[(","_CRDTYP_"|"_CRDNUM_",") quit 1

	lock +CARD(CRDTYP,CRDNUM):2 else  quit 0

	if %LOCK="" set %LOCK=CRDTYP_"|"_CRDNUM quit 1

	set %LOCK=%LOCK_","_CRDTYP_"|"_CRDNUM

	quit 1


UNLOCK(String STR,String %LOCK)	//

	/*

	   This sub-routine will decrement the LOCK for the card record(s)
	   specified by the character string 'STR' and remove it from
	   %LOCK (if it is contained in %LOCK).

	   ARGUMENTS:
	       . STR    Card(s) to unlock, comma separated    /TYP=T/REQ
	                                                      /MECH=VAL

	   INPUTS:
	       . %LOCK  Record lock string                       /TYP=T/NOREQ
	                                                         /MECH=REFNAM

	   EXAMPLE:
	       D UNLOCK(%LOCK,.%LOCK)

	*/

	type Number I,J
	type String CRDNUM,CRDTYP
	type public String CARD(,),CRDREC,TR

	set %LOCK=%LOCK.get()

	for I=1:1:STR.length(",") do {
		set CRDREC=STR.piece(",",I) quit:CRDREC=""
		set CRDTYP=CRDREC.piece("|",1)
		set CRDNUM=CRDREC.piece("|",2)
		lock -CARD(CRDTYP,CRDNUM)
		for J=1:1:%LOCK.length(",") if %LOCK.piece(",",J)=CRDREC do { quit
			set %LOCK=%LOCK.piece(",",1,J-1)_","_%LOCK.piece(",",J+1,999)
			}
		}

	if %LOCK.extract(%LOCK.length())="," set %LOCK=%LOCK.extract(1,%LOCK.length()-1)

	quit


ZTCRD	// Error trap at account level

	do ZE^UTLERR

	quit


ZT1(String FILE)	// Error trap for opening files

	type public Number %ZHALT,%ZTSEQ,CRDNUM
	type public String ET
	
	set %ZHALT=0

	do ZE^UTLERR

	// System error #~p1, contact system manager
	if %ZTSEQ.exists() set %ZTSEQ=$$^MSG(6747,%ZTSEQ)

	// Error opening ~p1
	set ET=$$^MSG(989,FILE)

	do LOG^UTLEXC(%RoutineName,"*",ET,CRDNUM.get(),%ZTSEQ.get())

	kill ET,%ZTSEQ

	quit


EXC	// Log error to DAYEND

	type public Number %ZTSEQ
	type public String CRDNUM,ET,RM

	do LOG^UTLEXC($T(+0),"*",RM.get(),CRDNUM.get(),%ZTSEQ.get(),ET.get())

	kill ET,%ZTSEQ

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60472^62254^Pete Chenard^13240"	// Signature - LTD^TIME^USER^SIZE
