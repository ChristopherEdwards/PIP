UTLMRPC		/* Procedure ID: UTLMRPC
	
	   DESC: MRPC Utilities
	   ORIG: Marty Ronky (3623)
	
	   KEYWORDS: RPC
	
	   This utility contains multiple line tags which which can be
	   called to perform various utilities fpr MRPCs.  Written to
	   help support BBMB's DecBank Interface.
	
	   LIBRARY:
	   . MOVEARR Retuns new array from array with multiple file id elements
	   . STR2ARR Returns array from tag=value string
	   . ARR2STR Retruns a tag=value string from an array
	   . SETUP  Returns array from tag=value string
	   . MORETKN Returns unique key for MORETKN file.
	   . PARSE Returns a string with doubled apostrophes where appropriate
	
	---- Revision History ------------------------------------------------

	   04/11/07 - KinI - CR 26508
	   	      Modified MORETKN section to make it public performing
	   	      minor PSL cleanup. Deleted old revision history.
	   	      
	   11/15/04 - GEORGES - CR 13074
	   	      Added function PARSE to process input strings for
                      MRPC's.  It will add single quotes around each element
                      in the delimited list, and double up single quotes
                      that are embedded inside input values.
	*/

	quit

MOVEARR(FID,NEWFID,ARRAY,NEWARR)  // Move single file record in array to new array
	/*
	  This function will take as input 2 file names and a data array.
	  The array must be in the form DATA(FID.DI)=VAL.  The function
	  will take the fields specified by the FID argument and transpose
	  them to the new array, using the NEWFID argument as the file name
	  for the new data items.

	  For example, if the following call is made,
	    D MOVEARR^UTLMRPC("DEPODP1","DEPODP",.DATA,.TMPDATA)
	  the function will copy all entries in the first array beginning
	  with DEPODP1 to the second array, replacing DEPODP1 with DEPODP as
	  the file name.  This function is useful when working with arrays
	  that contain elements corresponding to multiple files, and only a
	  subset of those elements is required.
	*/

	new DI
	set DI=FID
	for  set DI=$O(ARRAY(DI)) quit:DI=""!($P(DI,".",1)'=FID)  set NEWARR(NEWFID_"."_$P(DI,".",2))=ARRAY(DI)
	quit


STR2ARR(str,ar,dl)	// Parse input string into array format
	/*
	   STR2ARR will take a delimiter separated tag=value string
	   as input, and convert it into an array (ar) with the format
	   ar(tag)=value.
	
	   ARGUMENTS:
	
	   . str  Delimiter Separated Input String  /TYP=T/REQ/MECH=VAL
	     str format is tag=value,
	     for example:
	     str=DEP.BOO=10,DEP.BWF=1,DEP.ACNRELC='A'
	
	   . dl  Delimiter  /TYP=T/DFT=","
	
	   RETURNS:
	   . ar  ar array  /TYP=ARRAY
	     ar(tag)=value
	
	   Sample Call D STR2ARR^UTLMRPC(INPUT,.DATAIN)
	*/

	if $G(str)="" quit 
	if $G(dl)="" set dl=","
	
	new tok,i,v,z
	
	if str["'" set str=$$TOKEN^%ZS(str,.tok,"'")
	if str["""" set str=$$TOKEN^%ZS(str,.tok)
	
	for i=1:1:$L(str,dl) do {
	
		set z=$P(str,dl,i) set v=$P(z,"=",2,999) set z=$P(z,"=",1) if z="" quit 
		if $E(v)="(" set v=$E(v,2,$L(v)-1)
		if v[$C(0) set v=$$UNTOK^%ZS(v,.tok) if "'"""[$E(v) set v=$$QSUB^%ZS(v,$E(v))
	
		set ar(z)=$$TRIM^%ZS(v)
		}
	quit 
	
	
ARR2STR(fid,ar,null,dl)	// Convert array into a tag=value string
	/*
	   ARR2STR will take an array (ar) with the format ar(tag)=value as
	   input and convert it into a delimiter separated tag=value string.
	
	   ARGUMENTS:
	   . fid  DATA-QWIK Table Name /TYP=T
	     Table name to limit output
	
	   . ar  ar array  /TYP=ARRAY
	     ar(tag)=value
	
	   . null  Allow null array values in string /DFT=0
	
	   . dl  Delimiter  /TYP=T/DFT=","
	
	   RETURNS:
	   . $$  Delimiter Separated Input String  /TYP=T
	     str format is tag=value,
	     for example:
	     str=DEP.BOO=10,DEP.BWF=1,DEP.ACNRELC='A'
	
	   Sample Call S string=$$ARR2STR^UTLMRPC("CIF",.INPUT,"","|")
	*/

	new di,str
	if $G(dl)="" set dl=","
	set di=fid
	set str=""
	set null=$G(null)
	for  set di=$O(ar(di)) quit:di=""!((fid'="")&($P(di,".",1)'=fid))  do {
		if 'null,ar(di)="" quit 
		if ar(di)[".NEXTVAL"!(ar(di)[".CURRVAL") set str=str_di_"="_ar(di)_dl quit 
		set str=str_di_"="_$$QADD^%ZS(ar(di),"'")_dl
		}
	set str=$E(str,1,$L(str)-1)
	quit str
	
	
SETUP(STRING,DATA,ER)	// Put input string into array format
	/*
	
	   SETUP will take a comma separated string as input, and
	   convert it into an array (DATA) with the format DATA(FID.DI)=VAL.
	   This can be used to accept input from a foreign client for
	
	
	   Sample Call D SETUP^UTLMRPC(INPUT,.DATAIN,.RM)
	
	   ARGUMENTS:
	
	   . STRING Comma Separated Input String  /TYP=T/REQ/MECH=VAL
	     STRING format is FID.DI=VAL comma separated,
	     for example:
	     STRING=DEP.BOO=10,DEP.BWF=1,DEP.RELACNC="A"
	
	   RETURNS:
	   . DATA  DATA array  /TYP=ARRAY
	     DATA(FID.DI)=VAL
	
	
	   . ER  Error Flag  /TYP=L
	
	*/

	new PC,PTR,X
	set ER=0
	set DATA=""
	for  set PC=$$NPC^%ZS(STRING,.PTR,1) quit:PTR=0  do {
		if PC="" quit                         // Don't continue if blank
		set X=$P(PC,"=",1)                    // X=FID.DI
		if X="" set ER=1 quit                 // Error with string
		set DATA(X)=$P(PC,"=",2)              // Value of Data Item
		quit 
		}
	
	quit


public	MORETKN(String pid)	// Process ID	/TYP=T/REQ/MECH=VAL

	/*  Public Generate unique key for [MORETKN]

	    This function will generate a unique key for the MORETKN
	    file using the calling process id, date, time and a sequence
	    number.
	
	    A unique key is created by building a fixed length key
	    with the process id as the first 10 bytes, next is the julian
	    date (5 bytes) followed by the time (5 bytes). This is followed
	    by a 2 digit sequence number. The sequence will get used in
	    the event that a single process creates 2 keys in the same
	    second. If a second key is needed within a single tp set, the 
	    1st key must be inserted into the MORETKN file before calling
	    this function a second time. Since the process id is the
	    1st ten bytes, no other process will be generating a number
	    in that range, making it unqiue from all other server processes.
	
	    RETURNS:
	    . $$	Unique Key		/TYP=T
	
	    Sample Call set MORE=$$MORETKN^UTLMRPC(%ProcessID)
	*/
	
	type String X = "", MORE
	type Number PID, SEQ, TM
	type Date DT
	
	// Get last key for this pid, date, and time.
	set MORE = $$RJ((pid+1),10)_"000000000000"
	type ResultSet moretkn = Db.select("MORE","MORETKN","MORE<:MORE","MORE DESC") 
	if moretkn.next() set X = moretkn.getCol("MORE")
	
	// Generate next key
	set SEQ = "00"
	set PID = $$RJ(pid,10)
	set DT = $$RJ(%CurrentDate,5)
	set TM = $$RJ(%CurrentTime,5)
	if X.extract(1,20) = (PID_DT_TM) set SEQ = $$RJ(X.extract(21,22)+1,2)
	set MORE = PID_DT_TM_SEQ
	
	quit MORE

	
RJ(STR,LEN)     quit $tr($J(STR,LEN)," ",0)
	;
PARSE( String str, String del)	/* Public function to process MRPC input string.
 
        Parse input string for "'"'s.  Need to double up '"'s that
        appear in the input string
 
           Sample Call set INPUT=$$PARSE^UTLMRPC(INPUT)
 
           ARGUMENTS:
 
           .  str - Delimited Input String  /TYP=T/REQ/MECH=VAL
             str format is FID.DI=VAL comma separated,
             for example:
             STRING=DEP.BOO=10,DEP.BWF=1,DEP.RELACNC=A
 
           .  del  - Delimiter              /TYP=T/NOREQ/MECH=VAL
                     The delimiter to be used to parse the column name/
                     value pairs in the input string.  If not supplied,
                     comma (,) will be the default.
 
           RETURNS:
           .  $$ - reformatted input string with single quotes around each
                    value in the string and doubled apostrophes if there are
                    any apostrophes embedded in the input string.
 
         */
 
        type String i,val,x
        if del.get()="" set del=","               // default comma if delimiter is not supplied
 
        for i=1:1:str.length(del) do {
                set x=str.piece(del,i)
                set val=x.piece("=",2)
                if val.extract()="'",val.extract(val.length())="'" set val=val.extract(2,val.length()-1) //strip off quotes
                set val=val.trim()         // trim preceeding and trailing spaces
                set val=val.addQuotes("'")     // add "'" wherever needed in input string
                set x.piece("=",2)=val
                set str.piece(del,i)=x 
                }
        quit str
 #OPTION ResultClass ON
Public String vSIG()	quit "60733^41727^Irina Kin^8069"	// Signature - LTD^TIME^USER^SIZE
