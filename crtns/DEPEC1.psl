DEPEC1(RecordDEP dep,RecordTTX ttx,RecordTRN trn)	// Credit Error Correct
	/*
	   ORIG: Allan Mattson

	----  Revision History -----------------------------------------------
	
	12/04/06 - KinI - CR 22979
		   Modified KILLTR section to remove CLSTAX reference as part 
		   of Premature Withdrawal Tax processing obsoleting.
	
	10/13/06 - KinI - CR 23603
		   Modified PROC section to send dep record as additional 
		   parameter to EC^SRVTRN2.
	
	07/19/06 - DESHPANDE SK - CR20748
		   Replaced Transaction Variable %TRNMODE and %TRNPRIM with 
		   Transaction Stored Value.
	
	03/29/06 - RussellDS - CR20461
		   Fix FINDLN section to use correct variable for TSEQ when
		   accessing history record.
		   
		   Removed code in same section that got BRCD and UID from
		   PCID to make code match old version.  We can't do that anyway
		   since in that case there is no SEQ.  We just want to match
		   ETC and TAMT.
	
	09/22/05 - RussellDS - CR16911
		   Modify PROC section to fix error when trying to instantiate
		   DEP record for GL account.
		   
		   Copy lnerc from histdst to ttx.
		   
		   Modify FINDH to deal with TAMT in string format and possible
		   storage differences.
		   
		   Fix TAMT section - reference to X should have been AMT.
		   
		   Remove old revision history.
	*/

	// Backdated transaction to a segmented account
	if dep.segflg,%EffectiveDate,%EffectiveDate<%SystemDate do ^RECALSEG(.dep,.ttx) quit

	/*
	 If this credit invoked an overdraft sweep processing payment,
	 error correct the the transfer out and the payment. If this is a
	 fee, error correct the fee.
	*/

	if '$D(SRM) set SRM=""
	set CID=dep.cid

	if ttx.getStoredValue("isPrimary") do { if ER quit
		do FSECTR(.dep,.ttx)
		if SRM'="" set RM=SRM
		}

	set TAMT=ttx.tamt
	set %EffectiveDate=ttx.efd
	set TSO=ttx.tso
	set ITC=ttx.itc
	set ETC=ttx.etc

	if dep.ira do ^IRA(.dep,.ttx) if ER quit

	if ttx.getStoredValue("isPrimary") do AUT(.dep,ttx.itc) if ER quit

	new BGTSEQ,FDT,LNCID,PRIN,SEGEUR

	set PRIN=$P(TAMT,"#",2)
	if 'PRIN set PRIN=TAMT

	set dep.bal=dep.bal+PRIN
	set dep.tld=%SystemDate

	/*
	 update the collected balance if the value date/hold of
	 the original transaction has expired.
	*/
	if ttx.vdt'>%SystemDate!(ttx.vdt="") set dep.balcol=dep.balcol+PRIN

	// Call DEPSCH section of ^DEPPI when the Scheduled Deposit Processing flag is on.
	if dep.schproc do DEPSCH^DEPPI(.dep,.ttx,PRIN) if ER quit

	// Number of Credits
	if '$$TRB^UTRB(dep.cid) set dep.cntcr=dep.cntcr-1
	// Number of Debits
	else  set dep.cntdr=dep.cntdr-1

	/*
 	 If the initial deposit is being error-corrected or reversed, set
 	 the first deposit amount, first deposit date and funding date to
 	 null and kill off the dayend entry for the funding date.
	*/
	if 'dep.cntcr do {

		new ACLS,GRP,TYP

		set ACLS=dep.cls
		set GRP=dep.grp
		set TYP=dep.type
		// Date of First Deposit
		set dep.dfdep=""
		// Amount of First Deposit
		set dep.afdep=""
		set FDT=dep.fdt
		// Funding Date
		set dep.fdt=""

		if 'FDT quit

		do Db.fastDelete("DAYENDFNDT","FDT,ACLS,GRP,TYP,CID")
		}

	if ttx.tso["REV#" do ^UPDCCLD(.dep,.ttx)

	/*
	 if coming in from RECALSEG, do not round accrual amounts to zero
	 RECALSEG needs to reverse this amount so all buckets are hit
	*/
	if +dep.bal=0,'$G(RECALSEG) do {
		if $$^SCARND(dep.posacr,0,dep.cid)=0 set dep.posacr=0
		if $$^SCARND(dep.negacr,0,dep.cid)=0 set dep.negacr=0
		if $$^SCARND(dep.negacrun,0,dep.cid)=0 set dep.negacrun=0
		if $$^SCARND(dep.uncacr,0,dep.cid)=0 set dep.uncacr=0
		}

	// If Loan sweep reset ODSI and LPDUE flags
	if $P(ttx.lnerc,"#",6)=1 do {
		set dep.odsi=1
		set dep.lpdue=1
		}

	// Update Ineligible for Investment Funds
	if trn.pcfd14,dep.swpf=1 set dep.swpile=dep.swpile+TAMT

	// Segmented Account deposit Error Correct
	set SEGEUR=$$FIELD^UTSO(ttx.tso,"SEGEUR")

	if dep.segflg,'SEGEUR do DEPOSITEC^DEPPISEG(.dep,.ttx) if ER quit

	// Employer/Employee Contributions Error Correct
	if dep.emplben do EMP^DEPPI(.dep,.ttx,-1) if ER quit

	// Commission Payment error Correct
	if ttx.tso["COMPST#" do REVCOM^TTXCOM(.ttx)

	if (%EffectiveDate="")!(%EffectiveDate=%SystemDate) do UPDAVB^DEPPI(.dep,.ttx)

	set TSO=ttx.tso
	do OUT^UTSO(.TSO,TSO)

	// Budget Account Processing
	set BGTSEQ=$G(TSO("BGT"))

	if BGTSEQ'="" do {
		new BGTCHK,SAVEEC,MISCON

		// Pass new info from piece 16 of ttx
		set SAVEEC=ttx.lnerc
		set BGTCHK=$P(SAVEEC,"#",32)
		set MISCON=$P(SAVEEC,"#",33)

		do BGTPROC^DEPPO(.ttx,PRIN,BGTSEQ,3,BGTCHK,MISCON)
		}

	// Interest Reserve Processing
	set LNCID=$G(TSO("LNIRCID"))

	if LNCID="" do {
		type ResultSet rs=Db.select("LNCID","RELIR","IRCID=:CID")

		if rs.next() set LNCID=rs.getCol(1)
		}

	if LNCID'="" do {

		type RecordRELIR relir=Db.getRecord("RELIR","CID,LNCID",1)
		if relir.getMode()=0 quit

		set relir.iramtr=relir.iramtr+TAMT

		do relir.bypassSave()
		}

	if ttx.getStoredValue("isPrimary"),$$EFDATE do ENT^RECALC(.dep,.ttx) if 'ER,SRM="" set RM=SRM
	if ER quit

	// process effective-dated reversal transactions for commitment fee accts
	if (dep.commfper'="")&(%EffectiveDate'="") do {

		if dep.commefd="" set dep.commefd=%EffectiveDate

		else  if %EffectiveDate<dep.commefd set dep.commefd=%EffectiveDate
		}

	quit


AUT(RecordDEP dep,ITC)	// Authorization Verification

	new RTAMT

	set RTAMT=-TAMT

	do AUT^UHLD(.dep,RTAMT,ITC,.OVR)

	if +dep.rflg do ^UFLG(.dep)
	if dep.flg do FLG^UFLG(.dep,ITC)

	if RTAMT>(dep.bal+dep.nsflim) set OVR(dep.cid,"OVR","BAL")=$$^SCARND(+dep.bal,0,dep.cid)
	if dep.ircb'=3,dep.ircb'=6,RTAMT>(dep.balcol+dep.nsflim) set OVR(dep.cid,"OVR","BALCOL")=$$^SCARND(dep.balcol,0,dep.cid)

	if dep.minbal'="",(dep.bal-RTAMT<dep.minbal) set OVR(dep.cid,"OVR","MINBAL")=dep.minbal

	if dep.stat set OVR(dep.cid,"OVR","STAT"_+dep.stat)=""

	quit


Public FSECTR(RecordDEP dep, RecordTTX ttx)	// Overdraft Protection, Sweep Processing, Fee Error Correct
	/*
	   Find the transaction in history, then use the lower levels
	   of history to error correct the spawned transactions.
	*/
	new HDT,HSEQ,RESADJ,SITC,XT

	set TAMT=+ttx.tamt
	set RESADJ=$P(ttx.lnerc,"#",26)
	set HDT=""

	if ttx.itc6 set HSEQ=$$FINDH(.ttx)

	if ttx.itc12 do {
		set HSEQ=$$FIELD^UTSO(ttx.tso,"REV")

		type RecordHIST hist=Db.getRecord("HIST","CID,HSEQ")

		set HDT=hist.tjd
		}

	if RESADJ,'$$EFDATE do INTERVEN(HSEQ) if ER quit

	type ResultSet rs=Db.select("DSTSEQ","HISTDST","CID=:CID AND TSEQ=:HSEQ")

	if rs.isEmpty() quit

	new DSTSEQ,PCID,PEFD,PITC,PTSO

	set PCID=ttx.cid
	set PTSO=ttx.tso
	set PEFD=ttx.efd
	set PITC=ttx.itc

	while rs.next() do {

		set DSTSEQ=rs.getCol(1)

		type RecordHISTDST histdst=Db.getRecord("HISTDST","CID,HSEQ,DSTSEQ")
		type RecordTTX ttx=Class.new("RecordTTX")

		set ttx.cid=histdst.acct
		set ttx.itc=histdst.itc
		set ttx.etc=histdst.etc
		set ttx.tamt=histdst.tamt
		set ttx.efd=histdst.efd
		set ttx.tlo=histdst.tlo
		set ttx.tso=histdst.tso
		set ttx.tcmt=histdst.tcmt
		set ttx.cdt=histdst.cdt
		set ttx.uidt=histdst.uidt
		set ttx.spr=histdst.spr
		set ttx.crcd=histdst.crcd
		set ttx.rate=histdst.rate
		set ttx.cc=histdst.cc
		set ttx.bseamt=histdst.bseamt
		set ttx.custcd=histdst.custcd
		set ttx.bcrcd=histdst.bcrcd
		set ttx.lnerc = histdst.lnerc

		do PROC(.dep,.ttx)
		}

	quit


PROC(RecordDEP dep, RecordTTX ttx)	// Process transaction

	new AMT,CID,ETC,I,KILL,LTSEQ,PGM,TCMT,TSO1,TSO2

	set KILL=0
	set CID=ttx.cid
	set ETC=ttx.etc
	set AMT=ttx.tamt

	type RecordTRN trn=Db.getRecord("TRN","ETC")

	if trn.cls'="M" do CIDINIT(.ttx,CID)
	if KILL quit

	if trn.cls="L" do FINDLN(.ttx)

	if $E(PITC,6) do {
		set ttx.itc=$$ITC^TTXEXT(ttx.itc,6)
		set TCMT=$$^MSG(7651,ttx.tcmt)
		}
	else  do {
		set ttx.itc=$$ITC^TTXEXT(ttx.itc,12)
		set TCMT=$$^MSG(3543,$$DAT^%ZM(HDT,$G(%MSKD)),ttx.etc)
		}

	// Reverse the sign on all tran amount components
	set ttx.tamt=$$TAMT(AMT)

	if 'ttx.efd set ttx.efd=PEFD

	set TSO1=PTSO
	set TSO2=ttx.tso
	do OUT^UTSO(.TSO1,TSO1)
	do OUT^UTSO(.TSO2,TSO2)

	if $D(TSO1("EC")) set TSO2=$$FIELDIN^UTSO(TSO2,"EC",TSO1("EC"))

	if trn.cls="L",LTSEQ set TSO2=$$FIELDIN^UTSO(TSO2,"REV",LTSEQ)

	if '((trn.cls = "L") ! (trn.cls = "M")) do {
		/*
		  Find the original transaction generated by the
		  secondary and use that in TSO REV#seq.
		*/
		type Boolean HIT
		type Number PTSEQ

		set HIT=0

		// Get info from primary transaction
		set PTSEQ=TSO1("REV")

		type RecordHIST primhist = Db.getRecord("HIST", "CID=:CID,TSEQ=:PTSEQ", 1)
			
		quit:primhist.getMode() = 0
			
		//set TSO2 = primhist.tso
			
		// Find secondary
		type DbSet ds = Db.selectDbSet("HIST", "CID=:CID AND TSEQ>:PTSEQ AND TJD=:primhist.tjd AND BRCD=:primhist.brcd AND ETC=:ttx.etc", "TSEQ ASC")
			
		while ds.next() do { quit:HIT
				
			type RecordHIST hist = ds.getRecord("HIST")
				
			/* Until issues with Oracle handling of these columns is
			   resolved, don't put them in the WHERE clause.  Issues
			   are TAMT as string so 10'=10.00 (eventually use PRIN);
			   EFD="" does not return same results as EFD IS NULL.
			*/
			quit:hist.tamt + ttx.tamt '= 0
			quit:hist.efd '= primhist.efd
			quit:hist.trc '= primhist.trc
			quit:hist.crcd ' = primhist.crcd 

			set HIT = 1
			set TSO2 = hist.tso
			set TSO2 = $$FIELDIN^UTSO(TSO2, "REV", hist.tseq)
			if $D(TSO1("EC")) set TSO2=$$FIELDIN^UTSO(TSO2,"EC",TSO1("EC"))
					
			// Effective dated service fee adj
			if $D(TSO2("SRVADJ")) do {
				
				if (CID '= dep.cid) do {
				
					type RecordDEP dep2 = Db.getRecord("DEP", "CID=:CID")
				
					do EXTERN^BCHFEEUT(.dep2,"111",TSO2("SRVADJ"))
				}
				else  do EXTERN^BCHFEEUT(.dep,"111",TSO2("SRVADJ"))
			}
					
		}

 		if 'HIT,$G(TSO1("REV")) set TSO2=$$FIELDIN^UTSO(TSO2,"REV",TSO1("REV"))
	}

	set ttx.tso=TSO2
	set ttx.tcmt=TCMT

	// Direct Transaction Fee
	if +$P(ttx.lnerc,"#",11) do EC^SRVTRN2(.ttx, .dep)
	
	// Post the transaction
	if "DL"'[trn.cls do {
		do TRNSINGL^TRNDRV(.ttx,,TPD,BRCD,5)
	}
	else  do {
		if (CID = dep.cid) do {
			do TRNSINGL^TRNDRV(.ttx,.dep,TPD,BRCD,5)
		}
		else  do TRNSINGL^TRNDRV(.ttx,,TPD,BRCD,5)
	}
	
	quit


TSO2(RecordDEP dep,RecordTTX ttx)

	set TSO2=$$FIELDIN^UTSO(TSO2,"REV",TSEQ)
	set HIT=1
	set ttx.tamt=$$TAMT(AMT)

	if $D(TSO2("SRVADJ")) do EXTERN^BCHFEEUT(.dep,"111",TSO2("SRVADJ"))

	quit


FINDLN(RecordTTX ttx)	// find the loan seq to be reversed ...

	new BRCD,LTAMT,LTJD,LTSO,TAMT,TRC,UID,XTSO

	set TAMT=ttx.tamt
	set LTSEQ=""

	do OUT^UTSO(.XTSO,PTSO)

	if $G(XTSO("REV")) do {
		
		type String TSEQ = XTSO("REV")

		type ResultSet rs=Db.select("BRCD,UID,TRC","HIST","CID=:PCID AND TSEQ=:TSEQ")

		if rs.isEmpty() quit

		if rs.next() do {
			set BRCD=rs.getCol(1)
			set UID=rs.getCol(2)
			set TRC=rs.getCol(3)
			}

		type ResultSet rs1=Db.select("TSEQ,TSO,TAMT,TJD","HIST","CID=:CID AND ETC=:ETC AND TAMT=:TAMT AND BRCD=:BRCD AND UID=:UID AND TRC=:TRC","TSEQ DESC")

		if rs1.isEmpty() quit

		if rs1.next() do {
			set LTSEQ=rs1.getCol(1)
			set LTSO=rs1.getCol(2)
			set LTAMT=rs1.getCol(3)
			set LTJD=rs1.getCol(4)
			}
		}

	else  do {


		type ResultSet rs1=Db.select("TSEQ,TSO,TAMT,TJD","HIST","CID=:CID AND ETC=:ETC AND TAMT=:TAMT","TSEQ DESC")

		if rs1.isEmpty() quit

		if rs1.next() do {
			set LTSEQ=rs1.getCol(1)
			set LTSO=rs1.getCol(2)
			set LTAMT=rs1.getCol(3)
			set LTJD=rs1.getCol(4)
			}
		}

	if LTSEQ="" quit

	if $E(PITC,6) set ttx.tso=$$FIELDIN^UTSO(LTSO,"EC",LTSEQ)
	else  set ttx.tso=$$FIELDIN^UTSO(LTSO,"REV",LTSEQ)

	set AMT=LTAMT

	quit


CIDINIT(RecordTTX ttx,CID)	// Initialization for account transactions

	type RecordACN acn=Db.getRecord("ACN","CID")

	set TYPE=acn.type

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")

	if acn.crcd'=%SystemCurrency set ttx.crcd=acn.crcd

	/*
	  Secondary adjustments must be eliminated if effective-dated since
	  RECALC will recalculate them.
	*/
	if '$$EFDATE quit

	if $$KILLTR(0,.prodctl,.ttx) set KILL=1 quit

	if $$KILLTR(1,.prodctl,.ttx) set KILL=1 quit

	quit


KILLTR(DRCR,RecordPRODCTL prodctl,RecordTTX ttx)

	new FOUND

	set FOUND=0

	if 'DRCR do {
		if prodctl.dradin=ETC set FOUND=1 quit
		if prodctl.dradpe=ETC set FOUND=1 quit
		if prodctl.dradbw=ETC set FOUND=1 quit
		if prodctl.dradmi=ETC set FOUND=1 quit
		if prodctl.drades=ETC set FOUND=1 quit
		if prodctl.dradie=ETC set FOUND=1 quit
		if prodctl.dradna=ETC set FOUND=1 quit
		if prodctl.dradni=ETC set FOUND=1 quit
		if prodctl.dradres=ETC set FOUND=1 quit
		if prodctl.drnegacrua=ETC set FOUND=1 quit
		if prodctl.draai=ETC set FOUND=1 quit
		if prodctl.drpai=ETC set FOUND=1 quit
		}

	else  do {
		if prodctl.cradin=ETC set FOUND=1 quit
		if prodctl.cradpe=ETC set FOUND=1 quit
		if prodctl.cradbw=ETC set FOUND=1 quit
		if prodctl.cradmi=ETC set FOUND=1 quit
		if prodctl.crades=ETC set FOUND=1 quit
		if prodctl.cradie=ETC set FOUND=1 quit
		if prodctl.cradna=ETC set FOUND=1 quit
		if prodctl.cradni=ETC set FOUND=1 quit
		if prodctl.cradres=ETC set FOUND=1 quit
		if prodctl.cradpac=ETC set FOUND=1 quit
		if prodctl.crnegacrua=ETC set FOUND=1 quit
		if prodctl.craai=ETC set FOUND=1 quit
		if prodctl.crpai=ETC set FOUND=1 quit
		}

	if 'FOUND quit 0

	// Not a deferred int post or a cumulative int adj
	if ttx.tso'["DEFINT#",ttx.tcmt'[$$^MSG(4681) quit 1

	if 'DRCR,prodctl.dradie=ETC quit 0
	if 'DRCR,prodctl.dradni=ETC quit 0
	if 'DRCR,prodctl.dradres=ETC quit 0

	if DRCR,prodctl.cradie=ETC quit 0
	if DRCR,prodctl.cradni=ETC quit 0
	if DRCR,prodctl.cradres=ETC quit 0

	quit 1


FINDH(RecordTTX ttx)

	/* Because TAMT is stored in a character field, it may or may not
	   contain trailing zeros (10 or 10.00), so we need to check for
	   both values.
	*/

	new XETC,XTAMT1,XTAMT2,XBRCD,XUID

	set XETC=ttx.etc
	set XTAMT1 = -TAMT
	set XTAMT2 = {Number}XTAMT1.roundDec(2)
	set XBRCD=ttx.brcd
	set XUID=ttx.uid

	type ResultSet rs=Db.select("TSEQ","HIST","CID=:CID AND ETC=:XETC AND (TAMT=:XTAMT1 OR TAMT=:XTAMT2) AND BRCD=:XBRCD AND UID=:XUID","TSEQ DESC")

	if rs.isEmpty() quit 0

	if rs.next() quit rs.getCol(1)

	quit ""


EFDATE()	// Determine if there is an effective date

	if %EffectiveDate,%EffectiveDate-%SystemDate quit 1

	quit 0


INTERVEN(HSEQ)	// Check for intervening transactions

	type ResultSet rs=Db.select("ITC","HIST","CID=:CID AND TSEQ>:HSEQ")

	if rs.isEmpty() quit

	new ITC

	while rs.next() do {

		set ITC=rs.getCol(1)

		// Secondary transaction
		if $E(ITC,7) quit
		// Previously error corrected
		if $E(ITC,6) quit

		// Reverse intervening transactions first
		do Runtime.setErrMSG("DEP",856) quit
		}	

	quit


TAMT(AMT)

	new I

	for I=1:1:$L(AMT,"#") set:$P(AMT,"#",I) $P(AMT,"#",I)=-$P(AMT,"#",I)

	quit AMT
 #OPTION ResultClass ON
Public String vSIG()	quit "60603^53031^Irina Kin^13874"	// Signature - LTD^TIME^USER^SIZE
