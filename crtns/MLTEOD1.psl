MLTEOD1		/*
	PROCEDURE:  MLTEOD1
	ORIG: Tom Locke - 03/18/87
	DESC: Run batch file maintenance updates

	---- Comments --------------------------------------------------------

	This procedure uses the table DAYENDPCHG for the current system date
	to locate batch file maintenance by product type.  For each type,
	a set of run-time code is generated to apply the changes.  This code
	is passed to a jobbed version of MLTEOD2 to generate and run the
	code to apply the changes.

	RETURNS:
		. ER		Error flag	/TYP=L

		. RM		Error message	/TYP=T

 	---- Revision History ------------------------------------------------

	10/23/06 - KELLYP - CR 23506
		   Modified TYPE section to quit when the product type 
		   specified in DAYENDBFM is not present in PRODCTL.  This
		   prevents the whole procedure from aborting when a product
		   type specified in DAYENDBFM no longer exists in the system.
		   Also cleaned up top level and TYPE sections to conform to
		   current PSL standards.

	01/17/06 - chhabris - CR19002
		   Added an error check in ONECHG section after a call to 
		   ^UCQRYBLD to avoid undefined errors in Dayend.
		   Replaced variable CHGNUM with NUM in MULTCHG section to 
		   avoid errors occurring when there are two or more separate
		   entries made to a table with the exact same query.

	01/12/05 - ARPAVC 13861
		   Fixed compile errors and miscellaneous issues.  
		   - Properly scoped all variables
		   - Removed comment tag at end of line 100 so the following 
		     lines of code are not intrerpreted as comments.
		      
	05/12/02 - Dan Russell
		   Rewrote from M to PSL.  Modified to generate PSL code
		   and compile that to M, instead of going directly to M.

		   Makes use of the new DAYENDPCHG table.

		   Removed old change history.
	*/

	type public Boolean MLTEOD1,MLTEOD

	type Date DATE
	type Number BTTJOB
	type String CLSTBL(),TAB,TBLS()

	// Catch GT.M errors
	catch error {
		type public Boolean ER
		type public String RM
		
		do ZE^UTLERR
		set ER=1
		}

	lock +MLTEOD1:2 else  quit			// Only one can run
	
	/* 
	 Set valid tables and their key names, plus CLS to table
	 references.  May add new tables in the future if we split
	 some of the wide tables.
	*/
	set TBLS("CIF")="ACN",TBLS("ZCIF")="ACN"
	set TBLS("DEP")="CID",TBLS("ZDEP")="CID"
	set TBLS("LN")="CID",TBLS("ZLN")="CID"
	set CLSTBL("*")="CIF",CLSTBL("D")="DEP",CLSTBL("L")="LN"

	set DATE=%SystemDate
	set TAB=$char(9)

	type ResultSet debfmrs=Db.select("DISTINCT CLS,TYPE","DAYENDBFM","TJD=:DATE","CLS,TYPE")

	set BTTJOB=CUVAR.bttjob 
	if 'BTTJOB set BTTJOB=1	// Limit number of jobs

	// Process changes for each type
	while debfmrs.next() do TYPE(debfmrs.getCol("CLS"),debfmrs.getCol("TYPE"))

	// Wait until all jobs complete
	lock +MLTEOD
	lock -MLTEOD 
	lock -MLTEOD1

	quit


TYPE(String CLS,Number TYPE)	// Private - Process all changes for selected TYPE

	type public Boolean ER,MLTEOD()
	type public String ET,RM,TAB
	type public Number BTTJOB
	
	type Boolean OPTIMIZE
	type Number CHGNUM1,CNT,INDX,JOBNUM,N
	type String CODE(),CHGNUMS(),GRP,LOGFILE,PGM,TAGS(),X
	
	// Catch GT.M errors but continue with next type
	catch error {
		type String ET,%ZTSEQ

		do ZE^UTLERR

		set ER=1

		//Error Log Sequence #~p1
		if %ZTSEQ.exists() set %ZTSEQ=$$^MSG(3389,%ZTSEQ)

		// System processing error
		set ET=$$^MSG(2575)

		// Log error in exception file
		// MLT End-Of-Day
		do LOG^UTLEXC($T(+0),"*",$$^MSG(4275),"",$G(%ZTSEQ),ET,"")
		}

	/* ^DAYEND(TJD,"BFM",CLS,TYPE,CHGNUM,SEQ)
	    Get CHGNUMs.  If only one, generate optimized selection code so don't need to access
	    all accounts of this type.  If more than one, have no choice.
	*/

	// Load template into array CODE and create cross-reference for "//*" markers

	do ^ULODTMPL("MLTEOD3","CODE")
	set N=""
	for  set N=CODE(N).order() quit:N.isNull()  do {
		quit:CODE(N)'["//*"
		set TAGS($P($P(CODE(N),"//*",2)," ",1))=N
		}

	// Get group for this type.  Need it in SELECT to optimize query due
	// to use of order by clause -- otherwise query forces initial sort.
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE",1)

	if 'prodctl.getMode() quit	// Product type no longer defined
	
	set GRP=prodctl.grp

	// Get all change sets for this type
	type ResultSet chgnumrs=Db.select("DISTINCT CHGNUM","DAYENDBFM","TJD=:DATE AND CLS=:CLS AND TYPE=:TYPE","CHGNUM")

	// Shouldn't happen, but just in case, quit when no 
	// changes defined for this cls and type
	if chgnumrs.isEmpty() quit

	set CNT=0
	while chgnumrs.next() do {
		set CNT = CNT + 1
		set INDX = chgnumrs.getCol("CHGNUM")
		set CHGNUMS(INDX)=""
		}

	set CODE($$LINE("result_set"))=TAB_"// Changes for type "_TYPE

	// If only one change, see if can optimize
	set OPTIMIZE=0
	if CNT=1 set OPTIMIZE=$$ONECHG

	if ER quit
	
	if (CNT>1)!('OPTIMIZE) do MULTCHG

	// Test compile first, then pass to MLTEOD2 as jobbed process to
	// re-compile and run

	kill RM
	
	set PGM="TMP"_(%ProcessID#100000)
	
	do BUILDRTN^UCGM(.CODE,PGM,.RM)
	
	if RM.exists() set ER=1 quit

	do DEL^%ZRTNDEL(PGM)

	// Set first change number for use in filing restart info
	set CHGNUM1=CHGNUMS("").order()

	// See if can run another job yet -- coordinate on running
	// jobs with lock on MLTEOD.

	set JOBNUM=0
	for  do { quit:JOBNUM  hang 10
		type Number I
		for I=1:1:BTTJOB lock +MLTEOD(I):0 if  set JOBNUM=I quit
		}

	// Job MLTEOD2 to create run-time routine for this TYPE
	set LOGFILE=$C(34)_$$SCAU^%TRNLNM("SPOOL","MLTEOD_"_TYPE_".LOG")_$C(34)
	set X=$$^%ZJOB("^MLTEOD2","LOG="_LOGFILE)
	if 'X do {					// Error on ^%ZJOB
		set ER=1
		// ~p1 Job failure
		set ET=$$^MSG(3053,"MLTEOD "_TYPE)
		// Log error in exception file
		// MLT End-Of-Day
		do LOG^UTLEXC($T(+0),"*",$$^MSG(4275),"","",ET,"")
		set RM=ET
		}
	// Let jobbed process get started
	else  do {
		hang 2
		lock -MLTEOD(JOBNUM)
		}

	quit


ONECHG()	// Private - build optimized code if possible.
	/* This may be possible if there is only one change set for TYPE, and 
	   if the query is only against the same table.
	   Return 0 if can't optimize via single select, otherwise build 
	   optimized code and return 1 if able to optimize.
	*/

	new CHGNUM,COLUMN,INPUT,INSTANTS,KEY,LASTREC,NEWVAL,PSLOBJ,PSLQRY,QRY
	new QUERY,RS,SEQ,TABLE,TABLELC,TABLES,XUID,XTLO

	type Public Number CHGNUMS(),TYPE
	type Public String CODE(),GRP,TAB,TBLS()
	type Public Boolean ER

	set CHGNUM=$O(CHGNUMS(""))

	// Load change info
	type ResultSet chgrs=Db.select("SEQ,COL,NEWVALUE,TBL,QRY,UID,TLO,LASTREC","DAYENDBFM","TJD=:DATE AND CLS=:CLS AND TYPE=:TYPE AND CHGNUM=:CHGNUM","SEQ")
	while chgrs.next() do {
		set SEQ=chgrs.getCol(1)
		set COLUMN(SEQ)=chgrs.getCol(2)
		set NEWVAL(SEQ)=chgrs.getCol(3)
		if SEQ=1 do {
			set TABLE=chgrs.getCol(4)
			set QRY=chgrs.getCol(5)
			set XUID=chgrs.getCol(6)
			set XTLO=chgrs.getCol(7)
			set LASTREC=chgrs.getCol(8)
		}
	}

	set KEY=TBLS(TABLE)

	// Add group and type selection to query
	set QUERY="GRP='"_GRP_"' AND TYPE='"_TYPE_"'"
	if QRY'="" set QUERY=QUERY_" AND ("_QRY_")"

	if LASTREC set QUERY=KEY_">"_LASTREC_" AND "_QUERY	// Add restart logic

	set TABLELC=$$LOWER^%ZFUNC(TABLE)	// Lower case table name for object

	set INPUT("WHERE")=QUERY
	// Define object that will be instantiated, e.g., DEP=dep
	set INSTANTS=TABLE_"="_TABLELC
	do ^UCQRYBLD(.INPUT,INSTANTS,.TABLES,.PSLOBJ,.PSLQRY)
	
	if ER quit ""

	if TABLE'=TABLES quit 0		// Can't optimize as single select in PSL

	set RS=TABLELC_"rs"

	// Add result set
	set CODE($$LINE("result_set"))=TAB_"// Optimized code since only one set of changes"
	do ADDRS			// Add result set code

	// Add process record code - no need to do any queries, just do updates
	// and save since query build into result set
	set CODE($$LINE("procrec"))=TAB_"type Record"_TABLE_" "_TABLELC_"=Db.getRecord("""_TABLE_""","""_KEY_"=:RECID"")"
	set CODE($$LINE("procrec"))=TAB_"do "_TABLELC_".setAuditFlag(1)"
	set SEQ=""
	for  set SEQ=$O(COLUMN(SEQ)) quit:SEQ=""  do {
		set CODE($$LINE("procrec"))=TAB_"set "_TABLELC_"."_$$LOWER^%ZFUNC(COLUMN(SEQ))_"="""_NEWVAL(SEQ)_""""
	}
	set CODE($$LINE("procrec"))=TAB_"set UID="""_XUID_""""
	set CODE($$LINE("procrec"))=TAB_"set TLO="""_XTLO_""""
	set CODE($$LINE("procrec"))=TAB_"do "_TABLELC_".save()"
	set CODE($$LINE("procrec"))=""

	quit 1


MULTCHG	// Private - Multiple change sets or can't optimize
	/* Approach is to build result set of all records of given TYPE, call
	   PROCREC for each record to instantiate, then test each query and for
	   each one that is true, apply updates associated with the change set
	   and save.

	   Note that since all changes are applied at once, with a single save,
	   the user ID and TLO associated with the last change will be used
	   for recording all the changes.
	*/

	new CHGNUM,INSTANTS,KEY,LASTREC,QRYSET,QUERY,RS,TABLE,TABLELC,XTLO,XUID
	
	type Public String CLS,CLSTBL(),CODE(),GRP,TAB,TBLS()
	type Public Number CHGNUMS(),TYPE
	type Public Date DATE
	type Number NUM
	
	set TABLE=CLSTBL(CLS)
	set TABLELC=$$LOWER^%ZFUNC(TABLE)
	set RS=TABLELC_"rs"
	set KEY=TBLS(TABLE)
	set QUERY="GRP='"_GRP_"' AND TYPE='"_TYPE_"'"

	// Determine if restart
	set CHGNUM=$O(CHGNUMS(""))
	type RecordDAYENDBFM debfm=Db.getRecord("DAYENDBFM","TJD=:DATE,CLS=:CLS,TYPE=:TYPE,CHGNUM=:CHGNUM,SEQ=1")
	set LASTREC=debfm.lastrec
	if LASTREC set QUERY=KEY_">"_LASTREC_" AND "_QUERY	// Add restart logic
	do ADDRS

	// Instantiate record
	set CODE($$LINE("procrec"))=TAB_"type Record"_TABLE_" "_TABLELC_"=Db.getRecord("""_TABLE_""","""_KEY_"=:RECID"")"

	// Loop through each change - build query section and update section
	// Collapse query sections if identical
	set CHGNUM=""
	for  set CHGNUM=$O(CHGNUMS(CHGNUM)) quit:CHGNUM=""  do {
		new COLUMN,NEWVAL,QRYNUM,QUERY,SEQ,TABLE
		type ResultSet chgrs=Db.select("SEQ,COL,NEWVALUE,TBL,QRY,UID,TLO","DAYENDBFM","TJD=:DATE AND CLS=:CLS AND TYPE=:TYPE AND CHGNUM=:CHGNUM","SEQ")
		while chgrs.next() do {
			set SEQ=chgrs.getCol(1)
			set COLUMN(SEQ)=chgrs.getCol(2)
			set NEWVAL(SEQ)=chgrs.getCol(3)
			if SEQ=1 do {
				set TABLE=chgrs.getCol(4)
				set QUERY=chgrs.getCol(5)
				set XUID=chgrs.getCol(6)
				set XTLO=chgrs.getCol(7)
			}
		}
		if QUERY="" do {
			set CODE($$LINE("procrec"))=TAB_"// Change #"_CHGNUM_" - no query"
			set CODE($$LINE("procrec"))=TAB_"do UPDT"_CHGNUM_"(."_TABLELC_")"
		}

		else  do {
			if $D(QRYSET(QUERY)) do {
				set CODE($$LINE("procrec"))=TAB_"// Change #"_CHGNUM_" - Uses same query as #"_QRYSET(QUERY)
				set NUM=QRYSET(QUERY)
			}
			else  do {
				do BLDQRY
				set CODE($$LINE("procrec"))=TAB_"// Change #"_CHGNUM
				set QRYSET(QUERY)=CHGNUM,NUM=CHGNUM
			}
			set CODE($$LINE("procrec"))=TAB_"do QRY"_NUM_"(."_TABLELC_")"
			set CODE($$LINE("procrec"))=TAB_"if  do UPDT"_CHGNUM_"(."_TABLELC_")"
		}

		// Add update code
		set CODE($$LINE("updates"))="UPDT"_CHGNUM_"(Record"_TABLE_" "_TABLELC_")"_TAB_"// Apply updates for change #"_CHGNUM
		set CODE($$LINE("updates"))=TAB_"do "_TABLELC_".setAuditFlag(1)"
		set SEQ=""
		for  set SEQ=$O(COLUMN(SEQ)) quit:SEQ=""  do {
			set CODE($$LINE("updates"))=TAB_"set "_TABLELC_"."_$$LOWER^%ZFUNC(COLUMN(SEQ))_"="""_NEWVAL(SEQ)_""""
		}
		set CODE($$LINE("updates"))=TAB_"quit"
		set CODE($$LINE("updates"))=""
	}

	// Add code to save updates
	set CODE($$LINE("procrec"))=TAB_"set UID="""_XUID_""""
	set CODE($$LINE("procrec"))=TAB_"set TLO="""_XTLO_""""
	set CODE($$LINE("procrec"))=TAB_"do "_TABLELC_".save()"
	set CODE($$LINE("procrec"))=""

	quit


ADDRS	// Private - add result set code
	// Order by KEY to ensure go through the file in order to enable
	// restart if necessary

	type Public String CODE(),KEY,RS,QUERY,TAB,TABLE
	
	set CODE($$LINE("result_set"))=TAB_"type ResultSet "_RS_"=Db.select("""_KEY_""","""_TABLE_""","""_QUERY_""","""_KEY_""")"
	set CODE($$LINE("result_set"))=TAB_"if "_RS_".isEmpty() quit"
	set CODE($$LINE("result_set"))=TAB_"while "_RS_".next() do PROCREC("_RS_".getCol(1),debfm)"
	set CODE($$LINE("result_set"))=""

	quit


BLDQRY	// Private - Build query code

	new DBQRY,INPUT,N,PSLOBJ,PSLQRY,TABLES,WHERE
	
	type Public Number CHGNUM
	type Public String CODE(),QUERY,TAB,TABLE,TABLELC
	type String INSTANTS
	
	set CODE($$LINE("queries"))="QRY"_CHGNUM_"(Record"_TABLE_" "_TABLELC_")"_TAB_"// Query for change #"_CHGNUM

	// Convert query to PSL code
	set INPUT("WHERE")=QUERY
	// Define object that will be instantiated, e.g., DEP=dep
	set INSTANTS=TABLE_"="_TABLELC
	do ^UCQRYBLD(.INPUT,INSTANTS,.TABLES,.PSLOBJ,.PSLQRY)

	set N=""
	// Insert lines to instantiate new objects
	for  set N=$O(PSLOBJ(N)) quit:N=""  set CODE($$LINE("queries"))=TAB_PSLOBJ(N,1)

	// Insert the query lines
	for  set N=$O(PSLQRY(N)) quit:N=""  do {
		set CODE($$LINE("queries"))=TAB_"if "_PSLQRY(N)
		set CODE($$LINE("queries"))=TAB_"else  quit"
		}

	set CODE($$LINE("queries"))=TAB_"quit"
	set CODE($$LINE("queries"))=""

	quit


LINE(ref)	// Get next line number based on reference

	type Public String CODE,TAGS
	
	quit $O(CODE(TAGS(ref)),-1)+.0001
 #OPTION ResultClass ON
Public String vSIG()	quit "60561^58409^Pat Kelly^12526"	// Signature - LTD^TIME^USER^SIZE
