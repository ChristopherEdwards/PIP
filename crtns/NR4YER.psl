NR4YER	// Private; NR4 Year-end Form Extract
	/*
	Copyright(c)2000 Sanchez Computer Associates, Inc.  All Rights Reserved - 07/11/00 15:27:46 - KINI
	      ORIG: Dennis Ratmansky
	     CALLS:  
	      DESC:    NR4 yearend forms called by report YER435 to create 
			sort file.
	I18N=QUIT 
	  GLOBALS -
	      READ:  
	       SET:  
	
	     INPUT:  
	    OUTPUT:  
	
	       Description of special arrays and pieces 
	 
	 IRA("TOT",BOO)|1   = Node 13 Distribution totals 
	 IRA("TOT",BOO)|2   = Node 14 Withholding totals 
	 IRA("TOT",BOO)|3   = Branch has keepable unreportable plans 
	 IRA(BOO,RPASEQ)|55 = CRCD of 1st account in plan 
	 IRA(BOO,RPASEQ)|56 = [DEP]BOO of 1st account in plan 
	 IRA(BOO,RPASEQ)|57 = Is BOO/RPASEQ reportable. 
	 IRA(BOO,RPASEQ)|58 = Negative amount discovered. 
	
	 EXT ENTRY:  
	
	---- Revision History ------------------------------------------------

	07/31/06 - KELLYP - CR 22048
		   Modified NR4D2 section to eliminate compilation errors.

	01/20/06 - Mugilvannan - 18752
		   Converted to PSL

	*/
	
	
	/* NR4E	 
	
		Build ^NR4 Global for NR4-Earnings and NR4-Distributions
		files.
	
	 KEYWORDS:	YEAREND,NR4
	
	 ARGUMENTS:
		. None
	
	 INPUTS:
		. ^CIF,^IRA,^ACN
	
	 RETURNS:
		. ^NR4	File specified		/TYP=T
	
	 EXAMPLE:
		D NR4E^NR4YER
	*/
	quit
	
NR4E	// Build NR4EINF Table for NR4-Earnings
	
	
	type String A(,),CRCD,KEY1
	type Number ACNCNT,CID,FN,KEEP,RPTALL,RAMT,NEGAMT,NONREP
	type public Number ACN,BOOS(),BOO,START,STOP
	type public String CRCDS(),DATA(),MYQRY,TOTGI(),TOTIS(),TOTNR(),TOTBI(),TOTBW(),NRGI(),NRNTW(),YEAR
	
	set KEY1="NR4E"
	
	set ACNCNT=0   
	set YEAR=$$YEAR^SCADAT(%SystemDate)-1
	do Db.fastDelete("TMPRPT0","PID=:%ProcessID")
	
	if MYQRY="ALL" set RPTALL=1
	else  set RPTALL = 0

	
	//  Retrieve the Default Currency Code for the system.
	do CRCD^TTXSUM
	set RAMT = CUVAR.nr4bramt	// NR4B Reportable Amount
	
	set (CID,FN,NEGAMT,NONREP)=""
	set ACN=START
	
	type ResultSet rs=Db.select("ACN,BOO","CIF","ACN>:START AND (ACN<:STOP or ACN=:STOP)","ACN")

	while rs.next() quit:ACN>STOP  do { 
		set ACN = rs.getCol("ACN")
		set BOO = rs.getCol("BOO")
		
		if MYQRY'="ALL" set KEEP=1 do { quit:'KEEP
			type Number I
			set I=""
			for  set I=A(3,I).order() quit:I=""  if 'A(3,I) set KEEP=0
			}
		else  set KEEP=0
		
		if 'RPTALL do Db.fastDelete("NR4EINF","ACN=:ACN")
		
		kill DATA		// Reset the DATA array for each membership

		type ResultSet rs1=Db.select("CID,POI","RELCIF","ACN=:ACN")
		while rs1.next() do {
			if 'rs1.getCol("POI") quit
			set CID=rs1.getCol("CID")
			do EXEC
			}
		do SET
		}
	
	
	/* Before ending, file the summary totals to be used by the NR4 Currency
	 Code Summary Report.*/
	
	set CRCD=""
	for  set CRCD=CRCDS(CRCD).order() quit:CRCD.isNull()  do {
	  	type RecordNR4SUM nr4sum = Class.new("RecordNR4SUM")
	  	set nr4sum.pid = %ProcessID
	  	set nr4sum.crcd = CRCD
	  	set nr4sum.cnt = ACNCNT.get()
	  	set nr4sum.totgi = TOTGI(CRCD).get()
	  	set nr4sum.totis = TOTIS(CRCD).get()
	  	set nr4sum.totnr = TOTNR(CRCD).get()
	  	set nr4sum.nrgi = NRGI(CRCD).get()
	  	set nr4sum.nrntw = NRNTW(CRCD).get()
	  	set nr4sum.frmcnt = FN
	  	do nr4sum.bypassSave()
	  	}

	set BOO=""
	for  set BOO=BOOS(BOO).order() quit:BOO.isNull()  do {
		type RecordTMPRPT2 tmprpt2 = Class.new("RecordTMPRPT2")
		set tmprpt2.pid = %ProcessID
		set tmprpt2.key1 = KEY1
		set tmprpt2.key2 = BOO
		set tmprpt2.data = TOTBI(BOO).get()_"|"_+TOTBW(BOO).get()
		do tmprpt2.bypassSave()
		}
	quit
	
EXEC	// Process an account
	
	/* Reset the exchange rate valid/nonreportable flag for the current 
	 account and the negative Gross Income flag. */
	 
	type public String CRCD,DCRCD
	type public Number CID,NEGAMT,NONREP
	type Number FWA,GI,INCCD,ITRO,RTE,NTW,NEGIPO,NRPPY,NRPOSIPY,NRNEGIPY,NRINTPY
	
	set (NEGAMT,NONREP)=""
	type RecordACN acn=Db.getRecord("ACN","CID=:CID")
	// Make sure this is a deposit account
	if acn.cls'="D" quit
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	if dep.ira quit
		
	/* The following function checks to see if reportable information exits
	 for the current account.  But we must report all individual accounts */
	
	if '$$REPRTABLE(.dep) quit
	
	// Retrieve the currency code for the current account.

	set CRCD = acn.crcd
	if CRCD="" set CRCD=DCRCD

	/* If the account's currency code is different from the default currency
	 code, convert the foriegn currency to Canadian dollars. */
	
	if CRCD'=DCRCD do EXCH(.RTE,.NONREP)
		
	// Calculate gross income

	set (INCCD,GI)=0
	set ITRO=dep.itro
	set NEGIPO = dep.negipo
	set NRPPY = dep.nrppy			// NR penalty pr tax yr
	set NRPOSIPY = dep.nrposipy		// NR pos int pr tax yr
	set NRNEGIPY = dep.nrnegipy		// NR neg int pr tax yr
	set NRINTPY=NRPOSIPY-NRNEGIPY
	
	// Calculate interest paid gross income on Non-RPA Accounts.

	if CRCD = DCRCD set INCCD=15		// int paid in Canadian
	else  set INCCD=18			// int paid in foreign
	set GI=NRPOSIPY				// NR pos int paid pr tax yr
	if ITRO,NEGIPO set GI=NRINTPY-NRPPY	// net_int - penalty
	if 'ITRO,NEGIPO set GI=NRPOSIPY-NRPPY	// pos_int - penalty
	if 'ITRO,'NEGIPO set GI=NRPOSIPY-NRPPY	// pos_int - penalty
	
	// Set INCCD and GI in local array.

	do SETGI

	//  Calculate income subject to withholding

	set FWA=+dep.nrwapty			// NR pr tax yr int w/h against

	// Set INCCD and FWA in local array.

	do SETFWA
	set NTW=+dep.nrwhpty 		// NR pr tax yr int w/h

	// Set INCCD and NTW in local array.

	do SETNTW
	quit
	
	
SET	// set data into TMP file
	
	type Number CID,CNT,CRCD,INCCD,TGIC,VLDAMT
	type public Number ACN,ACNCNT,BOO,FN
	type public String DATA()
	
	//if 'DATA(INCCD).exists() quit
	if 'DATA("").order() quit
	set VLDAMT=$$VLDAMT(.DATA())
	
	/* Keep a running total of the number of slips/memberships which have
	 been filed. The number of forms will be the same as the mem count
	 since there can only be 2 income codes / membership and 1 form
	 handles 2 income codes. */
	
	if VLDAMT set ACNCNT=ACNCNT.get()+1,FN=FN+1
	
	set (INCCD,CRCD,CID,TGIC)="",CNT=0
	
	for  set INCCD=DATA(INCCD).order() quit:INCCD=""  do {
		for  set CRCD=DATA(INCCD,CRCD).order() quit:CRCD=""  do {
			for  set CID=DATA(INCCD,CRCD,CID).order() quit:CID=""  do {
				type String NRPT
	      			set NRPT=DATA(INCCD,CRCD,CID).piece("|",10)
	      			if 'VLDAMT,'NRPT quit
	      			
	      			type RecordNR4EINF nr4einf = Class.new("RecordNR4EINF")
	      			set nr4einf.CRDATE = %CurrentDate_","_%CurrentTime
				set nr4einf.RUNDATE = %CurrentDate_","_%CurrentTime
				set nr4einf.UPDCNT = 1
	      			set nr4einf.boo = BOO
	      			set nr4einf.cid = CID
	      			set nr4einf.acn = ACN
	      			set nr4einf.inccd = INCCD
	      			set nr4einf.gi = DATA(INCCD,CRCD,CID).piece("|",3)
	      			set nr4einf.gic = DATA(INCCD,CRCD,CID).piece("|",4)
	      			set nr4einf.ntw = DATA(INCCD,CRCD,CID).piece("|",5)
	      			set nr4einf.fwa = DATA(INCCD,CRCD,CID).piece("|",6)
	      			set nr4einf.crcd = CRCD
	      			set nr4einf.cntw = DATA(INCCD,CRCD,CID).piece("|",8)
	      			set nr4einf.cfwa = DATA(INCCD,CRCD,CID).piece("|",9)
	      			set nr4einf.nri = DATA(INCCD,CRCD,CID).piece("|",10)
	      			set nr4einf.negamt = DATA(INCCD,CRCD,CID).piece("|",11)
	      			do nr4einf.bypassSave()
	      			do NR4ETOT
				}
			}
		}
	quit

NR4ETOT	
	/* Keep totals by currency code and B00 for the Currency Code 
	 Summary Report (REP441) and the Branch Summary rpt (YER442) */

	type public Number BOO,CID,CNTW,CFWA,GIC,GI,INCCD,NTW,NRPT
	type public String BOOS(),CRCD,DATA(),CRCDS()
	type public String NRGI(),NRNTW(),TOTGI(),TOTIS(),TOTNR(),TOTBI(),TOTBW()
	
	set CRCD=DATA(INCCD,CRCD,CID).piece("|",7)
	set CRCDS(CRCD)=""

	if 'NRPT do {
		set BOOS(BOO)=""
	  	set GIC=DATA(INCCD,CRCD,CID).piece("|",4)
	  	set GIC=GIC.roundDec()
	  	set CNTW=DATA(INCCD,CRCD,CID).piece("|",8)
	  	set CNTW=CNTW.roundDec()
	  	set CFWA=DATA(INCCD,CRCD,CID).piece("|",9)
	  	set CFWA=CFWA.roundDec()
	  	set TOTGI(CRCD)=TOTGI(CRCD).get()+GIC
	  	set TOTIS(CRCD)=TOTIS(CRCD).get()+CFWA
	  	set TOTNR(CRCD)=TOTNR(CRCD).get()+CNTW
	  	set TOTBI(BOO)=TOTBI(BOO).get()+GIC
	  	set TOTBW(BOO)=TOTBW(BOO).get()+CNTW
	  	}
	else  do {
	  	set GI=DATA(INCCD,CRCD,CID).piece("|",3)
	  	set GI=GI.roundDec()
	  	set NTW=DATA(INCCD,CRCD,CID).piece("|",5)
	  	set NTW=NTW.roundDec()
	  	if GI<0 set GI=0
	  	set NRGI(CRCD)=NRGI(CRCD).get()+GI.roundDec()
	  	set GIC=GIC.roundDec()
	  	set NRNTW(CRCD)=NRNTW(CRCD).get()+NTW.roundDec()
	  	set GIC=GIC.roundDec()
		}
	
	quit


VLDAMT(DATA)	// Make sure Total Gross Canadian Income is >=NR4 reportable amt

	type public Number INCCD,CRCD,CID,TGIC,REPORT,RAMT
	
	set REPORT=1
	set (INCCD,CRCD,CID,TGIC)=""
	for  set INCCD=DATA(INCCD).order() quit:INCCD=""  do {
	  	for  set CRCD=DATA(INCCD,CRCD).order() quit:CRCD=""  do {
	    		for  set CID=DATA(INCCD,CRCD,CID).order() quit:CID=""  do {
	    			set TGIC=TGIC+DATA(INCCD,CRCD,CID).piece("|",4)
	    			}
	  		}
		}
	
	/* Check the total gross income against the minimum value.
	 This will also file accounts under this membership
	 which are not reportable. */
	 
	if TGIC<RAMT set REPORT=0
	
	quit REPORT
	
REPRTABLE(RecordDEP dep)	// Is there reportable information? 


	/* For non-RPA account types, check to see if the non-resident interest 
	 prior tax year or nonresident int W/H against prior tax year or 
	 nonresident int W/H prior tax year is greater than zero. */
	
	if (+dep.nrposipty '= 0) quit 1             // [DEP]NRPOSIPTY
	if (+dep.nrwapty '= 0) quit 1             // [DEP]NRWAPTY
	if (+dep.nrwhpy '= 0) quit 1            // [DEP]NRWHPTY
	
	quit 0			// No reportable information was found

SETGI	//  Set the Gross Income into local array
	
	type public Number ACN,CID,INCCD,GI,GIC,CRCD,NONREP,NEGAMT,RTE
	type public String DATA(),DCRCD
	set GIC=""

	/* If the Gross Income is negative, then set the NEGAMT flag and the
	 NONREP flag. */
	
	if GI<0 set (NEGAMT,NONREP)=1

	set DATA(INCCD,CRCD,CID).piece("|",1)=ACN
	set DATA(INCCD,CRCD,CID).piece("|",2)=INCCD
	set DATA(INCCD,CRCD,CID).piece("|",3)=GI.get()
	set DATA(INCCD,CRCD,CID).piece("|",7)=CRCD
	set DATA(INCCD,CRCD,CID).piece("|",10)=NONREP
	set DATA(INCCD,CRCD,CID).piece("|",11)=NEGAMT
	
	// Determine Canadian Gross Income
	
	if 'NONREP,CRCD'=DCRCD set GIC=GI*RTE
	if 'NONREP,CRCD=DCRCD set GIC=GI
	if GIC'="" set GIC=GIC.roundDec(2)
	
	// GIC is only set for reportable accounts
	set DATA(INCCD,CRCD,CID).piece("|",4)=GIC.get()
	quit

SETFWA	// Set the income subject to withholding into local array
	
	type public Number ACN,CID,CFWA,FWA,INCCD,NONREP,RTE
	type public String CRCD,DATA(),DCRCD
	
	set CFWA=""
	
	set DATA(INCCD,CRCD,CID).piece("|",1)=ACN
	set DATA(INCCD,CRCD,CID).piece("|",2)=INCCD
	set DATA(INCCD,CRCD,CID).piece("|",6)=FWA
	set DATA(INCCD,CRCD,CID).piece("|",7)=CRCD
	set DATA(INCCD,CRCD,CID).piece("|",10)=NONREP
	
	// Determine Canadian Income Subject to Withholding
	if 'NONREP,CRCD'=DCRCD set CFWA=FWA*RTE
	if 'NONREP,CRCD=DCRCD set CFWA=FWA
	if CFWA'="" set CFWA=CFWA.roundDec(2)
	
	/* only 1 pass should be made at the CID level, so there should be
	 no reason to accumulate pc 9 */
	 
	set DATA(INCCD,CRCD,CID).piece("|",9)=CFWA.get()
	
	quit

SETNTW	// Set The Nonresident Tax Withheld into local array
	// set piece 5 and 8 in Data array

	type public Number ACN,CID,CNTW,INCCD,NONREP,NTW,RTE
	type public String DATA(),CRCD,DCRCD

	set CNTW=""

	set DATA(INCCD,CRCD,CID).piece("|",1)=ACN
	set DATA(INCCD,CRCD,CID).piece("|",2)=INCCD
	/* only 1 pass should be made at the CID level, so there should be
	 no reason to accumulate pc 5 */
	set DATA(INCCD,CRCD,CID).piece("|",5)=NTW.get()
	set DATA(INCCD,CRCD,CID).piece("|",7)=CRCD
	set DATA(INCCD,CRCD,CID).piece("|",10)=NONREP

	// Determine Canadian Nonresident Tax Withheld
	if 'NONREP,CRCD'=DCRCD set CNTW=NTW*RTE
	if 'NONREP,CRCD=DCRCD set CNTW=NTW
	if CNTW'="" set CNTW=$$^SCARND(CNTW,"","","",2)

	/* only 1 pass should be made at the CID level, so there should be
	 no reason to accumulate pc 8 */
	set DATA(INCCD,CRCD,CID).piece("|",8)=CNTW.get()
	quit
	
NR4D	// Build NR4DINF Table for NR4-Distributions

	type public Number BOO,RPTALL,RAMT,FRMSEQ
	type String CRCDS(),NRGI(),TOTGI(),TOTIS(),TOTNR(),NRNTW(),TOTBI(),TOTBW()
	type public String CRCD,DCRCD,BOOS(),KEY1,MYQRY,YEAR
	type Number MEMCNT
	
	set KEY1="NR4D"
	set YEAR=$$YEAR^SCADAT(%SystemDate)-1
	do Db.fastDelete("TMPRPT0","PID=:%ProcessID")
	
	if MYQRY="ALL" set RPTALL=1
	else  set RPTALL = 0
		
	 
	// Retrieve the Default Currency Code and Minimum Report Amt 
	do CRCD^TTXSUM 
	set RAMT=CUVAR.NR4BRAMT
	
	// Form Sequence Number 
	set (FRMSEQ,MEMCNT)=0
	 
	do NR4D1 
	 
	// File total arrays to ^TMP global for NR4SUM and NR4TOT 
	for  set CRCD=CRCDS(CRCD).order() quit:CRCD.isNull()  do {
	  	type RecordNR4SUM nr4sum = Class.new("RecordNR4SUM")
	  	set nr4sum.pid = %ProcessID
	  	set nr4sum.crcd = CRCD
	  	set nr4sum.cnt = FRMSEQ.get()
	  	set nr4sum.totgi = TOTGI(CRCD).get()
	  	set nr4sum.totis = TOTIS(CRCD).get()
	  	set nr4sum.totnr = TOTNR(CRCD).get()
	  	set nr4sum.nrgi = NRGI(CRCD).get()
	  	set nr4sum.nrntw = NRNTW(CRCD).get()
	  	set nr4sum.frmcnt = MEMCNT.get()
	  	do nr4sum.bypassSave()
	  	}

	for  set BOO=BOOS(BOO).order() quit:BOO.isNull()  do {
		type RecordTMPRPT2 tmprpt2 = Class.new("RecordTMPRPT2")
		set tmprpt2.pid = %ProcessID
		set tmprpt2.key1 = KEY1
		set tmprpt2.key2 = BOO
		set tmprpt2.data = TOTBI(BOO).get()_"|"_+TOTBW(BOO).get()
		do tmprpt2.bypassSave()
		}
		
	quit
	
NR4D1	
	
	type public Number ACNRPT,ACN,BOO,RPTALL,RPASEQ,RAMT,MEMCNT,START,STOP,TOT
	type public String A(,),MYQRY
	type String IRA()
	type Number KEEP
	
	set ACN=START
	
	type ResultSet rs
	if ACN.isNull() set rs=Db.select("DISTINCT ACN,RPASEQ","IRATYPE")
	else  set rs=Db.select("DISTINCT ACN,RPASEQ","IRATYPE","ACN>:START AND (ACN<:STOP or ACN=:STOP)","ACN")
	
	while rs.next() do {
 		set ACN=rs.getCol("ACN")
 		if MYQRY'="ALL" set KEEP=1 do {  Q:'KEEP	// Check ACN query
	 		type Number I
 			set I=""
		 	for  set I=A(3,I).order() quit:I=""  if 'A(3,I) set KEEP=0
 			}
 		else  set KEEP=0 quit
		
		if 'RPTALL do Db.fastDelete("NR4EINF","ACN=:ACN")
		
		set RPASEQ=rs.getCol("RPASEQ")
		do NR4D2
		
		// Check to see if total distributions are > reportable amt
		set ACNRPT=0
		set BOO=""
		for  set BOO=$O(IRA("TOT",BOO)) quit:BOO=""  do {
			// if pc3 is set, then brn has keepable non-reportable plans
			if IRA("TOT",BOO).piece("|",3) do NR4DEXEC quit
			set TOT=IRA("TOT",BOO).piece("|",1)
			if TOT'<RAMT do NR4DEXEC
			}
		if ACNRPT set MEMCNT=MEMCNT+1
	}
	
	quit
	 
NR4D2	// Modified to improve run time efficiency

	type public Number ACN,BOO,IRA,REPORT,RPASEQ,PLAN,PLNTOT,NEGAMT
	type Boolean YEFLG
	type Number I
	type public String A(,,),CRCD,CID,DCRCD,RSPREC,RM
	
	type String CRCDCID,DI
	
	set (IRA,PLAN,CID)="",REPORT=1
	
	set DI="PLANID,LIMIT,IRACON,IRADIS,AUTFRE,AUTDND,AUTDLD,AUTAMT,AUTOPT,AUTNOT,IRAAUT,DISMTC,DISCID"
	set DI=DI_",NAME1,NAME2,AD1,AD2,AD3,CITY,STATE,MZIP,WTHAMT,WTHPCT,ANTCHK,CNTRY,BEN,TAXIND,IRABEN"
	set DI=DI_",RSPWIND,RSPWSCH,GRPNO,MADAGE,RSPMADO,MADSDOB,RSPMADB,AUTUPD,MADSAT,YEFLG,SPOUSEID,PLDTE"
	set DI=DI_",PLCDTE,IRATYP,RSPWCALC,PLANMAN,MADPCT,LIFPCT,LIFJUR,LOCK,MINPAY,MAXPAY,IRAIPO,RPMAD1,RPMAD2"
	set DI=DI_",RPMAD3,RPCITY,RPCNTRY,RPSTATE,RPZIP,RPHPH,RPBPH,RPEMAIL,DECNUM,DECNAM,DECTAXID,DECSEQ"
	set DI=DI_",DECPLNID,MF,PTC,BTC,JTC,EMPLRCIF,CONDIST,RFLG,LIMITPY,STWHCALC,STWHSCH,STWHAMT,STWHPCT,STPLNID"
	
	type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN",1) 
	set BOO=cif.boo
	
	type ResultSet rs2=Db.select(DI,"IRATYPE","ACN=:ACN and RPASEQ=:RPASEQ")
	if rs2.isEmpty() do { quit 
		set RM="Income not rpted - CIF#"_ACN_",RPASEQ#"_RPASEQ_", has no accts."
		do EXC
		}
	while rs2.next() do {
		set RSPREC=rs2.getRow("|")
		set YEFLG=$P(RSPREC,"|",38)       // Set the year end flag. 	
		if 'YEFLG quit
		set IRA=rs2.getCol("IRATYP")
		set IRA(BOO,RPASEQ)=RSPREC
		}
	
	type ResultSet rs3=Db.select("CID","DEP","ACN=:ACN AND RPASEQ=:RPASEQ AND IRA>0","CID")
	if rs3.isEmpty() quit
	if rs3.next() set CID=rs3.getCol("CID")
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
	set CRCD=dep.crcd
	
	
	if BOO="" do { quit 
		set RM="Branch of Ownership unknown" do EXC
		}
	
	set DI="NRD1,NRD2,NRD3,NRD4,NRD5,NRD6,NRD7,NRD8,NRD10,NRD12,NRD13,NRD14,NRD15,NRD16,NRD17,NRD18"
	set DI=DI_",NRD19,NRD20,NRD21,NRD22,NRD23,NRD24,NRD25,NRD26,NRD27,NRMADCY,NRD45"
	type ResultSet rs4=Db.select(DI,"IRA","ACN=:ACN AND RPASEQ=:RPASEQ and TAXYR=:YEAR")
	if rs4.next() set IRA(BOO,RPASEQ,13)=(rs4.getRow().toString()).translate($C(9),"|")
	
	set DI="NRW1,NRW2,NRW3,NRW4,NRW5,NRW6,NRW8,NRW9,NRW10,NRW12,NRW13,NRW14,NRW15,NRW16,NRW17,NRW18"
	set DI=DI_",NRW19,NRW20,NRW21,NRW22,NRW23,NRW24,NRW25,NRW26,NRW27,NRW45"
	type ResultSet rs5=Db.select(DI,"IRA","ACN=:ACN AND RPASEQ=:RPASEQ and TAXYR=:YEAR")
	if rs5.next() set IRA(BOO,RPASEQ,14)=(rs5.getRow().toString()).translate($C(9),"|")
	
	set DI="NRWA1,NRWA2,NRWA3,NRWA4,NRWA5,NRWA6,NRWA8,NRWA9,NRWA10,NRWA12,NRWA13,NRWA14,NRWA15,NRWA16"
	set DI=DI_",NRWA17,NRWA18,NRWA19,NRWA20,NRWA21,NRWA22,NRWA23,NRWA24,NRWA25,NRWA26,NRWA27,NRWA45"
	type ResultSet rs6=Db.select(DI,"IRA","ACN=:ACN AND RPASEQ=:RPASEQ and TAXYR=:YEAR")
	if rs6.next() set IRA(BOO,RPASEQ,15)=(rs6.getRow().toString()).translate($C(9),"|")
	 
	// Total up all distr and w/h and see if plan is keepable. PLNTOT 
	// Also accums into IRA("TOT",BOO), pc1=dist, pc2=w/h 
	set NEGAMT=0 
	for I=1,6,10,15,26,27 do {
		do ACCUM(1,13,I) // Accumulate in Bucket 1 total for ND=13 PC=I
		do ACCUM(2,14,I) // Accumulate in Bucket 2 total for ND=14 PC=I
		}
		
	// Added Self-Directed Plans below gfm 04/06/98
	if IRA=5!(IRA=8) for I=18,19,22,23 do {		// get RSP only fields also for RSP 
		do ACCUM(1,13,I) // Accumulate in Bucket 1 total for ND=13 PC=I
		do ACCUM(2,14,I) // Accumulate in Bucket 2 total for ND=14 PC=I
		}
		
	// If plan had no NR distribtutions then ignore it. 
	if +PLNTOT=0 kill IRA(BOO,RPASEQ) quit
	 
	set IRA(BOO,RPASEQ).piece("|",56,57)=BOO_"|1|0" 
	if CRCD'=DCRCD set REPORT=0 
	set IRA(BOO,RPASEQ).piece("|",55)=CRCD 
	// If plan is non-reportable then flag plan and keep for detail report 
	if REPORT=0 do { quit
		set IRA(BOO,RPASEQ).piece("|",57)=0
		if NEGAMT set IRA(BOO,RPASEQ).piece("|",58)=1
		set IRA("TOT",BOO).piece("|",3)=1
		}
	set (CID,CRCDCID,CRCD)="" 
	// Collate thru lower levels of XRSPPLID to verify CRCD
	type ResultSet rs7=Db.select("CRCD","DEP","ACN=:ACN AND RPASEQ=:RPASEQ AND IRA>0","CID")
	while rs7.next() do { 
		set CRCDCID=rs7.getCol("CRCD")
		if CRCDCID="" set CRCDCID=DCRCD 
		// save CRCD in RPASEQ of IRA 
		if CRCD="" set CRCD=CRCDCID,IRA(BOO,RPASEQ).piece("|",55)=CRCD 
		if CRCDCID'=CRCD do {
			set RM="Multiple CRCD for CIF="_ACN_" RPASEQ="_RPASEQ
			do EXC
			}
		if CRCDCID'=DCRCD do {
			set IRA(BOO,RPASEQ).piece("|",57)=0
			set IRA("TOT",BOO).piece("|",3)=1
			}
		}
	quit 

ACCUM(Number PC1,Number ND,Number PC2)	//
	// Accumulate totals into PC1 for Node=ND and Piece=PC2 
	type Number PC
	type public String IRA()
	type public Number BOO,NEGAMT,RPASEQ,PLNTOT,REPORT
	set PC=IRA(BOO,RPASEQ,ND).piece("|",PC2) 
	if PC<0 set PC=0,REPORT=0,NEGAMT=1 
	set IRA("TOT",BOO).piece("|",PC1)=(IRA("TOT",BOO).get()).piece("|",PC1)+PC 
	set PLNTOT=PLNTOT.get()+PC 
	
	quit
	
NR4DEXEC	//
	// Calculate RRSP/RIF distributions gross income. 
	type public Number ACN,ACNRPT,CID,BOO,FRMSEQ,RPASEQ,REPORT,NEGAMT
	type public String IRA(,,),MYQRY,NR4DINF()
	type Number C,I
	set REPORT=1,NEGAMT="",RPASEQ="" 
	for  set RPASEQ=IRA(BOO,RPASEQ).order() quit:RPASEQ=""!(RPASEQ="TOT")  do { quit:'REPORT 
		if 'IRA(BOO,RPASEQ).piece("|",57) set REPORT=0
		if IRA(BOO,RPASEQ).piece("|",58) set NEGAMT=1,REPORT=0
		}
	if REPORT set ACNRPT=1     // This will allow member count to bumped by 1 
	// since at least 1 plan gets a form. 
	 
	set (RPASEQ,NR4DINF)="" 
	for  set RPASEQ=IRA(BOO,RPASEQ).order() quit:RPASEQ=""!(RPASEQ="TOT")  do { 
		set NR4DINF(RPASEQ)=""
		set NR4DINF(RPASEQ).piece("|",17)=IRA(BOO,RPASEQ).piece("|",1)
		set NR4DINF(RPASEQ).piece("|",18)=NEGAMT
		set IRA=IRA(BOO,RPASEQ).piece("|",42)               // [IRATYPE]IRATYP
		do NR4DTOT(REPORT,.IRA,RPASEQ)
		// Added Self-Directed Plans below gfm 04/06/98
		if REPORT,IRA=5!(IRA=8) do {
			// Distributions
			do ROLL(1,13,10)
			do ROLL(2,13,26)
			for I=18,19,22,23 do ROLL(3,13,I)
			for I=1,15 do ROLL(4,13,I)
			for I=6,27 do ROLL(5,13,I)
			// Withholding
			do ROLL(8,14,10)
			do ROLL(9,14,26)
			for I=18,19,22,23 do ROLL(10,14,I)
			for I=1,15 D ROLL(11,14,I)
			for I=6,27 D ROLL(12,14,I)
			}
		// Added Self-Directed Plans below gfm 04/06/98
		if REPORT,(IRA=6)!(IRA=7)!(IRA=9) do {
			// Distributions
			do ROLL(6,13,10)
			for I=1,6,15,26,27 do ROLL(7,13,I)
			// Withholding
			do ROLL(13,14,10)
			for I=1,6,15,26,27 do ROLL(14,14,I)
			}
		// Added Self-Directed Plans below gfm 04/06/98
		if 'REPORT,IRA=5!(IRA=8) do {
			for I=1,6,10,15,18,19,22,23,26,27 do ROLL(15,13,I)
			for I=1,6,10,15,18,19,22,23,26,27 do ROLL(16,14,I)
			}
		// Added Self-Directed Plans below gfm 04/06/98
		if 'REPORT,(IRA=6)!(IRA=7)!(IRA=9) do {
			for I=1,6,10,15,26,27 do ROLL(15,13,I)
			for I=1,6,10,15,26,27 do ROLL(16,14,I)
		}
		
		
	if MYQRY="ALL" do {
		do Db.fastDelete("NR4DINF")
		type RecordNR4DINF nr4dinf = Class.new("RecordNR4DINF")
		set nr4dinf.CRDATE = %CurrentDate_","_%CurrentTime
		set nr4dinf.RUNDATE = %CurrentDate_","_%CurrentTime
		set nr4dinf.UPDCNT = 1
		set nr4dinf.boo = BOO
		set nr4dinf.acn = ACN
		set nr4dinf.rpaseq = RPASEQ
		set nr4dinf.rspap = NR4DINF(RPASEQ).piece("|",1)
		set nr4dinf.rsprp = NR4DINF(RPASEQ).piece("|",2)
		set nr4dinf.rspea = NR4DINF(RPASEQ).piece("|",3)
		set nr4dinf.rspwp = NR4DINF(RPASEQ).piece("|",4)
		set nr4dinf.rspdp = NR4DINF(RPASEQ).piece("|",5)
		set nr4dinf.rifpp = NR4DINF(RPASEQ).piece("|",6)
		set nr4dinf.rifls = NR4DINF(RPASEQ).piece("|",7)
		set nr4dinf.rspapw = NR4DINF(RPASEQ).piece("|",8)
		set nr4dinf.rsprpw = NR4DINF(RPASEQ).piece("|",9)
		set nr4dinf.rspeaw = NR4DINF(RPASEQ).piece("|",10)
		set nr4dinf.rspwpw = NR4DINF(RPASEQ).piece("|",11)
		set nr4dinf.rspdpw = NR4DINF(RPASEQ).piece("|",12)
		set nr4dinf.rifppw = NR4DINF(RPASEQ).piece("|",13)
		set nr4dinf.riflsw = NR4DINF(RPASEQ).piece("|",14)
		set nr4dinf.nrd = NR4DINF(RPASEQ).piece("|",15)
		set nr4dinf.nrdw = NR4DINF(RPASEQ).piece("|",16)
		set nr4dinf.planid = NR4DINF(RPASEQ).piece("|",17)
		set nr4dinf.negamt = NR4DINF(RPASEQ).piece("|",18)
		do nr4dinf.bypassSave()
		}
	else  do {
		type RecordNR4DINF nr4dinf = Class.new("RecordNR4DINF")
		set nr4dinf.RUNDATE = %CurrentDate_","_%CurrentTime
		set nr4dinf.UPDCNT = nr4dinf.UPDCNT + 1
		set nr4dinf.boo = BOO
		set nr4dinf.acn = ACN
		set nr4dinf.rpaseq = RPASEQ
		set nr4dinf.rspap = NR4DINF(RPASEQ).piece("|",1)
		set nr4dinf.rsprp = NR4DINF(RPASEQ).piece("|",2)
		set nr4dinf.rspea = NR4DINF(RPASEQ).piece("|",3)
		set nr4dinf.rspwp = NR4DINF(RPASEQ).piece("|",4)
		set nr4dinf.rspdp = NR4DINF(RPASEQ).piece("|",5)
		set nr4dinf.rifpp = NR4DINF(RPASEQ).piece("|",6)
		set nr4dinf.rifls = NR4DINF(RPASEQ).piece("|",7)
		set nr4dinf.rspapw = NR4DINF(RPASEQ).piece("|",8)
		set nr4dinf.rsprpw = NR4DINF(RPASEQ).piece("|",9)
		set nr4dinf.rspeaw = NR4DINF(RPASEQ).piece("|",10)
		set nr4dinf.rspwpw = NR4DINF(RPASEQ).piece("|",11)
		set nr4dinf.rspdpw = NR4DINF(RPASEQ).piece("|",12)
		set nr4dinf.rifppw = NR4DINF(RPASEQ).piece("|",13)
		set nr4dinf.riflsw = NR4DINF(RPASEQ).piece("|",14)
		set nr4dinf.nrd = NR4DINF(RPASEQ).piece("|",15)
		set nr4dinf.nrdw = NR4DINF(RPASEQ).piece("|",16)
		set nr4dinf.planid = NR4DINF(RPASEQ).piece("|",17)
		set nr4dinf.negamt = NR4DINF(RPASEQ).piece("|",18)
		do nr4dinf.bypassSave()
		}
		
	}
		
	if 'REPORT quit
	// Bump FRMSEQ by # of forms produced 
	set C=0 
	if NR4DINF.piece("|",6)!NR4DINF.piece("|",13) S C=C+1 
	if NR4DINF.piece("|",7)!NR4DINF.piece("|",14) S C=C+1 
	if NR4DINF.piece("|",1)!NR4DINF.piece("|",8) S C=C+1 
	if NR4DINF.piece("|",2)!NR4DINF.piece("|",9) S C=C+1 
	if NR4DINF.piece("|",3)!NR4DINF.piece("|",10) S C=C+1 
	if NR4DINF.piece("|",4)!NR4DINF.piece("|",11) S C=C+1 
	if NR4DINF.piece("|",5)!NR4DINF.piece("|",12) S C=C+1 
	set C=(C+1)\2 
	if C<0 set C=0 
	set FRMSEQ=FRMSEQ+C 
	
	quit

NR4DTOT(Number REPORT,Number IRA,Number RPASEQ)	// accumulate totals for NR4SUM and NR4TOT files 
	type public String BOOS(),CRCDS(),CRCD
	type public Number BOO
	type Number I
	type public String NRGI(),NRNTW(),TOTGI(),TOTBI(),TOTNR(),TOTBW()
	
	set CRCD=IRA(BOO,RPASEQ).piece("|",55) 
	set CRCDS(CRCD)="" 
	set BOOS(BOO)="" 
	if REPORT do {
		for I=1,6,10,15,26,27 do {
			set TOTGI(CRCD)=TOTGI(CRCD).get()+$$POSPC(13,I)
			set TOTBI(BOO)=TOTBI(BOO).get()+$$POSPC(13,I)
			}
		// Added Self-Directed Plans below gfm 04/06/98
		if IRA=5!(IRA=8) for I=18,19,22,23 do {
			S TOTGI(CRCD)=$G(TOTGI(CRCD))+$$POSPC(13,I)
			S TOTBI(BOO)=$G(TOTBI(BOO))+$$POSPC(13,I)
			}
		for I=1,6,10,15,26,27 do {
			set TOTNR(CRCD)=TOTNR(CRCD).get()+$$POSPC(14,I)
			set TOTBW(BOO)=TOTBW(BOO).get()+$$POSPC(14,I)
			}
		// Added Self-Directed Plans below gfm 04/06/98
		if IRA=5!(IRA=8) for I=18,19,22,23 do {
			set TOTNR(CRCD)=TOTNR(CRCD).get()+$$POSPC(14,I)
			set TOTBW(BOO)=TOTBW(BOO).get()+$$POSPC(14,I)
			}
		}
	if 'REPORT do { 
		for I=1,6,10,15,26,27 do {
			set NRGI(CRCD)=NRGI(CRCD).get()+$$POSPC(13,I)
			}
		// Added Self-Directed Plans below gfm 04/06/98
		if IRA=5!(IRA=8) for I=18,19,22,23 do {
			S NRGI(CRCD)=NRGI(CRCD).get()+$$POSPC(13,I)
			}
		for I=1,6,10,15,26,27 do {
			set NRNTW(CRCD)=NRNTW(CRCD).get()+$$POSPC(14,I)
			}
		// Added Self-Directed Plans below gfm 04/06/98
		if IRA=5!(IRA=8) for I=18,19,22,23 do {
			set NRNTW(CRCD)=NRNTW(CRCD).get()+$$POSPC(14,I)
			}
		}
		
	quit

POSPC(Number ND,Number PC)	// return positive piece of given node and piece 

	type public String IRA()
	type public Number BOO,RPASEQ
	type Number X
	set X=IRA(BOO,RPASEQ,ND).piece("|",PC)
	if X<0 quit 0
	quit X

ROLL(Number P1,Number ND,Number P2)	// accum IRA(BOO,RPASEQ,ND)|PC2 in 
	//         NR4DINF|PC1 and NR4DINF(RPASEQ)|PC1 

	type Number X,X1,X2
	type public Number BOO,RPASEQ
	type public String IRA(),NR4DINF
	
	set X1=NR4DINF.piece("|",P1) 
	set X2=IRA(BOO,RPASEQ,ND).piece("|",P2) if X2<0 set X2=0 
	set X=X1+X2 if X=0 set X="" 
	set NR4DINF.piece("|",P1)=X 
	 
	set X1=NR4DINF(RPASEQ).piece("|",P1) 
	set X=X1+X2 if X=0 set X="" 
	set NR4DINF(RPASEQ).piece("|",P1)=X 
	
	quit 

EXCH(Number RTE,Number BAD)	//Return Yearend Currency Exchange Rate 
	/*---------------------------------------------------------------------- 
	 ARGUMENTS: 
	       . RTE   Yearend conv Rate       /TYP=N/REQ/MECH=REF:W 
	       . BAD   Set to 1 if RTE=""      /TYP=L/REQ/MECH=REF:W 
	 
	 INPUT: 
	       . CRCD  Curreny Code            /TYP=T/REQ/MECH=VAL 
	 
	 RETURNS: 
	       . RTE   Exchange Rate           /TYP=N 
	       . BAD   Set to 1 if RTE=""      /TYP=L 
	       . CO(CRCD) Exchange Rate Table  /TYP=A 
	 
	 EXAMPLE: 
	       D EXCH(.RTE,.NONREP) 
	*/ 
	// If this is not a valid exchange rate table, then set REP to 0 
	type public String CO,CRCD
	type Number EXCH
	set RTE="" 
	if 'CO.get() set CO=CUVAR.co
	if 'CO(CRCD).get() do {
		type RecordCRCD crcd=Db.getRecord("CRCD","CO=:CO,CRCD=:CRCD",1)
		set EXCH=crcd.exch
		}
	else  set EXCH=CO(CRCD).piece("|",53)
	
	if EXCH="" set BAD=1 quit
	 
	// Retrieve the actual exchange rate value. 
	set RTE=EXCH/100 
	
	quit 

EXC	// log error in exception file 
	type String DESC
	type public String ET,RM
	set DESC="NR4 Yearend Forms Extract|1",ET=RM.get()
	do EXC1
	quit
EXC1	
	type public Number %ZTSEQ,CID
	type public String DESC,ET,RM
	do LOG^UTLEXC($T(+0),"*",DESC,CID.get(),"",ET.get(),"") 

	kill ET,%ZTSEQ,RM 
	
	quit 
 #OPTION ResultClass ON
Public String vSIG()	quit "60477^65458^Pat Kelly^26687"	// Signature - LTD^TIME^USER^SIZE
