BCHSWIFT //Batch BCHSWIFT950 - Automatic Generation of Vostro Account S
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 12:47 - shetyes
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHSWIFT950 Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 set vBCHSTS=$$STATUS^BCHUTL("BCHSWIFT950")
 if vBCHSTS=1 set ER=1,RM=$$^MSG(3410) quit
 if vBCHSTS=2 set ER=1,RM=$$^MSG(3414) quit
 if vBCHSTS=0 set %BatchRestart=1
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit do EXIT^BCHUTL("BCHSWIFT950") quit
 do JOBMGR^BCHUTL(%FN,"BCHSWIFT950",.vINPUT)
 do ^JOBMGR(.vINPUT)
 do EXIT^BCHUTL("BCHSWIFT950")
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(CID) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHSWIFT950","*","",CID.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 if %BatchRestart,$$CHKLOG^BCHUTL(%SystemDate,%FN,"BCHSWIFT950",CID.get()) do { quit
 do LOG^BCHUTL(%SystemDate,%FN,"BCHSWIFT950",CID.get(),"Record already processed")
 }
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,CID)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHSWIFT950","*","",CID.get(),"",et)
 }
 do UPDLOG^BCHUTL(%SystemDate,%FN,"BCHSWIFT950",CID.get(),vCONTEXT)
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,CID) //
	/*	
	  This subroutine will scan the account's history for transactions
	  which have been posted during the last statement period.  This is
	  a nightly process so the last statement period should only be today.
	  If there is no activity in DTJ today, then check the last statement
	  date.  If there has not been a statement in the last month, then 
	  generate one and queue it in the Ready To Transmit (RTT) SWIFT
	  getaway queue.
	*/

	new RM,%ZTSEQ,%ZTHANG
	new CONV60,CONV62,CONV64,H,OSTMT,NSTMT,PAGE,PG,SEQ,DUP

	set SWSEQ=1
	set (AMT62,AMT60,TOTAL,QUIT)=0,(DC,ITC,NJD,AMTALL,nxdate)=""
	kill HIST,DEP,UX,SW61
	
        type RecordDEP dep=Db.getRecord("DEP","CID")

	new XTJD	

	set SWDIRECT="OUT"
	set MSG=950
	set TRREFNO=$$950^TRREFNO()

	type RecordSWIFT fswift=Class.new("RecordSWIFT")
	set fswift.swdirect=SWDIRECT
	set fswift.msg=MSG
	set fswift.trrefno=TRREFNO
	set fswift.status=0				// Status - "RTT"
	set fswift.date=%SystemDate			// Response Date
	set fswift.swftdt=%SystemDate			// Message Transfer Date
	set XTJD=%SystemDate
	
	// Closed acct w/no finc.trans
	
	type Number XCID
	set XCID=""
	type ResultSet rs = Db.select("CID","DTJ","TJD =:XTJD and CID>:CID")
	if rs.next() set XCID = rs.getCol(1) 
	if dep.stat=4,XCID="" quit

	/*   
	  Initialize beginning balance to zero if there are 
	  no financial trans for previous day
	*/

 	set BEGBAL=0,DC="C"				
        set DTE=$$DATE^SWIFTCDI(%SystemDate,"YYMMDD")
        set CRCD=dep.crcd                       	// Currency Code

	set CONV60=$$AMTCNV^SWIFTCDI(.dep,.BEGBAL,CRCD) 
        
	set fswift.obal=DC_DTE_CRCD_CONV60  // Statement Opening Ledger Balance	
	
	new hist
 	type RecordHIST hist()

	set PAGE=0,PG=1
	do BUILD(.dep,.fswift,.hist())
	
        /*
	  No statement is required if there was no activity today and
          the last statement date was within 30 days ago
	  K SWARR61
	*/

	set nxdate=dep.vosnsdt                  //  Next MT950 Statement Date

	set JD=%SystemDate
        set FRE=dep.vosfreq                 // MT950 Account Statment Frequency
        set VOSSTMT=dep.vosstmt                 // MT950 Ad Hoc Statement Flag
	
        if nxdate=%SystemDate,FRE'="" do {
		set NJD=$$NJD^UFRE(JD,FRE) if ER quit
		set dep.vosnsdt=NJD		  // Next MT950 Statement Date
		set dep.vosdate=%SystemDate       // Last MT950 Statement Date	
		} 
	       
	if TOTAL'>1,nxdate'=%SystemDate,'VOSSTMT quit 
	
	new cuvar
	type RecordCUVAR cuvar
	set cuvar=Db.getRecord("CUVAR")

	set fswift.sndr=cuvar.swiftadd	 		// SWIFT Address

	set ACN=dep.acn					// Customer Number
	
	new cif
	type RecordCIF cif
	set cif=Db.getRecord("CIF","ACN")


	/*
        Set the receiver MT950 address defined on the account record.
        If it is not defined, use the MT950 address defined in the customer's
        record. If neither of those are defined, use cif.swiftadd.
        */
	if dep.mt950a'="" set rcvr=dep.mt950a
        else  if cif.mt950a'="" set rcvr=cif.mt950a
        else  set rcvr=cif.swiftadd
        // SWIFT Address must be defined.
        if $G(rcvr)="" set ER=1,RM=$$^MSG(4029) quit ER	

	set fswift.rcvr=rcvr                        // Receiver

	set fswift.priority="N"			    // Priority - (Normal)
	
  	// Format transactions into field 61.
	set SEQ=""
	for  set SEQ=$O(H(SEQ)) quit:SEQ=""  do 61(.dep,.hist())
	
	do SORT		    // Sort all transactions into ascending dr/cr order 
	do OPTION(.fswift)           // Set opening and closing balance options
        do SET(.fswift)                  	    // Set up array to be filed
        do MSG(.dep,.fswift)   // Complete formatting additional message fields
        do FILE(.dep,.fswift)   	       // File 950 into ^SWIFT and ^ACN
        quit


MAIN(RecordDEP dep,RecordSWIFT fswift)	
	new QUIT
	do PROCESS(.dep,.fswift)
	set QUIT=0
	if PAGE>1 while QUIT=0 do {

		do KSWIFT(.fswift)
		set I=I+1
		set fswift.obal=fswift.clbal
		set SWSEQ=SWSEQ+1
		set PG=PG+1
		set AMT60=AMT62
		set AMT62=0
		if '((PG<PAGE)!(PG=PAGE)) set QUIT=1 quit
		do PROCESS(.dep,.fswift)
		}
	quit


PROCESS(RecordDEP dep,RecordSWIFT fswift)


	do OPTION(.fswift)	     // Set opening and closing balance options
	do SET(.fswift)				    // Set up array to be filed
	do MSG(.dep,.fswift)   // Complete formatting additional message fields
 	do FILE(.dep,.fswift)		       // File 950 into ^SWIFT and ^ACN
	quit
	

61(RecordDEP dep,RecordHIST hist())	

	/*
  	  For financial transactions posted today, format field 61 of the
	  SWIFT message. Tag 61 consists of 9 subfields:
		
		1. transaction date (YYMMDD)			/LEN=6/REQ
		2. Entry date (MMDD)				/LEN=4/NOREQ
		3. Debit/Credit Indicator			/LEN=2/REQ
		4. Funds code (last char. of currency code)	/LEN=1/NOREQ
		5. Amount					/LEN=15/REQ
		6. Transaction Type Code			/LEN=4/REQ
		7. Ref for account owner			/LEN=16/REQ
		8. Account servicing institution reference	/LEN=16/NOREQ
		9. Supplimental data				/LEN=34x/NOREQ
	
	  These subfields are fixed length and there are no delimiters
	  with the exception of the supplimental data.  A CR/LF  will be
	  inserted berfore subfield 9 (only if there is supplimental data)
	  and after each line of data. 
	*/
		
        new TAMT,VD,ED
	set TAMT=hist(SEQ).tamt		// Transaction Amount		
	set VD=hist(SEQ).efd            // Value Date
	set ED=hist(SEQ).tjd            // Entry Date

	if hist(SEQ).tjd<%SystemDate quit

	type RecordTTX ttx=hist(SEQ).copy()

	set DUP=0
	set VDT=$$DATE^SWIFTCDI(VD,"YYMMDD")  // IK - 34281
	set EDT=$$DATE^SWIFTCDI(ED,"MMDD")    // IK - 34281 
	set DCI=$$DC^SWIFTCDI(ttx.tso)
	set FCD=$$FCODE^SWIFTCDI(.dep,ttx.crcd)
	if TAMT["#" set TAMT=$P(TAMT,"#",2)
	set CRCD=hist(SEQ).crcd if CRCD="" set CRCD=dep.crcd
	set AMT=+TAMT
	set AMTT=$$AMTCNV^SWIFTCDI(.dep,.TAMT,CRCD)
	set TCD=$$TTYPE^SWIFTCDI(ttx.tso,ttx.etc)
	set RAW=$$REF^SWIFTCDI(ttx.tso,ttx.etc)
	set RAS=$$ASIR^SWIFTCDI() 
	set SUP=$$SUPP^SWIFTCDI(ttx.tso)

	if DCI["D" set ITC=0
       	if DCI'["D" set ITC=1
	set DUP=$O(SW61(ITC,%SystemDate,AMT,""),-1)+1
	if SUP='"" set SW61(ITC,%SystemDate,AMT,DUP)=VDT_EDT_DCI_FCD_AMTT_TCD_RAW_RAS_$C(11,13)_SUP
        if SUP="" set SW61(ITC,%SystemDate,AMT,DUP)=VDT_EDT_DCI_FCD_AMTT_TCD_RAW_RAS
	
	quit


BUILD(RecordDEP dep,RecordSWIFT fswift,RecordHIST hist())	
	
	/* 
	Build array collating backwards through history.
	*/

	new exe,Q,vsql,rs,cnt
	set cnt=0

        type ResultSet rs
	set rs=Db.select("TSEQ,TAMT","HIST","CID=:CID AND ETC IS NOT NULL AND ITC IS NOT NULL","TSEQ DESC")
	if rs.isEmpty() quit
 
	while rs.next() do {
        	set TAMT=rs.getCol(2)
        	if TAMT["#",$P(TAMT,"#",2)="" quit
        	set SEQ=rs.getCol(1)
        	set hist(SEQ)=Db.getRecord("HIST","CID,SEQ")
	        set H(SEQ)=""

		if hist(SEQ).tjd=%SystemDate set TOTAL=TOTAL+1  //IK - 34281
	
		if hist(SEQ).tjd<%SystemDate do { 
			set cnt=cnt+1 if cnt>1 quit             //IK - 34281
 	 		set DTE=$$DATE^SWIFTCDI(hist(SEQ).tjd,"YYMMDD") //IK
			set CRCD=hist(SEQ).crcd		
			if CRCD="" set CRCD=dep.crcd
			set BEGBAL=hist(SEQ).endbal // Balance after Transaction
			set AMT60=BEGBAL
        		if (BEGBAL>0)!(BEGBAL=0) set DC="C"
	                I BEGBAL<0 set DC="D",BEGBAL=(BEGBAL*-1)  
      	                set CONV60=$$AMTCNV^SWIFTCDI(.dep,.BEGBAL,CRCD)
			set fswift.obal=DC_DTE_CRCD_CONV60
			set QUIT=1 quit
			}
		}
	
	set PG=1					// Current page
	set PAGE=(TOTAL\LIMIT)+$S(TOTAL#LIMIT:1,1:0)  	// Total pages
	quit


SORT	
	/* 
	Sort all transactions into ascending DR/CR amount order
	*/

	new AMT,ITC,JD,SSEQ,ARR

        set (ITC,JD,AMT,DUP)=""
	set (SSEQ,ARR)=0

        for  set ITC=$O(SW61(ITC)) quit:ITC=""  do {
        	for  set JD=$O(SW61(ITC,JD)) quit:JD=""  do {
        		if ITC=0 for  set AMT=$O(SW61(ITC,JD,AMT),-1) quit:AMT=""  do {
				for  set DUP=$O(SW61(ITC,JD,AMT,DUP)) quit:DUP=""  do {
						set SSEQ=SSEQ+1,ARR=ARR+1
						set ARRAY(SSEQ)=SW61(ITC,JD,AMT,DUP)
						set AMTALL(ARR)=ITC_"|"_AMT
						}	
				}
           		if ITC=1 for  set AMT=$O(SW61(ITC,JD,AMT)) quit:AMT=""  do {  
				for  set DUP=$O(SW61(ITC,JD,AMT,DUP)) quit:DUP=""  do {
         	                            	set SSEQ=SSEQ+1,ARR=ARR+1
					   	set ARRAY(SSEQ)=SW61(ITC,JD,AMT,DUP)
					   	set AMTALL(ARR)=ITC_"|"_AMT
						}
				}
			}		// JMH - 03/10/99
		}	
        quit

  
OPTION(RecordSWIFT fswift)  
	/* 
	Set opening and closing balance options
	*/

	if (PAGE=0)!(PAGE=1) do { quit
		set fswift.obopt="F"		// Opening Balance Option
		set fswift.clbopt="F"		// Closing Ledger Balance Option
  		}

	if (PAGE>1)&(PG=1) do { quit
		set fswift.obopt="F"		
		set fswift.clbopt="M"
		}	
	
	if (PAGE>1)&(PG<PAGE) do { quit
		set fswift.obopt="M"
		set fswift.clbopt="M"
		}

	if (PAGE>1)&(PG=PAGE) do { quit
		set fswift.obopt="M"
		set fswift.clbopt="F"
		}				


	quit
	

SET(RecordSWIFT fswift)	

	set COUNT=1
	if PG'>1 set ARR=1

	set SSEQ=""
	set I=61
	for  do { quit:(SSEQ="")!(COUNT>LIMIT)  
		set SSEQ=$O(ARRAY(SSEQ)) quit:SSEQ=""
		
		if I=61 set fswift.f61data1=ARRAY(SSEQ)
		if I=61.001 set fswift.f61data2=ARRAY(SSEQ)		
		if I=61.002 set fswift.f61data3=ARRAY(SSEQ)
		if I=61.003 set fswift.f61data4=ARRAY(SSEQ)
		if I=61.004 set fswift.f61data5=ARRAY(SSEQ)
		if I=61.005 set fswift.f61data6=ARRAY(SSEQ)
		if I=61.006 set fswift.f61data7=ARRAY(SSEQ)
		if I=61.007 set fswift.f61data8=ARRAY(SSEQ)
		if I=61.008 set fswift.f61data9=ARRAY(SSEQ)
		if I=61.009 set fswift.f61data10=ARRAY(SSEQ)
		if I=61.01 set fswift.f61data11=ARRAY(SSEQ)
		if I=61.011 set fswift.f61data12=ARRAY(SSEQ)
		if I=61.012 set fswift.f61data13=ARRAY(SSEQ)
		if I=61.013 set fswift.f61data14=ARRAY(SSEQ)
		if I=61.014 set fswift.f61data15=ARRAY(SSEQ)

		if $P(AMTALL(ARR),"|",1)=0 set AMT62=AMT62-$P(AMTALL(ARR),"|",2) 
		if $P(AMTALL(ARR),"|",1)=1 set AMT62=AMT62+$P(AMTALL(ARR),"|",2) 

                kill AMTALL(ARR),ARRAY(SSEQ)
	        set I=I+.001,COUNT=COUNT+1,ARR=ARR+1
		}
	quit


MSG(RecordDEP dep,RecordSWIFT fswift)
	/* 
	Format all other fields in the message
	*/

	set OSTMT=dep.vosnum		      // MT950 Account Statement Number
	if (PG<1)!(PG=1) do {
		set NSTMT=OSTMT+1
		set dep.vosnum=NSTMT 	      // MT950 Account Statement Number
		}

	set fswift.acctid=CID		      // Account Identification			
	set fswift.stnum=NSTMT_"/"_SWSEQ      // Statement Number

	set AMT62=AMT60+AMT62
	if (AMT62>0)!(AMT62=0) set DC="C",CONV62=AMT62
        if AMT62<0 set DC="D",CONV62=(AMT62*-1) 	// Remove negative sign
        
        set CRCD=dep.crcd		

	set CONV62=$$AMTCNV^SWIFTCDI(.dep,CONV62,CRCD)        // SWIFT format amount
	set fswift.clbal=DC_DTE_CRCD_CONV62 // Statement Closing Ledger Balance	

	set CLSBAL=dep.balavl
        set DTE=$$DATE^SWIFTCDI(%SystemDate,"YYMMDD")
        
        set CRCD=dep.crcd

	if (CLSBAL>0)!(CLSBAL=0) set DC="C"
	if CLSBAL<0 set DC="D",CLSBAL=(CLSBAL*-1)	// Remove negative sign
        set CONV64=$$AMTCNV^SWIFTCDI(.dep,.CLSBAL,CRCD)
       	set fswift.clabal=DC_DTE_CRCD_CONV64	    // Closing Available Balance

	quit

FILE(RecordDEP dep,RecordSWIFT fswift)	
	/*
          File into ^SWIFT and also ^ACN - must file directly
          because no UX array exists
        */

	set dep.vosstmt=""			// MT950 Ad Hoc Statement Flag

	set fswift.trnofmt=fswift.trrefno   // Transaction Reference Number (Formatted)

	// Record locked by another user
	if fswift.trnofmt="" set ER=1,RM=$$^MSG(2333) quit

	do dep.bypassSave()	
	do fswift.save()

	// Stick the message in the RTT queue
	do QUEUE^SWIFTGEN("RTT",%SystemDate)
	
	set TYPE=4

	type RecordTRREF trref=Db.getRecord("TRREF","TYPE",1)
	set trref.refno=TRREFNO
	do trref.bypassSave()

	quit


KSWIFT(RecordSWIFT fswift)	

	/*
           This section will remove transactions from fSWIFT(61-61.014) for
           an account that has more than 15 transactions so that transactions
           on the first statement are not repeated on the sectond statement.
           JMH - 09/23/98
	*/        

	set fswift.f61data1=""
        set fswift.f61data2=""
        set fswift.f61data3=""
        set fswift.f61data4=""
        set fswift.f61data5=""
        set fswift.f61data6=""
        set fswift.f61data7=""
        set fswift.f61data8=""
        set fswift.f61data9=""
        set fswift.f61data10=""
        set fswift.f61data11=""
        set fswift.f61data12=""
        set fswift.f61data13=""
        set fswift.f61data14=""
        set fswift.f61data15=""

        quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
 type String vRECORD,CID
 for  set vRECORD=vINPUT.piece("|",1),vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD.isNull()  do {
 set CID=vRECORD.piece($C(9),1)
 do vPROC(CID)
 }
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
 type public String vBUFOVFL
 type String vRECORD,vrow,CID
 type Number vcur,vlen
 set vINPUT=vBUFOVFL.get()
 set vBUFOVFL="",vlen=0
 type public ResultSet vRESULT
 for  do { quit:'vcur
 set vcur=vRESULT.next() if 'vcur quit
 set vrow=vRESULT.getRow()_"|",vlen=vlen+vrow.length()
 if vlen>32767 set vBUFOVFL=vrow,vcur=0 quit
 set vINPUT=vINPUT_vrow if vlen+13>32767 set vcur=0 quit
 }
 set vINPUT=vINPUT.extract(1,vINPUT.length()-1)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("CID","DEP","DEP.VOSTRO=1 OR DEP.MT950=1")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	set LIMIT=15
	set %UserID="BATCH"

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
