MRPC067(String RETURN,Number VERSN,Number LINENO,String FILE,String DIR,String CLIENT)
	/*

	   ORIG: Spier - 02/14/98

	   This MRPC is used to transfer a FILE from the server to the CLIENT.
	   Execution of ths mrpc is initiated by the PFW CLIENT table
	   synchronization software.

	    [SCATBL5]RPCID=1

	   KEYWORDS: CLIENT/Server, Database

	   ARGUMENTS:
	       . RETURN 	Value of fields requested		/TYP=T/REQ/MECH=REFNAM:W

	       . VERSN	^MRPC0067 version number			/TYP=N/REQ/MECH=VAL
				Current version = 1  

	       . LINENO 	Last line number sent			/TYP=N/REQ/MECH=VAL/DEF=0

	       . FILE		Rms FILE name				/TYP=T/REQ/MECH=VAL

	       . DIR 		Directory name where FILE is stored	/TYP=T/REQ/MECH=VAL

	       . CLIENT 	Client requesting the FILE transfer	/TYP=T/REQ/MECH=VAL

	   RETURNS:
	       . $$ 		Error message				/TYP=T
	    				Null = No error

	   RELATED:
	       . $$^PBSMRPC - MRPC Service Class Driver

	   EXAMPLES:

	   S RM=$$^MRPC0067(.val,1,0,"F123.FEP","$2$dua200:[v53dev.ddp]","STEIN")

	---- Revision History ------------------------------------------------
	
	07/10/06 - RussellDS - CR22121
		   Modified length checking against 32000 to consider bytes,
		   not characters to be Unicode compliant.

	01/23/06 - KELLYP - CR 19209
		   Modified top level of procedure to delete TMPFTPCODE records
		   when a TMPFTPHOLD record doesn't exist for the FEP file 
		   specified by the calling process.  This prevents a "Unique
		   constraint violated" error from occurring in TMPXFR when 
		   creating TMPFTPCODE records.

	10/13/05 - KELLYP - CR 17802
		   Modified TMPXFR section to instantiate the code object for
		   every iteration of the loop that is saving the TMPFTPCODE
		   records.

	08/22/05 - KELLYP - CR 16960
		   Modified TMPXFR section to change the mode of the "code" 
		   object to "0" (Create) every time the loop iterates.  
		   This prevents a problem where only the first line from a 
		   FEP file would get stored in the TMPFTPCODE table and 
		   returned to PFW because the mode in the object would 
		   change from 0 to 1 and the subsequent updates would fail.

	05/24/05 - RussellDS - CR16071
		   Changed TP method from "BA" to "CS".
		   
		   Removed old revision history.

	02/04/05 - KELLYP - CR 14239
		   Modified to eliminate TP-Timeouts by calling the TMPXFR section
		   directly instad of via the READFILE section.  Removed the READFILE
		   and RECREATE sections as a result since they're no longer called.
		   Also moved the lock on the TMPXTRN mutex to the top level of the 
		   procedure.  Also modified the entire procedure to conform to PSL 
		   standards and removed pre-2003 revision history.
	*/

	type public Number ER
	type public String RM,TMPXTRAN()
	
	type Boolean QUIT
	type String REC
	type Number LINECNT

	set ER=0
	
	// Version number of CLIENT message is not compatible with server
	if VERSN.get()'=1 quit $$ERRMSG^PBSUTL($$^MSG(2951))

	if $Tlevel do Runtime.rollback()
	
	lock +TMPXTRAN(FILE):25

	// Transfer file could not be accessed before time-out. Please 
	// check server resources.
	else  set ER=1 quit $$ERRMSG^PBSUTL($$^MSG(4565))

	// TMPXTRN(FILE) = TMPFTPHOLD
	type RecordTMPFTPHOLD tftphold=Db.getRecord("TMPFTPHOLD","FILE=:FILE",1)
	
	set LINECNT=tftphold.linecnt
	if 'LINECNT do { quit:ER $$ERRMSG^PBSUTL(RM.get())
		do Db.delete("TMPFTPHOLD","FILE=:FILE")
		do Db.delete("TMPFTPCODE","FILE=:FILE")
		do TMPXFR(FILE,DIR)
		}

	lock -TMPXTRAN(FILE)
	
	do global
	
	set REC=REC.extract(3,34000)
	set REC=REC.translate($C(0)," ")
	set REC=LINENO_$C(13,10)_REC
	
	set RETURN=$$V2LV^MSG(.REC)
	
	quit ""		


global	// Private

	// Read data to transfer from table rather then file since the file has more then 32k bytes
	// global can not be read before completely created.

	type public Number LINENO
	type public String FILE,REC

	type Boolean QUIT
	type Number I,LINE,SEQ

	set I=LINENO
	set QUIT=0
	set REC=""

	type DbSet ds=Db.selectDbSet("TMPFTPCODE","FILE=:FILE AND SEQUENCE>:LINENO")
	if ds.isEmpty() set LINENO=0 quit
	while ds.next() do { quit:QUIT
		type RecordTMPFTPCODE tmpftp=ds.getRecord()
		set LINE=tmpftp.fmtline
		set SEQ=tmpftp.sequence
		if (REC.toByteString().length()+({String}LINE).toByteString().length())>32000 do { quit
			set QUIT=1
			set LINENO=SEQ-1
			}
		set REC=REC_$C(13,10)_LINE
		}

	if QUIT quit

	type RecordTMPFTPHOLD hold=Db.getRecord("TMPFTPHOLD","FILE=:FILE")
	
	// Last Line # = Total # of Lines
	if SEQ=hold.linecnt do {

		/*
		 At this point all data has been returned, update the table
		 to indicate that one less client needs to retrieve the data 
		 for this file. If the total number of clients is already 1 
		 then remove the table containing the counter and remove the 
		 table containing the data from the file
		*/

		set LINENO=0
		
		do Runtime.start("CS")
		
		if hold.clientcnt=1 do {
			do Db.fastDelete("TMPFTPCODE","FILE=:FILE")
			do Db.fastDelete("TMPFTPHOLD","FILE=:FILE")
			}
		else  do {
			set hold.clientcnt=hold.clientcnt-1
			do hold.bypassSave() 
			}
		
		do Runtime.commit()
		}

	quit


TMPXFR(String FILE,String DIR)	// Private, Copies host-sync files into a table

	type public Number ER
	type public String RM,TMPXTRAN()

	type Boolean EOT,X
	type Number CNT,FEPS,LINE
	type String IO,%QN

	set IO=$$FILE^%TRNLNM(FILE,DIR)
	set X=$$FILE^%ZOPEN(IO,"READ:VARIABLE",2,5600)
	
	// Unable to open file ~p1
	if 'X set ER=1,RM=$$^MSG(2799,FILE) quit

	// make sure another process is not already doing this 
	lock +TMPXTRAN(FILE):1
	else  quit

	if Db.isDefined("TMPFTPHOLD","FILE") quit

	for CNT=1:1 set LINE=$$^%ZREAD(IO,.EOT) quit:EOT  do {
		type RecordTMPFTPCODE code=Class.new("RecordTMPFTPCODE","FILE=:FILE,SEQUENCE=:CNT")
		set code.fmtline=LINE
		do code.save()
		}

	set FEPS=0
	set %QN=+FILE.extract(2,10)	

	type ResultSet fep=Db.select("COUNT(FEPDIR)","DDPTQUE1","%QN=:%QN")
	if 'fep.isEmpty(),fep.next() set FEPS=fep.getCol(1)

	type RecordTMPFTPHOLD ftphold=Class.new("RecordTMPFTPHOLD")
	set ftphold.file=FILE
	set ftphold.linecnt=CNT-1
	set ftphold.clientcnt=FEPS
	do ftphold.bypassSave()

	lock -TMPXTRAN(FILE)
	close IO

	quit 

vSIG()	quit "60472^45704^Dan Russell^5831"	// Signature - LTD^TIME^USER^SIZE
