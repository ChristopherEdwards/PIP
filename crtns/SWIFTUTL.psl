SWIFTUTL	//
	/*
	   DESC: Utilities for the SWIFT incoming and outgoing servers

	   LIBRARY:  $$STOPCHK - Check if server stop signal is set
	    $$CNCT  - Connect
	    $$DCNCT  - Disconnect
	    $$SEND  - Send message
	    $$RECEIVE - Receive message
	    $$REQUE  - Move msg. from one que to another
	    $$GETFLD - Returns the value of the specified field
	    $$PUTFLD - Writes value to specified field
	    $$INCSEQ - Increments a counter, pad with "0"
	    $$CHKSEQ - Verify sequence number
	    $$WCTL  - Write server control string

	    INIT  - Common init's for incom/outg. servers
	    CLS  - Write close file control string into MBX
	    CLSFIL  - Open new version of erro log and journal files


	  ---- Revision History -------------------------------------------------

	   02/03/06 - KELLYP - CR 18292
	   	      Modified section REQUE to move else condition from prior
	   	      revision to next line (else statement wasn't being executed).

	   01/11/06 - ratht - CR 18292
	      	      Modified section REQUE to add one else condtion for
	      	      dealkey. Added 3rd parameter to RecordNOSTTRF 
	      	      object type. Removed the Deprecated warnings.
	  
	   10/17/05 - KUMARB - CR 17050
	   	      Modified section INITS, the check for node.isNull() to
	   	      (node.get()).isNull().
 
	   09/09/05 - KELLYP - CR 17050
		      Modified entire procedure to no longer reference the ST400
		      interface which has been obsoleted by SWIFT.  No new core 
		      interface for SWIFT is currently available (ICG maintains
		      an SAA interface).  The core linetags have been preserved
		      to allow for an easy transition to another interface at a
		      later time.  Also removed pre-2003 revision history.
 
	   09/07/05 - KELLYP - CR 17118
	   	      Replaced reference to MSG100DT with MSG103DT.  The MT100
	   	      has been obsoleted by SWIFT and all references to it have
	   	      been removed from the system.  Also removed pre-2003
	   	      revision history.
 
           07/26/05 - SkariahV- CR16679
	              Removed #WARN and #OPTIMIZE directives.
	              
  	   12/29/03 - CARROLLJ - CR7658
		      Corrected precedence error.

	   06/07/03 - SRIVASTAVAN - 51351
	   	      Converted to PSL

	   	      Removed history before 2000
	---------------------------------------------------------------------- 
	*/

	quit

public INIT	// Common init's for incom/outg. servers

	type Public String ER,ET,iologi,iojrnli,iojrnlo,iologo,pid,RM,svrdir,svrid,X
	type Public String chnlin,chnlout,monitor,node,obsper,svrmbxi,svrmbxo
	type Public Number delmon,local,taskin,taskout
	type Public Date TJD
	
	// Load status table:

	// Direct Mode
	if '%UserID.exists() do INIT^SCADRV set %UserID=1,%UserClass="SCA"
	if '%Library.exists() set %Library=CUVAR.%libs
	set ER=0 
	set TJD=%SystemDate

	// Initialize variables for processing. Called from SWIFTMSG for ITS integration 
	do INITS

	// Define Journal/Log files

	// Establish incoming server communication

	// Error opening input server control mailbox
	if X.piece("|",1)=0 set ER=1,RM=$$^MSG(7533) quit

	// Establish outgoing server communication

	// Error opening Output Server control mailbox
	if X.piece("|",1)=0 set ER=1,RM=$$^MSG(7534) quit

	// SWIFTEFT is now considered an internal server, no comm. w/ mbx needed

	// Error opening EFT server control mailbox

	// Open incoming/outgoing journal files

	quit


public INITS	// Initialize all variables for processing

	type Public String svrid,svrdir,cs2,fs1,fs2,fs3,fs4,fs5,fs6,fs7,jpi,pid
	type Public String obsper,node,journal,monitor,X
	type Public Number stat,timeout,timouto,timouti
	type Public Number delmon,local,taskin,taskout

	// Ready to transmit
	set stat("RTT")=0
	
	// Pending response
	set stat("PND")=1
	
	// Repair
	set stat("REP")=2
	
	// Complete
	set stat("CMP")=3
	
	// In process
	set stat("PRC")=4

	// newline
	set cs2=$C(13,10)

	// start of message
	set fs1=$C(1)

	// start of text
	set fs2=$C(13,10,58)

	// field separator within text
	set fs3=$C(13,10,58)

	// end of text
	set fs4=$C(13,10,45)

	// end of message
	set fs5=$C(3)

	// cr/lf -}
	set fs6=$C(13,10,45,125)

	// {4: cr/lf
	set fs7=$C(123,52,58)

	// Envelope length
	set envlen=17

	set jpi=$$PRCNAM^%ZFUNC
	set svrdir=jpi.piece("_",2) set svrid=jpi.extract(jpi.length())
	set pid=$$PID^%ZFUNC("")

	if (node.get()).isNull() set node=$$NODENAM^%ZFUNC

	// Default timeout of 10 sec.
	set timeout=15

	quit


public STOPCHK(String svrid,String dir)	//Public; Check if server stop signal is set

	/*
	   ARGUMENTS:
	   . svrid	Server Id				/REQ/MECH=VAL
	   . dir	SWIFT Direction (Incoming/Outgoing)	/REQ/MECH=VAL

	   RETURNS:
	   . $$ Condition value  /TYP=T
	    0 - Continue
	    1 - Stop issued from Profile/IBS
	    2 - Stop issued from ST400
	    3 - Server does not exist

	   EXAMPLE:
	    status=$$STOPCHK^SWIFTUTL(String svrid,String dir)
	*/

	quit 3


public CNCT(String chnl,String STsess,String STseqO,String STseqI)	//Public; Connect a decnet channel for ST400

	/*
	   ARGUMENTS:
	   . chnl Server id   /REQ/MECH=REF

	   OUTPUTS:
	   . STsess ST400 session number  /MECH=REF
	   . STseqO ST400 seq Outgoing within sess /MECH=REF
	   . STseqI ST400 seq Incoming within sess /MECH=REF

	   RETURNS:
	   . $$ Condition value
	    0 - Succes
	    1 - Fail

	   EXAMPLE:
	    status=$$CNCT^SWIFTUTL(chnl
	*/

	quit 1


public DCNCT(String chnl)	//Public; Disconnect the channel

	/*
	   ARGUMENTS:
	   . chnl Channel to close /MECH=VAL

	   RETURNS:
	   . $$ Condition value  
	    0 - Succes
	    1 - Failiure

	   EXAMPLE:
	    status=$$DCNCT^SWIFTUTL(chnl)
	*/
	
	quit 1


public SEND(String chnl,String msg,String reply,Number noreply)		//Public; Send msg. over channel

	/*
	   ARGUMENTS:
	   . chnl	Channel			/REQ/MECH=VAL
	   . msg	Outgoing message	/REQ/MECH=VAL
	   . reply	Response		/REQ/MECH=REF  
	   . noreply	Flag			/NOREQ/MEC=VAL

	   RETURNS:
	   . $$ Condition value  /TYP=T
	    0    - Succes
	    1    - Send failed
	    2    - Response timeout

	   EXAMPLE:
	    status=$$SEND^SWIFTUTL(channel,message,reply,1)
	*/
	
	quit 1


public REQUE(fromque,toque,svdir,key1,key2,key3,key4)	//Public; Move msg. from one que to another

	/*

	   We'll need to store any reject reason in the SWIFT message.

	   Call SWFILE to file the change in status and the reject reason (if
	   any) into SWIFT.  SWFILE will not automatically move the message
	   from one queue to the other.  This routine will handle that.

	   ARGUMENTS:
	   . fromque - curr msg. que			/MECH=VAL  
	   . toque   - new msg. que			/MECH=VAL  
	   . svdir  - direction of server(IN/OUT)	/MECH=VAL
	   . key1,key2,key3,key4 - key, dependent of which que	/MECH=VAL

	   RETURNS:
	   . $$ Condition value  /TYP=T
	    0 - Success
	    1 - Fail

	   EXAMPLE:
	    status=$$REQUE^SWIFTUTL

	*/
	type Public String did,dealkey,NOINT,ER,RM,REFNO,SWIFTQ(),VFMQ
	type Public Number CID,SEQ,stat(),tot,qtot
	type Date date
	type Number newseq,seq
	type String MSG,refno,SWDIRECT,type,TRREFNO
	type Public Date SWFTDT,TJD
	
	if fromque="RTT" do {
		set date=key1 
		set seq=key2 
		set refno=key3 
		set type=key4
		}
	else  do {
		set seq=key1 
		set refno=key2 
		set type=key3
		}
		
	type RecordSWIFT fSWIFT=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:refno,MSG=:type")
	
	do fSWIFT.setAuditFlag(1)

	set SWFTDT=fSWIFT.swftdt
	
	if SWFTDT.isNull() set SWFTDT=0

	// Status
	set fSWIFT.status=stat(toque)
	set TRREFNO=refno 
	set MSG=type 
	set SWDIRECT=svdir

	do fSWIFT.save()

	//Lock SWIFTQ

	// ~p1 record locked by another user
	if toque'="CMP" lock +SWIFTQ(toque):5 else  set VFMQ="Q" set ER=1,RM=$$^MSG(7354,toque) do ERR^SWIFTUTL quit (1)

	// ~p1 record locked by another user
	else  lock +SWIFTQ(toque,TJD):5 else  set VFMQ="Q" set ER=1,RM=$$^MSG(7354,toque) do ERR^SWIFTUTL quit (1)

	// ~p1 record locked by another user
	if fromque="RTT" lock +SWIFTQ(fromque,date):5 else  set VFMQ="Q" set ER=1,RM=$$^MSG(7354,fromque) do ERR^SWIFTUTL quit (1)

	// ~p1 record locked by another user
	else  lock +SWIFTQ(fromque):5 else  set VFMQ="Q" set ER=1,RM=$$^MSG(7354,fromque) do ERR^SWIFTUTL quit (1)
	if ER do ERR^SWIFTUTL quit (1)

	//Update the total nuber of record in the queue for today  TT,04.07.94
	
	if toque'="CMP" do {
		type RecordSWQCNT swqcnt=Db.getRecord("SWQCNT","QUE=:toque",1)
		set swqcnt.ptoday=swqcnt.ptoday+1
		}
		
	else  do {
		type RecordSWQCNTD swqcntd=Db.getRecord("SWQCNTD","QUE=:toque,DT=:TJD",1)
		set swqcntd.ptoday=swqcntd.ptoday+1
		}		

	//Date stamp for each message type in banking transaction  TT, 04.05.94
	type RecordEFTREF eftkey=Db.getRecord("EFTREF","REFNO=:refno")

	
	type ResultSet rs=Db.select("NOINT","DEAL1","TRREFNO=:refno")			
	if rs.next() set dealkey=rs.getCol("NOINT")
	else  set dealkey=""

	type RecordNOSTTRF nostkey=Db.getRecord("NOSTTRF","TRREFNO=:refno",1)

	if toque="CMP" do {
		if '(eftkey.getPointer()!dealkey!nostkey.getPointer())&(MSG'=950) do { quit

			
			// ~p1 Banking transaction is not found.
			
			// File def. not available for ^SWIFTX("TRREFNO",refno,SWFTDT,"OUT",MSG)
			type ResultSet rs=Db.select("TRREFNO","SWIFT","TRREFNO=:refno AND SWFTDT=:SWFTDT AND SWDIRECT='OUT' AND MSG=:MSG") 
			if (MSG'=900)&(MSG'=910)&('eftkey.getPointer())&(rs.isEmpty()) do {
				
				// ~p1 Banking transaction is not found.
				set RM=$$^MSG(7353,refno)
				do ERR^SWIFTUTL
				}
				
		type RecordSWQCNTD swqcntd=Db.getRecord("SWQCNTD","QUE=:toque,DT=:TJD",1)
		set newseq=swqcntd.nseq+1
		set swqcntd.nseq=newseq
		set qtot=swqcntd.tot+1 
		set swqcntd.tot=qtot

		do Db.delete("SWIFTQ1","QUE=:toque AND DT=:TJD AND SEQ=:newseq AND TRREFNO=:refno AND TYPE=:type")

		type RecordSWIFTQ1 swftq1=Db.getRecord("SWIFTQ1","QUE=:toque,DT=:TJD,SEQ=:newseq,TRREFNO=:refno,TYPE=:type",1)

		do swftq1.bypassSave()
		 
		}
		
		set did="MSG"_type_"DT"
		if eftkey.getPointer() do {
			set CID=eftkey.cid 
			set SEQ=eftkey.seq 
			set REFNO=refno
	
			type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ",1)
			do eftpay.setAuditFlag(1)
			
			if type=202 do {
				set eftpay.msg202dt=+%CurrentDate
				}
			else  if type=103 do {
				set eftpay.msg103dt=+%CurrentDate
				}
			else  quit	
			
			do eftpay.save()
			
			}
		if dealkey do {
		
			set NOINT=dealkey
			
			do DLOAD^DEALRPC(NOINT)
			
			type RecordDEAL1 deal1=Db.getRecord("DEAL1","NOINT=:NOINT",1)
			do deal1.setAuditFlag(1)
			
			if type=202 do {
				set deal1.msg202dt=+%CurrentDate
				}
			else  if type=210 do {
				set deal1.msg210dt=+%CurrentDate
				}
			else  if type=300 do {
				set deal1.msg300dt=+%CurrentDate
				}
			else  quit	
			
			do deal1.save()
			
			//set UX("DEAL1",did)="|"_+%CurrentDate
			}
		
		type RecordSWQCNTD swqcntd=Db.getRecord("SWQCNTD","QUE=:toque,DT=:TJD",1)
		set newseq=swqcntd.nseq+1
		set swqcntd.nseq=newseq
		set qtot=swqcntd.tot+1 
		set swqcntd.tot=qtot

		do Db.delete("SWIFTQ1","QUE=:toque AND DT=:TJD AND SEQ=:newseq AND TRREFNO=:refno AND TYPE=:type")

		type RecordSWIFTQ1 swftq1=Db.getRecord("SWIFTQ1","QUE=:toque,DT=:TJD,SEQ=:newseq,TRREFNO=:refno,TYPE=:type",1)

		do swftq1.bypassSave()
		}

	else  do {
		type RecordSWQCNT swqcnt=Db.getRecord("SWQCNT","QUE=:toque",1)
		set newseq=swqcnt.nseq+1
		set swqcnt.nseq=newseq
		set qtot=swqcnt.tot+1 
		set swqcnt.tot=qtot
	
		do Db.delete("SWIFTQ2","QUE=:toque AND SEQ=:newseq AND TRREFNO=:refno AND TYPE=:type")

		type RecordSWIFTQ2 swq2=Db.getRecord("SWIFTQ2","QUE=:toque,SEQ=:newseq,TRREFNO=:refno,TYPE=:type",1)
	
		do swq2.bypassSave() 
		}

	if ER do { quit (1)
		if toque'="CMP" lock -SWIFTQ(toque)
		else  lock -SWIFTQ(toque,TJD)
		if fromque="RTT" lock -SWIFTQ(fromque,date)
		else  lock -SWIFTQ(fromque)

		do ERR^SWIFTUTL quit

		}

	type RecordSWQCNTD swqcntd
	type RecordSWQCNT swqcnt
	if fromque="RTT" do {
		
		do Db.delete("SWIFTQ1","QUE=:fromque AND DT=:date AND SEQ=:seq AND TRREFNO=:refno AND TYPE=:type")
		set key2=newseq
		set swqcntd=Db.getRecord("SWQCNTD","QUE=:fromque,DT=:date",1)
		set swqcntd.tot=swqcntd.tot-1
		if swqcntd.tot<0 set swqcntd.tot=0

		do swqcntd.bypassSave()

		}
	else  do {
		do Db.delete("SWIFTQ2","QUE=:fromque AND SEQ=:seq AND TRREFNO=:refno AND TYPE=:type")
		set key1=newseq
		set swqcnt=Db.getRecord("SWQCNT","QUE=:fromque",1)
		set swqcnt.tot=swqcnt.tot-1
		if swqcnt.tot<0 set swqcnt.tot=0
		
		do swqcnt.bypassSave()
		
		}

	if toque'="CMP" lock -SWIFTQ(toque)
	else  lock -SWIFTQ(toque,TJD)
	if fromque="RTT" lock -SWIFTQ(fromque,date)
	else  lock -SWIFTQ(fromque)

	quit (0)


public INCSEQ(String cnt,Number len,Number inc)	//Public; Increments a counter, pad with "0"

	/*
	   ARGUMENTS:
	   . cnt counter to be incremented			/MECH=VAL
	   . len length of resulting counter			/MECH=VAL
	   . inc increment by fct (optional) default is 1	/NOREQ/MECH=VAL

	   RETURNS:
	   . $$
	   
	   EXAMPLE:
	   . $$INCSEQ^SWIFTUTL(STsess,4,0)
	*/
	type String pad

	set:'inc.exists() inc=1
	set pad="000000000000000000000000000000000000"_(cnt+inc)

	quit pad.extract((pad.length()-(len-1)),pad.length())



public GETFLD(String segment,String field,Number mrpl)

	/*
	   ARGUMENTS:
	   . segment	
	   . field
	   . mrpl	

	   RETURNS:
	   . $$    String

	   EXAMPLE:
	   . $$GETFLD^SWIFTUTL("4:","451:",1)
	*/

	/*
	; added 3rd parameter to indicate
	which section of the seg array to retrieve the
	field from (1="F21" data, 2="F01" data)
	*/
	type Public String seg
	
	if mrpl.exists() set mrpl=2
	type String fld
	if segment[":" set segment=segment.piece(":",1)
	if 'seg(mrpl,segment).exists() quit ""
	set fld=seg(mrpl,segment).piece(field,2)
	set fld=fld.extract(1,$F(fld,"}")-2)
	quit fld


public ERR	//Log error in exception file
	/*
	   INPUTS:
	   . id Server to check  /TYP=T

	   RETURNS:
	   . $$ Condition value  /TYP=T
	    0 - Continue
	    1 - Stop

	   EXAMPLE:
	    status=$$  ^SWIFTUTL
	
	*/
	// I18N=OFF
	type Public String ER,ET,iologi,iologo,msg,monitor,RM,procn,rm,svrdir,%ZTSEQ

	if 'ET.exists() set ET=RM.get()

	set procn=$S(svrdir="IN":"SWIFTIN",1:"SWIFTOUT")

	// SWIFT Message Processing
	do LOG^UTLEXC(procn,"*",$$^MSG(7371),"",%ZTSEQ.get(),ET,"")

	set rm=$$DAT^%ZM(%CurrentDate)_" "_$$TIM^%ZM(%CurrentTime,"24:60:SS")_ET
	if svrdir="IN",'iologi.isNull() do {
		use iologi write !,rm,!

		// Check Error Log #~p1
		if '(%ZTSEQ.get()).isNull() use iologi write $$^MSG(7352,%ZTSEQ),!
		use iologi write !,msg,!
		}
	if svrdir="OUT",'iologo.isNull() use iologo write !,rm
	if ER.get() do REPLY(monitor,rm)
	kill ET,%ZTSEQ
	quit

REPLY(String monitor,String message)	//Send message to monitor device

	quit


public WCTL(svrname,msg)	//Write control string into server's mail box

	/*
	   Call by:  S X=$$WCTL^SWUTL(svrname,msg)
	   Example:  S X=$$WCTL^SWUTL("SWIFT_OUT_1","CLOSE")
	   Values and defaults:
	       svrname    - Server name - no default
	       msg  - Valid msg are:
	                  CLOSE  - To inform server to stop processing.
	                  CCLS   - To inform server to stop processing.
	                  CLSFIL - To inform server to close mail box.

	   If process succeeds, value returned is 1
	   If process fails, value returned the following:

	                 .  "0|error msg 1|error msg 2|...."

	*/
	
	quit 0

public CLS	//
	/*
	  Write control string "CLSFIL" into mail box of currently running server
	  to inform server to close error log file and journal file.
	*/

	quit


CLSFIL(direction)	//To create a new version of error log file and journal file


	quit


public RECMSG(Number dir,Number refno,Number msg,Number node)	//
	
	/*

	   ARGUMENTS:
	   . dir	SWIFT Direction (Incoming/Outgoing)	/REQ/NONULL/MECH=VAL
	   . refno	Transaction Reference Number		/REQ/NONULL/MECH=VAL		
	   . msg	Message Type				/REQ/NONULL/MECH=VAL
	   . node	Node					

	   RETURNS:
	         . $$    Condition value

	*/

	type String cs2,fs3,string
	type Public Number SEQ
	
	set cs2=$C(13,10)

	// field separator within text
	set fs3=$C(13,10,58)
	set node=node-.0001
	set string=""

	type DbSet ds=Db.selectDbSet("SWIFTSEQ","SWDIRECT=:dir AND TRREFNO=:refno AND MSG=:msg AND SEQ>:node")
	while ds.next() do {
		type RecordSWIFTSEQ swiftseq=ds.getRecord("SWIFTSEQ")
		set string=string_swiftseq.message
		}
	
	if string.extract(string.length()-1,2)=cs2 set string=string.extract(1,string.length()-2)

	quit string


public 500(String txt,Number maxlen,RecordSWIFT fSWIFT,RecordSWIFTSEQ fSWIFTSE())	//

	/*

	   ARGUMENTS:
	   . txt 	Message					/REQ/MECH=VAL
	   . maxlen 	Max. length of the message - 400 byte	/REQ/MECH=VAL
	   . fSWIFT 	Swift object				/REQ/MECH=REF
	   . fSWIFTSE()	Swiftse array of object			/REQ/MECH=REF

	   EXAMPLE:
	    do 500^SWIFTUTL(txt,400,.fSWIFT,.fSWIFTSE())

	*/

	/*
	  File message in 400 byte segments on nodes beginning with
	  500 and incrementing by .001.
	*/

	type Number beg,end,I,node,seg

	
	
	set I=(txt.length()\maxlen)+1
	set node=500
	for seg=1:1:I do {
		set node=node+.001

		set fSWIFTSE(node)=Class.new("RecordSWIFTSEQ")
		set fSWIFTSE(node).swdirect=fSWIFT.swdirect
		set fSWIFTSE(node).trrefno=fSWIFT.trrefno
		set fSWIFTSE(node).msg=fSWIFT.msg
		set fSWIFTSE(node).seq=node
		
		set beg=((seg-1)*maxlen)+1
		set end=beg+maxlen-1
		set fSWIFTSE(node).message=txt.extract(beg,end).translate($C(0),"")
		}
	quit
	//I18N=ON


public TFSIN(String trrefno,String typ,String txt)	//

	/*

	   ARGUMENTS:
	   . trrefno	Transaction reference number	/REQ/NONULL/MECH=VAL
	   . typ 	Message type	/REQ/NONULL/MECH=VAL
	   . txt 	Message		/REQ/MECH=VAL

   	   RETURNS:
	   . $$ Formatted Swift msg.    		

	*/

	type String msg,SWDIRECT

	do INITS

	set SWDIRECT="IN"
	
	type RecordSWIFT fSWIFT=Db.getRecord("SWIFT","SWDIRECT=:SWDIRECT,TRREFNO=:trrefno,MSG=:typ",1)

	set msg=$$fmttfs(trrefno,typ,txt,0,.fSWIFT)
	quit msg


fmttfs(String refno,String typ,String txt,String dup,RecordSWIFT fSWIFT)	//

	type String msgbdy,MSG,SWDIRECT,sendadr,sendadr1,sendadr2,trlblc,TRREFNO
	type Public String STsess,STseqO

	set SWDIRECT="IN"
	set TRREFNO=refno
	set MSG=typ
	
	set trlblc=""
	if dup set trlblc="{5:{PDE:}}"

	set sendadr=CUVAR.swiftadd
	set sendadr1=sendadr.extract(1,8)
	set sendadr2=sendadr.extract(9,11)
	set sendadr=sendadr1_"A"_$S(sendadr2.length()=3:sendadr2,1:"XXX")
	set sendadr="{1:F01"_sendadr_STsess_STseqO_"}"
	set msgbdy=sendadr_$$tfsapp^SWIFTFMT(.fSWIFT)
	set msgbdy=msgbdy_$$txtblc^SWIFTFMT(.fSWIFT)
	set msgbdy=msgbdy_trlblc
	
	quit msgbdy


public TEST	//I18N=OFF

	type public Number MSG,TRREFNO
	type Number dup

	read "Transaction reference number: ",TRREFNO
	read !,"Message type: ",MSG

	do INITS^SWIFTUTL

	set dup=0
	write !!!,$$MSGOUT^SWIFTFMT(TRREFNO,MSG,0)
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60299^42116^Pat Kelly^17854"	// Signature - LTD^TIME^USER^SIZE
