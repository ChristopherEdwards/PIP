PROCOMP		/*
	  LIBRARY:
	  $$ BENTYP    - Benefit Type
	  $$ BALCMP    - Ledger Balance
	  $$ PRNPMTRC - Principal-Only Payments Received
	  $$ PRPAYRCD - Principal-Only Payments Received
	  $$ CRDAVL    - Remaining Available for the Current Day
	  $$ COLDES    - Column Description
	  $$ CLS      - Transaction Class
	  $$ GRP      - Transaction Group
	  $$ AMTYPDSC - Description
	  $$ INSTNAM   - Institution Name
	  $$ METDSC    - Payment Code Description
	  $$ SRCDSC    - Financial Transaction Type
	  $$ STATDSC   - Description
	  $$ DESC      - Country Description
	  $$ TDES      - Transaction Description
	  $$ WTIRN     - Weighted Interest Rate
	  $$ RSEQ      - Restructured Loan Sequence
	  $$ TTXERBEN  - Beneficiary
	  $$ TTXERCOA  - Charge-off Amount
	  $$ TTXCORES  - Charge-off Reason
	  $$ TTXDISC1  - Discretionary Data 1
	  $$ TTXDISC2  - Discretionary Data 2
	  $$ TTXERITC  - Internal Transaction Code EXTRACT
	  $$ TTXEEFD   - Effective Date (Computed)
	  $$ TTXEREC   - Recovery Amount
	  $$ TTXERECS  - Recovery Source
	  $$ UBALITC   - Internal Transaction Code EXTRACT
	  $$ POSTP     - Logical indicating if node 3 exists
	  $$ PREP      - Logical indicating if node 2 exists
	  $$ URLCODE   - Logical indicating if node 1 exists
	  $$ XXDESC    - [STBLGRP] description
	  $$ XTRNUCLS  - Y/N access allowed
	  $$ PUI      - Payee In Use Indicator
	  $$ DESC2     - Description
	  $$ DCOA      - Charge On Analysis - Amount
	  $$ DOEA      - Offset Earnings Allowance - Amount
	  $$ GLDESC    - G/L Account Description
	  $$ AMTTY     - Description
	  $$ INVESCPC - Investor's Escrow Change Percent
	  $$ INVINTPC - INVINTPCT
	  $$ INVPRNPC - Investor's Principal Change Percent
	  $$ DSTATDSC  - NOSTTRF status description
	  $$ PATFREQ   - Preauthorized Transfer Frequency field
	  $$ PATLPD    - Preauthorized Transfer last posting date
	  $$ PATNPD    - Preauthorized Transfer next posting date
	  $$ PHLDDESC  - Permanent hold description
	  $$ RESPDT    - REPTBL response date
	  $$ SWFTDT    - REPTBL swift date
	  $$ UIDNAME   - Teller's name
	  $$ BALNEGY   - Previous Day's Negative Balance Accumlation from TTL
	  $$ ERDESC    - STBL XBAD description
	  $$ TRNSGT    - System-Generated Transaction field from TRN
	  $$ STATDESC  - Check Status Description
	  $$ DEALDESC  - Deal Description
	  $$ STATDSC1  - Status Description
	  $$ CIFBOO    - CIF Branch of Ownership
	  $$ CIFCODE   - CIF Customer Code
	  $$ XAMTTYPD  - Amount Type Description
	  $$ EFTDESC   - EFT Type Description
	  $$ XINSTNAM  - Recipient Institution Name
	  $$ XSRCDSC   - Source Description
	  $$ XMETDSC   - Payment Method Description
	  $$ XSTATDSC  - Status Description
	  $$ EFTTYPE   - EFT Type
	  $$ XSTATUS   - Status
	  $$ TAXID     - TIN/SINC
	  $$ MPSCERT   - MPS Certified Record Types
		
	  ---- Revision History -----------------------------------------------
	  
	11/02/06 - Ravindra Rathi - CR 23386
	           Modified the POSTP,PREP and URLCODE section to eliminate 
	           RECNOFL errors by adding a third parameter to 
	           type RecordUTBLACRXDTL utblacrxdtl.Also added a quit condition 
	           if 'utblacrxdtl.getMode() quit "".
	
	04/19/06 - RussellDS - CR20209
		   Remove code related to obsoleted Mutual Funds/Securities.
		   
	09/26/05 - ALAGARSS - CR 16677
		   Removed deprecated method Db.getOneRow and replaced with
		   Db.getRecord. 
	 
  	12/17/03 - RussellDS - CR 7514
		   Replace use of table UTBLSRCPAT (being obsoleted), with
		   table UTBLSRC.
		   
	10/15/02 - Spier - 51089
		   Corrected coding at PUI label which incorrectly
		   accessed an index table.

	05/03/02 - ESTERLYP - 50527
		   Change PRPAYRCD tag to PRNPMTRC to match file definition
		   for LNTAMT.PRNPMTRCD Principal-Only Payments Received. 
                   Added LNTAMT.TSEQ to argument list for PRNPMTRC to get
                   correct history information.

	11/12/01 - APPLEYARDM - 46857
		   Modified section NOTESACN to set and return CID instead of
		   cid. Previously, cid was only set if FILE was not equal to
		   CIF (CIF notes). This caused report SCA233 to miss all CIF 
		   notes for a customer when searching for the specific CID. 
		   The value returned for cid was equal to the last cid 
		   encountered when the Account notes was searched. 

	10/15/01 - SIGDAE - 47650
		   Modified section XAMTTYPD to use table STBLEFTOPT instead
		   of STBLAMTTYP.

	10/03/01 - GARBERB - 47065	     
		   Modified the line tag CIFBOO, it was not being populated
                   with the proper data. Added code to retrieve ACN
                   information form the ACN table in the case, when CLS is
                   equal to "L" or "D". Prior to this change CIFBOO would not
                   return any data in the case of a "L" or "D" in CLS it
                   returned a Null. Also changed the coding so CIFBOO now
                   holds Account Branch Of Owner and not CIF Branch Of owner.
  
	
	08/23/99 -  DUJ - 33890
		Converted M code to PSL.
		
	*/
	
	quit

BENTYP(BENNUM)
	/*
	  The function is used to compute [MEMSHP]BENTYP field

	  ARGUMENTS:
	  . BENNUM  Membership Benefit Number	/TYP=N/REQ/MECH=VAL


	  RETURNS:
	  . $$	    Benefit Type		/TYP=T

	  EXAMPLE:
	  ($$BENTYP^PROCOMP([MEMSHP]BENNUM))
	  ($$BENTYP^PROCOMP(20))
	*/

	if $G(BENNUM)="" quit ""
	new bentyp
	
	type RecordUTBLBENNUM utblbennum=Db.getRecord("UTBLBENNUM","BENNUM=:BENNUM")
	set bentyp=utblbennum.bentyp	
	quit bentyp
	
BALCMP(CID,BAL,UDBAL)
	/*
	  The function is used to compute [PAA]BALCMP field

	  ARGUMENTS:
	  . CID  Account Number  /TYP=N/REQ/MECH=VAL

	  . BAL  Ledger Balance  /TYP=$/REQ/MECH=VAL


	  RETURNS:
	  . $$ Balance 		 /TYP=$

	  EXAMPLE:
	  ($$BALCMP^PROCOMP([PAA]CID,[PAA]BAL,[PAA]UDBAL))
	  ($$BALCMP^PROCOMP(701,400,100000))
	*/
	
	new aruf
	
	type RecordLN ln=Db.getRecord("LN","CID=:CID")
	set aruf=ln.aruf
	quit ($S('aruf:BAL,1:BAL-UDBAL))
	
PRNPMTRC(CID,XLNTAMT1,TSEQ)
	/*
	  The function is used to compute [LNTAMT]PRNPMTRCD field

	  ARGUMENTS:
	  . CID		Account Number			 /TYP=N/REQ/MECH=VAL

	  . XLNTAMT1	System Use - Component Breakdown /TYP=T/REQ/MECH=VAL
	
	  . TSEQ        Transaction Sequence             /TYP=N/REQ
	
	  RETURNS:
	  . $$ Principal-Only Payments Received		 /TYP=T

	  EXAMPLE:
	  ($$PRNPMTRC^PROCOMP([LNTAMT]CID,[LNTAMT]XLNTAMT1,[LNTAMT]TSEQ))
	  ($$PRNPMTRC^PROCOMP(800012498,"01010",42))
	*/

	new itc1
	
	type RecordHIST hist=Db.getRecord("HIST","CID=:CID,TSEQ=:TSEQ")
	set itc1=hist.itc1
	quit ($P(XLNTAMT1,$C(124),25)*$S('itc1:-1,1:1))
	
CRDAVL(TLD,CRDTYP,TWTLD)
	/*
	  The function is used to compute [CRD]CRDAVL field

	  ARGUMENTS:
	  . TLD  Last Transaction Date for Daily Limit  /TYP=T/REQ/MECH=VAL

	  . CRDTYP Card Type 				/TYP=T/REQ/MECH=VAL

	  . TWTLD  Total Withdraw - Last Transaction Date /TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ Remaining Available for the Current Day /TYP=T

	  EXAMPLE:
	  ($$CRDAVL^PROCOMP([CRD]TLD,[CRD]CRDTYP,[CRD]TWTLD)
	  ($$CRDAVL^PROCOMP("01/03/1997","DEBIT",50.00))
	*/

	new dlylmt
	if ($G(CRDTYP)="") quit ""
	
	type RecordCRDTYP crdtyp=Db.getRecord("CRDTYP","CARDTYPE=:CRDTYP")
	set dlylmt=crdtyp.dlylmt
	
	quit $S(TLD<%SystemDate:dlylmt,1:dlylmt-TWTLD)
	
COLDES(XPRITABLE,XJRNID,COLNAM)
	/*
	  The function is used to compute [DBTBL9D]COLDES field

	  ARGUMENTS:
	  . XPRITABLE Primary Table  /TYP=T/REQ/MECH=VAL/HLP=[DBTBL9D]PRITABLE

	  . XJRNID    Journal Name   /TYP=T/REQ/MECH=VAL/HLP=[DBTBL9D]JRNID

	  . COLNAM    Column Name    /TYP=T/REQ/MECH=VAL/HLP=[DBTBL9D]COLNAM

	  RETURNS:
	  . $$ Column Description    /TYP=T/HLP=[DBTBL9D]COLDES

	  EXAMPLE:
	  ($$COLDES^PROCOMP([DBTBL9D]PRITABLE,[DBTBL9D]JRNID,[DBTBL9D]COLNAM))
	  $$COLDES^PROCOMP("DEP","HIST_I","BRCD")
	*/
	
	new DES,subtable
	if $G(XPRITABLE)=""!($G(XJRNID)="")!($G(COLNAM)="") quit ""
	
	type RecordDBTBL9 dbtbl9=Db.getRecord("DBTBL9","%LIBS='SYSDEV',PRITABLE=:XPRITABLE,JRNID=:XJRNID")
	set subtable=dbtbl9.subtable
	
	set DES=$$DES^DBSDD(subtable_"."_COLNAM)
	quit DES

CLS(XETC)
	/*	
	  The function is used to compute data item that is equal to [TRN]CLS

	  ARGUMENTS:
	  . XETC  Transaction Code /TYP=T/REQ/MECH=VAL/HLP=[TRN]ETC

	  RETURNS:
	  . $$ Transaction Class   /TYP=T/HLP=[TRN]CLS

	  EXAMPLE:
	  $$CLS^PROCOMP([EFTOUT]ETC)
	  $$CLS^PROCOMP("DW")
	*/

	new xcls
	if $G(XETC)="" quit ""
	
	type RecordTRN trn=Db.getRecord("TRN","ETC=:XETC")
	set xcls=trn.cls
	
	quit xcls

GRP(XETC)
	/*
	  The function is used to compute data item that is equal to [TRN]GRP

	  ARGUMENTS:
	  . XETC  Transaction Code	/TYP=T/REQ/MECH=VAL/HLP=[TRN]ETC

	  RETURNS:
	  . $$ Transaction Group	/TYP=T/HLP=[TRN]GRP

	  EXAMPLE:
	  $$GRP^PROCOMP([EFTOUT]ETC)
	  $$GRP^PROCOMP("DW")
	*/
	
	new xgrp
	if $G(XETC)="" quit ""
	
	type RecordTRN trn=Db.getRecord("TRN","ETC=:XETC")
	set xgrp=trn.grp
	
	quit xgrp

AMTYPDSC(XCID,XSEQ)
	/*
	  The function is used to compute data item [EFTREV]AMTTYPDSC

	  ARGUMENTS:
	  . XCID  Account Number	/TYP=N/REQ/MECH=VAL/HLP=[EFTREV]CID

	  . XSEQ  Sequence Number	/TYP=N/REQ/MECH=VAL/HLP=[EFTREV]SEQ

	  RETURNS:
	  . $$		Description	/TYP=T/HLP=[EFTREV]AMTTYPDSC

	  EXAMPLE:
	  ($$AMTYPDSC^PROCOMP([EFTREV]CID,[EFTREV]SEQ))
	  $$AMTYPDSC^PROCOMP(400,8)
	*/

	new DESC,XAMTTYP
	if $G(XCID)=""!($G(XSEQ)="") quit ""
	
	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:XCID,SEQ=:XSEQ")
	set XAMTTYP=eftpay.amttyp
	
	type RecordSTBLAMTTYP stblamttyp=Db.getRecord("STBLAMTTYP","AMTTYP=:XAMTTYP")
	set DESC=stblamttyp.desc
	
	quit DESC

INSTNAM(XCID,XSEQ)
	/*
	  The function is used to compute data item [EFTREV]INSTNAM

	  ARGUMENTS:
	  . XCID  Account Number     /TYP=N/REQ/MECH=VAL/HLP=[EFTREV]CID

	  . XSEQ  Sequence Number    /TYP=N/REQ/MECH=VAL/HLP=[EFTREV]SEQ

	  RETURNS:
	  . $$    Institution Name   /TYP=T/HLP=[EFTREV]INSTNAM

	  EXAMPLE:
	  ($$INSTNAM^PROCOMP([EFTREV]CID,[EFTREV]SEQ))
	  $$INSTNAM^PROCOMP(400,5)
	*/

	if $G(XCID)=""!($G(XSEQ)="") quit ""
	new nam,xrecinst
	
	
	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:XCID,SEQ=:XSEQ")
	set xrecinst=eftpay.recinst
	
	
	type RecordUTBLEFTINST utbleftinst=Db.getRecord("UTBLEFTINST","KEY=:xrecinst") 
	set nam=utbleftinst.nam
	
	quit nam

METDSC(XCID,XSEQ)
	/*
	  The function is used to compute data item [EFTREV]METDSC

	  ARGUMENTS:
	  . XCID  Account Number	/TYP=N/REQ/MECH=VAL/HLP=[EFTREV]CID

	  . XSEQ  Sequence Number	/TYP=N/REQ/MECH=VAL/HLP=[EFTREV]SEQ

	  RETURNS:
	  . Payment Code Description	/TYP=T/HLP=[EFTREV]METDSC

	  EXAMPLE:
	  ($$METDSC^PROCOMP([EFTREV]CID,[EFTREV]SEQ))
	  $$METDSC^PROCOMP(401,2)
	*/
	
	if $G(XCID)=""!($G(XSEQ)="") quit ""
	new desc,xmet
		
	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:XCID,SEQ=:XSEQ")
	set xmet=eftpay.met
	
	type RecordSTBLPAYMET stblpaymet=Db.getRecord("STBLPAYMET","KEY=:xmet")
	set desc=stblpaymet.desc
	
	quit desc

NOTESACN(FILE,CID)
	/*
	  Return the primary CIF for a NOTES entry. If FILE="CIF", then
	  that value is CID. Otherwise retrieve ACN from the financial
	  account using CID as a key.

	  KEYWORDS:

	  ARGUMENTS:
	  . FILE Customer/Account File ID	/TYP=T/REQ/MECH=VAL

	  . CID  Account Number			/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Customer Number			/TYP=N

	  EXAMPLE:
	  $$NOTESACN^PROCOMP("CIF",401)
	*/

	if ($G(CID)="") quit ""
	
	//MCA 11/12/01 set and return CID, not cid
	
	if FILE'="CIF" do {
	type RecordACN acn=Db.getRecord("ACN","CID=:CID")
	set CID=acn.acn
	}
	
	quit CID

SRCDSC(XCID,XSEQ)
	/*
	  The function is used to computed [EFTREV]SRCDSC,[EFTREV2]EFTTYPEDSC,
	  [EFTREV2]SRCDSC

	  ARGUMENTS:
	  . XCID Account Numbe		/TYP=N/REQ/MECH=VAL/HLP=[EFTPAY]CID

	  . XSEQ Sequence Number	/TYP=N/REQ/MECH=VAL/HLP=[EFTPAY]SEQ

	  RETURNS:
	  . $$ Financial Transaction Type /TYP=T/HLP=[EFTREV]SRCDSC,
	  [EFTREV2]EFTTYPEDSC

	  EXAMPLE:
	  $$SRCDSC^PROCOMP([EFTREV]CID,[EFTREV]SEQ)
	  $$SRCDSC^PROCOMP(401,2)
	*/
	
	if $G(XCID)=""!($G(XSEQ)="") quit ""
	new fincl,xefttype
	
	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:XCID,SEQ=:XSEQ")
	set xefttype=eftpay.efttype
	
	type RecordCTBLEFTTYPE ctblefttype=Db.getRecord("CTBLEFTTYPE","KEY=:xefttype")
	set fincl=ctblefttype.fincl
	
	quit fincl

STATDSC(XCID,XSEQ)
	/*
	  This function is used to compute [EFTREV]STATDSC data item.

	  ARGUMENTS:
	  .XCID  Account Number		/TYP=N/REQ/MECH=VAL/HLP=[EFTREV]CID

	  .XSEQ  Sequence Number	/TYP=N/REQ/MECH=VAL/HLP=[EFTREV]SEQ

	  RETURNS:
	  . $$   Description		/TYP=T/HLP=[EFTREV]STATDSC

	  EXAMPLE:
	  $$STATDSC^PROCOMP([EFTREV]CID,[EFTREV]SEQ)
	  $$STATDSC^PROCOMP(401,2)
	*/

	if $G(XCID)=""!($G(XSEQ)="") quit ""
	new desc,xstatus
	
	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:XCID,SEQ=:XSEQ")
	set xstatus=eftpay.status
	
	type RecordSTBLESTAT stblestat=Db.getRecord("STBLESTAT","STATUS=:xstatus")
	set desc=stblestat.desc
	quit desc

DESC(XCNTRY)
	/*
	  Ths function is used to compute [EXPCNTRY]DESC data item

	  ARGUMENTS:
	  . XCNTRY Country Code		/TYP=T/REQ/MECH=VAL/HLP=[EXPCNTRY]CNTRY

	  RETURNS:
	  . $$ Country Description	/TYP=T/HLP=[EXPCNTRY]DESC

	  EXAMPLE:
	  $$DESC^PROCOMP([EXPCNTRY]CNTRY)
	  $$DESC^PROCOMP("US")
	*/

	if $G(XCNTRY)="" quit ""
	new desc
	
	type RecordSTBLCNTRY stblcntry=Db.getRecord("STBLCNTRY","CNTRY=:XCNTRY")
	set desc=stblcntry.desc
		
	quit desc

	
TDES(XETC)
	/*
	  This function is used to compute [IRAHIS]TDES data item

	  ARGUMENTS:
	  . XETC External Transaction Code /TYP=T/REQ/MECH=VAL/HLP=[IRAHIS]ETC

	  RETURNS:
	  . $$ Transaction Description	   /TYP=T/HLP=[IRAHIS]TDES

	  EXAMPLE:
	  $$TDES^PROCOMP([IRAHIS]ETC)
	  $$TDES^PROCOMP("DW")
	*/

	if $G(XETC)="" quit ""
	new prdes
	
	type RecordTRN trn=Db.getRecord("TRN","ETC=:XETC")
	set prdes=trn.prdes
	
	quit prdes

WTIRN(XCID)
	/*
	  This function is used to compute [IRAMAT]WTIRN data item

	  INPUTS:
	. XCID  Account Number			/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$    Weighted Interest Rate	/TYP=T

	  EXAMPLE:
	  $$WTIRN^PROCOMP([IRAMAT]CID)
	  $$WTIRN^PROCOMP(3510000050)
	*/

	if $G(XCID)="" quit ""
	new WTIRN,BAL,IRN
	
	type RecordDEP dep=Db.getRecord("DEP","CID=:XCID")
	set BAL=dep.bal
	set IRN=dep.irn
	
	set WTIRN=BAL*IRN
	quit WTIRN

RSEQ(XCID,XTSEQ)
	/*
	  ARGUMENTS:
	.   XCID Account Number		    /TYP=N/REQ/MECH=VAL/HLP=[HIST]CID

	. XTSEQ Transaction Sequence Number /TYP=N/REQ/MECH=VAL/HLP=[HIST]TSEQ

	  RETURNS:
	  . $$ Restructured Loan Sequence   /TYP=N

	  EXAMPLE:
	  $$RSEQ^PROCOMP([ITAUDIT]CID,[ITAUDIT]TSEQ)
	  $$RSEQ^PROCOMP(800013716,10)
	*/

	if $G(XCID)=""!($G(XTSEQ)="") quit ""
	new tso,RSEQ
	
	type RecordHIST hist=Db.getRecord("HIST","CID=:XCID,TSEQ=:XTSEQ")
	set tso=hist.tso
	
	set RSEQ=$P($P(tso,"RSEQ#",2),"~",1)
	quit RSEQ

	
TTXERBEN(%SystemDate,BRCD,UID,TSEQ)
	/*
	  Provided the keys into file TTX return data item LNERC to computed
	  field [TTXER1]BEN

	  ARGUMENTS:
	  . TJD System Processing Date	/TYP=D/REQ/MECH=VAL/HLP=[TTX]TJD

	  . BRCD Branch Code		/TYP=N/REQ/MECH=VAL/HLP=[TTX]BRCD,
					[TTXER1]BRCD

	  . UID User ID			/TYP=N/REQ/MECH=VAL/HLP=[TTX]UID,
					[TTXER1]UID

	  . TSEQ Transaction Sequence Number	/TYP=N/REQ/MECH=VAL/HLP=[TTX]
						TSEQ,[TTXER1]TSEQ
	  RETURNS:
	  . $$ Beneficiary		/TYP=T/HLP=[TTXER1]BEN
	  EXAMPLE:
	  $$TTXERBEN^PROCOMP(56994,1,2108,2001)
	*/

	if ($G(BRCD)="")!($G(UID)="")!($G(%SystemDate)="")!($G(TSEQ)="") quit ""
	new ben
	
	type RecordTTX ttx=Db.getRecord("TTX","TJD=:TJD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ")
	set ben=ttx.lnerc
	
	quit $P(ben,"#",6)
	
TTXERCOA(%SystemDate,BRCD,UID,TSEQ)
	/*
	  Provided the keys into file TTX retrieve data item TAMT and use
	  that field to return the value of COA.

	  ARGUMENTS:
	  . TJD System Processing Date	/TYP=D/REQ/MECH=VAL/HLP=[TTXFEP]TJD,
					[INTOSTR]TJD

	  . BRCD Branch Code		/TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]BRCD,
					[INTOSTR]BRCD

	  . UID User ID			/TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]UID,
					[INTOSTR]UID

	  . TSEQ Transaction Sequence Number /TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]
					      TSEQ,[INTOSTR]TSEQ

	  RETURNS:
	  . $$ Charge-off Amount 	/TYP=N/HLP= [TTXER1]COA,[INTRSTO]COA
	  EXAMPLE:
	  $$TTXERCOA^PROCOMP(56994,1,2108,2001)
	*/

	if ($G(BRCD)="")!($G(UID)="")!($G(%SystemDate)="")!($G(TSEQ)="") quit ""
	new tamt
	
	type RecordTTX ttx=Db.getRecord("TTX","TJD=:TJD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ")
	set tamt=ttx.tamt
	
	quit $P(tamt,"#",10)
	
TTXCORES(%SystemDate,BRCD,UID,TSEQ)
	/*
	  Provided the keys into file TTX retrieve data item TSO and use
	  it to return element CORES

	  ARGUMENTS:
	  . TJD System Processing Date	/TYP=D/REQ/MECH=VAL/HLP=[TTXFEP]TJD,
					[INTOSTR]TJD

	  . BRCD Branch Code 		/TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]BRCD,
					[INTOSTR]BRCD

	  . UID User ID			/TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]UID,
					[INTOSTR]UID

	  . TSEQ Transaction Sequence Number /TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]
					     TSEQ,[INTOSTR]TSEQ

	  RETURNS:
	  . $$ Charge-off Reason	/TYP=T/HLP=[TTXER1]CORES,[INTOSTR]CORES
	  EXAMPLE:
	  $$TTXCORES^PROCOMP(56994,1,2108,2001)
	*/

	if ($G(BRCD)="")!($G(UID)="")!($G(%SystemDate)="")!($G(TSEQ)="") quit ""
	new cores
	
	type RecordTTX ttx=Db.getRecord("TTX","TJD=:TJD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ")
	set cores=ttx.tso
		
	quit $P($P(cores,"CORES#",2),"~",1)
	
TTXDISC1(%SystemDate,BRCD,UID,TSEQ)
	
	/*
	  Provided the keys into file TTX retrieve data item TSO and use
	  it to return element DISC1

	  ARGUMENTS:
	  . TJD System Processing Date	/TYP=D/REQ/MECH=VAL/HLP=[TTXFEP]TJD

	  . BRCD Branch Code		/TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]BRCD

	  . UID User ID			/TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]UID

	  . TSEQ Transaction Sequence Number /TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]
					     TSEQ

	  RETURNS:
	  . $$ Discretionary Data 1	/TYP=T/HLP=[TTXER1]DISC1

	  EXAMPLE:
	  $$TTXDISC1^PROCOMP(56994,1,2108,2001)
	*/

	if ($G(BRCD)="")!($G(UID)="")!($G(%SystemDate)="")!($G(TSEQ)="") quit ""
	new desc
	
	type RecordTTX ttx=Db.getRecord("TTX","TJD=:TJD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ")
	set desc=ttx.disc1
	
	quit desc
	
TTXDISC2(%SystemDate,BRCD,UID,TSEQ)
	/*
	  Provided the keys into file TTX retrieve data item TSO and use
	  it to return element DISC2

	  ARGUMENTS:
	  . TJD System Processing Date	/TYP=D/REQ/MECH=VAL/HLP=[TTX]TJD

	  . BRCD Branch Code		/TYP=N/REQ/MECH=VAL/HLP=[TTX]BRCD

	  . UID User ID			/TYP=N/REQ/MECH=VAL/HLP=[TTX]UID

	  . TSEQ Transaction Sequence Number /TYP=N/REQ/MECH=VAL/HLP=[TTX]TSEQ

	  RETURNS:
	  . $$ [TTXER1]DISC2		/TYP=T
	   Discretionary Data 2
	  EXAMPLE:
	  $$TTXDISC2^PROCOMP(56994,1,2108,2001)
	*/
	
	if ($G(BRCD)="")!($G(UID)="")!($G(%SystemDate)="")!($G(TSEQ)="") quit ""
	new desc
	
	type RecordTTX ttx=Db.getRecord("TTX","TJD=:TJD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ")
	set desc=ttx.disc2
	
	quit desc
	
TTXERITC(%SystemDate,BRCD,UID,TSEQ,ITCLOC)
	/*
	  Provided the keys from [TTXER1] retrieve ITC from [TTX]
	  Using the variable ITCLOC return the appropiate extract of
	  [TTX]ITC

	  ARGUMENTS:
	  . TJD System Processing Date	/TYP=D/REQ/MECH=VAL/HLP=[TTXER1]TJD

	  . BRCD Branch Code		/TYP=N/REQ/MECH=VAL/HLP=[TTXER1]BRCD

	  . UID User ID			/TYP=N/REQ/MECH=VAL/HLP=[TTXER1]UID

	  . TSEQ Transaction Sequence Number /TYP=N/REQ/MECH=VAL/HLP=[TTXER1]
					     TSEQ

	  . ITCLOC  Numeric location of char to extract  /TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Internal Transaction Code EXTRACT /TYP=T/HLP[TTXER1]ITC*

	  EXAMPLE:
	  $$TTXERITC^PROCOMP(56994,1,2108,2001,1)
	*/

	if ($G(BRCD)="")!($G(UID)="")!($G(%SystemDate)="")!($G(TSEQ)="")!($G(ITCLOC)="") quit ""
	new itc
	
	type RecordTTX ttx=Db.getRecord("TTX","TJD=:TJD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ")
	set itc=ttx.itc
	
	quit $E(itc,ITCLOC)
	
TTXEEFD(%SystemDate,BRCD,UID,TSEQ)
	/*
	  Provided the keys into file TTX retrieve data item EFD. If this
	  field is null return the system date otherwise return its value.

	  ARGUMENTS:
	  . TJD System Processing Date	/TYP=D/REQ/MECH=VAL/HLP=[TTX]TJD

	  . BRCD Branch Code		/TYP=N/REQ/MECH=VAL/HLP=[TTX]BRCD

	  . UID User ID			/TYP=N/REQ/MECH=VAL/HLP=[TTX]UID

	  . TSEQ Transaction Sequence Number /TYP=N/REQ/MECH=VAL/HLP=[TTX]TSEQ

	  RETURNS:
	  . $$  Effective Date (Computed) /TYP=D/HLP=[TTXER1]EFDCMP

	  EXAMPLE:
	  $$TTXEEFD^PROCOMP(56994,1,2108,2001)
	*/

	new val
	if ($G(BRCD)="")!($G(UID)="")!($G(%SystemDate)="")!($G(TSEQ)="") set val=""
	else  do {
		type RecordTTX ttx=Db.getRecord("TTX","TJD=:TJD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ")
		set val=ttx.efd
	}
	quit $S(val:val,1:%SystemDate)
	
TTXEREC(%SystemDate,BRCD,UID,TSEQ)
	/*
	  Provided keys to TTX from TTXER1 retrieve TAMT from TTX file
	  and find value of REC entry within the TAMT. Return this value as
	  the computed field [TTXER1]REC.

	  ARGUMENTS:
	  . TJD System Processing Date	/TYP=D/REQ/MECH=VAL

	  . BRCD Branch Code		/TYP=N/REQ/MECH=VAL

	  . UID User ID			/TYP=N/REQ/MECH=VAL

	  . TSEQ Transaction Sequence Number /TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Recovery Amount		/TYP=N/HLP=[TTXER1]REC

	  EXAMPLE:
	  $$TTXEREC^PROCOMP(56994,1,2108,2001)
	*/

	if ($G(BRCD)="")!($G(UID)="")!($G(%SystemDate)="")!($G(TSEQ)="") quit ""
	new val
	
	type RecordTTX ttx=Db.getRecord("TTX","TJD=:TJD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ")
	set val=ttx.tamt
	
	quit $P(val,"#",11)
	
TTXERECS(%SystemDate,BRCD,UID,TSEQ)
	/*
	  Provided keys to TTX from TTXER1 retrieve TSO from TTX file
	  and find value of RECS entry within the TSO. Return this value as
	  the computed field [TTXER1]RECS.

	  ARGUMENTS:
	  . TJD System Processing Date	/TYP=D/REQ/MECH=VAL

	  . BRCD Branch Code		/TYP=N/REQ/MECH=VAL

	  . UID User ID			/TYP=N/REQ/MECH=VAL

	  . TSEQ Transaction Sequence Number /TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Recovery Source		/TYP=T/HLP=[TTXER1]RECS

	  EXAMPLE:
	  S RECS=$$TTXERECS^PROCOMP([TTXER1]TJD,[TTXER1]BRCD,[TTXER1]UID,
		 [TTXER1]TSEQ)
	  $$TTXERECS^PROCOMP(56994,1,2108,2001)
	*/

	if ($G(BRCD)="")!($G(UID)="")!($G(%SystemDate)="")!($G(TSEQ)="") quit ""
	new val
	
	type RecordTTX ttx=Db.getRecord("TTX","TJD=:TJD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ")
	set val=ttx.tso
	
	quit $P($P(val,"RECS#",2),"~",1)
	
UBALITC(%SystemDate,BRCD,UID,TSEQ,ITCLOC)
	/*
	  Provided the keys from [UBAL07] retrieve ITC from [TTXFEP]
	  Using the variable ITCLOC return the appropiate extract of
	  [TTXFEP]ITC

	  ARGUMENTS:
	  . TJD System Processing Date	/TYP=D/REQ/MECH=VAL/HLP=[TTXFEP]TJD

	  . BRCD Branch Code		/TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]BRCD

	  . UID User ID			/TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]UID

	  . TSEQ Transaction Sequence Number /TYP=N/REQ/MECH=VAL/HLP=[TTXFEP]
					     TSEQ

	  . ITCLOC  Numeric location of char extr /TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . Internal Transaction Code EXTRACT /TYP=T/HLP=[TTXFEP]ITC-subfields

	  EXAMPLE:
	  Return ITC3 from TTXFEP file
	  SRECS=$$UBALITC^PROCOMP([TTXER1]TJD,[TTXER1]BRCD,[TTXER1]UID,[TTXER1]
		TSEQ,3)
	  $$UBALITC^PROCOMP(56994,1,2108,2001,1)
	*/

	if ($G(BRCD)="")!($G(UID)="")!($G(%SystemDate)="")!($G(TSEQ)="")!($G(ITCLOC)="") quit ""
	new itc
	
	type RecordTTXFEP ttxfep=Db.getRecord("TTXFEP","TJD=:TJD,BRCD=:BRCD,UID=:UID,TSEQ=:TSEQ")
	set itc=ttxfep.itc
	
	quit $E(itc,ITCLOC)
	
POSTP(ACCRXNAM)
	/*
	  This function is used to return a logical if node 3 exists
	  at level three of UTBL with the literal key ACCRXPO.

	  ARGUMENTS:
	  . ACCRXNAM   Accrual Exit Name	/TYP=T/REQ/MECH=VAL/[UTBLACCRXP
						O]ACCRXNAM

	  RETURNS:
	  . $$ Existence of node 3 indicater	/TYP=L/HLP=[UTBLACCRXPO]POSTP

	  EXAMPLE:
	  $$POSTP^PROCOMP("AAA")
	*/

	if $G(ACCRXNAM)="" quit ""
	new exists
	
	type RecordUTBLACRXDTL utblacrxdtl=Db.getRecord("UTBLACRXDTL","ACCRXNAM=:ACCRXNAM,DTL=:3",1)
	if 'utblacrxdtl.getMode() quit ""
	
	set exists=utblacrxdtl.dtl
	
	set exists=$S(exists:1,1:0)
	quit exists
	
PREP(ACCRXNAM)
	/*
	  This function is used to return a logical if node 2 exists
	  at level three of UTBL with the literal key ACCRXPO.

	  ARGUMENTS:
	  . ACCRXNAM   Accrual Exit Name 	/TYP=T/REQ/MECH=VAL/[UTBLACCRXP
						O]ACCRXNAM

	  RETURNS:
	  . $$ Existence of node 2 indicater	/TYP=L/HLP=[UTBLACCRXPO]PREP

	  EXAMPLE:
	  $$PREP^PROCOMP("AAA")
	*/

	new exists
	if $G(ACCRXNAM)="" quit ""
	
	type RecordUTBLACRXDTL utblacrxdtl=Db.getRecord("UTBLACRXDTL","ACCRXNAM=:ACCRXNAM,DTL=:2",1)
	if 'utblacrxdtl.getMode() quit ""
	
	set exists=utblacrxdtl.dtl
	
	set exists=$S(exists:1,1:0)
	quit exists
	
URLCODE(ACCRXNAM)
	/*
	  This function is used to return a logical if node 1 exists
	  at level three of UTBL with the literal key ACCRXPO.

	  ARGUMENTS:
	  . ACCRXNAM   Accrual Exit Name 	/TYP=T/REQ/MECH=VAL/[UTBLACCRXP
						O]ACCRXNAM

	  RETURNS:
	  . $$ Existence of node 1 indicater	/TYP=L/HLP=[UTBLACCRXPO]URLCODE

	  EXAMPLE:
	  $$URLCODE^PROCOMP("AAA")
	*/

	if $G(ACCRXNAM)="" quit ""
	new exists
	
	type RecordUTBLACRXDTL utblacrxdtl=Db.getRecord("UTBLACRXDTL","ACCRXNAM=:ACCRXNAM,DTL=:1",1)
	if 'utblacrxdtl.getMode() quit ""
	
	set exists=utblacrxdtl.dtl
	
	set exists=$S(exists:1,1:0)
	quit exists
	
XXDESC(CLS,GRP)
	/*
	  Return Data item [STBLGRP]DES when provided GRP key from XCLSGRP

	  KEYWORDS:

	  ARGUMENTS:
	  . CLS Product Class	/TYP=T/REQ/MECH=VAL/HLP=[XCLSGRP]CLS

	  . GRP Product Group	/TYP=T/REQ/MECH=VAL/HLP=[XCLSGRP]GRP

	  RETURNS:
	  . $$ description	/TYP=T/HLP=[STBLGRP]DES

	  EXAMPLE:
	  $$XXDESC^PROCOMP("D","DDA")
	*/

	if $G(CLS)=""!($G(GRP)="") quit ""
	new des
		
	type RecordSTBLGRP stblgrp=Db.getRecord("STBLGRP","CLS=:CLS,GRP=:GRP")
	set des=stblgrp.des
	
	quit des
	
XTRNUCLS(ETC)
	/*
	  ARGUMENTS:
	  . ETC tran code		/TYP=T/REQ/MECH=VAL/HLP=[XTRN]ETC

	  RETURNS:
	  . $$ Tran Access allowed	/TYP=L/HLP=[XTRN]UCLS

	  INPUTS:

	  . %UCLS    User Class		/TYP=T
	  EXAMPLE:
	  $$XTRNUCLS("DW")
	*/

	if $G(ETC)="" quit ""
	if Db.isDefined("TRNAUT","ETC,""*""") quit 1
	if Db.isDefined("TRNAUT","ETC,%UCLS") quit 1
	quit 0
	
PUI(TRTYPE)
	/*
	  This function is to compute data item [LNTRS1]PUI

	  ARGUMENTS:
	  . TRTYPE Escrow Types		/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ Payee In Use Indicator	/TYP=T

	  EXAMPLE:
	  $$PUI^PROCOMP([LNTRS1]TRTYPE)
	  $$PUI^PROCOMP("IN")
	*/

	if $G(TRTYPE)="" quit ""
	type ResultSet rs=Db.select("TRTYPE","LNTRS","TRTYPE=:TRTYPE")
	if rs.isEmpty() quit 0
	quit 1
	
DESC2(XRID)
	/*
	  This function is used to compute data item [RDIST]DESC

	  ARGUMENTS:
	  . XRID Report Identificationd	/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ Description		/TYP=T

	  EXAMPLE:
	  $$DESC2^PROCOMP([RDIST]RID)
	  $$DESC2^PROCOMP("SCA220")
	*/

	if $G(XRID)="" quit ""
	new sdi
	
	type RecordDBTBL5SQ dbtbl5sq=Db.getRecord("DBTBL5SQ","%LIBS='SYSDEV',RID=:XRID")
	set sdi=dbtbl5sq.sdi
	
	quit sdi

DCOA(CID,SCND,FEECAT,FEETYP,ITM,COUNT,BASE,PLTP)
	/*
	  This function is used to compute data item [SRVDTL]DCOA

	  ARGUMENTS:
	  . CID  Account Number			/TYP=N/REQ/MECH=VAL

	  . SCND  Service Charge Next Date 	/TYP=D/REQ/MECH=VAL

	  . FEECAT Service Fee Category		/TYP=T/REQ/MECH=VAL

	  . ITM  Per Item Charge		/TYP=T/REQ/MECH=VAL

	  . COUNT  Number Of Times Applied	/TYP=N/REQ/MECH=VAL

	  . BASE  Base Charge Amount		/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$  Charge On Analysis - Amount	/TYP=N

	  EXAMPLE:
	  $$DCOA^PROCOMP([SRVDTL]CID,[SRVDTL]PLTP,[SRVDTL]SCND,[SRVDTL]FEECAT,[SRVDTL]FEETYP,
	  [SRVDTL]ITM,[SRVDTL]COUNT,[SRVDTL]BASE)
	  $$DCOA^PROCOMP(800012091,56978,2,"LDG",.5,2,1)
	*/

	if $G(CID)=""!($G(SCND)="")!($G(FEECAT)="")!($G(FEETYP)="") quit ""
	new DCOA,chgopt
	
	type RecordSRVD srvd=Db.getRecord("SRVD","CID=:CID,PLTP=:PLTP,SCND=:SCND,FEECAT=:FEECAT,FEETYP=:FEETYP")
	set chgopt=srvd.chgopt
	
	set DCOA=$S(chgopt=2:(ITM*COUNT)+BASE,1:0)
	quit DCOA
	
DOEA(CID,SCND,FEECAT,FEETYP,TOT,PLTP)
	/*
	  This function is used to compute data item [SRVDTL]DOEA

	  ARGUMENTS:
	  . CID		Account Number			/TYP=T/REQ/MECH=VAL

	  . FEECAT	Service Fee Category		/TYP=T/REQ/MECH=VAL

	  . FEETYP	Type Of Service Fee		/TYP=T/REQ/MECH=VAL

	  . TOT  	Total Charge			/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ Offset Earnings Allowance - Amount 	/TYP=N

	  EXAMPLE:
	  $$DOEA^PROCOMP([SRVDTL]CID,[SRVDTL]PLTP,[SRVDTL]SCND,[SRVDTL]FEECAT,[SRVDTL]FEETYP
	  ,[SRVDTL]TOT)
	  $$DOEA^PROCOMP(800012091,56978,2,"LDG",20)
	*/

	if $G(CID)=""!($G(SCND)="")!($G(FEECAT)="")!($G(FEETYP)="") quit ""
	new DOEA,chgopt
	
	type RecordSRVD srvd=Db.getRecord("SRVD","CID=:CID,PLTP=:PLTP,SCND=:SCND,FEECAT=:FEECAT,FEETYP=:FEETYP")
	set chgopt=srvd.chgopt
	
	set DOEA=$S(chgopt=3:TOT,1:0)
	quit DOEA
	
GLDESC(ACN)
	/*
	  This function is used to compute data item [TACCOUNT]GLDESC

	  ARGUMENTS:
	  . ACN General Ledger Number	/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ G/L Account Description	/TYP=T

	  EXAMPLE:
	  $$GLDESC^PROCOMP([TACCOUNT]ACN)
	  $$GLDESC^PROCOMP(29201)
	*/

	if $G(ACN)="" quit ""
	new desc1
	
	type RecordGLAD glad=Db.getRecord("GLAD","ACN=:ACN")
	set desc1=glad.desc1
		
	quit $E(desc1,1,35)
	
AMTTY(CID,SEQ)
	/*
	  This is used to compute data item [EFTREV2]AMTTYPDSC

	  ARGUMENTS:
	  . CID Account Number	/TYP=N/REQ/MECH=VAL

	  . SEQ Sequence	/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Amount Type Description	/TYP=N

	  EXAMPLE:
	  $$AMTTY^PROCOMP([EFTREV2]CID,[EFTREV2]SEQ)
	  $$AMTTY^PROCOMP(400,5)
	*/
	type Public String xamttyp
	
	if $G(CID)=""!($G(SEQ)="") quit ""
	new desc
	
	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ")
	set xamttyp=eftpay.amttyp
	
	type RecordSTBLAMTTYP stblamttyp=Db.getRecord("STBLAMTTYP","AMTTYP=:xamttyp")
	set desc=stblamttyp.desc
	
	quit desc
	
INVESCPC(CID,PSEQ,TSEQ)
	/*
	  This function is used to compute data item [LNLS6C]INVESCPCT

	  ARGUMENTS:
	  . CID		Loan Sold Account Number	/TYP=N/REQ/MECH=VAL

	  . PSEQ	Participation Seqence Number	/TYP=N/REQ/MECH=VAL

	  . TSEQ	Transaction Sequence Number	/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Investor's Escrow Change Percent		/TYP=N

	  EXAMPLE:
	  $$INVESCPC^PROCOMP([LNLS6C]CID,[LNLS6C]PSEQ,[LNLS6C]TSEQ)
	  $$INVESCPC^PROCOMP(800012369,1,1)
	*/

	if $G(CID)=""!($G(PSEQ)="")!($G(TSEQ)="") quit ""
	new crcd,INCD,PL,netescc,escpp
	
	type RecordLNTAMT lntamt=Db.getRecord("LNTAMT","CID=:CID,TSEQ=:TSEQ")
	set netescc=lntamt.netesccng
	
	type RecordLN ln=Db.getRecord("LN","CID=:CID")
	set crcd=ln.crcd
		
	type RecordLNLS6 lnls6=Db.getRecord("LNLS6","CID=:CID,PSEQ=:PSEQ")
	set INCD=lnls6.incd
	set PL=lnls6.pl
	
	if INCD="",PL="" quit ""
	
	type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:INCD,PL=:PL")
	set escpp=lnls2.escpp
	
	quit $$^SCARND((netescc*escpp/100),0,"",crcd)
	
INVINTPC(CID,PSEQ,TSEQ)
	/*
	  This function is used to compute data item [LNLS6C]INVINPCT

	  ARGUMENTS:
	  . CID		Loan Sold Account Number	/TYP=N/REQ/MECH=VAL

	  . PSEQ	Participation Seqence Number	/TYP=N/REQ/MECH=VAL

	  . TSEQ	Transaction Sequence Number	/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$  	INVINTPCT  			/TYP=N

	  EXAMPLE:
	  $$INVINTPC^PROCOMP([LNLS6C]CID,[LNLS6C]PSEQ,[LNLS6C]TSEQ)
	  $$INVINTPC^PROCOMP(800012369,1,1)
	*/
	
	if $G(CID)=""!($G(PSEQ)="")!($G(TSEQ)="") quit ""
	new pp,crcd,INCD,PL,NETINTC,data,XTAMT,INTCOL,INTRED,INTCOLRED
	set XTAMT=$$TAMT^LNCO3(CID,TSEQ)
	set INTCOL=$P(XTAMT,$C(124),3)
	set INTCOLRED=$P(XTAMT,$C(124),4)
	set NETINTC=INTCOL-INTCOLRED
	
	type RecordLNLS6 lnls6=Db.getRecord("LNLS6","CID=:CID,PSEQ=:PSEQ")
	set INCD=lnls6.incd
	set PL=lnls6.pl
	
	if INCD="",PL="" quit ""
	
	type RecordLN ln=Db.getRecord("LN","CID=:CID")
	set crcd=ln.crcd
	
	type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:INCD,PL=:PL")
	set pp=lnls2.pp
	
	quit $$^SCARND((NETINTC*pp/100),0,"",crcd)
	
INVPRNPC(CID,PSEQ,TSEQ)
	/*
	  This function is used to compute data item [LNLS6C]INVPRNPCT

	  ARGUMENTS:
	  . CID		Loan Sold Account Number	/TYP=N/REQ/MECH=VAL

	  . PSEQ	Participation Seqence Number	/TYP=N/REQ/MECH=VAL

	  . TSEQ	Transaction Sequence Number	/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ 		Investor's Principal Change Percent	/TYP=N

	  EXAMPLE:
	  $$INVPRNPC^PROCOMP([LNLS6C]CID,[LNLS6C]PSEQ,[LNLS6C]TSEQ)
	  $$INVPRNPC^PROCOMP(800012369,1,1)
	*/

	if $G(CID)=""!($G(PSEQ)="")!($G(TSEQ)="") quit ""
	new data,crcd,INCD,PL,NETPRNC,pp,XTAMT,PRNRED,PRNINC
	set XTAMT=$$TAMT^LNCO3(CID,TSEQ)
	set PRNRED=$P(XTAMT,$C(124),1)+$P(XTAMT,$C(124),10)
	set PRNINC=$P(XTAMT,$C(124),2)+$P(XTAMT,$C(124),9)
	set NETPRNC=PRNRED-PRNINC
	
	type RecordLNLS6 lnls6=Db.getRecord("LNLS6","CID=:CID,PSEQ=:PSEQ")
	set INCD=lnls6.incd
	set PL=lnls6.pl
	
	if INCD="",PL="" quit ""
	
	type RecordLN ln=Db.getRecord("LN","CID=:CID")
	set crcd=ln.crcd
	
	type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:INCD,PL=:PL")
	set pp=lnls2.pp
	
	quit $$^SCARND((NETPRNC*pp/100),0,"",crcd)
	
DSTATDSC(STATDSC)
	/*
	  Return the status description from the table STBLDSTAT

	  KEYWORDS:

	  ARGUMENTS:
	  . STATDSC Status		/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Description of status	/TYP=T

	  EXAMPLE:
	  $$DSTATDSC^PROCOMP(3)
	  $$DSTATDSC^PROCOMP([NOSTTRF]STATUS)

	  if $G(STATDSC)="" quit ""
	  new desc
	  set desc=Db.getOneRow("DESC","STBLDSTAT","STATDSC")
	  quit desc
	*/
	
	if $G(STATDSC)="" quit ""
	new desc
	
	type RecordSTBLDSTAT stbldstat=Db.getRecord("STBLDSTAT","DSTAT=:STATDSC")
	set desc=stbldstat.desc
	
	quit desc

PATFREQ(PATSRC)
	/*
	  Return the Posting frequency of a PAT source

	  KEYWORDS:

	  ARGUMENTS:
	  . PATSRC Source Code		/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ PAT Posting Frequency	/TYP=T

	  EXAMPLE:
	  $$PATFREQ^PROCOMP("1MA1")
	  $$PATFREQ^PROCOMP([PAT]SRC)
	*/

	if $G(PATSRC)="" quit ""
	
	type RecordUTBLSRC utblsrc=Db.getRecord("UTBLSRC","SRCTYP='PAT',KEY=:PATSRC")
	
	quit utblsrc.freq


PATLPD(PATSRC)
	/*
	  Return the last Posting date of a PAT source

	  KEYWORDS:

	  ARGUMENTS:
	  . PATSRC Source Code		/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ PAT Last Posting Date	/TYP=D

	  EXAMPLE:
	  $$PATLPD^PROCOMP("1MA1")
	  $$PATLPD^PROCOMP([PAT]SRC)
	*/

	if $G(PATSRC)="" quit ""
	
	type RecordUTBLSRC utblsrc=Db.getRecord("UTBLSRC","SRCTYP='PAT',KEY=:PATSRC")
	
	quit utblsrc.lpd


PATNPD(PATSRC)
	/*
	  Return the next Posting date of a PAT source

	  KEYWORDS:

	  ARGUMENTS:
	  . PATSRC Source Code		/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ PAT Last Posting Date	/TYP=D

	  EXAMPLE:
	  $$PATNPD^PROCOMP("1MA1")
	  $$PATNPD^PROCOMP([PAT]SRC)
	*/

	if $G(PATSRC)="" quit ""
	
	type RecordUTBLSRC utblsrc=Db.getRecord("UTBLSRC","SRCTYP='PAT',KEY=:PATSRC")
	
	quit utblsrc.npd


PHLDDESC(PHC)
	/*
	  Return the description of a permanent hold code from the
	  UTBLPHC table.

	  KEYWORDS:

	  ARGUMENTS:
	  . PHC Permanent Hold Code	/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Hold Description		/TYP=T

	  EXAMPLE:
	  $$PHLDDESC^PROCOMP(1)
	  $$PHLDDESC^PROCOMP([PHLD]PHC)
	*/

	if $G(PHC)="" quit ""
	new desc
	
	type RecordUTBLPHC utblphc=Db.getRecord("UTBLPHC","PHC=:PHC")
	set desc=utblphc.desc
	
	quit desc
	
RESPDT(TRREF,TYPE)
	/*
	  Return response date from swift file

	  KEYWORDS:

	  ARGUMENTS:
	  . TRREF	Transaction Reference Number	/TYP=T/REQ/MECH=VAL

	  . TYPE	Message Type			/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ 		Response Date			/TYP=D

	  EXAMPLE:
	  $$RESPDT^PROCOMP(1000029605,100)
	  $$RESPDT^PROCOMP([REPTBL]TRREF,[REPTBL]TYPE)
	*/

	if $G(TRREF)=""!($G(TYPE)="") quit ""
	new rdate
	
	type RecordSWIFT swift=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:TRREF,MSG=:TYPE")
	set rdate=swift.date
	
	quit rdate

SWFTDT(TRREF,TYPE)
	/*
	  Return data item SWIFT.SWFTDT as a computed field for other files
	  associated with the SWIFT file.

	  KEYWORDS:

	  ARGUMENTS:
	  . TRREF	Transaction Reference Number	/TYP=T/REQ/MECH=VAL

	  . TYPE	Message Type			/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$		Message Transfer Date		/TYP=D

	  EXAMPLE:
	  $$SWFTDT^PROCOMP(1000029605,100)
	  $$SWFTDT^PROCOMP([REPTBL]TRREF,[REPTBL]TYPE)
	*/

	if $G(TRREF)=""!($G(TYPE)="") quit ""
	new rdate
	
	type RecordSWIFT swift=Db.getRecord("SWIFT","SWDIRECT='OUT',TRREFNO=:TRREF,MSG=:TYPE")
	set rdate=swift.swftdt
	
	quit rdate

UIDNAME(UID)
	/*
	  Return tellers name from the SCAU file

	  KEYWORDS:

	  ARGUMENTS:
	  . UID		User ID		/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$		User Full Name	/TYP=T

	  EXAMPLE:
	  $$UIDNAME^PROCOMP("2108")
	  $$UIDNAME^PROCOMP([SCALIB2]UID)
	*/

	if $G(UID)="" quit ""
	new name
	
	type RecordSCAU scau=Db.getRecord("SCAU","UID=:UID")
	set name=scau.%ufn
	
	quit name

BALNEGY(%SystemDate,CRCD,CLS,GRP,TYPE,GLSC,CC)
	/*
	  Return the value of BALNEG from yesterdays TTL file. This is
	  the computed field BALNEGY.

	  KEYWORDS:

	  ARGUMENTS:
	  . TJD		System Processing Date	/TYP=D/REQ/MECH=VAL

	  . CRCD	Currency Code		/TYP=T/REQ/MECH=VAL

	  . CLS		Product Class		/TYP=T/REQ/MECH=VAL

	  . GRP		Product Group		/TYP=T/REQ/MECH=VAL

	  . TYPE	Product Type		/TYP=N/REQ/MECH=VAL

	  . GLSC	GLSC			/TYP=T/REQ/MECH=VAL
	
	  . CC		Cost Center		/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Previous Day's Negative Balance Accum /TYP=$

	  EXAMPLE:
	  $$BALNEGY^PROCOMP(56993,"USD","D","DDA",411,"400A",1)
	  $$BALNEGY^PROCOMP([TTL]TJD,[TTL]CRCD,[TTL]CLS,[TTL]GRP,[TTL]TYPE,
	  [TTL]GLSC,[TTL]CC)
	*/

	if $G(%SystemDate)=""!($G(CRCD)="")!($G(CLS)="")!($G(GRP)="")!($G(TYPE)="")!($G(GLSC)="")!($G(CC)="") quit ""
	new neg

	/*
	   Retrieve yesterdays negative balance by subtracting one from the 
	   date provided.
	*/
	new SAVTJD
	set SAVTJD=%SystemDate
	#ACCEPT DATE=12/1703; PGM=RussellDS
	set %SystemDate=%SystemDate-1
	
	type RecordTTL ttl=Db.getRecord("TTL","TJD=:TJD,CRCD=:CRCD,CLS=:CLS,GRP=:GRP,TYPE=:TYPE,GLSC=:GLSC,CC=:CC")
	set neg=ttl.balneg
	
	#ACCEPT DATE=12/1703; PGM=RussellDS
	set %SystemDate=SAVTJD
	quit neg

ERDESC(ET)
	/*
	  Retrieve description from STBLXBAD

	  KEYWORDS:

	  ARGUMENTS:
	  . ET Discrepancy Reason   		/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ Description of XBAD error	/TYP=T

	  EXAMPLE:
	  $$ERDESC^PROCOMP("XIRA")
	  $$ERDESC^PROCOMP([UVER]ET)
	*/

	if $G(ET)="" quit ""
	new desc
	
	type RecordSTBLXBAD stblxbad=Db.getRecord("STBLXBAD","KEY=:ET")
	set desc=stblxbad.desc
	
	quit desc

TRNSGT(ETC)
	/*
	  KEYWORDS:

	  ARGUMENTS:
	  . ETC		Transaction Code	/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ System-Generated Transaction 	/TYP=T

	  EXAMPLE:
	  $$TRNSGT^PROCOMP("DW")
	  $$TRNSGT^PROCOMP([XTRN]ETC)
	*/
	
	if $G(ETC)="" quit ""
	new sgt
	
	type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC")
	set sgt=trn.sgt
	
	quit sgt

STATDESC(STAT)
	/*
	  This function is used to compute data item [ARS]STATDESC

	  ARGUMENTS:
	  . STAT  Check Status   	/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Check Status Description /TYP=T

	  EXAMPLE:
	  $$STATDESC^PROCOMP(4)
	  $$STATDESC^PROCOMP([ARS]STAT)
	*/

	if $G(STAT)="" quit ""
	new desc
	
	type RecordSTBLARSSTAT stblarsstat=Db.getRecord("STBLARSSTAT","STAT=:STAT")
	set desc=stblarsstat.desc
	
	quit $S($L(STAT):desc,1:"")
	
DEALDESC(TYPE)
	/*
	  This function is used to compute data item [DEAL1]DEALDESC

	  ARGUMENTS:
	  . TYPE 	Deal Type	/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ 	Deal Description	/TYP=T

	  EXAMPLE:
	  $$DEALDESC^PROCOMP("SPOT")
	  $$DEALDESC^PROCOMP([DEAL1]TYPE)
	*/

	if $G(TYPE)="" quit ""
	new desc
	
	type RecordSTBLDEALTYPE stbldealtype=Db.getRecord("STBLDEALTYPE","DTYPE=:TYPE")
	set desc=stbldealtype.desc
	
	quit desc
	
STATDSC1(STATUS)
	/*
	  This function is used to compute [DEAL1]STATDSC data item.

	  ARGUMENTS:
	  . STATUS	Status		/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$   Status Description	/TYP=T

	  EXAMPLE:
	  $$STATDSC1^PROCOMP(8)
	  $$STATDSC1^PROCOMP([DEAL1]STATUS)
	*/

	if $G(STATUS)="" quit ""
	new desc
	
	type RecordSTBLDSTAT stbldstat=Db.getRecord("STBLDSTAT","DSTAT=:STATUS")
	set desc=stbldstat.desc
	
	quit desc
	
CIFBOO(CIFACN,CLS)
	/*
	  This function is used to compute [DTJNA]CIFBOO data item.

	  ARGUMENTS:
	  . CIFACN	CIF Account Number	/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$   Account Branch of Ownership	/TYP=N

	  EXAMPLE:
	  $$CIFBOO^PROCOMP(2424)
	  $$CIFBOO^PROCOMP([DTJNA]CIFACN)
	*/

	if $G(CIFACN)="" quit ""
	new boo
	
	if CLS="*" do {
		type RecordCIF cif=Db.getRecord("CIF","ACN=:CIFACN")
		set boo=cif.boo
	}
	if CLS'="*" do	{
		type RecordACN acn=Db.getRecord("ACN","CID=:CIFACN")
		set boo=acn.boo
	}
	
	quit boo
	
CIFCODE(CIFACN)
	/*
	  This function is used to compute [DTJNA]CIFCODE data item.

	  ARGUMENTS:
	  . CIFACN	CIF Account Number	/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$		CIF Customer Code	/TYP=T

	  EXAMPLE:
	  $$CIFCODE^PROCOMP(2424)
	  $$CIFCODE^PROCOMP([DTJNA]CIFACN)
	*/

	if $G(CIFACN)="" quit ""
	new cifcode
	
	type RecordCIF cif=Db.getRecord("CIF","ACN=:CIFACN")
	set cifcode=cif.ccode
	
	quit cifcode
	
XAMTTYPD(AMTTYP)
	/*
	  This function is used to compute [EFTPAY]AMTTYPDSC data item.

	  ARGUMENTS:
	  . AMTTYP        Amount Type	/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Amount Type Description	/TYP=T

	  EXAMPLE:
	  $$XAMTTYPD^PROCOMP(3)
	  $$XAMTTYPD^PROCOMP([EFTPAY]AMTTYP)
	*/

	if $G(AMTTYP)="" quit ""
	new desc
	
	type RecordSTBLAMTTYP stblamttyp=Db.getRecord("STBLAMTTYP","AMTTYP=:AMTTYP")
	set desc=stblamttyp.desc
	
	quit desc
	
EFTDESC(EFTTYPE)
	/*
	  This function is used to compute [EFTPAY]EFTDESC, data
	  item.

	  ARGUMENTS:
	  . EFTTYPE	Electronic Payment Type		/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ 		EFT Type Description		/TYP=T

	  EXAMPLE:
	  $$EFTDESC^PROCOMP("PO")
	  $$EFTDESC^PROCOMP([EFTPAY]EFTTYPE)
	*/

	if ($G(EFTTYPE)="") quit ""
	new desc
	
	type RecordCTBLEFTTYPE ctblefttype=Db.getRecord("CTBLEFTTYPE","KEY=:EFTTYPE")
	set desc=ctblefttype.desc
	
	quit desc
	
XINSTNAM(RECINST)
	/*
	  This function is used to compute [EFTPAY]INSTNAM data item.

	  ARGUMENTS:
	  . RECINST	Recipient Institution	/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ Recipient Institution Name  	/TYP=T
	
	  EXAMPLE:
	  $$XINSTNAM^PROCOMP([EFTPAY]RECINST)
	  $$XINSTNAM^PROCOMP(300)
	*/

	if ($G(RECINST)="") quit ""
	new nam
	
	type RecordUTBLEFTINST utbleftinst=Db.getRecord("UTBLEFTINST","KEY=:RECINST")
	set nam=utbleftinst.nam
	
	quit nam
	
XSRCDSC(EFTTYPE)
	/*
	  This function is used to compute [EFTPAY]SRCDSC data item.

	  ARGUMENTS:
	  . EFTTYPE	Electronic Payment Type		/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$		Source Description		/TYP=T

	  EXAMPLE:
	  $$XSRCDSC^PROCOMP([EFTPAY]EFTTYPE)
	  $$XSRCDSC^PROCOMP("PO")
	*/

	if ($G(EFTTYPE)="") quit ""
	new fincl
	
	type RecordCTBLEFTTYPE ctblefttype=Db.getRecord("CTBLEFTTYPE","KEY=:EFTTYPE")
	set fincl=ctblefttype.fincl
	
	quit fincl
	
XMETDSC(MET)
	/*
	  This function is used to compute [EFTPAY]METDSC data item.

	  ARGUMENTS:
	  . MET		Payment System		/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ Payment Method Description	/TYP=T

	  EXAMPLE:
	  $$XMETDSC^PROCOMP([EFTPAY]MET)
	  $$XMETDSC^PROCOMP("CC")
	*/
	
	if $G(MET)="" quit ""
	new desc
	
	type RecordSTBLPAYMET stblpaymet=Db.getRecord("STBLPAYMET","KEY=:MET")
	set desc=stblpaymet.desc
	
	quit desc
	
XSTATDSC(STATUS)
	/*
	  This function is used to compute [EFTPAY]STATDSC data item.

	  ARGUMENTS:
	  . STATUS	Status		/TYP=T/REQ/MECH=VAL

	  RETURNS:
	  . $$ Status Description	/TYP=T

	  EXAMPLE:
	  $$XSTATDSC^PROCOMP([EFTPAY]STATUS)
	  $$XSTATDSC^PROCOMP("A")
	*/
	
	if ($G(STATUS)="") quit ""
	new desc
	
	type RecordSTBLESTAT stblestat=Db.getRecord("STBLESTAT","STATUS=:STATUS")
	set desc=stblestat.desc
	
	quit desc
	
EFTTYPE(CID,SEQ)
	/*
	  This function is used to compute [EFTREF]EFTTYPE data item.

	  ARGUMENTS:
	  . CID	Account Number		/TYP=N/REQ/MECH=VAL
	  . SEQ Sequence Number		/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ EFT Type			/TYP=T

	  EXAMPLE:
	  $$EFTTYPE^PROCOMP([EFTREF]CID,[EFTREF]SEQ)
	  $$EFTTYPE^PROCOMP(4000000515,5)
	*/

	if $G(CID)=""!($G(SEQ)="") quit ""
	new efttype
	
	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ")
	set efttype=eftpay.efttype
	
	quit efttype
	
XSTATUS(CID,SEQ)
	/*
	  This function is used to compute [EFTPAY]STATUS data item.

	  ARGUMENTS:
	  . CID Account Number		/TYP=N/REQ/MECH=VAL
	  . SEQ Sequence Number		/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ Status			/TYP=T

	  EXAMPLE:
	  $$XSTATUS^PROCOMP([EFTREF]CID,[EFTREF]SEQ)
	  $$XSTATUS^PROCOMP(4000000515,5)
	*/

	if $G(CID)=""!($G(SEQ)="") quit ""
	new status
	
	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID=:CID,SEQ=:SEQ")
	set status=eftpay.status
	
	quit status
	
	
TAXID(ACN)
	/*
	  This function is used to compute [INVCIF]TAXID data item.

	  ARGUMENTS:
	  . ACN	Customer Number		/TYP=N/REQ/MECH=VAL

	  RETURNS:
	  . $$ TIN/SINC			/TYP=T

	  EXAMPLE:
	  $$TAXID^PROCOMP([INVCIF]ACN)
	  $$TAXID^PROCOMP(4882)
	*/
	
	if $G(ACN)="" quit ""
	new taxid
		
	type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN")
	set taxid=cif.taxid
	
	quit taxid
	
public MPSCERT()
        /*
         This function is used to compute [CUVAR]MPSCERT data Item.
       
         ARGUMENTS:
         

         RETURNS:
         . $$ CUVAR.MPSCERT                 /TYP=T
       
         EXAMPLE:
         $$MPSCERT^PROCOMP
        */

	type String mpscert

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
	set mpscert=cuvar.mpscert

	quit mpscert

vSIG()	quit "60571^26671^Ravindra Rathi^42645"	// Signature - LTD^TIME^USER^SIZE
