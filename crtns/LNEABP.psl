LNEABP	// POST ESCROW ANALYSIS BATCH
	/*
	   ORIG:  Chuck Hardy (6721) - 09/25/86
	   DESC:  Post Escrow Analysis Batch

	  ---- Revision History ------------------------------------------------
	   02/15/07 - RussellDS - CR25382
		      Eliminated use of obsoleted routine DBSQRYA.  Added code
		      to make use of queries.
		   
	   02/10/06 - Srinivar - CR19137
	   	      Modified the look up table for APCND.
	   	      Changed the runtime routine from LNEBP to LNEABP
	   	   
	   12/09/03 - CARROLLJ - CR7239
		      Modified call to NXE to pass loan object.		    

	   08/01/02 - SHVACHKINAD/GRAY - 49794
		      Converted to PSL.

	   07/20/00 - DOUGANM- 39582
	              To improve the performance of error handling, cleaned up
	              call to $$NEW^%ZT, and removed use of indirection.

	   04/07/00 - LAMY - 37856
	              Fix code in NXC section to correct an undefine error.

	   02/10/98 - SPIER - 26685
	              Replaced skl-load calls with select^sql

	   01/15/98 - Terrie Dougherty - 26277
	              Modified section 3 and EXECE to move the field PE??NA to
	       	      DEP.REC

	*/

        catch vError {
		new ET
                set ET=vError.type
                // Log MUMPS error
                do ZE^UTLERR
		// Log exception
		do EXC
		}

	set %EffectiveDate=%SystemDate

	do INIT
	quit

INIT	
	new %READ,%TAB
	set (%PG,%PAGE)=0
	kill VFMQ
	do VPG
	quit

VPG	// Page control

	if %PG=0 do VPG00 
	do VPG0 
	quit

VPG0	// Process completed/aborted

	if "DFQ"[VFMQ do VER quit
	set %PG=%PG+1
	do VPG 
	quit

VPG00	// Set up

	set %TAB("APCND")=".APCND1/HLP=[LN]APCND/TBL=[LNAPCHG]APCND:DISTINCT"
	set %TAB("BOO")=".A5/HLP=[LN]BOO/XPP=D EXT^DBSQRY"
	set %TAB("TYPE")=".QI1/HLP=[LN]TYPE/XPP=D EXT^DBSQRY"
	set %TAB("EFD")=".EFD4"

	set %READ="@@%FN,,,APCND/REQ,BOO/REQ,TYPE/REQ,EFD/REQ"
	do ^UTLREAD 
	if VFMQ="Q" quit

	quit

ERR	//
	set ER=1 
	do ^UTLERR
	set VFMQ="Q"
	quit

VER	// Main module

	new BRCD,KEY,SRC,TPD

	if VFMQ="Q" do END quit

	set SRC="ESCR"
	set KEY="ALL"
	
	do SOURCE^BCHSOURC(SRC,KEY,.%UserID,.BRCD,.%UserClass)

	type RecordTPCTRL tpctrl=Db.getRecord("TPCTRL","BRCD=:BRCD,UID=:%UserID,TPD=:%SystemDate",1)
	set TPD=tpctrl.pmdate 
	if TPD="" set TPD=%SystemDate

	do ^TTXLOK 
	if ER do ERR do END quit

	do FILE
	do END 

	quit

FILE	//

	new APCK,APS,APSE,APSL,APTC,APTD,ESCCHK,ESCGL

	if 'Db.isDefined("TTXUID","TJD=:%SystemDate,BRCD=:BRCD,UID=:%UserID") do {
		type RecordTTXUID ttxuid=Class.new("RecordTTXUID")
		set ttxuid.tjd=%SystemDate
		set ttxuid.brcd=BRCD
		set ttxuid.uid=%UserID
		do ttxuid.bypassSave()
		}

	set TRC=Db.currVal("TTX","TJD=:%SystemDate,BRCD=:BRCD,UID=:%UserID")
	set TRC=TRC\1000*1000+1000

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

	set APS=$$DAT^%ZM(APCND,$G(%MSKD))

	// ~p1 Analysis deficit
	set APSL=$$^MSG(4079,APS)

	// Reduce ~p1  deficit
	set APSE=$$^MSG(4076,APS)

	// Transfer to ~p1
	set APTD=$$^MSG(3940)

	// Transfer from ~p1
	set APTC=$$^MSG(3939)

	// Escrow Overage Check
	set APCK=$$^MSG(8628)

	// Escrow check type and G/L account
	set ESCCHK=cuvar.escchk 
	set ESCGL=cuvar.escgl

	do NXC
	quit

NXC	// Create Analysis Payment Change Batch records

	type public String BOO, TYPE
	
	type Number QRYSEQ
	type String DQQRY(), TABLES, WHERE
	
	set QRYSEQ = 0
	if (BOO '= "ALL") do {
	
		set QRYSEQ = QRYSEQ + 1
		set DQQRY(QRYSEQ) = "[LN]BOO "_BOO
	}
	if (TYPE '= "ALL") do {
	
		set QRYSEQ = QRYSEQ + 1
		set DQQRY(QRYSEQ) = "[LN]TYPE "_TYPE
	}
	
	set WHERE = "LNAPCHG.APCND=:APCND"
	set TABLES = "LNAPCHG"
	if (QRYSEQ > 0) do {
		
		set WHERE = WHERE_" AND "_$$WHERE^SQLCONV(.DQQRY(), "LNAPCHG,LN")
		set WHERE = WHERE_" AND LN.CID=LNAPCHG.CID"
		set TABLES = TABLES_",LN"
	}

	#ACCEPT Date=02/16/07;Pgm=RussellDS;CR=25356;Group=Dynamic
	type ResultSet lnapchgrs=Db.select("CID", TABLES, WHERE)
	
	if lnapchgrs.isEmpty() quit

	while lnapchgrs.next() do {
		new BILETC,BILTC,CRCD,DEBETC,DEBTC,EOETC,EOTC,EWETC,EWTC,TYPE

                set LCID=lnapchgrs.getCol(1)

		//Check posting flag prior to processing.  Skip if set.
		type RecordLNAPCHG lnapchg=Db.getRecord("LNAPCHG","APCND=:APCND,CID=:LCID")
		if lnapchg.epost quit

		type RecordLN ln=Db.getRecord("LN","CID=:LCID")

		// Product Type
		set TYPE=ln.type
		// Currency Code
		set CRCD=ln.crcd 
		if CRCD="" set CRCD=%SystemCurrency

		type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
		set DEBTC=prodctl.drtrcd
		set BILTC=prodctl.drtrdm
		set EOTC=prodctl.crtrts
		set EWTC=prodctl.drtrts

		type RecordTRN trn=Db.getRecord("TRN","ETC=:DEBTC")
		type RecordTRN trn1=Db.getRecord("TRN","ETC=:BILTC")
		type RecordTRN trn2=Db.getRecord("TRN","ETC=:EOTC")
		type RecordTRN trn3=Db.getRecord("TRN","ETC=:EWTC")
		set DEBETC=trn.itc
		set BILETC=trn1.itc
		set EOETC=trn2.itc
		set EWETC=trn3.itc

		do EXEC(.ln,.lnapchg)
		}

	do POST
	quit

EXEC(RecordLN ln,RecordLNAPCHG lnapchg)	

	/*
	  Process loan accounts
 
	ARGUMENTS:
		. lnapchg   Analysis Payment Change Batch Data Object    TYP=RecordLNAPCHG/REQ
	*/
 
        catch vError {
                new ET
                set ET=vError.type
                // Log MUMPS error
                do ZE^UTLERR
                // Log exception
                do EXC
                }

	lock +ACN(LCID):2 else  do { quit
		set ER=1 
		// Record locked by another user
		set ET="RECLOC" 
		do EXC
		}

	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID=:LCID")
	
	do NXE(.ln,.lnbil0)

	// Set posted flag
	set lnapchg.epost=1
	do lnapchg.bypassSave()
	quit

NXE(RecordLN ln,RecordLNBIL0 lnbil0)

	/*
	 Create Analysis Payment Change Batch Escrow records
 
	ARGUMENTS:
		. ln       Loan Account Object           TYP=RecordLN/REQ
		. lnbil0   Internal Bill Control Object  TYP=RecordLNBIL0/REQ
	*/

	type ResultSet lnapchgers=Db.select("ECID","LNAPCHGE","APCND=:APCND AND CID=:LCID")
	if lnapchgers.isEmpty() do ND quit

	while lnapchgers.next() do {
		set ECID=lnapchgers.getCol(1)

		type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")

		// Account is closed, delete record from LNAPCHGE
		if dep.stat=4 do Db.delete("LNAPCHGE","APCND=:APCND AND CID=:LCID AND ECID=:ECID") quit

		do EXECE(.ln,.dep,.lnbil0)
		}

	do NC(.ln,.lnbil0)
	quit

EXECE(RecordLN ln,RecordDEP dep,RecordLNBIL0 lnbil0)

	/*
	  Process escrow accounts
 
	ARGUMENTS:
		. ln         Loan Account Object           TYP=RecordLN/REQ
		. dep 	     Deposit Account Object        TYP=RecordDEP/REQ
		. lnbil0     Internal Bill Control Object  TYP=RecordLNBIL0/REQ
	*/

        catch vError {
                new ET
                set ET=vError.type
                // Log MUMPS error
                do ZE^UTLERR
                // Log exception
                do EXC
                }

	new AMT,SVUX
	
	type RecordLNAPCHGE lnapchge
        set lnapchge=Db.getRecord("LNAPCHGE","APCND=:APCND,CID=:LCID,ECID=:ECID")

	set AMT=lnapchge.amtd if AMT do BLDTTX1(.ln,.dep) set AMT=0 do UPD(.lnapchge,.lnbil0)
	set AMT=lnapchge.amtb if AMT do BLDTTX2(.ln,.dep) set AMT=0 do UPD(.lnapchge,.lnbil0)
	set AMT=lnapchge.amtl do UPD(.lnapchge,.lnbil0)

	set AMT=lnapchge.amtc 
	if AMT do CHECK(.ln,.dep)

	if $D(SVUX(ECID)) set dep.recamt=SVUX(ECID)
	set dep.remtot=lnapchge.remtot
	set dep.anpdt=dep.andt
	set dep.andt=APCND
	do dep.save()
	quit

BLDTTX1(RecordLN ln,RecordDEP dep)

	/*
 
	ARGUMENTS:
		. ln            Loan Account Object       TYP=RecordLN/REQ
		. dep 		Deposit Account Object    TYP=RecordDEP/REQ
	*/
 
	set TRC=TRC+1
	set TRTYP=dep.esc
	type RecordTTX ttx=Class.new("RecordTTX")
	do TTX(.ttx,.ln)
	set ttx.itc=DEBETC
	set ttx.etc=DEBTC
	set ttx.tcmt=APSL
	do ttx.bypassSave()

	set TRC=TRC+1
        type RecordTTX ttx2=Class.new("RecordTTX")
	do TTX(.ttx2,.ln)
        set ttx2.itc=EOETC
        set ttx2.etc=EOTC
        set ttx2.tcmt=APSE
	do ttx2.bypassSave()

	quit

BLDTTX2(RecordLN ln,RecordDEP dep)

	/*
 
	ARGUMENTS:
		. ln            Loan Account Object     TYP=RecordLN/REQ
 		. dep           Deposit Account Object    TYP=RecordDEP/REQ
	*/		

	set TRC=TRC+1
	set TRTYP=dep.esc
        type RecordTTX ttx=Class.new("RecordTTX")
	do TTX(.ttx,.ln)
        set ttx.itc=BILETC
        set ttx.etc=BILTC
        set ttx.tcmt=APSL
        do ttx.bypassSave()

	set TRC=TRC+1
        type RecordTTX ttx2=Class.new("RecordTTX")
	do TTX(.ttx2,.ln)
	set ttx2.itc=EOETC
        set ttx2.etc=EOTC
        set ttx2.tcmt=APSE
        do ttx2.bypassSave()

	quit

TTX(RecordTTX ttx,RecordLN ln)	

	/*
	  Create common fields in TTX record

	 ARGUMENTS:
		. ttx      Teller Transaction Object  TYP=RecordTTX/REQ		
		. ln       Loan Account Object        TYP=RecordLN/REQ
	*/

        set ttx.tjd=%SystemDate
        set ttx.brcd=BRCD
        set ttx.uid=%UserID
        set ttx.tseq=TRC
        set ttx.cid=LCID
        set ttx.tamt=AMT
        set ttx.efd=%EffectiveDate
        set ttx.tlo=%UserStation
        set ttx.tso="ESC#"_TRTYP
        set ttx.cdt=+%CurrentDate
        set ttx.tim=%CurrentTime
        set ttx.brcde=BRCD
        set ttx.trc=TRC
        set ttx.uidt=%UserID
        if ln.crcd'="" set ttx.crcd=ln.crcd
	quit
	
UPD(RecordLNAPCHGE lnapchge,RecordLNBIL0 lnbil0)

	/*

	Set Billing Information

	ARGUMENTS:
         . lnapchge   Analysis Payment Change Batch  TYP=RecordLNAPCHGE/REQ
		      Escrow Object
	 . lnbil0     Internal Bill Control Object   TYP=RecordLNBIL0/REQ
	*/


	set QUIT=0
	for ELENUM=1:1:20 do { quit:QUIT
		set X=$$ESCACT^BILFUNCS(.lnbil0,.ELENUM)
		if $P(X,$C(9),2)=lnapchge.ept do {
			set QUIT=1
			if AMT do {
				set VAR="pe"_ELENUM_"la"
				set lnbil0.@VAR=AMT
				}
			if $P(X,$C(9),1) do {
				set SVUX($P(X,$C(9),1))=lnapchge.epmt
				}
			}
		}
	quit

NC(RecordLN ln,RecordLNBIL0 lnbil0)

	/*
	  Update LN and LNBIL0

	ARGUMENTS:
		. ln            Loan Account Object         TYP=RecordLN/REQ
		. lnbil0     Internal Bill Control Object   TYP=RecordLNBIL0/REQ
	*/

	// Reset TRC for the next account
	set TRC=TRC\1000*1000+1000

	// Update LNBIL0
	do lnbil0.bypassSave()

	// Update LN
	set ln.anld=%SystemDate
	set ln.eacip=1
	do ln.save()

	do ND

	quit

ND	//	
	lock

	quit

POST	// Post created transactions


	// Post created TTX records through batch processing
	do ^TTXP1 

	if ER do {
		// Teller Transaction file [TTX] locked by process <<PID>>
		if '$L($G(ET)) set ET="BCHLOC" 
		do ERR
		}
	quit

END	// Complete processing

	lock  
	
	if ER quit

	// Analysis batch not posted
	if VFMQ="Q" set RM=$$^MSG(288)

	// Analysis batch posted
	else  set RM=$$^MSG(289)

	set ER="W"

	quit

EXC	// File Dayend exceptions

	// System Processing Error
	set ET=$G(ET) if ET="" set ET=$$^MSG(2575)

	// Post Escrow Analysis
	do LOG^UTLEXC($T(+0),"*",$$^MSG(5595),$G(LCID),$G(%ZTSEQ),ET,"")
	kill ZE
	quit

CHECK(RecordLN ln,RecordDEP dep)

	/*
	  Generate a check

	ARGUMENTS:
		. ln            Loan Account Object     TYP=RecordLN/REQ
		. dep 		Deposit Account Object  TYP=RecordLN/REQ
	*/


	/* 
	  No escrow check or G/L account set up
	  Escrow overage check information not defined
	*/

	if (ESCCHK="")!(ESCGL="") set ET=$$^MSG(9) do EXC quit

	if ln.dist1nd+ln.ddra<%SystemDate do { quit
		new CID,ET
		set CID=LCID
		// No check generated - loan is delinquent
		set ET=$$^MSG(8522)
		do EXC
		}

	set TRC=TRC+1
        set TRTYP=dep.esc
        type RecordTTX ttx=Class.new("RecordTTX")
        do TTX(.ttx,.ln)
        set ttx.itc=EWETC
        set ttx.etc=EWTC
        set ttx.tcmt=APCK
        do ttx.bypassSave()

	// Set up check file
	new SQ
	set SQ=Db.currVal("XPDO","TJD=:%SystemDate,CKTYP=:ESCCHK")
	set SQ=SQ+1
	type RecordXPDO xpdo=Class.new("RecordXPDO")
	set xpdo.tjd=%SystemDate
	set xpdo.cktyp=ESCCHK
	set xpdo.ckseq=SQ
	set xpdo.brcd=BRCD
	set xpdo.uid=%UserID
	set xpdo.trc=TRC
	set xpdo.cid=LCID
	set xpdo.tamt=AMT
	do xpdo.bypassSave()

	set TRC=TRC+1
        type RecordTTX ttx2=Class.new("RecordTTX")
        do TTX(.ttx2,.ln)
	set ttx2.cid=ESCGL
	set ttx2.itc=1
	set ttx2.etc="MCR"
        set ttx2.tcmt=APCK
        do ttx2.bypassSave()

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60712^46295^Dan Russell^11351"	// Signature - LTD^TIME^USER^SIZE
