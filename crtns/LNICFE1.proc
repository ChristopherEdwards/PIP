LNICFE1	/* Private - Int/Perm/Def screen pre/post processors
	ORIG: Chuck Hardy (6721) - 07/01/87
	PROCEDURE ID: LNICFE1
	DESC: Int/Perm/Def screen pre/post processors

	------ Revision History ------------------------------------------------

	11/21/06 - MBUIM - CR 23262
		   Modified CK3 section to scope variable Y publicly to 
		   correct undefined error. CK1 & CK2 sections were 
		   modified to use different variable name as same variable I 
		   was used for 2 different cases and newing one caused 
		   undefined for the other.  

        09/21/05 - BHOLT - 17068
		   Modified the Depricated method to Current Standard.
          
        08/02/05 - SkariahV- CR16679
	           Removed #WARN and # OPTIMIZE directives.
	
	03/15/03 - Dan Russell - 51351
		   Convert to PSL.
		   
		   Remove old change history.

	------------------------------------------------------------------------
	*/
	
	quit
	

CK1(RecordLN LN)	// Private

	type public Boolean ER
	type public Number CID, IDPF, NI, X
	type public String ET, I(), REQ(), RM
	
	type Number %EXT, Y

	set ER = 0
	set Y = ""

	if X = "" do { quit
		
		type Number J

		for J = NI+1:1:NI+3 kill REQ(J) 
		}

	set %EXT = 1 do CID^UACN1 quit:ER

	/* If a transaction has occurred to the interim loan between TJD
	 and EFD do not allow the effective date conversion . 
	*/

	type ResultSet histrs=Db.select("TSEQ","HIST","CID=:CID AND (TJD >= :EFD AND (EFD IS NULL OR EFD >= EFD) AND (NOT (ITC6=1) OR NOT (ITC12=1)))")

 	if 'histrs.isEmpty() do { quit
		set ER = 1
		//  Interim transactions to EFD must be reversed
		set RM = $$^MSG(8438)
		}


	quit:$$INUSE(X, I(1), 1, "")

	do { quit:ER
		type RecordLN ln = Db.getRecord("LN", "CID = :X", 1)

		if ln.stat = 4 do { quit
			set ER = 1
			// Account closed
			set ET = "ACNCLO"
			do ^UTLERR
			}

		set Y = X
		if ln.idpf '= IDPF set Y = ln.relcid if Y do {
			set X = Y
			quit:$$INUSE(X, I(1), 1, "")
			}
		}

	type RecordLN ln = Db.getRecord("LN", "CID = :X", 1)

	if ln.idpf '= IDPF do { quit
		set ER = 1
		// Invalid interim/permanent/deferred status flag
		set ET = "INVLDIFLG"
		do ^UTLERR
		}

	if 'ln.bal do { quit
		set ER = 1
		// Account has a zero balance
		set ET = "AHZB"
		do ^UTLERR
		}

	/* Move select data from account X into new record.
	   These are the columns that are on nodes 57 and 60 in an
	   M database.
	*/
	set LN.irn = ln.irn
	set LN.idf = ln.idf
	set LN.ichnd = ln.ichnd
	set LN.ichld = ln.ichld
	set LN.intmx = ln.intmx
	set LN.intmn = ln.intmn
	set LN.intmno = ln.intmno
	set LN.sch = ln.sch
	set LN.icpf = ln.icpf
	set LN.eod = ln.eod
	set LN.eirn = ln.eirn
	set LN.irsexm = ln.irsexm
	set LN.diu = ln.diu
	set LN.dic =  ln.dic
	set LN.irf = ln.irf
	set LN.iacf = ln.iacf
	set LN.diaa = ln.diaa
	set LN.diand = ln.diand
	set LN.diald = ln.diald
	set LN.dimxb = ln.dimxb
	set LN.dimxy = ln.dimxy
	set LN.dimxl = ln.dimxl
	set LN.aniro = ln.aniro
	set LN.anirnd = ln.anirnd
	set LN.anirld = ln.anirld
	set LN.rpidc = ln.rpidc
	set LN.aniriv = ln.aniriv
	set LN.invl = ln.invl
	set LN.narl = ln.narl
	set LN.namxb = ln.namxb
	set LN.idefly = ln.idefly
	set LN.ditgacn = ln.ditgacn
	set LN.dirfre = ln.dirfre
	set LN.dirnd = ln.dirnd
	set LN.dirld = ln.dirld
	set LN.intramt1 = ln.intramt1
	set LN.intrrat1 = ln.intrrat1
	set LN.intrexp1 = ln.intrexp1
	set LN.intramt2 = ln.intramt2
	set LN.intrrat2 = ln.intrrat2
	set LN.intrexp2 = ln.intrexp2
	set LN.intramt3 = ln.intramt3
	set LN.intrrat3 = ln.intrrat3
	set LN.intrexp3 = ln.intrexp3
	set LN.air = ln.air
	set LN.nalpb = ln.nalpb
	set LN.flat = ln.flat
	set LN.intdeftytd = ln.intdeftytd
	set LN.intdefpty = ln.intdefpty
	set LN.index = ln.index
	set LN.ipf = ln.ipf
	set LN.prcb = ln.prcb
	set LN.trmmx = ln.trmmx
	set LN.intfre = ln.intfre
	set LN.intoff = ln.intoff
	set LN.intmxic = ln.intmxic
	set LN.intmxdc = ln.intmxdc
	set LN.pmxdic = ln.pmxdic
	set LN.pmxdil = ln.pmxdil
	set LN.pmxddc = ln.pmxddc
	set LN.pmxddl = ln.pmxddl
	set LN.pmxpic = ln.pmxpic
	set LN.pmxpil = ln.pmxpil
	set LN.pmxpdc = ln.pmxpdc
	set LN.pmxpdl = ln.pmxpdl
	set LN.intmxiy = ln.intmxiy
	set LN.intmxdy = ln.intmxdy
	set LN.pmxdiy = ln.pmxdiy
	set LN.pmxddy = ln.pmxddy
	set LN.pmxpiy = ln.pmxpiy
	set LN.pmxpdy = ln.pmxpdy
	set LN.ppinc = ln.ppinc
	set LN.numch = ln.numch
	set LN.pcfre = ln.pcfre
	set LN.caf = ln.caf
	set LN.pchm = ln.pchm
	set LN.anpto = ln.anpto
	set LN.anptnd = ln.anptnd
	set LN.anptld = ln.anptld
	set LN.cntc = ln.cntc
	set LN.intmnic = ln.intmnic
	set LN.intmndc = ln.intmndc
	set LN.pchnd = ln.pchnd
	set LN.pchld = ln.pchld
	set LN.pcoff = ln.pcoff
	set LN.piacm = ln.piacm
	set LN.pmndic = ln.pmndic
	set LN.pmnddc = ln.pmnddc
	set LN.indo = ln.indo
	set LN.ichm = ln.ichm
	set LN.rafre = ln.rafre
	set LN.rand = ln.rand
	set LN.rald = ln.rald
	set LN.index1 = ln.index1
	set LN.index2 = ln.index2
	set LN.index3 = ln.index3
	set LN.index4 = ln.index4
	set LN.index5 = ln.index5
	set LN.index6 = ln.index6
	set LN.index7 = ln.index7
	set LN.index8 = ln.index8
	set LN.index9 = ln.index9
	set LN.index10 = ln.index10
	set LN.compirn = ln.compirn
	set LN.randoff = ln.randoff
	set LN.intoffdt = ln.intoffdt
	set LN.pcoffdt = ln.pcoffdt
	set LN.intoffcl = ln.intoffcl
	set LN.intmat = ln.intmat
	set LN.intspr = ln.intspr
	set LN.rndmtd = ln.rndmtd

	quit


CK1B	// Private

	type public Boolean ER
	type public Number X, UCID	
	type public String I()

	type String PGM

	quit:X = ""

	quit:$$INUSE(X, I(1), 6, 0)

	set PGM = "VER"_UCID
	do @PGM

	quit


CK2	// Private - IDPF=2

	type public Boolean ER
	type public Number IDPF, NI, X
	type public String I(), ET, REQ()

	type Number %EXT, J, RELCID, Y

	if X = "" do { quit

		for J = NI+2:1:NI+4 kill REQ(J)
		}

	quit:$$INUSE(X, I(1), 1, "")

	set %EXT = 1 do CID^UACN1 quit:ER


	// Get permanent loan number

	set Y = X
	do { quit:ER
		type RecordLN ln = Db.getRecord("LN", "CID = :X")
		if ln.idpf '= IDPF set Y = ln.relcid if Y do {
			set X = Y
			quit:$$INUSE(X, I(1), 1, "")
			}
		}

	// Verify permanent loan
	type RecordLN ln = Db.getRecord("LN", "CID = :X", 1)

	if ln.idpf '= IDPF do { quit
		set ER = 1
		// Invalid interim/permanent/deferred status flag
		set ET = "INVLDIFLG"
		do ^UTLERR
		}

	if ln.stat = 4 do { quit
		set ER = 1
		// Account closed
		set ET = "ACNCLO"
		do ^UTLERR
		}

	if 'ln.bal do { quit
		set ER = 1
		// Account has a zero balance
		set ET = "AHZB"
		do ^UTLERR
		}

	if ln.tba do { quit
		set ER = 1
		// Satisfy all outstanding payments via bill record maintenance
		set ET = "SATBIL"
		do ^UTLERR
		}

	// Verify deferred loan
	set RELCID = ln.relcid

	if RELCID do { quit:ER
		type RecordLN defln = Db.getRecord("LN", "CID = :RELCID", 1)

		if defln.stat = 4 do {
			set ER = 1
			// Related account closed
			set ET = "RELACCL"
			do ^UTLERR
			}
		}

	for I = NI+2:1:NI+4 set REQ(I) = ""

	quit


CK3	// Private

	type public Boolean ER
	type public Number E12, IDPF, X, Y
	type public String ET, 	I()

	type Number %EXT, PIECE

	quit:X = ""

	for PIECE = 1, 21:1:24 quit:$$INUSE(X, I(1), PIECE, +E12)
	quit:ER

	set ER = 0

	set %EXT = 1 do CID^UACN1 quit:ER

	set Y = ""
	do { quit:ER
		type RecordLN ln = Db.getRecord("LN", "CID = :X", 1)

		if ln.idpf '= IDPF set Y = ln.relcid if Y do {
			set X = Y
			for PIECE = 1, 21:1:24 quit:$$INUSE(X, I(1), PIECE, +E12)
			}
		}

	type RecordLN ln = Db.getRecord("LN", "CID = :X", 1)

	if ln.idpf '= IDPF do { quit
		set ER = 1
		// Invalid interim/permanent/deferred status flag
		set ET = "INVLDIFLG"
		do ^UTLERR
		}

	if ln.stat = 4 do { quit
		set ER = 1
		// Account closed
		set ET = "ACNCLO"
		do ^UTLERR
		}

	if 'ln.bal do { quit
		set ER = 1
		// Account has a zero balance
		set ET = "AHZB"
		do ^UTLERR
		}

	quit


CK4	// Private - post processor for DIST1ND screen LNICVN1

	type public Date X
	type public Boolean ER
	type public Number AF, TYPE
	type public String ET, LNICNV(), RM

	type Date BNDT, DAT, JD, DTE, NJD, SNJD
	type Number I
	type String FRE

	quit:X = ""

	set ER = 0

	// Check that payment date and frequency are consistent
	if X '? 5N set X = $$^SCAJD(X) quit:X < 0

	set FRE = LNICNV(I(1)).piece("|", 2) quit:FRE = ""
	set FRE = "-"_FRE
	set JD = X, NJD = $$NJD^UFRE(JD, FRE, .AF) quit:ER
	set FRE = FRE.extract(2, 99)
	set SNJD = NJD
	for I = 1:1 set JD = NJD, NJD = $$NJD^UFRE(JD, FRE, .AF) quit:ER!(NJD = X)  if NJD > X set ER = 1 quit
	if ER = 1 do { quit
		type String DAT

		// First payment date <<$ZD(DAT,$G(%MSKD))>> is not consistent with frequency
		set ET = "LBDDAT"
		set DAT = X
		do ^UTLERR
		}

	// Check to see if BNDT is earlier than TJD
	if X, X'> %SystemDate do {
		// Next scheduled payment date precedes today's date
		set ET = "LNBLDDT2"
		do DSPBP^UTLERR
		}

	type RecordPRODDFTL proddftl = Db.getRecord("PRODDFTL", "TYPE = :TYPE", 1)

	if proddftl.bloff = "1P" set BNDT = SNJD	// 3.4 and higher
	else  set BNDT = X - proddftl.bloff

	if X, BNDT < %SystemDate do {
		type String DTE
		// First billing date <<$$DAT^%ZM(DTE,$G(%MSKD))>> precedes today's date|
		set ET = "LNBLDDT"
		set DTE = BNDT
		do DSPBP^UTLERR
		}

	set ER = 0
	set RM = ""

	quit


CK5(RecordLN LN)	//Private - Payment frequency

	type public Boolean ER
	type public Number AF, TYPE
	type public String RM, X

	type Date JD, NJD
	type String BLOFF, FPF, FRE
	type Number ICM	

	set ER = 0

	// Invalid frequency format
	do EDT^UFRE if ER set RM = $$^MSG(1354) quit

	quit:X = ""

	set FRE = X, JD = %EffectiveDate
	set NJD = $$NJD^UFRE(JD, FRE, .AF) quit:ER

	type ResultSet rs = Db.select("ICM, FPF, BLOFF", "PRODDFTL, PRODCTL", "TYPE = :TYPE",,,"DQMODE = 1")

	if rs.next() do {
		set ICM = rs.getCol("ICM")
		set FPF = rs.getCol("FPF")
		set BLOFF = rs.getCol("BLOFF")
		}
	else  set (ICM, FPF, BLOFF) = ""

	if FPF do FULL^UFRE quit:ER
	if ICM = 1 do { quit:ER
		set JD = NJD
		set FRE = "-"_X
		set NJD = $$NJD^UFRE(JD, FRE, .AF)
		if 'ER set FRE = X
		}

	if BLOFF = "1P" do { quit:ER
		set JD = NJD
		set FRE = "-"_X
		set NJD = $$NJD^UFRE(JD, FRE, .AF)
		if 'ER set BLOFF = JD-NJD, FRE = X
		}

	if NJD-BLOFF < %EffectiveDate do { quit:ER
		set JD = NJD
		set NJD = $$NJD^UFRE(JD, FRE, .AF)
		}

	set LN.dist1nd = NJD

	quit


INUSE(Number X,	// Private - See if account number already on screen
	String IONE,
	Number PIECE,
	Number E12)

	type public Boolean ER
	type public String ET, LNICNV()

	type Number INUSE, SEQ

	set INUSE = 0
	set SEQ = ""
	for  set SEQ = LNICNV(SEQ).order() quit:SEQ = ""  do { quit:INUSE
		if LNICNV(SEQ).piece("|",PIECE) = X do {
			if E12 = "" do {
				if SEQ '= IONE set INUSE = 1
				}
			else  if SEQ '= IONE !(SEQ '= E12) set INUSE = 1
			}
		}

	if INUSE do {
		set ER = 1
		// Account in use on screen
		set ET = "CIDINUSE"
		do ^UTLERR
		}

	quit INUSE

vSIG()	quit "60611^57164^Marie Mbui^10132"	// Signature - LTD^TIME^USER^SIZE
