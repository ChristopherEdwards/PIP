public MRPC043(RETURN,VERSN,TYPE,CRCD,INPUT,ACN,BOO)
	/*
	   Procedure ID: MRPC043
	   DESC: Deposit Account Create
	   ORIG: Marty Ronky (3623)
	   DATE: 1/31/97
	
	   KEYWORDS: RPC
	
	   ARGUMENTS:
	   . RETURN		Master/Float		/TYP=T/REQ/MECH=REFNAM:W
	     Account Numbers
	
	   . VERSN		version number		/TYP=N/REQ/MECH=VAL
	     current version=1
	
	   . TYPE		Account Type		/TYP=N/REQ/MECH=VAL

	   . CRCD		Currency Code		/TYP=T/REQ/MECH=VAL
	     (for master and float)
	
	   . INPUT		Input String		/TYP=T/REQ/MECH=VAL
	     See details below

	   . ACN		Customer Number		/TYP=N/NOREQ/MECH=VAL

	   . BOO		Branch of Ownership	/TYP=N/NOREQ/MECH=VAL
	
	   RETURNS:
	   . $$     Error Message	/TYP=T
	     Null= No Error
	
	   . RETURN Account Number	/TYP=N
	
	   RELATED:
	   . $$^PBSMRPC - MRPC Service Class Driver
	
	   EXAMPLE:
	   S RM=$$^MRPC043(.VAL,1,300,"USD",INPUT,ACN,BOO)
	
	   ACCOUNT CREATE
	
	   This RPC is a public RPC for deposit account creation.
	
	   This MRPC will accept the product type and the currency code,
	   and a comma separated string in the form FID.DI=VAL,
	   FID.DI=VAL,... which will be used to create the account.

	   This form of input is used vs. individual parameters to provide
	   the flexibility of changes on the input data without changes
	   to this routine.
		      
	   In order to handle multiple records for a single table, an
	   exception to the FID.DI=VAL format must be used.  For these
	   records, add a sequential number to the FID field.  For example,
	   if there are 3 CIFs that should be attached to an account,
	   CIFs 544 (primary), 545 and 546, this should be set up as
	   RELCIF1.ACN=544,RELCIF1.ROLE=1,RELCIF2.ACN=545,RELCIF2.ROLE=2,
	   RELCIF3.ACN=546,RELCIF3.ROLE=3.
	   This format should be used for the following files:
	        RELCIF (CIF-ACN Relationship File)
	        CMBSTM (Combined Statement Maintenance)
	        DEPODP (Overdraft Protection)
	        DEP101 (Sweep Relationships)
	        ACCTBENDTL (Account Beneficiary Details)


	   ---- Revision History ------------------------------------------------
	   
	   04/23/07 - MbuiM - CR 26623
	   	      Modified Account Address section to default missing 
	   	      column acnaddr.mcounty.
	   
	   03/01/07 - MbuiM - CR 25106
	   	      Modified section MAIN to add support for ACCTBENDTL.
	   
	   12/19/06 - SHRIRAM - CR 24547
	   	      Modified MAIN section to log the restriction if vzrstflg is 
	   	      not zero and restriction errors exist.	
	   	
	   08/23/06 - chhabris - CR 22510
	   	      Retrofit from P01DEV1 as per the below details.

		      04/04/06 Ed Sigda - CR 20575
		      Retrofit changes into Profile01 view.
		      o Moved %STFHOST date logic to be in section MAIN as
		        the top section should only be for handling the
		        RPC message formatting logic.
		      o Removed getOneRow method calls
		      o Modified section MAIN to properly truncate account
		        titles using new section TITLE.
		      o Added new section TITLE to build account titles 1-4
		      o Minor changes to remove trailing spaces from suffix and
			to increase efficiency.

	   04/14/06 - KELLYP - CR 20232
	   	      Modified end of MAIN section to correct a spacing issue
		      that caused a runtime error when CUVAR.UCID is defined.
		      Also cleaned up duplicate object declarations.

	   08/18/05 - KELLYP - CR 16681
	   	      Removed catch block from MAIN section prior to saving the
	   	      dep object.  Error trapping & handling is now part of the 
	   	      compiled code for the save method and the catch block was
	   	      suppressing PSL-E errors returned by the filer that should
	   	      have been returned to the client.  Also removed pre-2003
	   	      revision history.

	   11/07/03 - CARROLLJ - 51630
		      Added #ACCEPT around STFHOST check.
	*/

	// Begin processing
	type public String %STFHOST,CO,ERRORMSG,RM
	type public Number CID
	type public Boolean ER
	type String %EXT,GRP,STR,TCMT
	
	set ER=0
	set RM=""
	set ERRORMSG=""

	// Version number of client message is not compatible with server
	if VERSN.get()'=1 quit $$ERRMSG^PBSUTL($$^MSG(2951))
	
	// Invalid Record
	if INPUT.get().isNull() quit $$ERRMSG^PBSUTL($$^MSG(8097))
	
	// Invalid Currency
	if CRCD.get().isNull() quit $$ERRMSG^PBSUTL($$^MSG(1293))
	
	//Invalid currency code
	set CO=%CompanyName
	if 'Db.isDefined("CRCD",":CO,:CRCD") quit $$ERRMSG^PBSUTL($$^MSG(1293))
		
	// Invalid product type
	if TYPE.get().isNull() quit $$ERRMSG^PBSUTL($$^MSG(1503))

	do MAIN(TYPE,CRCD)

	if ER,$TLevel do Runtime.rollback()

	if 'ERRORMSG.get().isNull() set ER=1 quit $$ERRMSG^PBSUTL(ERRORMSG)
	if ER.get() quit $$ERRMSG^PBSUTL($G(RM))		

	set STR=CID_$C(13,10)

	#if $$VALID^%ZRTNS("ZMRPC043") do FAPOUT^ZMRPC043

	// Return the account number.
	set RETURN=$$V2LV^MSG(STR)
	quit ""
		
MAIN(TYPE,CRCD)

	/*
	   Private
	
	   ARGUMENTS:
	
	   . TYPE  Product Type  /TYP=N/REQ/MECH=VAL
	
	   . CRCD  Currency Code  /TYP=T/REQ/MECH=VAL
	     (for master and float)
	
	
	   This subroutine is responsible for:
	
	   1) Determining the account number and locking the record.
	
	   2) Creating ACNADDR, RELCIF and CMBSTM records which will
	      be used for the account create.
	
	   4) Building the account in the product type and
	      currency specified.  Product type defaults will be used,
	      by setting up an array to be used for SQL statements for
	      all non-blank elements in the product type from node 49 on
	      down.
	*/
	type Public String BOO,ERRORMSG,INPUT,RM,verrors
	type Public Number ACN,CID,vzrstflg
	type public Boolean ER
	type String ARR,cifdata,CLS,DATA,EXT,GRP,PGM,REL,ROLE
	type String STMGRP,TMPDATA
	type Number %EXT,I,ODACN,ODCID,PCIF
	type Boolean QUIT

	// If creating account during critical path set TJD to tomorrow
	#ACCEPT DATE=12-10-04; PGM=MBUIM
	if %STFHOST.get() new %SystemDate set %SystemDate=$$TTL^RCHK()+1

	// Extract out customer number if not defined
	if ACN.get().isNull() do { quit:ER
		if INPUT'["DEP.ACN=" set ER=1,RM=$$^MSG(1295) quit
		type String EXT
		set EXT=INPUT.piece("DEP.ACN=",2)
		set ACN=EXT.piece(",",1)
		if ACN.extract()="'" set ACN=ACN.extract(2,(ACN.length()-1))

		// Invalid Customer Account
		if ACN.get().isNull() set ER=1,RM=$$^MSG(1295)
		}

	// Extract out branch of ownership if not defined
	if BOO.get().isNull() do { quit:ER
		if INPUT["DEP.BOO=" do {
			type String EXT
			set EXT=INPUT.piece("DEP.BOO=",2)
			set BOO=EXT.piece(",",1)
			if BOO.extract()="'" set BOO=BOO.extract(2,(BOO.length()-1))
			}
		else  do {
			type RecordSCAU scau=Db.getRecord("SCAU",":%UserID")
			set BOO=scau.brcd
			}

		//Invalid Branch of Ownership
		if BOO.get().isNull() set ER=1,RM=$$^MSG(6654)
		}

	// Define array needed for market segmentation product extract
	set ARR("TYPE")=TYPE
	set ARR("CRCD")=CRCD
	set ARR("ACN")=ACN
	set ARR("BOO")=BOO
	do ^UPRODDFT(.ARR,.DATA)

	if ER.get() quit

	//Convert input string to data array
	do STR2ARR^UTLMRPC(INPUT,.DATA)

	#if $$VALID^%ZRTNS("ZMRPC043") do FAPINP^ZMRPC043

	if ER.get() quit 

	// Validate product types for currency, expiration, etc...
	
	set %EXT=1
	do AVL^NEW(TYPE)
	if ER.get() quit 
	set CLS="D"
	set GRP=DATA("DEP.GRP").get()

	type RecordDEP dep=Class.new("RecordDEP")

	/*
	    Now take the incoming information from the client, and overlay
	    the master product defaults with it.
	*/

	do dep.default("TYPE")
	do dep.overlay("DATA")
		
	//  Determine the account number.
	
	type String VFMQ
	type Number %NET 
	
	set VFMQ=""
	set %NET=1

	//  If CID is passed in, use it.  Otherwise, get a new one.
	set CID=+DATA("DEP.CID").get()
	if CID=0 set CID=$$CID^NEW quit:$G(ER)
	else  do {  quit:ER.get()		
		type ResultSet rs=Db.select("CID","ACN","CID=:CID")

		// Account Already Exists
		if 'rs.isEmpty() set ER=1,RM=$$^MSG(53)
		}
	
	set dep.cid=CID
	set dep.type=TYPE
	set dep.crcd=CRCD
	
	if dep.cc.isNull() do {
		type RecordUTBLBRCD utblbrcd=Db.getRecord("UTBLBRCD",":BOO")
		set dep.cc=utblbrcd.ccdef
	}

	// CIF/Account Relationship section

	type Number count1,ecount1
	type RecordRELCIF relcif()
	set QUIT=0
	set REL=DATA("DEP.ACNRELC").get()
	for ecount1=1:1 do { quit:ER.get()!(QUIT) 
		type String TMPDTA
		type Number ACN

		type RecordRELCODE relcode

		set ACN=DATA("RELCIF"_ecount1_".ACN").get()
		if ACN.isNull() set QUIT=1,ecount1=ecount1-1 quit 

		// Validate relationship & role
		// STBLMSG: Invalid code
		set ROLE=DATA("RELCIF"_ecount1_".ROLE").get()
		if (REL.isNull())!(ROLE.isNull()) do Runtime.setErrMSG("RELCIF",1284) quit

		// Create new RELCIF object from DATA array
		set relcif(ecount1)=Class.new("RecordRELCIF")
		set relcif(ecount1).acn=ACN
		set relcif(ecount1).cid=CID
		set relcif(ecount1).role=ROLE
		do MOVEARR^UTLMRPC("RELCIF"_ecount1,"RELCIF",.DATA,.TMPDATA)
		do relcif(ecount1).overlay("TMPDATA")

		// Retrieve relationship code information
		set relcode=Db.getRecord("RELCODE",":REL,:ROLE")

		// Make sure primary customer is defined
		if relcode.pcif=1 set dep.acn=ACN
		}
	
	if ER.get() quit 

	// File relationship error ... RELCIF
	if 'relcif(1).exists() do Runtime.setErrMSG("RELCIF",1093,"RELCIF") quit

	/*
	 Default title values if not defined
	 The default title logic will not be used if title1 contains a value.
	 In other words, if the client application passes in title1, then no
	 other title values will default.
	*/
	if dep.title1="" do TITLE(.dep,.relcif())
	
	type Number count2,ecount2
	type RecordCMBSTM cmbstm()

	// Statement Group Section
	set QUIT=0
	for ecount2=1:1 do { quit:ER.get()!(QUIT) 
		type Number ACN
		set ACN=DATA("CMBSTM"_ecount2_".ACN").get()
		if ACN.isNull() set QUIT=1,ecount2=ecount2-1 quit 
		set STMGRP=DATA("CMBSTM"_ecount2_".STMGRP").get()
		set cmbstm(ecount2)=Class.new("RecordCMBSTM")
		set cmbstm(ecount2).acn=ACN
		set cmbstm(ecount2).stmgrp=STMGRP
		set cmbstm(ecount2).cid=CID
		do cmbstm(ecount2).overlay("DATA")
		}

	if ER.get() quit 

	// Overdraft Protection Section                                      
	type Number count3,ecount3
	type RecordDEPODP depodp()

	set QUIT=0
	for ecount3=1:1 do { quit:ER.get()!(QUIT)
		set ODCID=DATA("DEPODP"_ecount3_".CID").get()
		set ODACN=DATA("DEPODP"_ecount3_".ODACN").get()

		// Either the protected or source account must be specified.
		if ODCID.isNull(),ODACN.isNull() set QUIT=1,ecount3=ecount3-1 quit
		if ODACN.isNull() set ODACN=CID
		if ODCID.isNull() set ODCID=CID

		// Target account number is the same as account number
		if ODACN=ODCID set ER=1,RM=$$^MSG(2601) quit

		// Convert DEPODPn data items to DEPODP in temp array
		do MOVEARR^UTLMRPC("DEPODP"_ecount3,"DEPODP",.DATA,.TMPDATA)
		set depodp(ecount3)=Class.new("RecordDEPODP")
		set depodp(ecount3).cid=ODCID
		set depodp(ecount3).odacn=ODACN
		do depodp(ecount3).overlay("TMPDATA")
		kill TMPDATA				// Kill Temp Array   
		}

	if $G(ER) quit

	// Investment Sweep Section
	type Number count4,ecount4
	type RecordDEP101 dep101()
 
	set QUIT=0
	for ecount4=1:1 do { quit:$G(ER)!(QUIT)
		type String GRP,TYPE
		type Number ICID,SAVCID

		set TYPE=DATA("DEP101"_ecount4_".ITYPE").get()
		if TYPE.isNull() set ecount4=ecount4-1,QUIT=1 quit
		if 'Db.isDefined("PRODCTL",":TYPE") set ER=1,RM=$$^MSG(1503) quit

		type RecordPRODCTL prodctl=Db.getRecord("PRODCTL",":TYPE")
		set GRP=prodctl.grp
	
		// Group not valid for investment sweep processing
		if GRP.isNull() set ER=1,RM=$$^MSG(2853) quit

		// If no account number passed in, generate one.
		set SAVCID=CID
		set ICID=DATA("DEP101"_ecount4_".ICID").get()
		if ICID.isNull() set ICID=$$CID^NEW Q:ER.get()

		// Cannot link a sweep account to itself
		if SAVCID=ICID set ER=1,RM=$$^MSG(3281) quit

		// Convert DEP101n data items to DEP101 in temp array
		do MOVEARR^UTLMRPC("DEP101"_ecount4,"DEP101",.DATA,.TMPDATA)
		set dep101(ecount4)=Class.new("RecordDEP101")
		set dep101(ecount4).cid=SAVCID
		set dep101(ecount4).icid=ICID
		do dep101(ecount4).overlay("TMPDATA")
		kill TMPDATA				// Kill Temp array
		set CID=SAVCID				// Restore CID
		}

	if ER.get() quit

	// Account Address Section
	type RecordACNADDR acnaddr=Class.new("RecordACNADDR")
	set acnaddr.cid=CID
	do acnaddr.overlay("DATA")	

	if acnaddr.ad1.isNull() do {
		type Number ACN
		set ACN=dep.acn

		type RecordCIF cif=Db.getRecord("CIF",":ACN")
		set acnaddr.ad1=cif.mad1
		set acnaddr.ad2=cif.mad2
		set acnaddr.ad3=cif.mad3
		set acnaddr.ad4=cif.mad4
		set acnaddr.city=cif.mcity
		set acnaddr.mcounty=cif.mcounty
		set acnaddr.state=cif.mstate
		set acnaddr.mzip=cif.mzip
		set acnaddr.cntry=cif.mcntry
		set acnaddr.loc=cif.mloc
		}

	type String vfkey
	do dep.save("/NOFKCHK=1/VALDD/VALRI/VALREQ/KEEPVFKEY") if ER quit
	set count1=ecount1
	for ecount1=1:1:count1 do:relcif(ecount1).exists() relcif(ecount1).save("/NOFKCHK=1/VALDD/VALRI/VALREQ/KEEPVFKEY") if ER quit
	if ER quit
	set count2=ecount2
	for ecount2=1:1:count2 do:cmbstm(ecount2).exists() cmbstm(ecount2).save("/NOFKCHK=1/VALDD/VALRI/VALREQ/KEEPVFKEY") if ER quit
	if ER quit
	set count3=ecount3
	for ecount3=1:1:count3 do:depodp(ecount3).exists() depodp(ecount3).save("/NOFKCHK=1/VALDD/VALRI/VALREQ/KEEPVFKEY") if ER quit
	if ER quit

	do acnaddr.save("/NOFKCHK=1/VALDD/VALRI/VALREQ/KEEPVFKEY") if ER quit

	// ACNADDR record must be saved prior to creation of DEP101 record
	set count4=ecount4
	for ecount4=1:1:count4 do:dep101(ecount4).exists() dep101(ecount4).save("/NOFKCHK=1/VALDD/VALRI/VALREQ/KEEPVFKEY") if ER quit
	if ER quit
	
	// Account Beneficiary Detail section
        if $$EXIST^MRPC044("ACCTBENDTL1") do BENDTL(.DATA,dep.cid) quit:ER
	
	// Verify foreign keys
	do vfkey^SQLBUF if ER quit

	/*
	   If custom account assignment program used, call update section
	   to update any necessarty tables. Call will be constructed as
	   PGM=UPD^UCIDSCA("D","SAV",350,87438473), for example
	*/

	set GRP=DATA("DEP.GRP").get()
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
	set PGM=cuvar.ucid
	if 'PGM.isNull() set PGM="D UPD"_PGM_"(""D"","""_GRP_""","_TYPE_","_CID_")"

	#ACCEPT DATE=11/05/99;PGM=Kevin Cho
	if  xecute PGM

	if ER quit

	if 'vzrstflg.get(), verrors.data() do XBAD^DBSEXECU(.verrors)	// Log the restriction

	quit

FAPINP	// Reformat input
	/*
	   This section can be used by creating ZMRPC043.  Any custom or
	   additional input DATA array can be processing here.  Compile
	   ZMRPC043 followed by MRPC043.  FAPINP in ZMRPC043
	   will be called directly from MRPC043 if it exists.

	   Example:
	   set DATA("DEP.VALUE1")=Db.getOneRow("VALUE1","TEST","GRP=:GRP")
	*/

	quit

FAPOUT	// Reformat output
	/*
	   This section can be used by creating ZMRPC043.  Output can be
	   reformatted by adding custom code.

	   Example:
	   if GRP="CD" do {
		type String DATA
		set DATA=Db.getOneRow("IRN,TRM,MDT","PRODDFTD","TYPE=:TYPE")
		set STR=DATA_$C(9)_STR
		}
	*/

	quit

SPODBC(VERSN,TYPE,CRCD,INPUT)
	/*
	   This function is intended to provide a capability to invoke a
	   true MRPC from the EXECUTE procedure facility within the PROFILE
	   ODBC driver.  This is needed in order to get the normal response
	   argument that is part of the MRPC structure returned to the calling
	   ODBC client.
	*/

	type Public String RM
	type public Boolean ER
	type String PTR,RETURN

	set RM=$$^MRPC043(.RETURN,$G(VERSN),$G(TYPE),$G(CRCD),$G(INPUT))
	if RM="" set PTR=$$LV2V^MSG(RETURN,.RETURN) quit $G(RETURN(1))
	set PTR=$$LV2V^MSG(RM,.RM)
	set ER=1
	set RM=$G(RM(5))
	quit ""
	
public TITLE(RecordACN acn,RecordRELCIF relcif())

	/*
	 Build account title fields

	 ARGUMENTS:
		acn		ACN (account) object
		relcif		RELCIF (account relationship) object array

	 RETURNS:
		acn		ACN object with title values

	 TITLE relies on the client application to send in RELCIFx in the
	 correct order when defaulting titles.  In other words, RELCIF1 will
	 match TITLE1, RELCIF2 will match TITLE2, i.e., RELCIFx will always
	 match TITLEx
	*/

	type String NAM,SFX
	type Number ecount,LAST
	type RecordCIF cif

	// Mark last customer
	set LAST=relcif("").order(-1)
	if LAST>4 set LAST=4

	// Build title values using relcif array, cycling in reverse order.
	set ecount=LAST+1
	for  set ecount=relcif(ecount).order(-1) quit:ecount.isNull()  do {

		// Validate customer
		if 'Db.isDefined("CIF",":relcif(ecount).acn") do Runtime.setErrMSG("RELCIF",1295) quit

		// Retrieve customer information
		set cif=Db.getRecord("CIF",":relcif(ecount).acn")

		// Add customer prefix to customer name
		set NAM=cif.nam
		if 'cif.pref.isNull() set NAM=cif.pref_" "_NAM set NAM=NAM.extract(1,40)

		type RecordRELCODE relcode

		// Retrieve relationship code information
		set relcode=Db.getRecord("RELCODE",":acn.acnrelc,:relcif(ecount).role")

		// Add title suffix if NOT last customer
		if 'relcode.sfx.isNull() do {
			if ecount=LAST,relcode.ovrsfx quit

			set SFX=" "_relcode.sfx
			set NAM=NAM.extract(1,(40-SFX.length()))_SFX
		}

		// Insert title value into proper title field
		if ecount=1 set acn.title1=NAM
		else  if ecount=2 set acn.title2=NAM
		else  if ecount=3 set acn.title3=NAM
		else  if ecount=4 set acn.title4=NAM
	}
	
	quit
	
public BENDTL( String DATA(), Number CID)
	/*
	  Create Account Beneficiary Detail
	*/
	type public Boolean ER
	
	type Number CNT
	type Boolean QUIT=0
 	
	for CNT=1:1 do { quit:ER!(QUIT)
		type String TMPDATA()
		type RecordACCTBENDTL bendtl
		
		if '$$EXIST^MRPC044("ACCTBENDTL"_CNT) set QUIT=1 quit
		
		// Create new ACCTBENDTL object from DATA array
		set bendtl=Class.new("RecordACCTBENDTL")
		set bendtl.cid=CID
		do MOVEARR^UTLMRPC("ACCTBENDTL"_CNT,"ACCTBENDTL",.DATA,.TMPDATA)
		if 'TMPDATA("ACCTBENDTL.BENSEQ").exists() set bendtl.benseq=Db.nextVal("ACCTBENDTL","CID=:CID")
		do bendtl.overlay("TMPDATA")
		do bendtl.save("/NOFKCHK/VALDD/VALRI/VALREQ/KEEPVFKEY") if ER quit
	}
 
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60743^47274^Marie Mbui^17074"	// Signature - LTD^TIME^USER^SIZE
