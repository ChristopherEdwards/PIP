public I18NMOD //New Module File
  /*
	ORIG: kumarb - 11/04/2005
	DESC: New Module File

	 I18N=QUIT
        CALLED BY:
            CALLS:
             DESC:	Creates the ^I18NMOD global, which contains names
			of menus, functions, report ids, screen ids, file
			ids.
			Must key in first level ^I18NMOD with description
			Starting with a menu number, program traces to
			bottom of all sub-menus till list of functions is 
			obtained.  Program name is accessed, then program
			source code is analyzed for RID and SID.  Global
			^I18NMODX is searched for additional RID/SID's.  If not
			a valid RID or SID, then error is logged.  If valid,
			then data dictionary is accessed for File names
			associated with RID/SID definition.
	
			^I18NMOD updated throughout the above process 
        
         GLOBALS -
             READ: ^I18NMODX
              SET: ^I18NMOD,^I18NMODE
        
            INPUT:
           OUTPUT:
        
        EXT ENTRY:
	
	---- Revision History --------------------------------------------
	
	10/21/05 - KUMARB - CR 16921
        	Converted to PSL.

	------------------------------------------------------------------
	*/
	
	//	Newing and setting
	type String desc,dqdir,HDG,index,indir,line,menu,subs,VFMQ,%READ,%TAB()

	set VFMQ=""

	//	Utlread screen
	for  quit:VFMQ="Q"  do {
		set HDG=$J(" ",20)_$$^MSG(5895)_$J(" ",19)
		set (subs,desc,menu)=""
		set %TAB("subs")="/LEN=12/TBL=[I18NMOD1]:NOVAL/XPP=D subsPP^I18NMOD/TYP=T/DES=Module name"
		set %TAB("desc")="/LEN=40/TYP=T/DES=Description"
		set %TAB("menu")="/LEN=6/TBL=[SCAMENU0]/TYP=N/DES=Starting menu number"
		set %READ="@HDG#1,,,subs#1,desc#1,menu#1" 
		do ^UTLREAD
		if VFMQ'="Q" do MAIN 
		}

	quit
	
MAIN	//	Main

	type public String desc,ER,menu,RM,subs

	type Boolean errflg
	type Number lineno
	type String deeptbl(),ftable(),mtable(),nfound(,),odesc,omenu,r1,r2,rtable(),s1,s2,x,xmtable()

	type RecordI18NMOD1 i18nmod1=Db.getRecord("I18NMOD1","MOD=:subs",1)	
	set odesc=i18nmod1.des
	set omenu=i18nmod1.name
	if ('odesc.isNull()),(odesc'=desc),(omenu=menu) do { quit
		set i18nmod1.des=desc
		do i18nmod1.bypassSave()
		// Description modified
		set ER="W",RM=$$^MSG(5456)
		}

	if ('omenu.isNull()),(omenu'=menu) do {
		// Module for menu ~p1 deleted. Module for menu ~p2 created.
		do Runtime.setErrMSG("I18MODE",5445,omenu_"~"_menu)
		do Db.delete("I18NMODE","MOD=:subs")
		do Db.delete("I18NMODE1","MOD=:subs")
		do Db.delete("I18NMOD","MOD=:subs")
		do Db.delete("I18NMOD1","MOD=:subs")
		}
	else  if (omenu'="") do {
		// Menu ~p1 already processed
		set ER="W",RM=$$^MSG(5457,menu)
		write !?32,"** re-initializing **"
		for x=1:1:5 do Db.fastDelete("I18NMOD","MOD=:subs,ITEM=:x")
		do Db.fastDelete("I18NMOD","MOD=:subs,ITEM=99")
		}

	set i18nmod1.des=desc
	set i18nmod1.name=menu
	do i18nmod1.bypassSave()
	
	set errflg=0
	type ResultSet rs=Db.select("MOD","I18NMODE","MOD=:subs")
	if rs.next() set errflg=1
	
	do Db.fastDelete("I18NMODE","MOD=:subs,TYP='NEW'")
	do Db.fastDelete("I18NMODE1","MOD=:subs,TYP='NEW'")
	do Db.fastDelete("I18NMODE","MOD=:subs,TYP='MISSING'")
	do Db.fastDelete("I18NMODE1","MOD=:subs,TYP='MISSING'")

	set s1=" SID=",s2=",SID=",r1=" RID=",r2=",RID="
	
	write !!,"Scanning menus...",!!
	do menu(menu)
	for  set x=mtable("").order() quit:x=""  do menu(x)
	
	write !,"Scanning functions...",!!
	set x=""
	for  set x=ftable(x).order() quit:x=""  do func(x)
	
	write !,"Scanning routines...",!!
	set x=""
	for  set x=rtable(x).order() quit:x=""  do rout(x)
	
	do modx
	do msgpr // pull out messages/prompts/dbsmbar's
	if errflg'=0 do errlog
	
	if nfound.data() do {
		write !!,"The following items were not found:",!!,*7,*7
		set x="" for  set x=nfound(1,x).order() quit:x=""  write "Function: ",x,!
		set x="" for  set x=nfound(2,x).order() quit:x=""  write " Routine: ",x,!
		read "Press [ENTER] to continue. ",x
		}
	quit
	
menu(String id) // Process a menu entry. 

	type public String ftable(),mtable(),xmtable(),subs
	
	type String x,z

	type RecordSCAMENU0 scamenu0=Db.getRecord("SCAMENU0","MENU=:id",1)
	set x=scamenu0.des
	write "Menu ",$j(id,6),":  ",x,!
	
	type RecordI18NMOD i18nmod=Db.getRecord("I18NMOD","MOD=:subs,ITEM=3,NAME=:id",1)
	set i18nmod.des=x
	do i18nmod.bypassSave()
	
	type ResultSet rs=Db.select("ITEM,NAME","I18NMODX","MENU=:id")
	if 'rs.isEmpty() set xmtable(id)=""
	kill mtable(id)
	
	set x=""
	type ResultSet rs1=Db.select("FUNMENU","SCAMENU","MNUMB=:x")
	while rs1.next() do {
		set z=rs1.getCol("FUNMENU")
		if z?.n do {
			set mtable(z)=0
			type ResultSet rs2=Db.select("ITEM,NAME","I18NMODX","MENU=:z")
			if 'rs2.isEmpty() set xmtable(z)=""
			}
		else  set ftable(z)=0
		}
	
	quit
	
func(String id) //	Process one function entry. 
	
	type public String line,nfound(,),rtable(),subs

	type String x,y,z

	write "Func ",id,?18
	type RecordSCATBL scatbl=Db.getRecord("SCATBL","FN=:id",1)
	if 'scatbl.getMode() write *7,"**** NOT FOUND ****",! set nfound(1,id)="" quit
	set y=scatbl.desc,z=scatbl.pgm
	write y,!
	// scan function pre-processor
	set line=scatbl.prp do scans,scanr
	// scan function post-processor
	set line=scatbl.pop do scans,scanr

	type RecordI18NMOD i18nmod=Db.getRecord("I18NMOD","MOD=:subs,ITEM=4,NAME=:id",1)
	set i18nmod.des=y
	do i18nmod.bypassSave()

	set z=(z.piece("^",2)).piece("(")
	set rtable(z)=0

	quit
	
rout(String id) //	Process a single routine. 

	type public Number lineno
	type public String deeptbl(),indir,line,nfound(,)

	type String a,file,IO,IOPAR,IOTYP
	
	write "Rout ",id

	set deeptbl(id)="" // save routine
	set file=id,lineno=0
	if file.extract()="%" set file="_"_file.extract(2,file.length())
	set file=indir_file_".m"
	set a=$$SEARCH^%ZFUNC(file)
	if a="" write ?18,*7,"**** NOT FOUND ****",! set nfound(2,file)="" quit
	write !
	set IO=file
	set IOPAR="readonly"
	set IOTYP="RMS"
	do OPEN^SCAIO
	for  read line quit:$zeof  do {
		set lineno=lineno+1
		do scans,scanr
		}
	close IO use $p

	quit
	
scans	//  Scan the routine text for SIDs.

	type public Number index
	type public String line,s1,s2

	type Number i,n
	
	set index=2
	set n=line.length(s1)
	if n>1 for i=2:1:n do scan(line.piece(s1,i))
	set n=line.length(s2)
	if n>1 for i=2:1:n do scan(line.piece(s2,i))
	
	quit

scanr	//  Scan the routine text for RIDs.

	type public Number index
	type public String line,r1,r2

	type Number i,n
	
	set index=5
	set n=line.length(r1)
	if n>1 for i=2:1:n do scan(line.piece(r1,i))
	set n=line.length(r2)
	if n>1 for i=2:1:n do scan(line.piece(r2,i))

	quit
	
scan(String x) //  Scan a SID= or RID= argument.

	type public Number i,lineno
	type public String id
	
	set lineno=+(lineno.get())
	if x.extract()?1UL do error(id,lineno,i-1,1) quit
	if x.extract()=" " do error(id,lineno,i-1,6) quit
	if x.extract()="$" do error(id,lineno,i-1,2) quit
	if x.extract()="""" do scanit quit
	do error(id,lineno,i-1,4)

	quit
	
scanit //  Scan a quote delimited string.
	
	type public Number i,lineno,x
	type public String id

	type String n,y,z

	set y=x.extract(2,x.length()),n=y.piece(""""),z=y.piece("""",2)
	if n="" do error(id,lineno,i-1,5) quit
	if z="" do save quit
	if z.extract()=" " do save quit
	if z.extract()="," do save quit
	if z.extract()=$C(9) do save quit
	do error(id,lineno,i-1,3)

	quit
	
save	//  Save data in ^I18NMOD.
	
	type public Number index
	type public Number deeptbl(),id,n,subs

	type Number g
	type String f,rn

	type RecordI18NMOD i18nmod=Db.getRecord("I18NMOD","MOD=:subs,ITEM=:index,NAME=:n",1)
	set i18nmod.des=id
	do i18nmod.bypassSave()
	
	if index=2 do {
		type RecordDBTBL2 dbtbl2=Db.getRecord("DBTBL2","LIBS='SYSDEV',SID=:n",1)
		if 'dbtbl2.getMode() quit
		set f=dbtbl2.pfid
		set rn=dbtbl2.vpgm
		if 'rn.isNull() set deeptbl(rn)=""
		}

	if index=5 do {
		type RecordDBTBL5H dbtbl5h=Db.getRecord("DBTBL5H","LIBS='SYSDEV',RID=:n",1)
		if 'dbtbl5h.getMode() quit
		set f=dbtbl5h.pfid
		set rn=dbtbl5h.pgm
		if 'rn.isNull() set deeptbl(rn)=""
		}

	for g=1:1:$l(f,",") do {
		type RecordI18NMOD i18nmod=Db.getRecord("I18NMOD","MOD=:subs,ITEM=1,NAME=:f.piece("","",g)",1)
		set i18nmod.des=n_"|"_index
		do i18nmod.bypassSave()
		}

	quit
	
error(String r,Number l,Number i,Number n) //	Error processing - global ^I18NMODE

	type public Boolean errflg,TMPER()
	type public String line,subs,x
	
	if l=1 quit		; Do not report error for line 1 of routine (header)
	if errflg=0 do { quit
		type RecordI18NMODE i18nmode=Db.getRecord("I18NMODE","MOD=:subs,TYP='FULL',RTN=:r,LINE=:l,NUM=:i,ERR=:n",1)
		set i18nmode.exp=x
		do i18nmode.save()

		type RecordI18NMODE1 i18nmode1=Db.getRecord("I18NMODE1","MOD=:subs,TYP='FULL',RTN=:r,LINE=:l",1)
		set i18nmode1.code=line
		do i18nmode1.save()
		}
	else  do {
		set TMPER(r,l,i,n)=x
		set TMPER(r,l)=line
		type RecordI18NMODE i18nmode=Db.getRecord("I18NMODE","MOD=:subs,TYP='FULL',RTN=:r,LINE=:l,NUM=:i,ERR=:n",1)
		if (i18nmode.exp'=x) do {
			type RecordI18NMODE i18nmode=Db.getRecord("I18NMODE","MOD=:subs,TYP='NEW',RTN=:r,LINE=:l,NUM=:i,ERR=:n",1)
			set i18nmode.exp=x
			do i18nmode.save()

			type RecordI18NMODE1 i18nmode1=Db.getRecord("I18NMODE1","MOD=:subs,TYP='NEW',RTN=:r,LINE=:l",1)
			set i18nmode1.code=line
			do i18nmode1.save()
			}
		}
	quit
	
subsPP // post processor on Subsystem prompt

	type public Boolean ER
	type public String dqdir,indir,RM,subs,X

	type Number MRES

	set indir=$$CURR^%DIR
	set dqdir=indir.extract(1,indir.length()-1)_".CRTNS]"
	set indir=indir.extract(1,indir.length()-1)_".MRTNS]"

	type RecordI18NMOD1 i18nmod1=Db.getRecord("I18NMOD1","MOD=:X",1)
	if (i18nmod1.getMode()) do {
		do DEFAULT^DBSMACRO("@desc",i18nmod1.des)
		do DEFAULT^DBSMACRO("@menu",i18nmod1.name)
		do PROTECT^DBSMACRO("desc")
		if '((i18nmod1.getMode())#10) do UNPROT^DBSMACRO("desc")
		// I18N Module Found
		set RM=$$^MSG(5458)
		set MRES=$$^DBSMBAR(17) // Modify, Delete, Quit
		// Not updated
		if (MRES=0)!(MRES=3) do Runtime.setErrMSG("I18NMOD1",5459)
		if (MRES=2) do {
			do Db.fastDelete("I18NMOD","MOD=:X")
			do Db.fastDelete("I18NMOD1","MOD=:X")
			do Db.fastDelete("I18NMODE","MOD=:X")
			do Db.fastDelete("I18NMODE1","MOD=:X")
			// Deleted
			do Runtime.setErrMSG("I18NMODE",805)
			do DELETE^DBSMACRO("ALL")
			do DEFAULT^DBSMACRO("@subs","")
			do GOTO^DBSMACRO("@subs")
			}
		if (MRES=1) set ER=0 kill RM
		}
	else  do {
		do UNPROT^DBSMACRO("desc")
		// New Module
		set ER="W",RM=$$^MSG(5469)
		}

	quit
	
msgpr	/* Search for routines being used within menu selected.
	 When table of routines (deeptbl) has been created,
	 search for calls to $$^MSG, and uses of new UTLREAD
	 prompts and DBSMBAR. Add these items to the module
	 table. Note: deeptbl already contains the first level
	 routines that will be called. */

	type public String deeptbl(),x
	
	write !,"Scanning for sub-routines...",!!
	// build deeptbl
	set x="" for  set x=deeptbl(x).order() quit:x=""  do buildt(x) 
	write !,"Scanning for messages...",!!
	// find messages
	set x="" for  set x=deeptbl(x).order() quit:x=""  do findm(x)

	quit
	
buildt(String id) // Process a single routine. 

	type public Number lineno
	type public String dqdir,file,indir,line

	type String a,dir,fst,IO,IOPAR,IOTYP
	
	write $C(13),id,"           "
	set file=$$UPPER^%ZFUNC(id),lineno=0
	set dir=indir,fst=file.extract()
	if (file.extract()="V")!(file.extract()="R") set dir=dqdir,fst=file.extract(2)
	set file=dir_file_".m"
	set a=$$SEARCH^%ZFUNC(file)
	// routine not found
	if a.isNull() quit
	set IO=file
	set IOPAR="readonly"
	set IOTYP="RMS"
	do OPEN^SCAIO
	for  read line quit:$zeof  do {
		set lineno=lineno+1
		// scan for routine names and update deeptbl
		do scand
		// Scan for SID's & RID's
		do scans,scanr
		}
	close IO use $p

	quit
	
scand	/* Scan a line for routine name to add to deeptbl,
	 This procedure will only find routine names called by the
	 current routine without line tags and with a proceeding DO
	 % routines and certain utilities will be skipped
	
	 e.g.	"D ^xxxx" will add xxxx to deeptbl
		"D LINE^xxxx" will not
		"D ^xxxx,^yyyy will only find xxxx */

	type public String deeptbl(),file,fst,line

	type String n

	// strip off comments
	set n=$$UPPER^%ZFUNC(line.piece(";"))
	// find routine name
	set n=n.piece("D ^",2)
	if n'="" do {
		// change whitespace to ~'s
		set n=n.translate($C(9)_""" ,(|","~~~~~~")
		// piece before whitespace must be routine name
		set n=n.piece("~")
		// % routine or indirection
		if (n.extract()="%")!(n.extract()="@") quit
		// skip DataQwik
		if n.extract(1,3)="DBS" quit
		// skip utility routines unless called by one
		if n.extract()="U",fst'="U" quit
		// skip SCA routines unless called by one
		if n.extract(1,3)="SCA",fst'="S" quit
		if n'="" set deeptbl(n)=file.get()
		}
	quit
	
findm(String id) // Process a single routine. 

	type public Number lineno
	type public String dqdir,file,indir,line

	type Boolean dq
	type String a,dir,IO,IOPAR,IOTYP
	
	write $C(13),id,"           "
	set file=$$UPPER^%ZFUNC(id),lineno=0
	set dq=0
	// default to .MRTNS
	set dir=indir
	if (file.extract()="V")!(file.extract()="R") set dir=dqdir,dq=1
	set file=dir_file_".m"
	set a=$$SEARCH^%ZFUNC(file)
	// routine not found
	if a="" quit
	set IO=file
	set IOPAR="readonly"
	set IOTYP="RMS"
	do OPEN^SCAIO

	for  read line quit:$zeof  do {
		set lineno=lineno+1
		// kill comments
		set line=line.piece(";") quit:line=""
		set line=$$UPPER^%ZFUNC(line)
		// scan for messages
		do scanm
		// scan for UTLREAD prompts (unless in DataQwik)
		if 'dq do scanu
		// scan for DBSMBAR
		do scanb
		}

	close IO use $p

	quit
	
scanm	//  Scan the routine text for calls to $$^MSGs.

	type public Number index
	type public String id,line,subs

	type Number i,n
	type String fnd
	
	set index=99
	set n=line.length("$$^MSG(")
	if n>1 for i=2:1:n do { 
		// fnd = "###,~p1...) rest of line"
		set fnd=line.piece("$$^MSG(",i)
		set fnd="M_"_+fnd
		type RecordI18NMOD i18nmod=Db.getRecord("I18NMOD","MOD=:subs,ITEM=:index,NAME=:fnd",1)
		set i18nmod.des=id
		do i18nmod.bypassSave()
		}

	quit
	
scanu	//  Scan the routine text for %TAB sets.
	
	type public Number index
	type public String id,line,subs

	type Number i
	type String fnd,n

	set index=99
	// get back end of %TAB line
	set n=line.piece("%TAB(",2)
	if n'="" do {
		// find prompt table ptr
		set n=n.piece("=",2),n=n.piece(".",2)
		set fnd="U_"
		if n'="" do {
			for i=1:1 quit:((n.extract(i)="""")!(n.extract(i)="/")!(n.extract(i)=""))  set fnd=fnd_n.extract(i)
			}
		type RecordI18NMOD i18nmod=Db.getRecord("I18NMOD","MOD=:subs,ITEM=:index,NAME=:fnd",1)
		set i18nmod.des=id
		do i18nmod.bypassSave()
		}

	quit
	
scanb	//  Scan the routine text for calls to DBSMBAR

	type public Number index
	type public String id,line,subs

	type Number i,n
	type String fnd
	
	set index=99
	set n=line.length("^DBSMBAR(")
	if (n>1) for i=2:1:n do {
		// fnd = "###,...) rest of line"
		set fnd=line.piece("^DBSMBAR(",i)
		// fnd = "B_###"
		set fnd="B_"_+fnd
		type RecordI18NMOD i18nmod=Db.getRecord("I18NMOD","MOD=:subs,ITEM=:index,NAME=:fnd",1)
		set i18nmod.des=id
		do i18nmod.bypassSave()
		}

	quit
	
modx	//  Check the ^I18NMODX global for extra screens/reports to include 
	
	type public Number index
	type public String id,x,xmtable()

	type String m,n

	set m=""
	for  set m=xmtable(m).order() quit:m=""  do {
		type ResultSet rs=Db.select("ITEM,NAME,DESC","I18NMODX","MENU=:m")
		while rs.next() do {
			set index=rs.getCol("ITEM")
			set n=rs.getCol("NAME")
			set x=""""_n_""""
			set id=rs.getCol("DESC")
			do scanit
			}
		}

	quit
	
errlog //  Update ^I18NMODE global

	type public String subs,TMPER()
	
	type Number l,i,n
	type String mod,r,x,y

	type DbSet ds=Db.selectDbSet("I18NMODE","MOD=:subs AND TYP='FULL'")
	while ds.next() do {
		type RecordI18NMODE i18mode=ds.getRecord("I18NMODE")
		set mod=i18mode.mod
		set r=i18mode.rtn
		set l=i18mode.line
		set i=i18mode.num
		set n=i18mode.err
		set y=i18mode.exp
		type RecordI18NMODE1 i18mode1=Db.getRecord("I18NMODE1","MOD=:subs,TYP='FULL',RTN=:r,LINE=:l",1)
		set x=i18mode1.code
		
		if (TMPER(r,l,i,n).get()'=y) do {
			set i18mode.mod=subs
			set i18mode.typ="MISSING"
			set i18mode.RTN=r
			set i18mode.line=l
			set i18mode.num=i
			set i18mode.err=n
			set i18mode.exp=y
			if i18mode.getMode()=1 do i18mode.setMode(0)
			do i18mode.bypassSave()

			set i18mode1.typ="MISSING"
			set i18mode1.code=x
			if i18mode1.getMode()=1 do i18mode1.setMode(0)
			do i18mode1.bypassSave()
			}
		}

	do Db.fastDelete("I18NMODE1","MOD=:subs,TYP='FULL'")
	do Db.fastDelete("I18NMODE","MOD=:subs,TYP='FULL'")
		
	for  set r=TMPER(r).order() quit:r=""  do {
      	for  set l=TMPER(r,l).order() quit:l=""  do {
			type RecordI18NMODE1 i18mode1=Db.getRecord("I18NMODE1","MOD=:subs,TYP='FULL',RTN=:r,LINE=:l",1)
			set i18mode1.code=TMPER(r,l).get()
			do i18mode1.bypassSave()
			for  set i=TMPER(r,l,i).order() quit:i=""  do {
				for  set n=TMPER(r,l,i,n).order() quit:n=""  do {
					type RecordI18NMODE i18mode=Db.getRecord("I18NMODE","MOD=:subs,TYP='FULL',RTN=:r,LINE=:l,NUM=:i,ERR=:n",1)
					set i18mode.exp=TMPER(r,l,i,n).get()
					do i18mode.bypassSave()
					}
				}
			}
		}

	kill TMPER

	quit

vSIG()	quit "60239^21595^Balasubramonian Sankar^16376"	// Signature - LTD^TIME^USER^SIZE
