UEXTRMAP		/*
	PROCEDURE:  UEXTRMAP
	ORIG: Fan Zeng - 09/01/95
	DESC: Data Map Maintenance
 
	---- Comments --------------------------------------------------------
	Use this routine to create, modify, delete and inquire data maps for 
	data extraction. When a data map is created or modified, a data 
	extraction routine will be generated accordingly. If a data map is 
	deleted, the associated data extraction routine is deleted.
	
	---- Revision History ------------------------------------------------

        08/02/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.
	
	12/30/03 - CARROLLJ - CR7658
		   Corrected precedence errors.

	02/17/03 - Dan Russell - 51351
			   Modified to generate PSL instead of M code.

			   Removed old change history.

	*/
	
	// I18N=OFF
	
	quit		// Do not call from top

	
NEW	// Public - Create
	do INIT(0,0)
	quit

	
UPD	// Public - Maintenance
	do INIT(1,0)
	quit
	
	
INQ	// Public - Inquiry
	do INIT(2,0)
	quit
	
	
DEL	// Public - Delete
	do INIT(3,0)
	quit
	
	
CMP	// Public - Compile
	do INIT(1,1)
	quit
	

INIT(Number %ProcessMode,	// Private - Prompt for data map name
	Number COMPILE)

	type Public Number ER=0
	
	type Number %FRAME
	type String EXTRACT(),IO,MAP,%NOPRMT,%READ,%TAB(),VFMQ

	if %ProcessMode=0 set %TAB("MAP")=".MAPNAME1"
	else  set %TAB("MAP")=".MAPNAME2"
	if %ProcessMode=2 set %TAB("IO")=$$IO^SCATAB($I)

	set %READ="@@%FN,,MAP/REQ"
	if %ProcessMode=2 set %READ=%READ_",IO/REQ"
	
	set %NOPRMT="F"
	set %FRAME=2
	
	do ^UTLREAD quit:VFMQ="Q"
	
	type RecordEXTRACTDESC fEXTRDSC=Db.getRecord("EXTRACTDESC","MAP=:MAP",1)
	if 'fEXTRDSC.getMode() do {
		set fEXTRDSC.arcfid=MAP
		set fEXTRDSC.rtn=MAP.extract(1,8)
		}
	
	if COMPILE do COMPILE(MAP) quit

	if %ProcessMode=2,IO'=$I do OPEN^SCAIO quit:ER
	
	if %ProcessMode=0!(%ProcessMode=1)!(%ProcessMode=3) lock +EXTRACT(MAP)
	
	do PROCESS(.fEXTRDSC)
		
	if %ProcessMode=0!(%ProcessMode=1)!(%ProcessMode=3) lock -EXTRACT(MAP)
	
	if %ProcessMode=2,IO'=$P do CLOSE^SCAIO
		
	quit
	

PPMAP   // Private - Post processor for MAP variable in UTLREAD on create

	type Public Number ER
	type Public String RM,X

	if X'="",Db.isDefined("EXTRACTDESC","MAP=:X") do {
		set ER=1
		// Already created
		set RM=$$^MSG(252)
		}
	
	quit
	
	
PROCESS(RecordEXTRACTDESC fEXTRDSC)	// Private - Process the map
		
	type Public Number ER
	
	type Number ITEMCNT
	type String MAP,VFMQ
	
	set MAP=fEXTRDSC.map
	
	do DESC(.fEXTRDSC) quit:ER!(VFMQ="Q")
	
	if %ProcessMode=3 do { quit
		quit:VFMQ'="D"
		do Db.delete("EXTRACT","MAP=:MAP")
		do Db.delete("EXTRACTDESC","MAP=:MAP")
		// Remove old routine
		do DEL^%ZRTNDEL(fEXTRDSC.rtn)
		}
	
	type RecordEXTRACT fEXTRACT()
	
	do LOAD(fEXTRDSC.map,.fEXTRACT(),.ITEMCNT)

	do DETAIL(.fEXTRDSC,.fEXTRACT(),ITEMCNT) quit:ER!(VFMQ="Q")
	
	// Update database
	if %ProcessMode<2 do {
		type Number SEQ
		
		set fEXTRDSC.UID=%UserID
		set fEXTRDSC.LCD=%CurrentDate
		do fEXTRDSC.save()

		// Detail section - first delete all records, then add local records
		do Db.delete("EXTRACT","MAP=:MAP")

		// Move to new record to avoid potential problems with doing an
		// update on a record that doesn't exist.
		set SEQ=""
		for  set SEQ=$O(fEXTRACT(SEQ)) do { quit:SEQ=""
			quit:fEXTRACT(SEQ).srcdi=""

			type RecordEXTRACT EXTRACT=Class.new("RecordEXTRACT")

			set EXTRACT.map=MAP
			set EXTRACT.srcdi=fEXTRACT(SEQ).srcdi
			set EXTRACT.arcdi=fEXTRACT(SEQ).arcdi
			set EXTRACT.tblflg=fEXTRACT(SEQ).tblflg
			set EXTRACT.tbl=fEXTRACT(SEQ).tbl

			do EXTRACT.save()
			}
		}
	
	// Ask if want to compile
	if 'ER,%ProcessMode<2 do {
		type String X

		write $$BTM^%TRMVT
		// Compile extract program: Y
		write $$^MSG(3859),$C(8)
		read X
		if "Y"[$TR(X.extract(1),"y","Y") do COMPILE(MAP)
		}
		
	quit
	

DESC(RecordEXTRACTDESC fEXTRDSC)	// Private - General information of data map

	type Public String VFMQ
	
	type Number %PG
	
	// Force Continue prompt on first page, unless delete
	if %ProcessMode'=3 set %PG=-1

	do DRV^USID(%ProcessMode,"UEXTRMAP1",.fEXTRDSC)

	quit



DETAIL(RecordEXTRACTDESC fEXTRDSC,	// Private - Detail information of data map
	RecordEXTRACT fEXTRACT(),
	Number ITEMCNT)

	type Public String VFMQ
	
	type Number %MODS,%PAGE,%PG,%REPEAT
	
	set %REPEAT=15		// Number of lines per page
	
	if %ProcessMode=2 set %PAGE=((ITEMCNT-1)\%REPEAT)+((ITEMCNT-1)#%REPEAT'=0)
	else  set %PAGE=99
	
	set %PG=1

	if %ProcessMode=0 set %ProcessMode=1
	
	for  do { quit:VFMQ="F"!(VFMQ="Q")

		do DRV^USID(%ProcessMode,"UEXTRMAP",.fEXTRACT,.fEXTRDSC)
		quit:VFMQ="F"!(VFMQ="Q")
		set %PG=%PG+1
		set %MODS=((%PG-1)*%REPEAT)+1
		}

	quit
	

LOAD(String MAP,	// Private - Load existing detail data
	RecordEXTRACT fEXTRACT(),
	Number ITEMCNT)

	type Number SEQ

	set SEQ=1
	
	type DbSet ds=Db.selectDbSet("EXTRACT","MAP=:MAP")
	while ds.next() do {
		set fEXTRACT(SEQ)=ds.getRecord()
		set SEQ=SEQ+1
		}
		
	set ITEMCNT=SEQ-1

	quit


COMPILE(String MAP)	/* Public - Build data extraction routine from data map

	ARGUMENTS:
		. MAP		data map name		/REQ/NONULL/MECH=VAL

	EXAMPLE:
		do COMPILE^UEXTRMAP("ZDEPCL")

	Compiled program expects keys for the primary file to be passed in as
	public variables, with variable names the same as the key names.  E.g.,
	for table DEP or LN, pass variable CID, with the value of the account
	for which the extract is being done.
	*/
	
		
	type Public Number ER
	type Public String %MSKC,RM
	
	type Number ONETABLE
	type String CMPERR,CODE,COLLIST,EXTRACT(),PRIMTBL,PSLCODE()
	type String SOURCE,SRCKEYS(),TABLES,TRGTKEYS(),TRGTKLST,TRGTTBL
	
	type RecordEXTRACTDESC fEXTRDSC=Db.getRecord("EXTRACTDESC","MAP=:MAP",1)
	quit:'fEXTRDSC.getMode()
	
	set TABLES=fEXTRDSC.srcfid
	set PRIMTBL=TABLES.piece(",",1)
	set ONETABLE=TABLES'[","
	set TRGTTBL=fEXTRDSC.arcfid
	
	do GETKEYS(PRIMTBL,.SRCKEYS)
	do GETKEYS(TRGTTBL,.TRGTKEYS)

	// Build routine header
	set CODE=fEXTRDSC.rtn_$C(9)_"// Extract for MAP "_fEXTRDSC.map_" - "_fEXTRDSC.des
	do addcode(0,CODE)
	do ^SCACOPYR(.CODE)
	if CODE?1" ;;".E set CODE="// "_CODE.extract(4,999)
	do addcode(1,CODE)
	do addcode(0,"")
	do addcode(1,"// Built by procedure UEXTRMAP")
	do addcode(0,"")
	do addcode(1,"// Input expected of "_PRIMTBL_" keys "_$$KEYLIST(.SRCKEYS)_" identifying record to extract")
	do addcode(0,"")
	do addcode(0,"")
	do addcode(1,"type Public Cache %CACHE()")
	do addcode(1,"type Public String "_$$KEYLIST(.SRCKEYS))
	do addcode(0,"")
	
	// If only one table, instantiate the record.  Otherwise, build a SELECT and
	// use it to get the data, versus on object.
	
	if 'ONETABLE set COLLIST=""
	
	// Load extract definition into array
	type ResultSet rs=Db.select("SRCDI,ARCDI,TBLFLG,TBL","EXTRACT","MAP=:MAP")
	while rs.next() do {
		type String SOURCE,TARGET,X
		
		set SOURCE=rs.getCol("SRCDI")
		set TARGET=rs.getCol("ARCDI")
		set X=TARGET
		if rs.getCol("TBLFLG") set X=X_"|"_rs.getCol("TBL")
		set EXTRACT(SOURCE)=X
		
		if 'ONETABLE set COLLIST=COLLIST_SOURCE_","
		
		// If one of the target keys, save its source
		if TRGTKEYS(TARGET).data() set TRGTKEYS(TARGET)=SOURCE
		}
		
	if 'ONETABLE set COLLIST=COLLIST.extract(1,COLLIST.length()-1)
	
	if ONETABLE do {
		type Number I
		
		set CODE="type Record"_PRIMTBL_" source=Db.getRecord("""_PRIMTBL_""","""
		set CODE=CODE_$$KEYLIST(.SRCKEYS,",")_""",1)"
		do addcode(1,CODE)
		do addcode(1,"if 'source.getMode() quit"_$C(9,9)_"// No record")
		}
	else  do {
		// Build SELECT - break into small chuncks to avoid size issues with routine
		do addcode(1,"type Literal String COLUMNS")
		do addcode(0,"")

		if COLLIST.length()'>50 do addcode(1,"set COLUMNS="_$$QADD^%ZS(COLLIST))
		else  do {
			do addcode(1,"set COLUMNS=""""")
			for  do { quit:COLLIST=""
				do addcode(1,"set COLUMNS=COLUMNS_"_$$QADD^%ZS(COLLIST.extract(1,50)))
				set COLLIST=COLLIST.extract(51,COLLIST.length())
				}
			}
		do addcode(0,"")
	
		set CODE="type ResultSet rs=Db.select(COLUMNS,"_$$QADD^%ZS(TABLES)_","""
		set CODE=CODE_$$KEYLIST(.SRCKEYS," AND ")_""","""","""",""DQMODE=1"")"
		do addcode(1,CODE)
		do addcode(1,"if rs.isEmpty() quit  // No data")
		do addcode(0,"")
		do addcode(1,"if rs.next()")		// Load first record
		}
		
	do addcode(0,"")
	
	// Instantiate the target
	set CODE="type Record"_TRGTTBL_" target=Db.getRecord("""_TRGTTBL_""","
	set CODE=CODE_$$QADD^%ZS($$KEYMAP(.TRGTKEYS,ONETABLE))_",1)"
	do addcode(1,CODE)
	do addcode(0,"")
	
	// Build map from source to target
	set SOURCE=""
	for  set SOURCE=$O(EXTRACT(SOURCE)) quit:SOURCE=""  do {
		type String CODE,COLUMN,TABLE,TARGET
		
		set TARGET=EXTRACT(SOURCE).piece("|",1)
		set TABLE=EXTRACT(SOURCE).piece("|",2)
		set COLUMN=$$LOWER^%ZFUNC(SOURCE.piece(".",2))
		
		// If a target key, already dealt with by instantiation
		if TRGTKEYS(TARGET).data() quit
		
		if TABLE="" do {
			set CODE="set target."_$$LOWER^%ZFUNC(TARGET)_"="
			if ONETABLE set CODE=CODE_"source."_COLUMN
			else  set CODE=CODE_"rs.getCol("""_SOURCE_""")"
			do addcode(1,CODE)
			}
		else  do TBLCODE(SOURCE,TARGET,ONETABLE,COLUMN)
		}
		
	// Save the target record
	do addcode(0,"")
	do addcode(1,"// Save archive record")
	do addcode(1,"do target.save()")

	// All done
	do addcode(0,"")
	do addcode(1,"quit")

	// Compile the routine
	do BUILDRTN^UCGM(.PSLCODE,fEXTRDSC.rtn,.CMPERR)
	if $D(CMPERR) do {
		type Number N=""

		for  set N=$O(CMPERR(N)) quit:N=""  do {
			if 'ER set ER=1,RM=CMPERR(N)
			write CMPERR(N),!
		}
	}
	
	//Completed at ~p1
	if 'ER set ER="W",RM=$$^MSG(591,$$TIM^%ZM(%CurrentTime,$G(%MSKC)))
	
	quit


TBLCODE(String SOURCE,	// Private - Generate code for table description
	String TARGET,
	Number ONETABLE,
	String COLUMN)
		
	type Number I
	type String DESCCOL,KEY,KEYS,TBL,WHERE

	set TBL=$$TBL^DBSDD(SOURCE)
	
	// Must be [TABLE] syntax
	if TBL'?1"["1E.E1"]" do addcode(1,"Invalid table for "_SOURCE) quit
	set TBL=$TR(TBL,"[]")
	
	/* Set up code to retrieve table description.  For now, find
	   the first column and use it.  If we eventually come up with
	   a standard name for the description column for a table, then
	   modify to use that.
	*/

	do GETKEYS(TBL,.KEYS)		// First, get access keys

	// Find description column
	type ResultSet dbtbl1d=Db.select("DI","DBTBL1D","%LIBS='SYSDEV' AND FID=:TBL AND POS=1")
	
	if dbtbl1d.isEmpty() do addcode(1,"No description column for "_SOURCE_" table "_TBL) quit
	
	while dbtbl1d.next() do { quit		// Only care about 1st in case more
		set DESCCOL=dbtbl1d.getCol("DI")
		}

	set (KEY,WHERE)=""
	for  set KEY=$O(KEYS(KEY)) quit:KEY=""  do {
		type String VALUE
		
		if ONETABLE set VALUE="source."_COLUMN
		else  set VALUE="rs.getCol("""_SOURCE_""")"
		set WHERE=WHERE_KEY_"=:"_VALUE_","
		set WHERE=WHERE.extract(1,WHERE.length()-1)
		}

	do addcode(1,"do {")
	do addcode(2,"type Record"_TBL_" tbl=%CACHE("""_TBL_""").getRecord("""_TBL_""","_$$QADD^%ZS(WHERE)_")")
	do addcode(2,"set target."_$$LOWER^%ZFUNC(TARGET)_"=tbl."_DESCCOL)
	do addcode(2,"}")

	quit		
		
		
GETKEYS(String TABLE,	// Private - Get keys for TABLE
	String KEYS())

	type Number I
	type String ACCKEYS

	kill KEYS

	type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS=""SYSDEV"",FID=:TABLE")
	set ACCKEYS=$$TOKEN^%ZS(dbtbl1.acckeys)
	
	for I=1:1:$L(ACCKEYS,",") do {
	
		type String KEY
	
		set KEY=$P(ACCKEYS,",",I)
		quit:KEY?1.N				// Ignore numeric keys
		quit:$E(KEY)=$C(0)			// Ignore literal strings
		set KEYS(KEY)=""
		}
	
	quit
	

KEYLIST(String KEYS(),	// Private - Return key string
	String DELIM)
		
	/* Return KEY1=:KEY1,KEY2=:KEY2 for Db.getRecord (DELIM=","),
	   or KEY1=:KEY1 AND KEY2=KEY2 for Db.select (DELIM=" AND "),
	   or KEY1,KEY2 if no delimiter.
	*/

	type String KEYLIST,N
	
	set (KEYLIST,N)=""
	for  set N=$O(KEYS(N)) quit:N=""  do {
		if DELIM.get()'="" set KEYLIST=KEYLIST_N_"=:"_N_DELIM
		else  set KEYLIST=KEYLIST_N_","
		}
	
	if DELIM.get()'="" set KEYLIST=KEYLIST.extract(1,KEYLIST.length()-DELIM.length())
	else  set KEYLIST=KEYLIST.extract(1,KEYLIST.length()-1)
	
	quit KEYLIST

	
KEYMAP(String KEYS(),	// Private - Return Db.getRecord target from source key map
	Number ONETABLE)
		
	type String COLUMN,KEYLIST,N,SOURCE
	
	set (KEYLIST,N)=""
	for  set N=$O(KEYS(N)) quit:N=""  do {
		set SOURCE=KEYS(N)
		if SOURCE="" set SOURCE="??.??"			// Missing key map
		if ONETABLE do {
			set COLUMN=$$LOWER^%ZFUNC(SOURCE.piece(".",2))
			set KEYLIST=KEYLIST_N_"=:source."_COLUMN_","
			}
		else  set KEYLIST=KEYLIST_N_"=:rs.getCol("""_SOURCE_"""),"
		}
		
	quit KEYLIST.extract(1,KEYLIST.length()-1)
	
	
addcode(Number TABS,	// Private - Add new line to PSLCODE array
	String LINE,
	Number LINENO)

	/* If LINENO not null, use it.  Return used line number in LINENO.
	   If TABS<0, assume line already formatted and don't remove or add
	   tabs or left spaces.
	*/

	type Public String PSLCODE()

	if TABS>0 do {
		type Number I

		for I=1:1:TABS set LINE=$C(9)_LINE
		}

	if LINENO.get()="" set LINENO=$O(PSLCODE(""),-1)+1
	set PSLCODE(LINENO)=LINE
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60219^28712^Sunil Agithakaliya^12331"	// Signature - LTD^TIME^USER^SIZE
