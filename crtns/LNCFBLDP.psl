LNCFBLDP		//;PBS - LN - V3.6 - Generic Cash Flow Array Builder - Pmt Plans
	/*
	
	   Builds CF array in the following structure:
	
	       CF(n)=1 | 2 | 3 | 4 | 5 || 7 | 8
	
	       where:
	
	       1 = The payment amount
	       2 = The number of occurances of #1
	       3 = The interest rate at which the payment amount was calculated
	       4 = Whether a fixed principal amount was included in the payment
		   amount in #1
	       5 = The principal portion of the payment.
	       7 = The due date of each payment
	       8 = The balance after this payment (or series of payments is
		   applied.
	
	   Payment plans' CF arrays have the distinction of having many zero
	   payment amount entries by virtue of the fact that payment plans
	   have (generally) no regular payment frequencies.  Because of this,
	   the annual factor for calculations must be 365 (daily).  For periods
	   of time between payments, cash flow entries will be set for zero
	   amounts.

   ---- Revision History ------------------------------------------------
	12/09/03 - CARROLLJ - CR7239
		   Modified I1 section to accept recordln as parameter.	

	12/10/01 - SCOTTC - 43583
		   Convert to PSL.  Remove old revision history.
		   Remove EXT & PCH section since nothing calls to them anymore.
	

	*/
	quit


public	APR(RecordLN ln) // Called from ^LNAPR to build CF
	/*
	Arguments: Routine expects BASE and %PR to be hanging around
 
	. RecordLN ln  Loan object	 	     /TYP=object/REQ
 
 
	Returns:
 
	CF	     Cash flow array
 
	Example:
 
	D APR^LNCFBLDR(.ln)
 
	*/
	
	new APR,%EXT,NEW
	set (NEW,APR)=1 set (%EXT,ACR)=0
	// Credit Limit - Current
	set BASE=ln.crlmt
	// Interest Prepaid Date
	set LIDD=ln.amodt set CFDT=LIDD-1
	// Distribution 1 Last Due
	set NDD=ln.dist1ld

	Type RecordLNPS1 lnps1()
	do N1(.ln,.lnps1())
	quit


public	NEW(RecordLN ln) // Called from ^LNNFNEW1

	/* The function is called from ^LNNFNEW1 to compute 
	   net investment yield


	Arguments:
 
	. ln			/TYP=LN object/REQ/MECH=VAL
 				
 
	Example:
 
	do NEW^LNCFBLDP(.ln)
 
	*/
	new APR,NEW,TYP,TYPE,%EXT
	set (%EXT,APR,ACR)=0 set NEW=1

	set P=ln.nfplnorg
	set TYPE=ln.type
	if P="" set P=Db.getOneRow("FPLN","PRODCTL","TYPE") if P="" quit 
	set PLAN=P
	set TYP="PTS"
	set PAYEE=1
	if PLAN(P)=Db.getOneRow("FMET","AOAMO","TYP,PAYEE,PLAN") quit
	set BASE=ln.bal
	// Unadvanced Balance
	if ln.aruf set BASE=BASE-ln.udbal
	// Distribution 1 Last Due
	set NDD=ln.dist1ld
	set LIDD=%SystemDate-1 
	set CFDT=LIDD
	set ACR=ln.acr

	Type RecordLNPS1 lnps1()
	do N1(.ln,.lnps1())
	quit
	
N1(RecordLN ln,RecordLNPS1 lnps1()) 
	
	new B,INTPRI,MDT,N,ODD,PI,PRINPRI

	// Original Disbursement Date
	set ODD=ln.odd
	if 'NEW set ODD=%SystemDate
	// Account Maturity Date
	set MDT=ln.mdt
	
	if $G(NSIP)="" set NSIP=1

	//  Create lnps1 object array
	do LNPS(ln.cid,.lnps1())
	
	// INTPRI and PRINPRI are initially the P+I distributions.  
	
	set N="" set (PRINPRI,INTPRI,PI)=0
	for  set N=$O(lnps1(N)) quit:N=""  do {
		if lnps1(N).d3f,lnps1(N).d2f="P"!(lnps1(N).d2f="I") do {
			set P=lnps1(N).d4f set PI=1
			if B="P" do {
				set P=P-1
				if P=1 set PRINPRI=lnps1(N).d2f
				else  if P=2 set PRINPRI=lnps1(N).d3f
				else  if P=3 set PRINPRI=lnps1(N).d4f
				else  if P=4 set PRINPRI=lnps1(N).fpc
				else  set INTPRI=0
				}
			if B="I" do {
				set P=P-1
				if P=1 set INTPRI=lnps1(N).d2f
				else  if P=2 set INTPRI=lnps1(N).d3f
				else  if P=3 set INTPRI=lnps1(N).d4f
				else  if P=4 set INTPRI=lnps1(N).fpc
				else  set INTPRI=0
				}
			}
		}
	// No principle or interest
	if 'PI quit 
	do N2(.ln,.lnps1())
	
	quit

N2(RecordLN ln,RecordLNPS1 lnps1()) 
	
	new BUSOPT,NBDC
	// Int/Div Index
	set INDEX=ln.index
	// Fixed Interest Amount
	set FIA=ln.fia
	// Fixed Principal Amount
	set FPA=ln.fpa
	
	// If there's no maturity date we cannot build CF.
	// Payment Term

	set TRM=ln.trm 
	if TRM="" set TRM=ln.ptrm
	if MDT="",TRM="" quit 
	set BUSOPT=ln.busopt	 	
	set NBDC=ln.nbdc	 	  
	if MDT="" do {
		set ODT=ODD 
		set MDT=$$EXT^UMDT(TRM,ODT,0,BUSOPT,NBDC)
		}
       if '%EXT do {
	
		// If for some reason we know we cannot use the existing CF, proceed.
		if $G(KILLCF) quit
	
		// If this is a standard new loan, do not subject it to this processing,
		// as ^LNNEW has already built a good CF.
    		if $G(KEEPCF) do END1 quit
		kill CF,X
		}
	

	if $G(KEEPCF) do END1 quit
	set KEEPCF=1
	// Interest Accrual Method
	set IACM=ln.iacm
	set DENOM=$$DY^UIC(IACM,ODD)*100
	set IRN=ln.irn
	// Interest Calculation Period Frequency
	set ICPF=ln.icpf
	if ICPF="" set (SCHLD,SCHND)=""
	if ICPF'="" set FRE=ICPF set JD=ODD do ^UFRE set SCHLD=JD set SCHND=NJD
	// Index Rounding Option
	set IRF=ln.irf
	// Int/Div Check Frequency
	set INTFRE=ln.intfre
	// Int/Div Change - Next Date
	set ICHND=ln.ichnd
	if 'ICHND,INTFRE'="" do {
		// Interest Prepaid Date
		set JD=ln.amodt
		if 'JD set JD=ODD
		set NJD=$$NJD^UFRE(JD,INTFRE,,)
		// Int/Div Change - Last Date
		set ICHND=NJD set ln.ichld=JD
		}
	
	// Int/Div Change - Last Date
	set ICHLD=ln.ichld
	if 'ICHLD,INTFRE'="" do {
		if ODD=%SystemDate set ln.ichld=ODD quit      
		set FRE="-"_INTFRE
		set JD=ICHND
		for  do { quit:(NJD<ODD)!(NJD=ODD)  
			set NJD=$$NJD^UFRE(JD,FRE,,)
			set JD=NJD quit:ER  
			if NJD<%SystemDate,NJD>ODD quit
			}
		if NJD<ODD set ln.ichld=ODD quit      
		// Int/Div Change - Last Date
		set ICHLD=NJD set ln.ichld=NJD
		}

	
	set SEQ=""
	set NIDD=ICHND 
	if 'NIDD do {
		set SEQ=$O(lnps1(SEQ))
		set NIDD=lnps1(SEQ).pdd
		}
	
	set (ISTP,CNT,CHG)=0
	
	/* 
	NSIP indicates whether the loan has a non-standard rate of
	amortization.
	
	If the loan rate is fixed, at a premium, or at a discount with no
	prepayment penalty, or a prepayment penalty that is not 100% of term,
	amortize to 0.00 net def fee.  In this case, NSIP is set to 1, and
	amortization will cease at 0.00 net def fee.  This is the "standard"
	method of handling net def fee amortization for all loans, except
	those under methods 2 and 3.
	
	If the loan rate is at a discount with 100% of term prepayment
	penalty, NSIP will be set to 2.  Amortization will run to maturity,
	but the amount required to satisfy the loan will be checked.
	*/

	if 'ICHND set ISTP=1 do AMO(.ln,.lnps1()) quit
	
	// Check the index without applying limits
	set par("INDEX")=ln.index
	do CTL^UINDX(.ln,,ODD,BASE,par,) if ER set RATE=IRN
	// rate in account is not prem/discount
	if RATE-IRN=0 set ISTP=1 do AMO(.ln,.lnps1()) quit
	// Ignore existing for checking NSIP.
	if 'NEW do AMO(.ln,.lnps1()) quit
	// Premium rate loan
	if RATE<IRN do AMO(.ln,.lnps1()) quit
	
	/* 
	Check the loan product type to see what the prepayment percentage
	age of term is.  If the prepayment percentage of term is not 100%,
	we cannot amortize.
	*/

	// Currency Code
	set CRCD=ln.crcd 
	
	set PRODCTL=Db.getOneRow("EPPOFF","PRODCTL","TYPE")
	if PRODCTL-100'=0 do AMO(.ln,.lnps1()) quit
	set NSIP=2
	do AMO(.ln,.lnps1())
	quit
	

AMO(RecordLN ln,RecordLNPS1 lnps1())	 
	/* 
	ISTP determines whether we must recalculate the loan rate 
	due to a premium/discount condition.  Until ISTP=1 we must 
	do ^UFRE to track interest change dates.
	*/


	new SEQ
	set PMT=0,SEQ=0
	for  set SEQ=$O(lnps1(SEQ)) quit:SEQ=""  do {
		set SVD=lnps1(SEQ).pdd
		if 'ISTP,ICHND<NDD do ICHND(.ln)
		set NIDD=NDD
		if NDD>MDT set (NIDD,NDD)=MDT quit
	
		/*
		The ACR line tag computes interest from LIDD to NIDD-1.  The
		computation of interest is independent of interest billing (the INT
		line tag).  That line only sets up a CF entry for the interest
		portion.
		*/

		do ACR(.ln)

		// "Bill" interest
		if INTPRI do INT(.ln)
	
		// Compute the principal portion due; "Bill" principal.
		
		if PRINPRI do {
			if NDD-CFDT-1>0 set CHG=NDD-CFDT-1 
			set PT=0 
			do CFARRAY(PT)
			set CFDT=NDD
			if lnps1(SEQ).fpc set FPA=lnps1(SEQ).fpc
			set PMT=(PMT+FPA)_"|1"
			set BASE=BASE-FPA
			}
	
		// If there's anything to bill, create a CF entry
		if PMT do {
			set PT=PMT 
			set CHG=1 
			do CFARRAY(PT)
			}

		// CHG counts the number of days between cash flow entries.
		
		// If the loan has reached it's end if the balance is fully amortized,
		// we can stop.
			
		if BASE<.01 quit
		} 

	if NDD="" set NDD=MDT
	do END(.ln)
	quit

		
ACR(RecordLN ln) // Compute running ACR balance between due dates
	
	new NJD
	if ICPF'="",SCHND<NDD do { quit:ER
		set NJD=$$NJD^UFRE(SCHND,ICPF,,) quit:ER
		set SCHLD=JD 
		set SCHND=NJD
		}
	if NIDD-LIDD<1 quit 

	set ACR=ACR+$$^UIC(BASE,LIDD,NIDD-1,IACM,IRN,0,ln.dist1af,ln.dist1fre,ln.icpf,ln.schnd,ln.schld)
	set LIDD=NIDD
	quit 
	
INT(RecordLN ln)
		if NDD-CFDT-1>0 do {
		set CHG=NDD-CFDT-1 
		set PT=0 
		do CFARRAY(PT) 
		set CFDT=NDD
		}

	if FIA set PMT=PMT+FIA quit 
	set PMT=PMT+ACR 
	set ACR=0
	do I1(.ln)
	quit
	
I1(RecordLN ln)

	if ISTP quit 
	if BASE'>0 quit 
	if ICHND>SVD quit 
	
	// If the loan is at a discount or premium, recalculate the new rate.
	do I4
	set NIDD=ICHND
	if NIDD>SVD set NIDD=SVD
	do ACR(.ln)
	do I5(.ln)
	quit 
	
I4	
	set NJD=$$NJD^UFRE(ICHND,INTFRE,,) quit:ER 
	set ICHLD=ICHND 
	set ICHND=NJD
	quit 
	
I5(RecordLN ln)
 
	new par	
	set par("INDEX")=ln.index
	set par("ROUND")=1
	do CTL^UINDX(.ln,ODD,BASE,.par,) if ER set (RATE,URATE)=IRN
	set IRN=+RATE
	
	/* 
	If the calculated index rate (RATE) agrees with the current loan rate
	(IRN) then we can stop calculating interest rate changes (ISTP).
	*/

	if RATE-URATE=0 set ISTP=1 quit 
	
	//Check for Minimum or Maximum interest rates
	if ln.intmx=RATE do {
		set ISTP=1 
		set ICHLD=ICHND 
		set ICHND=NDD(PRI) 
		}
	if ln.intmn=RATE do {
		set ISTP=1 
		set ICHLD=ICHND 
		set ICHND=NDD(PRI)
		}
	quit 
	
ICHND(RecordLN ln)
	/*
	 We must calculate the interest "accrued" when a variable
	 rate changes in between principal payment dates.  Even though there
	 may not be an interest payment date, because the rate may be changing,
	 we must determine the interest upto the ICHND, save it in ACR, and
	 then adjust the rate.
	
	*/

	set NDD=ICHND
	for  do { quit:(ICHND>SVD)
		do ACR(.ln)
		if NDD-CFDT>0 do {
			set CHG=NDD-CFDT-1 
			set PT=0 
			do CFARRAY(PT)
			}
	
		set CFDT=NDD 
		set NIDD=ICHND
		do ACR(.ln) 
		do I5(.ln) 
		do I4
		set NIDD=ICHND
		}
	set NDD=SVD set NIDD=NDD
	quit 
	
CFARRAY(PT)	// Place entry in CF array.

	if 'CHG quit 
	set CNT=CNT+1
	if +PT-(+PT\1) set PT=$$^SCARND(PT,0,$G(CID))_"|"_$P(PT,"|",2)
	set CF(CNT)=+PT_"|"_CHG_"|"_IRN_"|"_$S($P(PT,"|",2):"1|"_FPA,1:"|")_"||"_NDD_"|"_BASE
	set CHG=0
	quit 
	
END(RecordLN ln)
	if LIDD<NDD do ACR(.ln)
	if ACR-(ACR*100\100) set ACR=$$^SCARND(ACR+.005,0,$G(CID))
	if 'BASE,'ACR do END1 quit
	
	// If there are days outstanding, file them.
	if NDD-CFDT>0 do {
		set CHG=NDD-CFDT 
		set PT=0 
		do CFARRAY(PT)
		}
	
	if 'CNT do END1 quit
	
	set P=CF(CNT)
	
	// Last entry was multiple payment
	if $P(P,"|",2)>1 do {
		set $P(P,"|",2)=$P(P,"|",2)-1 
		set CF(CNT)=P 
		set CNT=CNT+1 
		set $P(P,"|",4)=0
		}	
	// This payment contains FPA
	if +P,$P(P,"|",4) do { quit
		set P=P+BASE 
		set BASE=BASE+FPA-P 
		set CF(CNT)=P+ACR_"|1|"_IRN_"|1|"_BASE_"||"_NDD 
		do END1 
		}	
	// This was interest only
	if +P do { quit
		set CF(CNT)=P+BASE+ACR_"|1|"_IRN_"|1|0||"_NDD 
		do END1
		}

	// This was a zero payment entry
	set PT=BASE+ACR 
	set CHG=1 
	do CFARRAY(PT)
	do END1
	quit
	
END1	kill BASE,CNT,ICHND,ISTP,CHG,BAL,INTFRE,PT,NDD,RATE,URATE,SV,IRN
	quit 
	
LNPS(CID,RecordLNPS1 lnps1())	// 

	/* 
	The function is used to Retrieve records from LNPS1 
	and create an LNPS1 object array 

	Arguments:
 
	. CID				/TYP=N/REQ/MECH=VAL
 
	Returns:
 
	. lnps1				/TYP=array of objects
 
	Example:
 
	do LNPS(ln.cid,.lnps1()) 
	*/
	
	new N,X
	set N=0,X=0
	type ResultSet rs=Db.select("PDD","LNPS1","CID=:CID AND PDD>:N")
	if rs.isEmpty() quit
	while 'rs.next() do { quit:ER
		set X=X+1
		set PDD=rs.getCol(1)
		set lnps1(X)=Db.getRecord("LNPS1","CID,PDD")
		}
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60281^29110^Marie Mbui^11222"	// Signature - LTD^TIME^USER^SIZE
