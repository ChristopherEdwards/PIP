TPINERR	// TAPE INCLEARING ERROR CONTROL
	/*
	ORIG: Michael Winigrad

	I18N=QUIT : Excluded from I18N standards

	---Revision History---------------------------------------------------

	03/28/06 - SATYANAS - CR19687
		   set BCHNUM=Db.nextVal("INCTAPEB","TAPENUM") , because it is 
		   throwing the runtime undefined error BCHNUM. Added the .getMode()
		   condition for INCTAPEB table. Replaced Public by public. 
		   Removed the parameter of KILBCH section, because it is throwing
		   the runtime error undefined object and it is creating the object
		   of the file INCTAPEB, so no need to pass to KILBCH section. 
	
	12/22/05 - PRAKASHJ - CR17423
		   Removed PSL deprecited features and warnings.
		   
        07/26/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.
	              
	06/17/03 - GRAY - 51351
		   Converted to PSL.  Removed the writing of purged records
		   to an RMS file and removed the restore section.  Removed 
		   old revision history.

	04/11/02 - MYERSK - 48421
	           Modifications to sections END2 and LV2222 to support
	           processing of duplicate batches.  ^INC("INDEX" will now
	           contain a list of tapes/batches associated with the index.
	           Also fixed bug in D section, where SRTOPT was not
	           being set when running function TTXBACC.
	           Removed Pre-2000 Revision History.

	*/


	// Standard error logging
	
	type public Date %EffectiveDate
	type public Number BCHCR,BCHDR,BCHNUM,BRCD,RECCNT,REJBCH,REJCR,REJDR,TAPENUM,TRNSRT
	type public String ERRMSG,%INST,%UserID
	
	do DISPLAY
	
	set BCHNUM=Db.nextVal("INCTAPEB","TAPENUM")

	type RecordINCTAPEB inctapeb=Db.getRecord("INCTAPEB","TAPENUM=:TAPENUM,BCHNUM=:BCHNUM",1)
	if inctapeb.getMode() do {
		set inctapeb.sts=1
		do inctapeb.bypassSave()
		}

	set REJBCH=REJBCH+1 set REJDR=REJDR+BCHDR.get() set REJCR=REJCR+BCHCR.get()

	type RecordINCBADTTXBCH badbch=Class.new("RecordINCBADTTXBCH")
	set badbch.tapenum=TAPENUM
	set badbch.bchnum=BCHNUM
	set badbch.seq=Db.nextVal("INCBADTTXBCH","TAPENUM=:TAPENUM,BCHNUM=:BCHNUM")
	set badbch.txt="RECORD NUMBER "_RECCNT_" - "_ERRMSG
	do badbch.bypassSave()

	// Set ^TTXSRT if the sort option is 1 or 2
	if %INST.get(),%EffectiveDate.get() do {
		if TRNSRT.get() do {
			type RecordTTXSRTUID ttxsrt=Db.getRecord("TTXSRTUID","SJD=:%EffectiveDate,BRCD=:BRCD,UID=:%UserID",1)
			set ttxsrt.badttx=1
			do ttxsrt.bypassSave()
			}
		else  do {
			type RecordTTXUID ttx=Db.getRecord("TTXUID","TJD=:%EffectiveDate,BRCD=:BRCD,UID=:%UserID",1)
			set ttx.badttx=1
			do ttx.bypassSave()
			}
		}
	quit


public ABORT	// Abort error logging

	do DISPLAY
	
	type Number N,REJBCH,REJCR,REJDR
	type public Number ERR,TAPENUM
	
	set (REJBCH,REJDR,REJCR)=0

	type DbSet ds=Db.selectDbSet("INCTAPEB","TAPENUM=:TAPENUM")
	while ds.next() do {
		type RecordINCTAPEB inctapeb=ds.getRecord("INCTAPEB")
		set N=inctapeb.bchnum
		do ALLFLG(.inctapeb)
		do inctapeb.bypassSave()
		}

	set ERR=1

	quit


ALLFLG(RecordINCTAPEB inctapeb)	// 
	
	type Date TEFD
	type String TINST,%NODE
	type public Number BRCD,N,RECCNT,REJBCH,REJCR,REJDR,TAPENUM,TRNSRT
	type public String ERRMSG,%UserID

	set inctapeb.sts=1

	set TINST=inctapeb.inst
	set TEFD=inctapeb.efdt
	set %NODE=inctapeb.uid

	set REJBCH=REJBCH+1 
	set REJDR=REJDR+inctapeb.bchdr
	set REJCR=REJCR+inctapeb.bchcr

	type RecordINCBADTTXBCH badbch=Class.new("RecordINCBADTTXBCH")
	set badbch.tapenum=TAPENUM

	set badbch.bchnum=N
	set badbch.seq=Db.nextVal("INCBADTTXBCH","TAPENUM=:TAPENUM,BCHNUM=:N")
	set badbch.txt="RECORD NUMBER "_RECCNT_" - "_ERRMSG
	do badbch.bypassSave()

	// Set TTXSRT if the sort option is 1 or 2
	if TINST.length(),'TEFD.toString().isNull() do {
		if TRNSRT.get() do {
			type RecordTTXSRTUID ttxsrt=Db.getRecord("TTXSRTUID","SJD=:TEFD,BRCD=:BRCD,UID=:%UserID",1)
			set ttxsrt.badttx=1
			do ttxsrt.bypassSave()
			}
		else  do {
			type RecordTTXUID ttx=Db.getRecord("TTXUID","TJD=:TEFD,BRCD=:BRCD,UID=:%UserID",1)
			set ttx.badttx=1
			do ttx.bypassSave()
			}
		}
	quit


Public REJBCH	// Reject Batches

	type Number BCHEND,BCHSRT,CONT,STS,REJBCH,REJCR,REJDR,BCHNUM,TAPENUM
	type String HDG,VFMQ,%NOPRMT,%READ,%TAB
	type public String %NODE

	set %NODE=%NODE.get()
	set CONT=1

	do LKUP1

	set HDG="Reject Batches"
	set %TAB("TAPENUM")="/DES=File Number/TBL=TLKUP(/XPP=do PP01^TPINERR"
	set %TAB("BCHSRT")="/DES=Starting Batch Number/TBL=BLKUP(/TYP=N/LEN=5/"
	set %TAB("BCHEND")="/DES=Ending Batch Number/TBL=BLKUP(/XPP=do PP02^TPINERR/TYP=N/LEN=5"

	set %READ="@HDG/REV/CEN,,,TAPENUM/TYP=N/LEN=5/REQ,BCHSRT/REQ,BCHEND/REQ"
	set %NOPRMT="Y"

	do ^UTLREAD quit:VFMQ="Q"

	quit:(CONT=2)

	set STS=1
	if BCHSRT=0,BCHEND=99999 set STS=0
	set (REJBCH,REJDR,REJCR)=""

	type DbSet ds=Db.selectDbSet("INCTAPEB","TAPENUM=:TAPENUM")
	while ds.next() do {
		type RecordINCTAPEB inctapeb=ds.getRecord("INCTAPEB")
		set BCHNUM=inctapeb.bchnum
		if BCHNUM'<BCHSRT,BCHNUM'>BCHEND do KILBCH
		if inctapeb.sts=2 quit

		set REJBCH=REJBCH+1
		set REJDR=REJDR+inctapeb.bchdr
		set REJCR=REJCR+inctapeb.bchcr
		}

	do BLPEND

	quit


CHECK	//Check if batches have already been rejected or posted
	
	type Boolean TTX
	type Date TEFD
	type Number BCH,POSTED,REJ,REJ2,REJ3,REJ4,SRTSEQ,TBEND,TBRCD
	type String TUID
	type Public Number BCHEND,BCHSRT,SRTOPT,X

	set BCH=BCHSRT-0.1 
	set REJ=1 
	set (TTX,REJ2,REJ3,REJ4)=0
	set TBEND=$select(+BCHEND.get():BCHEND,1:X)

	type DbSet ds=Db.selectDbSet("INCTAPEB","TAPENUM=:TAPENUM AND BCHNUM>:BCH AND BCHNUM NOT>:TBEND")
	while ds.next() do {
		type RecordINCTAPEB inctapeb=ds.getRecord("INCTAPEB")
		if (inctapeb.starttrc.isNull())!(inctapeb.endtrc.isNull()) quit		
		set TEFD=inctapeb.efdt
		set TBRCD=inctapeb.brcd
		set TUID=inctapeb.uid

		type RecordTTXSRTUID ttxsrt
		type RecordTTXUID ttx

		if SRTOPT do { quit:REJ4
			set ttxsrt=Db.getRecord("TTXSRTUID","SJD=:TEFD,BRCD=:TBRCD,UID=:TUID",1)
			type ResultSet rssrt=Db.select("TSEQ","TTXSRT","SJD=:TEFD AND BRCD=:TBRCD AND UID=:TUID")
			if ttxsrt.getMode(),rssrt.isEmpty() set REJ4=1
			}

		else  do { quit:REJ4
			set ttx=Db.getRecord("TTXUID","TJD=:TEFD,BRCD=:TBRCD,UID=:TUID",1)
			type ResultSet rsttx=Db.select("TSEQ","TTX","TJD=:TEFD AND BRCD=:TBRCD AND UID=:TUID")
			if ttx.getMode(),rsttx.isEmpty() set REJ4=1
			}

		if SRTOPT,'ttxsrt.getMode() quit
		if 'SRTOPT,'ttx.getMode() quit

		if inctapeb.src.isNull() quit
		if inctapeb.inst.isNull() quit
		if inctapeb.efdt.isNull() quit
		if inctapeb.brcd.isNull() quit
		if inctapeb.uid.isNull() quit
		if inctapeb.starttrc.isNull() quit
		if inctapeb.endtrc.isNull() quit

		set TTX=1
	
		if SRTOPT do {
			if ttxsrt.badttx=2 set REJ2=1
			else  if ttxsrt.badttx'=1 set REJ=0
			}

		else  do {
			set POSTED=+ttx.lpseq
			set SRTSEQ=inctapeb.starttrc
			if ttx.badttx=2 set REJ2=1
			else  if POSTED'<(SRTSEQ\1000) set REJ3=1
			else  if ttx.badttx'=1 set REJ=0
			}
		}
	quit


BLPEND	//

	type public Boolean ER
	type public Date TEFD
	type public Number REJBCH,REJCR,REJDR,SRTOPT,TAPENUM,TBRCD
	type public String RM,TUID

	type RecordINCTAPE inctape=Db.getRecord("INCTAPE","TAPENUM=:TAPENUM")
	set inctape.rejbch=REJBCH
	set inctape.rejdr=REJDR
	set inctape.rejcr=REJCR

	do inctape.save()

	if SRTOPT do {
		type RecordTTXSRTUID ttxsrt=Db.getRecord("TTXSRTUID","SJD=:TEFD,BRCD=:TBRCD,UID=:TUID",1)
		type ResultSet rssrt=Db.select("TSEQ","TTXSRT","SJD=:TEFD AND BRCD=:TBRCD AND UID=:TUID")
		if ttxsrt.getMode(),rssrt.isEmpty() do {
			set ttxsrt.badttx=""
			do ttxsrt.bypassSave()
			}
		}
	
	else  do {
		type RecordTTXUID ttx=Db.getRecord("TTXUID","TJD=:TEFD,BRCD=:TBRCD,UID=:TUID",1)
		type ResultSet rsttx=Db.select("TSEQ","TTX","TJD=:TEFD AND BRCD=:TBRCD AND UID=:TUID")
		if ttx.getMode(),rsttx.isEmpty() do {
			set ttx.badttx=""
			do ttx.bypassSave()
			}
		}

	set ER="W" set RM="Batch rejection is complete"

	quit


LKUP1	//Build look-up table for inclearing files, indexed by tape number.

	type String S,TLKUP
	type Public String ER,RM

	set S="    "

	type DbSet rs=Db.selectDbSet("INCTAPE",,"TAPENUM")

	if rs.isEmpty() set ER="W" set RM="No Inclearing Files to Process"

	else  while rs.next() do {
		type RecordINCTAPE inctape=rs.getRecord("INCTAPE")
		set TLKUP(inctape.tapenum)=inctape.src_S_inctape.trantime_S_inctape.opercmt
		}

	quit


PP01	//Post Processor for tape number selection.
	//Build look-up table for batch numbers included in tape selected.
	
	type Date %EffectiveDate
	type Number TBCHEND,TBCHSRT
	type String BLKUP
	type public Boolean ER
	type public Number X
	type public String RM,S

	set S="    "
	set (TBCHEND,TBCHSRT)=0

	type RecordINCBADTTX incabad=Db.getRecord("INCBADTTX","TAPENUM=:X",1) 
	if 'incabad.getMode() set ER="W" set RM="Warning! No errors logged for this file"

	type RecordINCTAPE inctape=Db.getRecord("INCTAPE","TAPENUM=:X",1)
	// Invalid File Number
	if 'inctape.getMode() do Runtime.setErrMSG("INCTAPE","1338") quit:ER

	type DbSet ds=Db.selectDbSet("INCTAPEB","TAPENUM=:X")
	//No batches in this file and Use function TTXCLR to clear flag - Bad Batch
	if ds.isEmpty() do Runtime.setErrMSG("INCTAPEB","5995") do Runtime.setErrMSG("INCTAPEB","5997") quit:ER

	while ds.next() do {
		type RecordINCTAPEB inctapeb=ds.getRecord("INCTAPEB")
		if TBCHSRT=0 set TBCHSRT=inctapeb.bchnum
		set %EffectiveDate=(inctapeb.efdt).toString("MM/DD/YY")
		set BLKUP(inctapeb.bchnum)=%EffectiveDate_S_inctapeb.starttrc_S_inctapeb.endtrc
		set TBCHEND=inctapeb.bchnum
		}

	do DEFAULT^DBSMACRO("@BCHSRT",TBCHSRT)
	do DEFAULT^DBSMACRO("@BCHEND",TBCHEND)

	quit


PP02	//Post Processor for ending batch number selection.
	
	type Number SRTOPT
	type String TLR
	type public Boolean ER,TTX
	type public Number BCHSRT,CONT,REJ,REJ2,REJ3,REJ4,TAPENUM,X
	type public String MSG,RM

	if X<BCHSRT set ER=1 set RM="Ending batch must be greater than or equal to starting batch number"

	type RecordINCTAPE inctape=Db.getRecord("INCTAPE","TAPENUM=:TAPENUM")
	set SRTOPT=inctape.trnsrt

	if SRTOPT.isNull() do {
		type RecordINCTAPEB inctapeb=Db.getRecord("INCTAPEB","TAPENUM=:TAPENUM,BCHNUM=:BCHSRT")
		set TLR=inctapeb.uid
		type RecordSCAU scau=Db.getRecord("SCAU","UID=:TLR")
		set SRTOPT=scau.trnsrt
		}

	do CHECK
	// Warning! Only TTXSRTUID Level exists.
	if REJ4,SRTOPT do Runtime.setErrMSG("INCTAPE","5998") set CONT=$$^DBSMBAR(161) quit:ER
	if REJ4,'SRTOPT do Runtime.setErrMSG("INCTAPE","5998") set CONT=$$^DBSMBAR(161) quit:ER
	//No entries in ^TTXSRT to reject,Use function TTXCLR to clear flag - Bad Batch
	if 'TTX if SRTOPT do {
			do Runtime.setErrMSG("INCTAPEB","5999") 
			do Runtime.setErrMSG("INCTAPEB","5997") quit:ER
		}
	//Warning! Already rejected.
	if REJ do Runtime.setErrMSG("INCTAPE","6000") set CONT=$$^DBSMBAR(161) quit
	//Posting in process for this batch
	if REJ2 set ER=1 do Runtime.setErrMSG("INCTAPE","6001") quit:ER
	//Batch already posted
	if REJ3 set ER=1 do Runtime.setErrMSG("INCTAPE","5994") quit:ER
	quit

Public ACPBCH	// Accept Batches

	type Number BCHEND,BCHEND1,BCHNUM,BCHSRT,BCHSRT1,REJBCH,REJCR,REJDR
	type Number SRTOPT,STS,TAPENUM
	type String YN
	type public Boolean ER
	type public String %NODE,RM

	set (BCHSRT,TAPENUM)=""
	set %NODE=%NODE.get()

	type RecordINCTAPE inctape
	
	for  do { quit:(ER)!(TAPENUM)!(TAPENUM.isNull())
		set ER=0
		read !!,"Enter the file number to accept: ",TAPENUM if TAPENUM.isNull() quit
		if TAPENUM="?" do REPORT quit
		set inctape=Db.getRecord("INCTAPE","TAPENUM=:TAPENUM",1)
		if 'inctape.getMode() write *7," Invalid file number" set ER=1 quit
		type RecordINCBADTTX badttx=Db.getRecord("INCBADTTX","TAPENUM=:TAPENUM",1)
		if 'badttx.getMode() write *7,!! do H1 write "Warning !!! - This file number does not have any errors logged" do H0
		}

	if TAPENUM.isNull()!(ER) quit
	
	for  do { quit:BCHSRT
		set BCHSRT1=1
		write !!,"Enter the starting batch number to accept: ",BCHSRT1 read BCHSRT if BCHSRT.isNull() set BCHSRT=BCHSRT1
		if BCHSRT'?.N write " [must be numeric]"
		}

	for  do { quit:BCHEND
		set BCHEND1=inctape.bchcnt
		if BCHEND1.isNull() set BCHEND1=1
		write !!,"Enter the ending batch number to accept: ",BCHEND1 read BCHEND if BCHEND.isNull() set BCHEND=BCHEND1
		if BCHEND'?.N write " [must be numeric]" 
		}

	read !!,"Verified (Y/N): N=> ",YN if YN'["Y"&(YN'["y") quit
	write !!,"Batch acceptance was started at " do ^%T write "................",!

	set (REJBCH,REJDR,REJCR)=""
	set SRTOPT=inctape.trnsrt
	set STS=2

	type DbSet ds=Db.selectDbSet("INCTAPEB","TAPENUM=:TAPENUM","BCHNUM")
	while ds.next() do {
		type RecordINCTAPEB inctapeb=ds.getRecord("INCTAPEB")
		set BCHNUM=inctapeb.bchnum
		if BCHNUM'<BCHSRT,BCHNUM'>BCHEND do BCHOK(.inctapeb)
		if inctapeb.sts=2 quit
		set REJBCH=REJBCH+1
		set REJDR=REJDR+inctapeb.bchdr
		set REJCR=REJCR+inctapeb.bchcr
		}
	
	set inctape.rejbch=REJBCH
	set inctape.rejdr=REJDR
	set inctape.rejcr=REJCR
	do inctape.save()

	set ER="W" set RM="Batch acceptance is complete"

	quit


BCHOK(RecordINCTAPEB inctapeb)	// Batch Acceptor

	type Date TEFD
	type Number TBRCD
	type String TINST,TUID
	type Public Number BCHNUM,STS,TAPENUM

	set TINST=inctapeb.inst if TINST.isNull() do END1 quit
	set TEFD=inctapeb.efdt if TEFD.isNull() do END1 quit
	set TBRCD=inctapeb.brcd if TBRCD.isNull() do END1 quit
	set TUID=inctapeb.uid if TUID.isNull() do END1 quit
	if inctapeb.starttrc.isNull() do END1 quit
	if inctapeb.endtrc.isNull() do END1 quit

	set inctapeb.sts=STS

	do NOPOST(.inctapeb)

	do inctapeb.bypassSave()

	do Db.fastDelete("INCBADTTXBCH","TAPENUM=:TAPENUM,BCHNUM=:BCHNUM")

	write !,"Batch number ",BCHNUM," is accepted."

	quit


END1	//

	type Public Number BCHNUM

	write *7,! do H1
	write "Warning !!! - batch ",BCHNUM," has no entries in [TTX]"

	do H0

	quit


Public KILBCH	// Batch Killer

	type Date TEFD
	type Number AMT,BCHSEQ,CIDSRT,DTLSEQ,TBRCD,TSEQ,TTTXS,TTTXE
	type String DC,FILEID,INDEX,SIF,TINST,TUID
	type public Number BCHNUM,REJ4,SRTOPT,TAPENUM
	
	type RecordINCTAPEB inctapeb=Db.getRecord("INCTAPEB","TAPENUM=:TAPENUM,BCHNUM=:BCHNUM",1)
	if 'inctapeb.getMode() quit

	if (inctapeb.starttrc.isNull())!(inctapeb.endtrc.isNull()) quit
	
	set TINST=inctapeb.inst
	set TEFD=inctapeb.efdt
	set TBRCD=inctapeb.brcd
	set TUID=inctapeb.uid
	set TTTXS=inctapeb.starttrc
	set TTTXE=inctapeb.endtrc

	set INDEX=inctapeb.src_"^"_TEFD_"^"_inctapeb.bchcnt_"^"
	set INDEX=INDEX_inctapeb.bchdr_"^"_inctapeb.bchcr_"^"
	set INDEX=INDEX_inctapeb.bchid_"^"_inctapeb.spr
	
	// If IDXEFD is available, use it instead of EFD 
	if inctapeb.idxefd set INDEX.piece("^",2)=inctapeb.idxefd

	if TINST.isNull(),'REJ4.get() do END2 quit
	if TEFD.isNull(),'REJ4.get() do END2 quit
	if TBRCD.isNull(),'REJ4.get() do END2 quit
	if TUID.isNull(),'REJ4.get() do END2 quit
	if inctapeb.starttrc.isNull(),'REJ4.get() do END2 quit
	if inctapeb.endtrc.isNull(),'REJ4.get() do END2 quit

	set inctapeb.starttrc=""
	set inctapeb.endtrc=""

	do Db.delete("TPCTRL","BRCD=:TBRCD AND UID=:TUID AND TPD=:TEFD")

	set TTTXS=TTTXS-1

	// Use [TTXSRT] if the sort option is 1 or 2.

	if SRTOPT do {
		type DbSet ds=Db.selectDbSet("TTXSRT","SJD=:TEFD AND BRCD=:TBRCD AND UID=:TUID AND TSEQ>:TTTXS AND TSEQ NOT>:TTTXE")
		while ds.next() do {
			type RecordTTXSRT ttxsrt=ds.getRecord("TTXSRT")
			set DC=ttxsrt.dc
			set CIDSRT=ttxsrt.cidsrt
			set AMT=ttxsrt.amt
			set TSEQ=ttxsrt.tseq
			set SIF=$$FIELD^UTSO(ttxsrt.tso,"SIF")
			
			do Db.delete("TTXSRT","SJD=:TEFD AND BRCD=:TBRCD AND UID=:TUID AND DC=:DC AND CIDSRT=:CIDSRT AND AMT=:AMT AND TSEQ=:TSEQ")
						
			if SIF.isNull() quit
			
			set FILEID=SIF.piece("^",1)
			set BCHSEQ=SIF.piece("^",2)
			set DTLSEQ=SIF.piece("^",3)

			do Db.delete("ACHINCD","FILEID=:FILEID AND BCHSEQ=:BCHSEQ AND DTLSEQ=:DTLSEQ")
			}

		type RecordTTXSRTUID srtuid=Db.getRecord("TTXSRTUID","SJD=:TEFD,BRCD=:TBRCD,UID=:TUID",1)
		type DbSet dssrt=Db.selectDbSet("TTXSRT","SJD=:TEFD AND BRCD=:TBRCD AND UID=:TUID")
		if srtuid.getMode(),'dssrt.next() do { quit
			set srtuid.badttx=""
			do srtuid.bypassSave()
			do END2
			}

		if srtuid.badttx.isNull() set srtuid.badttx=0 
		do srtuid.bypassSave()
		}

	else  do {
		type DbSet dsttx=Db.selectDbSet("TTX","TJD=:TEFD AND BRCD=:TBRCD AND UID=:TUID AND TSEQ>:TTTXS AND TSEQ NOT>:TTTXE")
		while dsttx.next() do {
			type RecordTTX ttx=dsttx.getRecord("TTX")
			set TSEQ=ttx.tseq

			set SIF=$$FIELD^UTSO(ttx.tso,"SIF")

			do Db.delete("TTX","TJD=:TEFD AND BRCD=:TBRCD AND UID=:TUID AND TSEQ=:TSEQ")

			if SIF.isNull() quit
		
			set FILEID=SIF.piece("^",1)
			set BCHSEQ=SIF.piece("^",2)
			set DTLSEQ=SIF.piece("^",3)

			if (('FILEID)!('BCHSEQ)!('DTLSEQ)) quit
			do Db.delete("ACHINCD","FILEID=:FILEID AND BCHSEQ=:BCHSEQ AND DTLSEQ=:DTLSEQ")
			}

		type RecordTTXUID ttxuid=Db.getRecord("TTXUID","TJD=:TEFD,BRCD=:TBRCD,UID=:TUID",1)
		type DbSet sdsttx=Db.selectDbSet("TTX","TJD=:TEFD AND BRCD=:TBRCD AND UID=:TUID")
		if ttxuid.getMode(),'sdsttx.next() do { quit
			set ttxuid.badttx=""
			do ttxuid.bypassSave()
			do END2
			}

		if ttxuid.badttx.isNull() set ttxuid.badttx=0 
		do ttxuid.bypassSave()
		}

	do NOPOST(.inctapeb)

	do inctapeb.bypassSave()

	do END2 

	quit


END2	//

	/*
	04/11/02 - MYERSK
	To allow for duplicate batches, ^INC("INDEX",... could contain a list
	of tapes and batches corresponding to this index.  If it contains only
	this tape and batch, kill the index. If it is a list of tapes and
	batches containing this tape and batch, remove this tape and batch
	from the list.
	*/

	type Number I
	type String FILEBCH,TAPEBCH,TMP
	type Public Date TEFD
	type Public Number BCHNUM,TAPENUM,TBRCD,SRTOPT,STS
	type Public String INDEX,TINST,TUID

	type RecordINCINDEX incindex=Db.getRecord("INCINDEX","INST=:TINST,INDEX=:INDEX",1)
	
	set TAPEBCH=TAPENUM_"#"_BCHNUM
	set FILEBCH=incindex.filebch
	
	if FILEBCH[TAPEBCH do {
		set TMP=""
		for I=1:1:FILEBCH.length("~") do {
			if FILEBCH.piece("~",I)'=TAPEBCH set TMP=TMP_FILEBCH.piece("~",I)_"~"
			}

		set TMP=TMP.extract(1,TMP.length()-1)
		
		if TMP.isNull() do Db.delete("INCINDEX","INST=:INST AND INDEX=:INDEX")
		else  do {
			set incindex.filebch=TMP
			do incindex.bypassSave()
			}
		}

	type RecordINCTAPEB inctapeb=Db.getRecord("INCTAPEB","TAPENUM=:TAPENUM,BCHNUM=:BCHNUM")
	set inctapeb.sts=STS
	do inctapeb.bypassSave()
	
	do Db.delete("INCBADTTXBCH","TAPENUM=:TAPENUM AND BCHNUM=:BCHNUM")

	// Use [TTXSRT] if sort option is 1 or 2

	if SRTOPT do {
		type RecordTTXSRTUID srtuid=Db.getRecord("TTXSRTUID","SJD=:TEFD,BRCD=:TBRCD,UID=:TUID",1)
		if srtuid.badttx=0 do {
			set srtuid.badttx=""
			do srtuid.bypassSave()
			}
		}

	else  do {
		type RecordTTXUID ttxuid=Db.getRecord("TTXUID","TJD=:TEFD,BRCD=:TBRCD,UID=:TUID",1)
		if ttxuid.badttx=0 do {
			set ttxuid.badttx=""
			do ttxuid.bypassSave()
			}
		}

	write !,"Batch number ",BCHNUM," is rejected."

	quit


public DISPLAY	// Display the problem

	type String X
	type public Date %EffectiveDate,TRANDATE
	type public Number BCHCNT,BCHCR,BCHDR,BCHNUM,FILCNT,FILCR,FILDR
	type public Number IOSL,RECCNT,TAPENUM
	type public String %INST,%MSKD,ERRMSG,IO,NREC,OREC,REC,SRC,TRANTIME

	use IO
	
	if $Y+18'<IOSL write #
	set X="" set X.piece("*",50)="" write !,X
	if ERRMSG.exists() write !,"Error message: ",ERRMSG

	write !
	if OREC.exists() write !,"Last record   : ",OREC
	if REC.exists() write !,"Current record: ",REC
	if NREC.exists() write !,"Next record   : ",NREC

	write !
	if SRC.exists() write !,"Source:",?25,SRC
	if TAPENUM.exists() write !,"File number:",?25,TAPENUM
	if BCHNUM.exists() write !,"Batch number:",?25,BCHNUM
	if TRANDATE.exists(),TRANDATE>0 write !,"Transmission date:",?25,TRANDATE.toString(%MSKD.get())
	if TRANTIME.exists() write !,"Transmission time:",?25,TRANTIME
	if %INST.exists() write !,"Institution:",?25,%INST
	if %EffectiveDate.exists() write !,"Effective date:",?25,%EffectiveDate.toString(%MSKD.get())
	if RECCNT.exists() write !,"Record count:",?25,RECCNT

	write !
	if BCHDR.exists(),FILDR.exists() write !,"Batch debits:",?25,BCHDR.roundDec(2),?40,"File debits:",?60,FILDR.roundDec(2)
	if BCHCR.exists(),FILCR.exists() write !,"Batch credits:",?25,BCHCR.roundDec(2),?40,"File credits:",?60,FILCR.roundDec(2)
	if BCHCNT.exists(),FILCNT.exists() write !,"Batch item count:",?25,BCHCNT,?40,"File item count:",?60,FILCNT

	set X="" set X.piece("*",50)="" write !,X

	quit


public REPORT	// Report all logged errors

	type Number M,N
	type public Boolean QUIT
	type public Number IORM,IOSL,PN
	type public String %ED,%NODE,CONAM,IO,IOHDG,HDG(),POP,RN

	set %NODE=%NODE.get()
	write !!,"Output report to " kill POP do ^SCAIO
	set RN="INCLEARING FILE ERROR LOG REPORT" set IORM=132
	if '%ED.exists() set %ED="" 
	if 'CONAM.exists() set CONAM=""

	kill HDG
	set HDG(0)=""
	set HDG(1)="FILE NUMBER       BATCH NUMBER             ERROR MESSAGE"

	if 'IOHDG.exists() set IOHDG="^SCAHDG"
	use IO set PN=1 do @IOHDG

	type DbSet ds=Db.selectDbSet("INCBADTTXBCH")
	while ds.next() do { quit:QUIT
		type RecordINCBADTTXBCH badttx=ds.getRecord("INCBADTTXBCH")
		if $Y'<IOSL do @IOHDG if QUIT quit
		set N=badttx.tapenum
		set M=badttx.bchnum
		write !,(N.toString()).justify(10),?18,(M.toString()).justify(10),?40,badttx.txt
		}

	write ! use IO set PN=-1 do @IOHDG

	quit


public PURGE	// Purge the INC file

	type Number I,PURE,PURS,T	
	type String FILEBCH,INDEX,INST,TMP,YN
	type Public String %NODE,ET,RM

	set %NODE=%NODE.get()

	read !!,"Enter the starting file number to purge: ",PURS quit:PURS=""
	read !!,"Enter the ending file number to purge: ",PURE quit:PURE=""

	read !!,"Verified (Y/N): N=> ",YN if YN'["Y"&(YN'["y") quit
	write !!,"Purge was started at " do ^%T write "................"
	
	catch vERROR {
		set ET=vERROR.type
		set ET=ET_" - "_vERROR.thrownAt
		set RM=vERROR.description
		do ZE^UTLERR
		}
	
	// Purge INC for "TAPE" and "BADTTX"
	do Db.delete("INCTAPE","TAPENUM NOT <:PURS AND TAPENUM NOT >:PURE")
		
	do Db.delete("INCBADTTX","TAPENUM NOT <:PURS AND TAPENUM NOT >:PURE")

	do Db.delete("INCTAPEB","TAPENUM NOT <:PURS AND TAPENUM NOT >:PURE")

	do Db.delete("INCBADTTXBCH","TAPENUM NOT <:PURS AND TAPENUM NOT >:PURE")

	// Purge INCINDEX

	type DbSet ds=Db.selectDbSet("INCINDEX")
	while ds.next() do {	
		type RecordINCINDEX index=ds.getRecord("INCINDEX")
		set INST=index.inst
		set INDEX=index.index
		set FILEBCH=index.filebch
		
		set TMP=""
		for I=1:1:FILEBCH.length("~") do {
			set T=FILEBCH.piece("~",I).piece("#",1)
			if T'>PURS!(T>PURE) set TMP=TMP_FILEBCH.piece("~",I)_"~"
			}

		set TMP=TMP.extract(1,TMP.length()-1)
		if TMP.isNull() do Db.delete("INCINDEX","INST=:INST AND INDEX=:INDEX") quit
		
		set index.filebch=TMP
		do index.bypassSave()
		}
		

	write !!,"Purge complete ............."
	quit


NOPOST(RecordINCTAPEB inctapeb)	//Set no post flag in TTX

	type Boolean FLAG=0
	type Number B,T
	type Public Date TEFD
	type Public Number BCHNUM,SRTOPT,TAPENUM,TBRCD
	type Public String TUID
			
	type RecordTTXSRTUID srtuid=Db.getRecord("TTXSRTUID","SJD=:TEFD,BRCD=:TBRCD,UID=:TUID",1)
	type RecordTTXUID ttxuid=Db.getRecord("TTXUID","TJD=:TEFD,BRCD=:TBRCD,UID=:TUID",1)

	type ResultSet rs=Db.select("DISTINCT TAPENUM,BCHNUM","INCBADTTXBCH","TAPENUM NOT=:TAPENUM AND BCHNUM NOT=:BCHNUM")
	while rs.next() do { quit:FLAG
		set T=rs.getCol("TAPENUM")
		set B=rs.getCol("BCHNUM")
		type RecordINCTAPEB tapebcom=Db.getRecord("INCTAPEB","TAPENUM=:T,BCHNUM=:B")
		if tapebcom.inst'=inctapeb.inst quit
		if tapebcom.efdt'=inctapeb.efdt quit
		if tapebcom.brcd'=inctapeb.brcd quit
		if tapebcom.uid'=inctapeb.uid quit
		
		// Use [TTXSRT] if sort option is 1 or 2.
		if SRTOPT do {
			set srtuid.badttx=1
			set FLAG=1
			do srtuid.bypassSave()
			}
		
		else  do {
			set ttxuid.badttx=1
			set FLAG=1
			do ttxuid.bypassSave()
			}
		}

	if 'FLAG do {
		// Use [TTXSRT] if sort option is 1 or 2.
		if SRTOPT set srtuid.badttx="" do srtuid.bypassSave()
		else  set ttxuid.badttx="" do ttxuid.bypassSave()
		}

	quit


H1	//
	write *27,*91,*55,*109 
	quit

 
H0	//
	write *27,*91,*48,*109 
	quit
 

Public TTXCLR	//

	/*
	This section prompts for Processing date, Branch Code and User ID
	so that the Bad Batch Flag can be cleared on the TTX User ID Level
	Data.
	*/
	
	type Date PTJD
	type Number PBRCD
	type String %READ,%TAB,PUID
	type public Boolean ER
	type public Date PTJD
	type Public String VFMQ,PBRCD,PUID,RM

	set %TAB("PTJD")="/DES=Processing Date/REQ/TYP=D/LEN=10/TBL=[TTX]/XPP=do TJDPP^TPINERR"
	set %TAB("PBRCD")="/DES=Branch Code/REQ/TBL=PBRCD(/TYP=N/LEN=5/XPP=do BRCDPP^TPINERR"
	set %TAB("PUID")="/DES=Bad Batch User Ids/REQ/TBL=PUID(/LEN=12/TYP=T"

	set %READ="@@%FN/REV/CEN,,,PTJD,PBRCD,PUID"

	do ^UTLREAD quit:VFMQ="Q"

	type RecordSCAU scau=Db.getRecord("SCAU","UID=:PUID",1)

	if scau.trnsrt do { quit
		type DbSet ds=Db.selectDbSet("TTXSRT","SJD=:PTJD AND BRCD=:PBRCD AND UID=:PUID")
		type RecordTTXSRTUID srtuid=Db.getRecord("TTXSRTUID","SJD=:PTJD,BRCD=:PBRCD,UID=:PUID",1)
		if ds.next() do {
			if $$CLRLOG("TTXSRT") set srtuid.badttx="" quit
			//Use function TTXBREJ to delete Rejected Batches
			do Runtime.setErrMSG("TTXSRT","6002") quit:ER
			}
		else  set srtuid.badttx=""
		do srtuid.bypassSave()
		}

	type DbSet ds=Db.selectDbSet("TTX","TJD=:PTJD AND BRCD=:PBRCD AND UID=:PUID")
	type RecordTTXUID ttxuid=Db.getRecord("TTXUID","TJD=:PTJD,BRCD=:PBRCD,UID=:PUID",1)
	if ds.next() do {
		if $$CLRLOG("TTX") set ttxuid.badttx=""
			//Use function TTXBREJ to delete Rejected Batches
			do Runtime.setErrMSG("TTXSRT","6002") quit:ER
		}
	else  set ttxuid.badttx=""
	do ttxuid.bypassSave()
 
	quit


TJDPP	// Post Processor for Processing Date

	/*
	This section is the Post Processor for the Processing Date.  It will
	create a Lookup Table for Branch code when function TTXCLR
	(Clear Bad Batch Flag one TTXUID) is run.
	*/

	type Number XBRCD
	type String PBRCD()
	type Public Date X

	type ResultSet ttx=Db.select("DISTINCT BRCD","TTX","TJD=:X")
	while ttx.next() do {
		set XBRCD=ttx.getCol("BRCD")
		if PBRCD(XBRCD).data() quit
		type RecordUTBLBRCD brcd=Db.getRecord("UTBLBRCD","BRCD=:XBRCD",1)
		set PBRCD(XBRCD)=brcd.desc
		}

	type ResultSet ttxsrt=Db.select("DISTINCT BRCD","TTXSRT","SJD=:X")
	while ttxsrt.next() do {
		set XBRCD=ttxsrt.getCol("BRCD")
		if PBRCD(XBRCD).data() quit
		type RecordUTBLBRCD brcd=Db.getRecord("UTBLBRCD","BRCD=:XBRCD",1)
		set PBRCD(XBRCD)=brcd.desc
		}
	
	quit


BRCDPP	// Post Processor for Branch Code
 
	/*
	This section is the Post Processor for the Branch Code.  It will
	create a Lookup Table for User ID when function TTXCLR
	(Clear Bad Batch Flag one TTXUID) is run.
	*/

	type Boolean FLAG=0
	type String PUID(),XUID
	type public Boolean ER
	type public Date PTJD
	type public Number X
	type public String RM

	type ResultSet rsttx=Db.select("UID","TTXUID","TJD=:PTJD AND BRCD=:X AND BADTTX>0")
	while rsttx.next() do {
		set XUID=rsttx.getCol("UID")
		set PUID(XUID)=""
		set FLAG=1
		}

	type ResultSet rssrt=Db.select("UID","TTXSRTUID","SJD=:PTJD AND BRCD=:X AND BADTTX>0")
	while rssrt.next() do {
		set XUID=rssrt.getCol("UID")
		set PUID(XUID)=""
		set FLAG=1
		}
	//There are no batches tied to this event
	if 'FLAG do Runtime.setErrMSG("TTXSRTUID","5740") quit:ER

	quit


CLRLOG(String GBL)	// 

	/*
	Verify Clearing of TTXUID.BADTTX if Lower Level TTX records
	exist.  Then Insert an Entry into DAYENDEXC logging the Date,
	Branch Code and User Id the flag was cleared for.
	*/

	type String ERRMSG,MSG,REPLY
	type Public Date TJD
	type Public Number PBRCD
	type Public String %FN,%UserID,CUSID,FNDESC,PUID

	set ERRMSG="Lower Level "_GBL_" Records Exist"
	use 0 write $$MSG^%TRMVT(ERRMSG,1,1)
	set MSG="Clear Bad Batch Flag?"
	use 0 set REPLY=$$^DBSMBAR(161)

	if REPLY=2 quit 0

	set ERRMSG="Cleared Flag For "_TJD_","_PBRCD_","_PUID_" - By User"_%UserID
	do LOG^UTLEXC(%FN,"*",FNDESC.get(),CUSID.get(),"",ERRMSG,"")

	use 0 write $$MSG^%TRMVT(ERRMSG,1,1)

	quit 1

vSIG()	quit "60354^2165^Sethy, Satyanarayan^26723"	// Signature - LTD^TIME^USER^SIZE
