LNBLDE

	/*
	     Generate a single bill

	     ORIG: LOCKE - 04/08/93
	     DESC: Generate a single loan payment record (bill)
	
	---- Revision History ------------------------------------------------

	01/04/07 - KELLYP - CR 24661
		   Modified REMOVE section to bypass the filers when deleting
		   the LNBIL1 record.  This prevents integrity errors from
		   appearing on the loan when a future-dated bill record is
		   projected and then deleted by ZAMT^LNPTS3.  Also removed
		   pre-2004 revision history.
	
	11/07/06 - KELLYP - CR 23882
		   Modified REMOVE section to properly delete bill record.
	
	11/03/06 - Ravindra Rathi - CR 23890
	           Modified the TEASRT section to check for 'ln.trate.isNull() 
	           instead of ln.trate to set the correct teaser rate 
	           when it equals zero.
	
	10/20/06 - KELLYP - CR 19960
		   Modified EXEC section to call new section, PAYTOL, to add
		   tolerance amount due to bill being generated.
	
	09/05/06 - KELLYP - CR 22796
		   Modified SETBIL section to restore previous logic from
		   Profile99.  Interest and principal portions of a bill
		   should only be set into the PE*AB (Amount Billed) and 
		   PE*AD (Amount Due) fields if interest is determined at
		   billing (LN.IDP=0).  This fixes a problem when interest
		   is determined at payment (LN.IDP=1) where a payment was
		   not being directed against all the interest due.
	
	06/30/06 - SWARNALP - CR21448
		   Modified ROUND section to remove the condition check for 
		   ln.icm as there is no relationship between the interest 
		   collection method and escrow payment rounding. Also removed 
		   the condition BLDUE=ln.pchnd as it makes no sense since 
		   the ln.pchnd cannot be greater than BLDUE at any time and 
		   the condition check of BLDUE<ln.pchnd is already available 
		   in the ROUND section and the system continues to execute 
		   the next line by default only if BLDUE=ln.pchnd
		   
	06/15/06 - SPR - CR21309
		   Modified INT3 section to set error, if transaction code 
		   for DR Adj Accrued Int/Div Tran Code("DRADIN") is not
		   defined on product type.
	
	06/06/06 - KUMARB - CR 21379
		   Modified PRVBIL section, to include all non-due fees prior
		   to OSEQ by changeing the condition from BRFAMT>0 to DUEAMT>0, 
		   also added to include other fees at end of the section.

	04/03/06 - KELLYP - CR 20505
		   Modified ESCFEE and EXEC sections to ensure that billing-
		   based fee types are included in loan bills.

	03/21/06 - KUMARB/KELLYP - CR 19854
		   Modified LUMP section to call $$BIL0ELE^BILFUNCS instead of
		   $$ELEMENT^BILFUNCS.  BIL0ELE will return the entire LNBIL0
		   record whereas ELEMENT only returns the payment elements; 
		   LUMP needs the entire record.

	03/20/06 - KinI - CR 20219
		   Modified AMT section by adding TP rollback before quitting 
		   with null amount to avoid %GTM-E-TPQUIT error. 

	03/17/06 - TELIV - CR 19184
		   Modified section PAYOFF. If RFP option is 0, donot add back
		   the diffrence between payoff and PMTPI to the final bill 
		   generated. And adjust back the diffrence if RFP=1 and Payoff
		   is greater than PMTPI in which case the bill will be of PMTPI
		 
	03/16/06 - KELLYP - CR 20104
		   Modified PPB section to get the next lowest balance tier 
		   from UTBLRPPB instead of trying to match the loan's balance
		   to a specific balance tier.  

	03/14/06 - chhabris - CR19871
		   Modified CALCSUB section to remove calls to CALC^LNSUBU based
		   on ln.subrat and replaced the same with a direct call to 
		   CALC^LNSUBU as if the rate in UTBLLNSUB is modified the same
		   was not reflected in the bill generation.

	03/03/06 - KumarSS - CR 19183
		   Modified EXEC section, to get Payment Due Date from 
		   previous bill to set Cut-Off date for the current bill.

	02/28/06 - TITOVE - CR 19733
		   Modified EXEC, SETLNK and LNBIL5 sections to restore 
		   Profile01 logic and prevent infinite loops.

	02/20/06 - KELLYP - CR 19338
		   Modified PMTPI section to protect Db.getRecord on LNAPCHG
		   by passing a "1" as the third parameter.  This prevents a
		   RECNOFL error from occurring when backdating the opening 
		   of a loan account using payment change processing.

	02/03/06 - TITOVE - CR 19182
		   Modified EXEC section to use the LNBIL1 object that was
		   passed in, if it exists.

	12/30/05 - chhabris - CR18154
		   Modified the INT section to get the validation for ln.subpln
		   inside the 1st if block as it was quiting out of this section
		   whenever a subsidy plan is attached to accounts.

	09/26/05 - KinI - 17250
		   Modified ESCAMT section to quit with null value if XCID="".
		   Modified INT4 section to replace Class.new method for LNDIDE
		   record with Db.getRecord with third parameter "1" to avoid 
		   RDBSAVEFAIL error when the system was repeatedly trying to 
		   insert the same record during account backdating.
		   
	04/25/05 - KinI - CR15524
		   Modified PAYOFF, PPB and PRN3 sections to fix undefined 
		   variables.
		   Updated EXEC, SETBIL, INT1, LNBIL5, ROPT3, CALCSUB and
		   PRVBIL sections: replaced lnbil1.bp1 master field pieces 
		   updates with direct sub-field references and removed 
		   lnbil1.bp1 update since it is considered a special type 
		   of computed column as per DBI standards.
		   Modified EXEC section to nullify amounts billed and due as
		   they will be accumulated for each new bill in SETBIL 
		   section. Also added lnbil1.setMode(0) here as a new bill is
		   created.
		   Modified LUMP section to remove lnbil1.bypassSave() as 
		   duplicate since the record is saved in EXEC section.
		   Modified SETBIL section to add AMT to amount billed and due
		   not just overlaying these with AMT.
		   Modified top section call NEWBILL^BILFUNCS regardless of 
		   whether its a new bill or not to zero out bill payment
		   element amounts.
		   
	04/18/05 - KELLYP - CR 13662
		   Moved newing of several variables from RPP1 to PRN3 and
		   modified those two sections to conform to current PSL
		   standards.  Also removed pre-2003 revision history.

	08/02/04 - KELLYP - CR 11429
		   Prevented undefined error on ER.
	
	05/26/04 - KELLYP - CR 8446
		   Modified IRN section to use LNVRCHG instead of LNAPCHG
		   and to set up IRNC only if the LNVRCHG record exists.
		   Also moved newing of RECFRQ out of the RPP1 section and
		   into the top-level to prevent an undefined error in PPB.
	
	01/20/04 - CARROLLJ - CR 7722
		   Corrected undefined error when called from MRPC003.

	-----------------------------------------------------------------------
	*/
	quit


public EXEC(RecordLN ln,RecordTTX ttx,CID,%SystemDate,CTL,RecordLNBIL1 lnbil1)

	/*
	Arguments:	
	. ln		Loan Object				/TYP=RecordLN/REQ/REF:RW
	. ttx		Original Transaction Object		/TYP=RecordTTX/REQ/REF:RW
	. CID		Account Number				/TYP=N/REQ
	. %SystemDate	SystemDate				/TYP=D/REQ
	. CTL Control						/TYP=N/REQ
	       	Position 1 - 0: Do not process transactions
	    			1: Process transactions locally
	       	Position 2 - 0: Not being called from DAYEND process
	    			1: Called from DAYEND process
	. lnbil1	Internal Bill Detail object		/TYP=RecordLNBIL1/NOREQ/REF:RW
	
	new'd array's

	prvbil - array will hold "previously billed" amts for each item
	lnkfee - array holds fee linkages
	blamt - array accumulates billed amounts my element
	UAVB - array returned from ^UAVB

	*/		

	new ACR,AF,AMT,B,BALCMP,blamt,BL5SEQ,BLDUE,CPID,D,DATA,DIA,DIAA,DICO,DIFF
	new DIRLD,DIRND,DIU,DUEDT,ELMNT,ETC,FEE,FIA,FPA,FRE,I,IDP,IDPF,INT
	new INTA,IROPT,JD,LBDD,LNK,lnkfee,LNKFEE,lnsysgen,LUMP,MDT,N,NBBO,NJD
	new PBPOR,PC,PGM,PI,PINC,PLN,PMTPI,POFF,PPB,PRIN,prvbil,PTBAL,RATE
	new RND,ROPT,ROW,RPP,SAVETC,SEQ,TAMT,TOTESC,TSRFLG,UAVB,UFRE,X

	type Date BILDT
	type Number BSEQ

	// all billing transactions are system generated
	set lnsysgen=1

	set ETC=ttx.etc

	do INIT(.ln)

	do LNKFEE(CID)
	
	set ER=ER.get()

	// Instanstiate LNBIL1, if necessary
	if 'lnbil1.exists() do {
	
		set I=$S(ln.oseq>ln.bseq:ln.bseq,1:ln.oseq)

		// Conditinal set of "I" for call from LNPTS3 to create bill from OSEQ
		if PF.get()=0 set I=$S(ln.schseq>ln.oseq:ln.schseq,1:ln.oseq)	
	
		set lnbil1=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:I",1)
		}

	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID=:CID",1)

	set X=$$NEWBILL^BILFUNCS(.lnbil1,.lnbil0)
	
	set lnbil1.cid=CID
	set lnbil1.schseq=BSEQ+1 
	
	// Creating a new bill, so need the "create" mode
	do lnbil1.setMode(0)

	// Find previously billed amts so as not to "double count"
	do PRVBIL(.ln,.lnbil1)

	// Find due date for last bill (LBDD), and bill date/due date for this bill
	if 'ln.bseq do {
		set LBDD=ln.schld 
		set BLDUE=ln.schnd
		set LBDT=LBDD-ln.bloff
		set JD=ln.bldt
		if ln.bloff="1P" set JD=$$NJD^UFRE(BLDUE,ln.dist1fre,,1) quit:ER 
		}
	else  do {

		// Get Payment Due Date from previous bill and set Cut-Off date for the current bill.
		type RecordLNBIL1 plnbil1=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:BSEQ")
		set (JD,LBDD)=plnbil1.cdpd

		set BLDUE=$$NJD^UFRE(JD,ln.dist1fre) quit:ER
		
		/*
		The due date of the bill will be the later of the
		date derived by bumping [LN]LBDD by the payment frequency,
		and the value of [LN]SCHND in the account record.  This
		considers that SCHND may have been manually set into
		the future.
		*/
		if BLDUE<ln.schnd set BLDUE=ln.schnd
		}
	if ER quit 
	
	set BILDT=BLDUE-ln.bloff if ln.bloff="1P" set BILDT=JD
	
	// P&I amount used for this date
	set PMTPI=$$PMTPI(.ln,BLDUE)

	// check for teaser rate
	set IRN=$$TEASRT(.ln,BLDUE)

	// rate used for this date
	if 'TSRFLG set IRN=$$IRN(.ln,BLDUE)
	
	set lnbil1.cbcd=BILDT
	set lnbil1.cdpd=BLDUE
	set lnbil1.copb=ln.balint
	set lnbil1.cirn=IRN	

	set lnbil1.casd=""
	set lnbil1.ctab=""
	set lnbil1.cpib=""
	set lnbil1.cpid=""
	
	// Calculate interest and principal
	if $$ELECHK^BILFUNCS(ln.ppdcat1,"I") do { quit:ER
		
		set AMT=$$INT(.ln,.lnbil0,.lnbil1,.ttx,BLDUE)

		do SETBIL(.ln,.lnbil1,AMT,"I")

		if ln.stat'=4 do BASIS^LNFEEU(.ln,.ttx,CID,%SystemDate,AMT,"I",110_+$E(CTL,2),,,3)
		}
		
	if $$ELECHK^BILFUNCS(ln.ppdcat1,"P") do { quit:ER
		
		set AMT=$$PRN(.ln,.lnbil0,.ttx,BLDUE)

		do SETBIL(.ln,.lnbil1,AMT,"P")

		if ln.stat'=4 do BASIS^LNFEEU(.ln,.ttx,CID,%SystemDate,AMT,"P",110_+$E(CTL,2),,,3)
		}
		
	// Calculate fees "assessed at billing"
	if ln.stat'=4 do FEEDUE^LNFEEU(.ln,.ttx,CID,3,110_+$E(CTL,2),BLDUE) quit:ER
	
	set BL5SEQ = 0
	
	type RecordLNBIL5 lnbil5()
	
	set ROW=$$ELEMENT^BILFUNCS( .lnbil0)
	
	for PC=1:1:20 quit:ROW.piece($C(9),PC).isNull()  do {
		
		set ELMNT=ROW.piece($C(9),PC).piece("#",1)
		
		if '$$ELMNTDUE( .ln, .lnbil0, ELMNT, BLDUE) quit
		
		// Include linked fees
		do SETLNK( .lnbil1, .lnbil5(), ELMNT, 1)

		if (ELMNT="I") ! (ELMNT="P") quit

		// Calculate escrow and fee amounts
		do SETBIL(.ln,.lnbil1,$$ESCFEE(.ln,.lnbil0,ELMNT),ELMNT) quit
		}		
	
	do LUMP(.ln,.lnbil1,.lnbil0)
	
	do PAYTOL(.ln,.lnbil1)	// Add payment tolerance amounts to bill record
	
	do ROUND(.ln,.lnbil1,.lnbil0)
	
	// Reversed order of PMTMIN and PAYOFF
	do PMTMIN(.ln,.lnbil1)
	
	do PAYOFF(.ln,.lnbil1,.ttx)
	
	do MPPF(.ln,.lnbil1)
	
	do BUMPFRE(.ln)
	
	// Include fees not part of due amount
	type ResultSet rs = Db.select("FEETYP", "LNFEE", "CID=:CID")

	while rs.next() do {
		
		set FEE = rs.getCol("FEETYP")

		type String TOPFEE = $$TOPFEE^LNU( FEE, 1)

		if '$$ELECHK^BILFUNCS( ln.ppdcat1, TOPFEE) , (TOPFEE = FEE) do {
		
			do LNBIL5( .lnbil1, .lnbil5(), FEE, 0)
			
			do SETLNK( .lnbil1, .lnbil5(), FEE, 0)
			}
		}
	
	// Final cleanup before exiting
	
	do lnbil0.bypassSave()
	
	set lnbil1.cdib=DIA

	set lnbil1.cid=CID
	set lnbil1.schseq=BSEQ+1

	do lnbil1.bypassSave()
	
	set BL5SEQ = 0
	
	for  set BL5SEQ = lnbil5(BL5SEQ).order() quit:BL5SEQ.isNull()  do lnbil5(BL5SEQ).bypassSave()

	set ln.diu=ln.diu+DIA
	set ln.diaa=ln.diaa+DIA
	set ln.inta=INTA
	set ln.ppb=PPB

	do CALC^LNUBIL(.ln,"01")

	do DISBRES(.ln)

	quit 
	
	
SETBIL(RecordLN ln,RecordLNBIL1 lnbil1,AMT,ELMNT,UPDBLD)  

	// Set element amounts into Bill record
	
	type String X

	set UPDBLD=UPDBLD.get()

	set blamt(ELMNT) = blamt(ELMNT).get() + AMT
	
	if (ln.idp) , ((ELMNT="I") ! (ELMNT="P"))
	else  do {
		set X = $$SUB^BILFUNCS(ELMNT,.lnbil1)

		// Total Amount Billed
		if 'UPDBLD set X.piece("#",3) = X.piece("#",3) + AMT

		// Amount Still Due
		set X.piece("#",4) = X.piece("#",4) + AMT
		
		// Call to bill funcs to set
		do SETELMT^BILFUNCS(.lnbil1,ELMNT,X)		
		}
	
	// Pmt Amount Still Due
	set lnbil1.casd = lnbil1.casd + AMT
	
	// Total Amount Billed
	if 'UPDBLD set lnbil1.ctab = lnbil1.ctab + AMT

	if (ELMNT = "I") ! (ELMNT = "P") do {
		// Total Prin Plus Interest Amt Still Due
		set lnbil1.cpid = lnbil1.cpid + AMT
		// Total Prin Plus Interest Amount Billed
		if 'UPDBLD set lnbil1.cpib = lnbil1.cpib + AMT
		}

	quit 
	
	
ESCFEE(RecordLN ln,RecordLNBIL0 lnbil0,String ELMNT)	// Return amount for this fee or escrow item

	type public String prvbil()

	type RecordLNFEE lnfee=Db.getRecord("LNFEE","CID=:ln.cid,FEETYP=:ELMNT",1)
	if (lnfee.feerem) quit (lnfee.feerem-prvbil(ELMNT).get())

	quit $$ESCAMT(.ln,.lnbil0,ELMNT)


ESCAMT(RecordLN	ln,RecordLNBIL0 lnbil0,ELMNT)

	new CURRAMT,DATA,ECID,RECAMT,X,XCID

	set X=ln.apcnd
	set DATA=$$BIL0^BILFUNCS(.lnbil0,ELMNT)
	set XCID=DATA.piece("#",2)	

	if XCID="" quit ""

	set CURRAMT=""

	type RecordDEP dep=Db.getRecord("DEP","XCID")
	set CURRAMT=dep.curramt
	set RECAMT=dep.recamt
	
	// If an Off-Cycle analysis has been run and the bill due date greater
	// than return the new amount	

	if ln.ocaf,BLDUE'<ln.ocadt quit RECAMT
	
	// Return current escrow amount if bill due date is less than APCND
	if BLDUE<X quit CURRAMT
	
	// If bill due date =>APCND and "change in process", return new amount
	// Escrow Analysis Change In Process
	
	if ln.eacip quit RECAMT
	
	// Allow Unrestricted Pmts W/O Esc Analysis
	if 'ln.fpaf set OVR(CID,"EAB")=""
	quit CURRAMT
	

Public LNKFEE(CID)	// Build array lnkfee
	
	new BASIS,DATA,FEE,LFEE
	
	type ResultSet rs=Db.select("BASIS,LFEE,FEETYP","LNFEE,LNFEEP","lnfee.cid=:CID and lnfee.feetyp=lnfeep.feetyp")
	while rs.next() do {
		set BASIS=rs.getCol(1)
		set FEE=rs.getCol(3)
		if rs.getCol(2) set lnkfee(BASIS,FEE)=""
		}
	quit 


	
LUMP(RecordLN ln,RecordLNBIL1 lnbil1,RecordLNBIL0 lnbil0)	// Include lump amounts

	type Number PC
	type String DATA,ELMNT,ROW

	set ROW=$$BIL0ELE^BILFUNCS(.lnbil0)
	for PC=1:1:20 quit:ROW.piece($C(9),PC)=""  do {
		if +ROW.piece($C(9),PC).piece("#",5)=0 quit
		set ELMNT=ROW.piece($C(9),PC).piece("#",1)
		do SETBIL(.ln,.lnbil1,ROW.piece($C(9),PC).piece("#",5),ELMNT)
		set DATA=ROW.piece($C(9),PC)
		set DATA.piece("#",5)=""

		do SETBIL0^BILFUNCS(.lnbil0,PC,DATA)
		set DATA=$$SUB^BILFUNCS(ELMNT,.lnbil1)
		set DATA.piece("#",5)=ROW.piece($C(9),PC).piece("#",5)
		do SETELMT^BILFUNCS(.lnbil1,PC,DATA)
		}

	quit 

	
INT(RecordLN ln,RecordLNBIL0 lnbil0,RecordLNBIL1 lnbil1,RecordTTX ttx,BLDUE)

	if ('$$ELMNTDUE(.ln,.lnbil0,"I",BLDUE)) do { quit ""
		if 'ln.subpln.isNull() set ln.subamt=""
		}

	new INT 
	set INT=""
	// Calculate accrued interest
	do INT1(.ln,.lnbil0,.lnbil1) quit:ER ""

	// Anticipated interest
	if $E(STBL("PCM",PCM),4)=1 do INT2(.ln) if ER quit ""

	// Scheduled disb interest
	do INT5(.ln) quit:ER ""

	// Minimum finance charge
	do INT3(.ln,.ttx) quit:ER ""

	// Manage any deferred interest
	do INT4(.ln) quit:ER ""

	// Subsidizied interest payments
	do INT6(.ln,.lnbil1) quit:ER ""

	// Adjust excess interest
	do INT7 quit:ER ""

	if INT>0 quit $$^SCARND(INT,0,CID)
	quit ""
	

INT1(RecordLN ln,RecordLNBIL0 lnbil0,RecordLNBIL1 lnbil1) 

	// Calculate Accrued Interest

	new PCM2

	set PCM2=$E(STBL("PCM",PCM),2)
	
	if BALCMP<0 set INT=$$^SCARND(ACR,0,CID)+BALCMP set:INT<0 INT="" quit 
	
	// deferred student loan
	if 'BALCMP,ln.idpf=2 set INT="" quit
	
	if ('ln.cntdr),(PCM2=2) set ln.air=1

	// Recalculate average interest
	if ln.air do AVGINT^LNAIC(.ln) quit:ER
	
	// Bill accrued interest
	if 'PCM2 do { quit 
		set INT=ACR-prvbil("I").get()
		/*
		If loan bills accrued interest and LN.IDP=0, then the accrual
		balance already contains the lump amount.  Subtract it and let
		Section LUMP handle it.
		*/
		if 'IDP set INT=INT-$$LUMPAMT(.lnbil0,"I")
		}
	
	// Calculated interest
	if PCM2=1 do { quit
		new V
		set INT=$$^UIC(ln.balint,LBDD,BLDUE-1,ln.iacm,IRN,1,ln.dist1af,ln.dist1fre,ln.icpf,ln.schnd,ln.schld)
		set INT=$$^SCARND(INT,0,CID)
		set V=INTA if V<0,INT+V<0 set V=-INT
		set lnbil1.coia=V
		set INT=INT+V set INTA=INTA-V
		}
	
	// Fixed interest amount
	if PCM2=2 do {
		/*
		Loan has not yet been disbursed.  Set the recalculation flag
		to yes.
		*/
		if 'ln.cntdr set ln.air=1
		if FIA'=ln.fia do {
			set HSEQ=Db.nextVal("HIST","CID")

			type RecordHIST hist=Class.new("RecordHIST")
			set hist.cid=CID
			set hist.tseq=Db.nextVal("HIST","CID")
			set hist.tjd=%SystemDate
			set hist.efd=%EffectiveDate
			set hist.tlo=%UserStation
			set hist.tcmt=CID_"[LN]FIA:"_FIA_":"_ln.fia
			set hist.cdt=%CurrentDate
			set hist.time=%CurrentTime
			set hist.uid=%UserID
			set hist.spr=SPR.get()
			do hist.bypassSave()
			}

		set (INT,FIA)=ln.fia
		}
	
	if PCM2=3 set INT=ln.fia
	
	quit 
	

INT2(RecordLN ln) // Anticipated interest amount

	
	if (BLDUE-1)<%SystemDate quit
	// not anticipated interest
	if $E(STBL("PCM",PCM),4)-1 quit
	
	// No index - use IRN for rest of period
	if ln.index="" do {
		set INT=INT+$$^UIC(ln.balint,%SystemDate,BLDUE-1,ln.iacm,IRN,0,ln.dist1af,ln.dist1fre,ln.icpf,ln.schnd,ln.schld)
		set INT=$$^SCARND(INT,0,CID)
		}
	
	// Variable rate - find correct rates for rest of period
	if ln.index'="" set INT=INT+$$^SCARND($$ANTINT(.ln),0,CID)
	
	if $E(STBL("PCM",PCM))=1,($E(STBL("PCM",PCM),3)-2),INT>PMTPI set INT=PMTPI
	quit 

	
INT3(RecordLN ln,RecordTTX ttx) // Minumum finance charge

	/*
	Need to check rounded interest amount rather than the normal
	interest amount.
	*/
	if '$$^SCARND(INT) quit
	if 'ln.mfcb quit 
	if INT'<ln.mfcb quit 
	
	new CRCD,TAMT,X,TCMT,TC,DC,SEQ
	
	set CRCD=ln.crcd
	
	// Minimum Finance Charge
	set TCMT=$$^MSG("3896")
	set TAMT=$$^SCARND(ln.mfcb-INT,0,CID) 
	set INT=ln.mfcb
	
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=TYPE")

	set TC=prodctl.dradin
	if TC.isNull() do ETCERR^TTXEXT(TYPE,"DRADIN") quit:ER
		
	// Minimum Finance Charge
	type RecordTTX ttxpri=Class.new("RecordTTX")
	do POST^LNTRB(.ttxpri,CID,TC,TAMT,,%UserStation,,$$^MSG("3896"),CRCD)
		
	// Accumulate offset
	set DC=$S(ln.trb:1,1:0)
	
	new CID 
	type RecordUTBLGLSC utblglsc=Db.getRecord("UTBLGLSC","GLSC=:ln.glsc")
	set CID=utblglsc.lgli
	
	if $E(CTL,2) do {
		new CC,GLSC,TYPE

		set CC=ln.cc
		set TYPE=ln.type
		set GLSC=ln.glsc
		if 'MFCOFF(CRCD,TYPE,GLSC,CC).exists() do {
			// Min. Fin. Chg Type ~p1  Cost Ctr~p2
			set DESC=$$^MSG("3895",TYPE,CC)
			set MFCOFF(CRCD,TYPE,GLSC,CC)=CID_"|MDR|"_CID_"|MCR||"_DESC
			set MFCOFF(CRCD,TYPE,GLSC,CC,0)=0
			set MFCOFF(CRCD,TYPE,GLSC,CC,1)=0
			}
		set MFCOFF(CRCD,TYPE,GLSC,CC,DC)=MFCOFF(CRCD,TYPE,GLSC,CC,DC)+TAMT
		}
	else  do POST^LNTRB(.ttxpri,CID,$S(DC:"MCR",1:"MDR"),TAMT,,%UserStation,,$$^MSG("3896"),CRCD)

	quit 
	

INT4(RecordLN ln)	// Calculate deferred interest

	
	if 'ln.dxsi,(($E(STBL("PCM",PCM),3)=4)!($E(STBL("PCM",PCM),3)=5)) do { quit
		if ln.convdt'="",ln.bldt<ln.convdt quit
		set INT=$$DIAPPB(.ln,ln.pbpor,ln.balint,INT,$E(STBL("PCM",PCM),2),$E(STBL("PCM",PCM),4),ln.intcap))
		}
	
	// Does this loan meet conditions for deferred interest ?
	if 'ln.dxsi,'$E(STBL("PCM",PCM)) quit 
	if $E(STBL("PCM",PCM),3)=2 quit 
	if 'ln.dxsi,(INT'>PMTPI) quit 
	
	set DIA=INT-PMTPI set LST=0
	if ln.dxsi set DIA=$$^SCARND(INT-DIU,0,CID) set INT=INT-DIA
	
	// Check deferred interest against maximum limits
	if ln.dimxb'="",DIA>ln.dimxb,(DIA-ln.dimxb>LST) set K="DIMXB" set LST=DIA-ln.dimxb
	if ln.dimxy'="",DIA+DIAA>ln.dimxy,(DIA+DIAA-ln.dimxy)>LST set K="DIMXY" set LST=DIA+DIAA-ln.dimxy set LST=DIA+DIAA-ln.dimxy
	if ln.dimxl'="",DIA+DIL>ln.dimxl,(DIA+DIL-ln.dimxl)>LST set K="DIMXL" set LST=DIA+DIL-ln.dimxl
	
	set BILL=0
	if ln.iropt=1 do BILLDEF(.ln)
	
	if LST do {
		set DIA=DIA-LST
				
		type RecordLNDIDE dediexc=Db.getRecord("LNDIDE","EFD=:%SystemDate,CID=:CID,BDD=:BLDUE,DIDI=:K",1)

		set dediexc.cint=INT 
		set dediexc.pmtpi=PMTPI 
		set dediexc.limit=$S(K="DIMXB":ln.dimxb,K="DIMXY":ln.dimxy,K="DIMXL":ln.dimxl)
		set dediexc.lst=LST 
		do dediexc.bypassSave() 
		}	
	
	if 'ln.dxsi set INT=PMTPI
	
	if BILL=1 quit
	
	// Update deferred interest buckets
	set DIU=DIU+DIA
	set DIAA=DIAA+DIA
	set DIL=DIL+DIA
	quit 
	

INT5(RecordLN ln)	// Calculate interest due when scheduled disbursements made during BLOFF

	/*
	
	   This section will calculate interest due on the loan bill assuming
	   disbursements will be made as stated on the loan disbursement schedule
	
	   Billing and due dates are not included when determining whether
	   or not disbursements occured during billing offset period.
	
	*/

	new FDT,SDA,SDD,SDS

	// Disb sched not on file
	if 'ln.dschpr quit

	// Non anticipated int
	quit:'$E(STBL("PCM",PCM),4)
	
	type ResultSet rs=Db.select("SDD,SDA,SDS","LNDS1","CID=:CID and SDD>=:BILDT and SDS=0")
	if 'rs.isEmpty() quit
	while rs.next() do { quit:SDD'<BLDUE
		set SDD=rs.getCol(1)
		set SDA=rs.getCol(2)
		set SDS=rs.getCol(3)
		// Consider only if SDS=0
		set INT=INT+$$^UIC(SDA,SDD,BLDUE-1,ln.iacm,IRN,0,ln.dist1af,ln.dist1fre,ln.icpf,SCHND,ln.schld)
		}
	
	// Round accord to CRCD
	set INT=$$^SCARND(INT,0,CID)
	quit 
	

INT6(RecordLN ln,RecordLNBIL1 lnbil1) // Subsidizied interest amount


	//Calculate subsidy amount
	
	if ln.subpln'="" do {
		type RecordUTBLLNSUB utbllnsub=Db.getRecord("UTBLLNSUB","SUBPLN=:ln.subpln")
		if utbllnsub.rfreopt=2 do CALCSUB(.ln,.lnbil1)
		}	
	// Subtract subsidy amount from calculated interest
	set INT=INT-ln.subamt 
	if INT<0 set INT=0
	set PMTPIADJ=PMTPI-ln.subamt
	
	quit 
	

INT7	// Adjust interest and principal by excess calculated interest amount
	
	if acrproj.get()'="",INT>acrproj set INT=INT-$$^SCARND(acrproj,0,CID)

	quit 
	

LUMPAMT(RecordLNBIL0 lnbil0,ELMNT)	// Return lump amount for billed element
	
	new ROW
	set AMT=0
	set ROW=$$BIL0^BILFUNCS(.lnbil0,ELMNT)
	set AMT=ROW.piece("#",5)

	quit AMT
	

PRN(RecordLN ln,RecordLNBIL0 lnbil0,RecordTTX ttx,BLDUE)  // Calculate principal amount
	
	set PRN=""
	if '$$ELMNTDUE(.ln,.lnbil0,"P",BLDUE) quit ""
	
	// negative balance
	if BALCMP<0,'ln.peba,NBBO do PRN1(.ln) quit ""

	// matured - bill balance
	if ln.mdt,(BLDUE'<(ln.mdt+ln.peba)),(ln.rencd=4) do PRN2 quit PRN
	
	// Calc prin from PCM
	do PRN3(.ln,BLDUE)

	// Adjust principal by aei
	do PRN4(.ln)

	if PRN>0 quit PRN

	quit ""
	

PRN1(RecordLN ln)	// Check for negative balance
	
	new X

	set X=BALCMP+ACR
	if X'<0 set X=-BALCMP
	else  set X=$$^SCARND(ACR,0,CID)
	
	type RecordDAYENDNBL dayendnbl=Class.new("RecordDAYENDNBL") 
	set dayendnbl.tjd=%SystemDate 
	set dayendnbl.cid=CID 
	set dayendnbl.negbal=X
	do dayendnbl.bypassSave() 
	
	quit 

	
PRN2	// Matured - bill entire balance
	
	set PRN=BALCMP-prvbil("P").get()
	quit 
	

PRN3(RecordLN ln,Date BLDUE) // Calculate PRN based upon value of position 3 of PCM

	type public Date LBDD
	type public Number FPA,PMTPIADJ,PPB,PRN
	type public String blamt(),PCM,SPR,STBL(,)

	type Boolean NBBO
	type Number INT,P3
	type String RECFRQ

	set P3=STBL("PCM",PCM).extract(3)
	set INT=blamt("I").get()

	if 'P3 set PRN=PMTPIADJ-INT quit 

	if P3=2 do { quit 
		type Number X
		set X=$$^UIC(ln.balint,LBDD,BLDUE-1,ln.iacm,ln.iro,1,ln.dist1af,ln.dist1fre,"")
		set PRN=ln.pmtorg-$$^SCARND(X,0,ln.cid)
		set PMTPIADJ=INT+PRN
		}
	
	if P3=3 do { quit 
		
		type Number FPC
		
		set PRN=ln.fpa
		if ln.dist1fre'="*" quit 
		
		type RecordLNPS1 lnps1=Db.getRecord("LNPS1","CID=:ln.cid,PDD=:BLDUE")
		set FPC=lnps1.fpc
		if FPC.isNull() quit
		
		if ln.fpa-FPC=0 quit 
		set ln.fpa=FPC
		set (PRN,FPA)=FPC

		type RecordHIST hist=Class.new("RecordHIST")
 
		set hist.cid=ln.cid
		set hist.tseq=Db.nextVal("HIST","ln.cid")
		set hist.tjd=%SystemDate
		set hist.efd=%EffectiveDate
		set hist.tlo=%UserStation
		set hist.tcmt=CID_"[LN]FPA:"_FPC_":"_ln.fpa
		set hist.cdt=%CurrentDate
		set hist.time=%CurrentTime
		set hist.uid=%UserID
		set hist.spr=SPR.get()

		do hist.bypassSave()
		}
	
	if (P3=4)!(P3=5) do RPP1(.ln) do { quit 
		set PPB=$$PPB(.ln)
		if IPFC.get() set PRN=PPB
		else  set PRN=PPB-INT
		}
	quit 
	

PRN4(RecordLN ln) // Adjust principal by aei

	new AMTDUE,DIFF,TOTPMT

	set PRN=PRN+aei.get()
	if ln.subamt,acrproj.get() do {
		set TOTPMT=PMTPIADJ+ln.subamt
		set AMTDUE=$$^SCARND(BALCMP+acrproj,0,CID)
		if TOTPMT>AMTDUE do {
			set DIFF=TOTPMT-AMTDUE
			set PRN=PRN-DIFF
			set PMTPIADJ=PMTPIADJ-DIFF
			}
		}
	quit 
	

RPP1(RecordLN ln) // Revolving payment plan - define balance for calcs - RPPBAL

	type public Boolean IPFC,NBBO
	type public Date BNDT
	type public Number BALCMP,CALOP,P3,PBT,RPPBAL
	type public String RECFRQ,UAVB()

	type Number BALOP,WIRN
	
	type RecordUTBLRPP utblrpp=Db.getRecord("UTBLRPP","PLAN=:ln.rpp")
	
	// Balance option, calculation option
	set BALOP=utblrpp.balop
	set CALOP=utblrpp.calop
	
	// Recalc frequency, increase pymt by finance charge
	set RECFRQ=utblrpp.recfrq
	
	if P3=5 set IPFC=1
	else  set IPFC=0
	
	// Percent of Balance Type
	set PBT=utblrpp.pbt
	
	// Negative Balance Posting Option
	set NBBO=utblrpp.nbbo
	
	if 'BALOP set RPPBAL=BALCMP
	if BALOP=1 set RPPBAL=ln.baola
	if BALOP=2 set RPPBAL=ln.habl2
	if BALOP=3 set RPPBAL=ln.habl1
	if BALOP=4 set RPPBAL=ln.balint
	if BALOP=5 do {
		if 'UAVB(1).exists() do INIT^UAVB(.ln,ln.cid,ln.bldt+1,BNDT,1)
		set RPPBAL=UAVB(1).piece("|",20)
		}
	quit 

	
PPB(RecordLN ln)	// If necessary, recalculate PPB
	
	set X=ln.bloff if ln.bloff="1P" do {
		set JD=LBDD 
		set FRE="-"_ln.dist1fre 
		set NJD=$$NJD^UFRE(JD,FRE) if ER quit
		if NJD<ln.odd set NJD=ln.odd
		set X=JD-NJD if X<0 set X=0
		}
	if ER quit ""
	
	if ln.ladt'>(LBDD-X),(RECFRQ=1),(BSEQ>0) quit PPB
	
	set OLTAMT=ln.crlmt*(ln.oltp/100)
	if ln.bpocl,BALCMP>(ln.crlmt+OLTAMT) do {
		new OVERAMT
		set OVERAMT=BALCMP-(ln.crlmt+OLTAMT)
		set RPPBAL=RPPBAL-OVERAMT
		}
	if RPPBAL<0 set RPPBAL=0

	new FACT
	set FACT=""
	if 'ln.pbpor do {
		type Number RBAL = RPPBAL + .01
		type ResultSet rs=Db.select("FACT","UTBLRPPB","PLAN=:RPP and TIER<:RBAL","TIER DESC")
		if rs.next() set FACT = rs.getCol("FACT")
		}
	else  set FACT=ln.pbpor 
	set:FACT="" FACT=+FACT

	/*
	If the Calculation Option is null, and the Percent of Balance has a
	positive value, Payment Base will be calculated by the interest
	calculation utiliy $$^UIC.
	If the Calculation Option is 1, the Payment Base will be a specified
	amount of RPPBAL based on the tier structure.
	If the Calculation Option is 2, the Payment Base will be an amount
	calculated by dividing RPPBAL by a divisor based on the tier
	structure.
	Otherwise, the Payment Base will be a specified percentage of
	RPPBAL based on the tier structure.
	*/

	if 'CALOP.get() , PBT set PPB=$$^UIC(RPPBAL,LBDD,BLDUE-1,ln.iacm,FACT,1,ln.dist1af,ln.dist1fre,"")
	else  set PPB=$S(CALOP=1:FACT,CALOP=2:RPPBAL/FACT,1:RPPBAL*FACT/100)

	set PPB=$$^SCARND(PPB,0,CID)

	quit PPB
	

SETLNK(RecordLNBIL1 lnbil1,
       RecordLNBIL5 lnbil5(),
       String FEE,		// Fee Plan
       Boolean KEY)		// Update LNBIL1 amounts flag
       
	// Set linked fees

	type public Number blamt()
	type public String lnkfee(,)

	type String LNK = ""

	for  set LNK = lnkfee(FEE,LNK).order() quit:LNK.isNull()  do {
		
		if blamt(LNK).exists() quit 
			
		do LNBIL5( .lnbil1, .lnbil5(), LNK, KEY)
		
		do SETLNK( .lnbil1, .lnbil5(), LNK, KEY)
		}

	quit


LNBIL5(RecordLNBIL1 lnbil1,
       RecordLNBIL5 lnbil5(),
       String FEE,		// Fee Plan
       Boolean KEY)		// Update LNBIL1 amounts flag
       
       // Set entries for LNBIL5 and update LNBIL1 (if necessary)
	
	type public Number CID, BL5SEQ, BSEQ, blamt(), prvbil()

	type Number AMT
	
	type RecordLNFEE lnfee = Db.getRecord("LNFEE", "CID = :CID, FEETYP = :FEE")
	
	set AMT = lnfee.feerem - prvbil(FEE).get()
	
	if 'AMT quit
	
	set BL5SEQ = BL5SEQ + 1

	set lnbil5(BL5SEQ) = Db.getRecord("LNBIL5", "CID = :CID, SCHSEQ = :BSEQ+1, DUEAMT = :KEY, FEETYP = :FEE", 1)
		
	set lnbil5(BL5SEQ).bfamt = AMT
	set lnbil5(BL5SEQ).brfamt = AMT
	
	if (KEY = 1) do {
		
		set lnbil1.casd = lnbil1.casd + AMT
		set lnbil1.ctab = lnbil1.ctab + AMT
		}
		
	set blamt(FEE) = blamt(FEE).get() + AMT

	quit 
	

PMTPI(RecordLN ln,DUEDT)
	
	new PINC,PI
	set PINC=""
	if 'ln.pchnd quit ln.pmtpi
	set PI=ln.pmtpi
	set PCHND=ln.pchnd

	type RecordLNAPCHG lnapchg=Db.getRecord("LNAPCHG","CID,PCHND",1)
	
	set PINC=lnapchg.lfre
	if BLDUE>ln.pchnd do { quit PI
		if 'PINC set OVR(CID,"OVR","PINC")="" quit 
		set PI=PINC
		}
	if BLDUE=ln.pchnd,ln.icm do {
		if PINC set PI=PINC
		set OVR(CID,"OVR","PINC")=""
		}
	
	quit PI
	
	
Public IRN(RecordLN ln,DUEDT)

	/*
	   INPUTS:

		. ln	ln object	/TYP=RecordLN/REQ/REF:RW
		. DUEDT Due Date	/TYP=D/REQ
	*/

	type Number IRNC,RATE
	type Date ICHND

	set RATE=ln.irn
	if 'ln.ichnd quit RATE
	set ICHND=ln.ichnd
	set IRNC=""
	
	// 8446 - Only define IRNC if LNVRCHG record exists
	if Db.isDefined("LNVRCHG","ICHND,CID=:ln.cid") do {
		type RecordLNVRCHG lnvrchg=Db.getRecord("LNVRCHG","ICHND,CID=:ln.cid")
		set IRNC=lnvrchg.nrate
		}

	if (ln.intoff&(DUEDT>ICHND))!(ln.icm&(DUEDT=ICHND)) do OVR
	
	quit RATE

	
Public TEASRT(RecordLN ln,DUEDT)

	/*
	
	Arguements:
	. ln	ln object						/TYP=RecordLN/REQ/REF:RW
	. DUEDT - Date to compare against Teaser Rate Expiration Date	/TYP=D/REQ
	
	   INPUT:
	   IRN - Interest Rate
	
	   OUTPUT:
	   TSRFLG - Is teaser rate in effect
	
	   RETURNS:
	   RATE - Rate which should be used according to Teaser Expiration
	  -----------------------------------------------------------------------
	*/


	new RATE,TRATE,TREXD

	set RATE=ln.irn 
	set TSRFLG=""
	if 'ln.trate.isNull(),DUEDT<ln.trexd set RATE=ln.trate set TSRFLG=1
	quit RATE
	

OVR	// Check for possible override

	if 'IRNC set OVR(CID,"OVR","IRNC")=""
	else  set RATE=IRNC
	quit 


public ELMNTDUE(RecordLN ln,RecordLNBIL0 lnbil0,ELMNT,DUEDT)	// Find out if this element is due on this due date

	/*
	Arguments:
	. ln		ln object						/TYP=RecordLN/REQ/REF:RW
	. lnbil0	lnbil0 object						/TYP=RecordLNBIL0/REQ/REF:RW
	. ELMNT		Payment Element						/TYP=T/REQ
	. DUEDT		Date to compare against Teaser Rate Expiration Date	/TYP=D/REQ
	*/

	if $$ELECHK^BILFUNCS(ln.ppdcat1,ELMNT)=0 quit ""

	new BIL0,JD,X

	set BIL0=$$BIL0^BILFUNCS(.lnbil0,ELMNT)	
	set X=BIL0.piece("#",4) if 'X!(X=1) quit 1
	set JD=$S(X=2:ln.dist2nd,X=3:ln.dist3nd,1:ln.dist4nd)
	if DUEDT=JD quit 1
	quit ""
	

MPPF(RecordLN ln,RecordLNBIL1 lnbil1)	// Minimum payment required to produce form
	
	if lnbil1.casd'<ln.mppf quit 

	new AMT,DATA,PC

	for PC=1:1:20 set DATA=$$SUB^BILFUNCS(PC,.lnbil1) quit:DATA=""  do {
		set AMT=DATA.piece("#",4) 
		if AMT do SETBIL(.ln,.lnbil1,-AMT,DATA.piece("#",1))
		}
	quit 

	
PAYOFF(RecordLN	ln,RecordLNBIL1 lnbil1,RecordTTX ttx) // Is loan nearing payoff ?
	
	if '$$ELECHK^BILFUNCS(ln.ppdcat1,"P") quit

	new PIIND,POFF,SAVPTR
	set SAVPTR=""

	set POFF=0
	set PIIND=+$E($$PCMVAL^LNCDI(PCM))

	// Is too much principal being billed ?
	set X=prvbil("P").get()+blamt("P").get()-BALCMP
	if 'ln.peba,X>0 do {
		if X>blamt("P").get() set X=blamt("P").get()
		do SETBIL(.ln,.lnbil1,-X,"P") if PIIND set POFF=1
		}
	

	// First check for any account with the options to bill any amount of
	// prin greater than BALCMP and prin greater than target balance
	
	//  Always use CRLMT when PTBAL not set
	if ln.bpocl,PTBAL'>0 set PTBAL=ln.crlmt
	
	if ln.bpocl do {
		if 'ln.collimpr set X=+$$BLDPRN(.ln,$S((ln.crlmt>PTBAL):PTBAL,1:ln.crlmt)) if X>0 do SETBIL(.ln,.lnbil1,X,"P") quit 
	
		// Use lesser of CRLMT, PTBAL, & COLLIM if LN.COLLIMPR=1
		new LBAL
		set LBAL=$S(((ln.collim<PTBAL)&(ln.collim<ln.crlmt)):ln.collim,((PTBAL<ln.crlmt)&(PTBAL<ln.collim)):PTBAL,1:ln.crlmt)
		set X=+$$BLDPRN(.ln,LBAL) if X>0 do SETBIL(.ln,.lnbil1,X,"P")
		}
	
	if 'ln.bpocl,PTBAL>0 set X=+$$BLDPRN(.ln,PTBAL) if X>0 do SETBIL(.ln,.lnbil1,X,"P")
	
	if blamt("P").get()<0 do SETBIL(.ln,.lnbil1,blamt("P"),"P")
	

	// If billing fixed average interest and the loan has matured,
	// then bill the accrual minus previosly billed amounts.
	if (ln.mdt<%SystemDate),($E(STBL("PCM",PCM),2)=2) do {
		new I
		do SETBIL(.ln,.lnbil1,-blamt("I").get(),"I")
		set I=ACR-prvbil("I").get()
		do SETBIL(.ln,.lnbil1,I,"I")
		}
	
	// Determine if final payment adjustment is needed.
	new RFPADJ,DIFF
	set RFPADJ=0
	if (ln.rfp>0),(ln.mdt),(BLDUE'<ln.mdt) do { if RFPADJ quit 

		if PIIND=0 quit
		// Compare payoff amt to P&I
		set DIFF=blamt("P").get()+blamt("I").get()-PMTPI

		// If payoff is greater than P&I, do not adjust the bill.
		if ln.rfp=1,DIFF<0 quit
		if ln.ballamt,ln.rencd'=4 do SETBIL(.ln,.lnbil1,ln.ballamt,"P")
		do SETBIL(.ln,.lnbil1,-DIFF,"I")
		set RFPADJ=1
		}
	
	if 'POFF.get() quit 
	
	// This loan is set up for P&I.  An adjustment has been made to
	// principal, indicating it is near payoff.  Now calculate the payoff amount.
	set SEFD=%EffectiveDate.get()
	set %EffectiveDate=BLDUE

	do Runtime.start("CS","","SAVPTR")
	set PAYOFF=$$EXEC^LNTCP1(.ln,.ttx) 
	set %EffectiveDate=SEFD
	do Runtime.rollback("SAVPTR")

	if PAYOFF-ln.tba>lnbil1.casd quit 
	
	set TT=blamt("P").get()+blamt("I").get() 
	set TT=lnbil1.casd-TT
	
	if ln.idp do { quit 
		set X=PAYOFF-ln.tba 
		set:X<0 X=0 set:X<blamt("I").get() X=blamt("I").get()
		do SETBIL(.ln,.lnbil1,-blamt("P").get(),"P")
		do SETBIL(.ln,.lnbil1,-blamt("I").get(),"I")
		do SETBIL(.ln,.lnbil1,X,"I")
		}
	
	// Use P&I as final pmt due if final pmt adjustment is not needed.
	if (ln.rfp=1),ln.mdt,BLDUE'<ln.mdt do { if RFPADJ quit 
		if PIIND=0 quit
		set DIFF=blamt("P").get()+blamt("I").get()-PMTPI

		// If Payoff is less than PMTPI, the bill is already adjusted.
		if DIFF<0 quit
		do SETBIL(.ln,.lnbil1,-DIFF,"I")
		set RFPADJ=1
		}
	
	// Interest calculated at time of billing
	set I=$$^SCARND(XLN09.piece("|",4),0,CID)-prvbil("I").get() 
	if I<0 set I=0
	do SETBIL(.ln,.lnbil1,-blamt("I").get(),"I") do SETBIL(.ln,.lnbil1,I,"I")

	// Principal = BALCMP - bill/unpaid prin + penalty - rebate
	set P=BALCMP-prvbil("P").get()+XLN09.piece("|",5)-XLN09.piece("|",6) 
	if P<0 set P=0
	do SETBIL(.ln,.lnbil1,-blamt("P").get(),"P") do SETBIL(.ln,.lnbil1,P,"P")

	quit 
	

BLDPRN(RecordLN ln,
       Number Z)
	
	new OLT,X

	set OLTAMT=$$^SCARND(ln.crlmt*(ln.oltp)/100,0,CID)
	if 'Z quit 0
	if Z'<BALCMP quit 0
	set X=0
	set OLT=OLTAMT+ln.crlmt
	if ln.bpocl,BALCMP>OLT set Z=OLT set X=X+(BALCMP-Z)-prvbil("P").get()
	else  set Z=OLT set X=X+(BALCMP-Z) set X=X-prvbil("P").get()-blamt("P").get()
	quit X

	
PMTMIN(RecordLN	ln,RecordLNBIL1 lnbil1) // Minimum payment amount
	
	new X

	if '$$ELECHK^BILFUNCS(ln.ppdcat1,"P") quit

	if 'ln.mpo do { quit
		if lnbil1.casd<ln.pmtmin set X=ln.pmtmin-lnbil1.casd do SETBIL(.ln,.lnbil1,X,"P")
		}
	
	if blamt("P")<ln.pmtmin set X=ln.pmtmin-blamt("P") do SETBIL(.ln,.lnbil1,X,"P")
	quit 

	
ROUND(RecordLN ln,RecordLNBIL1 lnbil1,RecordLNBIL0 lnbil0)	// Round payment here

	/*
	   Eventually, we may need an option to round to something greater
	   than "units" for internationalization
	*/

	// Do not round
	if ln.ropt=2 quit

	if (ln.pchnd="")!(BLDUE<ln.pchnd) quit

	// Round total loan pmt
	if 'ln.ropt do ROPT0(.ln,.lnbil1) quit

	// Round total escrow
	if ln.ropt=1 do ROPT1(.ln,.lnbil0,.lnbil1) quit

	// Round principal amount
	if ln.ropt=3 do ROPT3(.ln,.lnbil1) quit
	quit 


	
ROPT0(RecordLN ln,RecordLNBIL1 lnbil1)	// Use escrow account to round total loan payment
	
	new DIFF

	if $E(STBL("PCM",PCM)),ln.rnd="" quit 
	
	if $E(STBL("PCM",PCM)),blamt("ESC1").get() quit
	
	if ln.rnd="",blamt("P").get() do ROPT3(.ln,.lnbil1) quit 
	
	set DIFF=lnbil1.casd if DIFF set DIFF=1-DIFF

	// already rounded
	if 'DIFF quit

	// no escrow-to-round
	if ln.rnd="" quit
	if DIFF do SETBIL(.ln,.lnbil1,DIFF,ln.rnd)
	quit 
	

ROPT1(RecordLN ln,RecordLNBIL0 lnbil0,RecordLNBIL1 lnbil1)	// Round total escrow
	
	// Calculate total escrow amts

	new AMT,DIFF,ELMNT,TOTESC
	set TOTESC=""
	set ELENUM=0
	for  set AMT=$$ESCACT^BILFUNCS(.lnbil0,.ELENUM) quit:AMT=""  do {
		set ELMNT=AMT.piece($C(9),2)
		set TOTESC=TOTESC+$$AMTDUE^BILFUNCS(.lnbil1,ELMNT)
		}
	set DIFF=TOTESC#1 if DIFF set DIFF=1-DIFF
	if DIFF do SETBIL(.ln,.lnbil1,DIFF,ln.rnd)
	quit 

	

ROPT3(RecordLN ln,RecordLNBIL1 lnbil1)	// Round principal amount

	
	new DIFF,PRIN
	set PRIN=blamt("P").get() if 'PRIN quit 
	set DIFF=lnbil1.casd#1 if DIFF set DIFF=1-DIFF
	if DIFF do SETBIL(.ln,.lnbil1,DIFF,"P")
	quit 

	
BUMPFRE(RecordLN ln)	// Bump secondary frequencies
	
	new FRE,NJD
	if BLDUE=ln.dist2nd do { quit:ER
		set FRE=ln.dist2fre
		if FRE="*" set FRE="*"_(ln.dist2nd/3+2)
		set NJD=$$NJD^UFRE(ln.dist2nd,FRE) quit:ER
		if NJD=ln.dist2nd quit
		set ln.dist2nd=NJD
		set ln.dist2ld=ln.dist2nd
		}

	if BLDUE=ln.dist3nd do { quit:ER
		set FRE=ln.dist3fre
		if FRE="*" set FRE="*"_(ln.dist3nd/3+2)
		set NJD=$$NJD^UFRE(ln.dist3nd,FRE) quit:ER
		if NJD=ln.dist3nd quit
		set ln.dist3nd=NJD
		set ln.dist3ld=ln.dist3nd
		}

	if BLDUE=ln.dist4nd do { quit:ER
		set FRE=ln.dist4fre
		if FRE="*" set FRE="*"_(ln.dist4nd/3+2)
		set NJD=$$NJD^UFRE(ln.dist4nd,FRE) quit:ER
		if NJD=ln.dist4nd quit
		set ln.dist4nd=NJD
		set ln.dist4ld=ln.dist4nd
		}
	quit 

	
BILLDEF(RecordLN ln)

	new denegam,EFD

	set %EffectiveDate=BNDT

	if ln.bloff="1P" set NJD=$$NJD^UFRE(%EffectiveDate,FRE) quit:ER 
	else  set JD=%EffectiveDate+ln.bloff set FRE=ln.dist1fre set NJD=$$NJD^UFRE(JD,FRE) quit:ER  set NJD=NJD-ln.bloff
	if DIRND>NJD quit 
	
	set FRE=ln.dirfre
	set NJD=$$NJD^UFRE(DIRND,FRE) quit:ER  
	set DIRLD=DIRND 
	set DIRND=NJD

	type RecordDAYENDNEGAM denegam=Class.new("RecordDAYENDNEGAM") 
	set denegam.tjd=%SystemDate 
	set denegam.cid=CID 
	do denegam.bypassSave() 
	
	
	set DIA=DIA-LST
	set INT=INT+DIA
	set BILL=1
	set DIU=DIU-DIA
	set DIAA=DIAA+DIA
	set DIL=DIL+DIA
	quit 

	
Public PRVBIL(RecordLN ln,RecordLNBIL1 lnbil1) // Find previously billed amounts
	
	/*
	Arguments:
	. ln		ln object						/TYP=RecordLN/REQ/REF:RW
	. lnbil1	lnbil1 object						/TYP=RecordLNBIL1/REQ/REF:RW
	*/


	new ACR,CPID,DATA,FEE,IDP,X

	type public Number BSEQ

	set OSEQ=ln.oseq
	set BSEQ=ln.bseq
	set ACR=ln.acr

	// Include all non-due fees prior to OSEQ
	type ResultSet rs=Db.select("FEETYP,BRFAMT","LNBIL5","CID=:CID and DUEAMT>1 and SCHSEQ<:OSEQ","SCHSEQ DESC")
	while rs.next() do {
		set FEE=rs.getCol("FEETYP")
		set prvbil(FEE)=prvbil(FEE).get()+rs.getCol("BRFAMT")
		}

	if OSEQ>BSEQ quit 

	type ResultSet rs=Db.select("SCHSEQ","LNBIL1","CID=:CID AND SCHSEQ>=:OSEQ")
	while rs.next() do {

		type RecordLNBIL1 lnbil=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:rs.getCol(1)")
		set IDP=$$IDP(.ln,.lnbil) 

		for PC=1:1:20 set DATA=$$GETFIELD^BILFUNCS(PC,.lnbil) quit:DATA=""  do {
			new ELMNT
			set ELMNT=DATA.piece("#",1)
			set prvbil(ELMNT)=prvbil(ELMNT).get()+DATA.piece("#",4)
			if 'IDP quit 
			set CPID=lnbil.cpid
			set X=ACR if ACR>CPID set X=CPID
			set X=$$^SCARND(X,0,CID)
			if ELMNT="I" set prvbil("I")=prvbil("I").get()+X set ACR=ACR-X
			if ELMNT="P" set prvbil("P")=prvbil("P").get()+CPID-X
			}
		}
		
	type ResultSet rs=Db.select("FEETYP,BRFAMT","LNBIL5","CID=:CID and SCHSEQ>=:OSEQ","SCHSEQ")
	while rs.next() do {
		set FEE=rs.getCol("FEETYP")
		set prvbil(FEE)=prvbil(FEE).get()+rs.getCol("BRFAMT")
		}
	
	quit 

	
IDP(RecordLN ln,RecordLNBIL1 lnbil1)

	/*
	Arguments:
	. ln		ln object						/TYP=RecordLN/REQ/REF:RW
	. lnbil1	lnbil1 object						/TYP=RecordLNBIL1/REQ/REF:RW
	*/



	new check,ELMTI,ELMTP

	set check="-"_ln.ppdcat1_"-"
	if check'["-I-"!(check'["-P-") quit ln.idp

	if 'lnbil1.cpid quit 0
	// Get I element from bill
	set ELMTI=$$SUB^BILFUNCS("I",.lnbil1)

	// If amt from I element>0 quit 0
	if ELMTI.piece("#",1)>0 quit 0

	// Get P element from bill
	set ELMTP=$$SUB^BILFUNCS("P",.lnbil1)

	// If amt from P = zero quit 1
	if ELMTP.piece("#",1)=0 quit 1
	quit 0
	

public REMOVE(RecordLN ln, Number BSEQ)  // Remove a bill
	
	/*
	Arguments:
	. ln		ln object						/TYP=RecordLN/REQ/REF:RW
	. BSEQ		Billing Sequence					/TYP=N/REQ
	*/

	type public String BILL()

	type Number INTA,LUMP,PC
	type String DATA,ELMNT,ROW

	if BSEQ.get().isNull() quit 
	
	type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:BSEQ")
	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID=:CID")
	
	// Replace INTA
	do CALC^LNUBIL(.ln,"01")
	
	set INTA=lnbil1.coia
	set ln.inta=ln.inta+INTA

	// Replace lump amounts
	set ROW=$$ELEMENT^BILFUNCS(.lnbil0)
	for PC=1:1:20 quit:ROW.piece($C(9),PC)=""  do {
		if ROW.piece($C(9),PC).piece("#",5)="" quit
		set ELMNT=ROW.piece($C(9),PC).piece("#",1)
		set DATA=$$SUB^BILFUNCS(ELMNT,.lnbil1)
		set LUMP=DATA.piece("#",5)
		set DATA=ROW.piece($C(9),PC)
		set DATA.piece("#",5)=ROW.piece($C(9),PC).piece("#",5)+LUMP
		do SETBIL0^BILFUNCS(.lnbil0,PC,DATA)
		}

	do lnbil0.bypassSave()

	/*
	 The bill record is deleted here w/o accessing the filers because
	 we don't want PROCLNB1 to be called to update late charge dates
	 and other buckets.  This section is only called for future-dated
	 bill generation from ZAMT^LNPTS3 and bills being projected that 
	 are then removed shouldn't cause any real changes to take place.
	*/
	do Db.delete("LNBIL1","CID=:ln.cid AND SCHSEQ=:BSEQ","/NOJOURNAL/NOTRIGAFT/NOTRIGBEF/NOVALDD/NOVALREQ/NOVALRI/NOVALST")

	// Recalculate loan parameters after deleting bill
	do CALC^LNUBIL(.ln,"01")

	quit 
	

public AMT(RecordLN ln,
           RecordTTX ttx,
           Number CID)

	new BSEQ,BILLAMT,SAVPTR
	
	do Runtime.start("CS","","SAVPTR")
	
	type RecordLN ln1=ln.copy()

	do EXEC(.ln1,.ttx,CID,%SystemDate,0)

	set BSEQ=ln1.bseq
	if 'BSEQ do Runtime.rollback("SAVPTR") quit ""		
		
	type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:BSEQ")
	set BILLAMT=lnbil1.casd

	do Runtime.rollback("SAVPTR")

	quit BILLAMT
	
	
INIT(RecordLN ln) // Initialization

	type public Number BSEQ

	set NBBO=""
	
	set PCM=ln.pcm
	Type RecordSTBLPCM stblpcm=Db.getRecord("STBLPCM","KEY=:PCM")

	if 'STBL("PCM",PCM).data() set STBL("PCM",PCM)=stblpcm.pcmp

	set IDP=ln.idp
	set TYPE=ln.type

	set (BAL,BALCMP)=+ln.bal do {
		if ln.aruf set BALCMP=BALCMP-ln.udbal
		}
	// Currency Code
	set CRCD=ln.crcd 
	set ACR=+ln.acr
	set IRN=+ln.irn

	// Deferred Interest - Uncapitalized
	set DIU=ln.diu
	set DIL=DIU+ln.dic

	// Deferred Int - Annual Accumulation
	set DIAA=ln.diaa

	// Deferred Interest Next Resolution Date
	set DIRND=ln.dirnd

	// Deferred Interest Last Resolution Date
	set DIRLD=ln.dirld

	// Principal and Interest Payment
	set PMTPI=ln.pmtpi

	// Interest Adjustment
	set INTA=ln.inta
	set BNDT=+ln.bndt

	// Billing - Last Sequence Number
	set BSEQ=ln.bseq
	set RPP=ln.rpp 
	if RPP'="" set NBBO=Db.getOneRow("NBBO","UTBLRPP","RPP")

	// Fixed Interest Amount
	set FIA=ln.fia

	// Payment Base
	set PPB=ln.ppb

	// Principal Target Balance
	set PTBAL=ln.ptbal

	// deferred interest
	set DIA=""
	quit 


DIAPPB(RecordLN ln,RATE,BAL,INT,P2,P4,CAP)	//  Defered interest from % Bal Pay Rate

	new AVBALINT,FD,NEWINT,TD
	
	if '$$DIA(RATE.get(),CAP,P2) quit INT
	
	// No deferred int
	if P2 do { if NEWINT>0,NEWINT'>INT quit INT
		//  Cap all
		if CAP set NEWINT=0 quit
		set TD=BLDUE-1 
		set FD=LBDD
		set NEWINT=$$^SCARND($$^UIC(BAL,FD,TD,ln.iacm,RATE,1,ln.dist1af,ln.dist1fre,""),0,CID)
		}
	
	// No deferred int
	if 'P2 do { if NEWINT>0,NEWINT'>INT quit INT
		if CAP set NEWINT=0 quit 
		set TD=BLDUE-1 
		set FD=LBDD
		if 'UAVB(1).data() do INIT^UAVB(.ln,CID,FD,TD,1)
		//  average BALINT
		set AVBALINT=UAVB(1).piece("|",20)
		set NEWINT=$$^SCARND($$^UIC(AVBALINT,FD,TD,ln.iacm,RATE,1,ln.dist1af,ln.dist1fre,""),0,CID)
		}
	
	if NEWINT=0 set DIA=(INT-NEWINT)-DIU.get()
	if NEWINT>0 set DIA=(NEWINT-INT)-DIU.get()
	set LST=0
	
	// Check deferred interest against maximum limits
	if $L(ln.dimxb),DIA>ln.dimxb,(DIA-ln.dimxb>LST) do {
		set K="DIMXB" 
		set LST=DIA-ln.dimxb
		}
	if $L(ln.dimxy),DIA+DIAA>ln.dimxy,(DIA+DIAA-ln.dimxy)>LST do {
		set K="DIMXY" 
		set LST=DIA+DIAA-ln.dimxy 
		}
	if $L(ln.dimxl),DIA+DIL>ln.dimxl,(DIA+DIL-ln.dimxl)>LST do {
		set K="DIMXL" 
		set LST=DIA+DIL-ln.dimxl
		}	
	// Bill Deferred Interest
	set BILL=0
	if ln.iropt=1 do BILLDEF(.ln)
	
	if LST do {
		set DIA=DIA-LST
		type RecordLNDIDE dediexc=Class.new("RecordLNDIDE") 
		set dediexc.efd=%SystemDate 
		set dediexc.cid=CID 
		set dediexc.bdd=BLDUE 
		set dediexc.didi=K 
		set dediexc.cint=INT 
		set dediexc.pmtpi=PMTPI 
		set dediexc.limit=$S(K="DIMXB":ln.dimxb,K="DIMXY":ln.dimxy,K="DIMXL":ln.dimxl)
		set dediexc.lst=LST
		do dediexc.bypassSave() 
		}
	
	set NEWINT=INT
	
	if BILL=1 quit NEWINT
	
	/*
	Update deferred interest buckets
	uncapitalized
	*/
	set DIU=DIU+DIA

	// annual accumulation
	set DIAA=DIAA+DIA

	// life (computed data item)
	set DIL=DIL+DIA
	
	quit NEWINT
	

DIA(LNG,CAP,P2)	//  Should we continue with Interest cap or not

	// If LNG=1 then there is a pay rate
	if LNG,P2'=3 quit 1

	// If CAP=1 then defere all int billed
	if CAP,P2'=3 quit 1
	quit 0

	
CALCSUB(RecordLN ln,RecordLNBIL1 lnbil1) // Calculate subsidy amount
	
	new SUBRAT,SUBAMT
	set (SUBRAT,SUBAMT)=""
	
	do CALC^LNSUBU(.ln,CID,%SystemDate,.SUBRAT,.SUBAMT,INT)

	set ln.subamt=SUBAMT
	set ln.subrat=SUBRAT

	if 'SUBAMT.isNull() set lnbil1.csubamt=SUBAMT set lnbil1.csubdue=SUBAMT
	
	quit 
	

DISBRES(RecordLN ln) // Reset BALINT of disbursements expire on system date

	/*
	   OUTPUTS:
	   . BALINT
	   . Updated loan object
	
	*/

	type ResultSet rs=Db.select("EXPDT,SDA,REPYMT","LNDS1","CID=:CID")
	while rs.next() do {
		if rs.getCol(1)=(%SystemDate-1) do {
			set BALINT=ln.balint
			set BALINT=BALINT-rs.getCol(2)+rs.getCol(3)
			set ln.balint=BALINT
			}
		}
	quit 

	
ANTINT(RecordLN	ln)
	
	new ANTINT,CHG,ICHND,INTOFF,INTFRE,INDDATA,MATRIX,NJD,OJD
	
	set ICHND=ln.ichnd
	set INDDATA=$$INDDATA^LNU(.ln)
	set NJD=ICHND
	for  quit:NJD'<BLDUE  do { quit:ER 
		set CHG(NJD)=""
		set NJD=$$NJD^UFRE(NJD,ln.intfre) quit:ER 
		}
	set ANTINT=0
	set (NJD,OJD)=%SystemDate
	for  set NJD=CHG(NJD).order() do { quit:NJD=BLDUE  quit:ER 
		if NJD="" set NJD=BLDUE set RATE=IRN
		set PAR("MATRIX")=ln.intmat
		else  do CTL^UINDX(.ln,OJD,ln.balint,ln.intmat) quit:ER
		set ANTINT=ANTINT+$$^UIC(ln.balint,OJD,NJD-1,ln.iacm,RATE) quit:ER 
		set OJD=NJD
		}
	quit ANTINT
	
PAYTOL( RecordLN ln,		// Loan Record		RW 
	RecordLNBIL1 lnbil1) 	// Loan Bill Record	RW
	
	// Adds the tolerance amount due to the bill being generated

	type Number I,SEQ
	type String DATA

	if 'ln.toldue quit	// No tolerance amount(s) due
	
	type DbSet ds = Db.selectDbSet("LNBILTOL","CID=:ln.cid AND CASD=:ln.toldue")
	if ds.next() do {	// Should only be one matching record
	
		type RecordLNBILTOL lnbiltol = ds.getRecord("LNBILTOL")

		// P&I amounts aren't stored for IDP loans, so the whole P&I
		// due amount needs to be added to the bill record.
		if ln.idp = 1 do SETBIL^LNBLDE(.ln,.lnbil1,lnbiltol.cpid,"P")
	
		type RecordLNBIL1 biltmp = lnbiltol.copy()
	
		for I=1:1:20 do {
	
			set DATA = $$GETFIELD^BILFUNCS(I,.biltmp)

			if 'DATA.piece("#",4) quit	// No amount due
	
			do SETBIL(.ln,.lnbil1,DATA.piece("#",4),DATA.piece("#",1))
			}
		}

	set ln.toldue = 0

	quit
	

vSIG()	quit "60634^43105^Pat Kelly^45243"	// Signature - LTD^TIME^USER^SIZE
