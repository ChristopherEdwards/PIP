CMS8583(String IM) //
	/*
	  ORIG: DADAP - 08-Jan-1998
	  CALLED BY:
	      CALLS:  ^%ZD,^%ZFUNC,^%ZT,^SCADAT1,^SCADRV0,^SIGNON,^TTXEXT,
	              ^TTXP2,^UNBD,^UTLERR,^UTLFIL,^UTSO

	       DESC:  This program re-formats Authorization Request and
		      Acquirer Reversal Request for the card interface.
		      This specifically handles card messages in the 1992
		      Europay implementation of the ISO8583 standard message
		      format.  This routine has been adapted from PTMPHATM.M
		      by Phil Chenard in V4.2.

	     FILES :  ACN,CRCD,CRDTYP,DEP,DAYENDCMSHLD,HIST,PHLD,SCAU,SIGNON
		      TRN,TTX,UTBLCRCDNO,UTBLEXTINT,UTBLEXTTRN1,ZDDP

	       READ:
	        SET:

	   ARGUMENT:  IM - incoming message from switch

	    RETURNS:  OM - outgoing message to switch

	  EXT ENTRY:

	    EXAMPLE:  S OM=$$^CMS8583(IM)


	   This routine receives messages from the CMS network in ASCII
	   characters and reformats them into PROFILE structure for transaction
	   processing.

	   The message is variable length, and the structure will change based
	   on the context of the message itself.  In order to properly
	   identify exactly what is contained in a particular message, a series
	   of bit maps are included in the message that will identify the data
	   elements that are contained in the message.  The bit map is comprised
	   of 16 hexadecimal bytes, where each byte corresponds to 4 bit map
	   data elements.

	   Once the transaction is processed, an outgoing message will be built
	   to go back to the CMS network.

	  =======================================================================

	   Message Types:

	  * 	0100 	Authorization Request
	  ** 	0110 	Authorization Request Reply
	  * 	0120 	Authorization Advice
	  ** 	0130 	Authorization Advice Reply

	  * 	0400 	Acquirer Reversal Request
	  ** 	0410 	Acquirer Reversal Request Reply
	  * 	0420 	Acquirer Reversal Advice
	  ** 	0430 	Acquirer Reversal Advice Response

	  * 	0800 	Network Management Request
	  ** 	0810 	Network Management Resquest Response

	  * 	Received from the Switch
	  ** 	Sent to the Switch
	  ====================================================================

	   The processing related to CMS processing is as follows.


	   The message is passed to an INCOMING subroutine, where the message
	   will be "translated" and the data placed into variables to be used to
	   process the transaction.

	   Once the message has been interpreted, the transaction is then
	   processed.  As part of this process, a reply message is returned
	   identifying, basically, the success or failure of the transaction.

	   The third step in this procedure is to construct the outgoing message
	   to be sent to the CMS processor, or switch.  Based on the return
	   message from PROFILE, a response code is defined and the variable OM
	   is built.  This structure of this variable is dependent on the
	   incoming message type and contains only the information pertinent to
	   the transaction.

	  There are four main line tags:

	    INIT  - Initializes CMS and CMS8583 variables
	    INCOMING - Receives and reformats incoming messages
	    PROC  - Processes the transaction in PROFILE
	    OUTGOING - Reformats outgoing messages

	  ------------ Revision History ---------------------------------------
	
	   12/12/05 - SPR - 18555
		   Card Management - General DBI3 system area cleanup.
			
	  ----------------------------------------------------------------------

	*/

	type public Number NOER
	type public String ET,RM

	if IM.get()="" quit ""

	catch vERROR {

		set ET=vERROR.type
		set NOER=0

		if ET["%GTM-" do ZE^UTLERR quit

		set ET=ET_"-"_vERROR.thrownAt
		set RM=vERROR.description

		do ^UTLERR
		}


	//======================================================================
	// Dispatch to reformatter and process message
	//======================================================================

	type public Number ECHO
	type public String BIT(),ER,OM,TBL()

	type RecordDEP dep
	type RecordTTX ttx()

	set NOER=1
	set ECHO=0

	// Initialize variable
	do INIT

	// Format incoming message
	do INCOMING(IM,.TBL,.BIT)

	// Process transaction
	do PROC(.ttx())

	// Build outgoing message
	do OUTGOING(.OM,.BIT,.dep)

	// Echo messages not internally generated
	if 'ECHO set OM=$$RXLATE(OM)

	// should not be translated
	set ER=0

	quit OM.get()


	//======================================================================
INIT	// Initialize variables
	//======================================================================

	type public String %ATM,%LOGID,%MODE,%NET,%SUBMODE,%UCLS,%UserId,BCAL,CHAR,ER,IIN,RT,SPR,STFUCLS,TBL(),TCMT
	type public Number %LOG,BRCD,FINPRE,INQUIRY,NETWORK,PHC,POS,PRE,REV,STF,VALID

	do SYSVAR^SCADRV0()

	// login information
	set %LOGID=$$LOGID^SCADRV

	set %ATM=CUVAR.%ATM
	set %ATM=%ATM.piece("|",1)

	// Card interface 
	type RecordUTBLEXTINT utblext=Db.getRecord("UTBLEXTINT","INTRFACE=:%ATM",1)

	// Teller ID for card processing
 	set %UserID=utblext.uid

	type RecordSCAU scau=Db.getRecord("SCAU","UID=:%UserID")

	// User class
	set %UCLS=scau.%ucls

	// Branch code
	set BRCD=utblext.brcd

	// Institution number
	set IIN=utblext.iin

	// Store and forward userclass
	set STFUCLS=utblext.safucls

	// Hold table
	set RT=utblext.rt

	// determine how to log messages
	set %LOG=utblext.%log

	// business day calendar
	set BCAL=utblext.bcal

	// Permanent Hold Code
	set PHC=utblext.phc

	set %MODE="B"
	set CHAR="@"
	set %SUBMODE=""


	set (ER,FINPRE,INQUIRY,NETWORK,POS,PRE,REV,STF,VALID)=0
	set (SPR,TCMT)=""

	// Variable array 'TBL' for bitmap translation
	do INITBM(.TBL)

	quit


INCOMING(String IM,String TBL,String BIT)	// Receive and parse incoming messages in variable "IM"
	/*
	   ARGUMENTS:
	   . IM Incoming message from the SWITCH
	   . TBL Data element descriptions (see BITMAP section)
	   . BIT Data element values
	*/

	type public Number ERROR,NETWORK,NOER,PRE,REV,STF,VALID,VLD
	type public String ERAUT,ER,ET,MID,OMID,RM,RC

	catch vERROR {
 
                set ET=vERROR.type
		set ER=1
 
                if ET["%GTM-" do ZE^UTLERR quit
		set NOER=0

                set ET=ET_"-"_vERROR.thrownAt
                set RM=vERROR.description
 
                do ^UTLERR
                }

	set ERROR=0

	// Message Type and set up
	set MID=$$BITMAP(IM,.TBL,.BIT)

	// array of data elements

	if "-0100-0120-0121-0400-0420-0421-0800"'[MID do { quit

		//Only the above are
		set VALID=0

		//invalid message codes
		set ER=1
		set RC="30"
		}
	else  set VALID=1

	// Default AC if message does not process
	set ERAUT="      "
	set VLD=$$VALIDIN(MID,.BIT)

	// Translate into return message IDs for outgoing messages

	// store original for return
	set OMID=MID

	// message types that will
	if MID="0100" set MID="0110"

	// define response message ID
	if MID="0120" set MID="0130" set STF=1
	if MID="0121" set MID="0130" set STF=1

	// be received from the Switch
	if MID="0400" set MID="0410" set REV=1
	if MID="0420" set MID="0430" set STF=1
	if MID="0421" set MID="0430" set STF=1
	if MID="0800" set MID="0810"

	// Network transactions
	if MID.extract(2)="8" set NETWORK=1 quit

	// Identify message as pre-auth
	if MID.extract(2)="1" set PRE=1

	// Identify message as a reversal
	if MID.extract(2)="4" set REV=1

	if 'VLD set RC="30" set BIT(38)=ERAUT quit

	do CARD

	quit


CARD	// Card information

	type public String BIT(),CRDNUM,CRDTYP,ER,ERAUT,TMDATE,TRACE
	type public Number ERROR,RC,TTIME
	type public Date EXPDATE,TRDATE

	// Primary Card Number
	set CRDNUM=BIT(2).get()

	if CRDNUM.get()="" do {
		set ERROR=1
		set ER=1
		set RC=14
		set BIT(38)=ERAUT
		}
	else  do {
		type ResultSet rs=Db.select("CRDTYP","CRD","CRDNUM=:CRDNUM")
		if rs.next() set CRDTYP=rs.getCol("CRDTYP")
		}

	if CRDTYP.get()="" do {

		// Invalid card number
		set ERROR=1
		set ER=1
		set RC=14
		set BIT(38)=ERAUT
		}


	//Transaction information

	// Trans. date and time
	set TMDATE=BIT(7).get()

	// Trace number
	set TRACE=BIT(11).get()

	// Trans. time local
	set TTIME=BIT(12).get()

	// Trans. date local
	set TRDATE=BIT(13).get()

	// Expiration date
	set EXPDATE=BIT(14).get()

	do POS

	quit


POS	// Point of Service Info

	type public String AUTCODE,BIT(),EXPDATE,EXPDT,ER,ERAUT,MID,MTYP,NETID,PAYEE,POSEM,RC,RETRN,RRC
	type public Number AISC,AIIC,FIIC,POSCC,REV,STF,YEXP,YR
	type Number MEXP,MNTH

	// Merchant's type
	set MTYP=BIT(18).get()

	// POS entru mode
	set POSEM=BIT(22).get()

	// Network identifier
	set NETID=BIT(24).get()

	// POS condition code
	set POSCC=BIT(25).get()

	// Acquiring inst. ID code
	set AIIC=BIT(32).get()

	// Forwarding inst. ID
	set FIIC=$S(BIT(33).exists():BIT(33).get(),1:BIT(32).get())

	// Payee
	set PAYEE=BIT(98).get()

	// Miscellaneous information

	set AUTCODE=BIT(38)

	// Retrieval reference number
	set RETRN=BIT(37).get()
	if BIT(39).exists() do { quit:ER

		// Response code
		set RRC=BIT(39).get()

		// Reversal transaction
		if MID.extract(2)=4 quit

		if RRC'="00" do {

			// Store and forward
			if STF quit

			// Reversal
			if REV quit

			// Denied by the switch
			set ER=1
			set RC="00"
			set BIT(38)=ERAUT
			}
		}

	// Intermediate network facility
	set AISC=BIT(62).get()

	/* Current date
	   Setting Expiration date to check if the card has already expired
	   This must assume that there were no cards issued to expire
	   before 1970 and no cards issued to expire after 2069, since
	   PROFILE is getting only two-digit years.  If the system upgrades
	   to four-digit years, this will not be an issue.
	*/

	// Current year
	set YR=%SystemDate.year()

	// Current month
	set MNTH=%SystemDate.month()

	if EXPDATE'="" do { quit:ER
		if EXPDATE.length()=4 do {

			//Year on expirartion
			set YEXP=EXPDATE.extract(1,2)

			//Month of expiration
			set MEXP=EXPDATE.extract(3,4)
			set YEXP=$S(YEXP<70:"20"_YEXP,1:"19"_YEXP)
			}
		else  do {
			set YEXP=EXPDATE.extract(1,4)
			set MEXP=EXPDATE.extract(5,6)
			}

		if YR>YEXP set ER=1 set RC="54" set BIT(38)=ERAUT quit

		if YR=YEXP,MNTH>MEXP set ER=1 set RC="54" set BIT(38)=ERAUT quit
		}

	// Dates

	// expiration date
	set EXPDT=BIT(14).get()
	if EXPDT'="" do {
		set EXPDT=EXPDT.extract(3,4)_"01"_EXPDT.extract(1,2)
		
		set EXPDT=EXPDT.toDate("MM/DD/YEAR")

		set EXPDT=$$EOMJD^SCADAT(EXPDT,1)
		}

	do ATMID

	quit


ATMID	// Card Acceptor Termininal location information

	type public String AAMT1,AAMT3,ERAUT,BIT(),CAID,CACS,CACNTRY,CACTY,CALOC,CAST,CRCD,ER,LOC,ORCRCD,ORIGINAL,ORIGFIID,ORIGMID,RC,REPAMT
	type public Number AMT2,AMT3,CNVRT1,ATMID,EXP3,FINPRE,FOREIGN,ORIGSTAN,RATE,REV,TLO
	type public Date CNVDATE,ORIGDATE

	//Card Acceptor Terminal ID #
	set ATMID=BIT(41).get()

	//Card Acceptor ID Code
	set CAID=BIT(42).get()

	//Card Acceptor Location
	set CALOC=BIT(43).get()
	if CALOC'="" do {

		//Physical Location
		set CACS=$$RTB^%ZFUNC(CALOC.extract(1,23))

		//Card Acceptor City
		set CACTY=$$RTB^%ZFUNC(CALOC.extract(24,26))

		//Card Acceptor State
		set CAST=CALOC.extract(37,38)

		//Card Acceptor Country
		set CACNTRY=CALOC.extract(39,40)

		//REG E info
		set LOC=CACS_","_CACTY_","_CAST_","_CACNTRY
		}
	else  set LOC=CAID

	if ATMID'="" set TLO=ATMID
	else  set TLO=$$TLO^UTLO

	/* Currency information - this assumes that there is an implied two digit
	   exponent in both the settlement currency and the card holder billing
	   currency.
	*/

	//Foreign exchange
	if BIT(6).get() do {
		set FOREIGN=1

		//Settlement amount
		set AMT2=BIT(5).get()/100

		//Amount card holder billing
		set AMT3=BIT(6).get()

		//Conversion rate, settement
		set CNVRT1=BIT(9).get()

		//Conversion rate, card holder billing
		set RATE=BIT(10).get()

		//Conversion date
		set CNVDATE=BIT(16).get()

		//Currency code, card issuer
		set CRCD=$$CRCD(BIT(51).get())
		set EXP3=$$EXP(CRCD)

		set AMT3=AMT3/EXP3
		}
	else  set CRCD=$$CRCD(BIT(49).get())

	if CRCD="" set ER=1 set RC="12" set BIT(38)=ERAUT quit

	set ORCRCD=BIT(49).get()

	if ORCRCD do {	
		type ResultSet rs=Db.select("CRCD","CRCD","CO=:CUVAR.CO AND CRCDNO=:ORCRCD")
		if rs.next() set ORCRCD=rs.getCol("CRCD")
		}

	/*
	Define Original transaction data elements used in 
	pre-authorizations, reversals
	*/

	//Original Data elements
	if BIT(90).get()'="" do {
		set ORIGINAL=BIT(90)

		//Original message type
		set ORIGMID=ORIGINAL.extract(1,4)

		//Previous pre-auth
		if ORIGINAL.extract(2)=1 set FINPRE=1

		//Original system trace audit #
		set ORIGSTAN=ORIGINAL.extract(5,10)

		//Original date and time of transaction
		set ORIGDATE=ORIGINAL.extract(11,20)

		//Original forwarding inst. ID
		set ORIGFIID=ORIGINAL.extract(15,26)
		}


	//Replacement amounts - used for partial transactions

	if REV!(BIT(95).get()'="") do {

		//Replacement amount
		set REPAMT=BIT(95).get()

		//Actual amount,transaction
		set AAMT1=REPAMT.extract(1,12)

		//Actual amount,card holder billing
		set AAMT3=REPAMT.extract(25,36)
		set REPAMT=REPAMT/$$EXP(ORCRCD)
		}

	/* This field is present when a transaction is being reversed, or
	   when a POS correction is processed.  The replacement amounts are
	   the actual amounts of the transaction, where the previously
	   processed transaction used a different amount.  If a reversal
	   comes through and there are NO replacement amounts, the reversal
	   is a full reversal, otherwise, we need to process a new
	   transaction with this replacement amount and reverse the original.

	   In this case, TAMT was the amount disbursed from the original
	   transaction, AAMT1 is what was really disbursed. The original
	   transaction will be error corrected and a new transaction will
	   be posted for the AAMT1 amount.

	   If there are no amounts in the replacement amount fields, then
	   a full reversal will be required, otherwise, a partial disbursement
	   had been made.
	*/
	do PRCD

	quit


PRCD	// Set up the Process code and the Transaction Type (TRTYP)

	/*
	   The processing code contains three (3) pieces of information.
	   The transaction type or action code, the "From" account and the
	   "To" account.

	         Action Codes:


		"00"    -	debit, goods and services
		"01"    -	debit/withdrawal
		"17" 	-	debit (for cash advance)
		"31" 	-	inquiry services (for balance inquiry)

	         Account Types:


	         "00"    -       default account (checking)
	         "10"    -       savings
	         "20"    -       checking
	*/

	type public String %fcid,%tcid,BIT(),CUSTCD,ER,ERAUT,FRGRP,PRCD,RC,TOGRP,TRTYP,X,Y,Z
	type public Number FCID,INQUIRY,ORAMT,POS,SPR,STF,TAMT,TCID,TRCD

	type RecordUTBLEXTTRN1 exttrn

	//Process Code
	set PRCD=BIT(3).get()

	// Transaction Type
	set X=PRCD.extract(1,2)

	// Only process as account type 00-
	set Y="00"

	// default account type (checking)
	set Z="00"

	// point of sale debit
	if X="00" set POS=1

	// table only uses the 2 digits of PRCD
	set TRCD=$$GETTRN(X,.exttrn)

	// couldn't find tran in table
	if TRCD="" do { quit:ER

		// invalid transaction
		if 'STF set ER=1 set RC="12" set BIT(38)=ERAUT quit

		// set up "SUSPDR" tran code
		set TRCD=$$GETTRN("SUSPDR",.exttrn)
		}

	// account balance info
	if exttrn.inq=1 set INQUIRY=1 quit

	set TRTYP=exttrn.trtype

	/* Valid Account Groups: (Defined in PROFILE)
	   "SAV" = Savings Account
	   "DDA" = Checking Account
	*/
	set TOGRP="DDA"

	//always use the default account - DDA
	set FRGRP="DDA"

	//determine what the trans amount is
	set TAMT=$$TAMT
	set ORAMT=$$ORAMT
	set SPR=BIT(11).get()

	//initialize "customer" account numbers
	set (%fcid,%tcid)=""

	set FCID=$$FRCID

	if ER do { if ER set BIT(38)=ERAUT quit

		//If transaction is store and
		if 'STF quit

		//forward, we MUST process it
		set ER=0

		//into suspense
		set TRCD=$$GETTRN("SUSPDR",.exttrn)

		set TRTYP=exttrn.trtype
		}

	//Get "to" account
	set TCID=$$TOCID

	if ER do { if ER set BIT(38)=ERAUT quit

		//If transaction is store and
		if 'STF quit

		//forward, we MUST process it
		set ER=0

		//into suspense
		set TRCD=$$GETTRN("SUSPCR",.exttrn)
		set TRTYP=exttrn.trtype
		}

		//validate account number
		type RecordACN acn=Db.getRecord("ACN","CID=:FCID",1)
		if FCID'="",'acn.getMode() do { if ER set BIT(38)=ERAUT quit 

			if STF do { quit

				//suspense will be to the
				set TRCD=$$GETTRN("SUSPDR",.exttrn)

				//DEBIT side of the TR
				set TRTYP=exttrn.trtype
				}
			set ER=1
			set BIT(38)=ERAUT
			set RC=$S(FRGRP="SAV":"53",FRGRP="DDA":"52",1:"05")
			}

		//validate account number
		type RecordACN acn1=Db.getRecord("ACN","CID=:TCID",1)
		if TCID'="",'acn1.getMode() do { if ER set BIT(38)=ERAUT quit

			if STF do { quit

				//suspense will be to the
				set TRCD=$$GETTRN("SUSPCR",.exttrn)

				//CREDIT side of the TR
				set TRTYP=exttrn.trtype
				}

			set ER=1
			set BIT(38)=ERAUT
			set RC=$S(TOGRP="SAV":"53",TOGRP="DDA":"52",1:"05")
			}

	if FCID.get()'="" do {
		type RecordACN acn2=Db.getRecord("ACN","CID=:FCID",1)
		if acn2.getMode() set CUSTCD=acn.ccode
		}

	do STFCHK(.exttrn)

	quit


STFCHK(RecordUTBLEXTTRN1 exttrn)	// Store forward information - messages coming in as ADVICES have
	/*
	   already been processed by the Switch and need to be considered
	   as store and forward transactions by PROFILE. That is, they MUST
	   be processed by PROFILE since the transaction already occurred.
	*/

	type public String %UserId,BIT(),ETCCR,ETCDR,ER,ERAUT,MID,NETID,RC,RM,RRC,STFUCLS,TCMTCR,TCMTDR,TRTYP,TSO,TSPV()
	type public Number %fcid,%tcid,AAMT1,FCID,HSEQ,INQUIRY,ORIGMID,ORIGRRN,ORIGSTAN,REV,REPAMT,RETRN,STF,TCID,TRACE

	//Stand-in from switch
	if MID="0130"!(MID="0430") do {

		type Number AP,CID,TRC

		//Store and forward flag
		set STF=1

		//build supervisor array
		set TSPV("*")=%UserID_"|"_STFUCLS

		set CID=$S(%fcid'="":%fcid,%tcid'="":%tcid,1:"")
		if CID="" do { quit

			//Suspense transaction
			if TRTYP="SUSP",RRC="00" quit

			// No checking account
			set RC="52" set INQUIRY=1
			}

		//determine if transaction has already been processed
		set AP=$$CKPRE(CID,TRACE)

		set HSEQ=AP

		if AP,RRC="00" do { quit

			// duplicate transmission
			set RC="94"
			set INQUIRY=1

			// Card message ~p1 has already been processed
			set RM=$$^MSG(3791,TRACE)

			do EXC(CID,RM)
			}

		if AP,RRC'="00" do { quit

			//processed by us, but is to be reversed
			if REV quit

			//processed by us but
			if 'REPAMT.exists() set AAMT1=""

			//denied by the switch
			if 'ORIGMID.exists() set ORIGMID=MID
			if 'ORIGRRN.exists() set ORIGRRN=RETRN

			// system trace audit #
			if 'ORIGSTAN.exists() set ORIGSTAN=TRACE

			//flag trans to be reversed
			set REV=1 quit
			}

		if REV quit

		//not processed by us,denied by switch
		if RRC'="00" set RC="00" set INQUIRY=1 quit
		}

	//quit out of processing and just
	if INQUIRY.get() quit

	/* send an outgoing response
	   Always assume that there was an original transaction
	   and process the reversal
	*/

	// Transaction information

	// debit transaction
	set ETCDR=exttrn.dretc

	// credit transaction
	set ETCCR=exttrn.cretc

	//validate tran code
	type RecordTRN trn=Db.getRecord("TRN","ETC=:ETCDR",1)
	type RecordTRN trn1=Db.getRecord("TRN","ETC=:ETCCR",1)
	
	if 'trn.getMode() set ER=1 set RC="12" set BIT(38)=ERAUT quit

	//validate tran code
	if 'trn1.getMode() set ER=1 set RC="12" set BIT(38)=ERAUT

	// build ETC array
	type RecordTRN trnetcdr=Db.getRecord("TRN","ETC=:ETCDR")

	// build ETC array
	type RecordTRN trnetccr=Db.getRecord("TRN","ETC=:ETCCR")

	// default transaction comment
	set TCMTDR=trnetcdr.des

	// default transaction comment
	set TCMTCR=trnetccr.des

	//get G/L account number
	if FCID="" set FCID=$$GLACN^TRNUTL(.trnetcdr,%UserID)

	//get G/L account number
	if TCID="" set TCID=$$GLACN^TRNUTL(.trnetccr,%UserID)

	if REV set TSO=""

	// use network identifier
	set NETID=BIT(24).get()
	if NETID'="" set TSO=NETID
	else  set TSO=""

	quit


	//       Quit out of INCOMING
	//======================================================================
CKPRE(Number CID,Number RRN)	//determine whether a transaction has already been posted
	//======================================================================

	type Number AP,SEQ
	type Date TPD

	set SEQ=""
	set TPD=CUVAR.TJD
        set AP=0

	type DbSet rs=Db.selectDbSet("HIST","CID=:CID","TSEQ DESC")
	while rs.next() quit:(AP)!(%SystemDate-TPD>3)  do {
		type RecordHIST hist=rs.getRecord("HIST")
		set SEQ=hist.tseq
	
		//was already
		set TPD=hist.tjd

		//processed in a prior
		if hist.spr'=RRN.get() quit

		//message.
		set AP=1
		}

	//If so, pass this message through
	if AP.get() quit SEQ

	quit 0


	//======================================================================
JD( String %DS)	//return date in julian format  (input = MM/DD)
	//======================================================================

	type public Date %JD

	if %DS="" quit %SystemDate
	set %DS=%DS.extract(1,2)_"/"_%DS.extract(3,4)

	set %JD=%DS.toDate("MM/DD/YEAR")

	quit %JD


	//======================================================================
FRCID()	/* This function assumes that the transaction type (TRTYP) is a
	   withdrawal,transfer, or a balance inquiry.  If the account cannot be
	   found, return an error and account="".  If the transaction is to a
	   Savings account and the account cannot be found, check in the DDA
	   Card for a second checking account.
	  ======================================================================
	*/

	type public String BIT(),CRDNUM,CRDTYP,ER,ERAUT,FRGRP,RC,TRTYP
	type public Number %fcid,%tcid
	type Number CID

	set ER=0

	//No from account involved
	if TRTYP="CREDIT"!(TRTYP="PMT") quit ""

	//post to suspense
	if TRTYP="SUSP" quit ""

	//Make sure the from GROUP is defined
	if 'FRGRP.length() quit ""

	//If CID is in message, use it, otherwise
	set CID=+BIT(102).get()

	//get it from IM
	if CID quit CID

	if CRDTYP="",FRGRP="DDA" set ER=1 set RC="52" set BIT(53)=ERAUT quit ""
	set CID=""
	type ResultSet rs=Db.select("CID","CRDGRP","CRDTYP=:CRDTYP AND CRDNUM=:CRDNUM AND GRP=:FRGRP")
	if rs.next() do {
                set CID=rs.getCol("CID")
                set %fcid=CID
                }
	else  if FRGRP="DDA" do {
		set ER=1
		set RC="52"
		set BIT(53)=ERAUT
		}

	quit CID


	//======================================================================
TOCID()	/* This function assumes that the transaction type (TRTYP) is a
	   deposit or transfer.
	  ======================================================================
	*/

	type public String BIT(),CRDNUM,CRDTYP,ER,ERAUT,RC,TOGRP,TRTYP
	type public Number %tcid
	type Number CID

	set ER=0

	//No TO account involved
	if TRTYP="DEBIT"!(TRTYP="INQ") quit ""

	//post to suspense
	if TRTYP="SUSP" quit ""

	//Make sure the toGROUP is defined
	if '(TOGRP.get().length()) quit ""

	//If CID is in message, use it, otherwise
	set CID=+BIT(103).get()

	//get it from IM
	if CID quit CID

	if CRDTYP="",TOGRP="DDA" set ER=1 set RC="52" set BIT(38)=ERAUT quit ""
	set CID=""
	type ResultSet rs=Db.select("CID","CRDGRP","CRDTYP=:CRDTYP AND CRDNUM=:CRDNUM AND GRP=:TOGRP")
	if rs.next() do {
		set CID=rs.getCol("CID")
		set %tcid=CID
		}
        else  if TOGRP="DDA" do {
		set ER=1
		set RC="52"
		set BIT(38)=ERAUT
		}

	quit CID


	//======================================================================
TAMT()	/*get transaction amount
	  ======================================================================
	  amount, card issuer
	*/

	type public String BIT(),CRCD
	type public Number EXP

	if BIT(6).exists() do { quit BIT(6)/EXP
		set EXP=$$EXP(CRCD)
		}
	set EXP=$$EXP(CRCD)

	//transaction amount
	quit BIT(4).get()/EXP


	//======================================================================
ORAMT()	//get original transaction amount
	//======================================================================

	type public String BIT(),ORCRCD

	if 'BIT(4).exists() quit ""
	quit BIT(4).get()/$$EXP(ORCRCD)


	//======================================================================
EXP(String CURR)	// get number of decimal places
	//======================================================================

	type public String %CO,CRCD
	type Number EXP

	if CURR="" quit 1

	type RecordCRCD crcd=Db.getRecord("CRCD","CO=:%CO,CRCD=:CRCD")
	set EXP=crcd.curdec
	quit 10**EXP


	//======================================================================
public TCMT(String ETC)	//get the transaction comment
	//======================================================================

	/*

	ARGUMENTS:

	. ETC String			/REQ/NONULL/MECH=VAL

	*/

	type public String %ATM,PRCD
	type String TCMT

	if ETC.exists() quit ETC.piece("|",6)
	type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC",1)
	set TCMT=trn.des

	if TCMT'="" quit TCMT

	type RecordUTBLEXTTRN1 exttrn1=Db.getRecord("UTBLEXTTRN1","INTRFACE=:%ATM,CODE=:PRCD",1)
	set TCMT=exttrn1.desc

	if TCMT'="" quit TCMT

	quit ""


	//======================================================================
GETTRN(String PRCD,RecordUTBLEXTTRN1 exttrn)	//return transaction information
	//======================================================================

	type public String %ATM
	
	type RecordUTBLEXTTRN1 exttrn1=Db.getRecord("UTBLEXTTRN1","INTRFACE=:%ATM,CODE=:PRCD",1)
	if 'exttrn1.getMode() quit ""

	set exttrn=Db.getRecord("UTBLEXTTRN1","INTRFACE=:%ATM,CODE=:PRCD")

	quit 1


	//======================================================================
CRCD(String CURR)	// return ISO code
	//======================================================================

	type public String %SystemCurrency
	type String ISOCD = ""

	// default system currency if none specified
	if CURR="" quit %SystemCurrency.get()

	type ResultSet rs=Db.select("CRCD","CRCD","CO=:CUVAR.CO AND CRCDNO=:CURR")
	if rs.next() set ISOCD=rs.getCol("CRCD")

	if ISOCD="" do {
		set ISOCD=$$NCRCD(CURR)
		if ISOCD'="" set ISOCD=CURR
		}
	quit ISOCD


	//======================================================================

NCRCD(String CURR)	// return ISO numeric code
	//======================================================================

	type public String %CO,%SystemCurrency,CO,CRCD
	type String NCR

	if CURR="" set CURR=$S(%SystemCurrency.exists():%SystemCurrency,1:CUVAR.%CRCD)
	if 'CO.exists() set CO=$S(%CO.exists():%CO,1:CUVAR.CO)

	type RecordCRCD crcd=Db.getRecord("CRCD","CO=:CO,CRCD=:CRCD",1)
	set NCR=crcd.crcdno
	quit NCR


	//======================================================================
VALIDIN(String mid,String bit)	// return valid flag if all mandatory fields are present
	//======================================================================

	
	type Number pos,valid,I
	type String VALID

	set valid=1
	set pos=0

	if mid="0100" set VALID="2,3,4,11,18,22,32,33,49"
	if mid="0120"!(mid="0121") set VALID="2,3,4,11,18,22,32,33,38,39,49"
	if mid="0420"!(mid="0421") set VALID="2,3,4,11,22,32,33,38,39,49,90"
	if mid="0800" set VALID="11,33,48,70,100"
	for I=1:1:VALID.length(",") quit:'valid  do {
		set pos=VALID.piece(",",I)
		if 'bit(pos).data() set valid=0
		}
	quit valid


public	STRTPRC(RecordTTX ttx())	//************Standard Transaction Processing Coding*********************/

	/*
	ARGUMENTS:

	. ttx() Array of Objects for file TTX		/REQ/NONULL/MECH=REF

	*/

	do PROC(.ttx())

	quit


PROC(RecordTTX ttx())
	/*
	======================================================================
	Process the transaction - set up all necessary variables
	transactions will be two sided, i.e. debit and credit.
	======================================================================
	Variables that must be defined to process a PROFILE transaction

		CID 	- 	account number
		ETC 	- 	external transaction code
		TAMT 	-  	transaction amount
		EFD 	- 	effective date

		TLO 	- 	use for Reg E info
		TSO 	-  	use network identifier
		TCMT 	- 	transaction comment

		SPR 	- 	Transaction Date_Terminal Sequence #
	----------------------------------------------------------------------

	*/

	type public String %UserId,BIT(),CRDNUM,ER,ET,RM,RRC,SPR,TLO,TSO,TRACE,TRTYP
	type public Number AUTCODE,CID,ERROR,ETCCR,ETCDR,FCID,HSEQ,INQUIRY,NETWORK,NOER,PRE,REV,TAMT,TCID,TCMTCR,TCMTDR,VALID,VLD
	type public Date BCAL,%EffectiveDate,TPD
	type Date %DS,%JD
	type String ETC,FILL
	type RecordDEP dep

	catch vERROR {

		set ET=vERROR.type
		set ER=1

		if ET["%GTM-" do ZE^UTLERR quit
		set NOER=0

		set ET=ET_"-"_vERROR.thrownAt
 		set RM=vERROR.description
 
		do ^UTLERR
		}


	// don't process, error already occurred
	if ER quit
	if ERROR quit

	// hit the error trap - system error
	if 'NOER quit

	// not a valid message type
	if 'VALID quit

	// not a valid message (missing req. fields)
	if 'VLD quit

	// Transaction is an inquiry
	if INQUIRY quit

	// transaction is a network message
	if NETWORK quit

	set %EffectiveDate=""
	type RecordSIGNON signon=Db.getRecord("SIGNON","UID=:%UserID",1)
	if 'signon.getMode() do {

		set TPD=$$NBD^UNBD($$JD(BIT(15).get()),1,0,BCAL)
	
		// If posting date is in the past
		if TPD<%SystemDate set %EffectiveDate=TPD set TPD=%SystemDate

		// effective date transactions
		do TSGNON
		}

	type RecordSIGNON signon1=Db.getRecord("SIGNON","UID=:%UserID")
	set TPD=signon1.tpd

	set dep=Db.getRecord("DEP","CID=:CID")

	// handle reversal separately
	if REV do ATMREV(FCID,AUTCODE,RRC,HSEQ.get(),.dep) quit

	// build TR
	do TTX(FCID,$S(TRTYP="DEBIT":ETCDR,1:ETCCR),TAMT,%EffectiveDate,TLO,TSO,$S(TRTYP="DEBIT":TCMTDR,1:TCMTCR),SPR,CRDNUM,.ttx())
	if ER quit

	// build TR
	do TTX(TCID,$S(TRTYP="DEBIT":ETCCR,1:ETCDR),TAMT,%EffectiveDate,TLO,TSO,$S(TRTYP="DEBIT":TCMTCR,1:TCMTDR),SPR,CRDNUM,.ttx())
	if ER quit

	// pre-auths will need to hold funds
	if PRE do ATMPRE(FCID,TRACE,.ttx(),.dep)

	quit


	//======================================================================
TTX(Number CID,String ETC,Number TAMT,Date %EffectiveDate,String TLO,String TSO,String TCMT,String SPR,String MSD,RecordTTX ttx())	//build transaction array
	//======================================================================

	type public String BCRCD
	type public Number BSEAMT,TRC
	type String ITC
	type public Date %EffectiveDate


	set BCRCD=%SystemCurrency
	set BSEAMT=TAMT
	//set TRC=$O(ttx(""),-1)+1
	set TRC=ttx("",-1).order(-1)+1

	set ttx(TRC)=Class.new("RecordTTX")

	// utility to build TR
	do TTX^TTXEXT(.ttx(TRC))

	quit


	//*******************End Standard Transaction Processing****************/

	//======================================================================
ATMPRE(Number CID,String SPR,RecordTTX ttx(),RecordDEP dep)	// Pre-authorizations
	//======================================================================

	type public String %UserId,AUTCODE,BIT(),CRCD,CRDNUM,CRDTYP,ER,ERAUT,ET,ORCRCD,RC,TLO,TSO,UID
	type public Number BALLIM,BRCD,ORAMT,PHC,STF
	type String AUTLIF,DYS,MNS,X
	type Number BALAVL,EXP,HRS,EXPTM,SEQ,TAMT
	type Date EXPDT
	type public Date %SystemDate,TPD

	if dep.exists()=0 set ER=1,ET="RECNOF" do ^UTLERR

	if ER,STF quit

	set TAMT=$$CNVAMT(.ttx(),.dep)             // convert amounts into account currencydo CNVAMT(.dep,.ttx)

	//get available balance
	set BALAVL=$$AVLDEP^TTXEXT(.dep)

	set BIT(54)=$$^SCARND(BALAVL,,CID,,,,1)*$$EXP(CRCD)

	//If no amount, set RC=13 and return
	if 'TAMT set BIT(38)=ERAUT set RC="13" quit

	/*
	   removed code to add the auth. ovrd. lim. to available balance
	   since the new available balance includes the overdraft limit.
	*/
	set BALLIM=BALAVL

	//insufficient funds
	if 'STF if TAMT>BALLIM set ER=1 set RC="51" set BIT(38)=ERAUT quit

	set SEQ=1
	do {
		type String RC

		type RecordACN acn=Class.new("RecordACN")

		//process the transaction
		do Runtime.start("CS","","SAVPTR")

		do TRNSET^TRNDRV(.ttx(),TPD,BRCD,4)
		}

	//deny the transaction if error
	if ER,'STF set RC="05" set BIT(38)=ERAUT do Runtime.rollback("SAVPTR") quit

	do Runtime.rollback("SAVPTR")

	// set up pre-auth hold
	type ResultSet rs=Db.select("SEQ","PHLD","CID=:CID","SEQ DESC")
	if rs.next() set SEQ=rs.getCol("SEQ")+1

	if UID.get()="" set UID=%UserID.get()

	// Required fields for a permanent hold
	type RecordPHLD ffA=Db.getRecord("PHLD","CID=:CID,SEQ=:SEQ",1)
	set ffA.stdt=%SystemDate
	set ffA.amt=TAMT
	set ffA.phc=PHC
	set ffA.tlo=TLO
	set ffA.tcmt=TSO
	set ffA.spr=SPR
	set ffA.crdnum=CRDNUM
	set ffA.crdtyp=CRDTYP
	set ffA.autcode=AUTCODE
	set ffA.oramt=ORAMT
	set ffA.orcrcd=ORCRCD

	/* 
	   PHLDFIL calls DEPFILE, which update the DEP array.  The problem with
	   this is the next line (AVLDEP^TTXEXT) looks at %A, which has not yet
	   been updated with the PHLD flag indicating that there is a permanent
	   hold on the acount.  So the first time a hold in place on an account
	   through this program, it is not reflected in the new available balance
	  on the account.
	*/

	do ffA.save("/NOVALDD")

	//indicate that there's a hold on the account
	if 'ER set dep.phld=1

	// ***w/o auth ovrdft lim
	set BALAVL=$$AVLDEP^TTXEXT(.dep)

	set BIT(54)=$$^SCARND(BALAVL,,CID,,,,1)*$$EXP(CRCD)

	/*
	   set DAYEND entry to track pre-auth. card holds for matching against
	   transactions and removing
	*/
	type RecordDAYENDCMSHLD dcmsauth=Db.getRecord("DAYENDCMSHLD","TJD=:%SystemDate,CID=:CID,AUTHNUM=:AUTCODE",1)
	set dcmsauth.hldseq=SEQ
	set dcmsauth.hldamt=TAMT
	set dcmsauth.crdnum=CRDNUM
	do dcmsauth.bypassSave()

	quit


CNVAMT(RecordTTX ttx(),RecordDEP dep)	//called from AMTPRE

	if ttx(1).exists()=0 quit 0

	type Number I,TAMT
	type String ACRCD,SVCRCD,TCRCD
	type public String %SystemCurrency
	type public Date %SystemDate

	for I=1,2 do {
		set TCRCD=ttx(I).crcd
		if TCRCD="" set TCRCD=%SystemCurrency

		// Currency Code
		set ACRCD=dep.crcd
		set SVCRCD=ACRCD
		set TAMT=ttx(I).tamt
		if TCRCD'=ACRCD do {
			set TAMT=$$CONV^CRCDUTL(TAMT,ACRCD,TCRCD,1,%SystemDate)

			set ttx(I).tamt=TAMT
			set ttx(I).bseamt=TAMT
			set ttx(I).crcd=ACRCD
			}
		}

	quit TAMT


CNVAMT2(RecordDEP dep,Number AMT,String CRCD)	//

	type public String %SystemCurrency,SVCRCD
	type public Date %SystemDate
	type String ACRCD


	if CRCD="" set CRCD=%SystemCurrency

	// Currency Code
	set ACRCD=dep.crcd
	set SVCRCD=ACRCD
	if AMT="" quit AMT

	if CRCD'=ACRCD set AMT=$$CONV^CRCDUTL(AMT,ACRCD,CRCD,1,%SystemDate)

	quit AMT


	//======================================================================
ATMREV(Number CID,String AUTCODE,String RRC,Number HSEQ,RecordDEP dep)	// Error correct a previous transaction
	/*
	   ARGUMENTS:
	   . CID  Account Number
	   . AUTCODE Authorization Code
	   . RRC  Reason for Reversal Code

	   INPUTS:
	   . AMT2  Amount 2
	  ======================================================================
	*/

	type public String BIT(),CRCD,CRDNUM,CRDTYP,ER,ORCRCD,RM,TLO,TRACE,TSO
	type public Number AAMT1,AAMT3,BALAVL,NEWAMT,ORAMT,ORIGSTAN,PHC,REPAMT,TAMT
	type public Date TPD
	type Number AMT,SEQ,TRAN,TRC,TSEQ
	type String TCRCD

	type RecordDAYENDCMSHLD cmshld

	// Find original transaction, use TSEQ to get original TR's

	set TPD=%SystemDate

	set TRAN=$$FINDH(CID,AUTCODE,.cmshld)

	set TAMT=$$CNVAMT2(.dep,TAMT,CRCD)

	// ******* What if original not found? *******
	if HSEQ do { quit

		// Card reversal message ~p1 already processed
		set RM=$$^MSG(3584,TRACE)

		do EXC(CID,RM)
		}

	if TRAN="" set HSEQ=$$CKPRE(CID,ORIGSTAN.get())
	else  do {
		set SEQ=cmshld.hldseq
		set TAMT=cmshld.hldamt
		}

	if HSEQ do {

		// Card reversal ~p1 matched by original elements. Invalid auth code ~p2
		set RM=$$^MSG(3585,TRACE,AUTCODE)

		do EXC(CID,RM)

		type RecordHIST hist=Db.getRecord("HIST","CID=:CID,TSEQ=:HSEQ",1)
		if hist.getMode() set TRAN=1 set SEQ=hist.trc
		if SEQ="" set TRAN="" set HSEQ=0 quit

		type RecordPHLD phld=Db.getRecord("PHLD","CID=:CID,SEQ=:SEQ",1)
		set TAMT=phld.amt
		}

	if TRAN="",('HSEQ) do { quit

		// Unmatched card reversal message ~p1. Authorization code ~p2.
		set RM=$$^MSG(3586,TRACE,AUTCODE)

		do EXC(CID,RM)
		}

	// Remove the original hold

	if (AAMT3/1=0)!('BIT(6).get()) do {

		// transaction currency
		if BIT(6).exists() set TCRCD=$$CRCD(BIT(4))
		else  set TCRCD=CRCD

		// transaction currency
		set NEWAMT=AAMT1/$$EXP(TCRCD)
		}
	else  do {
		set TCRCD=CRCD
		set NEWAMT=AAMT3/$$EXP(TCRCD)
		}

	if (NEWAMT'="")!(NEWAMT'=0) set NEWAMT=$$CNVAMT2(.dep,NEWAMT,TCRCD)

	do Db.delete("PHLD","CID=:CID AND SEQ=:SEQ","/NOVALDD")

	set ER=0

	// Place hold for the new amount

	//If original amount is different
	if TAMT'=NEWAMT,NEWAMT'=0 do {
		/*
		   from this amount, it's a partial
		   reversal.  Create a new hold for the new
		   amount.
		*/
		set SEQ=1
		type ResultSet rs=Db.select("SEQ","PHLD","CID=:CID","SEQ DESC")
		if rs.next() set SEQ=rs.getCol("SEQ")+1

		type RecordPHLD ffA=Db.getRecord("PHLD","CID=:CID,SEQ=:SEQ",1)
		set ffA.stdt=%SystemDate
		set ffA.amt=NEWAMT
		set ffA.phc=PHC
		set ffA.tlo=TLO
		set ffA.tcmt=TSO
		set ffA.spr=TRACE
		set ffA.crdnum=CRDNUM
		set ffA.crdtyp=CRDTYP
		set ffA.autcode=AUTCODE
		set ffA.oramt=REPAMT
		set ffA.orcrcd=ORCRCD

		do ffA.save("/NOVALDD")
		}

	// ***w/o auth ovrdft lim
	set BALAVL=$$AVLDEP^TTXEXT(.dep)

	set BIT(54)=$$^SCARND(BALAVL,,CID,,,,1)*$$EXP(CRCD)

	quit


	//======================================================================
FINDH(Number CID,String AUTCODE,RecordDAYENDCMSHLD cmshld)
	/* This attempts to match the reversal to the original
	   authorization request using the authorization code.  In the
	   interest of time, it only attempts to match authorizations that
	   were received today.
	  ======================================================================
	*/

	type Date DT,STPDT

	set STPDT=CUVAR.TJD
	set DT=CUVAR.TJD+1

	if (AUTCODE="000000")!(AUTCODE="") quit ""

	type ResultSet rs=Db.select("TJD","DAYENDCMSHLD","TJD<:DT")
	while rs.next() quit:rs.getCol("TJD")<STPDT  do { quit:Db.isDefined("DAYENDCMSHLD","TJD=:DT,CID=:CID,AUTHNUM=:AUTCODE")
		set DT=rs.getCol("TJD")
		}

	set cmshld=Db.getRecord("DAYENDCMSHLD","TJD=:DT,CID=:CID,AUTHNUM=:AUTCODE",1)
	if cmshld.getMode() quit 1
	quit ""


	//======================================================================
LOCK(Number CID,String %LOCK)	//
	/*
	  ======================================================================

	   This sub-routine will incrementally LOCK the account record
	   specified if it is not already contained in %LOCK.  If the
	   lock is successful, %LOCK is updated to include the account
	   number.

	   ARGUMENTS:
	       . CID             Account Number               /TYP=T/REQ
	                                                      /MECH=VAL


	       . %LOCK           Record lock string           /TYP=T/NOREQ
	                                                      /MECH=REFNAM

	   EXAMPLE:
	       I '$$LOCK(123456,.%LOCK) S ER=1,ET="RECLOC" Q

	*/

	type public String ACN()

	set %LOCK=%LOCK.get() if ","_%LOCK_","[(","_CID_",") quit 1

	lock +ACN(CID):2 else  quit 0

	if %LOCK="" set %LOCK=CID quit 1
	set %LOCK=%LOCK_","_CID
	quit 1


	//======================================================================
UNLOCK(String STR,String %LOCK)	//
	/*
	  ======================================================================

	   This sub-routine will decrement the LOCK for the account record(s)
	   specified by the character string 'STR' and remove it from
	   %LOCK (if it is contained in %LOCK).

	   ARGUMENTS:
	       . STR    Account(s) to unlock, comma separated    /TYP=T/REQ
	                                                         /MECH=VAL

	   INPUTS:
	       . %LOCK  Record lock string                       /TYP=T/NOREQ
	                                                         /MECH=REFNAM

	   EXAMPLE:
	       D UNLOCK(%LOCK,.%LOCK)


	*/

	type public String ACN()
	type Number CID,I,J

	set %LOCK=%LOCK.get()

	for I=1:1:STR.length(",") do {
		set CID=STR.piece(",",I) quit:CID=""

		lock -ACN(CID)
		for J=1:1:%LOCK.length(",") if %LOCK.piece(",",J)=CID do { quit
			set %LOCK=%LOCK.piece(",",1,J-1)_","_%LOCK.piece(",",J+1,999)
			}
		}

	if %LOCK.extract(%LOCK.length())="," set %LOCK=%LOCK.extract(1,%LOCK.length()-1)

	quit


	//**********************************************************************
OUTGOING(String OM,String BIT,RecordDEP dep)	//Send outgoing message to the network, OM variable
	/*
	  **********************************************************************

	   ARGUMENTS:
	         . OM    Outgoing message to the SWITCH
	         . BIT   Data element values

	*/

	type public String ER,ET,MID,RC,RM
	type public Number NOER,VLD,VALID

	catch vERROR {
 
                set ET=vERROR.type
                set ER=1
 
                if ET["%GTM-" do ZE^UTLERR quit
                set NOER=0
 
                set ET=ET_"-"_vERROR.thrownAt
                set RM=vERROR.description
 
                do ^UTLERR
                }


	if 'VALID do { quit

		//Invalid transaction
		set RC="30"

		//Format error
		set OM=MID_"0000000002000000"_RC
		do KILL
		}

	if 'VLD set RC="30"
	if 'NOER set RC="96"

	//Network management
	if MID.extract(2)=8 do 800 do KILL quit

	if 'ER,'RC.exists() set RC="00"

	// System malfunction
	if ER,'RC.exists() set RC="96"
	do BLDOM(.dep)

	do KILL

	quit


	//======================================================================
BLDOM(RecordDEP dep)	// Build the outgoing message
	/*
	  ======================================================================
	  I $D(BIT(2)) S BIT(2)="16"_BIT(2)    ;put the length back on
	  Resetting the values of the variable length fields to the original
	  values with the length header
	*/

	type public String BIT(),MID,OM,RC,var()
	type public Number FIELD

	set FIELD=""

	for  set FIELD=var(FIELD).order() quit:FIELD=""  set BIT(FIELD)=var(FIELD)
	set BIT(54)=$$OUTBAL(.dep,BIT(54).get())
	set BIT(39)=RC
	set OM=$$VALIDOUT(MID,.BIT)
	quit


	//======================================================================
VALIDOUT(String mid,String bit)	// Sets up the VALID array for out-going messages
	//======================================================================

	type public String OM,RC
	type public Number pos
	type String OBM,VALID
	type Number I,SBM

	set pos=""

	// Response Code
	if 'RC.exists() set bit(39)="05"
	if mid="0110" set VALID="2,3,4,6,7,10,11,16,20,32,33,37,38,39,41,44,49,51,54,62,100"
	if mid="0130" set VALID="2,3,4,6,7,10,11,16,20,,32,33,37,39,41,44,49,51,54,62"
	if mid="0430" set VALID="2,3,4,6,7,11,16,20,32,33,37,39,44,49,51,54,62,90,95"
	if mid="0810" set VALID="7,11,33,39,70,100"
	set SBM=0

	for I=1:1:VALID.length(",") do {
		set pos=VALID.piece(",",I)
		if bit(pos).data() do {

			// computes hexidecimal bit map values
			do BITARR

			if pos>64 set SBM=1
			set OM=OM.get()_bit(pos)
			}
		}
	// creates out-going bit maps
	do OBM

	set OM=mid_OBM_bit(1).get()_OM
	quit OM


	//======================================================================
BITARR	//  Builds the array for the bitmap values
	//======================================================================

	type Number bmpos
	type public Number pos
	type public String OBM

	set bmpos=((pos-1)\4)+1
	set OBM(bmpos)=OBM(bmpos).get()+$S('(pos#4):1,1:(2**(4-(pos#4))))
	quit


	//======================================================================
OBM	//  Builds the new out-going bitmap based on the bit array
	//======================================================================

	type Number I,POS
	type public String bit(),OBM()
	type public Number SBM

	set POS=""


	for I=2:1:16 do {
		if OBM(I).exists() do {

			// A-F
			if OBM(I)>9 set OBM(I)=$C(OBM(I)+55)
			set OBM=OBM.get()_OBM(I)
			}
		else  set OBM=OBM.get()_0
		}

	if SBM do {
		for I=17:1:32 do {
			if OBM(I).data() do {
				if OBM(I)>9 set OBM(I)=$C(OBM(I)+55)
				set bit(1)=bit(1).get()_OBM(I)
				}
			else  set bit(1)=bit(1).get()_0
			}

		set OBM(1)=OBM(1).get()+8
		if OBM(1)>9 set OBM(1)=$C(OBM(1)+55)
		}
	if 'OBM(1).get() set OBM(1)=0
	set OBM=OBM(1)_OBM.get()
	quit


	//======================================================================
800	// Network Management Transactions
	/*
	  ======================================================================
	   "001" - Sign on
	   "002" - Sign off
	*/

	type public String BIT(),IM,KEYEX,OM,RC
	type public Number CODE,ECHO,TRACE,VLD
	type public Date TMDATE

	set TRACE=BIT(11).get()
	set TMDATE=BIT(7).get()

	// Key Exchange
	set KEYEX=BIT(48).get()

	// Network Control Code
	set CODE=BIT(70).get()

	// Echo flag
	if CODE=301 set ECHO=1 set OM=IM quit

	if 'VLD do OUT800 quit

	if "-001-002-"'[CODE do { quit
		set RC="06"
		do OUT800
		}

	do @CODE
	
	quit

OUT800	// Format 810 messages

	type public String BIT(),FIELD,MID,OM,RC,var()

	set FIELD=""
	for  set FIELD=var(FIELD).order() quit:FIELD=""  set BIT(FIELD)=var(FIELD)
	set BIT(39)=RC.get()
	set OM=$$VALIDOUT(MID,.BIT)

	quit


	//======================================================================
TSGNON	// Teller signon  (needs: TPD,%SystemDate,TLO,BRCD,%UserID,KEY,ENV,%MCP,%SystemCurrency)
	//======================================================================

	type public String %SUBMODE,%SystemCurrency,%UserID,KEY,RC
	type public Number NOPW
	type public Date %EffectiveDate,TPD
	type String ER,ENV,RM 
	type Number CRT

	set %SUBMODE="T"
	set NOPW=1
	set KEY="A"

	set ENV=$$ENVDFT^CRTTOGL(%UserID)

	if 'TPD.exists() set TPD=%SystemDate

	// If posting date is in the past
	if TPD<%SystemDate set %EffectiveDate=TPD set TPD=%SystemDate

	// effective date transactions
	do FILE^SIGNON

	// RC "06" is "Error"
	set RC=$S(ER.get()=1:"06",1:"00")
	quit


	//======================================================================
002	// Teller signoff  (needs: BRCD,TJD,TPD,TLO,UID)
	//======================================================================
	type public String %ATM,%SUBMODE,RC,UID
	type public Number %MCP,NOPW
	type public Date TPD
	type String CRT,ER,RM

	set %SUBMODE="T"
	set NOPW=1
	
	set %ATM=CUVAR.%ATM
        set %ATM=%ATM.piece("|",1)
	set %MCP=CUVAR.%MCP

	type RecordUTBLEXTINT extint=Db.getRecord("UTBLEXTINT","INTRFACE=:%ATM",1)
	set UID=extint.uid
	type RecordSIGNON signon=Db.getRecord("SIGNON","UID=:%UserID")
	if signon.getMode() do {
		type RecordSIGNON signon=Db.getRecord("SIGNON","UID=:UID")
		set TPD=signon.tpd

		do FILEOFF^SIGNON
		}

	// RC "06" is "Error"
	set RC=$S(ER.get()=1:"06",1:"00")
	quit


	//======================================================================
public PM(RecordTTX ttx)	//Signon for PM'ing
	/*
	  ======================================================================
	   Need to address signing on to the next day for PROFILE when we
	   receive the initiate cutoff request from the SWITCH.

	   Signon the ATM teller
	   if signon is successful, set RC="00"

	ARGUMENTS:

	. ttx object for file TTX		/REQ/NONULL/MECH=REF

	*/

	type public String BIT()
	type public Date BCAL,TPD
	type public Number BRCD
	type Number TRC
	type Date SDATE

	set SDATE=$$JD(BIT(15))

	//PM to Switch's settlement date
	set TPD=$$NBD^UNBD(SDATE,1,0,BCAL)

	//Signon
	do TSGNON

	set ttx=Db.getRecord("TTX","TJD=:TPD,BRCD=:BRCD,UID=:%UserID,TSEQ=:TRC",1)

	//Flag record for PM date
	set ttx.tso=SDATE
	do ttx.bypassSave()

	quit


	//===============================================================
OUTBAL(RecordDEP dep, String OUTBAL)	// Sets up BIT(54) for available balance format
	//===============================================================

	type public String ACRCD,CRDNUM,CRDTYP,ER,ET,LNOUTBAL,SGN,SVCRCD
	type public Number CID
	type Number I


	if 'SVCRCD.exists() do {

		// Currency Code
		if dep.exists() set SVCRCD=dep.crcd quit

		if 'CID.exists() do {
			if (CRDTYP.get()="")!(CRDNUM.get()="") set SVCRCD="" quit

			type ResultSet rs=Db.select("CID","CRDGRP","CRDTYP=:CRDTYP AND CRDNUM=:CRDNUM AND GRP='DDA'")
			if rs.next() set CID=rs.getCol("CID")
			if CID="" set SVCRCD=""
			}
		}

	set SVCRCD=$S(SVCRCD.exists():SVCRCD,1:dep.crcd)

	if OUTBAL.get()="" do {
		type String ER

		if 'CID.exists() do {
			if (CRDTYP.get()="")!(CRDNUM.get()="") set OUTBAL=0 quit
			type ResultSet rs=Db.select("CID","CRDGRP","CRDTYP=:CRDTYP AND CRDNUM=:CRDNUM AND GRP='DDA'")
                        if rs.next() set CID=rs.getCol("CID")
			}

		if CID.get()="" set OUTBAL=0 quit

		type RecordDEP dep1=Db.getRecord("DEP","CID=:CID",1)
		if dep1.getMode()=0 set ER=1,ET="RECNOF" do ^UTLERR

		if ER.get()=1 set OUTBAL=0 quit
	
		set OUTBAL=$$AVLDEP^TTXEXT(.dep1)*$$EXP(SVCRCD)
		}

	if OUTBAL<0 set OUTBAL=OUTBAL.extract(2,OUTBAL.length()) set SGN="D"
	else  set SGN="C"

	for I=1:1:(12-OUTBAL.length()) set OUTBAL="0"_OUTBAL

	// set in CNVAMT or CNVAMT2
	set ACRCD=SVCRCD
	set ACRCD=CUVAR.%CRCD
	set ACRCD=$$NCRCD(ACRCD)

	set OUTBAL="0002"_ACRCD_SGN_OUTBAL
	set LNOUTBAL=OUTBAL.length()
	for I=1:1:(3-LNOUTBAL.length()) set LNOUTBAL="0"_LNOUTBAL
	set OUTBAL=LNOUTBAL_OUTBAL
	quit OUTBAL


	//======================================================================
KILL	//Cleanup unused variables
	//======================================================================

	do XKILL^SCADRV0(",%ATM,%MCP,%LOG,%NET,%UserID,%UCLS,BRCD,IIN,RT,STFUCLS,CIO,IIO,OIO,%MODE,OM,vzerror,ECHO")

	quit


	//======================================================================
BITMAP(String rec,String tbl,String bit)	//
	/*
	  ======================================================================
	       DESC:  Translates data stored in 'rec' into individual fields
	              ('bit'(n)), based on the bitmap of fields which are
	              present in the record.  The bit map is a set of ASCII
	              characters representing binary data (e.g., 0="0000",
	              1="0001", ..., F="1111")

	              Returns values of individual fields in 'bit'(n), plus
	              tran code

	      ARGUMENTS:  
		      rec    = record to parse
	              tbl  = field definition array, where
	                        tbl(field)=length|type|description
	              bit = array containing parsed data
	              var = array containing exact value of variable length data

	      OUTPUT: trncd  = transaction

	    CALL BY:  S MID=$$BITMAP^CMS8583(rec,.tbl,.bit)

	*/

	type public String var()
        type public Number B,BMPOS,FIELD,START
        type String BITMAP,FLD,MAP,MID,STR
        type Number BMLEN,END,I

	// Get transaction type
	set MID=rec.extract(1,4)

	// Get primarybitmap
	set BITMAP=rec.extract(5,12)
	set START=13
	set BMLEN=16
	set BITMAP=$$XLATE(BITMAP)

	// Get secondary bit map
	set MAP=$$MAP(BITMAP.extract())

	if (MAP\8)#2 do {
		set BITMAP=$$XLATE(rec.extract(5,20))

		set START=21
		set BMLEN=32
		}

	//Initialize return values array
	kill bit
	kill var
	set BMPOS=0
	set FIELD=1
	do LOOP

	quit


LOOP	//

	type public String bit(),BITMAP,MID,rec,tbl(),var()
	type public Number BMLEN,BMPOS,FIELD,LEN,MAP,START,VAR
	type Number FINISH,I

	set FINISH=0

	for  do { quit:FINISH

		set BMPOS=BMPOS+1 		//Increment postion in bitmap

		//Done, return transaction
		if BMPOS>BMLEN set FINISH=1 quit

		//Get next 4-bit map
		set MAP=$$MAP(BITMAP.extract(BMPOS))

		if 'MAP set FIELD=FIELD+4 quit		//'0000', so skip all

		//Check each bit
		for I=8,4,2,1 do {

			//If no, extract
			if (MAP\I)#2 do {

				set VAR=+tbl(FIELD)
				if VAR do {
					set LEN=rec.extract(START,START+VAR-1)
					set var(FIELD)=rec.extract(START,START+VAR+LEN-1)
					set START=START+VAR
					}
			else  set LEN=tbl(FIELD).piece("|",2)

			set bit(FIELD)=rec.extract(START,START+LEN-1)
			set START=START+LEN
			}

		//Increment field counter
		set FIELD=FIELD+1
		}
	}

	if BMPOS>BMLEN quit MID

	quit


XLATE(String X)	//

	type String BITMAP,BYTE
	type Number I
	
	set BITMAP=""
	for I=1:1:X.length() do {
		set BYTE=X.extract(I)
		set BYTE=$A(BYTE)

		set BYTE=$$DECHEX^%ZHEX(BYTE)

		if BYTE="" set BYTE="0"
		if BYTE.length()=1 set BYTE="0"_BYTE
		set BITMAP=BITMAP_BYTE
		}

	quit BITMAP


RXLATE(String X)	//

	type String A,B,BITMAP,C,Y,Z
	type Number I,START

	set Z=""
	set BITMAP=X.extract(5,20)
	set START=21
	if $$MAP(BITMAP.extract())>7 set BITMAP=X.extract(5,36) set START=37

	for I=1:2:BITMAP.length() do {
		set Y=BITMAP.extract(I,I+1)
		set Y=$$HEXDEC^%ZHEX(Y)
		set Y=$C(Y)
		set Z=Z_Y
		}

	set A=X.extract(1,4)
	set B=X.extract(START,99999)
	set C=A_Z_B
	quit C


MAP(String byte)	// Translate bitmap byte (0-9,A-F) to decimal

	// 1-9
	if byte quit byte

	// 0,A-F
	if 'byte quit $S(byte=0:0,1:$A(byte)-55)

	quit


INITBM(String tbl)	// Initialize table of fields for the Exchange

	/*
	   Call by:  D INITBM^CMS8583(.tbl)
	   Returns:  tbl(field)=length|data_type|description
	*/

	type Number I

	//initialize tbl array
	new I for I=1:1:128 set tbl(I)=""

	set tbl(1)="|0|B|Bit map, extended"
	set tbl(2)="2||N|Primary account number"
	set tbl(3)="|6|N|Processing code"
	set tbl(4)="|12|N|Amount, transaction"
	set tbl(5)="|12|N|Amount, settlement"
	set tbl(6)="|12|N|Amount, cardholder billing"
	set tbl(7)="|10|N|Transmission date and time"
	set tbl(8)="|8|N|Amount, cardholder billing fee"
	set tbl(9)="|8|N|Conversion rate, settlement"
	set tbl(10)="|8|N|Conversion rate, cardholder billing"
	set tbl(11)="|6|N|System trace audit number"
	set tbl(12)="|6|N|Time, local transaction"
	set tbl(13)="|4|N|Date, local transaction"
	set tbl(14)="|4|N|Date, expiration"
	set tbl(15)="|4|N|Date, settlement"
	set tbl(16)="|4|N|Date, conversion"
	set tbl(17)="|4|N|Date capture"
	set tbl(18)="|4|N|Merchant category code"
	set tbl(19)="|3|N|Acquiring institution country code"
	set tbl(20)="|3|N|PAN, country code"
	set tbl(21)="|3|N|Forwarding country code"
	set tbl(22)="|3|N|Point-of-service entry mode"
	set tbl(23)="|3|N|Card sequence number"
	set tbl(24)="||T|Network international identifier"
	set tbl(25)="|2|N|Point-of-service condition code"
	set tbl(26)="|2|N|PIN capture code"
	set tbl(27)="|1|N|Authorization identification response length"
	set tbl(28)="|8|XN|Amount transaction fee"
	set tbl(29)="|8|XN|Amount settlement fee"
	set tbl(30)="|8|XN|Amount transation processing fee"
	set tbl(31)="|8|XN|Amount settlement processing fee"
	set tbl(32)="2|N|Acquirer insitition identification code"
	set tbl(33)="2|N|Forwarding institution identification code"
	set tbl(34)="2||T|Reserved"
	set tbl(35)="2||Z|Track 2 data"
	set tbl(36)="3||Z|Reserved"
	set tbl(37)="|12|T|Retrieval reference number"
	set tbl(38)="|6|T|Authorization identification response"
	set tbl(39)="|2|T|Response code"
	set tbl(40)="|3|T|Service restriction code"
	set tbl(41)="|8|T|Card acceptor terminal identification"
	set tbl(42)="|15|T|Card acceptor identification code"
	set tbl(43)="|40|T|Card acceptor name and location"
	set tbl(44)="2||T|Additional response data"
	set tbl(45)="2||T|Track-1 data"
	set tbl(46)="3||T|Additional data ISO"
	set tbl(47)="3||T|Additional data national"
	set tbl(48)="3||T|Additional data, private"
	set tbl(49)="|3|T|Currency code, transaction"
	set tbl(50)="|3|T|Currency code, settlement"
	set tbl(51)="|3|T|Currency code, customer billing"
	set tbl(52)="|16|B|PIN (personal identification number) data"
	set tbl(53)="|16|T|Security control information"
	set tbl(54)="3||T|Additional amounts"
	set tbl(55)="3||T|Reserved ISO"
	set tbl(56)="3||T|Reserved ISO"
	set tbl(57)="3||N|Reserved national"
	set tbl(58)="3||N|Reserved national"
	set tbl(59)="3||T|Reserved national"
	set tbl(60)="3|12|XN|Reserved private"
	set tbl(61)="3|12|XN|Reserved private"
	set tbl(62)="3|12|XN|Reserved private"
	set tbl(63)="3|12|XN|Reserved private"
	set tbl(64)="|32|B|MAC"
	set tbl(65)="|0|B|Bit map, extended"
	set tbl(66)="|1|N|Reserved"
	set tbl(67)="|2|N|Reserved"
	set tbl(68)="|3|N|Reserved"
	set tbl(69)="|3|N|Reserved"
	set tbl(70)="|3|N|Network management information code"
	set tbl(71)="|4|N|Reserved"
	set tbl(72)="|4|N|Reserved"
	set tbl(73)="|6|N|Reserved"
	set tbl(74)="|10|N|Reserved"
	set tbl(75)="|10|N|Reserved"
	set tbl(76)="|10|N|Reserved"
	set tbl(77)="|10|N|Reserved"
	set tbl(78)="|10|N|Reserved"
	set tbl(79)="|10|N|Reserved"
	set tbl(80)="|10|N|Reserved"
	set tbl(81)="|10|N|Reserved"
	set tbl(82)="|12|N|Reserved"
	set tbl(83)="|12|N|Reserved"
	set tbl(84)="|12|N|Reserved"
	set tbl(85)="|12|N|Reserved"
	set tbl(86)="|16|N|Reserved"
	set tbl(87)="|16|N|Reserved"
	set tbl(88)="|16|N|Reserved"
	set tbl(89)="|16|N|Reserved"
	set tbl(90)="|42|N|Original data elements"
	set tbl(91)="|1|T|Reserved"
	set tbl(92)="|2|T|Reserved"
	set tbl(93)="|5|T|Reserved"
	set tbl(94)="|7|T|Reserved"
	set tbl(95)="|42|T|Replacement amounts"
	set tbl(96)="|16|B|Reserved"
	set tbl(97)="|16|XN|Reserved"
	set tbl(98)="|25|T|Payee"
	set tbl(99)="2||N|Reserved"
	set tbl(100)="2||N|Receiving institution identification code"
	set tbl(101)="2||T|Reserved"
	set tbl(102)="2||T|Account identification 1"
	set tbl(103)="2||T|Account identification 2"
	set tbl(104)="3||T|Reserved"
	set tbl(105)="3||T|Reserved"
	set tbl(106)="3||T|Reserved"
	set tbl(107)="3||T|Reserved"
	set tbl(108)="3||T|Reserved"
	set tbl(109)="3||T|Reserved"
	set tbl(110)="3||T|Reserved"
	set tbl(111)="3||T|Reserved"
	set tbl(112)="3||N|Reserved"
	set tbl(113)="3||N|Reserved"
	set tbl(114)="3||N|Reserved"
	set tbl(115)="3||T|Reserved"
	set tbl(116)="3||T|Reserved"
	set tbl(117)="3||T|Reserved"
	set tbl(118)="3||T|Reserved"
	set tbl(119)="3||T|Reserved"
	set tbl(120)="3||T|Reserved"
	set tbl(121)="3||T|Reserved"
	set tbl(122)="3||T|Reserved"
	set tbl(123)="3||T|Reserved"
	set tbl(124)="3||T|Key management information"
	set tbl(125)="3||T|Reserved"
	set tbl(126)="3||T|Reserved"
	set tbl(127)="3||T|Reserved"
	set tbl(128)="|8|B|MAC"
	quit


EXC(Number CID,String RM)	//

	type String DESC

	// Card messages
	set DESC=$$^MSG(3587)

	do LOG^UTLEXC(%RoutineName,"*",DESC,CID,"",RM)

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60254^31856^Renga SP^55185"	// Signature - LTD^TIME^USER^SIZE
