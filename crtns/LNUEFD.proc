LNUEFD	
	/*
	Loan Utility to Unwind Account Activity

	DESC: This procedure "unwinds" account history and scheduled activity
	      back to a particular date and/or project through a date. This 
	      facilitates the unwind (reverse) / reapply process used for 
	      backdated loan transaction processing (including loan renewals).
	      LNUEFD flag, local to this procedure, is set to ensure that
	      we only unwind account's activity once. This is controlled by
	      a check in LNPTSR procedure that prevents executing LNPTSRV
	      procedure that would attempt to unwind and reapply history of
	      transactions for the same account again.

	------ Revision History -----------------------------------------------

	01/10/07 - KELLYP - CR 24826
		   Modified the RUNBIL and RUNSCHND sections to quit before 
		   unwinding bills and scheduled date rolls.  

	12/07/06 - KELLYP - CR 24438
		   Modified the REVPOFF section to prevent an UNDEFINED error
		   that occurs on the BRCD variable when late charges are due
		   on the account and are reversed out by MRPC003/LNTCP for
		   payment amount calculations.

	12/04/06 - DHANALAKSHMI R - CR 21407
		   Modified the section PROCFM to use DBTBL1D instead of 
		   the Table DBTBL11 and also added a condition to make sure 
		   that only the non-computed columns of LN and DEP records are 
		   getting updated.

	11/30/06 - SANTHUMS - CR 24210
		   Modified REAPPLY section to determine if "LNFEE" exists in 
		   the TSO field.  If it does, and if it's value exists in the 
		   LNFEEP table and the DEFINC flag is enabled, the REAPPLY 
		   function will quit with 1. This is required since deferred 
		   fee amortization transactions need to be reapplied 
		   during the unwind/reapply process to prevent OOB errors. 
		
	11/13/06 - KELLYP - CR 23888
		   Modified REVPOFF to pass BRCD instead of ln.boo to TRNDRV
		   when posting reversals.  This prevents false out-of-balance
		   errors from being reported for payoff reversals when ln.boo
		   is not the same as the branch the reversal is posted from.

	10/20/06 - KELLYP - CR 19960
		   Modified RUNBIL to delete LNBILTOL records corresponding to
		   LNBIL1 records that are being deleted.  If the bills are
		   being deleted, then the payment tolerance due on a bill
		   is no longer valid and needs to be recalculated (by LNPTS3
		   in the case of reapplying payments).
	
	10/13/06 - SmithCD - CR 23395
		   Modified REVPOFF to pass appropriate parameters to TRNSINGL 
		   tag of TRNDRV when reversing a payoff (or error correct), 
		   in which case the primary transaction is being reversed 
		   here instead of ^LNPTSRV. Moved "Intervening transactions 
		   are being reversed and reposted" override to REVPOFF 
		   section to prevent it from being set on an error correct / 
		   reversal when there are no other transactions being 
		   reversed.

	09/19/06 - SANTHUMS - CR21183
		   Modified HISTTRN section so the system should reverse 
		   payoffs trnsactions.  Added quit with 0 if hist.tseq
		   matches with REVSEQ and if Close Acct and Prohibit Further 
		   Proc(trn.pcfl5) is true. 
	
	09/18/06 - KELLYP - CR 23117
		   Modified the EXEC section to pass the primary ttx object 
		   instead of the ttx1 array to the END section.  Prevents
		   an UNDEFINED error on ttx in POSTADJ^LNPTS12.
	
	08/30/06 - KELLYP - CR 22443
		   Modified HISTTRN so the system would not attempt to reverse
		   the transaction represented by REVSEQ.  The system was 
		   previously reversing the REVSEQ transaction as part of the
		   unwind process, then reapplying it, then reversing it back
		   out again.
	
	06/14/06 - TITOVE - CR 21765
		   Modified EXEC to set new LNUEFD flag and correct setting
		   of REVPOCLO flag. Added check on existence of ttx object to 
		   SETHIST, when setting LNTRV override. It does not apply when
		   called by other than transaction processing, such as RPC 
		   calls, as they do not expect any overrides to be returned.

	05/23/06 - SmithCD - CR 19732
	  	   Modified SECPCFD5 and SETHIST section to properly select 
	  	   HISTLST records using DEP instead of TRN (HISTLST.ETC is 
	  	   null for escrow HISTLST records, so no records could ever 
	  	   be selected).
	
	05/15/06 - TITOVE - CR 19671
		   Modified SETHIST section by adding the LNTRV restriction.
		   It was originally set in LNPTSRV, but relied on TR array
		   that is no longer in use.

	05/12/06 - KELLYP - CR 21249
		   Modified RUNBIL section to correctly determine LN.BSEQ after
		   deleting bill records that occur after the effective date.
	
	04/27/06 - SmithCD - CR 20965
		   Removed local scoping of ER in PROCFM section, and 
		   modified it to handle deposit account file maintenance.
		   Added consideration of minacr and minopt in DEPACR / 
		   LNACR sections to prevent accrual on balances less than the 
		   minimum (prevents possible "Accrued amount exceeds Int/Div" 
		   errors).

	04/11/06 - TITOVE - CR 20348
		   Modified HISTTRN to reverse Special Event type of fee
		   (such as a booking fee), in case the primary transaction
		   is the fee transaction being reversed via Teller, also
		   replaced references to TSEQ with hist.tseq, for clarity.

	03/15/06 - SANTHUMS - CR 19983
		   When Scheduled last date is less than the Date of Note,
		   Scheduled last date and Scheduled next date are set with 
		   same value in RUNSCHND section.Hence division by zero 
		   error is displayed when loan disbursement is done.
		   So changes are done in RUNSCHND section to change the 
		   value of scheduled last date as Date of Note.
		 
	03/07/06 - chhabris - CR19806
		   Modified RUNHIST, PROCTRN and subpmt section to make TAMT
		   as public.
	
	03/02/06 - TITOVE - CR 19733
		   Modified SETFEE and RUNFEE sections to instantiate an LNFEEP
		   object with a "create-if-needed" qualifier.

	02/09/06 - SmithCD - CR 19505
		   Modified check on ttx.exists() near top of EXEC section to 
		   make sure ttx.etc is defined before loading the transaction 
		   code from disk. Removed ttx1(,,) parameter from PRELCHG 
		   call to EXEC (was causing an undefined error).

	02/06/06 - TITOVE - CR 18449
		   Modified HISTTRN not to reverse a booking fee.

	02/03/06 - KELLYP - CR 19343
		   Modified EXEC section to plus (+) REVSEQ.  This prevents a
		   "not all variables bound" error when the transaction being
		   processed is the original backdated transaction (e.g., for a
		   backdated disbursement).  This error would occur in the 
		   SECPCFD5 section because REVSEQ was equal to "" but was used
		   in a WHERE clause for a numeric column.  Also modified 
		   SETHIST section to pass TSEQ instead of HSEQ in a WHERE clause
		   (HSEQ was undefined).
	
	01/30/06 - SmithCD - CR 19343 (16890)
		   Integrated escrow account processing into the unwind 
		   process, and low balance accrual recalculation capability 
		   (related changes made to UANTIC*). Changes include:
		   . Added EVENTD and related sections EVENTE, SETIPF, SETHISTD,
		     SETSRV, RUNLBCM, RUNLBCP, RUNINTPD, RUNSRV and DEPACR for
		     new deposit account events, including low balance 
		     processing
		   . Brought in SECPCFD5 section
     		   . Created UNWIND and EVNTEXEC sections and moved applicable
		     sections of code into it to improve modularity and allow 
		     for multiple account handling
		   . Modified ACRADJ argument to the EXEC section to be a
		     reference array to enable eventual accrual adjustments
		     in ESCADJ^UANTIC
		   . Changed key structure of ttx1(,) to have account number 
		     as the second key to handle multiple accounts
		   . Changed key structure of QUEUE(EVNTJD,EVNTSQ) to
		     QUEUE(EVNTJD,CID,EVNTSQ) to accommodate multiple accounts
		   . ACRDT modified to be an array keyed by CID
		   . Removed "INT#" check from "REAPPLY" list
		   General changes not directly related to escrow integration:
		   . Modified RUNHIST to reset to base transaction amount 
		     after reversing the transaction (the full TAMT will be 
		     rebuilt when the transaction is reapplied)
		   . Corrected select from hist in SETHIST section to include 
		     transactions that do not have hist.efd defined, and to 
		     set ttx1.efd to ttx1.tjd if null in case the current 
		     system date is not equal to ttx1.tjd (ttx1.efd is then 
		     reset to the system date)
		   . Remove check on hist.tamt.int in HISTTRN section so loan 
		     transactions for escrow accrual adjustments are not 
		     reversed (hist.tamt.int is only set on the escrow tran 
		     in this case, not the loan tran)
		   . Removed call to LNPDT^LNPTSR, which is no longer needed 
		     in p04 (this will ultimately be called by the subsequent 
		     call to TRNSINGL^TRNDRV)
		   . Modified SETFEE to set up QUEUE entries for loan fee plan 
		     frequency dates (new section runfee) instead of handling 
		     it all in SETFEE (allows for more correct accruals by 
		     breaking up accruals dates just as UANTIC does)
		   . Corrected RUNHIST section that removes a ttx1() entry if 
		     system-generated and the transaction will not be 
		     reapplied (was formerly checking itc of transaction 
		     instead of tso, causing entries to be deleted that should 
		     not have)
		   . Added SETEOM and RUNEOM sections to handle end-of-month
		     chores (done mainly to keep QUEUE(,,) in balance with 
		     reapply)
		   . Added logic to make daily interest rate changes more 
		     efficient for both loans and deposits (escrow)
		   . Renamed lowercase sections to uppercase to conform to 
		     standards
	  
	   08/15/05 - CARROLLJ - CR16928
		      . Modified runhist section to copy ttxunwind object 
			to ttxoffst object to handle backdated disbursements 
			with fees.

	   05/31/05 - SmithCD - CR 15902
	   	      . Modified runbil section to prevent undefined SCHSEQ
	   	      . Removed trn parameter from subpmt section (not needed 
	   	        b/c ETC is reset in the section, and should be using 
	   	        trn for that ETC instead)
	   	      . Moved processing that only applies when ETC is defined 
	   	        to new function HISTTRN to fix null subscript error
	   	      . Modified HISTTRN to use ttxtran object instead of 
	   	        ttx(,) when checking for intervening transactions
	   	      . Added REAPPLY function
	   	      . Modified EVNTPGM section to pass ttx(,) by reference 
	   	        to fix undefined error
	   	      . Changed SETCUS section to store the correct data in 
	   	        LCHGNOT() (was using rs instead of rs1)
	   	      . Added $translate that was missing in runhist section, 
	   	        which had caused a "if argument always false" 
	   	        informational compilation error
	   	      . Modified the parameters passed to runhist2 (trn 
	   	        removed, and ttx(,) changed to ttx - fixes issues 
	   	        with changes to ttx for reversals getting into 
	   	        reapplied transactions in UANTIC)
	   	      . Renamed runhist2 to PROCTRN and runhist3 to PROCFM
	   	      . Replaced remaining references to HSEQ with TSEQ in 
	   	        runhist* sections to prevent undefined error on HSEQ
	   	      . Consolidated kills of ttx(,) to the end of the while 
	   	        loop in section runhist to prevent undefined errors on 
	   	        ttx(,)
	   	      . Replaced RUNPMT^UANTICLN calls with TRNSINGL^TRNDRV 
	   	        calls in REVPOFF section so actual transaction from 
	   	        history gets reversed (RUNPMT^UANTICLN was building a 
	   	        different transaction)
	   	      . Corrected parameters passed to EXEC for call in 
	   	        PRELCHG section
		      . Removed use of EFDDI in section runhist3 so the oldest
			value is correctly used for each day
		      . Removed occurrences of lnsysgen variable, which are no 
		        longer needed
	   	      . Removed ADJACR(CID) reference from ACRCALC section
      	   	      . Added EFD and REVTRN to where clause in setefd section 
      	   	        to prevent unnecessary collation
	   	      . Removed extra (unnecessary) Db.getRecord on hist from 
	   	        sethist section
	   	      . Removed old revision history

	*/

	quit


public	EXEC(RecordLN ln, 	  	// Loan record		  	/REF:RW
	     RecordTTX ttx1(,,),   	// Transaction set from history	/NOREQ/REF:W
	     RecordTTX ttx,   		// Primary transaction	  	/NOREQ/REF:R
	     Date %EffectiveDate, 	// Effective date
	     String CTL,	  	// Control flags	  	/NOREQ
	     Number ACRADJ(,),	  	// Accrual adjustments tracker	/NOREQ/REF:W
	     String STATS,	  	// Historical Statistics  	/NOREQ/REF:RW
	     RecordDEP dep())		// Escrow accounts	  	/NOREQ/REF:RW

	/*

	Unwind account back to effective date

	   Additional notes on ARGUMENTS:

	       . STATS

	   Input as the withdrawal period beginning date, this value
	   is used to calculate the withdrawal amount within a selected
	   period. It is used by MRPC080 (Deceased/Disabled Customer
	   account Calculations)

	   Returned as a tab delimited string containing the following:
		Payments after effective date
		Payments before effective date
		Reversals and error corrections after effective date
		Withdrawals after effective date
		Withdrawals within date period

	*/
	
	type public Cache %CACHE()
	type public Boolean ER
	
	type Date ACRDT(), JD, TPD
	type String CUVAR2, LCADCNOT(), POSTDT(), QUEUE(,,), SAVEFD
	type Number BALCMP, CID, IRN, LCHGADJ = 0, REVSEQ
	type Boolean DAILYFRE(,), LNUEFD = 1, REVPOCLO = 0

	// Skip commitments
	if ln.cpf quit
	
	set CTL = CTL.get()

	if ttx.exists(), 'ttx.etc.isNull() do {
		// Save reversal sequence
		set REVSEQ = +$$FIELD^UTSO(ttx.tso, "REV")
		
		// Save reversal of payoff / closeout indicator
		type RecordTRN trnpri = %CACHE("TRN").getRecord("TRN", "ETC=:ttx.etc")
		if trnpri.pcfl5 ! ($$SECPCFD5(trnpri.pcfl5, REVSEQ, ln.cid)) set REVPOCLO = 1
		}
	else  set REVSEQ = 0
	
	set CUVAR2 = %SystemDate
	if %EffectiveDate.isNull() set %EffectiveDate = CUVAR2
	set SAVEFD = %EffectiveDate

	// Effective date cannot be prior to Date of Note
	if %EffectiveDate < ln.dtnt set %EffectiveDate = ln.dtnt

	do EVENTL(.ln, .ttx1(,,), .ttx, %EffectiveDate) quit:ER
	do EVENTE(.ln, .dep(), .ttx1(,,), .ttx) quit:ER

	do UNWIND(.ln, .ttx1(,,), .ttx, .ACRDT(), .QUEUE(,,), .dep()) quit:ER
	
	// This is needed to post late charges if any
	do END(.ln, .ttx, CUVAR2)
	
	quit


UNWIND(RecordLN ln,		// Loan record			/REF:RW
       RecordTTX ttx1(,,),	// Transaction set		/REF:RW
       RecordTTX ttx,		// Primary transaction		/REF:R
       Date ACRDT(),		// Accrual date			/REF:RW
       String QUEUE(,,),	// Event queue			/REF:RW
       RecordDEP dep())		// Escrow accounts		/REF:RW

	// Execute QUEUE(,,) going backward

	type public Boolean ER
	type public Date CUVAR2
	type public Number ACRADJ(,)
	
	type String EVENT
	type Number CID, EVNTSQ
	type Date EVNTJD

	set (CID, EVNTJD, EVNTSQ) = ""
	
	for  set EVNTJD = QUEUE(EVNTJD).order(-1) quit:EVNTJD.isNull()  do { quit:ER
		for  set CID = QUEUE(EVNTJD, CID).order(-1) quit:CID.isNull()  do { quit:ER
			for  set EVNTSQ = QUEUE(EVNTJD, CID, EVNTSQ).order(-1) quit:EVNTSQ.isNull()  do { quit:ER
				
				// Re-define acn so POST^LNTRB picks up the acn
				// object corresponding to the correct account 
				if CID = ln.cid do EVNTEXEC(.ln, .ttx, .ttx1(,,), .QUEUE(,,), EVNTJD, EVNTSQ)
				if CID '= ln.cid do EVNTEXEC(.dep(CID), .ttx, .ttx1(,,), .QUEUE(,,), EVNTJD, EVNTSQ)
				}
			}
		}

	if ER quit
       
	quit


EVNTEXEC(RecordACN acn, 	// Account			/REF:RW
	 RecordTTX ttx,		// Primary transaction		/REF:RW
	 RecordTTX ttx1(,,),	// Transaction set		/REF:RW
	 String QUEUE(,,),	// Event queue			/REF:R
	 Date EVNTJD,		// Event date
	 Number EVNTSQ)		// Event sequence
	 
	type public Number ACRADJ(), CID
	type public Date ACRDT()
	type public Boolean ER
	type public String RM
		
	type String EVENT
	 
	if EVNTSQ '= 9999 do {
		set EVENT = QUEUE(EVNTJD, acn.cid, EVNTSQ)
		do EVNTPGM(.acn, .ttx1(,,), .ttx, EVNTJD)
		}
	else  do ACRCALC(.acn, .ttx, .ACRDT(), .ACRADJ(,))
				
	// Report detailed error message - Reversed (unwind)
	if ER set RM = CID_" "_EVNTJD.toString()_" - "_$$^MSG(846)_" "_EVENT.piece("|",1)_": "_RM.get() quit
		
	// Maintain QUEUE(,,)as we go to keep the array
	// as small as possible
	kill QUEUE(EVNTJD, CID, EVNTSQ)

	quit


EVNTPGM(RecordACN acn,		// Account record		/REF:RW
	RecordTTX ttx1(,,),	// Transaction set		/REF:RW
	RecordTTX ttx,		// Primary transaction		/REF:R
	Date %SystemDate)	// System date

	/*
	
	Run a single event

	     Each application called (billing, schedule date roll, etc)
	     expects TJD to be the projected system date.

	*/
	
	type public String EVENT
	type public Number CID
	
	type String EVNTNAME
	
	set EVNTNAME = EVENT.piece("|", 2)

	if EVNTNAME.isNull() quit
	
	// Uncomment for trouble-shooting statistics (do not remove)
	//write !,"Unwind "_$select(acn.cls = "L":"LN ", 1:"DEP ")_CID_": "_EVNTNAME_"("_EVENT.piece("|", 3)_") "_EVENT.piece("|", 1)_" on "_%SystemDate.toString()

	// Events common to both loan and deposit accounts
	if EVNTNAME = "RUNHIST" do RUNHIST(.acn, .ttx1(,,), .ttx) quit
	if EVNTNAME = "RUNICHND" do RUNICHND(.acn) quit	

	if acn.cls = "L" do {
		// Loan-specific events
		if EVNTNAME = "RUNBIL" do RUNBIL(.acn) quit
		if EVNTNAME = "RUNFEE" do RUNFEE(EVENT.piece("|", 3)) quit
		if EVNTNAME = "RUNSCHND" do RUNSCHND(.acn) quit
		if EVNTNAME = "RUNPCHND" do RUNPCHND(.acn) quit
		if EVNTNAME = "RUNICAP" do RUNICAP(.acn) quit
		if EVNTNAME = "RUNIDGP" do RUNIDGP(.acn) quit
		if EVNTNAME = "RUNLCHG" do RUNLCHG quit
		if EVNTNAME = "RUNEOM" do RUNEOM(.acn) quit
		}
	else  do {
		// Deposit-specific events
		if EVNTNAME = "RUNSRV" do RUNSRV(.acn, EVENT.piece("|", 3)) quit
		if EVNTNAME = "RUNINTPD" do RUNINTPD(.acn, EVENT.piece("|", 3)) quit
		}

	quit


END(RecordLN ln,		// Loan record			/REF:RW
    RecordTTX ttx,		// Transaction			/REF:R
    Date %SystemDate)		// Current date

	type public Boolean ER
	type public Number LCHGADJ

	// Quit if no late charges
	quit:'LCHGADJ

	// Late Charge Adjustment
	type Date %EffectiveDate

	set LCHGADJ = LCHGADJ.roundCur(ln.crcd)

	if LCHGADJ do POSTADJ^LNPTS12(.ln, .ttx, LCHGADJ) quit:ER

	set LCHGADJ = 0

	quit


ACRCALC(RecordACN acn,		// Account record		/REF:RW
	RecordTTX ttx,		// Primary transaction		/NOREQ/REF:R
	Date ACRDT(),		// Accrual date			/REF:RW
	Number ACRADJ(,))	// Accrual adjustments tracker	/REF:RW

	// Calculate accrued interest from ACRDT+1 through EVNTJD
	
	type public Boolean DAILYFRE(,), ER
	type public Date EVNTJD

	type Date ACRLD, ACRND

	set ACRND = ACRDT(acn.cid) - 1
	set ACRLD = EVNTJD
	set ACRDT(acn.cid) = ACRLD
	
	// If daily freq, bump the dates using enddate (ACRLD)
	if 'acn.index.isNull(), DAILYFRE(acn.cid, 0) do {
		set acn.ichnd = ACRLD - 1
		set acn.ichld = ACRLD
		}
	
	if acn.cls = "L" do LNACR(.acn, ACRLD, ACRND, .ttx) quit

	do DEPACR(.acn, ACRLD, ACRND) quit:ER
	
	quit
	

LNACR(RecordLN ln,		// Loan account				/REF:RW
      Date ACRLD,		// Interest accrual last date
      Date ACRND,		// Interest accrual next date
      RecordTTX ttx)		// Primary transaction
      
	type public Boolean ER
	type public Date EVNTJD
	type public Number ACRADJ(,)

	type Number ACRAMT, IRN
		
	if ln.trexd > EVNTJD set IRN = ln.trate
	else  set IRN = ln.irn
	
	if 'ln.minacr.isNull(), (ln.balint < ln.minacr) do {
 		if (ln.minopt <> 0) set ACRAMT = 0		// Keep accrual
		else  set ACRAMT = -ln.acr			// Zero accrual
                }
	if ln.balint set ACRAMT = $$^UIC(ln.balint, ACRLD, ACRND, ln.iacm, IRN, 0, ln.dist1af, ln.dist1fre, ln.icpf, ln.schnd, ln.schld) quit:ER
	else  set ACRAMT = 0

	set ACRAMT = ACRAMT.roundDec(5)

	set ACRADJ(ln.cid, "ACR") = ACRADJ(ln.cid, "ACR") - ACRAMT
	set ln.acr = ln.acr - ACRAMT
	
	// Uncomment for trouble-shooting statistics (do not remove)
	//write !,"Unwind LN "_ln.cid_": LNACR Accrue "_ln.balint_" at "_IRN_"% "_ACRND.toString()_"-"_ACRLD.toString()_" = "_(-ACRAMT)
	//write !,$char(9)_"(ln.acr = "_ln.acr_")"
			
	if ln.dlcaf do DLYLATE(.ln, .ttx, EVNTJD)
	
	quit


DLYLATE(RecordLN ln, 		// Loan account			/REF:RW
	RecordTTX ttx,		// Pimary transaction		/REF:R
	Date %SystemDate)	// Current date

	// Recalculate daily Late Charges
	
	type public Boolean ER
	type public Date LCADCNOT(), ACRLD, ACRND
	type public Number CID, LCHGADJ
	
	type Number LCHRG

	/*
	If this is the LCAD, see if the loan is delinquent from the previous
	bill.  If not, turn off the daily accrual flag.  This will stop
	the late charges from accruing after this date (in reverse) and will
	allow the "catch up" to be calculated in BCHLNLATE if necessary.
	*/
	if %SystemDate = ln.lcad do {
		type ResultSet rs = Db.select("SCHSEQ,CASD", "LNBIL1", "CID=:CID AND SCHSEQ<=:ln.bseq", "SCHSEQ DESC")
		
		while rs.next() do {
			if rs.getCol("CASD") '> 0 set ln.dlcaf = 0

			/*
			set up next LCAD in reverse if LCHGNOTO
			Late Charge Action Date
			*/
			if ln.lchgnoto set ln.lcad = LCADCNOT(ln.lcad).order(-1)
			}
		}
		
	set LCHRG = $$EXTERN^BCHLNLAT(.ln, .ttx, CID, ACRND, ACRLD, 1) quit:ER

	set LCHGADJ = LCHGADJ - LCHRG

	// Uncomment for trouble-shooting statistics (do not remove)
	//write !,"Unwind LN "_ln.cid_": DLYLATE Daily late charge "_ACRND.toString()_"-"_ACRLD.toString()_" = "_(-LCHRG.roundDec(5))

	// ACRADJ section will post the necessary offsetting transactions for 
	// the full late charge amount

	quit


SETHIST(RecordLN ln,		// Loan record			/REF:RW
	RecordTTX ttx1(,,),	// Transaction set		/REF:W
	RecordTTX ttx)		// Primary transaction		/REF:R

	// Set-up for backing out history entries

	type public RecordDEP dep()
	type public Number BRCD, REVSEQ
	type public String OVR(,,), QUEUE(,,), STATS
	type public Boolean ER
	type public Date CUVAR2, SAVEFD
	
	type literal String TAB = $char(9)
	
	type String EFDHIT(), ETC, EVNT, TCMT, TSO
	type Date HEFD
	type Number CID, PA, PB, RA, TAMT, TSEQ, WA, WW
	
	set CID = ln.cid

	// Allow for LCGADJ transactions
	if 'REVSEQ set %EffectiveDate = %EffectiveDate - 1
	
	set (PA, PB, RA, WA, WW) = 0
	
	set EVNT = "Reverse History Entries|RUNHIST"

	type DbSet ds = Db.selectDbSet("HIST", "CID=:CID AND TJD>=:%EffectiveDate AND (EFD IS NULL OR (EFD>0 AND EFD>=:%EffectiveDate)) AND REVTRN=0", "TSEQ DESC")

	while ds.next() do { quit:ER
		type RecordHIST hist = ds.getRecord("HIST")

		set TCMT = hist.tcmt
				
		// Ignore simple notes, such as "SET UP NEW ACCOUNT"
		// (must contain a : to be a true file maintenance)
		if hist.fm, 'TCMT.isLike("%:%") quit
		
		set TSEQ = hist.tseq
		
		/*
		Do not reverse FM for ODD or DTNT to prevent
		error message during backdated disbursement
		*/
		if (TCMT.isLike("%[LN]DTNT%")) ! (TCMT.isLike("%[LN]ODD%")) quit

		// Do not unwind changes to Currency Code, General Ledger Set 
		// Code, Product Type and/or Cost Center
		if TCMT.isLike("%CRCD%") quit
		if TCMT.isLike("%[LN]ACR%") quit
		if TCMT.isLike("%[LN]GLSC%") quit
		if TCMT.isLike("%[LN]TYPE%") quit
		if TCMT.isLike("%[LN]CC%") quit

		set TSO = hist.tso

		/*
		Quit if secondary. Secondary transactions will be reversed
		by the originating transaction.
		*/
		if hist.itc7 = 1, ('TSO.isLike("%LCHGADJ%")) quit

		set HEFD = hist.efd
		if HEFD.isNull() set HEFD = hist.tjd
		
		// Future-dated file maintenance will be processed on its 
		// effective date
		if HEFD > hist.tjd quit

		/*
		Late charges on the effective date should not be unwound
		if they involve problem loan sub-account reclassification
		*/
		if (HEFD '> SAVEFD) & ((TSO.isLike("%CRNLC%")) ! (TSO.isLike("%NALC%")) ! (TSO.isLike("%COLC%"))) quit

		set ETC = hist.etc
		set TAMT = +hist.tamt
	
		if 'ETC.isNull(), $$HISTTRN(.hist, .ln, .ttx) quit

		// Note: compiler can't handle the spaces on this line
		set ttx1(HEFD,CID,TSEQ) = hist.copy("TIM=TIME,BRCDE=BRCD,UIDT=UID,LNERC=XHS16,CC=BEN")

		if ttx1(HEFD, CID, TSEQ).efd.isNull() set ttx1(HEFD, CID, TSEQ).efd = ttx1(HEFD, CID, TSEQ).tjd

		set ttx1(HEFD, CID, TSEQ).tjd = %SystemDate
		set ttx1(HEFD, CID, TSEQ).brcd = BRCD.get()
		set ttx1(HEFD, CID, TSEQ).uid = %UserID
		set ttx1(HEFD, CID, TSEQ).tseq = ""

		/* 
		System-generated transactions are always unwound (reversed),
		but only those specified with REAPPLY will be reapplied; the
		others will be re-generated by UANTIC
	        */
		if $$REAPPLY(ETC, TCMT, TSO, hist.itc7) do {
			set TSO = $$FIELDIN^UTSO(TSO, "REAPPLY", 1)
			set ttx1(HEFD, CID, TSEQ).tso = TSO
			}

		// Set RUNHIST event into QUEUE(,,) only if not already set 
		// for this date
		if 'EFDHIT(HEFD).exists() do {
			do SETQUE("", HEFD, "", "", EVNT) 
			set EFDHIT(HEFD) = ""
			}
		
		/*
		If lower level of history indicates an associated escrow
		account was hit via a secondary transaction, set escrow
		accrual event (the secondary transaction to the escrow
		account will be rebuilt upon reprocessing the primary
		transaction to the loan account)
		*/

		if HEFD = CUVAR2 quit

		type ResultSet rs = Db.select("ACT", "HISTLST,DEP", "HISTLST.CID=:CID AND SLN=:TSEQ AND HISTLST.ACT=DEP.CID AND DEP.GRP='ESC'")
		
		// Set escrow accrual event on/after entry (going forward)
		while rs.next() do {
			type Number ESCCID = rs.getCol("ACT")
			
			// Escrow not involved in this calculation
			if 'dep(ESCCID).exists() quit
			
			set QUEUE(HEFD, ESCCID, 9999) = "Calculate accruals"
			}
		}

	// Reset from top
	if 'REVSEQ set %EffectiveDate = %EffectiveDate + 1

	set STATS = PA_TAB_PB_TAB_(-RA)_TAB_WA_TAB_WW
	
	quit
	
	
HISTTRN(RecordHIST hist,	// History record		/REF:R
	RecordLN ln, 		// Loan record			/REF:R
	RecordTTX ttx)		// Primary transaction		/REF:RW

	// Process non-file-maintenance history transaction, and return quit 
	// indicator

	type public Cache %CACHE()
	type public Boolean ER
	type public String STATS, ETC, TSO
	type public Number CID, PA, PB, RA, REVSEQ, TAMT, WA, WW
	type public Date HEFD, SAVEFD
	
	type Date WPEFD
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")
		
	// Quit if system-generated accrual adjustment
	if TSO.isLike("%SGAA#1%") quit 1

	set WPEFD = STATS.get()

	// E/C or Reversal
	if hist.itc12 ! (hist.itc6) do { quit 1
		if (hist.itc7 '= 2), (hist.itc1 = ln.trb), 'Db.isDefined("HISTR", "CID=:CID,TSEQ=:hist.tseq"), (HEFD '< %EffectiveDate) set RA = RA + TAMT set PA = PA + (-TAMT)
		}

	if hist.itc1 = ln.trb do {
		if (HEFD < %EffectiveDate) set PB = PB + TAMT
		else  set PA = PA + TAMT
		}

	if hist.itc1 '= ln.trb do {
		if (HEFD > %EffectiveDate), (hist.prin + hist.whld), trn.pcfl4 set WA = WA + TAMT
		if 'WPEFD.isNull(), (HEFD '< WPEFD), (HEFD '> %EffectiveDate) set WW = WW + TAMT
		}

	// Include transaction on the effective date if there are late charges and 
	// also other loan fees if transaction has been reversed
	if ('REVSEQ) & (HEFD '> SAVEFD) & ('TSO.isLike("%LCHGADJ%")) & ('TSO.isLike("%LNFEE%")) quit 1

	// Unwind back the "effective date", not "processing date"
	if (HEFD < %EffectiveDate) quit 1

	// 21183 - Changed to quit with 0 when TSEQ=REVSEQ
	if REVSEQ, (hist.tseq=REVSEQ), trn.pcfl5 quit 0
		
	// If reversing reverse all fees for that day. They will be reapplied.
	// PK 22443 - Changed to quit when TSEQ<=REVSEQ, no need to reverse/reapply ttx being reversed
	if REVSEQ, (hist.tseq '> REVSEQ), 'TSO.isLike("%LNFEEIN%") quit 1

	// Reverse Special Event type of fee (such as a booking fee) on a Date of Note
	// unless one of the following two conditions is true:
	
	// 1. Primary transaction is not a reversal
	if 'REVSEQ, TSO.isLike("%LNFEEIN%"), (HEFD = ln.dtnt) quit 1
	
	// 2. Reversal transaction is not a fee transaction being reversed via Teller
	if (hist.tseq < REVSEQ), TSO.isLike("%LNFEEIN%"), (HEFD = ln.dtnt) quit 1

	/*
	If the posted transaction is a payoff then payments within the 
	effective dated period need to be manually reversed
	*/
	
	// Reverse intervening transactions first
	if (hist.itc7 '= 1), 'REVSEQ.get(), hist.itc, ttx.exists(), trn.pcfl5, 'TSO.isLike("%LCHGADJ%") do Runtime.setErrMSG("HIST", 856) quit 1
	
	quit 0
	

REAPPLY(String ETC,		// External transaction code
	String TCMT,		// Teller comment
	String TSO,		// Teller source
	Number ITC7)		// Secondary transaction indicator

	// Reapply non-system generated financial transactions that have not 
	// already been eliminated from unwind process
	
	type Boolean GETOUT
	type String FEETYP,UTSO
	if 'ETC.isNull(), ITC7 '= 2 quit 1
	
	if ITC7 '= 2 quit 0
	
	// System Generated
			
	// Auto Disbursement
	if TCMT.isLike("%"_$$^MSG("4045")_"%") quit 1

	// External Transfer
	if $$FIELD^UTSO(TSO, "EXTTRF") quit 1

	set GETOUT=0
	
	if TSO.isLike("%LNFEE%") do { quit:GETOUT 1
		do OUT^UTSO(.UTSO,TSO)
		set FEETYP = UTSO("LNFEE").get().piece(":",1)
		if FEETYP.isNull() quit
		type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP=:FEETYP")
		if 'lnfeep.getMode() quit
		if lnfeep.DEFINC set GETOUT=1
		}
	
		// Funds Transfer
	if TSO.isLike("%EFT#%") quit 1

	// Identify the problem loan sub-account
	if TSO.isLike("%NA%") quit 1
	if TSO.isLike("%CRN%") quit 1
	if TSO.isLike("%COF%") quit 1
	if TSO.isLike("%COP%") quit 1
	if TSO.isLike("%COLC%") quit 1
	if TSO.isLike("%COI%") quit 1

	quit 0
	

EVENTL(RecordLN ln,		// Loan record			/REF:RW
       RecordTTX ttx1(,,),	// Transaction set		/REF:W
       RecordTTX ttx,		// Primary transaction		/REF:R
       Date %EffectiveDate)	// Effective date

	// Set up QUEUE(,,) for loan events within the effective period

	type public Boolean ER
	type public Number ACRADJ(), BALCMP, IRN, REVSEQ
	type public Date ACRDT(), CUVAR2, SAVEFD
	type public String QUEUE(,,)
	
	type Number CID = ln.cid

	set BALCMP = ln.bal

	// If it is a loan, determine how much of the balance is undisbursed
	if ln.aruf set BALCMP = BALCMP - ln.udbal
	
	// Accrued-thru date
	set ACRDT(ln.cid) = %SystemDate

	// Get the interest rate (could be a teaser rate)
	if ln.trexd > (ACRDT(ln.cid) + 1) set IRN = ln.trate
	else  set IRN = ln.irn

	// Accrued thru-date
	set ACRADJ(CID, "ACR") = 0
	
	if 'REVSEQ set %EffectiveDate = %EffectiveDate + 1
	
	do SETMT(.ln) quit:ER
	do SETICAP(.ln) quit:ER
	do SETDECAP(.ln) quit:ER
	do SETFEE quit:ER
	do SETHIST(.ln, .ttx1(,,), .ttx) quit:ER
	do SETEOM(.ln) quit:ER
	
	// Set final accrual event on the primary transaction effective date
	if SAVEFD '= CUVAR2 set QUEUE(SAVEFD, CID, 9999) = "Calculate accruals"
	
	quit
	
	
SETMT(RecordLN ln)		// Loan record			/REF:RW

	type public Boolean ER
	type public Date CUVAR2, SAVEFD

	if ln.dist1fre.isNull() ! (SAVEFD = CUVAR2) quit
	
	type String EVNT
	
	// Set up custom notice entries for late charge processing
	if ln.lchgnoto do SETCUS(.ln) quit:ER

	set EVNT = "Billing|RUNBIL"
	if ln.bloff = "1P" do SETQUE(ln.dist1fre, ln.bldt, 0, 1, EVNT) quit:ER
	if ln.bloff' = "1P" do SETQUE(ln.dist1fre, (ln.bldt + ln.bloff), ln.bloff, 1, EVNT) quit:ER

	set EVNT = "Scheduled Date Roll|RUNSCHND"
	do SETQUE(ln.dist1fre, ln.schld, 0, 0, EVNT)

	do SETICHND(.ln, ln.intoff) quit:ER

	set EVNT = "Payment Change Date|RUNPCHND"
	if ln.pchld > ln.dtnt, 'ln.pcfre.isNull() do SETQUE(ln.pcfre, ln.pchld, 0, 0, EVNT) quit:ER
		
	quit


SETCUS(RecordLN ln)

	// Set up LCADCNOT array for custom notices that triggered late charges

	type public Date CUVAR2, LCADCNOT(), LCHGNOT()

	type String CUSTNOT
	type Date LCAD
	
	type ResultSet rs = Db.select("LCAD", "LNLCNOT", "CID=:CID")
	
	while rs.next() do { quit:(LCAD < CUVAR2) ! (LCAD.isNull())
		set LCAD = rs.getCol("LCAD")
		set LCADCNOT(LCAD) = ""

		// Late Charge Action Date
		set ln.lcad = LCAD
		}

	// Also set up LCHGNOT array
	set CUSTNOT = ln.custnot

	quit:'CUSTNOT
	quit:LCHGNOT(CUSTNOT).exists()
	
	type ResultSet rs1 = Db.select("MINNOTBA,LCGRDNOT", "UTBLCUSNOT", "NOTICE=:CUSTNOT AND LCGRDNOT IS NOT NULL")
	
	if rs1.next() set LCHGNOT(CUSTNOT) = rs1.getRow().toString()

	quit


SETICAP(RecordLN ln)	// Set up queue if interest is being capitalized

	//  Check to see if interest is to be capitalized
	if 'ln.icap quit

	//  Check to see if it is capitalized on a frequency
	if ln.iropt'=2 quit

	// Deferred Interest Resolution Frequency

	// Deferred Interest Last Resolution Date
	do SETQUE(ln.dirfre, ln.dirld, 0, 0, "Capitalize Interest Due|RUNICAP")

	do setidgp(%EffectiveDate)

	quit


SETDECAP(RecordLN ln)	// Set up queue if interest is being capitalized

	type public Number REVSEQ

	type String EVNT

	// Check to see if interest is to be capitalized
	if 'ln.dxsi quit
	if ln.iropt '= 2 quit

	// Deferred Interest Resolution Frequency

	set EVNT = "Capitalize Interest Due|RUNICAP"
	if 'REVSEQ set %EffectiveDate = %EffectiveDate - 1
	do SETQUE(ln.dirfre, ln.dirld, 0, 0, EVNT) 
	if 'REVSEQ set %EffectiveDate = %EffectiveDate + 1

	quit


SETFEE	// Reapply frequency based loan fee

	// Determine [LNFEE]ASND to find starting point
	
	type public Boolean ER
	type public Number CID
	
	type DbSet ds = Db.selectDbSet("LNFEE", "CID=:CID AND ASND>0")

	while ds.next() do { quit:ER
		
		type RecordLNFEE lnfee = ds.getRecord("LNFEE")
		
		type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP = :lnfee.feetyp", 1)

		// Must be frequency based
		if lnfeep.cfre.isNull() quit
		
		do SETQUE(lnfeep.cfre, lnfee.asnd, 0, 0, "Loan Fees|RUNFEE|"_lnfee.feetyp)
		}

	quit


SETQUE(String FRE,		// Frequency of event			/NOREQ
       Date NJD,		// Projected date
       Number OFF,		// Billing date offset			/NOREQ
       Boolean PLUS1,		// Offset				/NOREQ
       String EVNT,		// Event data
       Boolean LBC)		// Low balance calculation control	/NOREQ

	// Set the processing queue
	
	type public Boolean ER, DONE
	type public String QUEUE(,,)
	type public Number CID

	type Date EVNTJD

	if 'NJD quit

	set OFF = OFF.get()
	set PLUS1 = PLUS1.get()
	set LBC = LBC.get()

	set DONE = 0
	for  do { quit:ER ! (DONE)
		set EVNTJD = NJD - OFF + PLUS1

		// Beyond effective date - stop
		if EVNTJD < %EffectiveDate set DONE = 1 quit
		
		do SETEVENT(CID, EVNT, EVNTJD, .QUEUE(,,))
		
		// Single event
		if FRE.isNull() set DONE = 1 quit
		
		// Multiple events
		if LBC.isNull() set NJD = NJD.nextFreqDate(FRE, , 1) quit:ER
		else  set NJD = $$NXDT^UANTICDP(NJD, FRE, LBC, 1) quit:ER
		}

	quit
	
	
SETEVENT(Number CID,		// Account number
	 String EVNT,		// Event data
	 Date EVNTJD,		// Event date
	 String QUEUE(,,))	// Event queue				/REF:RW

	// Set a single event and an accompanying accrual event
	
	type public String POSTDT()
	type public Date CUVAR2
	
	type Number PRVQSQ

	// Get previous non-acrual sequence
	set PRVQSQ = QUEUE(EVNTJD, CID, 9999).order(-1)

	// Set new entry in QUEUE(,,)
	set QUEUE(EVNTJD, CID, PRVQSQ + 1) = EVNT

	if EVNTJD < %SystemDate, EVNTJD '< %EffectiveDate set QUEUE(EVNTJD, CID, 9999) = "Calculate accruals"
	
        #IF CUVAR.IPD
        	// Set to accrue for Include Posting Date
		if EVNT.piece("|", 2) = "RUNINTPD" do {
			set POSTDT(EVNTJD) = ""
			set QUEUE((EVNTJD - 1), CID, 9999) = "Calculate accruals"
			}
	#ENDIF
        
	quit


RUNBIL(RecordLN ln)	// Reset account for prior bill date

	type public Number CID
	type public Boolean ER
	type public String QUEUE(,,)
	type public Date CUVAR2, SAVEFD

	type Date LCAD, NJD, PJD

	/*
	 If we're unwinding to a date that falls between the date the
	 bill was actually generated (LN.BLDT + 1) and the payment due
	 date (LN.BLDT + LN.BLOFF) then the bill represented by LN.BLDT
	 should not be unwound.  That bill would have existed on EFD.
	*/
	if (EFD > ln.bldt),(EFD '> (ln.bldt + ln.bloff)) quit

	// No bill records to process
	type DbSet ds = Db.selectDbSet("LNBIL1", "CID=:CID","SCHSEQ ASC")
	if ds.isEmpty() quit
	
	// Billing - Last Date
	if ln.bloff '= "1P", (ln.bldt + ln.bloff) < ln.dfp quit

	set NJD = ln.bldt
	if ln.bloff '= "1P" set NJD = NJD + ln.bloff
	
	set NJD = NJD.nextFreqDate(ln.dist1fre, , 1) quit:ER
	set PJD = NJD

	if ln.bloff '= "1P" set NJD = NJD - ln.bloff

	// Reset next / last billing dates
	set ln.bndt = ln.bldt
	set ln.bldt = NJD

	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0", "CID=:CID")

	// Reset BSEQ	
	while ds.next() do { quit:ER
		type RecordLNBIL1 lnbil1 = ds.getRecord("LNBIL1")
	
		// Ignore if Amount Still Owe different from Total Amount 
		// Billed (partially paid pills)
		if lnbil1.casd <> lnbil1.ctab quit
		
		// Does bill cutoff date indicate advance bill?
		if lnbil1.cbcd > NJD do { quit:ER
			// If interest not capitalized do lump
			if ln.iropt < 2 do LUMP(.lnbil1, .lnbil0) quit:ER

			// Otherwise, delete advance bill
			do Db.fastDelete("LNBIL1", "CID=:CID, SCHSEQ=:lnbil1.schseq")
			
			// Delete any pmt tolerance records associated with this bill
			do Db.fastDelete("LNBILTOL", "CID=:CID, SCHSEQ=:lnbil1.schseq")
			}
		}
	
	do lnbil0.bypassSave()

	// Billing - Last Sequence Number
	type ResultSet rs=Db.select("SCHSEQ","LNBIL1","CID=:CID","SCHSEQ DESC")
	if rs.next() set ln.bseq=rs.getCol("SCHSEQ")
	else  set ln.bseq=""

	// Reset the rest of the guys
	do CALC^LNUBIL(.ln, "01001") quit:ER

	// Entries for LCAD set up in SETCUS if LCHGNOTO = 1
	quit:ln.lchgnoto

	// Do not recalculate LCAD for the last bill
	if 'Db.isDefined("LNBIL1", "CID=:CID,SCHSEQ=1") set ln.lcad = "" quit

	// Late Charge Calculation Method
	if ln.popt.isNull() quit

	set LCAD = $$PERIOD^LNU(PJD, ln.pmtgrc, ln.dist1fre) quit:ER
	if LCAD '< CUVAR2 quit

	set ln.lcad = LCAD
	quit:LCAD '> SAVEFD

	do SETQUE("", LCAD, 0, 0, "Late Charge Processing|RUNLCHG")
	if QUEUE(LCAD, CID, 9999).get().isNull() set QUEUE(LCAD, CID, 9999) = "Calculate accruals|"

	quit
	
	
RUNFEE(String FEETYP)	// Reset loan fee plan for prior frequency date

	type public Boolean ER
	type public Date SAVEFD
	type public Number CID

	type Date NJD
	
	type RecordLNFEE lnfee = Db.getRecord("LNFEE", "CID=:CID,FEETYP=:FEETYP")
	
	type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP = :FEETYP", 1)

	set NJD = lnfee.asnd.nextFreqDate(lnfeep.cfre, , 1) quit:ER ! (NJD < SAVEFD)
	
	set lnfee.asnd = NJD
		
	do lnfee.bypassSave()
	
	quit


RUNHIST(RecordLN ln,		// Loan record			/REF:RW
	RecordTTX ttx1(,,),	// Transaction set		/REF:RW
	RecordTTX ttxpri)	// Primary transaction		/REF:R
	
	// Reverse history entry

	type public Date EVNTJD
	type public Boolean ER
	type public Number CID, REVSEQ
	type public Cache %CACHE()

	type Date HEFD2
	type Number ITC7, TSEQ
	type Boolean NOFF
	type String ETC, OFFST
	
	set TSEQ = ""
	for  set TSEQ = ttx1(EVNTJD, CID, TSEQ).order(-1) quit:TSEQ.isNull()  do { quit:ER
		set ITC7 = ttx1(EVNTJD, CID,TSEQ).itc7
		set NOFF = 0

		if $translate(ttx1(EVNTJD, CID, TSEQ).tamt, "#0") do {
			type String ITC, TAMT, TSO, TSO1(), UTSO()

			set TSO = ttx1(EVNTJD, CID, TSEQ).tso
			do OUT^UTSO(.UTSO(), TSO)
			
			set ETC = ttx1(EVNTJD, CID ,TSEQ).etc
			
			// Protect unwind transaction set from being tainted 
			// by PROCTRN
			type RecordTTX ttxunwind = ttx1(EVNTJD, CID, TSEQ).copy()
			
			do PROCTRN(.ln, .ttxunwind, .ttxpri) quit:ER
			
			// Reset to base transaction amount (the full TAMT 
			// will be rebuilt when the transaction is reapplied)
			set ttx1(EVNTJD, CID, TSEQ).tamt = ttx1(EVNTJD, CID, TSEQ).tamt
			
			do OUT^UTSO(.TSO1(), TSO)
			set OFFST = UTSO("OFFST").get()
			if 'UTSO("SUBPMT").get().isNull() do subpmt(.ln, .ttx1(EVNTJD, CID, TSEQ))

			// Quit if no offset or NOFF flag is set
			if OFFST.isNull() ! (NOFF) quit
			
			type Number CID
			type String ETC

			// Protect offset transaction set from being tainted 
			// by PROCTRN
			type RecordTTX ttxoffst = ttxunwind.copy()
			
			set CID = OFFST.piece(":", 2)
			set ETC = OFFST.piece(":", 1)
			set ttxoffst.tamt = -ttxoffst.tamt

			set ttxoffst.cid = CID			
			set ttxoffst.etc = ETC
			
			type RecordTRN trnoffst = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")
			
			set ITC = $$ITC^TTXEXT(trnoffst.itc, 7, ITC7) quit:ER
			set ttxoffst.itc = ITC
					
			do PROCTRN(.ln, .ttxoffst, .ttxpri)
			}
		else  do PROCFM(.ln, .ttx1(EVNTJD, CID, TSEQ))
		
		if ER quit

		// If system-generated and the transaction will not be 
		// reapplied, kill entry; UANTIC will generate a new one
		if ITC7.get(), '$$FIELD^UTSO(ttx1(EVNTJD, CID, TSEQ).tso, "REAPPLY") kill ttx1(EVNTJD, CID, TSEQ)
		
		// If this is the primary transaction being reversed, kill 
		// entry so it doesn't get reprocessed going forward
		if REVSEQ = TSEQ kill ttx1(EVNTJD, CID, TSEQ)
		}

	quit


PROCTRN(RecordLN ln,		// Loan record			/REF:RW
	RecordTTX ttx,		// Transaction			/REF:RW
	RecordTTX ttxpri)	// Primary transaction		/REF:R

	// Reverse transaction
	
	type public Number CID, TSEQ
	type public Boolean ER, NOFF
	type public Date EVNTJD
	type public String ETC, TAMT, TSO, TSO1()
	type public Cache %CACHE()

	type Boolean CDF
	type String ITC
	type Number POS, SEQ, TAMTLEN, UTSO()
	
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")

	set ITC = ttx.itc

	// Dont set up for offsetting transactions
	if ln.cid = CID, 'ln.popt.isNull() do {
		type ResultSet rs = Db.select("CDF", "LNPOPT", "GRP=:ln.grp AND POPT=:ln.popt")

		if rs.next() set CDF = rs.getCol("CDF")
		else  set CDF = ""
		}

	/*
	DONT reverse if Late Charge accrues daily -- this will be
	taken care of via the LATE section of ACRCALC
	*/
	if CDF.get(), ttx.tso.isLike("%LCHGADJ%") set NOFF = 1 quit

	set ITC = $$ITC^TTXEXT(ITC, 12, 1) quit:ER
	set ttx.itc = ITC
	
	set TAMT = ttx.tamt
	set TAMTLEN = TAMT.length("#")
	for POS = 1:1:TAMTLEN if TAMT.piece("#", POS) set TAMT.piece("#", POS) = -TAMT.piece("#", POS)
	set ttx.tamt = TAMT

	if ln.cid = CID do {
		set TSO = $$FIELDIN^UTSO(TSO, "REV", TSEQ)
		set ttx.tso = TSO
		}
	else  do { quit:ER
		// Offset transaction to G/L Account
		type Boolean DONE = 0
		type Number HTAMT
		type String TSO2

		if (trn.cls.isNull() ! (trn.cls = "M")) quit

		set HTAMT = TAMT * (-1)
		
		type ResultSet rs2 = Db.select("TSO,TSEQ", "HIST", "CID=:CID AND EFD=:%SystemDate AND ETC=:ETC AND TAMT=:HTAMT", "TSEQ DESC")
		
		// No valid history transactions on file for reversal
		if rs2.isEmpty() do Runtime.setErrMSG("HIST", 2000) quit
		
		while rs2.next() do { quit:DONE
			do OUT^UTSO(.TSO2(), rs2.getCol("TSO"))
			if TSO1("AUTPMT").get() = 1, TSO2("AUTPMT").get().isNull() quit
			
			do OUT^UTSO(.UTSO, ttx.tso)
			set UTSO("REV") = rs2.getCol("TSEQ")
			do IN^UTSO(.UTSO, .TSO)
			set ttx.tso = TSO set DONE = 1
			}
		}

	do REVPOFF(.ln, .ttx, .trn, .ttxpri)
	
	quit


REVPOFF(RecordLN ln,		// Loan record			/REF:RW
	RecordTTX ttx,		// Transaction			/REF:RW
	RecordTRN trn,		// Transaction code record	/REF:R
	RecordTTX ttxpri)	// Primary transaction		/REF:R

	/*
	If it is a reversal and it is a primary and primary is a payoff
	process it here not in LNPTSRV
	*/
	
	type public Boolean CDF, ER, REVPOCLO
	type public Number BALCMP, BRCD, CID, EVNTSQ, ITC7, REVSEQ, TSEQ
	type public Date EVNTJD
	type public String LCHGNOT()

	if REVSEQ = TSEQ do { quit:ER
		/*
		If this is the primary transaction and is being reversed, 
		don't process here (process in LNPTSRV as normal) UNLESS it
		is the reversal of a payoff / closeout transaction (in which 
		case RUNHIST will remove it from ttx1(,,)). This is necessary
		because all other transactions for the effective date are 
		reversed here, and CLSD^TRNDRV may otherwise return an error 
		due to the account status indicating the account is closed.
		*/
		if 'REVPOCLO quit
		
		type String PRETRN()
		set PRETRN("BALCMP") = BALCMP
		
		if BRCD.get().isNull() set BRCD = CUVAR.BOBR
		
		do TRNSINGL^TRNDRV(.ttxpri, .ln, ttxpri.tjd, BRCD, ttxpri.getStoredValue("TranMode"), .RJ(), .SPV(), .OVR(,,), PTRC, ttxpri.getStoredValue("TranSeq"), .OM()) quit:ER
		}
	else  do {
		/*
		  This restriction originally was set in LNPTSRV, after the call to
		  BACKWARD^LNRENEW. It relied on the presence of TR array that would
		  contain all transactions, including those built by LNUEFD. Since
		  this logic is no longer in use, it made sense to move the restriction
		  to this location. It only applies to financial transactions that are
		  being reversed/reapplied, not to file maintenance history entries.
		  It does not apply when called by other than transaction processing,
		  such as RPC calls, as they do not expect any overrides to be returned.
		*/
		// Intervening transactions are being reversed and reposted
		if ttxpri.exists(), $translate(ttx.tamt, "#0") set OVR(ln.cid, "OVR", "LNTRV") = ""
		
		if BRCD.get().isNull() set BRCD = CUVAR.BOBR
		
		do TRNSINGL^TRNDRV(.ttx, .ln, EVNTJD, BRCD, 4) quit:ER
		}

	// Don't continue for offsetting transactions
	if ln.cid '= CID quit

	// Check if the account is delinquent and set CDF
	if (ln.lcad.isNull()) ! (%SystemDate < ln.lcad) quit

	type Date CASD
	type Number OSEQ = ln.oseq

	type ResultSet bilrs = Db.select("CASD", "LNBIL1", "CID=:CID AND SCHSEQ=:OSEQ")

	if bilrs.next() set CASD = bilrs.getCol("CASD")
	else  quit

	if 'ln.lchgnoto, CASD > 0 set ln.dlcaf = CDF.get()

	/*
	If late charges are based on notices, must make sure due amount on
	bill is greater than MINNOTBA
	*/
	if ln.lchgnoto do {
		// Custom Notice Production
		type String CUSTNOT = ln.custnot
		quit:CUSTNOT.isNull()
		
		if 'LCHGNOT(CUSTNOT).exists() do {
			type ResultSet cusrs = Db.select("MINNOTBA,LCGRDNOT", "UTBLCUSNOT", "NOTICE=:CUSTNOT AND LCGRDNOT IS NOT NULL")

			if cusrs.next() set LCHGNOT(CUSTNOT) = cusrs.getRow().toString()
			}
			
		if CASD > LCHGNOT(CUSTNOT).piece("|", 11) set ln.dlcaf = CDF
		}

	quit


PROCFM(RecordLN ln,		// Loan account			/REF:RW
       RecordTTX ttx)		// Transaction			/REF:R

	// Reverse file maintenance

	type public Boolean ER
	type public RecordDEP dep()
	type public Number CID

	type String DI, FID, FMREC, OV

	set FMREC = ttx.tcmt.piece(":", 1)
	set FMREC = FMREC.piece("[", 2) if FMREC.isNull() quit
	set FMREC = "["_FMREC
	
	set FID = FMREC.piece("]", 1).extract(2, 99)
	set DI = FMREC.piece("]", 2, 99)
	
	// Translate all lower case alpha to UPPER CASE
	set FID = FID.upperCase()
	set DI = DI.upperCase()
	
	// Check if the table exists
	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:FID", 1)
	if dbtbl1.getMode() = 0 quit
	
	if FID '= "LN", FID '= "ZLN", FID '= "DEP", FID '= "ZDEP", FID '= "ACN" quit
	
	// File new data into account, if DI exists
	type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=:FID,DI=:DI", 1)
	if dbtbl1d.getMode() = 0 quit
	
	// Get new value from the TMCT
	set FMREC = ttx.tcmt.piece(":", 2, 3)
	set OV = FMREC.piece(":", 1)
	
	if FID = "LN" ! (FID = "ZLN") !  (FID = "ACN" & (CID = ln.cid)) do {

		// Update only non computed columns
		if dbtbl1d.cmp.isNull() set ln.@DI = OV
			
		/*
		Update balance for interest calculations when credit 
		limit is adjusted and Capitalized Deferred Interest 
		flag set to 1
		*/
	
		type RecordUTBLICPA icpa = Db.getRecord("UTBLICPA", "KEY=:ln.icpa")

		if DI = "CRLMT", icpa.pc10 do {
			if ln.bal < ln.crlmt set ln.balint = ln.bal
			else  set ln.balint = ln.crlmt
			}
		}
	else  if FID = "DEP" ! (FID = "ZDEP") !  (FID = "ACN" & (CID '= ln.cid)) do {

		// Update only non computed columns
		if dbtbl1d.cmp.isNull() set dep(CID).@DI = OV
		}

	quit


RUNSCHND(RecordLN ln)		// Loan account			/REF:RW

	// Reset account for prior scheduled date
	
	type public Boolean ER

	type Number SCHBAL

	quit:ln.schld '> ln.amodt

	/*
	 If we're unwinding to a date that falls on a scheduled date
	 roll for this loan, the scheduled date roll should not be 
	 unwound.  The scheduled date roll would have occurred in the 
	 BOD portion of the dayend that rolled into EFD.  The account
	 should be left in a state reflecting that after the unwind
	 process is completed.
	*/
	if EFD = ln.schld quit

	set ln.schnd = ln.schld

	set ln.schld = ln.schld.nextFreqDate(ln.dist1fre, , 1) quit:ER

	//Don't allow SCHLD to be set prior to DTNT (use SCHND in this case)
	if ln.schld < ln.dtnt set ln.schld = ln.dtnt

	// Don't allow SCHND to be set prior to DFP
	if ln.schnd < ln.dfp set ln.schnd = ln.dfp

	// Scheduled Internal Bill Sequence Number
	if 'ln.schseq quit

	set ln.schseq = ln.schseq - 1

	// Scheduled Payment Number
	set ln.schnum = ln.schnum - 1

	/*
	Reset SCHBAL.  Calculate interest for the period, subtract this
	amount from PMTPI and increase SCHBAL by this amount.
	*/

	// Principal and Interest Payment
	if ln.pmtpi, (ln.schbal > 0) do {
		set SCHBAL = $$PVI^UFINC(ln.pmtpi, ln.irn, 1, ln.schbal, ln.schnd, ln.iacm, ln.dist1fre, ln.iacm, ln.dist1af, "") quit:ER
		set SCHBAL = SCHBAL.roundCur(ln.crcd)
		set ln.schbal = SCHBAL
		}

	// Reset the rest of the guys
	do CALC^LNUBIL(.ln, "01001") quit:ER

	quit


RUNICHND(RecordACN acn)		// Deposit / loan account		/REF:RW

	// Reset account for prior interest date

	type public Boolean ER
	
	type Date ACTLIMDT

	if acn.intfre.isNull() quit

	set acn.ichnd = acn.ichld

	set acn.ichld = acn.ichld.nextFreqDate(acn.intfre, , 1) quit:ER
	
	if acn.cls = "L" do {
		type RecordLN ln = {RecordLN}acn
		set ACTLIMDT = ln.dtnt
		}
	else  do {
		type RecordDEP dep = {RecordDEP}acn
		set ACTLIMDT = dep.odt
		}

	// Don't allow ICHLD to be set prior to Date of Note / Opening Date
	if acn.ichld < ACTLIMDT set acn.ichld = ACTLIMDT
	if acn.ichnd '> ACTLIMDT set acn.ichnd = ACTLIMDT.nextFreqDate(acn.intfre) quit:ER

	quit


RUNPCHND(RecordLN ln)		// Loan account			/REF:RW

	// Reset account for prior payment date

	type public Boolean ER

	// Reset PCHND
	set ln.pchnd = ln.pchld

	// Reset PCHLD
	set ln.pchld = ln.pchld.nextFreqDate(ln.pcfre, , 1) quit:ER

	quit


RUNICAP(RecordLN ln)		// Loan account			/REF:RW

	// Reset account for prior capitalization date
	
	type public Boolean ER

	type Date DIRLD

	// Reset next capitalization date, to previous date
	set ln.dirnd = ln.dirld

	// Reset last capitalization back 1 frequency
	set DIRLD = ln.dirld.nextFreqDate(ln.dirfre, , 1) quit:ER

	set ln.dirld = DIRLD
	
	quit


subpmt(RecordLN ln,		// Loan account			/REF:RW
       RecordTTX ttx)		// Transaction			/REF:RW
       
	// Credit agency income

	type public Cache %CACHE()
	type public Boolean ER
	type public String TAMT

	type Number CID
	type String ETC, GLSC
	type Date %EffectiveDate = ""

	// Debit offset

	set GLSC = ln.glsc
	type RecordUTBLLNSUB lnsub = Db.getRecord("UTBLLNSUB", "SUBPLN=:ln.subpln")
	
	set ETC = lnsub.gltrn
	if ETC.isNull() set ETC = "MDR"
	
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")
	
	set CID = lnsub.glcid
	set ttx.cid = lnsub.glcid
	set ttx.itc = $$ITC^TTXEXT(trn.itc, 7, 2) quit:ER
	set ttx.etc = ETC
	set ttx.tamt = +TAMT

	do PROCTRN(.ln, .ttx)

	set CID = lnsub.glinc
	if CID.isNull() quit
	
	set ETC = lnsub.glinctrn
	if ETC.isNull() set ETC = "MCR"
	
	type RecordTRN trn1 = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")
	
	set ttx.cid = CID
	set ttx.itc = $$ITC^TTXEXT(trn1.itc, 7, 2) quit:ER
	set ttx.etc = ETC
	set ttx.tamt = +TAMT

	do PROCTRN(.ln,.ttx)

	// Interest income account

	type RecordUTBLGLSC glsc = Db.getRecord("UTBLGLSC", "GLSC=:GLSC")
	
	set ttx.cid = glsc.lgli
	
	set ETC = "MDR"
	type RecordTRN trn2 = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")
	
	set ttx.itc = $$ITC^TTXEXT(trn2.itc, 7, 2) quit:ER
	set ttx.etc = ETC
	set ttx.tamt = +TAMT

	do PROCTRN(.ln,.ttx)

	quit


RUNLCHG	// Late Charge Processing

	quit


public PRELCHG(RecordLN ln,		// Loan account			/REF:RW
	       RecordTTX ttx)		// Transaction			/REF:RW

	// Calculate default late charge amount that can be paid

	type public Date CUVAR2 = %SystemDate

	type String ITC, ETC, LCHGNOT
	type Number SEQ

	do EXEC(.ln, , .ttx, %EffectiveDate)

	quit ln.lchg


setidgp(Date %EffectiveDate)

	// Set up queue entries for recalculating BALINT

	type public Number REVSEQ

	type Date EXPDT
	type String EVNT = "Free Interest Period Processing|RUNIDGP"

	if 'REVSEQ set %EffectiveDate = %EffectiveDate - 1
	
	type ResultSet rs = Db.select("EXPDT", "LNDS1", "CID=:CID")

	while rs.next() do {
		set EXPDT = rs.getCol("EXPDT")

		if EXPDT < %EffectiveDate quit

		if EXPDT > (%SystemDate - 1) quit
		
		do SETQUE("", EXPDT + 1, 0, 0, EVNT)
		}
		
	quit


RUNIDGP(RecordLN ln)	// Recalculate BALINT

	/*
	INPUTS:
	 
		. ln    Loan object		/TYP=RecordLN/REQ/MECH=REF
	*/

	type Date JD = %SystemDate-1
	
	type ResultSet rs = Db.select("SDA,REPYMT", "LNDS1", "CID=:CID AND EXPDT=:JD")

	if rs.next() set ln.balint = ln.balint - rs.getCol("SDA") - rs.getCol("REPYMT")
	
	quit


LUMP(RecordLNBIL1 lnbil1, RecordLNBIL0 lnbil0)

	//Find prepaid items and set into lnbil0

	type public Boolean ER
	
	type literal String TAB = $char(9)

	type String BIL1, DATA, ROW
	type Number LUMP, PC

	set ROW = $$ELEMENT^BILFUNCS(.lnbil0) quit:ER
	for PC = 1:1:20 quit:ROW.piece(TAB, PC).isNull()  do { quit:ER
		set BIL1 = $$SUB^BILFUNCS(PC, .lnbil1) quit:ER
		set LUMP = BIL1.piece("#", 5) if LUMP do {
			set DATA = ROW.piece(TAB, PC)
			set DATA.piece("#", 5) = DATA.piece("#", 5) + LUMP
			do SETBIL0^BILFUNCS(.lnbil0, PC, DATA) quit:ER
			}
		}

	quit
	
	
EVENTE(RecordLN ln,		// Loan account			/REF:RW
       RecordDEP dep(),		// Deposit accounts		/REF:RW
       RecordTTX ttx1(,,),	// Transaction set		/REF:W
       RecordTTX ttx)		// Primary transaction		/REF:R

	// Set up QUEUE(,,) for escrow events within the effective period
	
	type public Boolean ER
	
	type Number CID = ""

	// Process escrow accounts linked to this loan
	for CID = dep(CID).order() quit:CID.isNull()  do EVENTD(.dep(CID), .ttx1(,,), .ttx) quit:ER
	
	quit
	
	
EVENTD(RecordDEP dep,		// Deposit account		/REF:R
       RecordTTX ttx1(,,),	// Transaction set		/REF:W
       RecordTTX ttx)		// Primary transaction		/REF:R
       
	// Set up deposit QUEUE(,,) events to be unwound (processed in reverse)

	type public Date ACRDT(), CUVAR2, SAVEFD
	type public Number ACRADJ(,), CID
	type public String QUEUE(,,)
	type public Boolean ER

	// Accrued-thru date
	set ACRDT(CID) = %SystemDate

	// Save original accrual amounts
	set ACRADJ(CID, "POSACR") = dep.posacr
	set ACRADJ(CID, "NEGACR") = dep.negacr
	set ACRADJ(CID, "NEGACRUN") = dep.negacrun
	set ACRADJ(CID, "UNCACR") = dep.uncacr

	// Set service charge entries
	do SETSRV(.dep, 0) quit:ER			// Service Fee Plan
	do SETSRV(.dep, 1) quit:ER			// Usage Credit Plan

	// Set other entries
	do SETHISTD(dep.cid, .ttx1(,,), .ttx, 1) quit:ER	// History
	do SETIPF(.dep) quit:ER				// Interest Posting
	do SETICHND(.dep, "") quit:ER			// Interest change
		
	// Set final accrual event on the primary transaction effective date
	if SAVEFD '= CUVAR2 set QUEUE(SAVEFD, CID, 9999) = "Calculate accruals"

	quit
	
	
SETSRV(RecordDEP dep,		// Deposit account		/REF:R
       Boolean PLTP)		// Posting control

	/*
	Set up QUEUE(,,) events for reversing Service Fee charge dates
	and Usage Credit Plans charge dates

	Additional notes on ARGUMENTS:
		. PLTP
			0 - Service Fee Plan
			1 - Usage Credit Plan
	*/
	
	type public String QUEUE(,,)

	if 'PLTP do {
		if dep.feepln.isNull() quit
		
	        // Service Fee Plan event
		do SETQUE(dep.feepln, dep.scld, 0, 0, "Service Charge|RUNSRV|0")
		}
	else  do {
		if dep.uspl.isNull() quit
		
		// Usage Credit Plan event
		do SETQUE(dep.uspl, dep.upldt, 0, 0, "Usage Credit Charge|RUNSRV|1")
		}

	quit
	
	
SETHISTD(Number CID,		// Deposit account number	/REF:R
	 RecordTTX ttx1(,,),	// Transaction set		/REF:W
	 RecordTTX ttx,		// Primary transaction		/REF:R
	 Boolean FM)		// File maintenance option

	/*
	Set up deposit QUEUE(,,) and ttx1(,,) for escrow transactions
	
	Additional notes on ARGUMENTS:
	FM
		0 - Load all transactions
		1 - Load file maintenance transactions only
	*/
	
	type public String QUEUE(,,)
	type public Boolean ER
	type public Number BRCD
	
	/*
	All transactions not supported yet for deposit accounts (escrow
	deposit account transactions will be unwound automatically as
	secondary transactions to the loan)
        */
	if 'FM quit

	type String EFDHIT(), EVNT, TCMT
	type Number TSEQ
	type Date HEFD
	
	set EVNT = "Reverse History Entries|RUNHIST"

	type DbSet ds = Db.selectDbSet("HIST", "CID=:CID AND TJD>=:%EffectiveDate AND (EFD IS NULL OR (EFD>0 AND EFD>=:%EffectiveDate)) AND REVTRN=0 AND FM=:FM", "TSEQ DESC")
	while ds.next() do { quit:ER
		type RecordHIST hist = ds.getRecord("HIST")

		set TCMT = hist.tcmt
		
		// Ignore simple notes, such as "SET UP NEW ACCOUNT"
		// (must contain a : to be a true file maintenance)	
		if hist.fm, 'TCMT.isLike("%:%") quit
			
		// Do not reverse FM for ODT
		if TCMT.isLike("%[DEP]ODT%") quit
			
		// Do not unwind changes to General Ledger Set Code, Product
		// Type and/or Cost Center
		if TCMT.isLike("%[DEP]GLSC%") quit
		if TCMT.isLike("%[DEP]TYPE%") quit
		if TCMT.isLike("%[DEP]CC%") quit
		
		set HEFD = hist.efd
		if HEFD.isNull() set HEFD = hist.tjd
		
		set TSEQ = hist.tseq

		// Note: compiler can't handle the spaces on this line
		set ttx1(HEFD,CID,TSEQ) = hist.copy("TIM=TIME,BRCDE=BRCD,UIDT=UID,LNERC=XHS16,CC=BEN")

		set ttx1(HEFD, CID, TSEQ).tjd = %SystemDate
		set ttx1(HEFD, CID, TSEQ).brcd = BRCD.get()
		set ttx1(HEFD, CID, TSEQ).uid = %UserID
		set ttx1(HEFD, CID, TSEQ).tseq = ""

		// Set RUNHIST event into QUEUE(,,) only if not already set 
		// for this date
		if 'EFDHIT(HEFD).exists() do {
			do SETQUE("", HEFD, "", "", EVNT)
			set EFDHIT(HEFD) = ""
			}
		}

	quit
	
	
SETIPF(RecordDEP dep)		// Deposit account		/REF:R

	/*
	Set up QUEUE(,,) entries for both pos and neg interest posting dates
        (actual) and low balance processing dates for deposit account
        */
        
	type public String QUEUE(,,)
        type public Boolean ER
        type public Date CUVAR2, SAVEFD

        type Date JD, START
        type String EVNT, MFRE

	// Low Balance processing
	if 'dep.ipf.isNull(), (dep.ircb = 5 ! (dep.ircb = 6)) do { quit:ER
		set MFRE = $$MFRE^DEPLBB(dep.ipf)

		// Consider special case with semi-monthly
		set JD = $$NXDT^UANTICDP(dep.inp, MFRE, dep.lbcm, 1) quit:ER
		if JD '< CUVAR2 set JD = dep.ipld

		do SETQUE(MFRE, JD, 0, 0, "Low Balance Re-calculation|RUNLBCM", dep.lbcm)

		// Same event dates
		if dep.lbcm = dep.lbcp quit

		// Consider special case with semi-monthly
		set JD = $$NXDT^UANTICDP(dep.inp, MFRE, dep.lbcp, 1) quit:ER
		if JD '< CUVAR2 set JD = dep.ipld

		do SETQUE(MFRE, JD, 0, 0, "Low Balance Periodic Calculation|RUNLBCP", dep.lbcm)
		}
		
	#IF CUVAR.INTPOS=1
		set START = SAVEFD
	#ELSE
		set START = SAVEFD + 1
	#ENDIF
	
	// Actual posting dates should be defined for all non-segmented
	// deposit accounts
	type DbSet ds = Db.selectDbSet("ACNDSD", "CID=:CID AND SCHDT NOT<:START")
	while ds.next() do {
		type RecordACNDSD acndsd = ds.getRecord("ACNDSD")
		
		if acndsd.frecol = "IPF" set EVNT = "Interest Posting|RUNINTPD|0"
		else  set EVNT = "Negative Interest Posting|RUNINTPD|1"
		
		do SETQUE("", acndsd.schdt, 0, 0, EVNT)
		}

        quit


SETICHND(RecordACN acn,		// Account			/REF:R
	 Number INTOFF)		// Interest offset (loans)

	// Set interest change date events

	type public String QUEUE(,,)
	type public Boolean DAILYFRE(,), ER
	
	type String EVNT
	type Number AF
	type Date JD
	
	set EVNT = "Interest Change Date|RUNICHND"

	// Set up QUEUE(,,) entries for interest change dates
	if acn.ichld.isNull() ! (acn.intfre.isNull()) quit

	// Find Annual Factor
	set JD = %SystemDate.nextFreqDate(acn.intfre, .AF) quit:ER
	
	// Daily frequency - let accruals handle change bumping
	if AF > 360 do { quit
		set DAILYFRE(acn.cid, 0) = 1
		do ratechg(.acn, acn.index, EVNT)
		}

	set DAILYFRE(acn.cid, 0) = 0

	type RecordINDEX index = Db.getRecord("INDEX", "INDEX=:acn.index")

	// Non-basis index
	if index.basrel do ratechg(.acn, acn.index, EVNT)
	
	do SETQUE(acn.intfre, acn.ichld, INTOFF, 0, EVNT)

	quit
	
	
ratechg(RecordACN acn,		// Account			/REF:R
	String INDEX,		// Int/div index
	String EVNT)		// Event name

	// Daily index rate change - mark dates in which the index changed 
	// to force an accrual break
	
	type public String IX(,)
	type public Date ACRDT()

	type Date INDXEFD

	do SETQUE("", %SystemDate, 0, 0, EVNT)

	set INDXEFD = ACRDT(acn.cid)

	// Use Last Accrual Date or Teaser Rate Expiration Date
	if acn.trexd > INDXEFD set INDXEFD = acn.trexd	
	
	type DbSet ds = Db.selectDbSet("INDEX0", "INDEX=:INDEX AND EFD>:INDXEFD")
	while ds.next() do {
		type RecordINDEX0 index0 = ds.getRecord("INDEX0")
		set INDXEFD = index0.efd
		if 'IX(INDEX, INDXEFD).exists(), '$$LOADIX^UINDX(.acn, INDEX, , INDXEFD, 1) quit
		do SETQUE("", INDXEFD, 0, 0, EVNT)
		}

	quit
	
	
RUNLBCM	// Low balance accrual calculation method

	/*
	No processing to perform here... all low balance processing be
	performed in ^DEPLBB, which is called from section DEPACR. The
	purpose of having this section is merely to allow for a place
	holder in the QUEUE array, which will cause functionally cause
	an accrual entry to be set up around it, but also serves as a
	reminder that the low balance accrual calculation event will take
	place, and when it will occur in relation to other events.
        
	The Low Balance Calculation Period (LBCM) determines the interval
	over which accrual is calculated on the lowest balance over the
	interval.
	*/

	quit
        
        
RUNLBCP	// Low balance accruals calc period (periodic RE-calculation)

	/*
	See comment above for RUNLBCM.

	The Low Balance Calculation Period (LBCP) determines the interval
	over which accrual is RE-calculated based on the lowest balance
	over the period interval. If this interval is the same as the Low
	Balance Calculation Method (LBCM), no re-calculation is necessary.
	*/
	
	quit

	
RUNSRV(RecordDEP dep,		// Deposit account			/REF:RW
       Boolean PLTP)		// Posting control

	/*
	Run service charge events (reverse)
	
	Additional notes on ARGUMENTS:

		. PLTP
			0  - Service Fee Plan
			1  - Usage Credit Plan
	*/
	
	type public Boolean ER

	// Reset Service Fee Charge dates
	if 'PLTP do {
		set dep.scnd = dep.scld
		set dep.scld = dep.scld.nextFreqDate(dep.scfre) quit:ER
		}
	// Reset Usage Credit Charge dates
        else  do {
		set dep.upndt = dep.upldt
		set dep.upldt = dep.upldt.nextFreqDate(dep.upfre) quit:ER
		}

        quit

        
RUNINTPD(RecordDEP dep,		// Deposit account		/REF:RW
	 Boolean POSTING)	// Interest posting type

	// Run interest posting event (reverse)

	type public Date EVNTJD
	
	type Date SCHDT

	if 'POSTING do { quit
		type ResultSet rs = Db.select("SCHDT", "ACNDSD", "CID=:dep.cid AND FRECOL='IPF' AND SCHDT>0 AND SCHDT<:EVNTJD", "SCHDT DESC")
		if rs.next() set SCHDT = rs.getCol("SCHDT")
		else  set SCHDT = dep.odt

		set dep.inp = EVNTJD
		set dep.ipld = SCHDT
		}

	type ResultSet rs1 = Db.select("SCHDT", "ACNDSD", "CID=:dep.cid AND FRECOL='NEGIPF' AND SCHDT>0 AND SCHDT<:EVNTJD", "SCHDT DESC")
	if rs1.next() set SCHDT = rs1.getCol("SCHDT")
	else  set SCHDT = dep.odt

	set dep.neginp = EVNTJD
	set dep.negipld = SCHDT

	quit
	
	
DEPACR(RecordDEP dep,		// Deposit account			/REF:RW
       Date ACRLD,		// Interest accrual last date
       Date ACRND)		// Interest accrual next date

	// Calculate accrual amount for deposit account
	
	type public Boolean ER

	type Number ACRAMT, BASE, IRCB
	
	set ACRAMT = 0
	set IRCB = dep.ircb
	set BASE = $$IRCB^UANTICDP(.dep, , 0) + dep.cmp

	// Int/Div Rate Calculation Base set to 5 - Low Balance Based on Ledger
	// Balance or 6 - Low Balance Based on Collected Balance
	if IRCB = 5 ! (IRCB = 6) do { quit:ER
		type Date %SystemDate = ACRLD

		do ^DEPLBB(.dep, .ACRAMT, .IRCB, .BASE, 0, 1) quit:ER
		}

	// Consider minimum balance to accrue
	if 'dep.minacr.isNull(), (BASE < dep.minacr) do {
		if (dep.minopt <> 0) set ACRAMT = 0		// Keep accrual
		else  set ACRAMT = -dep.posacr			// Zero accrual
	        }
	/*
	Only calculate "regular" accrual if not low balance (note IRCB can be 
	reset in ^DEPLBB due to negative balance) and an accrual amount has 
	not been calculated yet
	*/
	if IRCB '= 5 , IRCB '= 6 , 'ACRAMT, BASE set ACRAMT = $$^UIC(BASE, ACRLD, ACRND, dep.iacm, dep.irn, 0, dep.intaf, dep.ipf, dep.icpf, dep.inp) quit:ER

	if dep.negacrpo = 1, ACRAMT < 0 do {
		// Note: Unauthorized and uncollected negative accrual not
		// supported yet for unwind / reapply
		set ACRAMT = (ACRAMT * (-1)).roundDec(5)
		
		// Update Negative In/Div Accrual
		set dep.negacr = dep.negacr - ACRAMT
		}
	else  do {
		set ACRAMT = ACRAMT.roundDec(5)

		// Update Positive Int/Div Accrual
		set dep.posacr = dep.posacr - ACRAMT
			
		/*
		If backup withholding flag and accrued withholding tax 
		processing are turned on, calculate the tax withholding 
		based on positive accrued amount
		*/

		if ACRAMT > 0, dep.bwf, dep.awtp do { quit:ER
			type Number BWA, TAXRATE
		
			set TAXRATE = dep.awtr

			do ^DEPBW(.dep, , ACRAMT, .BWA, , CUVAR.BWAPGM, dep.awti, dep.irn, .TAXRATE) quit:ER

			// Update Accrued Withholding Tax amount
			set dep.awt = dep.awt - BWA.roundDec(5)
		
			if (dep.awtr - TAXRATE) do {
				// Record tax rate change in history
				do dep.setAuditFlag(1)
				set dep.awtr = TAXRATE
				}
			}
		}

	// Uncomment for trouble-shooting statistics (do not remove)
	//write !,"Unwind DEP "_dep.cid_": DEPACR Accrue "_BASE_" at "_dep.irn_"% "_ACRND.toString()_"-"_ACRLD.toString()_" = "_(-ACRAMT)
	//write !,$char(9)_"(dep.acr = "_dep.acr_")"

	quit
	
	
SETEOM(RecordLN ln)		// Loan account			/REF:R

	// Set the end of month events
	
	type public Boolean ER
	type public Date CUVAR2, SAVEFD

	type Date BOMDATE
	
	set BOMDATE = $$BOMJD^SCADAT(CUVAR2, 1)
	
	for  quit:BOMDATE < SAVEFD  do { quit:ER
		do SETQUE("", BOMDATE, 0, 0, "End of Month Balance|RUNEOM") quit:ER
		set BOMDATE = $$BOMJD^SCADAT((BOMDATE - 1), 1)
		}

	quit


RUNEOM(RecordLN ln)		// Loan account			/REF:RW

	// Maintain month end balances

	// Balance (Computed)
	type Number BALCMP, PC
	type String MEBAL
	
	set BALCMP = +ln.bal

	if ln.aruf set BALCMP = BALCMP - ln.udbal

	set PC = +%SystemDate.month()

	// Set Month End Balance
	set MEBAL = "MEBAL"_PC
	set ln.@MEBAL = BALCMP

	quit


public	SECPCFD5(Boolean PCFL5, // Loan process control flag 5 (payoff)
		 Number HSEQ,	// Loan history sequence
		 Number CID)	// Loan account number

	/*
	Determine if secondary transaction from loan history is a deposit
	closeout (as would be the case for a direct escrow closeout, which 
	must be through the loan). Check only for primary loan transactions 
	that are not payoffs.
        */
        
        type public Cache %CACHE()
        type public Boolean ER

        // Exclude loan payoff
	if PCFL5 quit 0
	
	type Boolean FOUND = 0

	type ResultSet rs = Db.select("ACT,RSEQ", "HISTLST,DEP", "HISTLST.CID=:CID AND SLN=:HSEQ AND HISTLST.ACT=DEP.CID AND DEP.GRP='ESC'")
	while rs.next() do { quit:FOUND ! (ER)
		type Number ACT, RSEQ

		set ACT = rs.getCol("ACT")
		set RSEQ = rs.getCol("RSEQ")

		type RecordHIST hist = Db.getRecord("HIST", "CID=:ACT,TSEQ=:RSEQ")

		// Quit if no transaction code defined
		if hist.etc.isNull() quit
	
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:hist.etc")
	
		// Quit if this is not a payoff / closeout transaction
		if 'trn.pcf.extract(5) quit
		
		set FOUND = 1
		}

	quit FOUND

vSIG()	quit "60641^45197^Pat Kelly^64529"	// Signature - LTD^TIME^USER^SIZE
