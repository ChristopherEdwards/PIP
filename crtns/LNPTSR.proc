public	LNPTSR(RecordLN ln,		// Loan account			/REF:RW
	       RecordTTX ttx,		// Transaction			/REF:RW
	       RecordTRN trn)		// Transaction code		/REF:R

	/*
	Generic reversal utility
	
	---- Revision History ------------------------------------------------

	01/09/07 - KELLYP - CR 24768
		   Modified the AOI & REVSEC sections to fix several problems
		   with resetting cycled item buckets during payoff reversals.
		   REVSEC was modified to ensure that the reversal of financed
		   items doesn't update the buckets twice. AOI was modified to
		   fix a problem where negative net deferred fee amounts would
		   be added to the buckets incorrectly and also to check the
		   ITC1 flag in TRN instead of PCF.

	11/16/06 - KELLYP - CR 24123
		   Modified DCC section to call new DCCUPD section to increment
		   a loan's delinquency counters according to CUVAR.DCCUP.  If
		   CUVAR.DCCUP = 0 or null, the counters will be updated based
		   on only the oldest delinquent bill.  If CUVAR.DCCUP = 1, the 
		   counters will be updated for all delinquent bill records.
		   Also remove code from DCC section that set the delinquency
		   counter values into the ln object; this is already handled
		   via LNPTSRV calling FILE2^LNPTS3.
	
	11/13/06 - SANTHUMS - CR 23883
		   Modified REVBIL section to get the list of the loan's 
		   payment elements from lnbil0, Also modified REVBIL2 section 
		   to do a compare of TAB_ELMNT_TAB to avoid adding late 
		   charges, since the total due was getting increased by the 
		   amount of the late charges.
	
	11/09/06 - Ravindra Rathi - CR 23939
	           Modified DLCAF section to use Db.getRecord() instead 
	           of Class.new() for DAYENDLCHG record to avoid RDBSAVEFAIL error.
	
	11/02/06 - KELLYP - CR 23885
		   Modified REVSEC section to process reversals for secondary
		   cycled item transactions properly.

	10/19/06 - KELLYP - CR 19960
		   Retrofit of payment tolerance functionality.  Added call to 
		   new section, PAYTOL, from REVBIL2 to retrieve bill records 
		   previously satisfied by payment tolerance processing and to 
		   load them into LNBIL1.  This allows the system to reverse
		   bill amounts previously satisfied by payment tolerance
		   functionality and put them back into the bill record.
	
	09/25/06 - KELLYP - CR 23237
		   Modified DCC section to perform date-based comparisons
		   instead of year-based comparisons for updating delinquency
		   counters.  This prevents problems where the prior-year
		   buckets were not updated correctly for transactions EFD'd
		   for the previous financial year.
	
	07/19/06 - KELLYP - CR 22239
		   Modified top level to check for the LNPTSRV variable in 
		   addition to checking the LNUEFD variable.  This prevents
		   infinite loops from occurring when reversing or error
		   correcting non-payoff transactions.
	
	06/14/06 - TITOVE - CR 21765
		   Modified to check LNUEFD flag instead of LNPTSRV when
		   determining whether to call LNPTSRV procedure.

	05/23/06 - SmithCD - CR 19732
		   . Modified top to always go into LNPTSRV once and only 
		     once, in case there are intervening transactions (even 
		     if there is no effective date)
		   . Added .ttx required parameter to LDHISSEC call
		   . Retrofitted the following from p01:
				07/27/04 - KESTELMANN - CR11140
			Modified code to call STATCK^LNPTS1 if the secondary
			transaction is a deposit closeout before reopening the 
			account. Removed the clearing of DEP.STAT and DEP.DTC
				07/20/04 - KESTELMANN - CR10799
			Remove deletion of DTJCL.
			SETSTAT^LNFUNCS handles it.
		   . Removed code surrounding call to TSOESC^LNCO3, whose net 
		     result was not used in any effective way (even in prior 
		     versions)
		   . Further cleaned up documentation
	
	04/12/06 - TITOVE - CR 20348
		   Removed call to obsoleted section P2^LNPTS2B. Modified
		   LNFEE2 section to correctly update account's fee buckets.

	03/03/06 - TITOVE - CR 19733
		   Modified LNFEE2 section to instantiate an LNFEEP object with
		   a "create-if-needed" qualifier.

	03/02/06 - KUMAR - CR 19363
		   Modified section INIT to set the value for PRETRN("DSEQ"),
		   and also modifed main section, the call of CNTCR^LNPTS3 to 
		   pass PRETRN("DSEQ").
	
	02/24/06 - TITOVE - CR 19776
		   Added missing comma between arguments in EXPCOM section.

	02/10/06 - TITOVE - CR 19271
		   Modified REOPEN section to use getRecord instead of
		   Class.new when updating the DTJNA table. Since this is
		   a reversal, the record already exists and only needs
		   to be updated with reopen indicator.

	02/04/06 - TITOVE - CR 19182
		   Added code to REVSEC to deal with cases when only lower
		   level of history exists for transaction sequence. Modified
		   DRAT to save the value of %EffectiveDate correctly and
		   DISB to only create LNDS1 record if LN.IDGP has value.

	01/31/06 - SmithCD - CR 19343 (16890)
		   . Removed the ' operator before the call to $$IDP^LNPTS3()
		     in the HISTBILL section to enable bills to be reversed 
		     properly (previously only escrow was being reversed, 
		     corrupting the bill)
		   . Replaced call to RAROD^LNPTSRV (which no longer exists) 
		     with call to RAROD^LNPTS1, and fixed "Argument always 
		     false" informational on LMIPRO with compiler directives
		   Made the following changes to the REVSEC section:
		   . Modified to select statement specify "SLN=:HSEQ" instead 
		     of "SLSEQ=:HSEQ" in select on HISTLST so that secondary 
		     transactions can be reversed when the primary transaction 
		     is reversed
		   . Replaced next ttx record passed to POST^LNTRB with 
		     current (primary) ttx, as required by POST^LNTRB
		   . Removed call to RECALC for deposit accounts (was for 
		     escrow accounts, which are now handled in the unwind / 
		     reapply process)
		   . Further cleaned up section
	  
	   08/12/05 - TITOVE - CR 16844
	   	      Modified TAMT3 tag by removing unused argument from call
	   	      to MRPT^SUSPROC.

	   05/31/05 - SmithCD - CR 15902
	   	      . Removed MAIN tag, and added efd condition before 
	   	        calling LNPTSRV
	   	      . Modified select statement in REVBIL section to use SLN 
	   	        column instead of SLSEQ to compare with the history 
	   	        sequence number (previously no records were being 
	   	        selected and bills payments were not being reversed)
	   	      . Modified REVBIL2 section to reference lnbil1.cpid 
	   	        instead of piece 5 of X to prevent undefined error
	   	      . In INTDEF section, fixed SELECTFALSE error on PTR, 
	   	        and undefined errors caused by various variables being 
	   	        scoped locally instead of publically (used by CR 8444)
	   	      . Removed instantiation and passing of lnbil1 to 
	   	        CNTCR^LNPTS3 since it is no longer accepted by that 
	   	        section
	   	      . Changed scope of ER to public in LNFEE section to 
	   	        prevent undefined error
	   	      . Performed some minor cleanup
	  
	   05/06/05 - KinI - 15524
	   	      Modified REVBIL2 and SETAD sections to replace lnbil1 
	   	      master field piece references with direct sub-field 
	   	      updates and removed master fields updates as they are 
	   	      considered a special type of computed per DBI standards.
	  	      Modified DCC section to bump NJD and avoid endless loop.
	  	      
	   04/06/05 - TITOVE - CR 13733
		      Cleaned up logic as part of DBI2 project. Added MAIN
		      section for the recursive call from LNPTSRV. Removed
		      RAROD section, the call to it replaced with call to
		      identical section in LNPTSRV. Removed UNWIND and LNPTS
		      sections.

	-----------------------------------------------------------------------	
	*/	

	type public Boolean LLCR, LNPTSRV, LNUEFD
	type public Cache %CACHE()
	type public Date CUVAR2, TPD
	type public Number CID, CNVMCHG, ER, SEQ
	type public String %LOGID

	/*
	 Start reverse / reapply processing - always go into LNPTSRV once and 
	 only once, in case there are intervening transactions (even if there 
	 is no effective date).
	
	  If LNUEFD = 1, it means that we got back here because LNUEFD called 
	  TRNDRV (e.g., the primary transaction is a loan payoff reversal).
	    
	  If LNPTSRV = 1, it means that we got back here because LNPTSRV called
	  TRNDRV (e.g., the primary transaction is a loan payment reversal).
	
	 If either of these conditions are true, it means that the top level
	 of LNPTSRV has already been called, so there's no need to start the
	 unwind/reapply process again.
	*/
	if 'LNUEFD.get(),'LNPTSRV.get() do { quit
		// Make sure effective date has a value for unwind / reapply
		if %EffectiveDate.isNull() set %EffectiveDate=%SystemDate
		do ^LNPTSRV(.ln,.trn,.ttx)
		}
		
	type Boolean EXTFLG, HIT, INCRS
	type Date ACRDT, FINB, FINBPY, FINE, FINEPY, JAN1PY, JD, LADT, ND, ORGTJD
	type Date TAXB, TAXE
	type Number AMT, BALCMP, BAOLA, FBPY, FEE, FEEAMT, FEPY, HABL1, HABL2
	type Number HSEQ, I, J, PC, TAG, TAXYEOFF, UDBAL, X, YEOFF, ZAMT
	type String CRCD, DATA, ETC, FEETSO, FINESTR, HIST, ITC, PCM, PRETRN(), REC
	type String SAVETC, TAMT, TRN, TSO, UTSO

	set EXTFLG = 0
	
	if CUVAR2.get().isNull() set CUVAR2 = %SystemDate
	
	set FINB = $$BOFY^SCADAT(CUVAR2,1)
	set TAXB = $$BOTY^SCADAT(CUVAR2,1)
	set TAXE = $$EOTY^SCADAT(CUVAR2,1)
	set YEOFF = CUVAR.YEOFF
	set TAXYEOFF = CUVAR.TAXYEOFF
	set LLCR = LLCR.get() 
	set CNVMCHG = 0
	set ZAMT = ttx.tamt
	
	do INIT(.ln)
	
	set ETC = ttx.etc
	
	if ln.rflg do ^UFLG(.ln)
	
	// Re-open account
	if trn.pcfl5 do { quit:ER
		set ln.stat = 0
		do RAROD^LNPTS1
		}
		
	set FINE = $$EOFY^SCADAT(%SystemDate, 1)	
	set FEPY = $$YEAR^SCADAT(FINE, 1) - 1
	set FINESTR = FINE.toString("MM/DD/")_FEPY
	set FINEPY = $$^SCAJD(FINESTR)
	set FINBPY = $$BOFY^SCADAT(FINEPY, 1)
		
	// Reverse fee amounts in TSO
	do REVTSO(.ttx)
	
	// Reset accrual balance and interest rate as of effective date
	// unless the loan is an add-on
	if 'ln.iam, %EffectiveDate, (%EffectiveDate < %SystemDate) do ^LNPTS2B(.ln) quit:ER 
	
	// Recalc HABL1, HABL2, BAOLA, LADT when on the host
	if '%LOGID.get() do ^LNPTSE2A(.ln, .ttx)
	
	set INCRS = (ln.trb - ttx.itc1)
	set TAMT = ttx.tamt
	
	set HSEQ = $$HSEQ(.ttx)
	
	// Unable to locate transaction in account history
	if 'HSEQ do Runtime.setErrMSG("LN", 2793) quit:ER
	
	// Reset balances
	for PC = 2:1:5, 9, 11 do {

		set AMT = TAMT.piece("#", PC) if 'AMT quit
		
		if INCRS set AMT = -AMT

		if PC = 2 do TAMT2(.ln, AMT)
		if PC = 3 do TAMT3(.ln, .trn, .ttx, AMT)
		if PC = 4 do TAMT4(.ln, .ttx, AMT)
		if PC = 5 do TAMT5(.ln, AMT)
		if PC = 9 set ln.unapf = ln.unapf + AMT
		if PC = 11 do TAMT11(.ln, AMT, .trn)
		}
		
	// Reset Principal Variance amount
	do {
		type Number AMT
		set AMT = ttx.tso.getSub("PVAR", "~", "#")
		if INCRS set ln.pvar = ln.pvar + AMT
		else  set ln.pvar = ln.pvar - AMT
		}
		
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:ln.type")
	
	// Reset fees
	do LNFEE(.ln, .ttx, .trn) quit:ER
	
	// Reset Extension Payments
	do EXTPMT(.ln, .ttx) quit:ER
	
	// Reverse bill entries and Total Principal Only Payments amount
	do REVBIL(HSEQ, .trn, .ttx, .ln) quit:ER 

	// Reset certain data items if this was a disbursement	
	do DISB(.ln, .trn, .ttx) quit:ER 
	
	// File account, recalculate remaining amortization and calculate
        // Previous Largest Loan Balance
	do FILE(.ln) quit:ER 
	
	// Reset Scheduled and Collected Balances
	do BALCMP(.ln) quit:ER 
	
	// Reset Daily Late Charge Assessment Flag
	do DLCAF(.ln, .ttx) quit:ER 
	
	// Set transaction to reduce UDBAL on revolving commitment
	do COMM(.ln, .ttx, .prodctl) quit:ER 
	
	// Reset Enterprise processing
	if ln.entf do LNENT(.ln, .trn, .ttx) quit:ER 
	
	// Remove small balance waiver dayend entry
	if 'INCRS do SBWAMT(.ln, .ttx) quit:ER 
	
	// Set TSO field to contain adjustment for committed exposure
	do EXPCOM(.ln, .trn, .ttx) quit:ER 
	
	// Auto-escrow update (call for reversals only)
	if ttx.itc12 do AEU(.ln, .ttx) quit:ER 
	
	// Add-on item rebate
	do AOI(.trn, ttx.tso) quit:ER
	
	// Load bills and update account based on LNBIL* data
	do ^LNPTS(.ln) quit:ER

	// Adjust number of Payments Satisfied and Full Payments Made
	if 'EXTFLG do CNTCR^LNPTS3(.ln, PRETRN("DSEQ")) quit:ER 
	
	// Reset Payments to sold loans
	do LNPDT(.ln) quit:ER	
	
	// Reverse secondary transactions
	do REVSEC(HSEQ, .ttx, .trn) quit:ER
	
	// Reverse amounts stored in pieces 3 of history secondary levels
	do LDHISSEC(CID, HSEQ, .ttx)
	
	set ttx.tsb = ln.teb

	// If bullet was pre-paid, then raise the payment amount on controlling
        // variable loan
	if prodctl.fbp = 2 do VARPMT(.ln)
	
	/*
        Determine if secondary transaction from loan history is a deposit
        closeout (as would be the case for a direct escrow closeout, which
        must be through the loan). If so, reopen the escrow account now, 
        b/c trn.pcfl5 will not be set on the loan transaction code to get into 
        REOPEN (which calls STATCK^LNPTS1 to change account status)
        */
	if $$SECPCFD5^LNUEFD(trn.pcfl5, +$$FIELD^UTSO(ttx.tso, "REV"), ln.cid) do STATCK^LNPTS1(.ln, .ttx, 1)
	
	// Re-open account
	if trn.pcfl5 do REOPEN(.ln, .trn, .ttx) quit:ER 
	
	//  Check the Loan Payment Due/Delinquent Flag and reset it if necessary
	if 'trn.pcfl5 do CHECKDD^LNPTS1
	
	// Reset the date of last full payment with the old value
	do DLFP(.ln,.ttx)
	
	// Reset the date of last payment date with the old value
	do LPDT(.ln,.ttx) 
	
	// Reset Fiscal Balance/Interest fields
	do FISCAL(.ln, ttx.efd)
	
	kill LLCR
	
	quit

	
TAMT2(RecordLN ln, 		// Loan account				/REF:RW
      Number AMT)		// Principal amount

	// Principal

	type public Boolean INCRS
	
	set ln.bal=ln.bal-AMT

	// Update UDBAL for revolving accounts with 'ARUF
	if 'INCRS,ln.revf,'ln.aruf set ln.udbal=ln.udbal+AMT
	if ln.idgp,'INCRS do IDGP(-AMT)
	
	quit 


TAMT3(RecordLN ln, 		// Loan account				/REF:RW
      RecordTRN trn,		// Transaction code			/REF:R
      RecordTTX ttx, 		// Transaction				/REF:R
      Number AMT)		// Interest amount

	type public Date CUVAR2,FINB,TAXB
	type public Number CID,TAXYEOFF,YEOFF
	
	if ttx.tcmt[$$^MSG(4955),ttx.lnerc.piece("#",2) set ln.acr=ln.acr+ttx.lnerc.piece("#",2)
	else  set ln.acr=ln.acr-AMT

	// Update Deferred Int - Annual Accumulation if deferred interest was capped in the current year
	if trn.pcfl16,ln.iropt,'((YEOFF)&(%EffectiveDate<FINB)&(CUVAR2'>(FINB+YEOFF-1))) set ln.diaa=ln.diaa+AMT
	if 'trn.pcfl20 do {
		set ln.ipl=ln.ipl+AMT
		if (YEOFF)&(%EffectiveDate<FINB)&(CUVAR2'>(FINB+YEOFF-1)) set ln.ipy=ln.ipy+AMT
		else  set ln.iytd=ln.iytd+AMT
		if (TAXYEOFF)&(%EffectiveDate<TAXB)&(CUVAR2'>(TAXB+TAXYEOFF-1)) set ln.ipty=ln.ipty+AMT
		else  set ln.itytd=ln.itytd+AMT
		}

	if trn.pac["IRSC^" set ln.refint=ln.refint-AMT
	if trn.pac["IRSP^" set ln.prefint=ln.prefint-AMT
	
	// A.T. & D. R. 
	if $$FIELD^UTSO(ttx.tso,"SUBPMT")'="" do SUBPMT^LNPTS15(.ttx,-(AMT))
	
	// Update Suspense file for movement of interest suspense
	// if flag is on to report
	#IF CUVAR.MRPT 
	if ln.darcls do {
		type Number AMT, WOFF
		type String SUSDATA, XHS16
		type Boolean REV

		set XHS16=ttx.lnerc 
		set REV=0
		if XHS16.piece("#",31) set WOFF=1 set SUSDATA=XHS16.piece("#",31)
		else  set WOFF=0 set SUSDATA=XHS16.piece("#",30)
		set AMT=+SUSDATA

		// Reversed written back/written off of a prior month
		if $$EOMJD^SCADAT(CUVAR2,1)'=$$EOMJD^SCADAT(SUSDATA.piece(",",2),1) set REV=1

		// Reversed written back/written off of the current month
		if 'REV set AMT=-(AMT)

		do MRPT^SUSPROC(.ln,CID,AMT,$$EOMJD^SCADAT(CUVAR2,1),1,WOFF,REV)
		}
	#ENDIF
	
	quit 


TAMT4(RecordLN ln,		// Loan account				/REF:RW
      RecordTTX ttx,		// Transaction				/REF:R
      Number AMT)		// Late Charge Amount
	
	/*
	  Error-correct or reversal of a late charge
	*/	
	
	type public String TSO
	type public Boolean INCRS, LLCR
	type public Date CUVAR2, FINB, TAXB
	type public Number TAXYEOFF, YEOFF
	
	type String LCHGADJ
	
	set ln.lchg = ln.lchg - AMT
	
	set LCHGADJ = $$FIELD^UTSO(ttx.tso,"LCHGADJ")
	
	if 'INCRS,LCHGADJ.isNull() do {
	
		// Penalty Paid buckets
		if LLCR do {
			
			set ln.papl = ln.papl - AMT

			if (YEOFF)&(%EffectiveDate < FINB)&(CUVAR2 '> (FINB + (YEOFF - 1))) set ln.papy = ln.papy - AMT
			else  set ln.paytd=ln.paytd-AMT
			}

		else  do {
			
			set ln.ppl = ln.ppl + AMT

			if (YEOFF)&(%EffectiveDate < FINB)&(CUVAR2 '> (FINB + YEOFF - 1)) set ln.ppy = ln.ppy + AMT
			else  set ln.pytd = ln.pytd + AMT

			if (TAXYEOFF)&(%EffectiveDate < TAXB)&(CUVAR2 '> (TAXB + TAXYEOFF - 1)) set ln.penpty = ln.penpty + AMT
			else  set ln.pentytd = ln.pentytd + AMT
			}
		}
	else  do {
		
		// Late Charge Assessed buckets
		if (YEOFF)&(%EffectiveDate < FINB)&(CUVAR2 '> (FINB + YEOFF - 1)) set ln.papy = ln.papy - AMT
		else  set ln.paytd = ln.paytd - AMT

		set ln.papl = ln.papl - AMT
		set ln.lcanlf = ln.lcanlf - 1
		set ln.lcan = ln.lcan - 1
		}
		
	quit
	
	
TAMT5(RecordLN ln, 		// Loan account				/REF:RW
      Number AMT)		// Undisbursed amount

	// Undisbursed balance
	
	type public Boolean INCRS
	
	set ln.udbal = ln.udbal + AMT
	if 'INCRS do IDGP(-AMT)
	
	quit 
	

TAMT11(RecordLN ln, 		// Loan account				/REF:RW
       Number AMT, 		// Recorvery amount
       RecordTRN trn)		// Transaction code			/REF:R
	
	set ln.rec = ln.rec - AMT
	if 'trn.pcfl5 set ln.recytd = ln.recytd - AMT
	
	quit 


DLCAF(RecordLN ln, 		// Loan account				/REF:R
      RecordTTX ttx)		// Transaction				/REF:R

	// Reset LN.DLCAF

	type public Number CID
	
	if 'ln.dlcaf, ttx.lnerc.piece("#", 8) do {
		// Daily Late Charge Assess Flag
		set ln.dlcaf = 1
		type RecordDAYENDLCHG delchg=Db.getRecord("DAYENDLCHG","TJD=:%SystemDate,CID=:CID",1)
		do delchg.bypassSave() 
		}
	quit 


LNFEE(RecordLN ln, 		// Loan account				/REF:RW
      RecordTTX ttx, 		// Transaction				/REF:R
      RecordTRN trn)		// Transaction code			/REF:R

	// Reverse loan fees
	
	// No fees in TAMT (position 6 - Misc Charges)
	if 'ttx.misc quit
	
	type public Boolean ER
	
	type Number FEEAMT, PC
	type String FEETSO, FEE, X
	
	set FEETSO = $$FIELD^UTSO(ttx.tso,  "LNFEE")
	for PC = 1:1 quit:FEETSO.piece(",", PC).isNull()  do { quit:ER 
		set X = FEETSO.piece(",", PC) 
		set FEE = X.piece(":", 1)
		set FEEAMT = X.piece(":", 2)
		do LNFEE2(.ln, .trn, FEE, -FEEAMT)
		}
	quit 
	

LNFEE2(RecordLN ln, 		// Loan account				/REF:RW
       RecordTRN trn,		// Transaction code			/REF:R
       String FEE, 		// Fee type
       Number FEEAMT)		// Fee amount
	
	type public Boolean INCRS
	type public Number CID, TAXYEOFF, YEOFF
	type public Date CUVAR2, FINB, TAXB
	
	type RecordLNFEE lnfee = Db.getRecord("LNFEE", "CID=:CID,FEETYP=:FEE", 1)
	type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP=:FEE", 1)
	
	if INCRS set FEEAMT = FEEAMT * (-1)
	
	// If assessment (or assessment adjustment), update fees assessed buckets
	if 'trn.pcfl9 do {
	
		// Fee receivable
		set lnfee.feerem = lnfee.feerem + FEEAMT

		// Fee assessed life
		set lnfee.aslf = lnfee.aslf + FEEAMT

		if (YEOFF) & (%EffectiveDate < FINB) & (CUVAR2 '> (FINB + YEOFF - 1)) do {
			set lnfee.aspy = lnfee.aspy + FEEAMT

			if lnfeep.ded set ln.dafpy = ln.dafpy + FEEAMT
			else  set ln.ndafpy = ln.ndafpy + FEEAMT
			}
		else  do {
			set lnfee.asytd = lnfee.asytd + FEEAMT

			if lnfeep.ded set ln.dafyd = ln.dafyd + FEEAMT
			else  set ln.ndafyd = ln.ndafyd + FEEAMT
			}
	
		if (TAXYEOFF)&(%EffectiveDate<TAXB)&(CUVAR2 '> (TAXB + TAXYEOFF - 1)) do {
			set lnfee.aspty = lnfee.aspty + FEEAMT

			if lnfeep.ded set ln.dafpty = ln.dafpty + FEEAMT
			else  set ln.ndafpty = ln.ndafpty + FEEAMT
			}
		else  do {
			set lnfee.astytd = lnfee.astytd + FEEAMT

			if lnfeep.ded set ln.daftytd = ln.daftytd + FEEAMT
			else  set ln.ndaftytd = ln.ndaftytd + FEEAMT
			}
		}
	
	// Otherwise, update fees paid buckets
	else  do {
	
		// Fee receivable
		set lnfee.feerem = lnfee.feerem + FEEAMT
	
		// Fee paid life
		set lnfee.feelf = lnfee.feelf - FEEAMT
	
		if (YEOFF) & (%EffectiveDate < FINB) & (CUVAR2 '> (FINB + YEOFF - 1)) set lnfee.feepy = lnfee.feepy - FEEAMT
		else  set lnfee.feeytd = lnfee.feeytd - FEEAMT

		if (TAXYEOFF) & (%EffectiveDate < TAXB) & (CUVAR2 '> (TAXB + TAXYEOFF - 1)) set lnfee.feepty = lnfee.feepty - FEEAMT
		else  set lnfee.feetytd = lnfee.feetytd - FEEAMT
		}
	
	do lnfee.save()

	quit 


REVBIL(Number HSEQ,		// History sequencs
       RecordTRN trn,		// Transaction code			/REF:R
       RecordTTX ttx,		// Transaction				/REF:R
       RecordLN ln)		// Loan account				/REF:RW

	// Reverse bill entries and LN.POAMT

	type public Number CID
	type public String PCM
	type public Boolean INCRS

	type Number AMT, IDP, ND, PC, X
	type String ADJAVCR,BIL0,ELMNT, REC, RECARR, TSO

	type RecordHIST hist = Db.getRecord("HIST", "CID=:CID,TSEQ=:HSEQ")
	
	set TSO = hist.tso
	set ADJAVCR = $$FIELD^UTSO(TSO, "ADJAVCR")
	
	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0","CID=:ln.cid")
	set BIL0 = $char(9)_$$ELEMENT^BILFUNCS(.lnbil0)      
	
	type DbSet ds = Db.selectDbSet("HISTSB", "CID=:CID AND SLN=:HSEQ AND SLSEQ>.9999 AND SLSEQ<2")
	while ds.next() do {
		type RecordHISTSB histbill = ds.getRecord("HISTSB")		

		// Note "*" billing sequence denotes no bill was affected
		if histbill.pe01bseq do {
			type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:histbill.pe01bseq")
			do HISTBILL(.lnbil1, histbill.pe01bseq)
			if 'histbill.pe01ea.isNull() do REVBIL2(.trn, .ttx, .lnbil1, histbill.pe01bseq, histbill.pe01ea, histbill.pe01amt, .ln)
			do lnbil1.bypassSave()
			}
		if histbill.pe02bseq do {
			type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:CID,SCHSEQ=:histbill.pe02bseq")
			do HISTBILL(.lnbil1, histbill.pe02bseq)
			if 'histbill.pe02ea.isNull() do REVBIL2(.trn, .ttx, .lnbil1, histbill.pe02bseq, histbill.pe02ea, histbill.pe02amt, .ln)
			do lnbil1.bypassSave()
			}
		if histbill.pe03bseq do {
			type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:CID,SCHSEQ=:histbill.pe03bseq")
			do HISTBILL(.lnbil1, histbill.pe03bseq)
			if 'histbill.pe03ea.isNull() do REVBIL2(.trn, .ttx, .lnbil1, histbill.pe03bseq, histbill.pe03ea, histbill.pe03amt, .ln)
			do lnbil1.bypassSave()
			}
		if histbill.pe04bseq do {
			type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:CID,SCHSEQ=:histbill.pe04bseq")
			do HISTBILL(.lnbil1, histbill.pe04bseq)
			if 'histbill.pe04ea.isNull() do REVBIL2(.trn, .ttx, .lnbil1, histbill.pe04bseq, histbill.pe04ea, histbill.pe04amt, .ln)
			do lnbil1.bypassSave()
			}
		if histbill.pe05bseq do {
			type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:CID,SCHSEQ=:histbill.pe05bseq")
			do HISTBILL(.lnbil1, histbill.pe05bseq)
			if 'histbill.pe05ea.isNull() do REVBIL2(.trn, .ttx, .lnbil1, histbill.pe05bseq, histbill.pe05ea, histbill.pe05amt, .ln)
			do lnbil1.bypassSave()
			}
		}

	quit 


HISTBILL(RecordLNBIL1 lnbil1,		// Internal Bill Detail		/REF:R
	 Number BSEQ)			// Bill Sequence Number

	type public String IDP

	if IDP(BSEQ).exists() quit
	
	set IDP(BSEQ) = $$IDP^LNPTS3(.lnbil1)
	
	quit


REVBIL2(RecordTRN trn,			// Transaction code		/REF:R
	RecordTTX ttx,			// Transaction			/REF:R
	RecordLNBIL1 lnbil1,		// Internal bill detail
	Number BSEQ,			// Billing Sequence
	String ELMNT,			// Payment Element Acronym
	Number AMT,			// Payment Element Amount
	RecordLN ln)			// Loan account			/REF:RW

	type public Number ADJAVCR, IDP()
	type public String BIL0,PCM
	type public Boolean INCRS
	
	if 'BSEQ do { quit
	
		if ELMNT = "P", 'INCRS, 'ADJAVCR set ln.poamt = ln.poamt - AMT
		if ELMNT = "U", 'INCRS, 'ADJAVCR set ln.poamt = ln.poamt - AMT
		
		if 'PCM.extract(2) ! (PCM.extract(2) > 2) quit
		
		if 'trn.pcfl13 quit	// Update Interest Adjustment flag
		
		type Number %INTA, ZAMT
		
		set ZAMT = AMT
		
		do INTA^LNPTSU(.ttx, .ln, ZAMT)
		 
		set ln.inta = ln.inta + %INTA
		}
		
	if 'ELMNT.isNull(),(BIL0[($char(9)_ELMNT_$char(9)))  do {

		// Add payment tolerance amounts to AMT
		set AMT = AMT + $$PAYTOL(.ln,.lnbil1,BSEQ,ELMNT)
	
		/*
		  Reverse element if IDP is not set (i.e., determine interest
		  at billing) or if IDP is set and the element is not I or P
		*/
		if 'IDP(BSEQ) do SETAD(.lnbil1, BSEQ, AMT, ELMNT)  if 1
		else  if (ELMNT '= "I"), (ELMNT '= "P") do SETAD(.lnbil1, BSEQ, AMT, ELMNT)
		
		set lnbil1.casd = lnbil1.casd + AMT
		
		if (ELMNT = "I") ! (ELMNT = "P") set lnbil1.cpid = lnbil1.cpid + AMT
		
		if (ELMNT = "I") do INTDEF(.ln, .lnbil1, BSEQ)
		}
		
	type DbSet rs = Db.selectDbSet("LNBIL5", "CID=:CID AND SCHSEQ=:BSEQ AND FEETYP=:ELMNT")

	while rs.next() do {

		type RecordLNBIL5 lnbil5 = rs.getRecord("LNBIL5")

		set lnbil5.brfamt = lnbil5.dueamt + AMT
				
		do lnbil5.bypassSave()
		
		if lnbil5.dueamt = 1 set lnbil1.casd = lnbil1.casd + AMT

		}
	quit
	
	
SETAD(RecordLNBIL1 lnbil1,		// Bill detail
      Number BSEQ,			// Billing Sequence
      Number AMT,			// Payment Element Amount      
      String ELMNT)			// Payment Element Acronym
	     
	// Restore amount still owe on bill record for element acronym

	if lnbil1.pe01ea = ELMNT set lnbil1.pe01ad = lnbil1.pe01ad + AMT quit
	if lnbil1.pe02ea = ELMNT set lnbil1.pe02ad = lnbil1.pe02ad + AMT quit
	if lnbil1.pe03ea = ELMNT set lnbil1.pe03ad = lnbil1.pe03ad + AMT quit
	if lnbil1.pe04ea = ELMNT set lnbil1.pe04ad = lnbil1.pe04ad + AMT quit
	if lnbil1.pe05ea = ELMNT set lnbil1.pe05ad = lnbil1.pe05ad + AMT quit
	if lnbil1.pe06ea = ELMNT set lnbil1.pe06ad = lnbil1.pe06ad + AMT quit
	if lnbil1.pe07ea = ELMNT set lnbil1.pe07ad = lnbil1.pe07ad + AMT quit
	if lnbil1.pe08ea = ELMNT set lnbil1.pe08ad = lnbil1.pe08ad + AMT quit
	if lnbil1.pe09ea = ELMNT set lnbil1.pe09ad = lnbil1.pe09ad + AMT quit
	if lnbil1.pe10ea = ELMNT set lnbil1.pe10ad = lnbil1.pe10ad + AMT quit
	if lnbil1.pe11ea = ELMNT set lnbil1.pe11ad = lnbil1.pe11ad + AMT quit
	if lnbil1.pe12ea = ELMNT set lnbil1.pe12ad = lnbil1.pe12ad + AMT quit
	if lnbil1.pe13ea = ELMNT set lnbil1.pe13ad = lnbil1.pe13ad + AMT quit
	if lnbil1.pe14ea = ELMNT set lnbil1.pe14ad = lnbil1.pe14ad + AMT quit
	if lnbil1.pe15ea = ELMNT set lnbil1.pe15ad = lnbil1.pe15ad + AMT quit
	if lnbil1.pe16ea = ELMNT set lnbil1.pe16ad = lnbil1.pe16ad + AMT quit
	if lnbil1.pe17ea = ELMNT set lnbil1.pe17ad = lnbil1.pe17ad + AMT quit
	if lnbil1.pe18ea = ELMNT set lnbil1.pe18ad = lnbil1.pe18ad + AMT quit
	if lnbil1.pe19ea = ELMNT set lnbil1.pe19ad = lnbil1.pe19ad + AMT quit
	if lnbil1.pe20ea = ELMNT set lnbil1.pe20ad = lnbil1.pe20ad + AMT quit
	
	quit
	

REVSEC(Number HSEQ,		// History sequence of primary trans
       RecordTTX ttx,		// Primary transaction			/REF:RW
       RecordTRN trn)		// Primary transaction code		/REF:R

	// Reverse secondary transactions

	type public Cache %CACHE()
	type public Number ER

	type Boolean AOISKIP
	type Number CID, SAVCID, ZAMT
	type String CRCD, ETC, TAMT, TMP, TSO, TSOAOI()

	/*
	Select all History of Loan Secondary Transaction records related to 
	the primary loan transaction being reversed (that have not been 
	reversed) and spawn secondary transactions to reverse them
	*/
	type DbSet ds = Db.selectDbSet("HISTLST", "CID=:ttx.cid AND SLN=:HSEQ AND (SLSEQ>3.9999 AND SLSEQ<5) AND RFLG<>1", "SLSEQ DESC")
	while ds.next() do { quit:ER
		type RecordHISTLST histlst = ds.getRecord("HISTLST")
		
		set AOISKIP = 0

		// Different related account	
		if (histlst.act) set CID = histlst.act
		// Same account
		else  set CID = ttx.cid
	
		if histlst.rseq do {
			// Related sequence exists, must be an account
			type Number EC, POS, TAMTLEN

			/*
			 A flag is set here to skip the AOI section called below because
			 the TSO field of the related ttx to be reversed may contain AOI
			 info.  If it does, the reversal of that transaction will handle
			 updating the LNCYC* buckets via the call to AOI from the top of
			 LNPTSR.  If it is also called from REVSEC, the buckets would be 
			 updated twice for the same transaction.
			*/
			set AOISKIP = 1

			type RecordHIST hist = Db.getRecord("HIST", "CID=:CID,TSEQ=:histlst.rseq", 1)
			
			set ETC = hist.etc
			set TAMT = hist.tamt
			set CRCD = hist.crcd

			set TAMTLEN = TAMT.length("#")
			for POS = 1:1:TAMTLEN if TAMT.piece("#", POS) set TAMT.piece("#", POS) = -TAMT.piece("#", POS)

			// Insert original sequence being reversed into TSO
			set TSO = $$FIELDIN^UTSO(hist.tso, "REV", histlst.rseq)
			
			// Insert error correct indicator from primary 
			// transaction into TSO
			set EC = $$FIELD^UTSO(ttx.tso, "EC")
			if EC set TSO = $$FIELDIN^UTSO(TSO, "EC", EC)
			}
		else  do {
			// Related sequence does not exists, must be a G/L
			set ETC = histlst.etc
			set TAMT = -histlst.tamt
			set TSO = histlst.tso
			set CRCD = $$FIELD^UTSO(TSO, "CRCD")
			}
		
		if ETC.isNull() quit

		type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")
	
		set ZAMT = +TAMT
		
		set TMP = $$FIELD^UTSO(TSO, "AOI")
		if ('TMP.isNull()),('AOISKIP) do {  quit:ER
		
			/*
			 Some cycled item transactions require two G/L ttx's, others require 
			 only one.  In the event that there are two (e.g., for payoffs with 
			 rebateable net deferred fees there's a NFC to one G/L and a NFD to 
			 another) the item should only call into AOI to update the LNCYC*
			 record once.
			*/

			if TSOAOI(TMP).exists() quit	// Already processed this item

			set TSOAOI(TMP) = 1		// Mark this cycled item as processed
			
			// AOI needs the loan acct, not the G/L
			set SAVCID = CID
			set CID = ttx.cid
		
			do AOI(.trn, TSO)
			
			set CID = SAVCID
			}
	
		do POST^LNTRB(.ttx, CID, ETC, TAMT, %EffectiveDate, "", TSO, "", CRCD, "") quit:ER
		}

	quit


INIT(RecordLN ln)		// Loan account				/REF:RW

	// Initalization

	type public String CRCD, PCM, PRETRN()
	type public Number BALCMP

	set CRCD = ln.crcd
	
	type RecordSTBLPCM stblpcm = Db.getRecord("STBLPCM", "KEY=:ln.pcm", 1)
	set PCM = stblpcm.pcmp

	set BALCMP = ln.bal
	
	if ln.aruf set BALCMP = ln.bal - ln.udbal
	set PRETRN("BALCMP") = BALCMP
	set PRETRN("DSEQ") = ln.dseq

	quit
	
	
FILE(RecordLN ln)		// Loan account				/REF:RW

	// File account
	
	type public Number BAOLA, ER, HABL1, HABL2
	type public Date LADT
	
	if 'HABL1.get() set HABL1 = 0
	set ln.habl1 = HABL1
	set ln.habl2 = HABL2
	set ln.baola = BAOLA
	set ln.ladt = LADT

	// Call PMAXBAL to calculate Previous Largest Loan Balance
	do EXEC^PMAXBAL(ln.acn,ln.cid,HABL1) quit:ER 
	
	quit
	

public HSEQ(RecordTTX ttx)		// Transaction			/REF:R

	type public Date ORGTJD
	type public Number CID

	type Boolean HIT
	type Number ORGTSEQ, TSEQ
	type String UTSO

	do OUT^UTSO(.UTSO, ttx.tso)
	
	set (ORGTSEQ, HIT) = 0
	
	// Initialize ORGTJD, just in case
	set ORGTJD = ttx.tjd
	
	if UTSO("REV").get() do { quit ORGTSEQ

		set TSEQ = UTSO("REV")
		type RecordHIST hist = Db.getRecord("HIST", "CID = :CID, TSEQ = :TSEQ")

		set ORGTJD = hist.tjd
		
		if hist.etc '= ttx.etc quit
		
		if (+hist.tamt + ttx.tamt) quit 
		
		set ORGTSEQ = TSEQ
		}
		
	type DbSet ds = Db.selectDbSet("HIST", "CID=:CID AND ETC=:ttx.etc")
	while ds.next() do {  quit:HIT
		type RecordHIST hist = ds.getRecord("HIST")
		
		if (ttx.tjd - hist.tjd) quit

		if (hist.tot + ttx.tamt) quit
		
		if hist.trc, (UTSO("EC").get() - hist.trc) quit
		
		set ORGTJD = hist.tjd
		set ORGTSEQ = hist.tseq
		
		set HIT = 1
		}
		
	quit ORGTSEQ
	
	
AEU(RecordLN ln,		// Loan account				/REF:RW
    RecordTTX ttx)		// Transaction				/REF:R
  
  	// Auto-escrow update
	
	type Number CID
	
	set CID = ttx.cid

	do AUTO1^LNPTS1(.ln,.ttx)
	
	quit
	
	
COMM(RecordLN ln,		// Loan account				/REF:RW
     RecordTTX ttx,		// Transaction				/REF:R
     RecordPRODCTL prodctl) 	// Product type				/REF:R
   
	// Set transaction to reduce UDBAL on revolving commitment
	
	type public Number ER
	type public String OVR(,,)
	
	type String ITC

	// Principal part of transaction amount
	if 'ttx.prin quit

	// Revolving Account Flag
	if ln.revf quit

	// Commercial Commitment Link
	if 'ln.ccl quit
	
	type RecordLN ln1 = Db.getRecord("LN", "CID = :ln.ccl", 1)

	if 'ln1.revf quit

	if (ln1.stat > 1) set OVR(ln.ccl, "OVR", "STAT"_ln1.stat) = ""

	// Supporting credit transaction is not found in type ~p1
	if prodctl.crtraf.isNull() do Runtime.setErrMSG("LN", 7034, ln.type) quit:ER
	
	do POST^LNTRB(.ttx,ln.ccl, prodctl.crtraf, ttx.prin, %EffectiveDate, %UserStation, , , ln.crcd) quit:ER
	
	// Supporting debit transaction code is not found in type ~p1
	if prodctl.drtraf.isNull() do Runtime.setErrMSG("LN", 2566, ln.type) quit:ER
	
	do POST^LNTRB(.ttx, ln.ccl, prodctl.drtraf, ttx.prin, %EffectiveDate, %UserStation, , , ln.crcd) quit:ER
	
	quit
	
	
DISB(RecordLN ln,		// Loan account				/REF:RW
     RecordTRN trn,		// Transaction code			/REF:R
     RecordTTX ttx)		// Transaction				/REF:R

	// Reset LN.TCSA or LN.TCRP if this was a disbursement

	type public Boolean INCRS
	type public Date CUVAR2, FINB, TAXB
	type public Number ADJAVCR, CID, TAXYEOFF, YEOFF, ZAMT
	
	type Date SDD
	type Number PCFL30 = trn.pcfl30

	if trn.pgm = "MLSP^PROCPTL(.ln,.ttx,.trn)" set PCFL30 = 2

	if (PCFL30 = 2)!(PCFL30 = 3) do {
		
		set ln.tcsa = ln.tcsa - ttx.lnerc.piece("#",34)
		set ln.tcsl = ln.tcsl - ttx.lnerc.piece("#",42)
		}
		
	if (PCFL30 = 1)!(PCFL30 = 4) do {
		
		set ln.tcrp = ln.tcrp - ttx.lnerc.piece("#",34)
		set ln.tcrl = ln.tcrl - ttx.lnerc.piece("#",42)
  		}

	if 'INCRS quit 

	if 'ttx.tamt.piece("#",2), 'ttx.tamt.piece("#",5) quit 
	
	set ADJAVCR = $$FIELD^UTSO(ttx.tso,"ADJAVCR")
	
	// Reverse European Check Status
	if ttx.tso.isLike("%CK#%") do EUROCK(.ttx)
	
	// Deferred Interest Capitalization
	if trn.pcfl16 do {
		
		set ln.dic = ln.dic + ZAMT
		
		if ln.ccl set ln.balint = ln.balint - ttx.tamt
		
		if ln.rpidc do {
			
			if (YEOFF)&(%EffectiveDate < FINB)&(CUVAR2 '> ((FINB + YEOFF) - 1)) set ln.ipy = ln.ipy + ZAMT
			else  set ln.iytd = ln.iytd + ZAMT

			if (TAXYEOFF)&(%EffectiveDate < TAXB)&(CUVAR2 '> ((TAXB + TAXYEOFF) - 1)) set ln.ipty = ln.ipty + ZAMT
			else  set ln.itytd = ln.itytd + ZAMT

			set ln.ipl = ln.ipl + ZAMT 
			set ln.narl = ln.narl + ZAMT
			}
		}
	
	if 'ttx.tamt.piece("#",5),(trn.pcfl4 ! ln.revf) set ln.udbal = ln.udbal - ttx.tamt

	if 'trn.pcfl4 quit		// Apply to Single Payment Element flag

	if 'ADJAVCR set ln.cntdr = ln.cntdr - 1 set ln.tdr = ln.tdr + ttx.tamt

	if ln.idgp do {
		
		set SDD = %EffectiveDate if SDD.isNull() set SDD = ttx.efd
		
		if SDD.isNull() set SDD = %SystemDate
		
		type RecordLNDS1 lnds1 = Db.getRecord("LNDS1", "CID = :CID,SDD = :SDD", 1)

		set lnds1.sda = lnds1.sda + ttx.tamt
		
		do lnds1.bypassSave()	
		}
		
	set ln.schbal = ln.schbal + ttx.tamt
	
	if 'ln.cntdr do {
	
		set ln.org = 0 
		set ln.odd = ln.dtnt 
		set ln.inta = 0
		}
		
	// Debit Ratification Flag
	if ln.drf do DRAT(.ln,.ttx) quit	

	quit
	
	
DRAT(RecordLN ln,		// Loan account				/REF:RW
     RecordTTX ttx)		// Transaction				/REF:R
     
	// Reverse debit-ratification
	
	type public Number CID, HSEQ
	
	type Boolean HIT = 0
	type Date %EFD, HEFD, HTJD
	type Number %IRN, TSEQ
	type String %NV, %OV, DATA, DI, FID, NV, OV, TCMT, WIRN(), X
	
	set %EFD = %EffectiveDate
	
	type Date %EffectiveDate

	set TSEQ = HSEQ 

	set %IRN = ln.irn
	
	// Data from current history record
	type RecordHIST hist = Db.getRecord("HIST","CID = :CID,TSEQ = :TSEQ")
	set HTJD = hist.tjd
	set HEFD = hist.efd 

	// Starting sequence	
	type ResultSet rs = Db.select("TJD,EFD,TSO,TCMT","HIST","CID = :CID AND TSEQ > :TSEQ")
	while rs.next() do { quit:'HIT
		
		set TCMT = rs.getCol(4)
		
		if 'TCMT.isLike("%[%") quit
		
		set X = TCMT.piece("[",2)		
		set FID = X.piece("]",1)
		 
		if FID["," set FID = FID.piece(",",2)
		
		if FID '= "LN" quit
		
		set DI = X.piece("]",2)
		set DI = DI.piece(":",1)
		set OV = X.piece(":",2)
		set NV = X.piece(":",3)
		
		if DI '= "IRN" quit

		set %EffectiveDate = rs.getCol("EFD")
		
		if %EffectiveDate.isNull() set %EffectiveDate = HTJD
		
		if (%EffectiveDate < %EFD) set %EffectiveDate = %EFD
	
		// Rate change on same day overrides debit ratification rate change
		// Quit if we passed the reversal date without finding the rate change
		if HSEQ '= rs.getCol("TSO") quit

		if (rs.getCol("TJD") - HTJD) = 0 do {
			set %OV = OV
			set %NV = NV
			set HIT = 1
			}	
		}
	
	if 'HIT quit
	
	do ln.setAuditFlag(1)
	
	if (ln.ichld < HTJD) set ln.irn = %OV

	set %EffectiveDate = HEFD 
	if %EffectiveDate.isNull() set %EffectiveDate = HTJD
	
	set WIRN(%EffectiveDate).piece("|",1) = %OV 
	set WIRN(%EffectiveDate).piece("|",3) = 1
	
	if (%EffectiveDate < %EFD) set %EffectiveDate = %EFD
	
	do HSEQ^LNPTSU(.ttx)
	
	quit
	
	
LNENT(RecordLN ln,		// Loan account				/REF:R
      RecordTRN trn,		// Transaction code			/REF:R
      RecordTTX ttx)		// Transaction				/REF:R
      
	// Enterprise processing
	
	type String BGT,BUN,TSO,UTSO
	type Number PRIN,UNITS

	if trn.cls '= "L" quit
	
	do OUT^UTSO(.UTSO,ttx.tso)
	
	// Determine principal change
	if ln.aruf set PRIN = ttx.tamt.piece("#",2) + ttx.tamt.piece("#",5)
	else  set PRIN = ttx.tamt.piece("#",2)
	
	if 'PRIN quit 
	
	// Was this a disbursement transaction?
	if (ln.trb - trn.pcf) do {
		
		set BGT = UTSO("LBUDU").get()
	
		// If BGT is null, this may be a debit transaction which
		// increases principal (i.e., CMDEB from loan fee)
		if BGT.isNull() do {

			//Ignore disbursements
			if trn.pcfd4 quit
			
			type RecordLNENT0 lnent0 = Db.getRecord("LNENT0","CID = :ttx.cid", 1)
	
			set lnent0.dramt = lnent0.dramt + PRIN
			
			do lnent0.bypassSave()
			}
			
		else  do {

			set UNITS = $$SIGN^LNPTS1(UTSO("UNITU").get(),ttx.itc)

			type RecordLNENT lnent = Db.getRecord("LNENT","CID = :ttx.cid,USESRC = :BGT", 1)

			set lnent.act = lnent.act + PRIN
			set lnent.octant = lnent.octant + UNITS			

			do lnent.bypassSave()
			}
		}

	else  do {
		
		set BGT=UTSO("LBUDS").get()
		
		if BGT.isNull() do {
			
			if trn.pcfl4 quit
			
			type RecordLNENT0 lnent0 = Db.getRecord("LNENT0","CID = :ttx.cid", 1)
			set lnent0.dramt = lnent0.dramt - PRIN

			do lnent0.bypassSave()
			}
		else  do {

			set UNITS = $$SIGN^LNPTS1(UTSO("UNITS").get(),ttx.itc)

			type RecordLNENT lnent = Db.getRecord("LNENT","CID = :ttx.cid,USESRC = :BGT", 1)

			set lnent.rep = lnent.rep + PRIN
			set lnent.repunt = lnent.repunt + UNITS			

			do lnent.bypassSave()
			}
		}

	quit
	

public LNPDT(RecordLN ln)	// Loan account				/REF:R

	// Payments to sold loans
	// This section is called by LNUEFD for payoff reversals
	
	type public Date CUVAR2
	type public Number CID, HSEQ
	type public String PRETRN()

	type Boolean rflag, RFPF
	type Number BALCMP, PSEQ
	type String PL, INCD
	
	set rflag = 0

	type ResultSet rs = Db.select("PSEQ,INCD,PL,RFPF", "LNLS6", "CID = :CID")
	while rs.next() do {
		set PSEQ = rs.getCol("PSEQ")
		set INCD = rs.getCol("INCD")
		set PL = rs.getCol("PL")
		set RFPF = rs.getCol("RFPF")

		// Marked Inactive Flag
		if RFPF quit

		// Do not process commercials
		type RecordLNLS2 lnls2 = Db.getRecord("LNLS2", "INCD = :INCD, PL = :PL")
		if lnls2.picm = 6 quit

		// Do not process reversals
		type RecordLNLS1 lnls1 = Db.getRecord("LNLS1", "INCD = :INCD")
		if lnls1.revcus '= 1 quit

		set BALCMP = ln.bal + 0
		if ln.aruf set BALCMP = BALCMP - ln.udbal
			
		if Db.isDefined("LNLSDT","CUVAR2,INCD,PL,CID,HSEQ") do {
			do Db.delete("LNLSDT", "EFD=:CUVAR2 AND INCD=:INCD AND PL=:PL AND CID=:CID AND TSEQ=:HSEQ")
			set rflag = 1
			}
			
		type RecordLNLSDT lnlsdt=Class.new("RecordLNLSDT")
		
		set lnlsdt.efd = CUVAR2
		set lnlsdt.incd = INCD
		set lnlsdt.pl = PL
		set lnlsdt.cid = CID
		set lnlsdt.tseq = HSEQ

		/*
		If entry exists this seq, this date - this is an error correct that
		hasn't been transferred to custodial - so we don't want to overwrite
		the first entry with negative amounts.
		*/
		if rflag set lnlsdt.lnsfl = 1
		else  do {
			set lnlsdt.balbef = PRETRN("BALCMP")
			set lnlsdt.balaft = BALCMP
			set lnlsdt.pseq = PSEQ
			set lnlsdt.revpmt = 1
			set lnlsdt.escbef = ln.teb
			set lnlsdt.lstact = ln.tld
			set lnlsdt.lstdue = ln.dist1ld
			set lnlsdt.lstpmt = ln.lpdt
			}
	
		do lnlsdt.bypassSave()
		}

	quit
	
	
SBWAMT(RecordLN	ln,		// Loan account				/REF:R
       RecordTTX ttx)		// Transaction				/REF:R

	// Remove small balance waiver dayend entry
	
	type public Boolean INCRS
	type public Date ORGTJD
	type public Number CID
	type public String PRETRN()
	
	type Number X
	
	set X = ttx.tamt
	
	if ln.aruf set X = ttx.tamt.piece("#", 2) + ttx.tamt.piece("#", 5)
	else  set X = ttx.tamt.piece("#", 2)
	
	if ((PRETRN("BALCMP") - X) '> ln.sbwamt) quit
	
	do Db.delete("DAYENDLSBW", "EFD=:ORGTJD AND CLS=:ln.cls AND GRP=:ln.grp AND TYPE=:ln.type AND CID=:CID")
	
	quit
	
	
VARPMT(RecordLN ln) 		// Loan account				/REF:RW

	/*
	If bullet was pre-paid, then raise the payment amount on controlling
	variable loan.
	*/
	
	type public String OVR(,,), PRETRN()
	type Number BALCMP
	
	if PRETRN("BALCMP") quit
	
	set BALCMP = ln.bal
	
	if ln.aruf set BALCMP = BALCMP - ln.udbal
	
	if (BALCMP '> 0) ! (BALCMP '> (ln.cupr + ln.unpr)) quit 

	if ln.trm = ln.ptrm quit
	
	/*
	At this point, we figured that this is a pre-payment on
	a "balloon" bullet.  The variable loan would have normally
	had it's payment increased when the bullet's remaining balance
	transferred back to the variable loan.
	*/

	if 'ln.fpa ! ('ln.tracn) quit
	
	// Check call to LNPTSU
	do %FFPA^LNPTSU(ln.tracn, ln.mdt, 99999, ln.fpa)
	
	set OVR(ln.tracn, "OVR", "FPA") = ""
	
	quit
	
	
public REVTSO(RecordTTX ttx)		// Transaction			/REF:R

	// Reverse fee amounts in TSO
	
	type String FEETSO, PC, X

	set FEETSO = $$FIELD^UTSO(ttx.tso, "LNFEE")
	
	if FEETSO.isNull() quit
	
	for PC = 1:1 quit:FEETSO.piece(",", PC).isNull()  do {
		
		set X = FEETSO.piece(",", PC)
		
		if (X.piece(":", 2) > 0) set X.piece(":", 2) = -X.piece(":", 2)
		
		set FEETSO.piece(",", PC) = X
		}
	
	set ttx.tso = $$FIELDIN^UTSO(ttx.tso, "LNFEE", FEETSO)
	
	quit
	
	
AOI(RecordTRN trn,		// Transaction code			/REF:R
    String TSO)			// Transaction source of funds
       
	// Transaction Source of Funds
       
	//Create or update Loan Cycled Items tables

	type public Number CID, ER, ZAMT
	
	type String AOI, TYP
	
	if $$FIELD^UTSO(TSO,"AOI").extract() = "I" set AOI = "INS",TYP = $$FIELD^UTSO(TSO,"AOI")
	else  set (AOI,TYP) = $$FIELD^UTSO(TSO,"AOI") if AOI.isNull() quit 
	
	// Include all primary LNCYC* keys
	if "P"[AOI.extract() do { quit:ER

			type RecordLNCYCPTS lncycpts = Db.getRecord("LNCYCPTS","CID = :CID, TYP = :TYP", 1)

			// Invalid add-on type
			if 'lncycpts.getMode() do Runtime.setErrMSG("LNCYCPTS", 1264) quit:ER

			if 'trn.itc set ZAMT = -ZAMT
			else  if ZAMT < 0 set ZAMT = -ZAMT	// Amortizing a negative amount, add it back
			set lncycpts.caltd = lncycpts.caltd + ZAMT
			set lncycpts.reb = 0
					
			do lncycpts.bypassSave()		
			}

	if "I"[AOI.extract() do { quit:ER

			type RecordLNCYCINS lncycins = Db.getRecord("LNCYCINS","CID = :CID, TYP = :TYP", 1)

			// Invalid add-on type
			if 'lncycins.getMode() do Runtime.setErrMSG("LNCYCINS", 1264) quit:ER

			if 'trn.itc set ZAMT = -ZAMT
			set lncycins.caltd = lncycins.caltd + ZAMT
			set lncycins.reb = 0
			
			do lncycins.bypassSave()
			}

	if "M"[AOI.extract() do { quit:ER

			type RecordLNCYCMSC lncycmsc = Db.getRecord("LNCYCMSC","CID = :CID, TYP = :TYP", 1)

			// Invalid add-on type
			if 'lncycmsc.getMode() do Runtime.setErrMSG("LNCYCMSC", 1264) quit:ER

			if 'trn.itc set ZAMT = -ZAMT
			set lncycmsc.caltd = lncycmsc.caltd + ZAMT
			set lncycmsc.reb = 0
			
			do lncycmsc.bypassSave()
			}

	if "D"[AOI.extract() do { quit:ER

			type RecordLNCYCDLD lncycdld = Db.getRecord("LNCYCDLD","CID = :CID, TYP = :TYP", 1)

			// Invalid add-on type
			if 'lncycdld.getMode() do Runtime.setErrMSG("LNCYCDLD", 1264) quit:ER

			if 'trn.itc set ZAMT = -ZAMT
			set lncycdld.caltd = lncycdld.caltd + ZAMT
			set lncycdld.reb = 0
			
			do lncycdld.bypassSave()
			}
			
	quit
	
	
REOPEN(RecordLN	ln,		// Loan account				/REF:RW
       RecordTRN trn,		// Transaction code			/REF:R
       RecordTTX ttx)		// Transaction				/REF:R
     
	// Re-open account
     	
	type public Number CID, ER
	type public Date CUVAR2
	
	type Date %EffectiveDate, ACRDT, DTJEFD
	type Number TYPE
	type String E23, GRP
 
	set %EffectiveDate = ttx.efd

	if %EffectiveDate.isNull() set %EffectiveDate = %SystemDate
	
	// Set accrued-thru date.  Used by LNDE1 when generating past bills.
	set ACRDT = (ln.dtc - 1)

	if CUVAR2.get().isNull() set CUVAR2 = %SystemDate

	set ln.acs = CUVAR2 - 1
	
	// Update original DTJNA record with reopen indicator
	if ttx.itc12 do {
		
                type RecordDTJNA dtjna = Db.getRecord("DTJNA","TJD=:%SystemDate,CLS='L',GRP=:ln.grp,TYP=:ln.type,CID=:CID", 1)
 
                set dtjna.reopn = 1
 
                do dtjna.bypassSave()	
		}
		
	// Roll scheduled/billing dates until current
	if (ln.schnd '> 0) do ACR^LNDE2(.ln) if ER quit
	
	set DTJEFD = %EffectiveDate
	set GRP = ln.grp
	set TYPE = ln.type

	set E23 = trn.pcf
	
	set ln.clr = ""
	
	// Check call to LNPTS1
	do STATCK^LNPTS1(.ln, .ttx, 1)
	
	quit
	
	
public DCC(RecordLN ln)		// Loan account				/REF:RW

	/*
	Increment delinquency counters
	
	   These counters were not updated as part of normal end-of-day processing.  
	   Had this payment been applied on its effective date the counter might 
	   have been incremented.
	   FILE2^LNPTS3 will then use the data collected in DL, DP and DY arrays.
	*/
	
	type public Boolean ER
	type public Number DCC(), DL(), DP(), DY()
	type public String PRETRN()

	type Date FINYEL, FINYEL2, NJD
	type Number CNTR

	if ln.dist1nd '< PRETRN("DIST1ND") quit
	
	// Collect initial data inside DCC, DL, DP and DY arrays
	do DCC^LNPTS2A(.ln)
	
	set FINYEL = CUVAR.FINYEL
	set FINYEL2 = FINYEL.nextFreqDate("-1YA") quit:ER
	
	for CNTR = 1:1:7 do { quit:ER
	
		if DCC(CNTR).isNull() quit 
	
		/*
		For each due date that was satisfied by the original payment,
		interrogate each delinquency counter.  (The payment may
		have satisfied multiple due dates.)
		*/
	
		set NJD = ln.dist1nd 

		#IF 'CUVAR.DCCUP
			// Update each counter for only the oldest delinquent bill
			do DCCUPD
		#ENDIF
		
		#IF CUVAR.DCCUP=1
			// Update each counter for all delinquent bills
			for  do DCCUPD set NJD = NJD.nextFreqDate(ln.dist1fre) if ER ! (NJD '< PRETRN("DIST1ND")) quit
		#ENDIF
		}
	quit
	

DCCUPD	// Increment delinquency counters for a specified category and due date

	type public Date NJD, FINYEL, FINYEL2
	type public Number CNTR, DCC(), DL(), DP(), DY()

	// Find out if this counter should have been incremented
	if (NJD + DCC(CNTR)) '> %SystemDate do {
	
		// Determine if it had not been incremented
		if (NJD + DCC(CNTR)) > %EffectiveDate do {
	
			// Always increment the counter for LTD and YTD
			set DL(CNTR) = DL(CNTR) + 1
					
			// Date occurs after CUVAR.FINYEL, update current year bucket
			if (NJD+DCC(CNTR)) > FINYEL set DY(CNTR) = DY(CNTR) + 1 quit
					
			// Date occurs before CUVAR.FINYEL, and falls in that prior fin. year
			else  if ((NJD+DCC(CNTR)) '> FINYEL),((NJD+DCC(CNTR)) > FINYEL2) set DP(CNTR) = DP(CNTR) + 1

			// Otherwise, the date would have fallen prior to the end of the
			// previous financial year; only the life counters should be incremented.
			}
		}
	
	quit
	 

LDHISSEC(Number CID,		// Account number
	 Number HSEQ,		// History sequence
	 RecordTTX ttx)		// Transaction			/REF:R

	/*
	Load History secondary levels
	
              This function will build a HIST entry for the secondary
	        portion of history.  The amts which are stored in piece
	        three(#) of each field are subtracted from themselves
	        to make the BALINT value correct when it is calculated
	        using within UAVB.
	
	   EXAMPLE:
	
	   HIST(p1,SEQ,TRC)="#P#-500"
	
	Example of secondary payoff entry in history: 
	^HIST(7872,15,2)=7872|0000001|RMC|50#####50||BATCH|LNFEE#OPCHG:50~LNFEEIN#OPCHG:50||1||||||0||USD|||||||||||||||USD
                      2.01)=58001|1000001|LPOC|50||BATCH|||1|||||||||||0||||||||||||USD


	*/

	type String REC
	
	type DbSet histsbrs = Db.selectDbSet("HISTSB","CID=:CID AND SLSEQ=:HSEQ AND SLSEQ>.9999 AND SLSEQ<2")
	
	while histsbrs.next() do {
		
		type RecordHISTSB histbil1 = histsbrs.getRecord("HISTSB")
		type RecordHISTSB histnew = histbil1.copy(0)
		
		set histnew.cid = histbil1.cid
		set histnew.sln = ttx.tseq
		set histnew.slseq = histbil1.slseq
		
		do {
			if +histnew.pe01amt '= 0 do {
				set REC = histnew.pe01
				set REC.piece("#", 3) = "-"_histnew.pe01amt
				set histnew.pe01 = REC
				}
				
			if histnew.pe02.isNull() quit
			
			if +histnew.pe02amt '= 0 do {
				set REC = histnew.pe02
				set REC.piece("#", 3) = "-"_histnew.pe02amt
				set histnew.pe02 =REC
				}

			if histnew.pe03.isNull() quit

			if +histnew.pe03amt '= 0 do {
				set REC = histnew.pe03
				set REC.piece("#", 3) = "-"_histnew.pe03amt
				set histnew.pe03 = REC
				}

			if histnew.pe04.isNull() quit

			if +histnew.pe04amt '= 0 do {
				set REC = histnew.pe04
				set REC.piece("#", 3) = "-"_histnew.pe04amt
				set histnew.pe04 = REC
				}

			if histnew.pe05.isNull() quit

			if +histnew.pe05amt '= 0 do {
				set REC=histnew.pe05
				set REC.piece("#", 3) = "-"_histnew.pe05amt
				set histnew.pe05 = REC
				}
			}
			
		do histnew.bypassSave()
		}

	quit

	
BALCMP(RecordLN ln)		// Loan account				/REF:RW

	// Reset SCHBAL and BALCOL
	
	type public String PRETRN()
	type Number BALCMP
	
	set BALCMP = ln.bal
	
	if ln.aruf set BALCMP = BALCMP - ln.udbal
	
	set ln.balcol = BALCMP
	
	if ln.revf set ln.schbal = BALCMP
	
	// Limit processing
	#IF CUVAR.LIMPRO=1 if (ln.bal > PRETRN("BALCMP")) do INIT^PROCLIM

	quit
	
	
INTDEF(RecordLN ln,			// Loan account			/REF:RW
       RecordLNBIL1 lnbil1,		// Bill detail			/REF:R
       Number BSEQ)			// Billing sequence

	/*
	   Do not calculate INTDEF and INTDEFTX if not calculated interest and 
	   not anticipated.  
	   E.g. do not calculate if paying the accrual balance.
	*/

	type public Number AMT,CID,ER,PEOAD,PEOAB,YEOFF
	type public String PCM
	type public Date CUVAR2,FINB,FINE
	 
	if 'PCM.extract(2),'PCM.extract(4) quit 
	
	type Date JD,NJD,PTR,X
	type Number DEF
	type String BILSUB,FRE
	
	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0","CID = :CID", 1)
	
	if 'lnbil0.getMode() quit
	
	set FRE = ln.dist1fre
	
	set BILSUB = $$BIL0^BILFUNCS(.lnbil0,"I")
	set PTR = BILSUB.piece("#",4)
	if 'PTR.isNull() set FRE = $select(PTR=1:ln.dist1fre,PTR=2:ln.dist2fre,PTR=3:ln.dist3fre,PTR=4:ln.dist4fre,1:"")
		
	set JD = lnbil1.cdpd
	
	// Arrears
	if 'ln.icm do { quit:ER
	
		set FRE = "-"_FRE
		
		set NJD = JD.nextFreqDate(FRE) quit:ER
		
		set X = JD
		
		set JD = NJD
		
		set NJD = X
		}
	// Advance
	if ln.icm set NJD = JD.nextFreqDate(FRE) quit:ER 
	
	/*
	JD to NJD is the pay period.  Calculate deferred interest based on
	the number of days into the next fin. year that interest is due for this
	pay period.
	*/

	// Pay period resides completely within current fin. year
	if (NJD '> FINE) quit

	// Period is completed in fin. next year, use full amount
	if (JD > FINE) set DEF = AMT
	
	else  do {
		
		type Number AMTSAT, CURYRINT, FACTOR, NXTYRINT
		type String SUBELE
		
		set FACTOR = (NJD - FINE - 1) / (NJD - JD)
	
		/*
		The following code will determine the amount of the interest
		payment that should be credited for current fin. yr's int vs. 
		next fin. yr's int.  The code's intent is to set variable DEF,
		which reflects the amount of interest deferred until the next
		fin. year.  DEF is set once the current year's exected interest
		amount has been satisfied.
		*/
		
		// Returns subfield for the element in the payment record
		set SUBELE = $$SUB^BILFUNCS("I", .lnbil1)

		// Total Int Amt Billed
		set PEOAB = SUBELE.piece("#", 3)

		// Amt of Billed Int still due
		set PEOAD = SUBELE.piece("#", 4)

		// Total possible next fin. year int
		set NXTYRINT = (PEOAB * FACTOR).roundCur()

		// Total possible current financial year int
		set CURYRINT = PEOAB - NXTYRINT

		// Amt of Int the payment satisifed
		set AMTSAT = PEOAB - PEOAD

		if (AMTSAT '< CURYRINT) set DEF = AMT quit
		
		if (AMTSAT < CURYRINT) do { quit
			
			if ((AMTSAT + AMT) '> CURYRINT) set DEF = 0 quit
			
			if ((AMTSAT + AMT) > CURYRINT) set DEF = AMTSAT + (AMT - CURYRINT)
			}
		}
  	
	// Adjust (put back) deferred amount that was "taken out" by
	// section INT
	if (YEOFF)&(%EffectiveDate < FINB)&(CUVAR2 '> (FINB + YEOFF - 1)) set ln.ipy = ln.ipy + DEF
	else  set ln.iytd = ln.iytd + DEF
	
	set ln.intdef = ln.intdef - DEF

	do INTDEFTX(.ln, PEOAB, PEOAD, NJD, JD)

	quit
	
	
INTDEFTX(RecordLN ln,		// Loan account				/REF:RW
	 Number PEOAB,
	 Number PEOAD,
	 Date NJD,
	 Date JD)

	// tax year calculations

	type public Number AMT, CID, TAXYEOFF
	type public Date CUVAR2, TAXB, TAXE
	type Number DEFTX
	
	// pay period resides completely within current tax year
	if NJD '> TAXE quit

	// period is completed in tax next year, use full amt.
	if JD > TAXE set DEFTX = AMT
	else  do {
		type Number AMTSAT, CURTXYRINT, FACTORTX, NXTTXYRINT
	
		set FACTORTX = (NJD - TAXE - 1) / (NJD - JD)
		/*
		The following code will determine the amount of the interest
		payment that should be credited for current tax yr's int vs.
		next tax yr's int.  The code's intent is to set variable DEFTX,
		which reflects the amount of interest deferred until the next
		tax year.  DEFTX is set once the current year's exected interest
		amount has been satisfied.
		*/

		// Total possible next tax year int
		set NXTTXYRINT = (PEOAB * FACTORTX).roundCur()

		// Total possible current tax year int
		set CURTXYRINT = PEOAB - NXTTXYRINT

		// Amt of Int the payment satisifed
		set AMTSAT = PEOAB - PEOAD

		if AMTSAT '< CURTXYRINT set DEFTX = AMT quit
		if AMTSAT < CURTXYRINT do { quit
			if (AMTSAT + AMT) '> CURTXYRINT set DEFTX = 0 quit
			if (AMTSAT + AMT) > CURTXYRINT set DEFTX = AMTSAT + AMT - CURTXYRINT
			}
		}
	// Adjust (put back) deferred amount that was "taken out" by section INT

	if (TAXYEOFF) & (%EffectiveDate < TAXB) & (CUVAR2 '> (TAXB + TAXYEOFF - 1)) set ln.ipty = ln.ipty + DEFTX
	else  set ln.itytd = ln.itytd + DEFTX
	set ln.intdeftytd = ln.intdeftytd - DEFTX
	
	quit


EXTPMT(RecordLN ln,		// Loan account				/REF:RW
       RecordTTX ttx) 		// Transaction				/REF:R
     
	// Extension Payments

	type public Boolean EXTFLG
	type public Number ER, TAMT
	
	quit:'ttx.tso.isLike("%EXTLDT%")
	
	set ln.mdt = ln.mdt.nextFreqDate("-"_ln.dist1fre) quit:ER
	
	// Last Extension Date
	set ln.extldt = $$FIELD^UTSO(ttx.tso, "EXTLDT")

	// Total Number of Extension Payments
	set ln.exttot = ln.exttot - 1

	// Total Amount of Extension Payments
	set ln.extamt = ln.extamt + TAMT	

	set EXTFLG = 1
	
	quit
	
	
EXPCOM(RecordLN ln,		// Loan account				/REF:R
       RecordTRN trn,		// Transaction code			/REF:R
       RecordTTX ttx)		// Transaction				/REF:R

	// Set TSO field to contain adjustment for committed exposure

	type public String TAMT
	
	type Number ADJ,BALCMP,PRN
	
	// Exclude CBL loans
	if 'ln.trb quit

	set PRN = TAMT.piece("#",2) + TAMT.piece("#",5)
	
	set BALCMP = ln.bal
	
	if ln.aruf set BALCMP = BALCMP - ln.udbal
	
	set ADJ = 0
	
	if 'trn.pcf, ((BALCMP - PRN) > ln.crlmt) do {

		set ADJ = PRN
		
		if (BALCMP < ln.crlmt) set ADJ = (BALCMP - PRN) - ln.crlmt
		}
		
	// Decrease
	else  if (BALCMP > ln.crlmt) do {
		
		set ADJ = -PRN
		
		if (BALCMP + PRN) < ln.crlmt set ADJ = BALCMP - ln.crlmt
		}
		
	// Increase	
	if ADJ set ttx.tso = $$FIELDIN^UTSO(ttx.tso, "EXPCOM", ADJ)
	
	quit
	
	
public LLCR(RecordLN ln,	// Loan account				/REF:RW
	    RecordTTX ttx,	// Transaction				/REF:R
	    RecordTRN trn)	// Transaction code			/REF:R

	/* 
	   This subroutine will set a flag that will be used to
	   reverse/error correct the LLCR transaction.
	*/

	type Boolean LLCR
	
	set LLCR = 1
	
	do LNPTSR(.ln,.ttx,.trn)
	
	quit
	

public FISCAL(RecordLN ln,		// Loan account			/REF:RW
	      Date %EffectiveDate)	// Effective date
	
	type public Date CUVAR2
	type public Number TYPE, YEOFF
	
	type Date FINB
	type Number BALCMP
	type String EFDYEAR
		
	if %EffectiveDate.get().isNull() set %EffectiveDate = %SystemDate
	if %EffectiveDate '< CUVAR2 quit 

	//First day of the current year
	set FINB = $$BOFY^SCADAT(CUVAR2,1)
	
	// Financial Year-end Offset
	if YEOFF.get().isNull() set YEOFF = CUVAR.YEOFF
	
	if CUVAR2 > (FINB + (YEOFF - 1)) quit
	
	if %EffectiveDate '< FINB quit 
	
	set EFDYEAR = %EffectiveDate.toString("YEAR")
	
	set BALCMP = ln.bal
	
	if ln.aruf set BALCMP = BALCMP - ln.udbal
	
	set ln.fisbal = 0
	set ln.fisint = 0

	type RecordLNYR lnyr = Db.getRecord("LNYR", "CID=:ln.cid,YEAR=:EFDYEAR", 1)

	set lnyr.fisbal = 0
	set lnyr.fisint = 0

	if Db.isDefined("UTBLFISBAL", "TYPE,""LN.BALCMP""") do UPDFISB(.lnyr, .ln, BALCMP)
	if Db.isDefined("UTBLFISBAL", "TYPE,""LN.PAPY""") do UPDFISB(.lnyr, .ln, ln.papy)
	if Db.isDefined("UTBLFISBAL", "TYPE,""LN.PPY""") do UPDFISB(.lnyr, .ln, -ln.ppy)

	if Db.isDefined("UTBLFISINT", "TYPE,""LN.IPY""") do UPDFISI(.lnyr, .ln, ln.ipy)
	if Db.isDefined("UTBLFISINT", "TYPE,""LN.PPY""") do UPDFISI(.lnyr, .ln, ln.ppy)
	if Db.isDefined("UTBLFISINT", "TYPE,""LN.FEEPY""") do UPDFISI(.lnyr, .ln, $$FEEPY)
	if Db.isDefined("UTBLFISINT", "TYPE,""LN.ASPY""") do UPDFISI(.lnyr, .ln, $$ASPY)
	if Db.isDefined("UTBLFISINT", "TYPE,""LN.DEDPPY""") do UPDFISI(.lnyr, .ln, $$DEDPPY^LNCDI(ln.cid))
	if Db.isDefined("UTBLFISINT", "TYPE,""LN.IBPY""") do UPDFISI(.lnyr, .ln, $$IBPY^LNCDI(ln.cid))
	if Db.isDefined("UTBLFISINT", "TYPE,""LN.COMPPY""") do UPDFISI(.lnyr, .ln, ln.comppy)

	do lnyr.bypassSave()
	
	quit
	
	
UPDFISB(RecordLNYR lnyr,	// Year-end loan account totals		/REF:RW
	RecordLN ln,		// Loan account				/REF:RW
	Number AMT)		// Fiscal balance amount

	// Updates Fiscal Balance
	
	set ln.fisbal = ln.fisbal + AMT
	set lnyr.fisbal = lnyr.fisbal + AMT
	
	quit
	

UPDFISI(RecordLNYR lnyr,	// Year-end loan account totals		/REF:RW
	RecordLN ln,		// Loan account				/REF:RW
	Number AMT)		// Fiscal interest amount

	// Updates Fiscal Interest

	set ln.fisint = ln.fisint + AMT
	set lnyr.fisint = lnyr.fisint + AMT
	
	quit
	

FEEPY()
	
	type public Number CID

	type Number TOT = 0

	type ResultSet rs = Db.select("FEEPY", "LNFEE", "CID=:CID")
	
	while rs.next() set TOT = TOT + rs.getCol("FEEPY")
	
	quit TOT
	
	
ASPY()	
	
	type public Number CID
	
	type Number TOT = 0
	
	type ResultSet rs = Db.select("ASPY", "LNFEE", "CID=:CID")
	while rs.next() set TOT = TOT + rs.getCol("ASPY")
	
	quit TOT
	
	
DLFP(RecordLN ln,		// Loan account				/REF:W
     RecordTTX ttx) 		// Transaction				/REF:R

	/*
	  Resets the date of last full payment with the old value
	  of LN.DLFP in case the transaction is reversed.
	*/
	
	type String DLFP
	
	set DLFP = $$FIELD^UTSO(ttx.tso,"DLFP")
	
	if 'DLFP.isNull() set ln.dlfp = DLFP
	
	quit
	 
	
IDGP(Number AMT)		// Principal Amount (positive)

	// Decrease principal repayment LNDS1.REPYMT

	type Date JD
	type Number ADJ
	
	set JD = %SystemDate + 1
	
	type DbSet rs = Db.selectDbSet("LNDS1", "CID = :CID AND SDD = :JD")
	
	while rs.next() do { quit:'AMT
		
		type RecordLNDS1 lnds1 = rs.getRecord("LNDS1")
				
		if (AMT > lnds1.repymt) set ADJ = lnds1.repymt
		else  set ADJ = AMT
		
		set lnds1.repymt = lnds1.repymt - ADJ
		
		set AMT = AMT - ADJ
		
		do lnds1.bypassSave()
		}
		
	quit
	

LPDT(RecordLN ln,		// Loan account				/REF:W
     RecordTTX ttx)		// Transaction				/REF:R

	/*
	Resets the date of last payment date with the old value
	of LN.LPDT in case the transaction is reversed or error corrected.
	*/
	type String LPDT
	
	set LPDT = $$FIELD^UTSO(ttx.tso, "LPDT")
	
	if 'LPDT.isNull() set ln.lpdt = LPDT
	
	quit
	
	
EUROCK(RecordTTX ttx)		// Transaction				/REF:R

	// Resets the status of a European Check
	
	type public Number CID, ER
	type public String OVR(,,)
	
	type String CHKNUM, CHKTYP, NEWSTAT
	
	set CHKNUM = $$FIELD^UTSO(ttx.tso, "CK")
	
	if CHKNUM.isNull() quit
	
	// Not a European Check Processing Acct
	quit:'$$EUROCHK^CHKPROC(CID)
	
	if ttx.itc6 do CHKACT^CHKPROC("EC", CHKNUM, CID, .CHKTYP, , .NEWSTAT) quit:ER
	
	if ttx.itc12 do CHKACT^CHKPROC("REV", CHKNUM, CID, .CHKTYP, , .NEWSTAT) quit:ER
	
	// Set up override and reset ER.
	// Transaction against check <INVCHK> cannot be processed.
	if ER.get() set ER = 0 set OVR(CID, "OVR", "INVCHK") = CHKNUM quit 

	type RecordCHECK check = Db.getRecord("CHECK", "CHKS = :CHKTYP, CHKNUM = :CHKNUM", 1)		

	set check.chksts = NEWSTAT

	do check.bypassSave()	
	
	quit 
	
PAYTOL( RecordLN ln, 		// Loan Account		RW
	RecordLNBIL1 lnbil1, 	// Loan Bill Record	RW
	Number BSEQ, 		// Bill Sequence No.	R
	String ELMNT)		// Payment Element	R
	
	/*
	 This section extracts the portions of a bill record that were previously
	 satisfied by loan payment tolerance functionality.  The element amount
	 satisfied is returned to the REVBIL2 section so that the amount is added 
	 back to the bill record that was satisfied by the payment being reversed.
	*/

	type public String IDP()

	type Number ELEAMT,I
	type String DATA

	set ELEAMT = 0

	type RecordLNBILTOL lnbiltol = Db.getRecord("LNBILTOL","CID=:ln.cid,SCHSEQ=:BSEQ",1)
	if 'lnbiltol.getMode() quit 0	// No Pmt Tolerance record for this sequence
	
	// IDP loan & element is I or P - Add whole P&I amount back
	if IDP(BSEQ),((ELMNT="I")!(ELMNT="P")) set ELEAMT = lnbiltol.cpid
	else  do {
		
		type RecordLNBIL1 biltmp = lnbiltol.copy()
		
		for I=1:1:20 do {

			set DATA = $$GETFIELD^BILFUNCS(I,.biltmp)

			if DATA.piece("#",1)'=ELMNT quit	// Not the same element
			if 'DATA.piece("#",4) quit		// No amount due

			set ELEAMT = ELEAMT + DATA.piece("#",4)
		
			do SETELMT^BILFUNCS(.biltmp, ELMNT, "")
			}
		
		set lnbiltol = biltmp.copy()
		}
	
	set lnbiltol.casd = lnbiltol.casd - ELEAMT

	do lnbiltol.setMode(1)	// Force mode = 1, copy above sets mode to 0

	if lnbiltol.casd = 0 do {
		do Db.delete("LNBILTOL","CID=:ln.cid AND SCHSEQ=:BSEQ")
		}
	else  do lnbiltol.bypassSave()

	set ln.toldue = ln.toldue - ELEAMT
	
	/*
	 The following is only necessary when reversing a payment that
	 caused payment tolerance functionality to kick in, and a bill
	 was subsequently generated to include the tolerance due amount.
	 In that case, the bill w/ the tolerance amount will be deleted
	 by LNUEFD, but the tolerance due will already be zero, and should
	 not be driven negative.
	*/
	
	if ln.toldue < 0 set ln.toldue = 0

	quit ELEAMT
	
	

vSIG()	quit "60639^41894^Pat Kelly^59875"	// Signature - LTD^TIME^USER^SIZE
