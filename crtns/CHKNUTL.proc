CHKNUTL
	/*	CHKNUTL 	Public; CHECK NUMBER UTILITY

 	 PROCEDURE ID:	CHECK NUMBER UTILITY
 	     Original:	LAUL - 08/18/95
		 Date:	11/18/2002 - 9:47:17 AM
  
 	---- Comments --------------------------------------------------------
	This routine assumes a check number format "AA9999999" and skip
	the "AA0000000","AB0000000",... sequences.
		
	NOTE:  Because this procedure makes very specific assumptions about
	       the formatting of check numbers, it is not general and its
	       use of $A and $C is not Unicode compliant.  If needed for an
	       environment that will use non-ASCII check numbers, it must
	       be rewritten (or custom code used).
 
 
 	---- Revision History ------------------------------------------------

	07/28/06 - KELLYP - CR 22048
		   Modified CNVNUM section to eliminate PRECEDENCE warnings.

 	07/10/06 - RussellDS - CR22121
 		   Added note, above, that not Unicode compliant.
 		   
 		   Cleaned up some comments.
 		   
 		   Removed old revision history.

	-----------------------------------------------------------------------
	
	*/

	quit
	
public	INVFMT(CHKNUM)
	/*
	
	ARGUMENTS:
	. CHKNUM Check number		/TYP=T/REQ

	*/
	// invalid check number
	if CHKNUM'?2U7N set ER=1 set RM=$$^MSG(1277) quit 1    
	
	// invalid check number
	if +$E(CHKNUM,3,9)=0 set ER=1 set RM=$$^MSG(1277) quit 1   
	
	quit 0
	
public	CHKPRV(CHKNUM,CHKCNT)	// Return the previous "CHKCNT" check from check number "CHKNUM"	
	/*
	ARGUMENTS:
	
	INPUT:
	.CHKNUM - Check number			/TYP=T/REQ

	RETURNS:	   
	
	. CHKCNT - Number of checks to process. /TYP=N
			Default = 1
	
	*/
	set:$G(CHKCNT)="" CHKCNT=1

	quit $$CHKNXT($G(CHKNUM),-CHKCNT)
	
public CHKNXT(CHKNUM,CHKCNT)	// Return the previous "CHKCNT" check from check number "CHKNUM"	
	/*
	ARGUMENTS:
	
	INPUT:
	.CHKNUM - Check number			/TYP=T/REQ

	RETURNS:	   
	. CHKCNT - Number of checks to process. /TYP=N
	
	*/
	new AUX,CHKAUX

	quit:$$INVFMT(CHKNUM) ""
	
	if $G(CHKCNT)="" set CHKCNT=1
	set AUX=1E7
	
	quit $$CNVTXT($$CNVNUM(CHKNUM)+CHKCNT)
	
public	CHKRNG(CHKNUM,CHKCNT)	
	/*
	
	   Return the next "CHKCNT" check from check number "CHKNUM" and one
	   array with all the numbers
	
	ARGUMENTS:
	
	INPUT:
	. CHKNUM - Check number			/TYP=T/REQ

	RETURNS:	   
	. CHKCNT - Number of checks to process. /TYP=N
			
	*/

	quit:$$INVFMT(CHKNUM) 
	
	if $G(CHKCNT)="" set CHKCNT=1
	
	do CHKJMP(CHKNUM,.CHKCNT,1,1)
	
	quit 
	

public	CHKCNT(CHKINI,CHKEND)	// Return the number of checks between a range	
	/*
	ARGUMENT:

	. CHKINI Starting Check number		/TYP=T/REQ

	. CHKEND Ending Check number		/TYP=T/REQ

	RETURNS:
	
	. CHKARR - Variable/Array with the check's number
	
	*/
	
	quit:$$INVFMT(CHKINI) ""
	quit:$$INVFMT(CHKEND) ""
	
	new FIRSTINI,LASTINI,FIRSTEND,LASTEND,GRPINI,GRPEND,CHKARR
	new SEQINI,SEQEND,AUX
	
	if CHKINI]CHKEND do {
		set AUX=CHKINI
		set CHKINI=CHKEND
		set CHKEND=AUX
		}
	
	set AUX=1E7                            // Number of "0000000"
	
	set GRPINI=$E(CHKINI,1,2)
	set SEQINI=+$E(CHKINI,3,9)
	set GRPEND=$E(CHKEND,1,2)
	set SEQEND=+$E(CHKEND,3,9)
	
	set FIRSTINI=$E(GRPINI)
	set LASTINI=$E(GRPINI,2)
	set FIRSTEND=$E(GRPEND)
	set LASTEND=$E(GRPEND,2)
	
	set CHKARR=($A(FIRSTEND)-$A(FIRSTINI))*26*(AUX-1)
	
	set CHKARR=CHKARR+(($A(LASTEND)-$A(LASTINI))*(AUX-1))
	
	set CHKARR=CHKARR+((SEQEND-SEQINI)+1)
	
	quit CHKARR
	
CHKJMP(CHKNUM,CHKCNT,CHKRNG,JMPTYP)	
	/*
	ARGUMENTS:
	
	INPUT:
	. CHKNUM - Check number			/TYP=T/REQ

	. CHKRNG - Build checks array flag	/TYP=L
		Default = 0
	. CHKCNT - Number of checks to process. /TYP=N

	. JMPTYP - Next/Previous check		/TYP=L
		Default = 1
		"1"  - Next check
		"-1" - Previous check
	RETURNS:	   
		
	. CHKARR - Variable/Array with the check's number

	
	*/
	if '$G(JMPTYP) set JMPTYP=1
	
	new GRP,SEQ,CNT,AUX,FIRST,LAST
	
	set AUX=1E7                            // Number of "0000000"
	
	set GRP=$E(CHKNUM,1,2)
	set SEQ=$E(CHKNUM,3,9)
	
	set FIRST=$A($E(GRP))
	set LAST=$A($E(GRP,2))
	
	for CNT=1:1:CHKCNT do { quit:$G(ER) 
	
		if JMPTYP=1 do {
			if +SEQ=(AUX-1) do { quit:$G(ER)
				set SEQ=0
				do JMPGRP(1)
				}  
			set SEQ=SEQ+1                        // Skip "0000000"
			}
		else  do {
			if +SEQ=1 do { quit:$G(ER)
				set SEQ=AUX
				do JMPGRP(-1)
				}
				 
			set SEQ=SEQ-1                        // Skip "0000000"
			}
	
		quit:$G(ER) 
	
		set CHKNUM=$C(FIRST)_$C(LAST)_$TR($J(SEQ,7)," ",0)
	
		set:CHKRNG CHKARR(CNT)=CHKNUM
		}
	
	if $G(ER) do { quit
		kill CHKARR
		set CHKARR=""
		} 
	
	set CHKARR=CHKNUM
	
	quit 
	
JMPGRP(JMPTYP)
	/* 
	The Next/Previous sequence for a group
	
	. JUMTYP - Group Prev/Next	/TYP=N/REQ
	"1"  Next Group - Default
	"-1" Previous Group
	
	*/

	set:'$G(JMPTYP) JMPTYP=1
	
	if JMPTYP=1 do {                       // Next Group
		set LAST=LAST+1
		if LAST=91 do {
			set FIRST=FIRST+1
			set LAST=65
			}
		}
	else  do {                             // Previous Group
		set LAST=LAST-1
		if LAST=64 do {
			set FIRST=FIRST-1
			set LAST=90
			}
		}
	
	// invalid check range
	if FIRST<65!(FIRST>90) do {
		set ER=1
		set RM=$$^MSG(8705)
		}
	quit 
	
CNVNUM(CHKNUM)	

	/*
	
	   CHKNUM - Check Number - "AA0000001"	/TYP=T/REQ
	
	*/
	new CHKVAL
	
	// First letter
	set CHKVAL=($A($E(CHKNUM))-65)*26*AUX
	// Second letter
	set CHKVAL=CHKVAL+(($A($E(CHKNUM,2))-65)*AUX)
	// Numbers
	set CHKVAL=CHKVAL+($E(CHKNUM,3,$L(AUX)+1))
	
	// To skip the "XX0000000" sequences
	
	set CHKVAL=CHKVAL-(CHKVAL\AUX)
	
	quit CHKVAL
	
CNVTXT(CHKVAL)	

	//   CHKVAL - Number returned by $$CHKNUM

	//Invalid check range	
	if CHKVAL<1!(CHKVAL>(26*26*(AUX-1))) do { quit ""
		set ER=1
		set RM=$$^MSG(8705)
		}
	
	new CHKNUM
	
	// To count with the "XX0000000" sequences
	
	set CHKVAL=CHKVAL+((CHKVAL-1)\(AUX-1))
	
	set CHKNUM=$C((CHKVAL\(26*AUX)#26)+65)
	// First letter
	set CHKVAL=CHKVAL#(26*AUX)
	// Second letter
	set CHKNUM=CHKNUM_$C(CHKVAL\AUX+65)
	// Numbers
	set CHKNUM=CHKNUM_$TR($J(CHKVAL#AUX,$L(AUX)-1)," ",0)
	
	quit CHKNUM
	

	

vSIG()	quit "60477^65441^Pat Kelly^5581"	// Signature - LTD^TIME^USER^SIZE
