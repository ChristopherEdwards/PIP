RGLSUM		
	/*
		ORIG:		Frank R. Sanchez (2497)
		Procedure ID: 	RGLSUM      
		DESC:		Accumulate G/L summary totals

	---- Revision History ------------------------------------------------

	04/10/07 - SmithCD - CR 24945
		   Modified DC section to set position 9 of TAMT (Negative Tax)
		   to 0 (debit) when the transaction itself is a debit. When 
		   the transactin is itself a credit, position 9 of TAMT 
		   remains a credit. The change is necessary to allow TAMT to 
		   balance within itself when posting interests with tax on 
		   negative interest.
	
	06/15/06 - TITOVE - CR 21449
		   Modified TGL section to properly increment TGL.DRAMT.
		   Corrected setting and comparing between DATETIME stamps
		   in POSITION. Corrected instantiation of UTBLGLSC table
		   in GLACN section. Modified NC not to quit prematurely,
		   if there are no new accounts, since we still need to 
		   process closed accounts, also corrected counting and
		   filing logic and removed NCFILE section. Removed tag M0
		   and double updates made to several MTD/YTD columns.
		   Cleaned up code in THR section.

	05/15/06 - RussellDS - CR21296
		   Changed to use cache array instead of %CACHE, which is
		   reserved for PSL record objects.

	04/11/06 - KELLYP - CR 20232
		   Modified entire procedure to remove references to CUVAR.GLCC 
		   which has been obsoleted.  The system will always operate as 
		   if CUVAR.GLCC="Y" (cost center reporting enabled).  

	03/27/06 - KinI - CR 20009
		   Modified position section to fix undefined lastpos variable.
		   Modified THR section to fix undefined seq.
		   
	03/02/06 - TITOVE - CR 19733
		   Modified fee section to instantiate an LNFEEP object with
		   a "create-if-needed" qualifier.
	*/
	
	quit


public SUMDTJ(RecordDTJ dtj,	// DTJ Record 
	      String cls,	// Product Class
	      Number XCID,	// Account Number 
	      Number tim,	// Time of Transaction
	      String grp,	// Group
	      Date SPD)  	// System Processing Date 	
	      
	/*
	   Summarize Daily Transaction Journal transaction data
	   
	   INPUTS:
	       . GLEFD 	G/L Effective Date Batch Option
	       . GLTS 	G/L Transaction Suspense Account

	   RETURNS:
	       . GLSC 	G/L Set Code Array

	*/

	new amt,bamt,cmt,dc,efd,glamt,glsc,itc,sec,trc,tso,uid,DATE,GLACN,POS,SRC,XBRCD,XCC,XCRCD,XETC

	set glsc=dtj.glsc
	set itc=dtj.itc
	set amt=dtj.tamt
	set efd=dtj.efd
	set tso=dtj.tso
	set cmt=dtj.tcmt
	set trc=dtj.trc
	set uid=dtj.uid
	set XBRCD=dtj.brcd
	set XETC=dtj.etc	
	set XCC=dtj.cc
	set XCRCD=dtj.crcd

	//exch rate 
	set rate=dtj.rate

	//system base equiv 
	set bamt=dtj.sysbase

	if XCRCD="" set XCRCD=%SystemCurrency

	if GLEFD,efd set DATE=efd
	else  set DATE=SPD
	
	// Update Limits tables
	new GRP,PRIN 
	set PRIN=$P(amt,"#",2)+$P(amt,"#",5) 
	set GRP=$G(grp)
	if cls="L",PRIN,GRP'="CBL" do UPD^CNTLIMEX(PRIN,itc,XCID,tso)

	if amt'["#" set $P(amt,"#",2)=amt
	set dc=+$E(itc) 
	set sec=$S($E(itc,7):1,1:0)

	// For DTJ transactions only
	set itc1=$E(itc,1)

	type RecordACN acn=Db.getRecord("ACN","XCID")

	if ('itc1), acn.mt900 do THR(.acn, 1, DATE ,XCID, tim, amt)
	if (itc1), acn.mt910 do THR(.acn, 0, DATE, XCID, tim, amt)

	do sum(SPD,XCID)
	
	quit


public SUMDMJ(RecordDMJ dmj,	// DMJ Record
	      String cls,	// Product Class 
	      Number XCID,	// Account Number
	      Number tim,	// Time of Transaction
	      String grp,	// Group
	      Date SPD)   	// System Processing Date 
	
	/*
	  Summarize  Daily Miscellaneous Journal transaction data

	   INPUTS:
	       . GLEFD 	G/L Effective Date Batch Option
	       . GLTS 	G/L Transaction Suspense Account

	   RETURNS:
	       . GLSC 	G/L Set Code Array
	*/

	new amt,bamt,cmt,dc,efd,glamt,glsc,itc,sec,trc,tso,uid,DATE,GLACN,POS,SRC,XBRCD,XCC,XCRCD,XETC
	
	set glsc=dmj.glsc
	set itc=dmj.itc
	set amt=dmj.tamt
	set efd=dmj.efd
	set tso=dmj.tso
	set cmt=dmj.tcmt
	set trc=dmj.trc
	set uid=dmj.uid
	set XBRCD=dmj.brcd
	set XCC=dmj.cc
	set XCRCD=dmj.crcd
	set XETC=dmj.etc

	//exch rate 
	set rate=dmj.rate

	//system base equiv 
	set bamt=dmj.sysbase

	if XCRCD="" set XCRCD=%SystemCurrency

	if GLEFD,efd set DATE=efd
	else  set DATE=SPD
	
	// Update Limits tables
	new GRP,PRIN 
	set PRIN=$P(amt,"#",2)+$P(amt,"#",5) 
	set GRP=$G(grp)

	if amt'["#" set $P(amt,"#",2)=amt
	set dc=+$E(itc) set sec=$S($E(itc,7):1,1:0)

	do sum(SPD,XCID)
	
	quit


private	sum(Date SPD,		// System Processing Date
	    Number XCID)	// Account Number

	/*
	  Summarize data into ^SYSBAL level 1 by currency code and tran code.
	  ^SYSBAL(TJD,1,XCRCD,XETC) = cnt1 | amt1 | cnt2 | amt2

	  where cnt1 = Number of primary transactions
		amt1 = Amount of primary transactions
		cnt2 = Number of secondary transactions
		amt2 = Amount of secondary transactions
	  ----------------------------------------------------------------------
	*/

	if cls="M" set SRC=2 do {
		
		/*
		If this transaction is a batch reject, use the tran code
		(i.e., the original tran code) saved in the source field.
		*/

		set x=$$FIELD^UTSO(tso,"ETC") 
		quit:x=""
		set XETC=x
		}
	else  set SRC=1
	
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
		
	type RecordSYSBAL1 sysbal1=Db.getRecord("SYSBAL1","SPD,XCRCD,XETC",1)

	if sec=0 do {
		set sysbal1.ppmcount=sysbal1.ppmcount+1
		set sysbal1.ppmamt=sysbal1.ppmamt+amt
		}
	if sec=1 do {
		set sysbal1.tcount=sysbal1.tcount+1
		set sysbal1.tamt=sysbal1.tamt+amt
		}
		
	do sysbal1.bypassSave()

	for POS=2:1:$L(amt,"#") do {
		set glamt=$P(amt,"#",POS) if 'glamt quit
		set dc=$$DC(cls,itc,POS,XCID)

		// Inter-Company Clearing
		do icc(.cuvar,SPD,XCID)

		if cls="L",(POS=6!(POS=13)) do fee(SPD) quit
		if cls="M" set GLACN=+XCID
		else  set GLACN=$$glacn
		do tgl(XCC,SPD)
		}

	do sumpos(.cuvar,SPD)

	quit


public	sumpos(RecordCUVAR cuvar,  // CUVAR Record
	       Date SPD)	   // System Processing Date 

	// Build position file for spot position transactions
	 
	// only if miscellaneous
	if cls'="M" quit
	
	if XCRCD=%SystemCurrency quit
	
	if $G(CO)="" set CO=cuvar.co
		
	new posimx,posotc,posspt
	
	set (posotc,posspt,posimx)=""

	type ResultSet crc=Db.select("OTCGL,SPOTGL,TFSGL","CRCD","CO=:CO AND CRCD=:XCRCD")
	if 'crc.isEmpty(),crc.next() do {

		// over the counter pos.
		set posotc=crc.getCol(1)

		// spot position.
		set posspt=crc.getCol(2)

		// imex pos.
		set posimx=crc.getCol(3)
		}

	// not a position acct
	if (XCID'=posotc)&(XCID'=posspt)&(XCID'=posimx) quit
	
	if XCID=posotc set poscid=posotc
	else  if XCID=posspt set poscid=posspt
	else  set poscid=posimx

	do position(uid,tim,XCRCD,poscid,efd,amt,itc,tso,bamt,SPD)

	kill poscid

	quit


private	icc(RecordCUVAR cuvar,	// CUVAR Record
    	    Date SPD,		// System Processing Date
    	    Number XCID)	// Account Number	     
    	    
	/*
	   Accumulate Inter-Company Clearing Accounts -- ^TGL level 9
	   
	   This level will only be created for a transaction which meets the
	   following criteria:
		 o  the posting cost center is different from the account's
		    cost center, and
		 o  the two cost centers are in different companies.

	  ----------------------------------------------------------------------
	   Post debit and credit to inter-company clearing accounts

	   Example:
		     Branch     Cost Center     Company
		     ------     -----------     -------
			1           111            A
			2           222            B

		     Account 11111 belongs to Branch 1 (associated to Company A).
		     A customer goes into Branch 2 (associated to Company B) and
		     deposits $500 in account 11111.

				 SD  11111  500  (credit)
				 CI  10000  500  (debit)

		     Two ^TGL level 9 records will be created for the savings
		     deposit transaction.

		     Debit the A-Clear-B inter-company account (44444).
		^TGL(TJD,9,XCRCD,date,44444,111,x)=11111|111|DR|500.00|||||222

		     Credit the B-Clear-A inter-company account (55555).
		^TGL(TJD,9,XCRCD,date,55555,222,x)=11111|111|CR|500.00|||||222

		 At the end of day, the A-Clear-B account will show up in
		 Company A's ^GLP and the B-Clear-A will show up in Company B's
		 ^GLP.
		 ----------------------------------------------------------------------
	*/

	new dc,pbcc,SRC

	if '$D(GLS) set GLS=cuvar.gls

	// Posting Branch Cost Center
	type RecordUTBLBRCD utblbrcd=Db.getRecord("UTBLBRCD","XBRCD")
	
	// Cost Centers aren't different
	if XCC=utblbrcd.ccdef quit

	// Posting Branch Cost Centers
	set pbcc=utblbrcd.ccdef

	// If no company associated with cost centers, use default company
	if $G(CO(XCC))="" set CO(XCC)=GLS
	if $G(CO(pbcc))="" set CO(pbcc)=GLS

	// Companies aren't different
	if CO(XCC)=CO(pbcc) quit

	// Create ^TGL level 9
	set SRC=9

	// Reverse debit/credit on account
	set dc='$$DC(cls,itc,POS,XCID)

	// Inter-company clearing account
	set GLACN=$G(ICC(CO(XCC),CO(pbcc)))

	new icc 
	if GLACN="" set icc=CO(XCC)_"/"_CO(pbcc)

	// Post A-Clear-B
	do tgl(XCC,SPD)

	// Change back to d/c on the account
	set dc='dc

	// Inter-company clearing account
	set GLACN=$G(ICC(CO(pbcc),CO(XCC)))
	
	new icc 
	if GLACN="" set icc=CO(pbcc)_" / "_CO(XCC)

	// Post B-Clear-A
	do tgl(pbcc,SPD)
	
	quit


public position(String uid,	// User ID
		Number tim,	// Transaction Processing Date/Time stamp
		String XCRCD,	// Currency Code
		Number poscid,	// Account Number
		Date efd,	// Transaction Effective Date
		Number amt,	// Transaction Amount
		String itc,	// Internal Transaction Code
		String tso,	// Transaction Source of Funds
		Number bamt,	// Base Amount
		Date SPD)	// System Processing Date

	// Build POSITION file with exchange accumulations by currency

	type Number lastpos, ptim, tsokey
	
	// Last time POSITION was built
	type ResultSet rs = Db.select("TIME", "POSITION", "TJD = :SPD")

	if rs.next() set lastpos = rs.getCol("TIME")

	// This record already in POSITION table
	if (lastpos.get() > tim) quit

	// Already in POSITION from TTXFDT
	if tso.get().isLike("%SPM%") quit

	// Today's transaction
	if efd.isNull() set efd = SPD
	
	// Date and time stamp
	set ptim = $$TIM^TGLMON("")
	
	// Debit or credit
	set pitc = 'itc.extract(1)

	// Transaction processing
	set tsokey = 1
	
	// Foreign payments
	if tso.isLike("%SPEC%") set tsokey = 2
	
	// Store individual position hits

	type RecordPOSITION position = Class.new("RecordPOSITION")
	
	set position.tjd = SPD
	set position.efd = efd
	set position.crcd = XCRCD
	set position.tsokey = tsokey
	set position.itc = pitc
	set position.time = ptim
	set position.cid = poscid
	set position.seq = Db.nextVal("POSITION","SPD,efd,XCRCD,tsokey,pitc,ptim,poscid")
	set position.tamt = +amt
	set position.bamt = +bamt
	set position.tso = tso
	set position.uid = uid

	do position.bypassSave()

	quit

	
private	fee(Date SPD)	// System Processing Date

	// Accumulate miscellaneous fee breakdown
	
	new FEETY,I,LNFE,Z

	set LNFE=$$FIELD^UTSO(tso,"LNFEE")

	for I=1:1 set Z=$P(LNFE,",",I) quit:Z.isNull()  do {
		
		set FEETY=$P(Z,":",1)
		set glamt=$P(Z,":",2)

		if 'FEETYP(FEETY).exists() do {
		
			type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP = :FEETY", 1)
			
			set FEETYP(FEETY) = lnfeep.glfr_"|"_lnfeep.glfdi
			}

		if POS=6 do {
			
			set GLACN=$P(FEETYP(FEETY),"|",1)
			
			if 'GLACN set GLACN=$$glacn
			}
		else  set GLACN=$P(FEETYP(FEETY),"|",2)
		
		do tgl(XCC,SPD)
		}
	quit


private	tgl(Number XCC,	// Cost Center
	    Date SPD)	// System Processing Date

	// Accumulate transactions into TGL table

	type public Boolean dc
	type public Date DATE
	type public Number bamt, glamt, GLACN, SRC
	type public String XCRCD, XETC

	set GLACN = $$ver(GLACN)

	type RecordTGL tgl = Db.getRecord("TGL", "TJD = :SPD, SRC = :SRC, CRCD = :XCRCD, EFD = :DATE, ACN = :GLACN, CC = :XCC", 1)
	
	if 'dc do {
		// Set count
		set tgl.drcnt = tgl.drcnt + 1
		// Set amount
		set tgl.dramt = tgl.dramt + glamt
		
		// Debit base amount  
		set tgl.drbseamt = tgl.drbseamt + bamt
		}
	if dc do {
		// Set count
		set tgl.crcnt = tgl.crcnt + 1
		// Set amount
		set tgl.cramt = tgl.cramt + glamt
		
		// Credit base amount 
		set tgl.crbseamt = tgl.crbseamt + bamt
		}

	do tgl.bypassSave()

	if (SRC = 2) do {
		
		type RecordTRN trn = Db.getRecord("TRN", "ETC = :XETC")
	
		// Detail G/L Transfer
		if trn.dtl do dtl(SPD)
		}

	if (SRC = 9) do dtl(SPD)
	
	quit


dtl(Date SPD)	// System Processing Date

	// Log "detail transactions"

	type RecordTGLDTL tgldtl=Class.new("RecordTGLDTL")
	
	set tgldtl.tjd=SPD
	set tgldtl.src=SRC
	set tgldtl.crcd=XCRCD
	set tgldtl.efd=DATE
	set tgldtl.acn=GLACN
	set tgldtl.cc=XCC
	set tgldtl.seq=Db.nextVal("TGLDTL","SPD,SRC,XCRCD,DATE,GLACN,XCC")
	set tgldtl.glacn=XCID
	set tgldtl.ccntr=XCC
	set tgldtl.trn=$S(dc:"CR",1:"DR")
	set tgldtl.tamt=glamt
	set tgldtl.cmt=cmt
	set tgldtl.uid=uid
	set tgldtl.trc=trc
		
	// Place posting branch cost center on detail information
	if SRC=9 set tgldtl.trc=pbcc			
		
	// File record
	do tgldtl.bypassSave()
	
	quit
	
	
	
ver(Number acn)		// G/L Account Number

	// Validate G/L account number
	
	type public String cache(,,,)

	new ER,RM

	set ER=0
	if acn="" set ER=1
	else  if $D(GL(acn)) set ER=GL(acn)
	else  do GLAD^TTXEXT(acn) set GL(acn)=ER

	if ER do {
		new desc

		// Invalid G/L account linkage -
		set desc=$$^MSG(4652)

		// ~p1 Fee Plan ~p2
		if cls="L",POS=6,SRC'=9 set desc=$$^MSG(4653,desc,FEETY)

		else  if cls="M" set desc=desc_" "_$S(SRC=9:icc,1:acn)

		else  do {
			if SRC=9,acn="" set desc=desc_" "_icc quit

			// ~p1 G/L Set Code ~p2
			new x 
			set desc=$$^MSG(4654,desc,glsc)

			set x=$P($G(cache("TGLMON", "GLDESC", cls, POS)),"|",1)
			
			if x'="" set desc=desc_" ("_x_")"
			}

		// Transaction suspense
		set acn=GLTS
		
		do EXC
		}
		
	quit acn


private	glacn()	// Get G/L account from G/L set code

	type public Number POS
	type public String cache(,,,), cls, glsc

	type String gldi
	
	type RecordUTBLGLSC utblglsc = Db.getRecord("UTBLGLSC", "GLSC = :glsc", 1)
	
	set gldi = cache("TGLMON", "GLDESC", cls, POS).get().piece("|", 3)
	
	if 'gldi.isNull() quit utblglsc.@gldi
	
	quit ""
	

public	DC(String cls,  // Class 
	  String itc,	// Internal Transaction Code
	  Number POS,	// Position
	  Number CID)	// Account Number	

	// Returns transaction amount component direction

	/*
	   If a loan or miscellaneous transaction, the direction of each
	   component is the same as the transaction itself.  For deposit
	   transactions, the direction depends upon the component.
	*/

	new x,TRB

	if cls="D" do {
		set TRB=0

		type RecordDEP dep=Db.getRecord("DEP","CID")
	
		// add check for POS=15, State Withholding Amount
		if (POS=5)!(POS=15) set TRB=dep.trb
	
		if TRB set x=$E($S($E(itc):" 1111101111  11001",1:" 0010010000  00000"),POS)
		else  set x=$E($S($E(itc):" 1111101111  11001",1:" 0011010000  01000"),POS)
		}
	else  set x=$E(itc)
	
	quit +x



public	MTD(Date SPD)	// Transaction Processing Date

	// Calculate Month-to-dates and Year-to-dates

	type Number CC, TYPE
	type String CLS, CRCD, GLSC, GRP

	type ResultSet rsttl = Db.select("TJD", "TTL",  "TJD=:SPD")
	
	// Count new and closed accounts and update TTL counters
	if rsttl.next() do NC(SPD)
	
	type ResultSet rs = Db.select("CRCD,CLS,GRP,TYPE,GLSC,CC", "TTL", "TJD=:SPD")
	
	while rs.next() do {
		
		set CRCD = rs.getCol("CRCD")
		set CLS = rs.getCol("CLS")
		set GRP = rs.getCol("GRP")
		set TYPE = rs.getCol("TYPE")
		set GLSC = rs.getCol("GLSC")
		set CC = rs.getCol("CC")
 		
		type RecordTTL ttl = Db.getRecord("TTL", "TJD = :SPD, CRCD = :CRCD, CLS = :CLS, GRP = :GRP, TYPE = :TYPE, GLSC = :GLSC, CC = :CC")
		
		// Get TTL record as of yesterday for accumulation updates
		type RecordTTL tty = Db.getRecord("TTL", "TJD = :SPD-1, CRCD = :CRCD, CLS = :CLS, GRP = :GRP, TYPE = :TYPE, GLSC = :GLSC, CC = :CC", 1)
				
		// If the First of Month, ignore Month-to-Date TTL data 
		// as of T-1 for a new accumulation
		if (+$$DAT^%ZM(SPD, "DD") = 1) do {
			
			set tty.mdrcnt = 0
			set tty.mdramt = 0
			set tty.mcrcnt = 0
			set tty.mcramt = 0
			set tty.mnew = 0
			set tty.mclosed = 0
			set tty.mtrin = 0
			set tty.mtrout = 0
			set tty.motrin = 0
			set tty.mctrout = 0
			
			// If the First of Year, also ignore Year-to-Date 
			// TTL data as of T-1 for a new accumulation
			if (+$$DAT^%ZM(SPD, "MM") = 1) do {
				
				set tty.ydrcnt = 0
				set tty.ydramt = 0
				set tty.ycrcnt = 0
				set tty.ycramt = 0
				set tty.ynew = 0
				set tty.yclosed = 0
				set tty.ytrin = 0
				set tty.ytrout = 0
				set tty.yotrin = 0
				set tty.yctrout = 0
				}				
			}
			
		// Add yesterday's MTD/YTD to today's figures for current MTD/YTD
		set ttl.mdrcnt = tty.mdrcnt + ttl.drcnt
		set ttl.mdramt = tty.mdramt + ttl.dramt
		set ttl.mcrcnt = tty.mcrcnt + ttl.crcnt
		set ttl.mcramt = tty.mcramt + ttl.cramt
		set ttl.mnew = tty.mnew + ttl.new
		set ttl.mclosed = tty.mclosed + ttl.closed
		set ttl.ydrcnt = tty.ydrcnt + ttl.drcnt
		set ttl.ydramt = tty.ydramt + ttl.dramt
		set ttl.ycrcnt = tty.ycrcnt + ttl.crcnt
		set ttl.ycramt = tty.ycramt + ttl.cramt
		set ttl.ynew = tty.ynew + ttl.new
		set ttl.yclosed = tty.yclosed + ttl.closed 
		set ttl.mtrin = tty.mtrin + ttl.trin
		set ttl.mtrout = tty.mtrout + ttl.trout
		set ttl.motrin = tty.motrin + ttl.otrin
		set ttl.mctrout = tty.mctrout + ttl.ctrout
		set ttl.ytrin = tty.ytrin + ttl.trin
		set ttl.ytrout = tty.ytrout + ttl.trout
		set ttl.yotrin = tty.yotrin + ttl.otrin
		set ttl.yctrout = tty.yctrout + ttl.ctrout	
				
		do ttl.save()
		}	
		
	quit


NC(Date SPD)	// Transaction Processing Date

	// Count new and closed accounts for today, file into TTL table

	type Number CC, CID, NC(,,,,,), NEWCL, TYPE
	type String CLS, CRCD, GLSC, GRP
	
	type ResultSet rsdtjna = Db.select("CLS,GRP,TYP,CID","DTJNA","TJD=:SPD AND (CLS='D' OR CLS='L')")	

	while rsdtjna.next() do {

		set CLS = rsdtjna.getCol("CLS")
		set GRP = rsdtjna.getCol("GRP")
		set TYPE = rsdtjna.getCol("TYP")
		set CID = rsdtjna.getCol("CID")

		type RecordACN acn = Db.getRecord("ACN", "CID = :CID")
		
		set CRCD = acn.crcd
		set GLSC = acn.glsc
		set CC = acn.cc

		set NC(CRCD,CLS,GRP,TYPE,GLSC,CC,0) = NC(CRCD,CLS,GRP,TYPE,GLSC,CC,0).get() + 1
			
		// Update Limits tables
		if (CLS = "L"), (GRP '= "CBL") do NC^CNTLIMEX(0, CRCD, CID)
		}

	type ResultSet rsdtjcl = Db.select("CLS,GRP,TYP,CID","DTJCL","TJD=:SPD AND (CLS='D' OR CLS='L')")

	while rsdtjcl.next() do {

		set CLS = rsdtjcl.getCol("CLS")
		set GRP = rsdtjcl.getCol("GRP")
		set TYPE = rsdtjcl.getCol("TYP")
		set CID = rsdtjcl.getCol("CID")
		
		type RecordACN acn = Db.getRecord("ACN", "CID = :CID")
 
		set CRCD = acn.crcd
		set GLSC = acn.glsc
		set CC = acn.cc

		set NC(CRCD,CLS,GRP,TYPE,GLSC,CC,1) = NC(CRCD,CLS,GRP,TYPE,GLSC,CC,1).get() + 1
					
		// Update Limits tables
		if (CLS = "L"), (GRP '= "CBL") do NC^CNTLIMEX(1, CRCD, CID)
		}
		
	set (CRCD,CLS,GRP,TYPE,GLSC,CC,NEWCL) = ""
	
	for  set CRCD = NC(CRCD).order() quit:CRCD.isNull()  do {
		for  set CLS = NC(CRCD,CLS).order() quit:CLS.isNull()  do {
			for  set GRP = NC(CRCD,CLS,GRP).order() quit:GRP.isNull()  do {
				for  set TYPE = NC(CRCD,CLS,GRP,TYPE).order() quit:TYPE.isNull()  do {
					for  set GLSC = NC(CRCD,CLS,GRP,TYPE,GLSC).order() quit:GLSC.isNull()  do {
						for  set CC = NC(CRCD,CLS,GRP,TYPE,GLSC,CC).order() quit:CC.isNull()  do {
							for  set NEWCL = NC(CRCD,CLS,GRP,TYPE,GLSC,CC,NEWCL).order() quit:NEWCL.isNull()  do {
							
								type RecordTTL ttl = Db.getRecord("TTL", "TJD = :SPD, CRCD = :CRCD, CLS = :CLS, GRP = :GRP, TYPE = :TYPE, GLSC = :GLSC, CC = :CC", 1)
							
								if (NEWCL = 0) set ttl.new = NC(CRCD,CLS,GRP,TYPE,GLSC,CC,NEWCL)
								
								if (NEWCL = 1) set ttl.closed = NC(CRCD,CLS,GRP,TYPE,GLSC,CC,NEWCL)
								
								do ttl.save()
								}
							}
						}			
					}
				}
			}
		}
	quit


EXC	// Log exceptions

	type public Number XCID
	type public String desc

	// Accumulate G/L Summary Totals
	do LOG^UTLEXC(%RoutineName, %SystemDate.toString(), $$^MSG(4651), XCID.get(), "", desc)

	quit


THR(RecordACN acn,	// Account
    Boolean DEB,	// MT900 vs. MT910 Indicator
    Date DATE,		// Processing Date
    Number XCID,	// Account Number
    String TIM,		// Transaction Date/Time Stamp
    Number AMT)		// Transaction Amount
    
	// Threshold Testing for MT900/MT910 Generation

	type Number THRAMT, XTIM, EXCAMT

	// MT900 Credit Threshold amount
	if DEB set THRAMT = +acn.mt900thr
	// MT910 Credit Threshold amount
	else  set THRAMT = +acn.mt910thr
 
	// No MT900/MT910 Threshold defined at account level
	if (THRAMT = 0) do {
		
		type RecordCIF cif = Db.getRecord("CIF", "ACN = :acn.acn")

		if DEB set THRAMT = +cif.mt900thr
		else  set THRAMT = +cif.mt910thr
		
		if THRAMT, 'cif.crcd.isNull(), (cif.crcd '= acn.crcd) do {
			
			do EXC^CRCDUTL(cif.crcd, acn.crcd, THRAMT, 1, 2, 11)
			
			set THRAMT = EXCAMT.get()
			}
		}
		
	if (AMT '< THRAMT) do {
	
		set XTIM = TIM.extract(6,TIM.length())
		
		if DEB do {

			type RecordSW900HST sw900hst = Class.new("RecordSW900HST")
			set sw900hst.dat = DATE
			set sw900hst.tim = XTIM
			set sw900hst.cid = XCID
			set sw900hst.tseq = Db.nextVal("SW900HST", "DAT=:DATE,TIM=:XTIM,CID=:XCID")
			set sw900hst.gen = 0
			do sw900hst.bypassSave()
			}
		else  do {

			type RecordSW910HST sw910hst = Class.new("RecordSW910HST")
			set sw910hst.dat = DATE
			set sw910hst.tim = XTIM
			set sw910hst.cid = XCID
			set sw910hst.tseq = Db.nextVal("SW910HST", "DAT=:DATE,TIM=:XTIM,CID=:XCID")
			set sw910hst.gen = 0
			do sw910hst.bypassSave()
			}
		}			
	quit
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60730^80376^Chad Smith^20519"	// Signature - LTD^TIME^USER^SIZE
