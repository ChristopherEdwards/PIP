SCA680	 /*
  ORIG: KELLYP - 04/13/2000
  DESC: Temp File Builder for SCA680 Report

  ---- Comments --------------------------------------------------------
   This program is called from the SCA680 report (after query pre proccessor) 
   to build an entry for each commitment, and for all of the accounts tied to 
   it, of a type specified in the report query.  The SCA680A global is used
   to store the commitment level data and the SCA680B global is used to store  
   data for each account.  
  ---- Revision History ------------------------------------------------
  08/02/05 - KUMARB - CR16684
	Modified section GETACCTS, changed the table name LNLCOM 
	to LN in Db.select
 
  07/10/00 - KELLYP - 35505:1
	Changed the "ztype" field references for the SCA680A and SCA680B
	tables to "lptype". 


  07/05/00 - KELLYP - 40816
	Created START section to handle the deletion of any entries left in 
	the SCA680A and SCA680B temp globals before and after running the 
	report.  Previously, the report's post-processor was killing these
	globals but was only doing so if the user exited on the last page of
	the report and was leaving data in the globals as a result.   		
 */

	quit 	// Dummy quit for compiler

START
	/* 
	 This section initializes the ^SCA680A and ^SCA680B globals by doing
	 a fast delete on them for the key value of $J.  It also handles the
	 call to URID for the SCA680 report and performs another fastdelete on
	 the aforementioned globals upon exiting the report.
	*/

	new RID,ZPID
	
	S ZPID=$J
	S RID="SCA680"

	do Db.fastDelete("SCA680A","ZPID")	// Kill existing temp entries
	do Db.fastDelete("SCA680B","ZPID")	// Kill existing temp entries 

	do DRV^URID				// Run the report

        do Db.fastDelete("SCA680A","ZPID")      // Kill existing temp entries
        do Db.fastDelete("SCA680B","ZPID")      // Kill existing temp entries

	quit  


PROC(XTYP,XPID)
	/*
	 This section retrieves all commitments of a specified type from the
	 XCLS global and calls the COMM section for each.
	*/

	new comms

	// Retrieve all Commitment CIDs from LN matching this type

	type ResultSet comms=Db.select("CID","LN","TYPE=:XTYP")
	if comms.isEmpty() quit
	while comms.next() do COMM(comms.getCol(1))

	quit

	
COMM(XCCL)
	/*
	 This section builds a SCA680A entry for the XCCL commitment parameter
	 and a SCA680B entry for each account tied to the specified commitment.
	*/

	new ACCTS,CBF,CDF,DATA,LNCID,tmpcomm,xcid

	set (ACCTS,xcid)=""
	do GETACCTS(.ACCTS,XCCL)	// Get all acct #'s linked to commitment
		
	set DATA=Db.getOneRow("CBF,CDF","LN","XCCL")
	set CBF=$P(DATA,$C(9),1)	// Commitment Billing Flag
	set CDF=$P(DATA,$C(9),2)	// Commitment Delinquency Flag
	type RecordSCA680A tmpcomm=Class.new("RecordSCA680A")
	do BLDCOMM(.tmpcomm)		// Get non-computed commitment data

	set LNCID=""
	for  set LNCID=$O(ACCTS(XCCL,LNCID)) quit:(LNCID="")  do {
		// Build SCA680B entry for each acct tied to commitment
		new rs
		type ResultSet rs=Db.select("CID,STAT,ORG,AVLBAL,BAL,DAA,ACR,NAINT,UNIN,DUPR,UNPR,MDT,SCHND,POAM,LPDT","LN","CID=:LNCID")
		if rs.isEmpty() quit		
		while rs.next() do BLDACCT(.rs,.tmpcomm)
		}		

	do tmpcomm.save()		 // Save commitment
	quit


GETACCTS(ACCTS,ZCCL)
	/* 
	 This section uses recursion to get all accounts linked to a commitment
	 no matter how many levels deep it may go.  Current system restriction
	 is 5 levels.  The accts parameter should initially be set to null 
	 before calling this section and should be passed in by reference
	
	 EXAMPLE:
		do GETACCTS^SCA680(.ACCTS,XCCL)

	 Will return the ACCTS global with the structure:
		ACCTS(Commitment #, Account Number 1)=""
		       		    Account Number 2)=""
				    Account Number 3)=""
	*/

        new rs
        type ResultSet rs=Db.select("CID","LN","CCL=:ZCCL")
 
        if rs.isEmpty() quit
 
        while rs.next() do {	// Add account to ACCTS var
                new XCID,XCPF
                set XCID=rs.getCol(1)
                set XCPF=Db.getOneRow("CPF","LN","XCID")
                set ACCTS(XCCL,XCID)=""
                if XCPF do GETACCTS(.ACCTS,XCID)  // Recursive Call
                }
        quit


BLDACCT(ResultSet rs,RecordSCA680A tmpcomm)
	/*
	 This section builds the SCA680B entry of each account tied to the
	 commitment.  It also computes some columns for the commitment by
	 summing account level data at the commitment level.
	*/

	new tmpacct

	type RecordSCA680B tmpacct=Class.new("RecordSCA680B")
	
	set tmpacct.pid=XPID
	set tmpacct.lptype=XTYP
	set tmpacct.ccl=XCCL
	set tmpacct.cid=rs.getCol(1)
	set tmpacct.stat=rs.getCol(2)
	set tmpacct.org=rs.getCol(3)
	set tmpacct.avlbal=rs.getCol(4)	
	set tmpacct.bal=rs.getCol(5)
	set tmpacct.daa=rs.getCol(6)
	set tmpacct.acr=rs.getCol(7)
	set tmpacct.naint=rs.getCol(8)
	set tmpacct.unin=rs.getCol(9)
	set tmpacct.dupr=rs.getCol(10)
	set tmpacct.unpr=rs.getCol(11)
	set tmpacct.mdt=rs.getCol(12)
	set tmpacct.schnd=rs.getCol(13)

	// Keep track of Commitment-Level information
	set tmpcomm.prbal=tmpcomm.prbal+tmpacct.bal
	set tmpcomm.poam=tmpcomm.poam+rs.getCol(14)
	set tmpcomm.daa=tmpcomm.daa+tmpacct.daa
	set tmpcomm.acr=tmpcomm.acr+tmpacct.acr
	set tmpcomm.naint=tmpcomm.naint+tmpacct.naint
	
	if CBF do {   	// Commitment Billing Flag
		set tmpcomm.comprdue=tmpcomm.comprdue+tmpacct.dupr
	        new lpdt
        	set lpdt=rs.getCol(15)
 	        if lpdt<tmpcomm.lpdt set tmpcomm.lpdt=lpdt
	        if tmpacct.schnd<tmpcomm.schnd set tmpcomm.schnd=tmpacct.schnd
		}

	if CDF do { 	// Commitment Delinquency Flag
		set tmpcomm.pdi=tmpcomm.pdi+tmpacct.unin
		set tmpcomm.pdp=tmpcomm.pdp+tmpacct.unpr
		}

	do tmpacct.save()	// Save account 
	quit


BLDCOMM(RecordSCA680A tmpcomm)
	/*
	 This section builds the commitment level of the SCA680A file for 
	 each commitment of the type specified in the report query.  Note
	 that some columns of the commitment record are computed for all 
	 accounts tied to the commitment in the BLDACCT section.
	*/

	new DATA2

        set tmpcomm.pid=XPID
        set tmpcomm.lptype=XTYP
        set tmpcomm.ccl=XCCL

	set DATA2=Db.getOneRow("NAM,STAT,OFF,CRLMT,IRN","LN","XCCL")
	set tmpcomm.name=$P(DATA2,$C(9),1)
	set tmpcomm.stat=$P(DATA2,$C(9),2)
	set tmpcomm.off=$P(DATA2,$C(9),3)
	set tmpcomm.commamt=$P(DATA2,$C(9),4)
	set tmpcomm.irn=$P(DATA2,$C(9),5)
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60114^39145^Balasubramonian Sankar^6090"	// Signature - LTD^TIME^USER^SIZE
