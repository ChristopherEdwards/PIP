public UARCHIST(Number OPTION)	// 0 = report, 2 = purge
	/*
	ORIG: CHENARD - February 18,1994

	This utility will manage the process of purging PROFILE account
	history records.

	EXAMPLE:
		do ^UARCHIST(1) ; Archives account history
		do ^UARCHIST(2) ; Purges account history

	LIBRARY:
		. $$EXEC Serves as primary execution point for the
		 archive/purge utility. Based on selection
		 criteria, get an account and process it.

		. ARCHV Processes a single account based upon the minimum
		 history to retain, whether to archive or purge,
		 and the current global directory to use for
		 archiving.

	-------Revision History-----------------------------------------------
	
	03/16/07 - RussellDS - CR26387
		   Re-implemented archiving, using new approach.  Now calls
		   ARCHIVE^DBARCHIVE to perform archive actions.
		   
		   Removed old revision history.
	
	03/18/06 - RussellDS - CR16892
		   Remove archiving features, but leave purge capability.
		   
		   Remove old revision history.
	*/
	
	type public String %DB, ER, RM()
	
	type Date CUTOFF
	type Number TYPE
	type String %READ, %TAB(), CLS, GRP, IO, PRGDIR, QRY, VFMQ, VQRY(,,), ZQRY
	
	if '(%DB.isNull() ! (%DB = "GTM")) do { quit
	
		set ER = 1
		// Only valid with a GT.M database
		set RM = $$^MSG(6900)
	}
	
	if (OPTION = 1), 'Db.isDefined("DBUTARCHIVE", "ARCHTBL='HIST'") do { quit
		
		set ER = 1
		// ~p1 is not an archived table
		set RM = $$^MSG(6901, "HIST")
	}

	set %TAB("CLS") = ".CLS3/XPP=D PPCLS^UARCHIST/TBL=[STBLCLS]:QU ""STBLCLS.CLS>A"""
	set %TAB("GRP") = ".A8/XPP=D PPGRP^UARCHIST/TBL=[STBLGRP]:NOVAL"
	set ZQRY = "[ACN]CLS=<<CLS>> AND [ACN]GRP=<<GRP>>"
	set %TAB("TYPE") = ".QI1/XPP=D PPTYP^UARCHIST/TBL=[ACN]TYPE:DISTINCT:NOVAL:QU ZQRY"
	set %TAB("CUTOFF") = ".CUTOFF/MAX="_(%SystemDate-1)

	set (GRP, TYPE) = ""
	set %READ = "@@%FN,,,CLS/REQ,GRP/REQ,TYPE/REQ,,CUTOFF"
	
	set IO = ""

	if (OPTION = 0) do {
		
		set %TAB("IO") = $$IO^SCATAB($I)
		set %READ = %READ_",,IO/REQ"
	}

	else  if (OPTION = 2) do {
		
		set %TAB("PRGDIR") = ".DIR3"
		set PRGDIR = CUVAR.SPLDIR
		set %READ = %READ_",,PRGDIR/REQ"
	}

	do ^UTLREAD quit:(VFMQ="Q")
	
	set ER = 0

	if (OPTION = 0), (IO '= $I) do OPEN^SCAIO quit:(ER > 0)
	
	set QRY = "CLS: "_CLS_"  GRP: "_GRP_"  TYPE:  "_TYPE

	set ER = $$EXEC(.RM(),.VQRY(,,), OPTION, CUTOFF, "", PRGDIR.get(), IO, QRY)
	if (ER = 0) set ER = "W"
	
	quit


EXEC(String RM(),	// Return message		/MECH=REFNAM:W
     String VQRY(,,),	// List of selected types
     Number OPTION,	// 0 = Report, 2 = Purge
     Number CUTOFF,	// Cutoff date
     Number XCID,	// Starting account number
     String PRGDIR,	// Directory to purge to
     String IO,		// Output device for report
     String QRY)	// Info on selection input

	/*
	Execute purge
	*/
	
	type public Number ER
	
	type Boolean SHUTDN
	type Number ARCHNUM, ARCHSEQ, ERRCNT, MINHIST, RECCNT, TOTCID, TOTREC, VTYPE
	type String ARCHDIR, ARCHTBL, VCLS, VGRP

	catch vERROR {
		
		type public Number %ZTSEQ

		do ZE^UTLERR
		// Host error number ~p1. Contact system manager.
		set RM=$$^MSG(1191,%ZTSEQ.get())
		
		quit 1
	}

	if CUTOFF.isNull() set MINHIST = 0
	else  set MINHIST = %SystemDate - CUTOFF
	
	set SHUTDN = 0

	set (ER, ERRCNT, TOTCID, TOTREC)=0

	if (OPTION = 0) do Db.fastDelete("SCA166", "PID=:%ProcessID")
	
	/* Handle archive setup:
		- Get archive directory info
		- Set up archive history entry
	*/
	if (OPTION = 1) do { quit:ER 1
		
		set ARCHTBL = "HIST"
		
	 	// Get archive information
        	#ACCEPT Date=03/01/07; Pgm=RussellDS; CR=25675; Group=Bypass
		#BYPASS
		set ARCHNUM=$ZTRNLNM("SCAU_ARCHIVE_CURRENT")
		set ARCHDIR=$ZTRNLNM("SCAU_ARCHIVE_"_ARCHNUM)
		#ENDBYPASS
		
		if (ARCHDIR.isNull() ! (ARCHNUM '> 0)) do {
		
			set ER = 1
			// Archive directory information missing
			set RM = $$^MSG(2)
		}
		
		type ResultSet rsarchist = Db.select("MAX(ARCHSEQ)", "DBARCHIST", "ARCHTBL=:ARCHTBL")
	
		if rsarchist.next() set ARCHSEQ = rsarchist.getCol(1) + 1
		else  set ARCHSEQ = 1
	
		type RecordDBARCHIST dbarchist = Class.new("RecordDBARCHIST", "ARCHTBL=:ARCHTBL,ARCHSEQ=:ARCHSEQ")
	
		set dbarchist.begdat = %CurrentDate
		set dbarchist.begtim = %CurrentTime
		set dbarchist.primcnt = 0
		set dbarchist.reccnt = 0
		set dbarchist.stopped = 0
		set dbarchist.thrudate = CUTOFF - 1
		set dbarchist.sel = "CID"
		set dbarchist.frm = "ACN"
		set dbarchist.whr = "UARCHIST QRY - "_QRY
	
		do dbarchist.save()
	}
	else  set (ARCHDIR, ARCHNUM) = ""
	
	set (VCLS, VGRP, VTYPE) = ""
	for  set VCLS = VQRY(VCLS).order() quit:VCLS.isNull()  do { quit:SHUTDN
		for  set VGRP = VQRY(VCLS, VGRP).order() quit:VGRP.isNull()  do { quit:SHUTDN
			for  set VTYPE = VQRY(VCLS, VGRP, VTYPE).order() quit:VTYPE.isNull()  do { quit:SHUTDN
				
				set RECCNT = 0
				
				do TYPE(OPTION, VTYPE, .TOTCID, .RECCNT, PRGDIR, .ERRCNT, MINHIST, .SHUTDN, ARCHNUM, ARCHDIR)
				
				set TOTREC = TOTREC + RECCNT
			}
		}
	}

	// Run the report
	if (OPTION = 0) do {
		
		type String PGM, RID
		
		set RID = "SCA166"
		do ^URID
		if PGM.isNull() do {
			
			type String ET = "INVLDRPT"
			
			do ^UTLERR
			set ER = 1
		}
		
		else  do {
	
			type String VRWOPT()
			
			set VRWOPT("NOOPEN") = 1
	
			set PGM = "V0^"_PGM
			
			do @PGM
		}
	}
	
	// Save archiving history
	if (OPTION = 1) do {
		
		type RecordDBARCHIST dbarchist = Db.getRecord("DBARCHIST", "ARCHTBL=:ARCHTBL,ARCHSEQ=:ARCHSEQ")
		
		set dbarchist.enddat = %CurrentDate
		set dbarchist.endtim = %CurrentTime
		set dbarchist.primcnt = TOTCID
		set dbarchist.reccnt = TOTREC
		if SHUTDN set dbarchist.stopped = 1
	
		do dbarchist.save()
	}
	
	if ER quit 1

	// Process shutdown: ~p1 VTYPE ~p2, account ~p3
	if SHUTDN set RM(1) = $$^MSG(6820, VGRP, VTYPE, XCID)
	// Process complete
	else  set RM(1) = $$^MSG(2237)
	// Record count: ~p1
	set RM(2) = $$^MSG(6821, TOTREC)
	// Errors: ~p1
	set RM(3) = $$^MSG(6819,ERRCNT)
	
	if SHUTDN quit 2
	
	quit 0


TYPE(Number OPTION,	// 0 = Report, 2 = Purge
     String VTYPE,	// Product type
     Number TOTCID,	// Total accounts		/MECH=REFNAM:RW
     Number RECCNT,	// Record count			/MECH=REFNAM:W
     String PRGDIR,	// Directory to purge to
     Number ERRCNT,	// Error count
     Number MINHIST,	// Days to keep
     Boolean SHUTDN,	// Shutdown flag
     Number ARCHNUM,	// Archive number
     String ARCHDIR)	// Archive directory
     
	/*
	Process accounts within product VTYPE
	*/
	
	type public Number ER
	type public String RM
	
	type IO io = Class.new("IO")
	type Boolean X
	type String COLLIST
	
	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE=:VTYPE")

	set RECCNT = 0
	
	if OPTION=2 do {
	
		set io.fileName = $$FILE^%TRNLNM("SAVHIST."_VTYPE, PRGDIR)
		set io.openParams = "NEWV/WRITE"
		set io.timeout = 5
	
		catch ioExc {
			// catch exception error
			if ioExc'["%PSL-E-IO" throw ioExc

			set ER = 1
			// Error opening ~p1. Process stopped for type ~p2
			set RM = $$^MSG(992, io.fileName, ioExc.type)
		}
		
		do io.open()
	
		// Write header info
		do io.write($$HEADER("HIST", .COLLIST()))
		do io.write($$HEADER("HISTDST", .COLLIST()))
		if (prodctl.cls = "L") do io.write($$HEADER("HISTLST", .COLLIST()))
		do io.write($$HEADER("HISTN", .COLLIST()))
		if (prodctl.cls = "L") do io.write($$HEADER("HISTSB", .COLLIST()))
	}
	
	type ResultSet rs = Db.select("CID", "ACN", "TYPE=:VTYPE", "CID ASC")
	while rs.next() do { quit:SHUTDN
		
		if (ERRCNT > 99) set SHUTDN = 1 quit
		
		// Keep going if error
		catch error {
			
			set ERRCNT = ERRCNT + 1
			
			do ZE^UTLERR
		}
	
		set TOTCID = TOTCID + 1
		do ARCHV(.prodctl, rs.getCol("CID"), .MINHIST, OPTION, io, .RECCNT, .COLLIST(), .SHUTDN, ARCHNUM, ARCHDIR)
	}

	if (OPTION = 2) do io.close()

	quit


ARCHV(RecordPRODCTL prodctl,
      Number XCID,
      Number MINHIST,
      Number OPTION,
      IO io,
      Number RECCNT,
      String COLLIST(),
      Boolean SHUTDN,
      Number ARCHNUM,
      String ARCHDIR)
      
	/*
	Move account history records to archive database or purge file.

	This subroutine will determine if history can be archived/purged based
	on the minimum number of days history to keep. Other criteria include the 
	statement last date, the service charge last date and the last updated
	passbook sequence.

	In order for a History record to qualify for purging, must pass the
	following checks:

		1. Minimum history to keep, based on the value in the product
		   table or, if greater than the value in the product table,
		   the number of days specified by parameter 'irahist' (if 
		   retirement account) or 'MINHIST' (if non-retirement
		   active/open account) or 'clohist' (if non-retirement closed
		   account).

		2. Statement last date, for statement accounts.  If history record
		   pre-dates the last statement date, it qualifies for archiving/
		   purging.

		3. Service charge last date, for accounts that have a service fee
		   plan.  If history record pre-dates the last service charge date,
		   it qualifies for purging.

		4. Last passbook update sequence, for passbook accounts only.  If
		   history record pre-dates the last posted passbook sequence, it
		   qualifies for purging.

		5. Last history record in production.  If the record that is about
		   to be archived is the only remaining record left in the
		   production history file, it will not be purged.
	*/
	
	type public String %INTRPT()
	
	type Date CUTOFF

	type RecordACN acn = Db.getRecord("ACN", "XCID")

	// If IRA account
	if (acn.cls = "D") do {
		
		type RecordDEP dep = {RecordDEP}acn
	
		if (dep.ira > 0) do {
			
			// Set cutoff date to TJD-IRAHIST if IRAHIST is defined, else ignore cutoff date
			#IF CUVAR.IRAHIST.isNull()
			set CUTOFF = 0
			#ELSE
			set CUTOFF = %SystemDate - CUVAR.IRAHIST
			#ENDIF
		}
	}

	if 'CUTOFF.exists() do {
		// Non-retirement account
		// Determine the cut-off date for the account; i.e. the latest
		// date that can qualify to be purged/archived.
		
		// Account closed
		if (acn.stat = 4) do {
			
			if prodctl.clohist.isNull() set CUTOFF = 0
			else  set CUTOFF = %SystemDate - prodctl.clohist
		}
		else  do {
			
			if (MINHIST > prodctl.minhist) set CUTOFF = %SystemDate - MINHIST
			else  set CUTOFF = %SystemDate - prodctl.minhist
		}
	}

	if acn.cls="D" do {
		
		type RecordDEP dep = {RecordDEP}acn
		
		if 'dep.feepln.isNull(), 'dep.scld.isNull(), (dep.scld < CUTOFF) set CUTOFF = dep.scld

		if dep.pbi do {
			
			if (dep.pbkseq > 0) do {

				type RecordHIST hist = Db.getRecord("HIST", "CID=:XCID,TSEQ=:dep.pbkseq")
				if (hist.tjd < CUTOFF) set CUTOFF = hist.tjd
			}
		}
		else  do {
			
			type Number CID
			type String SFRE, XCF01
			
			set CID = XCID
			do STM^DEPDI
			set SFRE = XCF01.get().piece("|", 4)
			if '(SFRE.isNull() ! (SFRE="1DA")) do {
			
				type Date SLDT = XCF01.piece("|", 2)
				
				if (SLDT < CUTOFF) set CUTOFF = SLDT
			}
		}
	}
	
	// Handle purge and report
	if ((OPTION = 0) ! (OPTION = 2)) do {
	
		type ResultSet rs = Db.select("TSEQ,TJD", "HIST", "CID=:XCID AND TJD <= :CUTOFF", "TSEQ ASC")
	
		while rs.next() do {
		
			type Number TSEQ
				
			set TSEQ = rs.getCol("TSEQ")

			set RECCNT = RECCNT + 1

			// Anticipated report
			if (OPTION = 0) do {
			
				type RecordSCA166 sca166 = Class.new("RecordSCA166", "PID=:%ProcessID, CID=:XCID, TSEQ=:TSEQ")
			
				do sca166.save()
			}

			// Write record(s) to output file and delete them
			else  if (OPTION = 2) do {
			
				do PURGE(.acn, TSEQ, io, .COLLIST())
			
				set acn.hisctf = CUTOFF
				do acn.save()
			}
		}
	}
	
	// Archive
	// To avoid warning if ARCHIVE^HISTFILE is not defined (HIST not archived)
	#ACCEPT Date=05/07/07; Pgm=RussellDS; CR=25675; Group=Access,Mismatch
	if (OPTION = 1) set RECCNT = RECCNT + $$ARCHIVE^HISTFILE(ARCHDIR, ARCHNUM, CUTOFF, XCID)
	
	// Check Interrupt status for stop
	if %INTRPT.data() > 1 do INTRPT^IPCMGR
	if '%INTRPT.get().isNull() do {
		
		if %INTRPT = "STOP" set SHUTDN = 1
			
		// Clear Interrupt indicator
		set %INTRPT = ""
	}
	
	quit


PURGE(RecordACN acn,	// Account record
      Number TSEQ,	// History record sequence
      IO io,		// Output file
      String COLLIST())	// Column list, by table
      
	/*
	Write history record and any related records.  The output format
	is the same as that used in LNPURGU.proc
	*/
	
	type Number CID = acn.cid

	do DATA(CID, COLLIST("HISTDST"), "HISTDST", "CID="_CID_" AND TSEQ="_TSEQ, io)
	do Db.fastDelete("HISTDST", "CID=:CID,TSEQ=:TSEQ")
	
	if (acn.cls = "L") do {
		
		do DATA(CID, COLLIST("HISTLST"), "HISTLST", "CID="_CID_" AND SLN="_TSEQ, io)
		do Db.fastDelete("HISTLST", "CID=:CID,SLN=:TSEQ")
	
		do DATA(CID, COLLIST("HISTSB"), "HISTSB", "CID="_CID_" AND SLN="_TSEQ, io)
		do Db.fastDelete("HISTSB", "CID=:CID,SLN=:TSEQ")
	}
	
	do DATA(CID, COLLIST("HIST"), "HIST", "CID="_CID_" AND TSEQ="_TSEQ, io)
	do Db.fastDelete("HIST", "CID=:CID,TSEQ=:TSEQ")
	
	do DATA(CID, COLLIST("HISTN"), "HISTN", "CID="_CID_" AND TSEQ="_TSEQ, io)
	do Db.fastDelete("HISTN", "CID=:CID,TSEQ=:TSEQ")
		
	quit
	
	
HEADER( String TABLE, 		// Table name
        String COLLIST())	// Column list
        
	/*
	Return file header info for this table
	*/
 	
	set COLLIST = $$COLLIST^DBSDD(TABLE, 1, 1, 1)
	set COLLIST(TABLE) = COLLIST

	quit (TABLE_9.char()_COLLIST.translate(",", 9.char()))
	
	
DATA(Number CID,	// Account number
     String COLLIST, 	// Column list for TABLE
     String TABLE, 	// Table name
     String WHERE,	// Where clause
     IO io)		// Output device
     
	/*
	Write the record(s)
	*/

	type String DATA

	#ACCEPT Date=03/19/2006; PGM=RussellDS; CR=19862
	type ResultSet rs = Db.select(COLLIST, TABLE, WHERE)
	
	while rs.next() do {

		type Row rw = rs.getRow()

		set DATA = TABLE_9.char()_CID_rw.toString()

		do io.write(DATA)
	}

	quit


PPCLS	// Post processor for Class

	type public String VQRY(), X
	
	if 'X.isNull() do {
	
		kill VQRY
		set VQRY(X) = ""
	}
	
	quit


PPGRP	// Post processor for GROUP

	type public String VQRY(,), X
	
	type String CLS
	
	set CLS = VQRY("").order()

	if (X = "ALL") do { quit

		type ResultSet rs = Db.select("DISTINCT GRP", "PRODCTL", "CLS=:CLS")
			
		while rs.next() set VQRY(CLS, rs.getCol("GRP")) = ""
	}
	
	else  if X.isLike("%,%") do {
		
		type Number I
		type String GRP
		
		for I = 1:1:X.length(",") do {
			
			set GRP = X.piece(",", I)
			if 'GRP.isNull() set VQRY(CLS, GRP) = ""
		}
	}
	
	else  do {
		
		type ResultSet rs = Db.select("DISTINCT GRP", "PRODCTL", "CLS=:CLS AND GRP=:X")
			
		if rs.next() set VQRY(CLS, X) = ""
	}

	quit


PPTYP	// Post processor for TYPE

	type public String VQRY(,,), X
	
	type String CLS
	
	set CLS = VQRY("").order()

	if (X = "ALL") do { quit
		
		type String GRP = ""
		
		for  set GRP = VQRY(CLS,GRP).order() quit:GRP.isNull()  do {

			type ResultSet rs = Db.select("DISTINCT TYPE", "PRODCTL", "CLS=:CLS AND GRP=:GRP")
			
			while rs.next() set VQRY(CLS, GRP, rs.getCol("TYPE")) = ""
		}
	}
	
	// Handle single value or list
	else  do {
		
		type Number I
		type String CLS, GRP
		
		for I = 1:1:X.length(",") do {
			
			type ResultSet rs = Db.select("CLS, GRP", "PRODCTL", "TYPE=:X")
			
			if rs.next() do {
				
				set CLS = rs.getCol("CLS")
				set GRP = rs.getCol("GRP")
				
				if VQRY(CLS, GRP).exists() set VQRY(CLS, GRP, X) = ""
			}
		}
	}
			
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60757^63085^Dan Russell^14490"	// Signature - LTD^TIME^USER^SIZE
