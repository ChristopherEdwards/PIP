public LNPTS1(RecordLN ln,		// Loan account			/REF:RW
	       RecordTTX ttx)		// Primary transaction		/REF:RW

	/*
	Loan Transaction Processing Controller Part 2 

	---- Revision History -------------------------------------------------
	05/17/07 - GIRIDHAL - CR 26692
		   Modified section HIS4 to alter the check for isSystemGenerated
		   with an additional check for ttx.itc7 for cases where the 
		   stored values are not set in EXEC^TRNDRV

	04/16/07 - VARGAJ - CR 24940
		   Change key structure of Check to support the check numbering
		   change of check activation. 

	01/30/07 - VARGAJ - CR 25139
		   In call CHKVER^CHKPROC changed SEQ parameter from HISTSEQ to
		   PTRC.	

	11/13/06 - KELLYP - CR 23888
		   Modified HIS4 section not to create a HISTLST record for
		   transactions that specify the offset trancode & acct number
		   in TSO.  The reversal of the offset for the transaction will
		   be handled by RUNHIST^LNUEFD and the creation of the HISTLST
		   record would cause the offset to be reversed twice and cause
		   an OOB, so the HISTLST record for the offset is not desired.
		   
	10/16/06 - SmithCD - CR 23395
		   Modified HIS4 section to set the related history sequence 
		   in histlst to the stored value for the history sequence of 
		   the current transaction instead of the most recent sequence 
		   in history. In cases where the secondary transaction itself 
		   spawned a file maintanance journal entry, the related 
		   history sequence of the secondary transaction was pointing 
		   to the journal entry instead of itself, causing the 
		   secondary transaction to not get reversed on an error 
		   correct (hence causing an OOB).

	08/02/06 - KELLYP - CR 22318
		   Added TPART restriction check to OVR section so that any
		   transaction affecting a loan's balance when the loan is 
		   pending sale has the restriction returned.
	
	07/17/06 - KELLYP - CR 22174
		   Modified top level and LSDTJ sections to properly create
		   LNLSDT records for transactions on sold loans.  Previously,
		   the code was expecting a secondary transaction where it
		   should have been expecting a primary transaction.
	
	06/12/06 - KUMARB - CR 20906
		   Modified section HIS4 to add conditional quit if the
		   transaction is system generated.
	
	05/23/06 - SmithCD - CR 19732
		   . Replaced occurrences of secondary transaction check on 
		     TRNSEQ with .getStoredValue("isSecondary") and %TRNHSEQ 
		     with .getStoredValue("HistSeq")
		   . Added REV parameter to STATCK section so call to it from 
		     LNPTSR will work correctly
	
	  03/24/06 - BHOLT - CR19951
	  	     Added the code "do EXIT(.ln,.ttx)" in OVR section which 
	  	     calls EXIT in which the Loan Scheduled Disbursement Status
	  	     Flag is getting updated.
	  	       	
	  01/26/06 - SmithCD - CR 19343 (16890)
	  	     . Removed LN2, POST, EXEC sections (not needed 
	  	       in p04, and causes double-postings for secondary 
	  	       transactions to other accounts), and re-coded 
	  	       LN1 and LN4 sections (removing LN4 label) to work 
	  	       correctly for p04
	  	     . Restructured HIS4 section for secondary transactions 
	  	       (HISTLST table), and removed call to it from w/in (it 
	  	       is now called from POST^LNTRB)
	  	     . Removed use of TEBADJ (the individual posting routines 
	  	       will now take care of updating ttx.tsb=dep.bal to 
	  	       prevent the need for having "floating" variable TEBADJ)
	  	     . Performed some cleanup and Removed old revision history
	  	     
	  10/06/05 -  Srinivar - CR 16890
	  	      Modified the POST section to correct the case 
	  	      of the variable %Userstation to %UserStation
	  	      to avoid the undefined variable. 
	  	      Modified the LNTRS,LN2 sections to declare the  
	  	      variable P as local to avoid the undefined error.
	  	      Also renamed the variable P to ELEMENT.	
	  	      Removed the code to quit if not a primary transaction in
	  	      STATCK section.	
	  	      Removed call to P2^LNPTS2B from OVR section. Removed 
		      condition to check LFD before quitting and removed 
		      call to ENT^RECALC in LN4 section This code is no 
		      longer needed since unwind/reapply logic was added. 
		      
	   10/05/05 - KELLYP - CR 17399
	   	      Moved call to STATCK section from top level of procedure
	   	      to the top of the OVR section.  Also moved calls to EUROCK 
	   	      and STATCK2 from bottom of the STATCK section to the top of 
	   	      the same section.  Rewrote the STATCK and STATCK2 sections 
	   	      to call SETSTAT^LNFUNCS (as it used to) and removed old code 
	   	      that improperly determined whether the loan should be closed 
	   	      depending upon loan and escrow account balances w/o checking 
	   	      TRN.PCFL5.  Also fixed problems in RESETDD and CHECKDD.

	   07/13/04 - SCOTTC - 16505
		      Modified section STATCK to call STATCK2 and to quit if the
		      ttx being passed in is a secondary Trx. Modified 
		      code that set STAT and DTC into loan in order to
		      properly update the values during account close.
		      
	   07/05/05 - KELLYP - CR 16521
		      Modified DELP section to use a Db.getRecord(,,1) instead
		      of a Class.new when instantiating the LNDELP object to 
		      prevent an RDBSAVEFAIL during backdated transactions.
		      Also cleaned up DELP section and removed pre-2003 revision
		      history.

	   06/06/05 - SCOTTC - CR 15816
	   	      Added the condition in call to LNPTS2B in section
	   	      OVR to check if the transaction is a primary transaction.
	   	      Call was going into OVR for secondary and getting erroneous
	   	      information.
	   	      
	   03/23/05 - JERUCHIMC - 14057
	              Modified section OVR.  Define SEQ from TRNSEQ.
	              Add call to DELP from LSDTJ section.  Add ln parameter
	              to LSDTJ section.

	-----------------------------------------------------------------------
	*/

	type public Boolean ER,SAVE
	type public Cache %CACHE()
	type public String LNPDT,TB()

	type String LNERC

	// Evaluate the DUE or Delinquent Status of the loan if it is linked
	// to a loan payment sweep
	do CHECKDD quit:ER

	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ttx.etc")

	set LNERC=ttx.lnerc
	set LNERC.piece("#",1)=$select(trn.pcfl9:ln.dist1ld,SAVE.get():SAVE,1:"")
	set ttx.lnerc=LNERC

	// Remove unnecessary entries from transfer balance array
	do LNTRS(.TB())

	// Update loan budget files if appropriate for primary and secondaries
	do LNBUD(.ln,.ttx,.trn)

	if ln.pflg do LSDTJ(.ttx,.ln) quit:ER

	do OVR(.ln,.ttx,.trn)
	
	// Post transaction to increase UDBAL on linked revolving commit
	do LN1(.ln,.ttx,.trn) quit:ER

	quit


LNTRS(String TB())

	// Remove unnecessary entries from transfer balance array

	type String ELEMENT=""
	
	for  set ELEMENT=TB(ELEMENT).order() quit:ELEMENT.isNull()  do {
		if "P,I,L,U,M"[ELEMENT!('TB(ELEMENT)) kill TB(ELEMENT) quit
		if '(TB(ELEMENT)-TB(ELEMENT).piece(",",3)) kill TB(ELEMENT) quit
		}

	quit

	
LN1(RecordLN ln,		// Loan account			/REF:RW
    RecordTTX ttx,		// Transaction (current)	/REF:R
    RecordTRN trn)		// Transaction code		/REF:R

	/*
	Post transaction to increase UDBAL on linked revolving commitment
	
	Arguments:
 
	. ln	Loan object		/TYP=RecordLN/REQ/MECH=REF
 	. ttx	Primary ttx object	/TYP=RecordTTX/MECH=REF

	*/
	
	type public String CTL,OVR(,,)
	type public Boolean ER
	type public Cache %CACHE()
	
	if 'CTL.extract(1) quit

	type Number BALCMP,TAMT
	type String ETCCR,ETCDR
	
	// Exclude contra accounts
	if ln.trb-trn.itc.extract(1) quit

	set TAMT=ttx.tamt.piece("|",2)

	// If Not disbursed do not quit yet
	if 'TAMT,ln.cntdr quit

	// Revolving Account/No Commercial Commitment Link
	if ln.revf!('ln.ccl) quit

	set BALCMP=+ln.bal
	if ln.aruf set BALCMP=BALCMP-ln.udbal

	// Commitment Link is not a revolving account
	type RecordLN lnccl=Db.getRecord("LN","CID=:ln.ccl")
	if 'lnccl.revf quit

	// Ignore if not a payment; this could be a commitment transfer (CMCTO)
	// or credit limit decrease (CMUDO)
	if 'trn.pcfl9 quit

	if lnccl.stat,(lnccl.stat'=1) set OVR(ln.ccl,"OVR","STAT"_lnccl.stat)=""

	// Set TAMT equal to the Undisbursed Balance if account was never
	// disbursed
	if 'ln.cntdr set TAMT=ln.udbal

	// Set TAMT equal to the principal amount plus the Undisbursed Balance
	// if this is a payoff
	if ln.aruf,trn.pcfl5 set TAMT=TAMT+ln.udbal

	if ln.crlmt-BALCMP<0 quit

	if TAMT>(ln.crlmt-BALCMP) set TAMT=ln.crlmt-BALCMP

	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:lnccl.type")
	
	// If TRB of commitment matches TRB of loan, use "increase" trancodes
	if ln.trb=lnccl.trb do {
		set ETCDR=prodctl.drtrir
		set ETCCR=prodctl.crtrir
		}
	else  do {
		set ETCDR=prodctl.drtrdf
		set ETCCR=prodctl.crtrdf
		}
	
	// Reset ACN so POST^LNTRB will use it to post the transactions
	type RecordACN acn={RecordACN}lnccl
	
	do POST^LNTRB(.ttx,lnccl.cid,ETCCR,TAMT,%EffectiveDate,%UserStation,"","",lnccl.crcd) quit:ER
	do POST^LNTRB(.ttx,lnccl.cid,ETCDR,TAMT,%EffectiveDate,%UserStation,"","",lnccl.crcd) quit:ER

	quit


OVR(RecordLN ln,RecordTTX ttx,RecordTRN trn)
	/*

	Arguments:
 
	. ln	Loan object		/TYP=RecordLN/REQ/MECH=REF
	. ttx	Transaction object	/TYP=RecordTTX/REQ/MECH=REF
	. trn 	Transaction Code object /TYP=RecordTRN/REQ/MECH=REF

	Example:

	do OVR(.ln,.ttx)

	*/
	
	type public Cache %CACHE()
	type public String DELP,OVR(,,)

	type Number BALCMP

	do STATCK(.ln,.ttx,0)
	
	set BALCMP=+ln.bal
	if ln.aruf set BALCMP=BALCMP-ln.udbal

	// For revolving loans, [LN]SCHBAL should always equal [LN]BALCMP
	if ln.revf set ln.schbal=BALCMP

	// For all loans, BALCOL equals BALCMP
	set ln.balcol=BALCMP

	// Is escrow balance at least equal to the computed balance
	// If so, this could be a candidate for payoff.
	if 'trn.pcfl5,ln.teb,(ln.teb'<BALCMP) set OVR(ln.cid,"OVR","TEB")=""

	// Sale in process - balance change requires approval
	if (ln.tflg),(ttx.prin) set OVR(ln.cid, "OVR", "TPART") = ""

	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:ln.type")
	if prodctl.fbp=2 do VARPMT(.ln)

	// Set dayend entry for transactions made to sold loans
	if 'ln.pflg,'DELP.get().isNull() do DELP(.ln,.ttx)

	do AUTO1(.ln,.ttx)

	do EXIT(.ln,.ttx)

	quit


LSDTJ(RecordTTX ttx,RecordLN ln)

	/*
	Build and file the LNLSDT record for sold loan transactions

	Arguments:
 
	. ttx	Primary transaction object	/TYP=RecordTTX/REQ/MECH=REF
 	. ln    Loan Object			/TYP=RecordLN/REQ/MECH=REF
 
	Example:
 
	do LSDTJ(.ttx,.ttx2,.ln)
 
	*/

	type public Number BALCMP
	type public String LNPDT,RJ()

	set LNPDT.piece("|",2)=BALCMP

	if RJ(ttx.getStoredValue("HistSeq")).exists() quit
	if ttx.tso.isLike("%ADJAVCR%") quit

	do LNPDT(.ttx)
	do DELP(.ln, .ttx)

	quit


LNPDT(RecordTTX ttx)		// Transaction			/REF:R

	// Build LNLSDT records

	type public String LNPDT
	
	type DbSet ds=Db.selectDbSet("LNLS6","CID=:ttx.cid AND RFPF=0")
	while ds.next() do {
		type RecordLNLS6 lnls6=ds.getRecord("LNLS6")

		type RecordLNLS2 lnls2=Db.getRecord("LNLS2","INCD=:lnls6.incd,PL=:lnls6.pl")
		if lnls2.picm=6 quit

		set LNPDT.piece("|",7)=lnls6.pseq
	
		type RecordLNLSDT lnlsdt=Class.new("RecordLNLSDT")

		set lnlsdt.efd=%EffectiveDate
		set lnlsdt.incd=lnls6.incd
		set lnlsdt.pl=lnls6.pl
		set lnlsdt.cid=ttx.cid
		set lnlsdt.tseq=ttx.getStoredValue("HistSeq")

		set lnlsdt.balbef=LNPDT.piece("|",1)
		set lnlsdt.balaft=LNPDT.piece("|",2)
		set lnlsdt.escbef=LNPDT.piece("|",3)
		set lnlsdt.lstact=LNPDT.piece("|",4)
		set lnlsdt.lstdue=LNPDT.piece("|",5)
		set lnlsdt.lstpmt=LNPDT.piece("|",6)
		set lnlsdt.pseq=LNPDT.piece("|",7)
		set lnlsdt.srvfee=LNPDT.piece("|",8)
		set lnlsdt.lnsfl=LNPDT.piece("|",9)
		set lnlsdt.revpmt=LNPDT.piece("|",10)
		set lnlsdt.sdatacr=LNPDT.piece("|",11)

		do lnlsdt.bypassSave()
		}
	quit


DELP(RecordLN ln, RecordTTX ttx)

	/*
	The function builds the LNDELP record.

	Arguments:
 
	. ln	Loan object		/TYP=RecordLN/REQ/MECH=REF
 	. ttx	Transaction object	/TYP=RecordTTX/REQ/MECH=REF

	Example:
 
	do DELP(.ln,.ttx)
 
	*/

	type public Number BALCMP
	type public String DELP

	type String REC
	type Number TRNHSEQ=ttx.getStoredValue("HistSeq")

	set REC=ln.dist1ld_"|"_ln.ppa_"|"_ln.lchg_"|"_ln.tdue_"|"_BALCMP_"|"_ln.teb
	set DELP.piece("|",15)=REC
	
	type RecordLNDELP dedelp=Db.getRecord("LNDELP","EFD=:%SystemDate,CID=:ttx.cid,TSEQ=:TRNHSEQ",1)
	
	set dedelp.type=DELP.piece("|",1)
	set dedelp.btld=DELP.piece("|",2)
	set dedelp.blptd=DELP.piece("|",3)
	set dedelp.bdist1ld=DELP.piece("|",4)
	set dedelp.bppa=DELP.piece("|",5)
	set dedelp.blchg=DELP.piece("|",6)
	set dedelp.btdue=DELP.piece("|",7)
	set dedelp.bbal=DELP.piece("|",8)
	set dedelp.bteb=DELP.piece("|",9)
	set dedelp.adist1nd=DELP.piece("|",15)
	set dedelp.appa=DELP.piece("|",16)
	set dedelp.alchg=DELP.piece("|",17)
	set dedelp.atdue=DELP.piece("|",18)
	set dedelp.abal=DELP.piece("|",19)
	set dedelp.ateb=DELP.piece("|",20)

	do dedelp.bypassSave()

	quit

	
public AUTO1(RecordLN ln,RecordTTX ttx)

	/*
	Auto-escrow processing (also called from ^LNPTSR)

	Arguments:
 
	. ln	Loan object		/TYP=RecordLN/REQ/MECH=REF
 	. ttx 	Transaction object	/TYP=RecordTTX/REQ/MECH=REF

	Example:
 
	do AUTO1(.ln,.ttx)

	*/
	
	type public Cache %CACHE()

	// Account not coded for Auto Escrow Bal Changes
	if 'ln.auo quit		

	// Inactive Account
	if ln.stat quit		

	type Number PRIN

	set PRIN=ttx.tamt.piece("#",2)
	if ln.aruf set PRIN=PRIN+ttx.tamt.piece("#",5)

	// Transaction does not change principal balance
	if 'PRIN quit

	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ttx.etc")

	// Auto escrow processing disabled for tran code
	if 'trn.pcfl22 quit

	do EXEC^LNAEU(.ln,.ttx,ln.cid,1,ttx.tseq,%EffectiveDate,$$FIELD^UTSO(ttx.tso,"AEUO"))

	quit
	

EXIT(RecordLN ln,RecordTTX ttx) // Processing complete
	/*
	Arguments:
 
	. ln	Loan object		/TYP=RecordLN/REQ/MECH=REF
	. ttx	Transaction object	/TYP=RecordTTX/REQ/MECH=REF
 
	Example:
 
	do EXIT(.ln,.ttx)

	*/
	
	type public Boolean ER
	type public String TAMT
	
	type Number CID
	type String TSO

	set CID=ttx.cid

	// Process any commissions for this transaction
	do START^TTXCOM(.ln,.ttx)

	/*
	 if loan has a disbursement schedule and a scheduled disbursement
	 matching the effective date and amount of the transaction then
	 the status flag ([LNDS1]SDS) will be changed to 1 - disbursed.
	*/
	if Db.isDefined("LNDS1","CID,%EffectiveDate") do {
		type RecordLNDS1 lnds1=Db.getRecord("LNDS1","CID,%EffectiveDate")
		if +lnds1.sda=+ttx.tamt do {
			set lnds1.sds=1
			do lnds1.bypassSave()
			}
		}

	if %EffectiveDate=%SystemDate set %EffectiveDate=""
	set TAMT=+TAMT

	quit 


public STATCK(RecordLN ln,		// Loan account			/REF:RW
	      RecordTTX ttx,		// Transaction			/REF:R
	      Boolean REV)		// Reversal indicator

	do EUROCK(.ttx)
	do STATCK2(.ln,.ttx,REV)
	
	quit


STATCK2(RecordLN ln,			// Loan account			/REF:RW
	RecordTTX ttx,			// Transaction			/REF:R
	Boolean REV)			// Reversal indicator

	type public Cache %CACHE()
	type public Boolean ER,LNPTSRV
	type public Number CID

	if 'REV,ttx.getStoredValue("isSecondary") quit
	
	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ttx.etc")
	
	if ('LNPTSRV.get())!(REV) do SETSTAT^LNFUNCS(.ln,.ttx,REV) quit:ER
	
	if trn.pcfl5 do { quit:ER
		do RESETDD
		do CLAWBACK^TTXCOM(.ln,.ttx,ln.boo)
		}
	
	quit


public RAROD	// Delete entry dayend for loan payoff reversals

	type public Number CID

	type Date XTJD=%SystemDate-1
	
	do Db.delete("DAYENDAROD","CID=:CID AND TJD>:XTJD")

	quit 


public AROD	// Post entry dayend for collateral automatic release

	type public Number CID

	type Number XCOLL

	type ResultSet rs=Db.select("COLL","LNCOL","CID=:CID AND COLTYP=70")
	while rs.next() do {
		set XCOLL=rs.getCol("COLL")

		type RecordCOL col=Db.getRecord("COL","COLL=:XCOLL",1)

		if 'col.avrsl quit 

		type RecordDAYENDAROD darod=Class.new("RecordDAYENDAROD")

		set darod.tjd=%SystemDate+col.arod
		set darod.cid=CID
		set darod.coll=XCOLL

		do darod.bypassSave()
		}

	quit


RESETDD	// Reset Loan Payment Due/Delinquent indicator in Payment Sweep file
	/*
	     This line tag should be called during closeout transactions
	     only.  It will make sure the Due/Delinquent flag (for loan
	     payment sweep processing) is set to the proper value for
	     closeouts and reversals of closeouts.
	
	   INPUTS:
	   . CID Loan account number 		/TYP=N
	   . REV Reversal Flag  		/TYP=L
	    	0 - Do not determine due status (account is closing)
	    	1 - Determine due status (reversing a closeout)
	
	   EXAMPLE:
	   D RESETDD

	*/

	type public Boolean REV
	type public Number CID

	type Boolean NEWDD

	type DbSet ds=Db.selectDbSet("LPSWEEP","LPCID=:CID")
	while ds.next() do {

		type RecordLPSWEEP lpsweep=ds.getRecord("LPSWEEP")

		set NEWDD=lpsweep.duedel
		if 'REV,lpsweep.duedel set NEWDD=0

		// Recalculate due amount if indicated and the loan is not in a
		// due/delinquent state.
		if REV,'lpsweep.duedel set NEWDD=$$DUE^BCHLNPSR(CID)

		if NEWDD=lpsweep.duedel quit
		
		set lpsweep.duedel=NEWDD
		do lpsweep.bypassSave()
		}

	quit


public CHECKDD

	/*
	Check the Loan Payment Due/Delinquent Flag and reset it if necessary
	
	   DESC: This line tag will be used to re-evaluate the status of the
	         loan accounts Due/Delinquent flag for loan payment sweep
	         processing.  This line tag will be called for all loan
	         accounts which are not reversals.

	*/

	type public Number CID

	type Boolean NEWDD
	
	type DbSet ds=Db.selectDbSet("LPSWEEP","LPCID=:CID")
	while ds.next() do {

		type RecordLPSWEEP lpsweep=ds.getRecord("LPSWEEP")

		// Recalculate due amount if indicated and the loan is not in a
		// due/delinquent state.
		set NEWDD=$$DUE^BCHLNPSR(CID)

		if NEWDD=lpsweep.duedel quit
	
		set lpsweep.duedel=NEWDD
		do lpsweep.bypassSave()
		}
		
	quit 


public	HIS4(RecordTTX ttx)	// Secondary (current) transaction	/REF:R

	/*
	File to History of Loan Secondary Transactions table

	All secondary loan transactions should file to the History of Loan 
	Secondary Transactions table. This section is also called externally 
	by POST^LNTRB after posting a secondary transaction.
	*/

	type public RecordTTX ttxpri
	type public Cache %CACHE()
		
	// A primary transaction must exist
	if 'ttxpri.exists() quit
	if ttxpri.cid.isNull() quit
	
	// Quit if system generated transaction
	if ttx.getStoredValue("isSystemGenerated")!(ttx.itc7 = 2) quit
	
	type Number SLSEQ,TRNHSEQ
	type String OFFST,TSO

	/*
	 If the TSO field of the secondary transaction contains a "OFFST"
	 value, it means that the offset to the transaction will be reversed 
	 by RUNHIST^LNUEFD.  In this case a HISTLST record should not be 
	 created for the secondary transaction, otherwise an OOB will occur
	 because the offset reversal will be processed twice: once by LNUEFD
	 and once by REVSEC^LNPTSR.
	*/
	set OFFST = $$FIELD^UTSO(ttx.tso,"OFFST")
	if 'OFFST.isNull() quit
	
	// Note ttx.getStoredValue("HistSeq") is the history sequence pointer 
	// of the primary transaction at this point (not the secondary)
	set TRNHSEQ = ttxpri.getStoredValue("HistSeq")
	type ResultSet rs=Db.select("SLSEQ","HISTLST","CID=:ttxpri.cid AND SLN=:TRNHSEQ AND (SLSEQ>3.9999 AND SLSEQ<5)","SLSEQ DESC")
	if rs.next() set SLSEQ=rs.getCol("SLSEQ")+.0001
	else  set SLSEQ=4

	type RecordHISTLST histlst=Class.new("RecordHISTLST","CID=:ttxpri.cid,SLN=:TRNHSEQ,SLSEQ=:SLSEQ")

	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ttx.etc")

	if '"D/L".isLike("%"_trn.cls_"%") do {
		// Not a deposit or loan (most likely a miscellaneous) 
		// transaction
		set histlst.act=ttx.cid
		set histlst.etc=ttx.etc
		set histlst.tamt=ttx.tamt

		set TSO=ttx.tso
		if 'ttx.cc.isNull() set TSO=$$FIELDIN^UTSO(TSO,"CC",ttx.cc)
		set TSO=$$FIELDIN^UTSO(TSO,"CRCD",ttx.crcd)
		set histlst.tso=TSO
		}
	else  do {
		// Deposit or loan transaction
		set histlst.rseq=ttx.getStoredValue("HistSeq")
		if (ttxpri.cid-ttx.cid) set histlst.act=ttx.cid
		}

	/*
	Mark the transaction as no-reversal the transaction is a system 
	generated accrual adjustment
	*/
	if $$SKIPACR(.ttx) set histlst.rflg=1

	do histlst.bypassSave()

	quit
	

SKIPACR(RecordTTX ttx)
	/*
	   This section is used to check if the transaction is a system
	   generated accrual transaction.  If so, we need to mark the
	   transaction as a 'no-reversal', so that later when the
	   primary transaction is reversed, the adjustment will not be reversed.
	   In such a case, the system will build its own adjustment.

	   Arguments: 
	   .	ttx	transaction object	/TYP=recordTTX/REQ/MECH=REF

	*/

	if $$FIELD^UTSO(ttx.tso,"SGAA")=1 quit 1

	quit 0


VARPMT(RecordLN ln)

	/*
	If bullet is pre-paid, then lower the payment amount on controlling 
	variable loan

	Arguments:
	. ln	Loan object		/TYP=RecordLN/REQ/MECH=REF

	*/
	
	type public Number BALCMP,PRETRN()

	if PRETRN("BALCMP")'>0 quit 
	if (PRETRN("BALCMP")-BALCMP)'>0 quit 
	if (PRETRN("BALCMP")-BALCMP)'>(PRETRN("CUPR")+PRETRN("UNPR")) quit 

	if BALCMP quit 
	if ln.trm=ln.ptrm quit

	/*
	   At this point, we figured that this is a pre-payment on
	   a "balloon" bullet.  The variable loan would have normally
	   had it's payment increased when the bullet's remaining balance
	   transferred back to the variable loan.  Since this amount
	   will not transfer (because the balance was brought to 0),
	   then the payment schedule on the variable loan must be
	   decreased.
	*/
	do %FFPA^LNPTSU(ln.tracn,ln.mdt-1,99999,-PRETRN("FPA"))

	quit


LNBUD(RecordLN ln,		// Loan account			/REF:R
      RecordTTX ttx,		// Transaction			/REF:R
      RecordTRN trn)		// Transaction code		/REF:R

	// Update loan budget files if appropriate for primary and secondaries
	
	type public String OVR(,,)
	
	// Loan Budget Processing flag
	if 'ln.entf quit

	type Number BDL,BUN,PRIN,UNITS
	type String BGT,UTSO()

	if trn.cls'="L" quit
	
	do OUT^UTSO(.UTSO,ttx.tso)

	// Determine principal change
	// Advances to Reduce Undisbursed Flag
	set PRIN=ttx.tamt.piece("|",2)
	if ln.aruf set PRIN=PRIN+ttx.tamt.piece("#",5)

	if 'PRIN quit

	// Is this a disbursement transaction
	if ln.trb-trn.itc.extract(1) do {
		// Piece for budget dollars
		set BDL=2                            

		// Piece for budget units
		set BUN=5

		set BGT=UTSO("LBUDU").get()

		// If BGT is null, this may be a debit transaction which
		// increases principal (i.e., CMDEB from loan fee)
		if BGT.isNull() do {
			// Ignore Disbursements
			if trn.pcfl4 quit

			// Only the primary sequence
			if ttx.getStoredValue("isPrimary") quit

			type RecordLNENT0 lnent0=Db.getRecord("LNENT0","CID=:ttx.cid",1)
			set lnent0.dramt=lnent0.dramt+PRIN
			do lnent0.bypassSave()
			}

		set UNITS=$$SIGN(UTSO("UNITU").get(),ttx.itc)

		}
	else  do {
		// Piece for budget dollars
		set BDL=4

		// Piece for budget units
		set BUN=6

		set BGT=UTSO("LBUDS").get()

		// If BGT="", this may be a debit transaction which
		// increases principal (i.e., CMDEB from loan fee)
		if BGT.isNull() do {
			//Ignore Disb.
			if trn.pcfl4 quit

			//Only Primary transaction
			if ttx.getStoredValue("isPrimary") quit

			type RecordLNENT0 lnent0=Db.getRecord("LNENT0","CID=:ttx.cid")
			set lnent0.dramt=lnent0.dramt-PRIN
			do lnent0.bypassSave()
			}

		set UNITS=$$SIGN(UTSO("UNITS").get(),ttx.itc)
		}	

	if BGT.isNull() quit 

	type RecordLNENT lnent=Db.getRecord("LNENT","CID=:ttx.cid,USESRC=:BGT",1)
	
	// If disbursement, ensure that availability is not exceeded
	if ln.trb-trn.itc.extract(1) do {
		type Number AVAIL

		// Available equals budget less advances
		set AVAIL=lnent.bud-lnent.act

		// Availability is restored by "add back" amounts
		// if account is revolving
		if ln.revf set AVAIL=AVAIL+lnent.add

		// Require override if transaction exceeds available
		if PRIN>AVAIL set OVR(ttx.cid,"OVR","ENTAVL")=AVAIL.roundCur(ln.crcd)
		}

	// If payment, and revolving, add to "add back" column
	else  do {
		if 'ln.revf quit
		set lnent.add=lnent.add+PRIN
		}

	// BDL=2 and BUN=5, Update ACT, OCTANT and LADT for LNENT
	if BDL=2 do {
		set lnent.act=lnent.act+PRIN
		set lnent.octant=lnent.octant+UNITS	
		set lnent.ladt=%SystemDate
		}

	// BDL=4 and BUN=6, Update REP and REPUNT for LNENT
	else  do {
		set lnent.rep=lnent.rep+PRIN
		set lnent.repunt=lnent.repunt+UNITS
		}

	do lnent.bypassSave()

	quit 
	

public SIGN(AMT,ITC)	//  Flip sign on TSO units fileds if EC/REV transaction
	/*
	Arguments:
 
	. AMT	Amount			/TYP=$/REQ
	. ITC	Internal Tran Code	/TYP=N/REQ
	
	*/

	if '($E(ITC,6)-$E(ITC,12)) quit AMT

	quit -AMT
	

EUROCK(RecordTTX ttx) //  European Checkbook Processing for Loans
	/*
	Arguments:
 	. ttx	Transaction object	/TYP=RecordTTX/REQ/MECH=REF
	
	*/
	
	type public Boolean ER
	type public String OVR(,,)
	type public Number PTRC
	
	type Number CHKNUM,NEWSTAT
	type String CHKTYP

	set CHKNUM=$$FIELD^UTSO(ttx.tso,"CK")
	quit:CHKNUM.isNull()

	// Not a European Check processing account
	quit:'$$EUROCHK^CHKPROC(ttx.cid)

	do CHKVER^CHKPROC(.ttx,CHKNUM,ttx.cid,PTRC) quit:ER
	do CHKACT^CHKPROC("PAY",CHKNUM,ttx.cid,,,.NEWSTAT) quit:ER

	// Create an OVR if an error occours
	if ER.get() set ER=0 set OVR(ttx.cid,"OVR","INVCHK")=CHKNUM quit 

	type RecordCHECK check=Db.getRecord("CHECK","CHKS=:CHKTYP,CID=:ttx.cid,CHKNUM=:CHKNUM")
	set check.chksts=NEWSTAT
	do check.bypassSave()

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60785^45153^Lakshmi Giridharan^24369"	// Signature - LTD^TIME^USER^SIZE
