public	DEPPW(RecordDEP dep,		// Deposit account		/REF:RW
	      RecordTTX ttx,		// Transaction			/REF:R
	      RecordTRN trn)		// Transaction code		/REF:R

 	/*
	Partial withdrawal w/ penalty
	
 	 PROCEDURE ID:	DEPPW
 	     Original:	DEPPW.M
		 Date:	10/18/2002
 	         Desc:	Partial withdrawal w/ penalty
 	         
	NOTE: At some point this procedure s/be re-written to post AND process 
	      secondary transactions through TRNSINGL^TRNDRV. Currently there 
	      is duplicate code in this procedure that does the same thing as 
	      the posting routine of the secondary transaction would normally 
	      do, but it is risky and time-consuming to re-design ^DEPPW to 
	      operate like normal transaction posting procedures.
	
	---- Revision History ------------------------------------------------
	05/21/07 - NATRAJAH - CR 27172
		   . Modified ADJACR section to use the new variable AMT for
		     setting transaction amount and passing the same to TR 
		     section instead of the variable ADJ, so that the ADJ value
		     will be retained for use in other sections.		     
		   . Modified EXPGL section to set the AMT variable to AMT 
		     instead of ttx.tamt, since ttx.tamt contains primary
		     transaction amount.
		   . In TR section, modified transaction mode from 4 (Secondary)
		     to 5 (System Generated) in TRNSINGL^TRNDRV call.
		     
	01/05/07 - GIRIDHAL - CR 24721
		   Modified section AUT to add check for Single Signature
		   Withdrawal Limit.

	12/04/06 - KinI - CR 22979
		   Modified FILE section to remove Premature Withdrawal Tax 
		   processing related code as it should have been deleted 
		   along with some obsoleted Patagon system area elements.
		   
	11/29/06 - MbuiM - CR 21675
		   Changed reference of INTAVLNC to INTAVLNCR to comply with 
		   GTM version 5.0.

	06/23/06 - DESHPANDE S K - CR 20748
		   Removed unused reference to %TRNSEQ in section PAYINT.
		   Replaced %TRNPRIM with Transaction Stored Value. 
		   
	06/05/06 - SANTHUMS - CR 21314
	  	   . Initialized PRIN to ttx.prin instead of TAMT, and passed
                     PRIN to INIT^DEPPEN as a new parameter.
	
	03/23/06 - SmithCD - CR 20109
		   . Made modifications to last change, and modified to 
		     prevent complications with $T, and set stored values 
		     into secondary transactions to cause them to be filed but 
		     not processed (i.e., trn.pgm to be skipped) by 
		     TRNSINGL^TRNDRV
		   . Corrected default value for PRM in INIT section to default
		     PRM=1 only if dep.prm is null instead of if it is greater 
		     than 0 (fixes a problem where the penalty reduction method
		     was getting overriden with method the "Reduce principal" 
		     method)
		   . Corrected PENGL section to use the General Purpose Credit 
		     tran code when the intended tran code is not defined
		   . Modified PENGL and TR section to call RECALC for the 
		     secondary penalty transaction instead of calling RECALC 
		     for the primary (partial withdrawal) transaction
		   . Performed some cleanup

	03/22/06 - Hillanbrand CR 20109
	           . In TR section change call from TRNUPD^TRNDRV(.ttx2) to
	             TRNSINGL^TRNDRV(.ttx2,,,BRCD,5) to post the secondary
	             transaction which corrects the GTM Error 
	             vReSav9+5^TRNDRV,%PSL-E-RDBSAVEFAI.
	           . In FILE section on call ADJ section if not effective
	             date. If effective date, RECALC will take care of the
	             adjusments.
	           . In PAYINT section removed the call to ADJPER as the
	             setting of the columns in ADJPER are different than
	             the columns that are to be set in the PAYINT section.
	             Added the setting of the columns directly in PAYINT. 
	
	11/30/05 - TITOVE - CR 18414
		   Modified EC section to pass additional argument (dep) to
		   FSECTR^DEPEC1.

        09/15/05 - S.Krishnan - CR16884
		  . In the section PAYINT modified the calling FMHTRN^BCHINTPS
		    to HIST^UIC as FMHTRN is no longer exist in BCHINTPS.
		  . Cleaned up the section AUT.
		  . In the section PIPW added a line at the bottom to call the
		    section PROCESS and also changed PIPW to accept/pass the 
		    trn parameter 
        
        07/27/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.

	----------------------------------------------------------------------
	*/

	type Number ADJ,CID,INT,NET,PRATE	

	set CID=dep.cid

	// Backdated transaction to a segmented account
	if dep.segflg,'ttx.efd.isNull(),ttx.efd<%SystemDate do ^RECALSEG(.dep,.ttx) quit

	do PROC(.dep,.ttx,.trn,0,0)
	
	quit
	
	
PROC(RecordDEP dep,		// Deposit account		/REF:RW
     RecordTTX ttx,		// Transaction			/REF:R
     RecordTRN trn,		// Transaction code		/REF:R
     Boolean EC,		// Error correct
     Number PEN)		// Penalty amount

	type public Number ADJ,ER,INT,NET,PRATE
		
	type Number DSWA=0,DWA=0,GRACE,INTAVLNCR,INTPWD,PENINT,PRIN
	type Number PRM,TAMT
	
	do INIT(.dep,.ttx)

	set TAMT=ttx.tamt
	
	if dep.ira,'EC do { quit:ER
		set NET=TAMT
		do WITHHOLD^DEPPO(.dep,.ttx)
		}

	if dep.regd=5 do ^DEPMMDA(.dep,.ttx,.trn) quit:ER
	
	set PRIN=ttx.prin
	do ^UMAT(.dep,.ttx) quit:ER

	/*
	 If there is an Adjustment then we are within a grace period.
	 The adjustment needs to be processed and then we can quit, there
	 is nothing else to do.
	*/

	if ADJ do { quit
		set GRACE=1
		set (PENINT,INTPWD)=0
		do PROCESS(.dep,.trn,.ttx)
		}
	
	/*
	If penalty will come from accrued interest, then set PENINT;
	otherwise, PEN always comes from principal.
	*/
	if PRM=1 set (PENINT,ADJ)=0
	
	// If penalty exceeds interest accrued, take excess from principal
	if PRM=2,EC do {
		if -PEN>INT do {
			set PENINT=-INT
			set PEN=0
			set ADJ=PENINT
			}

		else  do {
			set PENINT=PEN
			set PEN=0
			set ADJ=PENINT
			}
		}
	
	else  if PRM=2,'EC do {
		if PEN>INT do {
			set PENINT=INT
			set PEN=PEN-INT
			set ADJ=-PENINT
			}

		else  do {
			set PENINT=PEN
			set PEN=0
			set ADJ=-PENINT
			}
		}
	
	// If penalty exceeds interest accrued, excess negates accrued

	else  if PRM=3 do {
		set PENINT=PEN
		set PEN=0
		set ADJ=-PENINT
		}
	
	// If penalty exceeds interest accrued, excess waived
	else  if PRM=4 do {
		if EC do { quit
			if -PEN>INT do {
				set PENINT=-INT
				set PEN=0
				set ADJ=INT
				}

			else  do {
				set PENINT=PEN
				set PEN=0
				set ADJ=PENINT
				}
			}
	
		if PEN>INT do {
			set PENINT=INT
			set PEN=0
			set ADJ=-INT
			}

		else  do {
			set PENINT=PEN
			set PEN=0
			set ADJ=-PENINT
			}
		}
	
	// Examine penalty rate; if necessary, default from account, product
	if 'PRATE.exists() set PRATE=""

	// Transaction Source of Funds
	if PRATE.isNull() set PRATE=$$FIELD^UTSO(ttx.tso,"PRATE")

	// Penalty Rate
	if PRATE.isNull() set PRATE=dep.prate

	set ttx.tso=$$FIELDIN^UTSO(ttx.tso,"PRATE",PRATE)
	
	if 'PENINT.exists() set PENINT=0
	do PIPW(.dep,.trn,.ttx)

	quit


PIPW(RecordDEP dep,		// Deposit account			/REF:RW
     RecordTRN trn,		// Transaction code			/REF:R
     RecordTTX ttx)		// Transaction				/REF:R

	/*
	Provide ability to pay interest on partial withdrawal;
	regardless of penalty method.
	*/

	type public Boolean EC	
	type public Number ADJ,DTL,INT,INTPWD,PEN,PENINT,POPT,PRIN,PRM,SAVPEN
	type public Number SAVPENINT,SAVPOPT

	if dep.pipw do {

		// Penalty Calculation Method
		if 'POPT.exists() set POPT=dep.popt
	
		// Determine interest paid on w/d using POPT "1" (all earnings)
		set SAVPEN=PEN
		set SAVPOPT=POPT
		set SAVPENINT=PENINT

		set POPT=1
		set DTL=0
		do INIT^DEPPEN(.dep,.ttx,PRIN)
		set INTPWD=PEN

		set PEN=SAVPEN
		set POPT=SAVPOPT
		set PENINT=SAVPENINT

		quit:EC
	
		// Do not pay more interest than what has accrued
		if INTPWD>INT set INTPWD=INT
	
		if PENINT'<INT do {
			if PRM=3 set ADJ=-PENINT quit
			if PRM=2!(PRM=4) set ADJ=-INT
			if PENINT>INTPWD do {
				quit:PRM=4
				set ADJ=-INTPWD
				set PEN=(PENINT+PEN-INTPWD)
				set PENINT=INTPWD
				}
			}
		else  do {
			set ADJ=-INTPWD
			if PENINT>INTPWD do {
				if PRM=4 set PEN=0,PENINT=INTPWD
				else  set PEN=PENINT+ADJ,PENINT=INTPWD
				}
			}
		}
	
	else  set INTPWD=0

	quit:EC
	
	// Rounding based upon account
	set INTPWD=INTPWD.roundCur(dep.crcd)
	set PENINT=PENINT.roundCur(dep.crcd)
	set PEN=PEN.roundCur(dep.crcd)
	set ADJ=ADJ.roundCur(dep.crcd)

	do PROCESS(.dep,.trn,.ttx)
	
	quit


PROCESS(RecordDEP dep,		// Deposit account			/REF:RW
	RecordTRN trn,		// Transaction code			/REF:R
	RecordTTX ttx)		// Transaction				/REF:R
	
	type public Number ADJ,DSWA,DWA,ER,NET,PEN,PENINT,PRM,TAMT,WTH
	type public String INTAVLNCR

	set WTH=$select(dep.ira:DWA+DSWA,1:0)

	if PRM=1 set NET=TAMT+PEN+WTH
	
	else  do {
		if PEN>0 set NET=TAMT+PEN+WTH
		else  set NET=TAMT+WTH
		}
	
	// Amount plus penalty exceeds balance
	if dep.bal-NET<0 do Runtime.setErrMSG("DEP",281) quit
	
	do AUT(.dep,.ttx,.trn) if ER quit

	if dep.iaf do INTAVL^DEPPO(.dep,.ttx)
	
	if dep.iaf=2 do {
		// Loan Error-Correct Data
		set INTAVLNCR=ttx.lnerc.curVal.piece("#",20)
		set NET=NET-INTAVLNCR
		}

	if PEN!PENINT.get()!(TAMT-NET)!(INTAVLNCR.get()) do TAMT(dep.ira,dep.iaf,dep.crcd)

	if ttx.getStoredValue("isPrimary") do {
		// Transaction Fee
		if trn.pcfd10 do ^SRVTRN2(.dep,.ttx,.trn,TAMT)

		// Restate Service Fee
		if trn.pcfd13,'dep.feepln.isNull() do {
			if 'ttx.efd.isNull(),(ttx.efd-%SystemDate=0) quit
			if '$$OLP^BCHFEEUT(dep.cid,dep.feepln,ttx.efd,ttx.etc) quit
			do EFDFEE^BCHFEEUT(dep.cid,dep.feepln,ttx.efd)
			}
		}

	if ADJ do SAVE(.ttx)

	do FILE(.dep,.trn,.ttx)

	quit


SAVE(RecordTTX ttx)		// Transaction				/REF:R

	/*
	Save data for E/C; including interest paid on a partial 
	withdrawal and penalty from interest accrued.
	*/

	type public Number ADJ,INTPWD,PENINT
		
	type String LNERC

	// Loan Error-Correct Data
	set LNERC=ttx.lnerc
	// Accrual adjustment
	set LNERC.piece("#",2)=ADJ
	// Interest paid on w/d
	set LNERC.piece("#",22)=INTPWD
	// Penalty from int acc
	set LNERC.piece("#",23)=PENINT
	// Loan Error-Correct Data
	set ttx.lnerc=LNERC

	quit


FILE(RecordDEP dep,		// Deposit account			/REF:RW
     RecordTRN trn,		// Transaction code			/REF:R
     RecordTTX ttx)		// Transaction				/REF:RW

	// File Data

	type public Number ADJ,NET,TAMT
	
	type String PCFD35
	
	set ttx.tamt=TAMT
	set dep.bal=dep.bal-NET
	set dep.tld=%SystemDate
	set dep.cntdr=dep.cntdr+1
	set dep.ldamt=+ttx.tamt
	set dep.lddt=%SystemDate
	set dep.balcol=dep.balcol-NET

	// Update penalty attributes on deposit account	
	do ADJPER(.dep,trn.pcfd35)
	
	// Update account status
	do ^UPDSTAT(.dep,.trn)

	// Check for Effective Date - RECALC will re-adjust
	if ttx.efd,ttx.efd-%SystemDate do ENT^RECALC(.dep,.ttx)

	if ADJ do ADJACR(.dep,.ttx,.trn,ADJ)
		
	quit 

	
TAMT(Number IRA,		// Retirement plan number
     Number IAF,		// Available interest option
     String CRCD)		// Currency code

	// Build TAMT

	type public Number DSWA,DWA,ER,INTAVLNCR,NET,PEN,WTH
	type public String RM,TAMT

	set TAMT.piece("#",2)=NET

	// Withholding, considering State W/H
	if IRA do { quit:ER
		set TAMT.piece("#",5)=DWA
		set RM=$$^MSG(7013,DWA.roundCur(CRCD))
		set TAMT.piece("#",15)=DSWA
		set RM=$$^MSG(7013,DSWA.roundCur(CRCD))
		}
	else  do {
		set TAMT.piece("#",5)=WTH
		set RM=$$^MSG(7013,WTH.roundCur(CRCD))
		}

	// Penalty assessed
	if PEN set TAMT.piece("#",4)=PEN
	set RM=$$^MSG(2999,RM.get(),PEN.roundCur(CRCD))

	// Available interest
	if IAF=2 do {
		set TAMT.piece("#",8)=INTAVLNCR
		set RM=$$^MSG(2995,RM.get(),INTAVLNCR.roundCur(CRCD))
		}
	
	quit 
	
INIT(RecordDEP dep,		// Deposit account			/REF:RW
     RecordTTX ttx)		// Transaction				/REF:R

	// Initialize data

	type public Number DIY,NUMDAYS,PRM,RATE,TAMT,TYR,YR
	type public String TSO

	type Date TEFD

	set PRM=dep.prm
	if PRM.isNull() set PRM=1
	
	set TAMT=ttx.tamt
	set TSO=ttx.tso
	
	set TEFD=ttx.efd
	set TEFD=$select(TEFD.isNull():%SystemDate,1:TEFD)

	if dep.dlr set NUMDAYS=TEFD-dep.dlr
	else  set NUMDAYS=TEFD-dep.odt
	
	set RATE=dep.iro/100              
	set DIY=$$DY^UIC(dep.iacm,TEFD)

	// Update Pr.Fin.Year indicator
	set YR=$$PYFLAG^DEPINT(.dep,.ttx)

	// Update Pr.Tax Year indicator
	set TYR=$$PTYFLAG^DEPINT(.dep,.ttx)

	quit 
	
	
ADJACR(RecordDEP dep,		// Deposit account			/REF:RW
       RecordTTX ttx,		// Transaction				/REF:R
       RecordTRN trn,		// Transaction code			/REF:R
       Number ADJ)		// Adjustment

	// Adjust accrued interest

	type String AMT,ETC
	type Boolean EC

	set EC=ttx.itc6+ttx.itc12

	type public Cache %CACHE()
	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:dep.type")

	if ADJ<0 do {
		set ETC=prodctl.dradin
		set AMT=$select(EC:ADJ,1:-ADJ)
		}
	else  do {
		set ETC=prodctl.cradin
		set AMT=$select(EC:-ADJ,1:ADJ)
		}

	set AMT=AMT_"##"_AMT
	
	do TR(.dep,.ttx,ETC,dep.cid,AMT,"ACRADJ")
	
	if 'EC set dep.posacr=dep.posacr+ADJ

	do EXPGL(.dep,.trn,.ttx) 

	quit


EXPGL(RecordDEP dep,		// Deposit account			/REF:RW
      RecordTRN trn,		// Transaction code			/REF:R
      RecordTTX ttx)		// Transaction				/REF:R

	// This section creates the interest expense G/L Offset transaction

	type public Boolean EC
	type public Cache %CACHE()
	type public Number ADJ,AMT,GRACE,PENINT,PRM
	
	type String ETC,TSO

	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:dep.type")

	// Build interest paid/penalty on early withdrawal transactions
	if dep.pipw,'GRACE.get() do PAYINT(.dep,.prodctl,.trn,.ttx) quit
	
	/*
	Penalty will come from accrued interest - build the credit
	to the penalty G/L to offset the decrease to accrual
	*/

	if 'PENINT.exists() set PENINT=0
	if (((PENINT>0)!((EC)&('dep.pipw)&(PRM>1)))&'GRACE.get()) do PENGL(.dep,.trn,.ttx,.prodctl) quit 
	
	// DEP GL for Interest Expense
	type RecordUTBLGLSC utblglsc=%CACHE("UTBLGLSC").getRecord("UTBLGLSC","GLSC=:dep.glsc")

	set AMT=+AMT
	set TSO="GLO#"_dep.cid

	if ADJ<0 set ETC="MCR"
	else  set ETC="MDR"

	do TR(.dep,.ttx,ETC,utblglsc.dgli,AMT,TSO)

	quit
	
	
TR(RecordDEP dep,		// Deposit account			/REF:RW
   RecordTTX ttx,		// Primary transaction			/REF:R
   String ETC,			// External transaction code
   Number CID,			// Account number
   Number AMT,			// Transaction amount
   String TSO,			// Teller source
   String TCMT,			// Teller comment			/NOREQ
   Boolean RECALC)		// Recalculate accruals			/NOREQ

	// Build secondary transaction and post

	type public Number BRCD

	type String ITC
	type Number TSEQ
	
	type RecordTRN trn2=Db.getRecord("TRN","ETC=:ETC")

	set ITC=trn2.itc

	if AMT<0 set ITC=ITC.extract(1,5)_"00000".extract(1,5-ITC.length())_1_ITC.extract(7,99)

	type RecordTTX ttx2=Class.new("RecordTTX")

	set ttx2.cid=CID
	set ttx2.itc=ITC
	set ttx2.etc=ETC
	set ttx2.tamt=AMT
	set ttx2.efd=%EffectiveDate
	set ttx2.tlo=%UserStation
	set ttx2.tso=TSO
	set ttx2.tcmt=TCMT.get()
	set ttx2.crcd=ttx.crcd

	// Post (update HIST / DTX) but do not process the posting program 
	// (updates to accounts are done in this procedure instead)
	do ttx2.setStoredValue("noPostProgram", 1)
	
        if '"DL".isLike("%"_trn2.cls_"%") do {
        	// Miscellaneous transaction
        	do TRNSINGL^TRNDRV(.ttx2,,,BRCD,4)
        	}
	else  do TRNSINGL^TRNDRV(.ttx2,.dep,,BRCD,4)

	// Recalculate interest for secondary transaction	
	if RECALC.get() do ENT^RECALC(.dep,.ttx2)
  
	quit


EC(RecordDEP dep,		// Deposit account			/REF:RW
   RecordTTX ttx,		// Primary transaction			/REF:R
   RecordTRN trn)		// Transaction code			/REF:R

	// Error Correct
	
	type public Number ADJ,ER,GRACE,INTPWD,NET,PEN,PENINT,POSACR,PRM,WTH
	type public String TAMT
	
	type Boolean EC=1
	type Date %EffectiveDate=""
	type Number GRCDYS
	
	do INIT(.dep,.ttx)
	if dep.ira do ^IRA(.dep,.ttx) quit:ER

	type public Cache %CACHE()
	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:dep.type")	

	if prodctl.grcdys.isNull() set GRCDYS=CUVAR.GRACE
	else  set GRCDYS=0

	if %EffectiveDate.isNull() set %EffectiveDate=%SystemDate

	if dep.dlr,(dep.dlr+GRCDYS+1)>ttx.efd set GRACE=1

	set NET=+$select(TAMT.isLike("%#%"):TAMT.piece("#",2),1:TAMT)
	set PEN=+TAMT.piece("#",4)

	// Add State W/H amount to the WTH
	set WTH=+TAMT.piece("#",5)+TAMT.piece("#",15)

	set INTPWD=ttx.lnerc.curVal.piece("#",22)
	set PENINT=ttx.lnerc.curVal.piece("#",23)
	set POSACR=ttx.lnerc.curVal.piece("#",2)

	set dep.bal=dep.bal-NET
	set dep.cntdr=dep.cntdr-1
	set dep.balcol=dep.balcol-NET

	if dep.iaf=1 set dep.intavl=dep.intavl+ttx.lnerc.curVal.piece("#",20)
	if dep.iaf=2 set dep.intavlncr=dep.intavlncr+ttx.lnerc.curVal.piece("#",20)
	set dep.intprior=dep.intprior+ttx.lnerc.curVal.piece("#",21)       
	set dep.posacr=dep.posacr-POSACR
	
	// Changed to adjust ACR by interest (penalty) portion of transaction
	if PRM'=1 set dep.posacr=dep.posacr-TAMT.piece("#",3)

	do ADJPER(.dep,trn.pcfd35)
	
	if %EffectiveDate,(%EffectiveDate-%SystemDate) do ENT^RECALC(.dep,.ttx)

	if PRM=1,POSACR do ADJACR(.dep,.ttx,.trn,POSACR) quit
	else  do {
		if EC,POSACR do ADJACR(.dep,.ttx,.trn,POSACR) quit

		if 'EC,POSACR do ADJACR(.dep,.ttx,.trn,(POSACR-PEN))
		}
	
	if trn.pcfd10 do FSECTR^DEPEC1(.dep,.ttx)
	
	// For error correction 
	if ttx.tso.isLike("%REV#%") do ^UPDCCLD(.dep,.ttx)

	quit 

	
AUT(RecordDEP dep,		// Deposit account		/REF:RW
    RecordTTX ttx,		// Primary transaction		/REF:R
    RecordTRN trn)		// Transaction code		/REF:R

	// Authorization Verification

	type public Number NET
	type public String OVR(),TAMT

	// Deposit account transaction authorization restrictions	
	do AUT^UHLD(.dep,TAMT,ttx.itc,.OVR)
	
	// Transaction restrictions
	if dep.rflg do ^UFLG(.dep)
	
	// Stop payment retrictions
	if dep.stp do STOP^DEPPO(.dep,.ttx)
	
	// Credit / debit transaction restrictions
	if dep.flg do FLG^UFLG(.dep,ttx.itc)
	
	// New balance is less than minimum allowed of $<MINBAL>
	if (dep.bal-NET)<dep.minbal set OVR(dep.cid,"OVR","MINBAL")=dep.minbal.roundCur(dep.crcd)
	
	// Debit amount must be in increment of $<INCDR>
	if dep.incdr,(NET#dep.incdr) set OVR(dep.cid,"OVR","INCDR")=dep.incdr.roundCur(dep.crcd)
	
	// Withdrawal amount is less than minimum of $<MINDR>
	if NET<dep.mindr set OVR(dep.cid,"OVR","MINDR")=dep.mindr.roundCur(dep.crcd)
	
	// Withdrawal amount is greater than maximum of $<MAXDR>
	if dep.maxdr,NET>dep.maxdr set OVR(dep.cid,"OVR","MAXDR")=dep.maxdr.roundCur(dep.crcd)

	// Withdrawal amount is greater than maximum of $<SSWLIM>
	if dep.sswlim,NET>dep.sswlim set OVR(dep.cid,"OVR","SSWLIM")=dep.sswlim.roundCur(dep.crcd)
	
	// New balance is less than minimum to accrue $<MINACR>
	if dep.minacr,(dep.bal-NET<dep.minacr) set OVR(dep.cid,"OVR","MINACR")=dep.minacr.roundCur(dep.crcd)

	if dep.iaf do {
		type Number TOTINTAV=$$TOTINTAV^DEPCDI(dep.cid)
		
		// Transaction exceeds available int/div of $<INTAVL>
		if NET>TOTINTAV set OVR(dep.cid,"OVR","INTAVL")=TOTINTAV.roundCur(dep.crcd)
		}

	// Account not in active status
	if dep.stat set OVR(dep.cid,"OVR","STAT"_dep.stat)=""
	
	// Partial Withdrawals Require Approval
	if dep.daparwd set OVR(dep.cid,"OVR","PWTRA")="" 

	quit 

	
PAYINT(RecordDEP dep,			// Deposit account		/REF:RW
       RecordPRODCTL prodctl,		// Product type			/REF:R
       RecordTRN trn,			// Transaction code		/REF:R
       RecordTTX ttx)			// Transaction			/REF:R

	// Pay Interest on Partial Withdrawal

	type public Boolean EC
	type public Number ADJ,AMT,BWA,CID,ER,INT,INTPWD,IRN
	type public Number NTAX,PEN,PENINT,PRM,SAVPEN
	type public String BWAPGM,TAMT,TSO
	type public Boolean TYR, YR
	
	type String ETC

	if 'dep.pipw quit

	if EC do {                         
		// Redo penalty calculation
		do PROC(.dep,.ttx,.trn,1,PEN)
	
		// Obtain original values from the original transaction
		set INTPWD=ttx.lnerc.curVal.piece("#",22)        
		set PENINT=ttx.lnerc.curVal.piece("#",23)        
		set ADJ=ttx.lnerc.curVal.piece("#",2)
		}
	
	/*
	If PRM=2, then excess penalty may be in principal, and this also
	must be removed from interest paid on the withdrawal.
	*/
	
	// Int paid less penalty
	if PRM=2 set INTPWD=INTPWD-PENINT-PEN  
	else  set INTPWD=INTPWD-PENINT
	
	// No int remains
	if EC,INTPWD=0 do PENGL(.dep,.trn,.ttx,.prodctl) quit
	if 'EC,INTPWD'>0 do PENGL(.dep,.trn,.ttx,.prodctl) quit         
	
	if dep.bwf do { quit:ER

		// Do not recalculate withholding (BWA is left as is)
		if dep.awtp quit
        
		type Number TAXRATE=""

		/*
		Determine tax on interest to be paid to customer
		dep.awti must be included for accounts that have dep.awti and dep.awtp=0
		*/

		do ^DEPBW(.dep,.ttx,.INTPWD,.BWA,.NTAX,.BWAPGM,dep.awti,IRN,.TAXRATE) quit:ER

		set BWA=BWA.roundCur(dep.crcd)

		if dep.awtr'=TAXRATE do { quit:ER
			do dep.setAuditFlag(1)
			set dep.awtr=TAXRATE
			}
		}
	
	if INTPWD>INT set INTPWD=INT
	
	/*
	For error corrects/reversal, negate amounts before building
	the transactions.
	*/

	if EC set INTPWD=-INTPWD,PENINT=-PENINT

	if INTPWD'=0 do {                      
		if EC set BWA=-BWA

		// Deduct tax                    
		set AMT=INTPWD_"#"_(INTPWD-BWA)_"###"_BWA     
		set TSO=""
		set ETC=prodctl.crtrin

		// Update IIPC with REV#
		if EC do TSOSEC(.ttx)
		    
		do TR(.dep,.ttx,ETC,dep.cid,AMT,TSO)              
		}
	
	// Update balances and interest paid fields
	set dep.bal=dep.bal+INTPWD-BWA         
	set dep.balcol=dep.balcol+INTPWD-BWA   
	set dep.posacr=dep.posacr-INTPWD-BWA   
	set dep.ipl=dep.ipl+INTPWD 

	if YR do {
		set dep.iytd=dep.iytd+INTPWD
		set dep.bwy=dep.bwy+BWA
		}
	
	else  do {
		set dep.ipy=dep.ipy+INTPWD
		set dep.bwp=dep.bwp+BWA
		}

	if TYR do {              
		set dep.itytd=dep.itytd+INTPWD
		set dep.bwtytd=dep.bwtytd+BWA
		}

	else  do {
		set dep.ipty=dep.ipty+INTPWD
		set dep.bwpty=dep.bwpty+BWA
		}

	// Build G/L offset
	do PENGL(.dep,.trn,.ttx,.prodctl)
	
	// Check if the interest paid should be transferred
	if dep.iopt=2 do IOPT2(.dep,.prodctl,.ttx,(INTPWD-BWA))

	quit 
	
	
PENGL(RecordDEP	dep,			// Deposit account		/REF:RW
      RecordTRN trn,			// Transaction code		/REF:R
      RecordTTX ttx,			// Transaction			/REF:R
      RecordPRODCTL prodctl)		// Product type			/REF:R

	// Build transaction to post to penalty income (via client account)
	
	type public Boolean EC
	type public Number ADJ,AMT,CID,PENINT,PRATE,PRM

	type String ETC,TSO()	

	set AMT=PENINT_"###"_PENINT
	            
	if EC,'dep.pipw,PRM>1 set AMT=ADJ_"###"_ADJ
	
	if PENINT=0,'EC quit
	if ADJ=0,EC quit
	
	if PRATE.exists() set TSO="PRATE#"_PRATE
	
	// Use penalty tran code; if null, use General Purpose Credit tran code
	set ETC=prodctl.cradpac
	if ETC.isNull() set ETC=prodctl.crtrgp
	
	if +AMT'=0 do {
		/*
		If this is an effective dated transaction, then this additional
		transaction to post penalty income may need an additional 
		accrual adjustment as well. Another call into RECALC will 
		analyze this transaction and generate another interest posting 
		if necessary.
	        */
		type Boolean RECALC
		
		if ttx.efd,ttx.efd-%SystemDate set RECALC=1
		else  set RECALC=0
		
		do TR(.dep,.ttx,ETC,dep.cid,AMT,TSO,,RECALC)
		}
	 
	quit 

	
IOPT2(RecordDEP	dep,			// Deposit account		/REF:RW
      RecordPRODCTL prodctl,		// Product type			/REF:R
      RecordTTX ttx,			// Transaction			/REF:R
      Number AMT)			// Transaction amount

	/*
	If Interest Disbursement Option is 2 (transfer interest paid to another
	account), then we must build the transactions to debit the term deposit 
	account and credit the transfer account.
	*/

	type public Number BWA,INT,INTPWD

	type String ETC,TCMT
	type Number XCID

	quit:(INT'>0)
	
	// Build transaction to debit the term deposit account
	
	// Transfer to ~p1
	set TCMT=$$^MSG(3940,dep.itrf)         
	set ETC=prodctl.drtrgp
	
	do TR(.dep,.ttx,ETC,dep.cid,AMT,"",TCMT)

	// Update the term deposit account's balances
	set dep.bal=dep.bal-AMT
	set dep.balcol=dep.balcol-AMT

	// Build transaction to credit the transfer account
	set XCID=dep.itrf
	
	// Int/Div transfer account required
	if XCID.isNull() do Runtime.setErrMSG("DEP",1257) quit

	// Transfer from ~p1
	set TCMT=$$^MSG(3939,dep.cid)
	
	// General Purpose Credit tran code
	set ETC=prodctl.crtrgp
	
	do TR(.dep,.ttx,ETC,XCID,AMT,"",TCMT)

	// Update the transfer account's balances
	type RecordDEP dep2=Db.getRecord("DEP","CID=:XCID")
	set dep2.bal=dep2.bal+AMT
	set dep2.balcol=dep2.balcol+AMT

	quit 
	
	
TSOSEC(RecordTTX ttx)		// Primary transaction			/REF:R

	// Find the original transaction generated by the secondary and use 
	// that in TSO REV#seq
	
	type public Number HSEQ,HTRC
	type public String TSO
	
	type Boolean HIT=0
	type Number TRC,tseq,TSEQ,TSO1,TSO2
	type String TAMT,vsql

	do OUT^UTSO(.TSO1,ttx.tso)

	if TSO1("EC").exists() set TSO2=$$FIELDIN^UTSO(TSO2,"EC",TSO1("EC"))
	if TSO1("REV").get() set HSEQ=TSO1("REV")
	if TSO1("EC").get() set HTRC=TSO1("EC")

	type ResultSet rs=Db.select("TAMT","HIST","CID=:CID and TSEQ=:HSEQ and TRC=:HTRC","TSEQ DESC")
	if rs.isEmpty() quit
	while rs.next() do {
		set TAMT=rs.getCol("TAMT")
		if TAMT+ttx.tamt quit

		set TSO2=$$FIELDIN^UTSO(TSO2,"REV",HSEQ)
		set HIT=1
		}

	if 'HIT,TSO1("REV").get() set TSO2=$$FIELDIN^UTSO(TSO2,"REV",TSO1("REV"))

	set TSO=TSO2               
	
	quit 


ADJPER(RecordDEP dep,		// Deposit account			/REF:RW
       Boolean PCFD35)		// Do not update prior tax year buckets

	// Adjust for penalty period

	type public Number DSWA,DWA,PEN,PENINT,TYR,WTH,YR

	if YR do {
		set dep.bwy=dep.bwy+WTH
		set dep.pytd=dep.pytd+PEN+PENINT.get()
		
		// Add Federal and State W/H Year-to-date
		set dep.fwy=dep.fwy+DWA.get()
		set dep.swy=dep.swy+DSWA.get()
		}

	else  do {
		set dep.bwp=dep.bwp+WTH
		set dep.ppy=dep.ppy+PEN+PENINT.get()
		
		// Add Federal and State W/H Prior Year
	        set dep.fwp=dep.fwp+DWA.get()
	        set dep.swp=dep.swp+DSWA.get()
		}

	if TYR do {
		set dep.bwtytd=dep.bwtytd+WTH
		set dep.pentytd=dep.pentytd+PEN+PENINT.get()
		}

	if 'TYR,'PCFD35 do {
		set dep.bwpty=dep.bwpty+WTH
		set dep.penpty=dep.penpty+PEN+PENINT.get()
		}

	set dep.ppl=dep.ppl+PEN+PENINT.get()

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60773^8877^Hari Natrajan^24851"	// Signature - LTD^TIME^USER^SIZE
