ISO8583(IM)
	/*
	 Procedure ID: ISO8583
	 DESC: ISO 8583 Message Processor
	 ORIG: Ed Sigda - 03/19/2001

	 DESC: Message processor for clients using message formats based 
	       on ISO 8583 (1987), which includes a number of private 
	       extensions.
	 ----------------------------------------------------------------------
	 This routine receives messages from the network switch in various
	 formats and re-formats them into PROFILE structure for transaction
	 processing.

	 The messages are variable length, and the structure changes based on
	 the context of the message itself. Financial transaction messages
	 are similar, though not standard. In order to properly identify the
	 content of a particular message, a series of bitmaps are included
	 in the message. These bitmaps identify the data elements that are
	 contained in the message. Each bitmap is comprised of 16 hexadecimal
	 bytes, where each byte corresponds to 4 data elements that may appear
	 in the message.

	 Once the transaction is processed, an outgoing message is built
	 to be sent back to the calling application.
	 ----------------------------------------------------------------------
	 Message Types:
	  *	Received from the Switch
	  **	Sent to the Switch

		*	0100	Pre-Authorization Request
		**	0110	Pre-Authorization Request Reply
		*	0120	Pre-Authorization Advice
		**	0130	Pre-Authorization Advice Reply

		*	0200	Financial Transcation Request
		**	0210	Financial Transcation Request Reply
		*	0220	Store and Forward Transaction Request
		**	0230	Store and Forward Transaction Request Reply

		*	0400	Authorization Reversal Request
		**	0410	Authorization Reversal Request Response
		*	0420	Authorization Reversal Advice
		**	0430	Authorization Reversal Advice Response

		**	0800	Network Management
		*	0810	Network Management Response	

	 Repeat versions of all request messages are also supported, 
	 e.g., 0101, 0121, 0201, etc.
	 ----------------------------------------------------------------------
	 The online processing is as follows.

	 The message is passed to an INCOMING subroutine, where the data
	 contained in the message is "translated" into local variables.

	 Once the message has been "translated", the transaction is then
	 processed using the local variables.  If the message is a financial
	 transaction, the necessary variables are passed to a processing
	 subroutine, where PROFILE attempts to process the transaction.  As
	 part of this process, the success or failure of the transaction is
	 determined.

	 The last step in this process is to construct an outgoing message
	 to be sent to the network switch. The outgoing message is formatted
	 using the information pertinent to the transaction and a response
	 code based on the success or failure of the transaction as
	 determined by PROFILE.

	 There are four main line tags:
		INIT    	Initializes ATM and ISO8583 variables
		INCOMING	Receives and reformats incoming messages
		PROC		Processes the transaction in PROFILE
		OUTGOING	Reformats outgoing messages

	 There are also line tags that can be customized:
		BLDMSG		Vendor specific message bits
		INITTBL		Initialize TBL array
		INIT2		Modify or add additional code prior to
				processing the transaction
		FAPIN		Remove optional headers
		FAPOUT		Replace optional headers
		GETBAL		Balance Information
		HDR		Build Header Information
		STMT		Statement Request
		RESPONSE	Response message processing
		POSTPRE		POST section pre-processor
		POSTPST		POST section post-processor
		BLDPRE		BLDOM section pre-processor
		VLDMSG		Validate incoming message
		NETWORK		Network Management Message Support
		RECON		Reconciliation Message Support
	 ----------------------------------------------------------------------
	 ---- Revision History ------------------------------------------------

	 27-Aug-2007 - Brandon Rickards - CR 28685
	 	o Added SPV to top new list

	 11-May-2007 - Brandon Rickards - CR 27068
	 	o Release including the following changes:

		Merged Profile_V72 version with most recent release version

		Added sections RESPONSE,POSTPRE,POSTPST,BLDPRE,VLDMSG,
		NETWORK,RECON
		Added calls to custom procedure ZISO8583
		Modified section INCOMING to use either transaction fields or 
		settlement fields to determine transaction amount and fee amount

		04/09/07 - VanithaK - CR26473
                Modified the INIT section to check if the user id is valid
                and give the error message if not.

		12/09/05 - chhabris - CR16677
		Replaced the reference to index table UTBLCRCDNO with CRCD.

		10/05/05 - ALAGARSS - CR16677
		Removed deprecated method Db.getOneRow and replaced with
		Db.getRecord. 
   
		05/24/05 - RussellDS - CR16071
		Converted M TP commands to PSL Runtime methods.

		Removed old revision history.

	 ----------------------------------------------------------------------
	*/

	// Drop null message (no reply)
	if IM.get().isNull() quit ""

	type public String BIT,BITFMT,CC,CRCD,CUTOFF,DEFAULT,DELDUP,EBC,ETC,ETCCR,ETCDR,EXTCODE
	type public String FCID,MERCHNM,MID,MSGHDR,OIM,PAUTH,REGETYPE,RSPCD,RT,SAFUCLS,SPR,SPV(),TBL,TCID,TCMT,TCODE
	type public String TRACE,TRTYP,TSO,UPK,VALID,VLB
	type public Number AMT2,AMT2FEE,ATMM,AUTCODE,BCAL,BILAMT,CRDNUM,FINPRE,NETID,NETWORK
	type public Number OM,PAMT,PARTIAL,PCID,PHC,PHDAYS,POS,POSADJ,PRCD,PRE,PSTDYS,RECON,REPEAT,RESPONSE
	type public Number REV,STF,TAMT,TAMTFEE

	// 43027
	if INTRFACE.get().isNull() set INTRFACE="ISOATM"

	// Initialize variables
	do INIT(INTRFACE)

	// Unique message sequence for NSMLOG
	set ATMM=$$NXTSEQ^ATMUTL()

	// Save original IM message
	set OIM=IM

	// Remove message header
	#IF $$VALID^%ZRTNS("ZISO8583") do FAPIN^ZISO8583

	// Format incoming message
	do INCOMING(IM,.TBL,.BIT)
	// Drop message (no reply)
	#IF $$VALID^%ZRTNS("ZISO8583")
	if RESPONSE do RESPONSE^ZISO8583 quit ""
	#ELSE
	if RESPONSE quit ""
	#ENDIF
	// Process transaction
	do PROC	
	// Build outgoing message				
	do OUTGOING(.OM,.TBL,.BIT)		
	// Attach the message header
	#IF $$VALID^%ZRTNS("ZISO8583") do FAPOUT^ZISO8583

	// Log Messages. If TRollback occured in application, issue new TStart
	if $TLevel=0 do {  if 1
		do Runtime.start("CS")
		do NSMLOG^PBSNSM(INTRFACE,ATMM,OIM,OM,RM.get().extract(1,40))
		do Runtime.commit()
		}
	else  do NSMLOG^PBSNSM(INTRFACE,ATMM,OIM,OM,RM.get().extract(1,40))

	quit OM


INIT(INTRFACE)
	/*
	 Initialize variables
	*/
	type public Boolean ER
	type public Number BRCD,FINPRE,NETWORK,PHC,PRE,PHDAYS,PCID,POS,POSADJ,REPEAT,RESPONSE,REV,STF
	type public String BCAL,RSPCD,RM,VALID
	type public String AMT2,AUTCODE,CC,CRCD,ETCCR,ETCDR,FCID,MID,MSGHDR,OM,PAMT,PRCD
	type public String SETAMT,SPR,TAMT,TCID,TCMT,TCODE,TRACE,TRTYP,TSO,VLB
	type public String BITFMT,CUTOFF,DEFAULT,DELDUP,NETID,REGETYPE,RT,SAFUCLS
	type public String EBC,PSTDYS,%STFHOST,UPK
	
	// Initialize to success
	set ER=0
	set RM=""
	set RSPCD="00"

	set (FINPRE,NETWORK,PARTIAL,PAUTH,PCID,POS,POSADJ,RECON,REPEAT,RESPONSE)=0
	set (REV,STF,VALID)=0
	set (AMT2,AUTCODE,CC,CRCD,ETCCR,ETCDR,FCID,MERCHNM,MID,MSGHDR,OM,PAMT,PRCD)=""
	set (SETAMT,SPR,TAMT,TCID,TCMT,TCODE,TRACE,TRTYP,TSO,VLB)=""

	type RecordUTBLEXTINT extint

	set extint=Db.getRecord("UTBLEXTINT","INTRFACE=:INTRFACE")

	#ACCEPT DATE=01/02/04;PGM=John Carroll
	set %SessionID=""			// Token, required for STFHOST
	set %UserID=extint.uid			// Teller id for ATM processing
	set BRCD=extint.brcd			// Branch code
	set SAFUCLS=extint.safucls		// Store and forward userclass
	set RT=extint.rt			// Hold table
	set BCAL=extint.bcal			// Business day calendar
	set NETID=extint.iin			// Network id
	set PHDAYS=extint.phdays		// Permanent hold days
	set PHC=extint.phc			// Permanent hold code
	set DELDUP=extint.dupmsg		// Delete ATMDUP entries
	set PSTDYS=extint.srchdays		// Number of search days
	set PRE=extint.preauth			// Pre-authorizations only
	set DEFAULT=extint.defacct		// Default account type
	set REGETYPE=extint.trmlocfmt		// Terminal location format
	set BITFMT=extint.misc1			// Bit data element format
	set CUTOFF=extint.hldcuttim		// Hold cutoff time

	// Use default values if not defined
	if SAFUCLS="" do {
		type RecordCUVAR cuvar=Db.getRecord("CUVAR")
		set SAFUCLS=cuvar.dftstfucls
	}
	if SAFUCLS="" set SAFUCLS="MGR"
	if PHC="" set PHC=92
	if PSTDYS="" set PSTDYS=1
	if PRE="" set PRE=0
	// Default account - Checking
	if DEFAULT="" set DEFAULT=20
	if REGETYPE="" set REGETYPE=1
	if BITFMT="" set BITFMT="000"

	type RecordSCAU scau=Db.getRecord("SCAU","UID=:%UID",1)
	// Invalid user ~p1
	if 'scau.getMode() do Runtime.setErrMSG("SCAU",7591,%UID) quit:ER
        else  set %UserClass=scau.%ucls

	set %STFHOST=%STFHOST.get()

	/*
	 VLB - Variable length binary indicator

	 The variable length indicator will indicate the format of the
	 variable length byte(s).

		. 0	not binary
		. 1	binary length of 1 only
		. 2	binary length of 1 or 2
	*/
	set VLB=BITFMT.extract()

	// UPK - Unsigned packed format option
	set UPK=BITFMT.extract(2)

	// EBC - EBCDIC format option
	set EBC=BITFMT.extract(3)

	// Initialize TBL array
	#IF $$VALID^%ZRTNS("ZISO8583")
	 do INITTBL^ZISO8583
	#ELSE
	 do INITTBL
	#ENDIF

	quit


INCOMING(IM,TBL,BIT)
	/*
	 Receives and parses incoming messages in variable "IM"
	 ARGUMENTS:
		IM	- Incoming message from the switch
		TBL	- Data element descriptions (see BITMAP section)
		BIT	- Data element values
	*/

	type public Date ATMD,SETDT
	type public Number ATMID,AMT2,AMT2FEE,PRE,REPEAT,RESPONSE,REPAMT,REV,STF,TAMT,TAMTFEE,VALID
	type public String ATMT,AUTCODE,CRCD,CNTRY,CTY,CRDNUM,EXP,FRGRP,FRTYP,GRP,INTRFACE,MID,MERCH,NETWORK,ODTTM,OMID,ORIGINAL,OTRACE,RM,RSPCD,SPR,TRACE
	type public String REGE,SETFLG,STA,STREET,TCRCD,TOGRP,TOTYP,TRACK2,TRCD,TRMNL,UTSO,VALMID
	
	// Set up array of data elements
	set MID=$$BITMAP(IM,.TBL,.BIT)

	// 43027 - Update SBN Host Server Status
	if INTRFACE="ISOSBN" do UPDSTAT^ISOSBN

	// Check if communication response
	if MID.extract(3)#2 set RESPONSE=1 quit

	// Validate incoming message
	#IF $$VALID^%ZRTNS("ZISO8583")
	set VALID=$$VLDMSG^ZISO8583(MID,.BIT)
	#ELSE
	set VALID=$$VLDMSG(MID,.BIT)
	#ENDIF
	// Invalid transaction ~p1
	if 'VALID set RSPCD=$S(RSPCD="00":$$RSPCD(1502,.RM,MID),1:RSPCD) quit

	// Determine message type
	if MID.extract(2)=8 set NETWORK=1
	if MID.extract(2)=5 set RECON=1
	if MID.extract(2)=1 set (POS,PRE)=1
	if MID.extract(2)=4 set REV=1
	if MID.extract(3)=2 set STF=1
	if MID.extract(4)=1 set REPEAT=1

	// Translate into return message ids for outgoing messages
	set MID=MID.extract(1,2)_(MID.extract(3)+1)_$S(MID.extract(4)<2:0,1:2)

	// Network messages are not processed in the INCOMING section
	if NETWORK quit

	// Reconciliation messages are not process in the INCOMING section
	if RECON quit
	/*
	 The Card Number needs to be retrieved from the following
	 places in this sequence:  Bit 34, Bit 2, Bit 35 for eFunds ATMs.
	*/
	set CRDNUM=BIT(34).get()
	set TRACK2=BIT(35).get()
	if CRDNUM="" set CRDNUM=BIT(2).get()			// Not in 34 use 2
	if CRDNUM="",TRACK2["D" set CRDNUM=TRACK2.piece("D",1)	// Not in 2, use 35
	if CRDNUM="",TRACK2["=" set CRDNUM=TRACK2.piece("=",1)	// Not in 2, use 35

	// Message Information
	set MERCH=BIT(18).get()		// Merchant category code
	set AUTCODE=+BIT(38).get()	// Authorization code (PROFILE generates number if not defined)
	set ORIGINAL=BIT(90).get()	// Original data elements
	set REPAMT=BIT(95).get()	// Replacement amounts

	// System trace audit number
	set TRACE=BIT(11).get()
	if TRACE="" set TRACE=INTRFACE

	// Terminal id
	set ATMID=$$RTB^%ZFUNC(BIT(41).get())

	/*
	 AUTCODE cannot begin with a 9 for some vendors, so only use 5
	 of the 6 possible characters.
	*/
	if 'AUTCODE set AUTCODE=$$GET^NXTSEQ("ISOAUTH",5)

	// Dates and Times
	set ATMT=BIT(12).get()		// Local transaction time
	set ATMD=BIT(13).get()		// Local transaction date
	set SETDT=BIT(15).get()		// Settlement date

	// TLO and SPR fields will uniquely identify a message
	set %UserStation=INTRFACE.extract(4,INTRFACE.length())_"-"_TRACE
	set SPR=ATMD_ATMT

	// Card acceptor location
	set REGE=BIT(43).get()

	/*
	 Determine transaction fields (transaction or settlement)
	 Bit 49 (transaction currency code) is always defined for
	 transactions with a Bit 50 (settlement currency code).
	 If Bit 50 is defined, then Bit 49 contains the code for the
	 currency dispensed by the ATM switch.
	*/
	set SETFLG=$S(BIT(50).get()="":0,1:1)

	/*
	 Use transaction fields or settlement fields
	 NOTE: Adjust AMT2 & AMT2FEE with Replacement amounts found in Bit
	 95.  Bit 95 consists of 4 data elements which are in fixed length
	 format. Absence of data is indicated by zeroes in the data element.
	 The 4 elements are:
		Actual amount, transaction (n 12)
		Actual amount, settlement (n 12)
		Actual amount, Transaction fee (x + n 8)  x=sign D or C
		Actual amount, settlement fee (x + n 8)
	*/
	if SETFLG do {

		// Validate currency code
		set CRCD=$$CRCD(BIT(50).get())
		if CRCD="" set RSPCD=$$RSPCD(1293,.RM) quit

		// Determine decimal position
		set EXP=$$EXP(CRCD)

		// Determine transaction amount
		set TAMT=BIT(5).get()/EXP

		// Determine fee amount (transaction fee + transaction processing fee)
		set TAMTFEE=($$XN(BIT(29).get())+$$XN(BIT(31).get()))/EXP

		// Determine adjustment amounts
		if REV,REPAMT'="" do {
			set AMT2=REPAMT.extract(13,24)/EXP
			set AMT2FEE=$$XN(REPAMT.extract(34,42))/EXP
		}
		else  set (AMT2,AMT2FEE)=0
	}
	else  do {

		// Validate currency code
		set CRCD=$$CRCD(BIT(49).get())
		if CRCD="" set RSPCD=$$RSPCD(1293,.RM) quit

		// Determine decimal position
		set EXP=$$EXP(CRCD)

		// Determine transaction amount
		set TAMT=BIT(4).get()/EXP

		// Determine fee amount (transaction fee + transaction processing fee)
		set TAMTFEE=($$XN(BIT(28).get())+$$XN(BIT(30).get()))/EXP

		// Determine adjustment amounts
		if REV,REPAMT'="" do {
			set AMT2=REPAMT.extract(1,12)/EXP
			set AMT2FEE=$$XN(REPAMT.extract(25,33))/EXP
		}
		else  set (AMT2,AMT2FEE)=0
	}
	if ER quit

	// Original Data Elements
	if ORIGINAL'="" do {
		set OMID=ORIGINAL.extract(1,4)	 // Original message type
		if (OMID.extract(2)=1),(MID.extract(2)=4) set (POS,PRE)=1  // Previous pre-authorization
		set OTRACE=ORIGINAL.extract(5,10)	 // Original sys trace audit #
		set ODTTM=ORIGINAL.extract(11,20)	 // Original date/time of tran
		}

	// Determine if it's a partial reversal
	if REV,(AMT2'=0),(TAMT'=AMT2) set PARTIAL=1

PRCD	/*
	 Set up the process code and the transaction type (TRTYP).
	 The processing code contains three (3) pieces of information: the
	 transaction type or action code, the "from" account and the "to"
	 account.
	 	Transaction types:
	 	--------------
		00	Goods or Service Purchase
		01	Withdrawal/Cash Advance
		09	Purchase with Cashback
		20	Merchandise Return
		21	Deposit - Cash
		24	Deposit - Cheque
		30	Balance Inquiry
		31	Balance Inquiry
		40	Account Transfer

		Account types:
		--------------
		0x	Default
		1x	Savings
		2x 	Checking
		3x	Credit Facility
		9x	Loan
	*/

	type public Boolean ER
	type public Cache %CACHE()
	type public Number FINPRE,PAUTH,POSADJ
	type public String DEFAULT,ETCDR,ETCCR,EXTCODE,FCID,PCID,PRCD,TCID,TCODE,TRTYP
	type public String ATMM,AUTOCODE,POS,REGETYPE,TCMT,TSO

	// Processing code
	set PRCD=BIT(3).get()

	// Account numbers
	set FCID=BIT(102).get()
	set TCID=BIT(103).get()

	/* Determine on-us/off-us
		. null	not used
		. 0	on-us
		. 1	off-us
	*/
	set TRMNL=""

	// POS completion request - Not applicable to bank transactions
	// It may make sense to use MERCH=5411, Retail Sales.
	if MERCH'=6011,MID.extract(2)=2,PRCD.extract(1,2)="00" set FINPRE=1

	// Custom section INIT2 can be used to modify or define custom information
	#IF $$VALID^%ZRTNS("ZISO8583") if INTRFACE'="ISOSBN" do INIT2^ZISO8583

	// 43027
	#IF $$VALID^%ZRTNS("ZISOSBN") 
	 if INTRFACE="ISOSBN" do INIT2^ZISOSBN
	#ELSE 
	 if INTRFACE="ISOSBN" do INIT2^ISOSBN
	#ENDIF

	if ER quit

	// Data required
	if CRDNUM="" set RSPCD=$$RSPCD(3784,.RM,"") quit

	// Transaction type
	set TCODE=PRCD.extract(1,2)

	set FRTYP=PRCD.extract(3,4)
	set TOTYP=PRCD.extract(5,6)

	// Check if message account codes should be ignored
	if DEFAULT="99" set (DEFAULT,FRTYP,TOTYP)="00"

	set FCID=+FCID,TCID=+TCID

	if FRTYP="00",FCID'=0 do {
		if INTRFACE="ISOSBN",PRE quit	// Do not reset FRTYP for SBN 0100's
		
		type RecordACN acn = Db.getRecord("ACN","CID=:FCID")
		set GRP = acn.grp
		set FRTYP=$S(GRP="SAV":10,GRP="DDA":20,GRP="RC":30,GRP="COM":90,GRP="MTG":91,GRP="LN":92,1:"00")
		}
	if TOTYP="00",TCID'=0 do {
		if INTRFACE="ISOSBN",PRE quit	// Do not reset TOTYP for SBN 0100's
		
		type RecordACN acn = Db.getRecord("ACN","CID=:TCID")
		set GRP = acn.grp
		set TOTYP=$S(GRP="SAV":10,GRP="DDA":20,GRP="RC":30,GRP="COM":90,GRP="MTG":91,GRP="LN":92,1:"00")
		}

	// Get account(s) from the card number
	if INTRFACE'="ISOSBN",FCID=0,TCID=0 do {
		// Use DEFAULT value to determine account type codes
		if FRTYP="00",TOTYP="00" do DEFAULT(CRDNUM,DEFAULT)

		if ER quit

		// Primary account defined by section DEFAULT
		if FCID'=0!(TCID'=0) quit

		set FRGRP=$S(FRTYP=10:"SAV",FRTYP=20:"DDA",FRTYP=30:"RC",FRTYP=90:"COM",FRTYP=91:"MTG",FRTYP=92:"LN",1:"")
		set TOGRP=$S(TOTYP=10:"SAV",TOTYP=20:"DDA",TOTYP=30:"RC",TOTYP=90:"COM",TOTYP=91:"MTG",TOTYP=92:"LN",1:"")

		if FRGRP'="" set FCID=$$GETCID(CRDNUM,FRGRP) quit:ER
		if TOGRP'="" set TCID=$$GETCID(CRDNUM,TOGRP) quit:ER
		}

	if ER quit

	set PRCD=TCODE_FRTYP_TOTYP

	// Validate PRCD and determine the PROFILE transaction codes
	set EXTCODE=PRCD_TRMNL
	set TRCD=$$GETTRN^ATMUTL(INTRFACE,EXTCODE,STF)
	if ER set RSPCD=$$RSPCD(RSPCD,.RM) quit

	// Define TRTYP from UTBLEXTTRN1
	set TRTYP=TRCD.piece($C(9),1)
	
	// Set PCID to the customer's account number
	set PCID=$S(TRTYP'="CREDIT":FCID,1:TCID)

	// Allow partial authorizations
	if PRE set PAUTH=1

	// Not financial
	if TRTYP'="DEBIT",TRTYP'="CREDIT",TRTYP'["SUSP" quit

	// Validate from account and to account
	if TRTYP'="CREDIT",'Db.isDefined("ACN","FCID") do { quit:ER
		// Invalid FROM account number ~p1
		if 'STF set RSPCD=$$RSPCD(2095,.RM,FCID) quit

		// Advice message must process, change to suspense trancodes
		type public String STFCODE
		set STFCODE="SUSPDR"
		if (INTRFACE="ISOSBN"),(PRCD.extract(1,2)=40) set STFCODE="SUSP"
		set TRCD=$$GETTRN^ATMUTL(INTRFACE,STFCODE,STF)
		if ER set RSPCD=$$RSPCD(RSPCD,.RM) quit
		set TRTYP=TRCD.piece($C(9),1)
		}
	if TRTYP="CREDIT",'Db.isDefined("ACN","TCID") do {
		// Invalid TO account number ~p1
		if 'STF set RSPCD=$$RSPCD(2096,.RM,TCID,TCID) quit

		// Advice message must process, change to suspense trancodes
		set TRCD=$$GETTRN^ATMUTL(INTRFACE,"SUSPCR",STF)
		if ER set RSPCD=$$RSPCD(RSPCD,.RM) quit
		set TRTYP=TRCD.piece($C(9),1)
		}
	if ER quit

	/*
	 Adjust TAMT based on fees. The fee amounts (TAMTFEE & AMT2FEE)
	 reflect cardholder's perspective (a negative amount for a fee
	 and a positive amount for a rebate).
	 Examples:
	 $100 DR with $2 fee		$102 total amount (100 - (-2))
	 $100 DR with $2 rebate		$98  total amount (100 - ( 2))
	 $100 CR with $2 fee		$98  total amount (100 + (-2))
	 $100 CR with $2 rebate		$102 total amount (100 + ( 2))

	 For reversals, the fee amount values are switched (C or D),
	 so the logic must be switched.
	 Examples:
	 $100 DR with $2 fee (REV)	$102 total amount (100 + ( 2))
	 $100 DR with $2 rebate (REV)	$98  total amount (100 + (-2))
	 $100 CR with $2 fee (REV)	$98  total amount (100 - ( 2))
	 $100 CR with $2 rebate (REV)	$102 total amount (100 - (-2))
	*/
	if TRTYP'="CREDIT" do {
		set TAMT=$S(REV:TAMT+TAMTFEE,1:TAMT-TAMTFEE)
		set AMT2=AMT2-AMT2FEE
	}
	else  do {
		set TAMT=$S(REV:TAMT-TAMTFEE,1:TAMT+TAMTFEE)
		set AMT2=AMT2+AMT2FEE
	}

	// POS Adjustment
	if TCODE="02"!(TCODE="22") set POSADJ=1

	// Debit and Credit transaction codes
	set ETCDR=TRCD.piece($C(9),2)
	set ETCCR=TRCD.piece($C(9),3)

	// Redefine account numbers for suspense trancodes
	if TRTYP["SUSP" set (FCID,TCID)=0

	/*
	 Determine default accounts based on first one with a value
		TRN.ACN		Default Account Number
		SCAU.TSDR	Transaction Suspense (DR)
		SCAU.TSCR	Transaction Suspense (CR)
		CUVAR.GLTS	Transaction Suspense
	*/
	if FCID=0 do {  if ER quit
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETCDR")
		set FCID=$$GLACN^TRNUTL(.trn,%UserID)
		// Invalid bank G/L account number
		if ER set RSPCD=$$RSPCD(1268,.RM)
		}
	if TCID=0 do {  if ER quit
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETCCR")
		set TCID=$$GLACN^TRNUTL(.trn,%UserID)
		// Invalid bank G/L account number
		if ER set RSPCD=$$RSPCD(1268,.RM)
		}

	// Suspense transactions will be debits
	if TRTYP["SUSP" set PCID=$S((TRTYP'="SUSPCR"):FCID,1:TCID)

	/*
	 Finish reversal transactions in PROC
	 NOTE: TCMT & TSO must be built for partial reversals
	*/
	if 'PARTIAL,REV quit

	// Parse Regulation E information
	do REGE(REGE,REGETYPE,.STREET,.CTY,.STA,.CNTRY)

	/*
	 Build TCMT field
	 Merchant name is only included in financial messages (non-POS)
	 because for POS messages the merchant name is included in the
	 street subfield of the terminal location.
	*/
	if 'POS set TCMT=MERCHNM
	if STREET'="" set TCMT=TCMT_$S(TCMT="":"",1:" ")_STREET
	if CTY'="" set TCMT=TCMT_$S(TCMT="":"",1:" ")_CTY
	if STA'="" set TCMT=TCMT_$S(TCMT="":"",1:", ")_STA
	if CNTRY'="" set TCMT=TCMT_$S(TCMT="":"",1:", ")_CNTRY

	// Build TSO field
	set UTSO("ATMM")=ATMM				// ATM message sequence
	if STREET'="" set UTSO("AD1")=STREET		// Terminal street address
	if CTY'="" set UTSO("CITY")=CTY			// Terminal city
	if STA'="" set UTSO("STPRV")=STA		// Terminal state
	if CNTRY'="" set UTSO("CNTRY")=CNTRY		// Terminal country

	// SBN specific logic  43027
	if INTRFACE="ISOSBN" do { quit
		set UTSO("SBSDT")=SETDT
		do IN^UTSO(.UTSO,.TSO)
		}

	// ATM specific fields
	if ATMID'="" set UTSO("ATM")=ATMID		// Terminal ID
	set UTSO("ATMC")=CRDNUM				// Card number
	if ATMD'="" set UTSO("ATMD")=$$JD^ATMUTL(ATMD)	// ATM transaction date
	if AUTCODE'="" set UTSO("AUTCODE")=AUTCODE	// Authorization code
	set UTSO("TRNTYPE")=$S(POS:"POS",1:"ATM")	// Transaction type

	do IN^UTSO(.UTSO,.TSO)

	quit

DEFAULT(CRDNUM,DEFAULT)
	/*
	 Determine Account Type Codes based on value of DEFAULT

	 If the default value is '00', use the primary account
	 linked to the card to determine the account type codes.

	 To determine the primary account number, this function will 
	 start with the first Card Type and Card Group for the type 
	 found in CRDGRP and then collate forward through all types
	 and groups until an account is found.

	 ARGUMENTS:
		CRDNUM	- Debit card number
		DEFAULT	- Default Account Type Code
	 OUTPUT:
		FRTYP	- From Account Type Code
		TOTYP	- To Account Type Code
		FCID	- From Account Number
		TCID	- To Account Number
	*/
	
	type public Boolean ER
	type public String FCID,FRTYP,RSPCD,TCID,TCODE,TOTYP,TRTYP,TYP
	type public Number CID

	/*
	 For now treat all transactions as credits or debits.  If
	 TRTYP="CREDIT" the PROFILE account is the To account, otherwise 
	 the PROFILE account is the From account.
	*/
	set TRTYP=$S(TCODE.extract()=2:"CREDIT",1:"DEBIT")

	// Use default account type
	if DEFAULT'="00" do {  quit
		if TRTYP'="CREDIT" set FRTYP=DEFAULT
		else  set TOTYP=DEFAULT
		}

	/*
	 Use primary account on card, set FRTYP and FCID, or TOTYP and 
	 TCID accordingly.
	*/

	// Primary account
	set CID=$$PRIMCID(CRDNUM,1,.TYP)

	// Try first account linked to card
	if CID=0 set CID=$$PRIMCID(CRDNUM,0,.TYP)

	// Invalid card or account
	if CID=0 set RSPCD=$$INVCRD(CRDNUM,"UNKNOWN") quit:ER

	if TRTYP="CREDIT" do {  quit
		set TOTYP=TYP
		set TCID=CID
		}

	set FRTYP=TYP
	set FCID=CID

	quit


PRIMCID(CRD,PRIM,TYP)
	/*
	 Primary Account Number

	 ARGUMENTS:
		CRD	- Debit card number
		PRIM	- Primary Account Indicator
		TYP	- Account Code
	 RETURNS:
		CID	- Primary Account Number
	*/

	type public String GRP
	type public Number CID

	type ResultSet rs

	set GRP=""
	set rs=Db.select("GRP,CID","CRDGRP","CRDNUM=:CRD AND PRIMCRD=:PRIM")
	if 'rs.isEmpty(),rs.next() set GRP=rs.getCol(1)
	// Invalid Account ~p1
	else  quit 0

	set TYP=$S(GRP="SAV":10,GRP="DDA":20,GRP="RC":30,GRP="COM":90,GRP="MTG":91,GRP="LN":92,1:"")
	set CID=rs.getCol(2)

	quit CID


REGE(REGE,OPTION,STREET,CITY,STATE,CNTRY)
	/*
	 Parse Regulation E (Bit 43) Information

	 ARGUMENTS:
		REGE	- Card Acceptor Location
		OPTION	- BIT 43 parsing method
		STREET	- Terminal location
		CITY	- City
		STATE	- State
		CNTRY	- Country
	*/

	if OPTION=1 do {  quit
		set STREET=$$RTB^%ZFUNC(REGE.extract(1,25))  // Street Address
		set CITY=$$RTB^%ZFUNC(REGE.extract(26,38))	// City
		set STATE=$$RTB^%ZFUNC(REGE.extract(39,40))	// State or Country
		set CNTRY=""
		}

	if OPTION=2 do {  quit
		set STREET=$$RTB^%ZFUNC(REGE.extract(1,23))  // Street Address
		set CITY=$$RTB^%ZFUNC(REGE.extract(24,36))	// City
		set STATE=$$RTB^%ZFUNC(REGE.extract(37,38))	// State
		set CNTRY=$$RTB^%ZFUNC(REGE.extract(39,40))	// Country
		}

	if OPTION=4 do {  quit
		set STREET=$$RTB^%ZFUNC(REGE.extract(1,22))	// Street Address
		set CITY=$$RTB^%ZFUNC(REGE.extract(23,35))	// City
		set STATE=$$RTB^%ZFUNC(REGE.extract(36,38))	// State
		set CNTRY=$$RTB^%ZFUNC(REGE.extract(39,40))	// Country
	}
	
	// Option 3, prior default before option 4 was created
	set STREET=$$RTB^%ZFUNC(REGE.extract(1,23))  // Street Address
	set CITY=$$RTB^%ZFUNC(REGE.extract(24,37))	// City
	set STATE=$$RTB^%ZFUNC(REGE.extract(38,40))	// State or Country
	set CNTRY=""

	quit


XN(AMT)
	/*
	 Fee Amounts

	 Arguments:
		AMT	- Amount, format X + n 8
			  Where X:
			   C = Credit Amount (+)
			   D or 0 = Debit Amount (-)
	 Returns:
		$$	- Amount
	*/

	if AMT.extract(1)="C" quit +AMT.extract(2,9)
	quit -AMT.extract(2,9)


PROC
	/*
	 Process message
	*/

	type public Boolean ER
	type public Number BCAL,BRCD,CRT,PCID,PRE,TCODE
	type public String ATMM,BIT,FINPRE,INTRFACE,PSTDYS,REPEAT,RM,RSPCD,TRTYP,VALID
	type public String CRCD,EFD,ETCDR,FCID,POSADJ,REV,SPR,STF,TAMT,TCMT,TRACE,TSO
	type public String AUTCODE,ETCCR,RT,TCID
	type public Date TPD

	if ER quit				// Error already occurred
	if 'VALID quit				// Invalid message type
	set CRT=0				// Mirror batch handling of overrides

	// 46356 - Modified test on 0100 message to use PRE instead
	#IF $$VALID^%ZRTNS("ZISOSBN")	
	 if INTRFACE="ISOSBN",PRE do EXTFLD^ZISOSBN(.BIT)
	#ELSE
	 if INTRFACE="ISOSBN",PRE do EXTFLD^ISOSBN(.BIT)
	#ENDIF

	// Statement request
	#IF $$VALID^%ZRTNS("ZISO8583")
	 if TRTYP="STMT" do STMT^ZISO8583 quit
	#ELSE
	 if TRTYP="STMT" do STMT quit
	#ENDIF

	// ATM Balance inquiry
	if TRTYP="INQUIRY" do { quit:ER
		// Invalid account number
		if PCID=0 set RSPCD=$$RSPCD(7774,.RM) quit
		// Invalid Account ~p1
		if 'Db.isDefined("ACN","PCID") set RSPCD=$$RSPCD(1259,.RM,PCID) quit
		}

	// Network Management Message
	#IF $$VALID^%ZRTNS("ZISO8583") 
	if NETWORK do NETWORK^ZISO8583(BIT(70).get()) quit
	#ENDIF
	
	// Reconciliation Message
	#IF $$VALID^%ZRTNS("ZISO8583")
	if RECON do RECON^ZISO8583 quit
	#ENDIF
	
	// Not financial
	if (TRTYP'="DEBIT"),(TRTYP'="CREDIT"),(TRTYP'["SUSP") quit

	// Check the account's history for a duplicate message
	if (REPEAT!STF),$$STFCHK^ATMUTL(PCID,SPR,TRACE,PRE,REV,FINPRE,ATMM,PSTDYS) quit

	type RecordTTX ttx()

	// Determine teller post date
	set TPD=$$TLRPDT^ATMUTL(BCAL,BRCD,.EFD)
	if ER set RSPCD=$$RSPCD("05") quit
	set ER=0
	set RM=""

	// Handle reversal separately
	if REV do ATMREV quit

	// Point of sale adjustments
	if POSADJ do POSADJ quit

	// Build transaction and offset transaction
	do TTX^ATMUTL(.ttx(),FCID,ETCDR,TAMT,EFD,TSO,TCMT,SPR,CRCD)
	do TTX^ATMUTL(.ttx(),TCID,ETCCR,TAMT,EFD,TSO,TCMT,SPR,CRCD)

	// Update check hold transaction if financial deposit
	if TCODE=21!(TCODE=24) do CKTRN^ATMUTL(.ttx(),TSO,RT)
	if ER quit

	// Process the transactions
	do POST(.ttx(),PCID,CRCD,TCMT,SPR,AUTCODE)
	set RSPCD=$$RSPCD(RSPCD,.RM)

	quit


ATMREV
	/*
	 Reversal transactions
	 Reverse the original transaction. If the original amount was
	 incorrect, then process the transaction with the correct amount
	 after the original is reversed.
	 INPUTS:
		AMT2	- Correction amount
		AUTCODE	- Authorization code
		BCAL	- Business day calendar
		CRCD	- Transaction currency code
		DELDUP	- Delete ATMDUP flag
		PARTIAL - Partial reversal flag
		PCID    - PROFILE account number
		PHC     - Permanent hold code
		PHDAYS  - Permanent hold days
		PRE     - Preauthorization flag
		SPR     - Spray value
		TAMT    - Transaction amount (converted)
		TCMT    - Transaction comment
		TSO	- Transaction source of funds
	*/
	
	type public Boolean ER
	type public Number AMT2,BRCD,PCID,PARTIAL,TAMT
	type public String ATMM,AUTCODE,CRCD,PSTDYS,PRE,RM,RSPCD,SPR,TCMT,TRTYP

	type RecordTTX ttx()

	/*
	 Build reversal transactions
	 Pre-auths do not build reversal transactions because a pre-auth is
	 reversed by removing the permanent hold that placed during the processing
	 of the original pre-auth message.
	*/
	if 'PRE do REV^ATMUTL(.ttx(),PCID,AMT2,SPR,AUTCODE,ATMM,BRCD,PSTDYS,PARTIAL)
	if ER set RSPCD=$$RSPCD(RSPCD,.RM) quit

	// Process the transactions
	do POST(.ttx(),PCID,CRCD,TCMT,SPR,AUTCODE,PARTIAL)
	set RSPCD=$$RSPCD(RSPCD,.RM)
	if 'ER set RSPCD="00"

	quit


POSADJ
	/*
	 POS Adjustments

	 INPUTS:
		ATMM	 - Unique sequence number
		AUTCODE	 - Authorization code
		BCAL	 - Business day calendar
		BRCD	 - Branch code
		CODE	 - External interface transaction code key
		CRCD	 - Currency code
		EXTCODE	 - External Code (PRCD_TRMNL)
		FCID	 - From account number
		FINPRE	 - POS preauthorized debit flag
		PCID	 - PROFILE account number
		PHC	 - Permanent hold code
		PHDAYS	 - Permanent hold days
		PRE	 - Preauthorization flag
		PSTDYS	 - Number of days to search into account history
		REV	 - Reversal flag
		SAFUCLS	 - PROFILE store and forward userclass
		SPR	 - Spray value
		STF	 - ATM switch store and forward flag
		AMT2	 - Correction amount
		TAMT	 - Transaction amount
		TCODE	 - Process code transaction type
		TCID	 - To account number
		TCMT	 - Transaction comment
		TPD	 - Teller posting date
		TRACE	 - Trace value
		TRTYP	 - Transaction type
		TSO	 - Transaction source of funds
	*/

	type public Boolean ER
	type public Cache %CACHE()
	type public String AMT,AMT2,EXTCODE,INTRFACE,RM,RSPCD,TAMT,TCODE,STF
	type public String AUTCODE,CRCD,EFD,ETC,ETCCR,ETCDR,PCID,TCMT,TSO,TRCD,SPR
	type public Number FCID,TCID

	type RecordTTX ttx()

	// The original amount is required and must not equal the current amount
	// Invalid transaction amount
	if (AMT2="")!(AMT2=TAMT) set RSPCD=$$RSPCD(6070,.RM) quit
	if AMT2=0 set AMT2=TAMT,TAMT=0

	/*
	 Debit adjustments - if the original amount is less than the actual
	 amount, then an additional debit is required. However, if the
	 original amount is more than the actual amount, then an additional
	 credit is required. If a credit is required, then the credit
	 transaction codes are used.
	*/

	if TCODE="02" do {
		// Debit account further
		if AMT2>TAMT set AMT=AMT2-TAMT quit

		// Credit account, switch account around and use credit codes
		else  do {  if 1
			set AMT=TAMT-AMT2
			set TCID=FCID
			set FCID=0
			set EXTCODE="22"_EXTCODE.extract(5,6)_EXTCODE.extract(3,4)_EXTCODE.extract(7,EXTCODE.length())
			}
		}

	/*
	 Credit adjustments - if the original amount is less than the actual
	 amount, then an additional credit is required. However, if the
	 original amount is more than the actual amount, then an additional
	 debit is required. If a debit is required, then the debit
	 transaction code are used.
	*/

	if TCODE="22" do {
		// Credit account further
		if AMT2>TAMT set AMT=AMT2-TAMT quit

		// Debit account, switch account around and use debit codes
		else  do {
			set AMT=TAMT-AMT2
			set FCID=TCID
			set TCID=0
			set EXTCODE="02"_EXTCODE.extract(5,6)_EXTCODE.extract(3,4)_EXTCODE.extract(7,EXTCODE.length())
			}
		}

	// Define ETCDR and ETCCR
	set TRCD=$$GETTRN^ATMUTL(INTRFACE,EXTCODE,STF)
	if ER set RSPCD=$$RSPCD(RSPCD,.RM) quit

	// Debit and Credit transaction codes
	set ETCDR=TRCD.piece($C(9),2)
	set ETCCR=TRCD.piece($C(9),3)

	// Determine G/L accounts
	if FCID=0 do {  if ER quit
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETCDR")
		set FCID=$$GLACN^TRNUTL(.trn,%UserID)
		// Invalid bank G/L account number
		if ER set RSPCD=$$RSPCD(1268,.RM)
		}
	if TCID=0 do {  if ER quit
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETCDR")
		set TCID=$$GLACN^TRNUTL(.trn,%UserID)
		// Invalid bank G/L account number
		if ER set RSPCD=$$RSPCD(1268,.RM)
		}

	// Build transaction and offset transaction
	do TTX^ATMUTL(.ttx,FCID,ETCDR,AMT,EFD,TSO,TCMT,SPR,CRCD)
	do TTX^ATMUTL(.ttx,TCID,ETCCR,AMT,EFD,TSO,TCMT,SPR,CRCD)

	// Process the transactions
	do POST(.ttx,PCID,CRCD,TCMT,SPR,AUTCODE)
	set RSPCD=$$RSPCD(RSPCD,.RM)

	quit


POST(RecordTTX ttx(),CID,CRCD,TCMT,SPR,AUTCODE,PARTIAL)
	/*
	 Messages coming in as ADVICES have already been processed by the
	 ATM switch and must be processed as store and forward transactions
	 on PROFILE. This means that store and forward transactions MUST be
	 successfully processed on PROFILE since the transaction has already
	 been approved by the ATM switch. The supervisory override array,
	 TSPV, is set up so the PROFILE ATM teller has authorization over
	 all generated transactions. Also, bit 10 of ITC for each transaction
	 is turned on indicating that the transaction is off-line.
	 ARGUMENTS:
		CID	- PROFILE account number
		CRCD	- Transaction currency code
		TCMT	- Transaction comment
		SPR	- Spray value
		AUTCODE	- Authorization code
		PARTIAL	- Partial reversal transaction
	 INPUTS:
		AMT2	- Correction amount
		ATMM	- Unique message sequence
		BCAL	- Business day calendar
		BRCD	- Branch code
		CUTOFF	- Hold cutoff time
		FINPRE	- POS preauthorized debit flag
		PAUTH	- Partial authorization flag
		PHC	- Permanent hold code
		PHDAYS	- Permanent hold days
		PRE	- Preauthorization flag
		PSTDYS	- Number of days to search into an account's history
		REV	- Reversal flag
		STF	- ATM switch store and forward flag
		TPD	- Teller posting date
		TRTYP	- Transaction type
		TSO	- Transaction source of funds
	*/

	type public Boolean ER
	type public Date TPD
	type public Number BRCD,FINPRE,STF,PHC,PRE,PAMT,REV
	type public String BIT,INTRFACE,MID,SAFUCLS,TRTYP,TSPV,TSO,%Userclass

	if STF set %UserClass=SAFUCLS
	set TSPV("*")=%UserID_"|"_%UserClass

	// POST pre-processor
	#IF $$VALID^%ZRTNS("ZISO8583") do POSTPRE^ZISO8583 quit:ER
	// Pre-authorizations
	if PRE do {
		// Remove a hold
		if REV do REVPRE^ATMUTL(CID,CRCD,TCMT,SPR,AUTCODE,TSO,TPD,BRCD,AMT2,ATMM,PARTIAL,TRTYP)  if 1

		// Place a hold
		else  do ATMPRE^ATMUTL(.ttx,CID,CRCD,TCMT,SPR,AUTCODE,TSO,TPD,BRCD,STF,PAUTH,.PAMT)
	}

	// Financial transactions
	else  do {
	// Remove hold if one exists
	if FINPRE,'REV do PREDEL^ATMUTL(CID,SPR,PHC,STF,TRTYP) quit:ER

	do POST^ATMUTL(.ttx,CID,TPD,BRCD,.TSPV,STF)

	// 43027 - Build extended fields for SBN financial messages 
	// 46356 - Modified to pass ttx instead of ts
	if INTRFACE="ISOSBN",'ER,MID="0210" do EXTFIN^ISOSBN(.BIT,.ttx)
	}

	// POST post-processor
	#IF $$VALID^%ZRTNS("ZISO8583") do POSTPST^ZISO8583 quit:ER

	quit 


OUTGOING(OM,TBL,BIT)
	/*
	 Format outgoing message to be sent back to the switch network
	 ARGUMENTS:
		BIT	- Parsed message array
		TBL	- Data element descriptions (see BITMAP section)
	 INPUT:
		AUTCODE	- Authorization code
		CRCD	- Currency of original transaction amount
		MID	- Outgoing message id
		NETWORK - Network message flag
		PCID	- Account linked to CRDNUM
		RSPCD 	- Response code
		STF	- ATM switch store and forward flag
	 OUTPUT:
		OM	- Outgoing message
	*/

	type public Boolean ER
	type public Number NETWORK,PCID,STF
	type public String ATMM,AUTCODE,INTRFACE,MID,RSPCD,TRTYP

	if 'STF,ER,(RSPCD="00") set RSPCD=$$RSPCD("05")

	// Advice messages must return a success
	if STF,RSPCD'="00" do {
		S RM=$$^MSG(4977)_" "_RSPCD_" "_$G(RM)
		// Log a dayend exception error
		do LOG^UTLEXC("ISO8583","*","",PCID,ATMM,RM)
		set RSPCD="00"
		}

	// Define account balance information
	#IF $$VALID^%ZRTNS("ZISO8583")
	 if 'NETWORK,PCID'=0,TRTYP'["SUSP",'ER set BIT(54)=$$GETBAL^ZISO8583
	#ELSE
	 if 'NETWORK,PCID'=0,TRTYP'["SUSP",'ER set BIT(54)=$$GETBAL
	#ENDIF

	// Error occurred obtaining balances
	if $D(BIT(54)),BIT(54)="" kill BIT(54)

	// Response code
	set BIT(39)=RSPCD

	// Authorization id
	if 'NETWORK,RSPCD="00" set BIT(38)=$$RJ^%ZTEXT(AUTCODE,TBL(38).piece("|",2),0,1)

	// Don't return Extended Fields for Shared Branch on Error
	if INTRFACE="ISOSBN",(ER!(RSPCD'="00")) do {
		type Number i
		for i=105:1:108 kill BIT(i)
	}
	// BLDOM pre-processor
	#IF $$VALID^%ZRTNS("ZISO8583") do BLDPRE^ZISO8583

	// Build outgoing message
	set OM=$$BLDOM(MID,.BIT,.TBL)

	quit


BITMAP(msg,TBL,BIT)
	/*
	 Translates data stored in 'msg' into individual fields BIT(n),
	 based on the bitmap which is present in the message. The bitmap
	 is a set of ASCII characters representing binary data
	 (e.g., 0="0000", 1="0001", ..., F="1111")
	 ARGUMENTS:
		msg	Message to parse
		TBL	Field definition array where
			TBL(field)=varlen|fixlen|type|description
	 OUTPUT:
		MID	Message id
		BIT	Parsed array of 'msg'
	*/

	type public Number BIT1,BM,BMLEN,BVAL,FLD,I,MAP,MID,STR

	// Clean out BIT array
	kill BIT

	set STR=1
	set MID=$$GETBIT(msg,"MID",.STR,.TBL)
	set BM=$$GETBIT(msg,"PBM",.STR,.TBL)

	// Convert Hex to ASCII
	set BIT1=$$HEXDEC^%ZHEX(BM.extract(1))

	if BIT1>7 set BM=BM_$$GETBIT(msg,1,STR,.TBL),BMLEN=32
	else  set BMLEN=16

	set FLD=1
	for BVAL=1:1:BMLEN set MAP=$$HEXDEC^%ZHEX(BM.extract(BVAL)) do {
		if 'MAP set FLD=FLD+4 quit	// "0000", so skip all
		for I=8,4,2,1 do {
			if MAP\I#2 set BIT(FLD)=$$GETBIT(msg,FLD,.STR,.TBL)
			set FLD=FLD+1		// Increase field counter
			}
		}
	quit MID


GETBIT(msg,FLD,STR,TBL)
	/*
	 Get bit value and convert to ASCII form.
	 ARGUMENTS:
		msg	- Incoming message
		FLD	- BIT field number
		STR	- Location in message
		TBL	- Field definition array
			  TBL(X)="lentyp|lenx|datatyp|des"
			  lentyp	= type of length (variable,fixed,...)
			  lenx		= length value
					  len 	= data length (if lentyp=V, len=byte length
			  			  of data length, i.e., LLVAR=2, LLLVAR=3)
					  x 	= variable length sub-field type
						  null	- Length of formatted data
						  a	- Length of data in message
			  datatyp	= data type
			  des		= description of data

			  Valid values:
				lentyp	F	Fixed Length
					V	Variable Length
	
				datatyp	A	ASCII
					N	Numeric
					T	Text
					B	Bitmap

	 INPUTS:
		VLB	- Variable length binary indicator
			  . 0	not binary
			  . 1	binary length of 1 only
			  . 2	binary length of 1 or 2
		UPK 	- Unsigned packed format option
		EBC 	- EBCDIC format option
	 OUTPUT:
		DTA	- Parsed piece of data
	*/

	type public String DTYP,EBC,LTYP,UPK,VLB,VLTYP
	type public Number ACTLEN,DTA,LEN,ORG

	set LTYP=TBL(FLD).piece("|",1)
	set LEN=TBL(FLD).piece("|",2)
	set DTYP=TBL(FLD).piece("|",3)

	/*
	 Variable length sub-field type
		null	- Length of formatted data
		a	- Length of data in message
	*/
	set VLTYP=$S(LTYP="V":LEN.extract(2),1:"")
	set LEN=+LEN

	// Determine actual length of data
	set ACTLEN=LEN

	// Variable length, not binary
	if LTYP="V",'VLB set ACTLEN=msg.extract(STR,STR+LEN-1),STR=STR+LEN

	// Variable length binary
	if LTYP="V",VLB do {
		type public Number LEN1
		set LEN1=$A(msg.extract(STR))

		// Variable length = 2 or max length = 1
		if LEN=2!(VLB=1) set ACTLEN=LEN1

		// Variable length = 3
		else  set ACTLEN=LEN1*256+($A(msg.extract(STR+1)))

		if VLB=1 set STR=STR+1
		else  set STR=STR+LEN-1
		}

	// No special formatting
	if 'UPK,'EBC do { quit DTA
		set DTA=msg.extract(STR,STR+ACTLEN-1)
		set STR=STR+ACTLEN
		}

	// Determine packed length
	set ORG=ACTLEN
	if UPK,VLTYP="",(DTYP="N"!(DTYP="B")) set ACTLEN=(ACTLEN\2)+(ACTLEN#2)

	set DTA=msg.extract(STR,STR+ACTLEN-1)
	set STR=STR+ACTLEN

	// Unsigned packed bit option
	if UPK,(DTYP="N"!(DTYP="B")) do {
		set DTA=$$UPKNS(DTA)

		// Remove leading zero of odd-length packed bit
		if DTA.length()'=ORG,DTA.extract(1)=0 set DTA=DTA.extract(2,DTA.length())
		}

	// EBCDIC bit option
	if EBC,DTYP="T" set DTA=$$EBC2ASC^%ZFUNC(DTA)

	quit DTA


UPKNS(DTA)
	/*
	 Convert packed data to unpacked
	 ARGUMENT:
		DTA	- Packed data
	 OUTPUT:
		CNV	- Converted data (DTA)
	*/

	type public String BYTE,CNV
	type public Number I

	set CNV=""
	for I=1:1:DTA.length() do {
		set BYTE=DTA.extract(I)
		set BYTE=$A(BYTE)
		set BYTE=$$DECHEX^%ZHEX(BYTE)
		if BYTE="" set BYTE="0"
		if BYTE.length()=1 set BYTE="0"_BYTE
		set CNV=CNV_BYTE
		}
	quit CNV


BLDOM(MID,BIT,TBL)
	/*
	 Build the outgoing message
	 Format the data fields in the BIT array. Convert back to Packed
	 or EBCDIC and add lengths to variable length fields.
	 ARGUMENTS:
		MID	- Outgoing message id
		BIT	- Parsed data array
		TBL	- Field definition array
	 OUTPUT:
		Outgoing message
	*/

	type public String FLD,OM,PBM,SBM

	set FLD=""
	for  set FLD=BIT(FLD).order() quit:FLD=""  set BIT(FLD)=$$FMTBIT(FLD,BIT(FLD),.TBL)

	// Create out-going data (OM) and bitmaps (PBM and SBM) using BIT array
	do OBM(.PBM,.SBM,.OM,.BIT)

	// Format MID and bitmaps
	set MID=$$FMTBIT("MID",MID,.TBL)
	set PBM=$$FMTBIT("PBM",PBM,.TBL)
	if SBM'="" set SBM=$$FMTBIT(1,SBM,.TBL)

	quit MID_PBM_SBM_OM

FMTBIT(FLD,BIT,TBL)
	/*
	 Convert data back to Packed or EBCDIC and add variable length
	 ARGUMENTS:
		FLD	- BIT array field number
		BIT	- Field value
		TBL	- Field definition array
	 INPUTS:
		VLB	- Variable length binary indicator
			  . 0	not binary
			  . 1	binary length of 1 only
			  . 2	binary length of 1 or 2
	 OUTPUT:
		BIT	- Formatted data for outgoing message
	*/

	type public String DTYP,LTYP,UPK,VLB,VLTYP
	type public Number ACTLEN,EBC,LEN

	set LTYP=TBL(FLD).piece("|",1)
	set LEN=TBL(FLD).piece("|",2)
	set DTYP=TBL(FLD).piece("|",3)

	/*
	 Variable length sub-field type
		null	- Length of formatted data
		a	- Length of data in message
	*/
	set VLTYP=LEN.extract(2)
	set LEN=+LEN

	set ACTLEN=BIT.length()

	// Unsigned packed bit option
	if UPK,(DTYP="N"!(DTYP="B")) do {
		if ACTLEN#2 set BIT=0_BIT
		set BIT=$$PKNS(BIT)
		if VLTYP="a" set ACTLEN=BIT.length()
		}

	// EBCDIC bit option
	if EBC,DTYP="T" set BIT=$$ASC2EBC^%ZFUNC(BIT)

	if LTYP'="V" quit BIT

	// Variable length, not binary
	if 'VLB quit "000000".extract(1,LEN-ACTLEN.length())_ACTLEN_BIT

	// Variable length binary 1 byte
	if LEN=2!(VLB=1) quit $C(ACTLEN)_BIT

	// Variable length binary 2 bytes
	quit $C(ACTLEN\256)_$C(ACTLEN#256)_BIT


OBM(PBM,SBM,OM,BIT)
	/*
	 Build the new out-going bitmaps and data based on the BIT array
	 ARGUMENT:
		BIT	- Parsed data array
	 OUTPUTS:
		PBM	- Primary bitmap
		SBM	- Secondary bitmap
		OM	- Data for outgoing message 
	*/
	type public Number EXFLG,I,VAL
	type public String BMPOS,OBM

	set EXFLG=0
	set (OM,PBM,SBM)=""

	set I=1
	for  set I=BIT(I).order() quit:I=""  do {
		set OM=OM_BIT(I)

		// Compute hexidecimal bit map value
		set BMPOS=((I-1)\4)+1
		set OBM(BMPOS)=OBM(BMPOS).get()+$S('(I#4):1,1:(2**(4-(I#4))))
		}

	if OBM("").order(-1)>16 set OBM(1)=OBM(1).get()+8,EXFLG=1

	// Build primary and secondary bitmap from OBM
	for I=1:1:32 do {
		if '$D(OBM(I)) set VAL=0
		else  set VAL=OBM(I) if VAL>9 set VAL=$C(VAL+55)  // A-F
		if I'>16 set PBM=PBM_VAL
		else  if EXFLG set SBM=SBM_VAL
		}
	quit


PKNS(DTA)
	/*
	 Conversion to binary packed
	*/
	type public String CNV,Y
	type public Number I

	set CNV=""
	for I=1:2:DTA.length() do {
		set Y=DTA.extract(I,I+1)
		set Y=$$HEXDEC^%ZHEX(Y)
		set Y=$C(Y)
		set CNV=CNV_Y
		}
	quit CNV


CRCD(CURR)
	/*
	 Translate ISO code to PROFILE currency code
	 ARGUMENT:
		CURR	- Currency number
	 OUTPUT:
		CRCD	- PROFILE currency code
	*/
	
	type public String %CRCD,CRCD 

	if CURR.isNull() quit %CRCD.get()

	type ResultSet rs=Db.select("CRCD","CRCD","CRCDNO=:CURR")
	if rs.next() set CRCD = rs.getCol("CRCD")

	if 'CRCD.isNull() quit CRCD

	// if CRCD="" try removing leading zeros
	set CURR=+CURR

	type ResultSet rs1=Db.select("CRCD","CRCD","CRCDNO=:CURR")
	if rs1.next() set CRCD = rs1.getCol("CRCD")

	quit CRCD


EXP(CRCD)
	/*
	 Get number of decimal places
	 ARGUMENT:
		CRCD	- PROFILE currency code
	 Returns
		Number of decimal places
	*/

	type public String %CO,%CRCD
	type public Number EXP

	if CRCD="" set CRCD=%CRCD.get()

	type RecordCRCD crcd=Db.getRecord("CRCD","CO=:%CO,CRCD=:CRCD")
	set EXP=crcd.curdec

	quit 10**EXP


GETCID(CRDNUM,GRP)
	/*
	 Find first account linked to the card

	 This function will start with the first Card Type found in
	 CRDGRP and then collate forward through all types until an
	 account is found.

	 ARGUMENTS:
		CRDNUM	- Debit card number
		GRP	- Account group
	 RETURNS:
		CID	- First GRP PROFILE account linked to CRDNUM
	*/

	type public String RSPCD
	type public Number CID

	type ResultSet rs

	set CID=0

	set rs=Db.select("CID","CRDGRP","CRDNUM=:CRDNUM AND GRP=:GRP")
	if 'rs.isEmpty(),rs.next() set CID=rs.getCol(1)

	// Invalid Card or Account
	else  set RSPCD=$$INVCRD(CRDNUM,GRP)

	quit +CID


INVCRD(CRDNUM,GRP)
	/*
	 Return invalid card or account response code
	*/

	type public String RM,RSPCD

	type ResultSet rs
	set rs=Db.select("CRDNUM","CRDGRP","CRDNUM=:CRDNUM")
	if 'rs.isEmpty(),rs.next() do {
		// No checking account
		if GRP="DDA" set RSPCD=$$RSPCD(5035,.RM) quit
		// No savings account
		if GRP="SAV" set RSPCD=$$RSPCD(5036,.RM) quit
		// Invalid account number (does not exist)
		set RSPCD=$$RSPCD(7822,.RM)
	}
	// Invalid card number ~p1
	else  set RSPCD=$$RSPCD(3784,.RM,CRDNUM)

	quit RSPCD


RSPCD(CODE,RM,ARG1,ARG2)
	/*
	 Response Code
	*/

	type public Boolean ER
	type public String INTRFACE,RSPCD

	if CODE="00" quit "00"

	// Not partial pre-auth
	if CODE'="10" set ER=1

	if CODE.length()>2 set RM=$$^MSG(CODE,ARG1.get(),ARG2.get())

	type RecordUTBLEXTRSP1 utblextrsp1=Db.getRecord("UTBLEXTRSP1","INTRFACE=:INTRFACE,KEY=:CODE",1)
	if utblextrsp1.getMode()=1 set RSPCD=utblextrsp1.respcde1

	// Don't respond with default error response for partial authorization
	if RSPCD="",CODE=10 quit 10

	if RSPCD="",CODE'="05" do {
		set CODE="05"
		
		type RecordUTBLEXTRSP1 utblextrsp1=Db.getRecord("UTBLEXTRSP1","INTRFACE=:INTRFACE,KEY=:CODE",1)
		if utblextrsp1.getMode()=1 set RSPCD=utblextrsp1.respcde1
		}

	if RSPCD="" quit "05"

	quit RSPCD


GENNET(CODE)
	/*
	 ISO 8583 Network Message Generator
	 Codes: "001" - Sign on request
		"002" - Sign off request
		"301" - Echo test
	*/

	type public String DEFAULT,DELDUP,INTRFACE,MID,OM,RT,SAFUCLS,TBL,TIME,VLB
	type public Date DATE
	type public Number ASCII,BCAL,BIT,BRCD,IGNORE,NETID,PHDAYS,PHC,PSTDYS

	if '$D(INTRFACE) new INTRFACE set INTRFACE="ISOATM"

	do INIT(INTRFACE)

	set MID="0800"

	if CODE.get()="" set CODE="001"
	set DATE=$$DAT^%ZM(%CurrentDate,"MMDD")
	set TIME=$$TIM^%ZM(%CurrentTime,"2460SS")
	set BIT(7)=DATE_TIME
	set BIT(11)=$$RJ^%ZTEXT($$GET^NXTSEQ("TRACE",6),6,0)
	set BIT(12)=TIME
	set BIT(13)=DATE
	if NETID'="" set BIT(32)=NETID
	set BIT(70)=$$RJ^%ZTEXT(CODE,3,0)

	// Vendor specific
	#IF $$VALID^%ZRTNS("ZISO8583") do BLDMSG^ZISO8583(MID,.BIT)

	// Build the message
	set OM=$$BLDOM(MID,.BIT,.TBL)
 
	// Attach the message header
	#IF $$VALID^%ZRTNS("ZISO8583") do FAPOUT^ZISO8583

	quit OM


NXTSEQ()
	/*
	 Unique message sequence
	 OUTPUT:
		Unique message sequence
	*/
	type public Number VAL
	type public String JOB,TIME

	type RecordNXTSEQ nxt

	set JOB=%ProcessID
	if Db.isDefined("NXTSEQ","JOB") set nxt=Db.getRecord("NXTSEQ","JOB")
	else  set nxt=Class.new("RecordNXTSEQ")
	set VAL=nxt.unq+1
	set nxt.id=JOB
	set nxt.unq=VAL
	do nxt.save()

	set TIME=%CurrentTime
	quit %CurrentDate_"00000".extract(1,5-TIME.length())_TIME_"000000".extract(1,6-JOB.length())_JOB_"00000".extract(1,5-VAL.length())_VAL

	/*
	 This section contains customizable sections that may be used 
	 in conjunction with routines ISO8583, which handles the actual
	 processing of the messages, and ISOTST, which is a testing utility.

		BLDMSG		Vendor specific message bits
		INITTBL		Initialize TBL array
		INIT2		Modify or add additional code prior to
				processing the transaction
		FAPIN		Remove optional headers
		FAPOUT		Replace optional headers
		GETBAL		Balance Information
		HDR		Build Header Information
		STMT		Statement Request
		RESPONSE	Response message processing
		POSTPRE		POST section pre-processor
		POSTPST		POST section post-processor
		BLDPRE		BLDOM section pre-processor
		VLDMSG		Validate incoming message
		NETWORK		Network Management Message Support 
		RECON		Reconciliation Message Support
	*/

	quit


BLDMSG(MID,BIT)
	/*
	 Vendor specific message bits

	 This section can be customized by copying ISO8583 to ZISO8583.

	 Define additional vendor specific message bits for the request 
	 message built by the ZISOTST testing utility and the Network
	 Management Message Generator in ZISOUTL.

	 ARGUMENTS:
		MID	- Message Type
			  . 0100 Pre-Authorization Request
			  . 0120 Pre-Authorization Advice
			  . 0200 Financial Transaction
			  . 0220 Financial Transaction Advice
			  . 0400 Pre-Authorization Request Adjustment
			  . 0420 Pre-Authorization Advice Adjustment
			  . 0800 Network Management Message
		BIT	- Message data array

	 For example:

	 if MID="0100"!(MID="0120") set BIT(60)="00"
	*/

	quit


INITTBL
	/*
	 This section can be customized by copying ISO8583 to ZISO8583.

	 Initialize TBL array
	 Format - TBL(X)="lentyp|lenx|datatyp|des"
		lentyp	= type of length (variable,fixed,...)
		lenx	= length value
			  len = data length (if lentyp=V, len=byte length
			  of data length, i.e., LLVAR=2, LLLVAR=3)
			  x = variable length sub-field type
				null	- Length of formatted data
				a	- Length of data in message
		datatyp	= data type
		des	= description of data
	 Valid values:
		lentyp	F	Fixed Length
			V	Variable Length

		datatyp	A	ASCII
			N	Numeric
			T	Text
			B	Bitmap

	 RETURNS:
		TBL	- Data element definitons
	*/
	type public String TBL()

	// Bit definitions
	set TBL("MID")="F|4|N|Message Type"
	set TBL("PBM")="F|16|B|Bit map, primary"

	set TBL(1)="F|16|B|Bit map, extended"
	set TBL(2)="V|2|N|Primary account number"
	set TBL(3)="F|6|N|Processing code"
	set TBL(4)="F|12|N|Amount, transaction"
	set TBL(5)="F|12|N|Amount, settlement"
	set TBL(6)="F|12|N|Amount, cardholder billing"
	set TBL(7)="F|10|N|Transmission date and time"
	set TBL(8)="F|8|N|Amount, cardholder billing fee"
	set TBL(9)="F|8|N|Conversion rate, settlement"
	set TBL(10)="F|8|N|Conversion rate, cardholder billing"
	set TBL(11)="F|6|N|System trace audit number"
	set TBL(12)="F|6|N|Time, local transaction"
	set TBL(13)="F|4|N|Date, local transaction"
	set TBL(14)="F|4|N|Date, expiration"
	set TBL(15)="F|4|N|Date, settlement"
	set TBL(16)="F|4|N|Date, conversion"
	set TBL(17)="F|4|N|Date capture"
	set TBL(18)="F|4|N|Merchant category code"
	set TBL(19)="F|3|N|Acquiring institution country code"
	set TBL(20)="F|3|N|PAN, country code"
	set TBL(21)="F|3|N|Forwarding country code"
	set TBL(22)="F|3|N|Point-of-service entry mode"
	set TBL(23)="F|3|N|Card sequence number"
	set TBL(24)="F|3|N|Network international identifier"
	set TBL(25)="F|2|N|Point-of-service condition code"
	set TBL(26)="F|2|N|PIN capture code"
	set TBL(27)="F|1|N|Authorization identification response length"
	set TBL(28)="F|9|T|Amount transaction fee"
	set TBL(29)="F|9|T|Amount settlement fee"
	set TBL(30)="F|9|T|Amount transation processing fee"
	set TBL(31)="F|9|T|Amount settlement processing fee"
	set TBL(32)="V|2|N|Acquirer insitition identification code"
	set TBL(33)="V|2|N|Forwarding institution identification code"
	set TBL(34)="V|2|N|Reserved"
	set TBL(35)="V|2|N|Track 2 data"
	set TBL(36)="V|3|N|Reserved"
	set TBL(37)="F|12|T|Retrieval reference number"
	set TBL(38)="F|6|T|Authorization identification response"
	set TBL(39)="F|2|T|Response code"
	set TBL(40)="F|3|T|Service restriction code"
	set TBL(41)="F|8|T|Card acceptor terminal identification"
	set TBL(42)="F|15|T|Card acceptor identification code"
	set TBL(43)="F|40|T|Card acceptor name and location"
	set TBL(44)="V|2|T|Additional response data"
	set TBL(45)="V|2|T|Track-1 data"
	set TBL(46)="V|3|T|Additional data ISO"
	set TBL(47)="V|3|T|Additional data national"
	set TBL(48)="V|3|T|Additional data, private"
	set TBL(49)="F|3|N|Currency code, transaction"
	set TBL(50)="F|3|T|Currency code, settlement"
	set TBL(51)="F|3|T|Currency code, customer billing"
	set TBL(52)="F|16|B|PIN (personal identification number) data"
	set TBL(53)="F|16|N|Security control information"
	set TBL(54)="V|3|T|Additional amounts"
	set TBL(55)="V|3|T|Reserved ISO"
	set TBL(56)="V|3|T|Reserved ISO"
	set TBL(57)="V|3|N|Reserved national"
	set TBL(58)="V|3|N|Reserved national"
	set TBL(59)="V|3|T|Reserved national"
	set TBL(60)="V|3|N|POS Entry Capability Code"
	set TBL(61)="V|3|T|Network specific information"
	set TBL(62)="V|3|T|Custom payment services fields"
	set TBL(63)="V|3|T|Reserved private"
	set TBL(64)="F|16|B|MAC"
	set TBL(65)="F|16|B|Bit map, extended"
	set TBL(66)="F|1|N|Reserved"
	set TBL(67)="F|2|N|Reserved"
	set TBL(68)="F|3|N|Reserved"
	set TBL(69)="F|3|N|Reserved"
	set TBL(70)="F|3|N|Network management information code"
	set TBL(71)="F|4|N|Reserved"
	set TBL(72)="F|4|N|Reserved"
	set TBL(73)="F|6|N|Reserved"
	set TBL(74)="F|10|N|Reserved"
	set TBL(75)="F|10|N|Reserved"
	set TBL(76)="F|10|N|Reserved"
	set TBL(77)="F|10|N|Reserved"
	set TBL(78)="F|10|N|Reserved"
	set TBL(79)="F|10|N|Reserved"
	set TBL(80)="F|10|N|Reserved"
	set TBL(81)="F|10|N|Reserved"
	set TBL(82)="F|12|N|Reserved"
	set TBL(83)="F|12|N|Reserved"
	set TBL(84)="F|12|N|Reserved"
	set TBL(85)="F|12|N|Reserved"
	set TBL(86)="F|16|N|Reserved"
	set TBL(87)="F|16|N|Reserved"
	set TBL(88)="F|16|N|Reserved"
	set TBL(89)="F|16|N|Reserved"
	set TBL(90)="F|42|N|Original data elements"
	set TBL(91)="F|1|T|Reserved"
	set TBL(92)="F|2|T|Reserved"
	set TBL(93)="F|5|T|Reserved"
	set TBL(94)="F|7|T|Reserved"
	set TBL(95)="F|42|T|Replacement amounts"
	set TBL(96)="F|16|B|Reserved"
	set TBL(97)="F|17|T|Reserved"
	set TBL(98)="F|25|T|Payee"
	set TBL(99)="V|2|N|Reserved"
	set TBL(100)="V|2|N|Receiving institution identification code"
	set TBL(101)="V|2|T|Reserved"
	set TBL(102)="V|2|T|Account identification 1"
	set TBL(103)="V|2|T|Account identification 2"
	set TBL(104)="V|3|T|Reserved"
	set TBL(105)="V|3|T|Reserved"
	set TBL(106)="V|3|T|Reserved"
	set TBL(107)="V|3|T|Reserved"
	set TBL(108)="V|3|T|Reserved"
	set TBL(109)="V|3|T|Reserved"
	set TBL(110)="V|3|T|Reserved"
	set TBL(111)="V|3|T|Reserved"
	set TBL(112)="V|3|T|Reserved"
	set TBL(113)="V|3|T|Reserved"
	set TBL(114)="V|3|T|Reserved"
	set TBL(115)="V|3|T|Reserved"
	set TBL(116)="V|3|T|Reserved"
	set TBL(117)="V|3|T|Reserved"
	set TBL(118)="V|3|T|Reserved"
	set TBL(119)="V|3|T|Reserved"
	set TBL(120)="V|3|T|Reserved"
	set TBL(121)="V|3|T|Reserved"
	set TBL(122)="V|3|T|Reserved"
	set TBL(123)="V|3|T|Private--Address verification"
	set TBL(124)="V|3|T|Key management information"
	set TBL(125)="V|3|T|Reserved"
	set TBL(126)="V|3|T|Reserved"
	set TBL(127)="V|3|T|Private--Non-monetary update information"
	set TBL(128)="F|16|B|MAC"

	quit


INIT2
	/*
	 This section can be customized by copying ISO8583 to ZISO8583.

	 The purpose of this section is to allow for custom code that may be
	 necessary to handle vendor specific variations of the ISO 8583
	 interface.  The following list represents a few of the more common 
	 variables that may need to be modified.

		TLO		Teller Location - used to uniquely identify 
				a message.
		SPR		Spray Number - used to uniquely identify 
				a message.
		CC		Cost Center
		FCID		From Account Number
		TCID		To Account Number
		PRCD		Process Code
		TRMNL		On-us/off-us indicator
				. null	not used
				. 0	on-us
				. 1	off-us
		REGE		Card Acceptor Location
		UTSO(id)	Teller Source - where id equals a custom TSO
				field. 
		MERCHNM		Merchant name (used in TCMT with REGE info)

	 For example:

	 new BIT48

	 // Reset TLO and SPR fields to FDR UK specifications
	 set %UserStation="ZISO8583"
	 set TRACE=""
	 set BIT48=$G(BIT(48))
	 set SPR=+$S($L(BIT48)=15:$E(BIT48,4,15),1:$E(BIT48,18,29))

	 // All transactions off-us
	 set TRMNL=1
	*/

	quit


FAPIN
	/*
	 This section can be customized by copying ISO8583 to ZISO8583.

	 Define the message header of the incoming message and remove it from
	 the incoming message

	 INPUTS:
		IM	- ISO 8583 Request Message

	 For example:

	 set MSGHDR=$E(IM,5,8)
	 set IM=$E(IM,1,4)_$E(IM,9,$L(IM))
	*/

	quit


FAPOUT
	/*
	 This section can be customized by copying ISO8583 to ZISO8583.

	 Define the message header for the outgoing message and attach it
	 to the outgoing message

	 INPUTS:
		OM	- ISO 8583 Response Message

	 For example:

	 set OM=$E(OM,1,4)_MSGHDR_$E(OM,5,$L(OM))
	*/

	quit


GETBAL()
	/*
	 This section can be customized by copying ISO8583 to ZISO8583.

	 Balance information

	 INPUTS:
		CRCD	- Currency of original transaction amount
		PCID	- PROFILE account number
		PRCD	- Processing code
		TRTYP	- Transaction type

	 OUTPUT:
		Account balance information
	*/

	type public String ACODE,%CO,CRCD,data,FCRCD,PAMT,PRCD,RM,RSPCD,TRTYP
	type public Number BAL,BALAVL,BALS,CRCDNO,PCID

	// Invalid account number
	if PCID=0 set RSPCD=$$RSPCD^ISO8583(7774,.RM) quit ""
	// Invalid Account ~p1
	if 'Db.isDefined("ACN","CID=:PCID") set RSPCD=$$RSPCD^ISO8583(1259,.RM,PCID) quit ""
	
	type RecordACN acn = Db.getRecord("ACN","CID=:PCID")
	set BALAVL=acn.balavail
	set FCRCD=acn.crcd
	set BAL=acn.bal

	if TRTYP'="CREDIT" set ACODE=PRCD.extract(3,4)
	else  set ACODE=PRCD.extract(5,6)

	type RecordCRCD crcd = Db.getRecord("CRCD","CO=:%CO,CRCD=:CRCD")
	set CRCDNO = crcd.crcdno
	set CRCDNO=$$RJ^%ZTEXT(CRCDNO,3,0)
	set EXP=10**crcd.curdec

	set BALS=$$BALFMT(ACODE,"01",CRCDNO,BAL,CRCD,EXP)
	set BALS=BALS_$$BALFMT(ACODE,"02",CRCDNO,BALAVL,CRCD,EXP)
	if PAMT>0 set BALS=BALS_$$BALFMT(ACODE,"58",CRCDNO,PAMT,CRCD,EXP)

	quit BALS


BALFMT(ACCTCODE,AMNTCODE,CRCDNO,AMT,CRCD,EXP)
	/*
	 Format Balance

	 Position	Data
	 1-2		Account Type (n 2)
	 3-4		Amount Type (n 2)
	 5-7		Currency Code (n 3)
	 8-20		Amount (x + n 12)
	*/

	type public Number BAL
	type public String SIGN

	if 'EXP.exists() S EXP=$$EXP^ISO8583(CRCD)

	// Convert amount to message currency
	set AMT=AMT*EXP
	if AMT<0 set AMT=-(AMT),SIGN="D"
	else  set SIGN="C"

	// Return all 9's if greater than 12 digits
	if AMT.length()>12 set AMT=999999999999

	quit ACCTCODE_AMNTCODE_CRCDNO_SIGN_$$RJ^%ZTEXT(AMT,12,0)


HDR(IM)
	/*
	 Build Header Information

	 This section can be customized by copying ISO8583 to ZISO8583.

	 Define the message header for the request message built by the 
	 ZISOTST testing utility and the Network Management Message
	 Generator in ZISOUTL.

	 ARGUMENTS:
		IM	- ISO 8583 Request Message

	 OUTPUT:
		Request message with header

	 For Example:

	 quit $E(IM,1,4)_$$PKNS^ISO8583("02000000")_$E(IM,5,$L(IM))
	*/

	quit IM


STMT
	/*
	 Statement request

	 This section can be customized by copying ISO8583 to ZISO8583.

	 INPUTS:
		CRDNUM	- Card Number
		PCID	- PROFILE account number
		PRCD	- Processing code
		TCODE	- Process code transaction type
	*/

	type public String RM,RSPCD

	// No current standard statement code
	// ~p1 not supported
	set RSPCD=$$RSPCD^ISO8583(374,.RM,"Statement processing")

	quit


RESPONSE
	/*
	 Response message processing

	 This section can be customized by copying ISO8583 to ZISO8583.
	*/

	quit


POSTPRE
	/*
	 POST section pre-processor

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to format transactions (i.e., fee transactions)
	 in addition to the transactions formatted by ISO8583.

	 For example:

	 new FEE,FEEAMT

	 // Do not build fee transactions for non-partial reversals.
	 if REV,'PARTIAL quit

	 // Determine fee information for fee code 1
	 do ZFEEUTL(.FEE,$G(BIT(28)),$G(BIT(30)),TAMT,TRTYP,PCID,$G(BIT(25)))
	 if ER set RSPCD=$$RSPCD("05") quit

	 // Build fee transactions based on fee information
	 set FEEAMT=$P(FEE,"|",2)
	 if FEEAMT>0 do {
		do TTX^ATMUTL(.ttx,PCID,$P(FEE,"|",3),FEEAMT,EFD,"",$$^MSG(3507),"",%SystemCurrency)
		do TTX^ATMUTL(.ttx,$P(FEE,"|",5),$P(FEE,"|",4),FEEAMT,EFD,"",$$^MSG(3507),"",%SystemCurrency)
	 }
	 if ER set RSPCD=$$RSPCD("05") quit

	 // Determine fee information for fee code 2
	 do ZFEEUTL(.FEE,$G(BIT(29)),$G(BIT(31)),TAMT,TRTYP,PCID,$G(BIT(25)))
	 if ER set RSPCD=$$RSPCD("05") quit

	 // Build fee transactions based on fee information
	 set FEEAMT=$P(FEE,"|",2)
	 if FEEAMT>0 do {
		do TTX^ATMUTL(.ttx,PCID,$P(FEE,"|",3),FEEAMT,EFD,"",$$^MSG(3507),"",%SystemCurrency)
		do TTX^ATMUTL(.ttx,$P(FEE,"|",5),$P(FEE,"|",4),FEEAMT,EFD,"",$$^MSG(3507),"",%SystemCurrency)
	 }
	 if ER set RSPCD=$$RSPCD("05") quit
	*/

	quit


POSTPST
	/*
	 POST section post-processor

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to view all transactions (including secondary
	 and system-generated transactions) posted in Profile in
	 relation to an ISO8583 request message.
	*/

	quit


BLDPRE
	/*
	 BLDOM section pre-processor

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to add/modify the bits used to build outgoing
	 ISO8583 response messages.
	*/

	quit


VLDMSG(MID,BIT)

	/*
	 Validate message

	 ARGUMENTS:
		MID		Message id
		BIT		Parsed array of 'msg'

	 RETURNS:
		$$		Validation flag (0-invalid,1-valid)

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to add/modify the message validation logic.

	 For example:

	 new FLD,VALFLD,VALID

	 // Initialization
	 set VALID=1
	 set VALFLD=""

	 // Determine valid fields
	 if MID="0110" set VALFLD=",2,3,4,5,6,7,10,11,12,13,15,18,19,32,33,37,38,39,41,48,49,51,54,102,103,"
	 if MID="0130" set VALFLD=",2,3,4,5,6,7,10,11,12,13,15,18,19,32,33,37,38,39,41,49,51,102,103,"
	 if MID="0210" set VALFLD=",2,3,4,5,6,7,10,11,12,13,14,15,18,19,32,33,37,38,39,41,48,49,51,54,102,103,128,"
	 if MID="0230" set VALFLD=",2,3,4,5,6,7,10,11,12,13,14,15,18,19,32,33,37,38,39,41,49,51,102,103,128,"
	 if MID="0410" set VALFLD=",2,3,4,5,6,7,10,11,12,13,14,15,18,19,32,33,37,38,39,41,48,49,51,54,95,102,103,"
	 if MID="0430" set VALFLD=",2,3,4,5,6,7,11,12,13,15,18,19,32,33,37,38,39,41,48,49,54,102,103,"
	 if MID="0810" set VALFLD=",2,7,11,32,39,70,"

	 // Search for invalid fields
	 set FLD=""
	 if VALFLD'="" for  set FLD=$O(BIT(FLD)) quit:FLD=""  if VALFLD'[(","_FLD_",") set VALID=0  quit:'VALID

	 quit VALID
	*/

	type public String VALMID

	// Check if the message id is valid
	set VALMID="-0100-0101-0120-0121-0200-0201-0220-0221-0400-0401-0420-0421-0500-0520-0521-0800-"
	// Invalid transaction ~p1
	if VALMID'[("-"_MID_"-") quit 0

	quit 1


NETWORK(CODE)

	/*
	 Network Management Message Support

	 ARGUMENTS:
		CODE		Network Management Information Code
				"001" - Sign on request
				"002" - Sign off request
				"201" - Cutover
				"301" - Echo test
	 RETURNS:
		MID		Return Message ID

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to perform Network Management logic.

	 */
	 
	 quit


RECON

	/*
	 Reconciliation Message Support

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to perform Reconciliation logic.

	 */
	 
	// No current standard reconciliation code
	// ~p1 not supported
	set RSPCD=$$RSPCD^ISO8583(374,.RM,"Reconciliation processing")
	
	quit
	 
	 	 
ZT
	/*
	 Error trap - called from PBSNSM
	*/

	set ATMM=$$NXTSEQ^ATMUTL()
	set RM=$ZS
	do NSMLOG^PBSNSM(INTRFACE.get(),ATMM,vzpkt.get(),RM,RM.extract(1,40))

	quit ""
 #OPTION ResultClass ON
Public String vSIG()	quit "60870^23482^Brandon Rickards^61159"	// Signature - LTD^TIME^USER^SIZE
