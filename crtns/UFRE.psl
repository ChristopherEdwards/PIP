public UFRE
	// Frequency Utility
	/*
	   KEYWORDS: Frequencies, Date and Time
	
	       ORIG: Tom Locke (2424) - 06/23/86
	
	       DESC:
	             Given a valid frequency and a starting julian date, the
	             next julian date occurance of that frequency will be
	             computed.
	
	             Frequencies are comprised of four separate components
	             (A_B_C_D).  Each of these components is defined below.
	
	             A = Multiple associated with the period.  The value of 1
	                 is a default value, and may be omitted if desired.
	
	             B = The period.  Standard values are:
	                                    D = Daily
	                                    W = Weekly
	                                    M = Monthly
	                                    Q = Quarterly
	                                    Y = Yearly
	
	                 Examples of AB combinations:
	                            2W = every two weeks
	                            1M = every month
	                            3Y = every three years
	                            1Q = every calendar quarter
	
	             C = Clarifies the payment due date when the calendar date
	                 is a non-business day.
	
	                 Possible values are:
	                       <A>ctual Date
	                       <N>ext Business Date
	                       <P>revious Business Date
	
	             D = The day of each frequency that the payment is due.
	                 Possible values are:  1 - 31
	
	                 The meaning of E (e.g., 1MAE, 1QAE, etc.):
	                   - for monthly, E indicates the end of the month
	                   - for quarterly, E indicates the end of the quarter
	                   - for user-defined type 0 frequencies that are
	                     either based on Q or 2M, 3M, 4M, or 6M (which
	                     are regular, recurring frequencies), which have
	                     a starting month specified, E indicates the end
	                     of the period.
	
	    Line Tag Calls:
	
	       NJD:  $$Extrinsic call to return next date.
	
	       FULL: The next date determined will be at least one full
	             frequency from the starting date.
	
	             Example:  FRE="1MA13"
	                       JD=53946  (9/12/88)
	                       NJD returned equals 53977 (10/13/88)
	
	             Sample Calls: @LNSL01 - Convert Interim Student Loan To
	                                     Permanent (^LNICFE1)
	
	       EDT:  The frequency (represented by X) is validated.
	
	             Sample Calls: @VERFRE - Frequency Integrity Check (^UFREIC)
	
	       INT:  Interactive: NJD is displayed at the bottom of a DATA-QWIK
	             screen.
	
	             Sample Calls: @DEP018 - Certificate Rollover Maintenance
	                                     (^DEPSTS, calls screen "ROLLOVR")
	
	
	   INPUTS:
	   . FRE	Valid Profile Frequency		/TYP=T/REQ
	
	   . JD		Starting Julian Date		/TYP=D/REQ
	
	
	   RETURNS:
	   . NJD	Next Julian Date		/TYP=D
	
	   . ER		Error Flag			/TYP=L
	
	   . RM		Return Error Message		/TYP=T/COND=(ER=1)
	
	   EXAMPLE:
	   S FRE="1MA13"
	   S JD=%SystemDate
	   D ^UFRE Q:ER
	
	---- Revision History -------------------------------------------------
	
	07/01/07 - KinI - CR 27406
		   o Modified ST section to redefine %SC only if it is null so 
		   that FS.USRFRE flag does not overlay CTL parameter’s 5th 
		   component if one is defined. This allows to avoid incorrect 
		   subsequent due date calculation with semi-monthly frequency 
		   and non-business dates calendar.
		   o Modified START1 section to save off %P when CTL 3rd 
		   component is 1 and %P is reset to "A". This allows to avoid
		   unnecessary edit check error.
	
	09/03/07 - Mugilvannan - CR 25834
		   Modified TBL section to directly set vREF with user-defined
		   Frequencies.
		   
	08/02/06 - KELLYP - CR 22048
		   Modified multiple sections to eliminate PRECEDENCE warnings.
	
	06/19/06 - KELLYP - CR 21207
		   Modified M section to properly initialize the %SM array.
		   The array was being initialized incorrectly which caused
		   problems with quarterly-based calculations.
	
	06/06/06 - KUMARB - CR 21379
		   Modified section NXT, to remove the condition "PDD>:STRT"
		   in ResultSet rs if STRT is Null.
	
	03/13/06 - KUMARB - CR 19875
		   Modified section LST, to remove the condition "PDD<:STRT"
		   in ResultSet rs if STRT is Null.
	
	05/23/05 - TITOVE - CR 15737
		   Modified D, OS2, Q, W, and M1 sections to round Annual Factor (AF)
		   value to five decimal places.

	04/28/05 - TITOVE - CR 15734
		   Modified UT3 section to correctly select data from USRFRE2.

	03/03/05 - TITOVE - CR 14220
		   Modified subroutine END1 to purge SVFRE if the number
		   of entries in the array exceeds 500, to prevent the
		   size of the array from impacting performance.		   

	02/01/05 - TITOVE - CR 13727
		   Cleaned up errors as part of DBI2 project.

	-----------------------------------------------------------------------
	*/

	do NEXT
	
	quit

public NEXT	// Next cycle
	
	new %EDT,%INT,%SC
	new BDOA,CTL

	set (CTL,%EDT,%INT,%SC)=0

	do START

	quit

public	FULL	// Go to next FULL cycle
	/*
	   KEYWORDS: Frequencies, Date and Time
	
	   DESC:
	       The next date determined will be at least one full frequency
	       from the starting date.
	
	   INPUTS:
	   . FRE	Valid Profile Frequency		/TYP=T/REQ
	
	   . JD		Starting Julian Date		/TYP=D/REQ
	
	   RETURNS:
	   . NJD	Next Julian Date		/TYP=D
	
	   . ER		Error Flag			/TYP=L
	
	   . RM		Return Error Message		/TYP=T/COND=(ER=1)
	
	   EXAMPLE:
	         S FRE="1MA13"
	         S JD=53946  ; (9/12/88)
	         W !,NJD     ; returned equals 53977 (10/13/88)
	
	*/

	new %EDT,%INT,%SC
	new BDOA,CTL

	set (%EDT,%INT,CTL)=0 
	set %SC=1

	do START

	quit
	
public	INT	// Interactive - print next date at bottom of screen
	/*
	
	   KEYWORDS: Frequencies, Date and Time, Formatting
	
	   DESC:
	       Interactive: NJD is displayed at the bottom of a DATA-QWIK
	       screen.
	
	       Sample Calls: @DEP018 - Certificate Rollover Maintenance
	                               (^DEPSTS, calls screen "ROLLOVR")
	
	   INPUTS:
	   . FRE	Valid Profile Frequency		/TYP=T/NOREQ
	
	   . JD		Starting Julian Date		/TYP=D/REQ
	
	   RETURNS:
	   . NJD	Next Julian Date		/TYP=D
	
	   . ER		Error Flag			/TYP=L
	
	   . RM		Return Error Message		/TYP=T/COND=(ER=1)
	
	*/

	new %EDT,%INT,%SC,BDOA,CTL 

	set (%EDT,%SC,CTL)=0 
	set %INT=1

	if $G(JD)<1 set JD=%SystemDate 

	do START

	quit

public	NJD(JD,FRE,AF,CTL)	// Extrinsic call for next date
	/*
	
	   KEYWORDS: Frequencies
	
	   DESC:
	      Returns next date based upon valid PROFILE frequency and
	      and starting date (JD).
	
	   ARGUMENTS:
	   . JD		Start date			/TYP=D/REQ/MECH=VAL
	
	   . FRE	Frequency			/TYP=T/REQ/MECH=VAL
	
	   . AF		Annual factor			/TYP=N/NOREQ/MECH=REFNAM:W
	
	   . CTL	Calculation control		/TYP=N/REQ/MECH=VAL
	     		 Position   Operation ( 0=No, 1=Yes )
	            	  1       Use reverse (backwards) calculation.
	                  2       Edit check for correct syntax only. Returns
			          "1" if error, "0" if no error.
	                  3       Use "A" business date option regardless of
			          what is found in frequency.
	                  4       Interactive - print next date on bottom of
			          screen.
	                  5       Automatically bump by at least one FULL cycle.
	
	   RETURNS:
	   . $$		Next Julian Date		/TYP=D
	
	*/

	new %EDT,%SC
	new BDOA,INT,NJD 

	set (%INT,%SC,%EDT,BDOA)=0
	
	if 'JD set JD=%SystemDate

	set AF=$G(AF)
	
	set CTL=$G(CTL)
	if $E(CTL,2) set X=FRE do EDT quit ER
	
	if CTL="" set CTL=0
	else  do {
		if $E(CTL,1),$E(FRE)'="-" set FRE="-"_FRE
		if $E(CTL,3) set BDOA=1
		if $E(CTL,4) set INT=1
		if $E(CTL,5) set %SC=1
		}
	
	do START

	quit NJD
	

DBSEDT(dinam,%INT)    // DATA-QWIK edit checking (batch/on-line)
	/*
	   ARGUMENTS:
	
	   . dinam	Data item name in [fid]di format	/TYP=T/REQ/MECH=VAL
	   . %INT	Batch/on-line mode			/TYP=L/NOREQ/MECH=VAL
	
	   EXAMPLE:
	
	   D DBSEDT(I(2),1)	; Called by DBSCRT8 routine
	   D DBSEDT(dinam,0)	; Called by filer routine
	
	*/

	set %INT=$G(%INT)

	do EDT2(dinam)

	quit

public	EDT	// Edit check for correct syntax
	/*
	   KEYWORDS: Frequencies, Formatting
	
	   DESC:
	   The frequency (represented by X) is validated.
	
	         Sample Calls: @VERFRE - Frequency Integrity Check (^UFREIC)
	
	   INPUTS:
	   . X		Frequency from data enty		/TYP=T/REQ
	
	    RETURNS:	
	   . ER		Error Flag				/TYP=L
	
	   . RM		Return Error Message			/TYP=T/COND=(ER=1)
	
	   EXAMPLES:
	   S X="1MA1"
	   D EDT^UFRE
	   W !,ER
	*/

	new %INT 

	set %INT=0

	do EDT2("")

	quit
	
EDT2(dinam)  // Edit Check
	new FREQ

	set FREQ=$P(X,"/",2)

	if $G(X)="" set NJD=-1 quit 
	if X="/" set ER=1 quit
	if X'="",X["/",FREQ="" set ER=1 quit 
	if $L(FREQ),'Db.isDefined("UTBLNBD","NBDC=:FREQ") set ET="NOCAL" do ERR quit

	if X="*2" quit

	// Check for "Invalid frequency"	
	if $E(X)="*" quit:$E($P(dinam,"]",2),1,4)="DIST"  do Runtime.setErrMSG("DEP",1353) quit:ER

	new %EDT,%SC,BDOA,CTL 

	set %EDT=1 

	set (%SC,BDOA,CTL)=0

	if $G(JD)<1 set JD=%SystemDate
	set FRE=X

	do START

	quit
		
START	
	new %BD,%C,%CAL,%D,%DD,%DJ,%DM,%DY,%FRE,%I,%JD,%L,%LPYR,%M,%MDYS,%NLPYR
	new %ORIGSM,%OS,%OSD,%P,%REM,%REV,%SEMI,%SGN,%SM
	new %UFRE,%XD,%XM,%XOS,%Z
	new CAL,FRETYP,I,XJD
	
	set %JD=JD
	set %FRE=FRE

	do ST

	quit

ST	
	if JD'>0 do { quit
		set NJD=-1
		set ET="INVLDSDFRE"
		do ERR
		do END1
		}

	if FRE=""!(JD="")!(FRE="-") do { quit
		set NJD=-1
		do INVFRE(FRE,JD)
		} 

	if '%EDT,'%SC,$D(SVFRE(FRE,JD,CTL)) do { quit 
		set NJD=+SVFRE(FRE,JD,CTL)
		set AF=SVFRE(FRE,JD,CTL).piece("|",2)
		}
	
	set %CAL=FRE.piece("/",2)
	set CAL=%CAL
	set FRE=FRE.piece("/",1)

	kill %OS
	
	set (ER,%BD,%OSD,%REM,%REV,%SEMI)=0
	set NJD=-1
	set (%ORIGSM,%SM)=%SM.get()

	if FRE'["*" set AF=0

	set %LPYR="31,29,31,30,31,30,31,31,30,31,30,31"
	set %NLPYR="31,28,31,30,31,30,31,31,30,31,30,31"
	
	set %D=$$DAT^%ZM(JD,"MM/DD/YEAR")
	set %DM=+$P(%D,"/",1)
	set %DD=+$P(%D,"/",2)
	set %DY=+$P(%D,"/",3)
	
	// Direction is reversed
	if FRE.extract()="-" set %REV=1,FRE=FRE.extract(2,99)
	set %UFRE=FRE
	
	// Loan payment schedule
	if FRE.extract()="*" do { quit
		set (FRETYP,%Z)=""
		do REALUDF
		do END
		}

	// Not User Defined
	if 'Db.isDefined("USRFRE","FRE") do START1 quit

	type ResultSet rs=Db.select("DESC,FRE,SM,FC,FRETYP,AF,BD,ENDF,NBDC","USRFRE","UFRE=:FRE")
	if rs.next() set %Z=rs.getRow("|")
	set FRETYP=rs.getCol("FRETYP")

	// Irregular frequency - same dates each year
	if FRETYP=1 do { quit
		do REALUDF
		do JD
		do END
		}

	// Irregular frequency - crosses years
	if FRETYP=2 do { quit
		do REALUDF
		do BUSDAT
		do END
		}

	// Pseudo-user-defined (mapped to a PROFILE frequency)
	set FRE=rs.getCol("FRE")
	set %SM=rs.getCol("SM")

	if %SC.isNull() set %SC=+rs.getCol("FC")
	if %CAL="" set %CAL=rs.getCol("NBDC")

	do START1

	quit
	
START1	
	set %M=+FRE 
	set %L=$select(%M:$L(%M),1:0) 
	set %C=FRE.extract(%L+1)

	if %C=""!("SDMWYQ"'[%C) do { quit
		set ET="INVLDCYC" 
		do ERR
		do END
		}

	if '%M do {
		set %M=1
		if %EDT do {
			set FRE=1_FRE
			set %L=1
			}
		}

	set %P=FRE.extract(%L+2)
	
	// If BDOA flag is turned on (CTL position 3) use "A" regardless of what 
	// is passed. Save off the business date option value for edit checks.
	type String SAVBDO=%P
	if BDOA.get() set %P="A"
	
	if "ANPE"'[%P,%P.length(),%P'?.N do { quit
		set ET="INVLDDAT" 
		do ERR
		do END
		}

	/* Semi-monthly (i.e. 10-20-30)
	   For semi-montly frequency edit check use original %P value (SAVBDO) 
	   to avoid unnecessary error when CTL 3rd component is 1 and %P is 
	   forced to be changed to "A".
	*/
	if %C="S",FRE.piece(SAVBDO,2)'?1N.N1"-"1N.N.E do INVFRE(FRE,JD),END1 quit

	if %C="S" do {
		set %C="M"
		set %SEMI=1
		}
	
	// If interactive, prompt user for "ANP".
	if %P=""!("ANP"'[%P) do { quit:ER 
		if %INT do BLD
		if '%INT do INVFRE(FRE,"") quit

		set FRE=FRE.extract(1,%L+1)_%P_FRE.extract(%L+2,99)

		// Reset original values to include "ANP"
		set %UFRE=FRE
		set X=$select(CAL'="":FRE_"/"_CAL,1:FRE)

		if %EDT set %FRE=X
		}
	
	if %P="P",'%REV.get() do {
		set XJD=JD
		new JD
		set JD=XJD
		do PRIOR
		}

	if %P="N",%REV.get() do {
		set XJD=JD
		new JD
		set JD=XJD
		do PRIOR
		}

	// Day offset
	set %OS=FRE.extract(%L+3,FRE.length())
	if %OS?1"0".E for I=1:1 quit:$E(%OS)'=0  set %OS=%OS.extract(2,99)
	
	do OSCHK if ER do INVFRE(FRE,JD),END1 quit
	
	// Set offset to day of month
	if %OS="" set %OS=%DD

	if %OS["+"!(%OS["-") do { if ER do END1 quit
		if '%SEMI do OS1
		if %SEMI do OS2 
		}

	if %INT set:$D(%UFRE) FRE=%UFRE set:%EDT X=%FRE do END1 quit

	do @%C

	quit


OS1	// Calculate offset in days
	if +%OS=%OS quit  
	set %SGN=$S(%OS["+":"+",1:"-")

	set %OSD=%SGN_+$P(%OS,%SGN,2),%OS=$P(%OS,%SGN,1) if %OS set %OS=+%OS

	do OSVER if ER quit 
	
	if %C="Q",%OS'=1,%OS'="E" do INVFRE(FRE,JD) quit 

	set %Z=%OS+%OSD 
	if %Z>0,%Z<29 set %OS=%Z,%OSD=0

	quit 

OSVER	//
	if %C="M"!(%C="Q") do { quit
		if %OSD>28!(%OSD<-28) do INVFRE(FRE,JD)
		}

	if %OSD do INVFRE(FRE,JD)

	quit 

OS2	// Find offset on semi-monthly frequency

	type public Number %I, AF
	type public String %OS(), %Z

	set %Z = %OS kill %OS set %OS = %Z

	for %I = 1:1 quit:%OS.piece("-",%I).isNull()  if (%I < 32) set %OS(+%OS.piece("-",%I)) = ""

	set AF = +$J((%I - 1)*12,0,5)

	quit 


OSCHK	// Validate off-set
	set ER=0

	if (%C="D")!(%C="W"),%OS'="" do { quit
		set JD=""
		set ER=1
		} 

	if %OS["E" if %OS="E" quit  if $L(%OS)>1 set ER=1 quit 
	if %OS>$S(%C="M":31,%C="Q":92,1:999) set ER=1 quit 
	if %OS?.N quit 
	if %OS?1N.N1"-"1N.N quit 
	if %OS?1N.N1"+"1N.N quit

	// Invalid, except possibly 10-20-30 for "S"
	if '%SEMI set ER=1 quit                
	for I=1:1 do { if ER quit
		set X=$E(%OS,I) if X="" quit  if X'?1N,X'?1"-" set ER=1 if 'ER,$E(%OS,I+1)'?1N set ER=1
		}
	quit

ERR	// Process the error condition
	if $D(%UFRE) set FRE=%UFRE

	set ER=1 do ^UTLERR
	
	quit

INVFRE(FRE,JD)	// Format invalid frequency message

	set ER=1
	
	if JD set JD=$$DAT^%ZM(JD)
	
	// Frequency of "~p1" is invalid
	if JD="" set RM=$$^MSG(1610,FRE)
	
	// Frequency of "~p1" with beginning date ~p2 is invalid
	else  set RM=$$^MSG(1613,FRE,JD)

	quit 
	
D	// Daily Frequency	

	type public Boolean %REV
	type public Date JD, NJD
	type public Number %M, AF

	set NJD = JD + $S(%REV:-%M,1:%M)

	set AF = +$J($S($$DAT^%ZM(JD,"YY")#4:365,1:366)/%M,0,5)

	do BUSDAT
	
	do END

	quit
	

W	// Weekly Frequency

	type public Boolean %REV
	type public Date JD, NJD
	type public Number %M, AF
	type public String %OS

	if (%OS = "E") set %OS = 7

	set NJD = ($S(%REV:-%M,1:%M) * 7) + JD
	
	set AF = +$J((52/%M),0,5)

	do BUSDAT
	
	do END

	quit
	
	
Q	// Quarterly Frequency

	type public Number %M, %SM, AF
	type public String %C

	set AF = $J(4/%M,0,5)
	
	set %C = "M"
	
	set %M = 3 * %M

	if '%SM set %SM = 1

	do M

	quit
	
	
Y	// Yearly Frequency

	type public Number %M

	set %M = %M * 12

	do M1

	quit


PRIOR	// Get proper starting point for Prior option
	/*
	   For Prior business day option, check to see if next day is a non-
	   business day.  If it is, move to last non-business day going
	   forward to ensure proper start to bump.  If this is not done,
	   because date may have moved back due to "P", one cycle will be
	   skipped on next bump.
	
	   For Next business day option on reverse frequencies we check to
	   see if the last day is a non-buisness day. If it is then we move to
	   the next non-business day going forward. The problem was the same
	   as that with "P" for positive frequencies.
	*/

	// Direction - forward for positive, backward for negative
	new X

	set X=$S(%REV:-1,1:1)

	for JD=JD+X:X if $$BD^UNBD(JD,%CAL) quit 

	set JD=JD-X
	
	set %D=$$DAT^%ZM(JD,"MM/DD/YEAR")
	set %JD=JD
	set %DM=+$P(%D,"/",1)
	set %DD=+$P(%D,"/",2)
	set %DY=+$P(%D,"/",3)

	quit 
	
REV	// Last cycle date
	if %SEMI do RSEMI quit
	if %SM do RSM quit

	do ROSD
	
	for %I=2:1:%M do DMA

	if '%OSD do {
		do MDYS
		if %XOS>%MDYS set %XOS=%MDYS
		set %OS=%XOS
		}
	quit
	
ROSD	// Reverse freq that is not semi or has starting month
	if '%OSD,%XOS'="E" do MDYS if %OS>%MDYS set %OS=%MDYS

	if '%OSD,%DD'>%OS do DMA

	if '%OSD,%SC,'%BD,%DD'=%OS do {

		if %P'="P" do DMA quit 
		if %DD=%OS quit 
		if '$$BD^UNBD(JD) do DMA quit 

		new XJD,HIT

		set HIT=1

		for XJD=JD+1:1 quit:$$DAT^%ZM(XJD,"DD")=%OS  if $$BD^UNBD(XJD) set HIT=0 quit 

		}

	if %OSD<0 do MDYS,DMB if %DD'>(%MDYS+(%OS+%OSD)) do DMA
	if %OSD>0 do DMA,MDYS if %DD'>(%OSD-(%MDYS-%OS)) do DMA
	
	quit 
	
RSM	// Reverse freq that has a starting month

	if %SM,%C'="Q" new %M set %M=1

	if '%OSD,%XOS'="E" do MDYS if %OS>%MDYS set %OS=%MDYS

	set %DM=%DM+1 do RXSM

	if '%OSD,%DD'>%OS,%XM=+%D do RXSM
	if '%OSD,%SC,'%BD,%DD'=%OS do RXSM

	if %OSD<0 do MDYS,DMB if %DD'>(%MDYS+(%OS+%OSD)),%XM=+%D set %DM=%XM do RXSM,DMB
	if %OSD>0 do DMA,MDYS if %DD'>(%OSD-(%MDYS-%OS)),%XM=+%D set %DM=%XM do RXSM,DMA
	if '%OSD do {
		do MDYS 
		if %XOS>%MDYS set %XOS=%MDYS
		set %OS=%XOS
	}
	
	quit 
	
RSEMI	// Reverse semi-monthly
	set %OS=%DD

	for %I=1:1:%M set %OS=$O(%OS(%OS),-1) if '%OS set %OS=$O(%OS(""),-1) do DMA

	quit

M	// Monthly

	// Determine valid months if starting month is specified. Only
	// recurring monthly/quarterly cycles within a year are valid.

	if %SM do { quit:ER

		if "/2/3/4/6/"'[("/"_%M_"/") do INVFRE(FRE,JD) quit 

		new X
		
		// Shift starting month if day is E (end-of-month) to
		// force to last day of cycle, not of the month
		if %OS="E" set %SM=%SM+(%M-1)

		set %SM=(%SM-1)#%M+1
		set X=%SM

		for  set %SM(X)="",X=X+%M quit:X>12 

		}
	do M1

	quit

M1	//

	type public Boolean %REV, %SEMI
	type public Date JD, NJD
	type public Number %BD, %D, %DD, %DM, %DY, %M, %OSD, %SC, %SM, %XM, AF, ER
	type public String %FRE, %MDYS, %OS, %XOS, FRE

	set AF = +$S(AF:AF,1:$J((12/%M),0,5))

	if (%OS = "E") set (%XOS,%OS) = 31
	
	else  set %XOS = %OS do XOS

	if %REV do REV,JD,END quit
	
	if %SEMI do SEMI quit
	
	if '%SM do OSD quit

	set %BD = 0

	// Starting month
	if (%SM(%DM - 1).order() = %DM),(%DD '< %OS) set %DM = %DM + 1

	set %DM = %SM(%DM-1).order() if %DM.isNull() set %DM = %SM("").order(),%DY = %DY + 1
	
	set %XM = %DM do XOS

	// Get the actual number of days in the month
	if '%OSD do {

		if ((%DD = %OS)&(%XM = +%D)) set %BD = 1
		
		if (%DD '< $$NODM^SCADAT(JD,1)),(%XM = +%D),(%DY = %D.extract(7,10)) do {

			do XSM
			
			if (%XOS = "E") do MDYS set %OS = %MDYS
			}
		}

	if %OSD do {

		do SM1
		
		if (%DD = %XD) set %BD = 1
		
		if (%XM = +%D),(%DD '< %XD) set %DM = %XM do XSM,SM1
		}
		
	do JD

	// Determine if full cycle, if not bump one more
	if %SC do {

		type Boolean BUMP = 0
		type Date ORIGJD, ORIGNJD
		type String ORIGFRE = %FRE

		set ORIGJD = JD
		set ORIGNJD = NJD

		do {

			new X

			set X = "(SVFRE,%FRE,JD,NJD)"

			new @X

			set JD = NJD
			set FRE = "-"_%FRE

			do UFRE
			}

		// Need one more cycle
		if (NJD < ORIGJD) set BUMP = 1

		set JD = ORIGJD
		set NJD = ORIGNJD
		set %FRE = ORIGFRE

		if 'BUMP ! ER quit

		// Bump one more cycle
		set ORIGJD = JD
		set JD = NJD
		set FRE = %FRE

		do UFRE

		set JD = ORIGJD

		}

	do END
	
	quit
	
	
XOS	//
	
	if %XOS="E" do MDYS set %OS=%MDYS quit 

	set %OS=%XOS

	quit
	

OSD	// Calculate NJD when %OSD is used
	if '%OSD,%XOS'="E" do MDYS if %OS>%MDYS set %OS=%MDYS
	
	if '%OSD do {
		if ((%XOS'="E")&(%OS=%DD)) set %BD=1 
		if %XOS="E" do MDYS set:%OS=%MDYS %BD=1 set %OS=%MDYS
		}

	if '%OSD do {
		if ((%DD'<%OS)&(%DM=+%D)) do DMB,XOS 
		if %SC,'%BD,%DD'=%OS do DMB,XOS
		}

	if %OSD<0 do MDYS,DMB set %XD=%MDYS+(%OS+%OSD)
	if %OSD>0 do DMA,MDYS set %XD=%OSD-(%MDYS-%OS)
	if %OSD if %DD'<%XD do DMB if %SC,%DD'=%XD do DMB

	for %I=2:1:%M do DMB

	if '%OSD do MDYS set:%XOS>%MDYS %XOS=%MDYS set %OS=%XOS

	do JD
	do END

	quit
	
SM1	//
	
	if %OSD<0 do MDYS,DMB set %XD=%MDYS+(%OS+%OSD) quit
	if %OSD>0 do DMA,MDYS set %XD=%OSD-(%MDYS-%OS) quit

	quit
	
SEMI	//
	
	set %OS=%DD
	
	if '%SC do SEMI1 quit
	if $D(%OS(%DD)) do SEMI1 quit
	
	do MDYS if $O(%OS(%DD))'>%MDYS set %M=%M+1 do SEMI1 quit
	
	if %DD<%MDYS set %M=%M+1
	
	do SEMI1
	
	quit

SEMI1	// Skip %M cycles
	
	for %I=1:1:%M set %OS=$O(%OS(%OS)) if %OS="" do DMB set %OS=$O(%OS(%OS))
	
	// Is offset greater than the total days in the month?
	do MDYS if %OS>%MDYS set %OS=%MDYS
	
	// Is NJD in current month and offset not greater than JD?
	// If yes, then get first occurence in next month
	if %DM=+%D,%OS'>%DD do {
		set %OS=$O(%OS(""))
		do DMB
		}
	
	do JD
	do END
	
	quit

JD	// Find NJD using %DM, %DD, %DY
	if %DY<100 set %DY=%DY+$S(%DY>50:1900,1:2000)

	set %Z=$S(%DY#4:%NLPYR,1:%LPYR)

	if +%OS=%OS set %DD=%OS
	if %DD>$P(%Z,",",%DM) set %REM=%DD-$P(%Z,",",%DM),%DD=$P(%Z,",",%DM)

	if %DY#4 set %DJ=$P("0,31,59,90,120,151,181,212,243,273,304,334",",",%DM)+%DD
	else  set %DJ=$P("0,31,60,91,121,152,182,213,244,274,305,335",",",%DM)+%DD

	set NJD=%DJ+((%DY-1841)*365)+((%DY-1841)\4)-1
	set NJD=NJD+%OSD

	do BUSDAT

	quit	

BUSDAT	// Non-Business Days

	if %P="A"!($$BD^UNBD(NJD,%CAL))
	else  if %P="N" for NJD=NJD:1 quit:$$BD^UNBD(NJD,%CAL) 
	else  if %P="P" for NJD=NJD:-1 quit:$$BD^UNBD(NJD,%CAL) 

	quit 
	
END	//

	if $D(%UFRE) set FRE=%UFRE
	if %REV set FRE="-"_FRE
	if %INT set X=$S(CAL'="":FRE_"/"_CAL,1:FRE)

	if ER,%INT do ^UTLERR 
	if ER do END1 quit

	if FRE'["*",%REV,NJD'<JD do { quit
		set JD=JD-1
		do ENDSM
		do ST
		}

	if FRE'["*",'%REV,NJD'>JD do { quit
		set JD=JD+1
		do ENDSM
		do ST
		}

	do END1

	quit

END1	//

	type public Number %EDT, %ER, %SC, AF, CTL, SVFRE
	type public String %FRE, FRE, SVFRE(,,)
	type public Date %JD, JD, NJD
	
	if %JD.exists() set JD = %JD
	if %FRE.exists() set FRE = %FRE

	if 'ER,'%EDT,'%SC,FRE'["*" do {

		if SVFRE.get() > 499 kill SVFRE
		set SVFRE = SVFRE.get() + 1
		set SVFRE(FRE,JD,CTL) = NJD_"|"_AF
		}

	quit
	
	
ENDSM	// Clean up starting month info before retry

	kill %SM

	if $D(%ORIGSM) set %SM=%ORIGSM

	quit 
	
BLD	
	new %JRNL

	set %P=$E("ANP",$$^DBSMBAR(38))

	if %P="" set %P="A"

	quit 
	
DMA	// Decrement month by 1

	set %DM=%DM-1 if '%DM set %DM=12,%DY=%DY-1

	quit 

DMB	// Increment month by 1

	set %DM=%DM+1 if %DM>12 set %DM=1,%DY=%DY+1

	quit 

MDYS	// Find the number of days in this month (%DM)

	set %MDYS=$S(%DY#4:$P(%NLPYR,",",%DM),1:$P(%LPYR,",",%DM))

	quit

XSM	// Find the next occurence of %DM when freq has a starting month

	set %DM=$O(%SM(%DM)) if %DM="" set %DM=$O(%SM("")),%DY=%DY+1

	set %XM=%DM

	quit 
	
RXSM	
	if $D(%SM(%DM-1)),%DD=%OS do {
		new X
		
		set X=%M
		
		new %M
		
		set %M=X
		set %M=%M+1
		}

	else  if $D(%SM(%DM-1)),%DD<%OS do {

		set %DM=$O(%SM(%DM),-1)

		if %DM="" do {
			set %DM=%O(%SM(""),-1)
			set %DY=%DY-1
			}
		}

	for I=1:1:%M set %DM=$O(%SM(%DM),-1) if '%DM set %DM=$O(%SM(""),-1),%DY=%DY-1

	set %XM=%DM

	quit 

REALUDF	// User Defined Frequency (not mapped to a PROFILE format)
	/*
	   Input   %DM,%DD,%DY,%Z

		   . CID	Account number			/TYP=N/NOREQ 

	   Output  %P  = business date option
	           AF  = annual factor
	           %DM,%DD,%DY = previous/next cycle date
	           %OS=%DD
	           %OSD=0
	*/

	// Used by routine JD above
	set (%OS,%OSD)=0

	// Annual factor
	if FRE'["*" set AF=$P(%Z,"|",6)

	// Business date option
	set %P=$P(%Z,"|",7)

	// Use "A" regardless of what is passed
	if $G(BDOA) set %P="A"

	// Save for later comparison
	set %DMSV=%DM
	set %DDSV=%DD
	set %DYSV=%DY

	// User Defined Frequency - type 1
	if FRETYP=1 do UDF quit 
	
	if FRE'="*" do UT2 quit 

	if '$G(CID) set ET="INVLDACN" do ERR quit 

	do {
		type ResultSet rs=Db.select("PDD","LNPS1","CID=:CID")
		if 'rs.isEmpty() quit
		set ER=1
		}

	if ER do { quit
		set ET="INVLDACN"
		do ERR
		}

	// User Defined Frequency - type 2
	do UT2

	quit
 
UDF	// User Defined Frequency
	set exit=0

	if %REV do UDFR quit

	type ResultSet rs=Db.select("MONTH,DAY","USRFRE1","UFRE=:FRE and MONTH>(:%DMSV-1)")
	if 'rs.isEmpty() while rs.next() set exit=$$VALDAT(.rs) quit:exit
	if exit set %OS=%DD quit

	set %DY=%DY+1

	new X
	type ResultSet rs2=Db.select("MONTH,DAY","USRFRE1","UFRE=:FRE")
	if rs2.isEmpty() quit
	set X=rs2.next()

	set %DM=rs2.getCol("MONTH")
	set %DD=rs2.getCol("DAY")
	set %OS=%DD

	quit
 
UDFR	// User Defined Frequency (Reverse)

	type ResultSet rs=Db.select("MONTH,DAY","USRFRE1","UFRE=:FRE and MONTH<(:%DMSV+1)","MONTH DESC,DAY DESC")
	if 'rs.isEmpty() while rs.next() set exit=$$VALDAT(.rs) quit:exit
	if exit set %OS=%DD quit

	set %DY=%DY-1

	new X
	type ResultSet rs2=Db.select("MONTH,DAY","USRFRE1","UFRE=:FRE","MONTH DESC,DAY DESC")
	if rs2.isEmpty() quit
	set X=rs2.next()

	set %DM=rs2.getCol("MONTH")
	set %DD=rs2.getCol("DAY")
	set %OS=%DD

	quit
 
VALDAT(ResultSet rs)	// Validate date

	set %DM=rs.getCol(1)
	set %DD=rs.getCol(2)
	
	if %DD="E" set %DD=$$UDFEOM

	if %DD=%DDSV,%DM=%DMSV,%DY=%DYSV quit 0
	if '%REV,%DM=%DMSV,%DD'>%DDSV quit 0
	if %REV,%DM=%DMSV,%DD'<%DDSV quit 0

	quit 1

UDFEOM()	// End of month
	if $$LEAP quit $P(%LPYR,",",%DM)

	quit $P(%NLPYR,",",%DM)

public	LEAP()	// Determine if year (%DY) is a leap year.
	/*
	
	   KEYWORDS: Frequencies, Date and Time
	
	   INPUTS:
	   . %DY	Year - Numeric				/TYP=N/REQ
	
	   RETURNS:
	   . $$		Leap year indicator			/TYP=L
	   		1 = leap year
	   		0 = not leap year
	
	   EXAMPLES:
	     S %DY=1994
	     W $$LEAP^UFRE()
	     0
	*/

	if %DY#4 quit 0

	if %DY#100=0,%DY#400 quit 0

	quit 1
	
UT2	// User defined frequency type 2 - crosses years
	new %F,%JD,%L,Z

	if %REV do UT2R quit

	// Forward Frequency
	if $E(FRE)'="*" do { do UT3 quit
		set NJD=""

		type ResultSet rs=Db.select("DATE","USRFRE2","UFRE=:FRE and DATE>:JD")
		if rs.isEmpty() quit
		if rs.next() set NJD=rs.getCol(1)

		}

	if FRE="*" set NJD=$$NXT(JD) do UT3 quit

	set NJD=JD

	for  set NJD=$$NXT(NJD) quit:NJD=""  if $$REC(NJD,$E(FRE,2)-1) quit

	if 'NJD do {
		set NJD=JD+1

		for  set NJD=$$LST(NJD) quit:NJD=""  if $$REC(NJD,$E(FRE,2)-1) quit

		}
 
	if NJD="",(FRE="*2") quit

	if 'NJD do INVFRE(FRE,JD) quit
	
	do UT3

	quit
 
UT3	//	

	if NJD quit

	// Use ending (final) frequency if start date is after last on file
	if $L($P(%Z,"|",8)) do { quit
		
		set FRE=$P(%Z,"|",8)
		do UT2U
		}

	// If no final frequency exists, must use values from last year on file
	if $E(FRE)'="*"  do {

		type ResultSet rs1=Db.select("DATE","USRFRE2","UFRE=:FRE","DATE DESC")
		if rs1.isEmpty() set %L="" quit
		if rs1.next() set %L=rs1.getCol(1)
		}

	else  set %L=$$LST("")

	if %L.isNull(),FRE="*2" quit

	if %L.isNull() do INVFRE(FRE,JD) quit

	do UT2N($$DAT^%ZM(JD,"MM/DD"),%L,0,.Z)
	
	if $E(FRE)'="*" do {

		type ResultSet rs2=Db.select("DATE", "USRFRE2", "UFRE = :FRE AND DATE > :Z")
		if rs2.isEmpty() set Z="" quit
		if rs2.next() set Z=rs2.getCol(1)
		}

	else  set Z=$$NXT(Z)

	if Z do UT2N($$DAT^%ZM(Z,"MM/DD"),JD,0,.NJD) quit

	do UT2N("12/31",%L,-1,.Z)
	
	if $E(FRE)'="*" do {

		type ResultSet rs3=Db.select("DATE", "USRFRE2", "UFRE = :FRE AND DATE > :Z")
		if rs3.isEmpty() set Z="" quit
		if rs3.next() set Z=rs3.getCol(1)
		}

	else  set Z=$$NXT(Z)

	do UT2N($$DAT^%ZM(Z,"MM/DD"),JD,1,.NJD)

	quit
	
 
UT2R    // Reverse Frequency
	
	if $E(FRE)'="*" do { do UT2R2 quit

		type ResultSet rs=Db.select("DATE","USRFRE2","UFRE=:FRE","DATE DESC")
		if rs.isEmpty() set %L="" quit
		if rs.next() set %L=rs.getCol(1)

		}

	if FRE="*" do { quit
		set %L=$$LST("")
		do UT2R2
		}

	set NJD=JD

	for  set NJD=$$LST(NJD) quit:NJD=""  if $$REC(NJD,$E(FRE,2)-1) quit

	if 'NJD do {

		set NJD=JD-1
		for  set NJD=$$NXT(NJD) quit:NJD=""  if $$REC(NJD,$E(FRE,2)-1) quit

		}

	if NJD="",FRE="*2" quit

	if 'NJD do INVFRE(FRE,JD)

	quit
 
UT2R2
	if JD>%L,$L($P(%Z,"|",8)) do { quit
		set FRE="-"_$P(%Z,"|",8)
		do UT2U 
		if NJD<%L set NJD=%L
		}

	if JD>%L do { quit
		do UT2D
		if NJD<%L set NJD=%L
		}

	if $E(FRE)'="*" do {

		type ResultSet rs=Db.select("DATE","USRFRE2","UFRE=:FRE and DATE<:JD","DATE DESC")
		if rs.isEmpty() set NJD="" quit
		if rs.next() set NJD=rs.getCol(1)

		}

	else  set NJD=$$LST(JD)

	if NJD="" do UT2B

	quit
 
UT2B	// Find NJD if start date is before 1st table value, using reverse freq
	if $E(FRE)'="*"  do {

		type ResultSet rs1=Db.select("DATE","USRFRE2","UFRE=:FRE")
		if rs1.isEmpty() set %F="" quit
		if rs1.next() set %F=rs1.getCol(1)

		}

	else  set %F=$$NXT("")

	do UT2N($$DAT^%ZM(JD,"MM/DD"),%F,0,.Z)

	if $E(FRE)'="*" do {

		type ResultSet rs2=Db.select("DATE","USRFRE2","UFRE=:FRE and DATE<:Z","DATE DESC")
		if rs2.isEmpty() set Z="" quit
		if rs2.next() set Z=rs2.getCol(1)

		}
	else  set Z=$$LST(Z)

	if Z do UT2N($$DAT^%ZM(Z,"MM/DD"),JD,0,.NJD) quit

	do UT2N("1/1",%F,1,.Z)
	
	if $E(FRE)'="*" do {

		type ResultSet rs3=Db.select("DATE","USRFRE2","UFRE=:FRE and DATE<:Z","DATE DESC")
		if rs3.isEmpty() set Z="" quit
		if rs3.next() set Z=rs3.getCol(1)

		}

	else  set Z=$$LST(Z)

	do UT2N($$DAT^%ZM(Z,"MM/DD"),JD,-1,.NJD)

	quit

UT2D	// Find NJD if start date is after last table value, using reverse freq
	do UT2N($$DAT^%ZM(JD,"MM/DD"),%L,0,.Z)

	if $E(FRE)'="*" do {

		type ResultSet rs1=Db.select("DATE","USRFRE2","UFRE=:FRE and DATE<:Z","DATE DESC")
		if rs1.isEmpty() set Z="" quit
		if rs1.next() set Z=rs1.getCol(1)

		}

	else  set Z=$$LST(Z)

	if Z,$$DAT^%ZM(Z,"YY")=$$DAT^%ZM(%L,"YY") do UT2N($$DAT^%ZM(Z,"MM/DD"),JD,0,.NJD) quit

	do UT2N("1/1",%L,1,.Z)
	
	if $E(FRE)'="*" do {

		type ResultSet rs2=Db.select("DATE","USRFRE2","UFRE=:FRE and DATE<:Z","DATE DESC")
		if rs2.isEmpty() set Z="" quit
		if rs2.next() set Z=rs2.getCol(1)

		}

	else  set Z=$$LST(Z)

	do UT2N($$DAT^%ZM(Z,"MM/DD"),JD,-1,.NJD)

	quit

UT2N(A,B,C,N)	// Find julian date by changing Mon, Day and/or string date year
	set D=$$DAT^%ZM(B,"YEAR")

	// If payment schedule has 2/29 set up, make sure the next year's date is 
	// returned as 02/28.
	if ((D+C)#4),(A="02/29") set A="02/28"

	set %DY=D+C

	if A="02/28",$$LEAP set A="02/29"

	set %DS=A_"/"_(D+C),%JD=$$^SCAJD(%DS),N=%JD

	quit
 
UT2U	// Re-call UFRE to return NJD using ending (final) frequency
	new X

	set X="(FRE,JD,NJD)"

	new @X

	do UFRE

	quit
	
NXT(Date STRT)	// Starting Date

	// Find Payment Due Date following STRT date
	type public Number CID
	
	type Date PDD
	
	type ResultSet rs
	if 'STRT.isNull() set rs=Db.select("PDD", "LNPS1", "CID = :CID and PDD > :STRT","PDD")
	else  set rs=Db.select("PDD", "LNPS1", "CID = :CID","PDD")

	if rs.isEmpty() quit ""

	if rs.next() set PDD = rs.getCol(1) 

	quit PDD
	

LST(Date STRT)	// Starting Date	

	// Find Payment Due Date previous to STRT date
	type public Number CID
	
	type Date PDD
	
	type ResultSet rs
	if 'STRT.isNull() set rs = Db.select("PDD", "LNPS1", "CID = :CID and PDD < :STRT", "PDD DESC")
	else  set rs = Db.select("PDD", "LNPS1", "CID = :CID", "PDD DESC")

	if rs.isEmpty() quit ""

	if rs.next() set PDD = rs.getCol(1)

	quit PDD
	

REC(Date DATE,		// Payment Due Date
    Number PTR)		// Distribution Number

	// Returns payment schedule record
	type public Number CID

	type RecordLNPS1 lnps1 = Db.getRecord("LNPS1", "CID = :CID, PDD = :DATE",1) 

	if 'lnps1.getMode() quit ""

	if PTR = 1 quit lnps1.d2f
	if PTR = 2 quit lnps1.d3f
	if PTR = 3 quit lnps1.d4f

	quit 0


TBL	
	/*
	   Entry point from routine DBSCRT to set up lookup table syntax for
	   FREQUENCY data type
	*/
	type public String vINFO(), vREF
	
	if $E(X)="/" do { quit
		set vREF="[UTBLNBD]"
		set X=""
		} 

	// User-Defined Frequencies
	set vINFO("HDG")=$$^MSG("5241")

	set vREF="[USRFRE]"
	
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60813^56312^Irina Kin^29863"	// Signature - LTD^TIME^USER^SIZE
