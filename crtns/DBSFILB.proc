DBSFILB	/* Utility to generate DATA-QWIK filer code
	Copyright(c)2003 Sanchez Computer Associates, Inc.  All Rights Reserved - 10/01/03 13:40:04 - GIRIDHARANB

	ORIG: FSANCHEZ - 11/11/2003
	DESC: Filer code generator

	---- Comments --------------------------------------------------------

	This routine is a rewrite of the pre-existing DATA-QWIK filer DBSFILB
	converted to PSL and with numerous performance optimizations.

	---- Revision History ------------------------------------------------
	
	08/17/06 - RussellDS - CRs: 22719 /20613
		   Modify handling of call to initPar^UCUTILN in generated code
		   to provide input parameter that indicates parameters are
		   already normalized and no call is needed.
		   
		   Remove check for %O="" from generated code since all code
		   now generated by PSL will ensure that vobj(,-2) is set.
		   
		   Remove all skip warning code.  Allow this to all be handled
		   at this point by UCOPTS.
		   
		   Replace references to OBJGBL^UCUTIL with getGbl^UCXDD.
		   
		   Modified code generated to call VOBJ^DBSDBASE to handle
		   new parameters.
		   
		   Correct format of vlist for passing to EXECUTE^%DBAPI and
		   checking of return value.
		   
		   Modified code generated for vlegacy section to fix problem
		   when %ProcessMode = 0 not creating indexes.
	
	06/15/06 - RussellDS - CR21912
		   Modify generation of M database save code to use new PSL
		   getSaveCode method to correct problems with saving of
		   memo/blob fields and clean up code.
		   
		   Modify code to generate cascade delete for RDB since cannot
		   just depend on RDB cascade delete logic because there may be
		   delete related triggers that need to be fired.
		   	
		   Added coding to deal with negative node subscripts, like in
		   table DBTBL2.
		   
		   Removed old revision history.
		   
	05/19/06 - RussellDS - CR21340
		   Modified vdelete section to honor filer parameters.
	
	05/17/06 - RussellDS - CR21382
		   Modify to recognize /NOLOG qualifier to avoid calls to
		   ^DBSLOGIT.
	
	05/11/06 - RussellDS - CR21235
		   Error in syntax for VCASDEL comment that made remapping
		   not work.
	
	05/05/06 - RussellDS - CR21137
		   Correct error in remapping logic for VIDXPGM tag.  Was not
		   getting built if not remapped.
	
	04/06/06 - RussellDS - CR20602
		   Set skipwarn in BUILDALL section to avoid undefined.  Extend
		   skipwarn comment.
		   
		   Modify remapping logic to avoid issues when line is not
		   tracked correctly since all code is not added to SOURCE.
		   
		   Add CR to generated ACCEPT statements.
	
	02/25/06 - RussellDS - CR19065
		   Modify COMPILE section to return PGM.
	
	02/22/06 - RussellDS - CR19723
		   Modified generated code to update to always call vregu.
		   Previously was using vreqn section, but change in logic
		   will now only check required fields on update if they
		   have been modified.
	
	02/15/06 - RussellDS - CR19556
		   Use SchemaColumn instead of DBTBL1D references.
	
	01/12/06 - RussellDS - CR18994
		   Add call to AUDIT^UCUTILN for %O = 0 mode since need the
		   information to pass to ^DBSLOGIT.  Use vxins array instead
		   vx to avoid issues with checks on vx.
	
	12/13/05 - RussellDS - CR18400
		   Fixed logic in SYSMAPLB section.
		   
		   Fixed casting issue.
		   
		   Eliminate call to PSL^SQLFILER and replace with direct
		   call to ^DBSLOGIT.
	
	11/17/05 - RussellDS - CR18065
		   Fix deprecated features warnings.
		   
		   Added new parameter, commands, to COMPILE, COPY, and
		   SPLITROU sections.
		   
	10/26/05 - RussellDS - CR17834
		   Removed use of ER and throwing of error for generated code
		   related to call to VDDUX^DBSFILER.  VDDUX^DBSFILER has been
		   converted to PSL and will now throw the error if necessary..
		   
		   Replaced .tr with .translate.
	
	10/05/05 - Pete Chenard - 
		   Modified to initialize vER=0 prior to call to VOBJ^DBSDBASE
		   in generated code.  Some cases there is no sql() array returned
		   form DBSDBASE, which caused an undefined error on vER.
		   
	07/19/05 - RussellDS - CR16614
		   Modified call to initPar^UCUTILN pass vpar by value, not
		   by reference.
		   
		   Included FRMFILER as valid parameter.
		   
	06/27/05 - RussellDS - CR16442
		   Corrected reference to vEr after call to EXECUTE^%DBAPI.
	
	06/13/05 - RussellDS - CR16282
		   Add codding for generated vload section to force loading of
		   entire record for incrementally loaded tables.
		   
		   Modified code to set up key change logic to include it for
		   RDBs as well.
		   
		   Modified to avoid trying to load nodes identified from -100
		   that are keys.
	
	06/09/05 - RussellDS - CR15379
		   Add new function vLITCHK to generated code.
		   
		   Add code in CONTROL section for generated code control
		   blocks to call SET^UCLREGEN.
		   
		   Replace call to main^UCGM with call to cmpA2F^UCGM to
		   standardize the interface.
		   		   
		   Added SYSMAPLB to return label name for use by UCSYSMAP.
		   
	06/09/05 - RussellDS - CR16206
		   Modified handling of blob/memo fields in MAIN section to
		   use new PSL column class to get internal reference.
		   
		   Modified vdelete generation for RBDs to assign variables
		   with key values before call to EXECUTE^%DBAPI.
		   
		   Made COMPILE label public.
	*/
	
	//I18N=OFF

	quit

	
COPY(	String from(),	 	// Append from array
	String to(),		// Append to array
	Number rtnCnt,		// Routine number
	String remap(),		// Remap tag array
	String commands(,),	// PSL commands array
	String PGMS)		// Generated program name(s)	/MECH=REFNAM:W
	
	/*
	Append from() to to()
	*/
	
	if from("").order().isNull() quit		// Nothing to append

	type public String PSFILE

	type Number n = ""
	type Number line = to("").order(-1)

	// If copy produces more than 2000 lines of output, split program
 	if rtnCnt.exists(),line+from("").order(-1)>2000 do SPLITROU(PSFILE, .from(), .rtnCnt, .remap(), .commands(,),.PGMS)

	set line = line+1,to(line) = "",line = line+1
	for  set n = from(n).order() quit:n.isNull()  set to(line) = from(n),line = line+1
	quit
	
	
BUILDALL	 // Build All Run-Time Filer Routines
  
	type ResultSet rs = Db.select("FID","DBTBL1","UDFILE IS NOT NULL")
	while rs.next() do COMPILE(rs.getCol("FID"))
	quit


BUILD	 // Build Run-Time Filer Routine

	type Number COUNT
	type String fid, RM
	
	set COUNT = $$LIST^DBSGETID("DBTBL1")			// Interactive select
	quit:'COUNT
	
	type ResultSet tmpdqrs=Db.select("ELEMENT","TMPDQ","PID=:%ProcessID")
	
	while tmpdqrs.next() do {
        	
        	set fid=tmpdqrs.getCol("ELEMENT")
	
		type SchemaTable tblrec = Db.getSchemaTable(fid)
		
		// Error message only if selected a single table
		if tblrec.filerPGM.isNull() do { quit
			if COUNT=1 set RM = $$^MSG(3056,fid) write !,$$MSG^%TRMVT(RM)
		}
		
		do COMPILE(fid)
	}
	
	do Db.delete("TMPDQ", "PID=:%ProcessID")

	quit


public COMPILE(String PSFILE,	 	// Table name
	       Boolean NLU,		// No longer used [*]
	       String commands(,),	// PSL commands array		/NOREQ/MECH=REFARR:R
	       String PGMS)		// Generated program name(s)	/NOREQ/MECH=REFNAM:W
	       
	/*
	Compile code
	
	ARGUMENT NOTES:
	
		. NLU		Parameter retained for backward compatibility
	*/
	
	catch ERROR {
		
		type Number ER=0
		type Number %ZTDY=0	// Scrolled display of error
		type Boolean %ZTHANG=0	// Don't wait for <CR> request
		
		write ?10," *** Compile error - see following error log entry",!
		
		do ZE^UTLERR
		
		write !
	}

	if 'Db.isDefined("DBTBL1","%LIBS='SYSDEV',FID=:PSFILE") write " Aborted - Table does not exist: ",PSFILE quit
	write !,PSFILE

	type public Number ER = 0
	type public String RM

	type String %LIBS = "SYSDEV"
	type String cmperr
	
	type Boolean hasLits, hasNegNd, vreqsec

	type Number i,del,n,sourceH
	type Number rtnCnt = 0

	type String code,delstr,di,gbl,key,keys,keywhr,lvn,partbl,rectyp,tag,z
	type String casdel(),ctl(),dft(),jrn(),keytrgs(),remap(),sections(),vddver(),vkchg(),vreq(),vsts(),vtrg(),zfkys(),zindx()
	type String SOURCE()

	type String file = PSFILE
	type SchemaTable tblrec = Db.getSchemaTable(file)

	type String INDEXPGM = tblrec.filerPGM
	if INDEXPGM.isNull() write " Aborted - filer program is NULL" quit
	
	set PGMS = INDEXPGM

	type Boolean isRDB = $$rdb^UCDB(file)

	type String objName = file.translate("_").lowerCase()
	
	type ResultSet rs = Db.select("DISTINCT TABLE", "SYSMAPLITDTA", "TABLE=:file")
	if rs.isEmpty() set hasLits = 0
	else  set hasLits = 1

	do ADDSRC(INDEXPGM_"(Record"_file_" "_objName_", String vpar, Boolean vparNorm) // "_file_" - "_tblrec.description_" Filer")
	do ^SCACOPYR(.z)
	do ADDSRC(" // "_z.piece(";;",2,z.length()))
	do ADDSRC(" // Generated from DATA-QWIK schema in: "_$$CURR^%DIR_"  by: "_$$PGMDIR($T(+0)))
	do ADDSRC("")

	set sourceH = SOURCE("").order(-1)		// Mark location
	
	/* Note FRMFILER is only used when trigger code in one filer needs to signal to
	   another filer, where that filer will base what it does on the flag.  It is
	   not set automatically, but is available for use by developers.
	*/	

	do ADDSRC(" /*")
	do ADDSRC("  vpar      Runtime qualifiers:      /NOREQ/MECH=REFARR:R")
	do ADDSRC("")
	do ADDSRC("  /[NO]CASDEL   - Cascade delete")
	do ADDSRC("  /[NO]FRMFILER - Called from another filer")
	do ADDSRC("  /[NO]INDEX    - Update Indexes")
	do ADDSRC("  /[NO]JOURNAL  - Journal update")
	do ADDSRC("  /[NO]TRIGAFT  - After update triggers")
	do ADDSRC("  /[NO]TRIGBEF  - Before update triggers")
	do ADDSRC("  /[NO]UPDATE   - Update primary table")
	do ADDSRC("  /[NO]VALDD    - Validate column values")
	do ADDSRC("  /[NO]VALFK    - Validate foreign keys")
	do ADDSRC("  /[NO]VALREQ   - Validate not null values")
	do ADDSRC("  /[NO]VALRI    - Validate transaction integrity")
	do ADDSRC("  /[NO]VALST    - Validate database state")
	do ADDSRC(" */")
	do ADDSRC("")
	
	#IF %VersionID<7
	// P01 still depends on ER and RM from the filers
	do ADDSRC(" type Public Number ER = 0")
	do ADDSRC(" type Public String RM")
	do ADDSRC("")
	#ENDIF
	
	do ADDSRC(" type public String verrors()")
	do ADDSRC("")
	
	#IF %VersionID<7
	// Add catch block for P01 error handling of DBFILER errors - rethrow GT.M errors
	do ADDSRC(" catch fERROR {")
	do ADDSRC("  if fERROR.type=""%PSL-E-DBFILER"" do {")
	do ADDSRC("   set ER = 1")
	do ADDSRC("   set RM = fERROR.description")
	do ADDSRC("  }")
	do ADDSRC("  else  throw fERROR")
	do ADDSRC(" }")
	#ENDIF
	
	set gbl = tblrec.global
	set keys = tblrec.primaryKeys
	set rectyp = tblrec.recordType
	set del = tblrec.columnDelimiter
	
	// If table has negative nodes (like DBTBL2), need to remap "v" node
	// when going between vobj and global
	if tblrec.nodeQuotedList.isLike("%""v%") set hasNegNd = 1
	else  set hasNegNd = 0

	if 'del.isNull() do {
	
		if (del < 32) ! (del > 127) set delstr = "$C("_del_")"
		else  set delstr = del.char().addQuotes()
	}
	
	if isRDB set rectyp=$$RDBRCTYP(file)

	set gbl = $$getGbl^UCXDD(tblrec,objName)
	if gbl.endsWith(",") set gbl = gbl.extract(1, gbl.length() - 1)
	set keywhr = $$KEYWHR(file,keys,objName,isRDB,0)

	// Find the parent table of this table to support Db.isDefined() method
	// properly.  This should be fixed in isDefined itself.
	set partbl = $$PARTBL(file,tblrec)		// Top of hierarchy

	do ADDSRC(" type String vx(), vxins()","audit column array")
	do ADDSRC(" type Number %O = "_objName_".getMode()","Processing mode")
	do ADDSRC(" set vpar = vpar.get()", "Initialize vpar")

	/* Need to call AUDIT^UCUTILN even in insert mode to make sure that vobj
	   -100 level is updated correctly.  Use different vx array for insert vs.
	   update so that can pass to DBSLOGIT, but don't mess with other vx
	   checking that is related only to update mode.
	*/
	do ADDSRC(" if %O = 0 do AUDIT^UCUTILN("_objName_",.vxins(),"_rectyp_","_delstr_")")
	set z = " if %O = 1"
	if rectyp>1 set z = z_" quit:'"_objName_".isChanged() "
	set z = z_" do AUDIT^UCUTILN("_objName_",.vx(),"_rectyp_","_delstr_")"
	do ADDSRC(z)
	do ADDSRC("")
	
	// Index code
	if 'isRDB  do {	quit:ER					// Skip for RDB
		type ResultSet rs = Db.select("FID","DBTBL8","FID = :file")
		if 'rs.isEmpty() do ^DBSINDXB(file,.zindx())	 // Index file logic
	}

	do DEFTBL^DBSTRG(PSFILE,.dft(),tblrec)			// Default logic
	if dft set sections("vinit")=""
	
	if 'isRDB do {
		do REQUIRD^DBSTRG(PSFILE,.vreq(),tblrec)	// Required logic (if GT.M)
		if 'vreq("").order().isNull() set sections("vreq")=""
	}
	
	do VDD^DBSTRG(PSFILE,.vddver(),tblrec,isRDB) quit:ER	// Validate data types
	if 'vddver("").order().isNull() set sections("vddver")=""

	do ^DBSJRNC(file,.jrn())				// Journal file logic
	if ER write " Aborted - journal error - ",RM,! quit

	// Trigger definitions
	do COMPILE^DBSTRG(file,.vtrg(),.vsts(),.keytrgs(),isRDB,tblrec)

	if 'isRDB do FKEYS^DBSTRG(file,.zfkys(),tblrec)		// Foreign key logic	
	
	do CASDEL^DBSTRG(file,.casdel(),tblrec)			// Cascade delete logic

	// Add statistical documentation
	do ADDDOC(.vddver,"1D"),ADDDOC(.vtrg,7),ADDDOC(.zindx,8),ADDDOC(.jrn,9)

	do ADDSRC(" if 'vparNorm.get() set vpar = $$initPar^UCUTILN(vpar)","Run-time qualifiers")

	// Define access keys as local variables to support legacy	
	if 'keys.isNull(),'vsts("").order().isNull() do {
	
		do ADDSRC("")
		do ADDSRC(" // Define local variables for access keys for legacy triggers")
		for i = 1:1:keys.length(",") do {

			type String di = keys.piece(",",i)
			type String var = di.translate("_").upperCase()

			do ADDSRC(" type String "_var_" = "_objName_"."_di.lowerCase())
		}
	}

	do ADDSRC("")

	type Number savLine = SOURCE("").order(-1)
	set SOURCE(savLine+100) = ""			// Save 100 lines for control block
	do ADDSRC(" quit")
	
	/* Code to support legacy calls from ^DBSFILER for integrity checks and ^DBSDF9
	   to rebuild DQ control filers -- note that this can be removed once no longer
	   needed by legacy code.  These are the only callers expected.  Do not add
	   any others without a careful review of this code.  Note that DBSDF9 in P04
	   and beyond no longer calls vlegacy.
	*/
	do {
		type String keylist = ""
		
		do TAG("vlegacy(Number %ProcessMode,String vpar) // Legacy interface (^DBSDF9 for %O=0, EXT^DBSFILER for %O = 2)")

		// Define keys -- they will be public
		if 'keys.isNull() do {
			for i = 1:1:keys.length(",") do {
				type String di = keys.piece(",",i)
				type String var = di.translate("_").upperCase()
				do ADDSRC(" type public String "_var)
				set keylist=keylist_var_"=:"_var_","
			}
		}
		
		set keylist=keylist.extract(1,keylist.length()-1)
		do ADDSRC("")
		do ADDSRC(" type Record"_file_" "_objName_" = Db.getRecord("""_file_""","""_keylist_""")")
		do ADDSRC(" if (%ProcessMode = 2) do {")
		do ADDSRC("  do "_objName_".setMode(2)")
		do ADDSRC("")
		do ADDSRC("  do "_INDEXPGM_"("_objName_",vpar)")
		do ADDSRC(" }")
		if 'zindx("").order().isNull() do ADDSRC(" else  do VINDEX("_objName_")")
		do ADDSRC("")
		do ADDSRC(" quit")
	}
	
	// Add function to return indicator if table involved in literals or not
	if hasLits do {
		do TAG("vLITCHK() quit 1 // Table has columns involved in literals")
	}
	else  do TAG("vLITCHK() quit 0 // Table does not have columns involved in literals")

	do TAG("vexec // Execute transaction")

	do ADDSRC(" type public Number %O")
	do ADDSRC(" type public String vpar,vobj(),vx(),vxins()")
	do ADDSRC("")
	do ADDSRC(" type public Record"_file_" "_objName)
	do ADDSRC("")
	do ADDSRC(" type String vERRMSG")
	do ADDSRC("")
	
	// 7932 = Record Not Defined; 2327 = Record already exists
	do ADDSRC(" if vpar[""/VALST/"" if '(''Db.isDefined("""_partbl_""","""_keywhr_""") = ''%O) set vERRMSG = $$^MSG($select(%O:7932,1:2327)) throw Class.new(""Error"",""%PSL-E-DBSFILER,""_vERRMSG.replace("","",""~""))")

	if 'zfkys("").order().isNull() do {
		do ADDSRC(" if vpar[""/VALFK/"" do CHKFKS","Check foreign keys")
		do ADDSRC(" if vpar[""/VALRI/"" do VFKEYS","Foreign key definition")
	}
	
	do ADDSRC("")
	do ADDSRC(" if vpar'[""/NOUPDATE/"" do {")
	
	do MAIN(file,tblrec)	// Build main update code

	if 'jrn("").order().isNull() do {
		type Number saveline
		do ADDSRC("")
		do ADDSRC("  if vpar[""/JOURNAL/"" do VJOURNAL(."_objName_")","Create journal files",.saveline)
		if 'remap("VJOURNAL").exists() set remap("VJOURNAL")=""
	}
	
	do ADDSRC(" }")
	
	// Always update index if requested, regardless of state of UPDATE flag
	if 'zindx("").order().isNull() do {
		type Number saveline
		do ADDSRC("")
		do ADDSRC(" if vpar[""/INDEX/"",'(%O = 1)!'vx("""").order().isNull() do VINDEX(."_objName_")","Update Index files",.saveline)
		if 'remap("VINDEX").exists() set remap("VINDEX")=""
	}
	
	do ADDSRC("")
	do ADDSRC(" quit")
	
	// Add procedures to load complete record and create -100 index

	if rectyp>1 do {
		
		/* Need to ensure all data is loaded, so force incremental loading
		   of any remaining data.  Do this directly with globals.  For RDB
		   generate code to load a column from each split table.
		*/
		
		do TAG("vload // Record Load - force loading of unloaded data")
		do ADDSRC(" type public Record"_file_" "_objName)
		
		if 'isRDB do {
			type String code, gblref
	
			if gbl.extract(gbl.length())="(" set gblref=gbl_"n)"	// CUVAR style
			else  set gblref=gbl_",n)"
			
			do ADDSRC(" type String n = """"")
			if hasNegNd do ADDSRC(" type String vn")
			do ADDSRC("")
			do ADDSRC(" // Allow global reference")
			do ADDSRC(" #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602")
			set code = " for  set n = $order("_gblref_") quit:n.isNull()  "
			if hasNegNd set code = code_"s vn=$S(n<0:""v""_-n,1:n) if 'vobj("_objName_",vn).data(),"_gblref_".data()#2 set vobj("_objName_",vn) = ^(n)"
			else  set code = code_"if 'vobj("_objName_",n).data(),"_gblref_".data()#2 set vobj("_objName_",n) = ^(n)"
			do ADDSRC(code)
			do ADDSRC(" quit")
		}
		
		else  do {
			
			do ADDSRC(" type String X")
			do ADDSRC("")
			
			type ResultSet rs = Db.select("DISTINCT RTBL", "DBMAP", "DB=:%DB AND TBL=:file", "RTBL ASC")
			while rs.next() do {
				type String rtbl = rs.getCol("RTBL")
				
				type ResultSet rs2 = Db.select("COL", "DBMAP", "DB=:%DB AND TBL=:file AND RTBL=:rtbl")
				
				if rs2.next() do {
					
					type String column = rs2.getCol("COL")
					
					do ADDSRC(" set X = "_objName_"."_column)
				}
			}
			
			do ADDSRC(" quit")
		}
	}

	do TAG("vdelete(Boolean vkeychg) // Record Delete")
	do ADDSRC(" type public String vobj(),vpar")
	if isRDB do ADDSRC(" type String vlist")
	do ADDSRC(" type public Record"_file_" "_objName)
	do ADDSRC("")
		
	if isRDB do {
		do ADDSRC(" type Boolean vER")
		do ADDSRC(" type String vRM")
		if 'keys.isNull() do {
			type Number i
			type String code = ""
			for i = 1:1:keys.length(",") set code = code_"vkey"_i_","
			set code = " type String "_code.extract(1, code.length() - 1)
			do ADDSRC(code)
		}
	}
	
	if rectyp>1 do {
		do ADDSRC(" if 'vkeychg.get(),"_objName_".isChanged() throw Class.new(""Error"",""%PSL-E-DBFILER,Deleted object cannot be modified"")")
		do ADDSRC("")
	}

	#IF CUVAR.PUBLISH
	if 'tblrec.publishPGM.isNull() do ADDSRC(" if '(%SVCHNID.get() = 5) do "_tblrec.publishPGM)
	#END

	if 'casdel("").order().isNull() do {
		type Number saveline
		do ADDSRC(" if vpar[""/CASDEL/"" do VCASDEL","Cascade delete",.saveline)
		if 'remap("VCASDEL").exists() set remap("VCASDEL")=""
	}
	if 'zindx("").order().isNull() do {
		type Number saveline
		do ADDSRC(" if vpar[""/INDEX/"" do VINDEX(."_objName_")","Delete index entries",.saveline)
		if 'remap("VINDEX").exists() set remap("VINDEX")=""
	}
	if 'jrn("").order().isNull() do {
		type Number saveline
		do ADDSRC(" if vpar[""/JOURNAL/"" do VJOURNAL(."_objName_")","Create journal entries",.saveline)
		if 'remap("VJOURNAL").exists() set remap("VJOURNAL")=""
	}
	if tblrec.isAutoLog do ADDSRC(" if vpar'[""/NOLOG/"" do ^DBSLOGIT("_objName_",3)")

	if 'isRDB do {

		set z=" kill " 
		if rectyp<10,'(tblrec.hasMemo!tblrec.hasBlob) set z = " ZWI "
		if 'tblrec.primaryKeys.isNull() do {
			do ADDSRC("")
			do ADDSRC(" // Allow global reference")
			do ADDSRC(" #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602")
			do ADDSRC(z_gbl_")","Delete Record")
		}
	}

	else  do { quit:ER

		type Number cnt
		type String sql()
		
		if keys.isNull() do {
			do ADDSRC(" set vlist=""""")
		}
		else  do {
			type String code = ""
			for i = 1:1:keys.length(",") do {
				
				type Boolean isNum = 0
				type String di = keys.piece(",",i)
				
				type SchemaColumn rec = Db.getSchemaColumn(file, di)
				
				if 'rec.dataType.isNull(),"N$L"[rec.dataType set isNum = 1
				
				if 'code.isNull() set code=code_"_"_delstr_"_"
				set code=code_objName_"."_di.lowerCase()
				do ADDSRC(" set vkey"_i_"="_objName_"."_di.lowerCase())
			}

			do ADDSRC(" set vlist="_code_"_"_delstr)
		}
		
		if keywhr.isNull() set sql(1) = "DELETE FROM "_file
		else  if 'isRDB set sql(1) = "DELETE FROM "_file_" WHERE "_keywhr
		else  do { quit:ER
			
			type String keywhrn, nattable
			
			set keywhrn = $$KEYWHR(file, keys, "", 1, 1, .nattable)
			
			// Handle wide tables (one table split into multiple)
			for cnt = 1:1:nattable.length(",") set sql(cnt) = "DELETE FROM "_nattable.piece(",", cnt)_" WHERE "_keywhrn
		}
		
		set cnt = ""
		for  set cnt = sql(cnt).order() quit:cnt.isNull()  do {
			do ADDSRC(" set vER = $$EXECUTE^%DBAPI("""","_sql(cnt).addQuotes()_","_delstr_",vlist,.vRM)")
			do ADDSRC(" if (vER<0) throw Class.new(""Error"",""%PSL-E-DBFILER,""_vRM.get().replace("","",""~""))")
		}
	}

	do ADDSRC(" quit")
	

	if dft do COPY(.dft(), .SOURCE(), , , .PGMS)	// Default section
	do COPY(.vreq(), .SOURCE(), , , .PGMS)		// Required items
	do COPY(.zfkys(),.SOURCE(), , , .PGMS)		// Foreign key definition
	
	type String zrtnCnt = rtnCnt			// Save value of rtncnt
	do COPY(.vtrg(), .SOURCE(), .rtnCnt, .remap(), .commands(,), .PGMS)	// Trigger definition

	if '(rtnCnt = zrtnCnt) do {			// Trigger routine changed
		type Number n = ""
		type String routine = tblrec.filerPGM
		set routine = routine.extract(1,routine.length()-1)_(rtnCnt-1)
		set keytrgs = routine
		for  set n = vsts(n).order() quit:n.isNull()  do {
			set z = vsts(n)_"^"_routine
			set vsts(n) = z
			}
		}

	do COPY(.vddver(), .SOURCE(), .rtnCnt, .remap(), .commands(,), .PGMS)	// Column validation
	do COPY(.jrn(), .SOURCE(), .rtnCnt, .remap(), .commands(,), .PGMS)		// Journal definitions	
	do COPY(.zindx(), .SOURCE(), .rtnCnt, .remap(), .commands(,), .PGMS)	// Index definitions

	/*
	The key change logic code must be generated after the trigger code is copied,
	because the before update and after update triggers are called by the key
	change logic and the proper address is needed.
	*/

	set vreqsec = sections("vreq").exists()
	// Key changed logic
	do KEYCHG^DBSTRG(file,.vkchg(),tblrec,.vsts(),.keytrgs(),vreqsec,.sections(),.remap(),rectyp,isRDB)

	do COPY(.vkchg(), .SOURCE(), , , .PGMS)

	/*
	The casade delete is not skipped on a relational database. although 
	the "on cascade delete" clause on the foreign key definition at 
	schema creation time will manage it.  That does not, however deal
	with triggers or journals that may be set up for the child table.
	The Db.delete method includes optimizations that will avoid calls
	to the filers if not necessary.
	*/

	if 'casdel("").order().isNull() do {

		set casdel(.1) = "VCASDEL // Cascade delete logic"
		set casdel(.2) = ""
		set casdel(casdel("").order(-1)+1) = $C(9)_"quit"
		do COPY(.casdel, .SOURCE, .rtnCnt, .remap(), .commands(,), .PGMS)
	}

	// Generate & insert control blocks
	do CONTROL(file,.ctl(),.sections(),.vsts(),tblrec,isRDB,.remap(),partbl,keywhr,hasLits)

	set n = ""
	for  set n = ctl(n).order() quit:n.isNull()  set savLine = savLine+1,SOURCE(savLine) = ctl(n)
	
	// Remap calls for split routines, if any exist
	if (rtnCnt > 0) do {
		
		set n = ""
		for  set n = SOURCE(n).order() quit:n.isNull()  if SOURCE(n).isLike("%do %") do {
			
			set tag = ""
			for  set tag = remap(tag).order() quit:tag.isNull()  do {
				
				type String rtn = remap(tag).get()
				
				if 'rtn.isNull(), 'SOURCE(n).isLike("%do "_tag_"^%") set SOURCE(n) = SOURCE(n).replace("do "_tag,"do "_tag_"^"_rtn)
			}
		}
	}
	
	// Add remapping of VIDXBLD section, if necessary.  VIDXBLD is called
	// by DBSINDXZ to rebuild indexes
	if 'remap("VINDEX").get().isNull() do {
		do TAG("VIDXBLD(vlist)"_$C(9)_"do VIDXBLD^"_remap("VINDEX")_"(vlist.get())"_$C(9)_"// Remapped")
		do ADDSRC(" quit")
		do ADDSRC("")
		do TAG("VIDXPGM()"_$C(9)_"quit """_remap("VINDEX")_""""_$C(9)_"// Location of index program")
	}
	
	// If not remapped, but indexes, still need to add VIDXPGM function
	else  if 'zindx("").order().isNull() do TAG("VIDXPGM()"_$C(9)_"quit """_INDEXPGM_""""_$C(9)_"// Location of index program")

	// Call PSL compiler
	do cmpA2F^UCGM(.SOURCE,INDEXPGM,,,.commands(,),,.cmperr,file_"~Filer")

	if +cmperr.get() set ER = 1
	
	quit


CONTROL(String fid,	// Return procedural code to process required data items
	String code(),
	String sections(),
	String vsts(),
	SchemaTable tblrec,
	Boolean isRDB,
	String remap(),
	String partbl,
	String keywhr,
	Boolean hasLits) 

	type Boolean vreqsec = sections("vreq").exists()
	type Number saveline
	type String keys = tblrec.primaryKeys

	// Insert program control logic into saved position for all %O
	
	do ADD(" if %O = 0 do { quit","Create record control block")
	if sections("vinit").exists() do ADD("  do vinit","Initialize column values")
	if vsts("BI").exists() do ADD("  if vpar[""/TRIGBEF/"" do "_vsts("BI"),"Before insert triggers")
	if 'isRDB,vreqsec do ADD("  if vpar[""/VALREQ/"" do vreqn","Check required")
	if sections("vddver").exists() do {
		do ADD("  if vpar[""/VALDD/"" do vddver","Check values",.saveline)
		if 'remap("vddver").exists() set remap("vddver")=""
	}
	do ADD("  do vexec")
	if vsts("AI").exists() do ADD("  if vpar[""/TRIGAFT/"" do "_vsts("AI"),"After insert triggers")
	if hasLits do ADD("  do SET^UCLREGEN("""_fid_""",""*"")", "Literal references to "_fid_" exist")
	do ADD(" }")
	do ADD("")

	do ADD(" if %O = 1 do { quit","Update record control block")

	// Check for key change, add call to key change logic
	if 'keys.isNull() do {

		type Number i
		type String z
		
		set z = "  if vx("_keys.piece(",",1).addQuotes()_").exists()"
		for i = 2:1:keys.length(",") set z = z_"!vx("_keys.piece(",",i).addQuotes()_").exists()"
		set z = z_" do vkchged quit"

		do ADD(z,"Primary key changed")
	}

	if vsts("BU").exists() do ADD("  if vpar[""/TRIGBEF/"" do "_vsts("BU"),"Before update triggers")
	if 'isRDB,vreqsec do ADD("  if vpar[""/VALREQ/"" do vrequ", "Check required")
		
	do ADD("  if vpar[""/VALDD/"" do VDDUX^DBSFILER("""_fid_""",.vx)")
	do ADD("  set %O = 1 do vexec")
	if vsts("AU").exists() do ADD("  if vpar[""/TRIGAFT/"" do "_vsts("AU"),"After update triggers")
	
	/* Note that checking of SYSMAPLITDTA is done at run-time to simplify overall processing.
	   No need to make sure that if literal is used that the code already exists in the filer
	   to check it, since just need to make sure the filer has the runtime code to check any
	   literals for this table.  This shouldn't be a performance issue since tables that are
	   used with literals have low change rates.  If it turns out to be a problem, could change
	   logic to generate column specific checking. 
	*/
	if hasLits do {
		do ADD("  do {", "Check to see if updated columns involved in literal references")
		do ADD("   type String vcol, vlitcols()")
		do ADD("")
		do ADD("   type ResultSet rslits = Db.select(""DISTINCT COLUMN"", ""SYSMAPLITDTA"", ""TABLE='"_fid_"'"")")
		do ADD("   while rslits.next()  set vlitcols(rslits.getCol(""COLUMN"")) = """"")
		do ADD("")
		do ADD("   set vcol = """"")
		do ADD("   for  set vcol = vlitcols(vcol).order() quit:vcol.isNull()  if vx(vcol).exists() do SET^UCLREGEN("""_fid_""",vcol)")
		do ADD("  }")
	}
	do ADD(" }")
	do ADD("")

	do ADD(" if %O = 2 do { quit","Verify record control block")
	if 'isRDB,vreqsec do ADD("  if vpar[""/VALREQ/"" do vreqn","Check required")
	if sections("vddver").exists() do {
		
		do ADD("  if vpar[""/VALDD/"" do vddver","Check values",.saveline)
		if 'remap("vddver").exists() set remap("vddver")=""
	}
	do ADD("  set vpar = $$setPar^UCUTILN(vpar,""NOJOURNAL/NOUPDATE"")")
	do ADD("  do vexec")
	if vsts("AI").exists() do ADD("  if vpar[""/TRIGAFT/"" do "_vsts("AI"),"After insert triggers")
	do ADD(" }")
	do ADD("")
	
	do ADD(" if %O = 3 do { quit","Delete record control block")
	do ADD("  quit:'Db.isDefined("""_partbl_""","""_keywhr_""")","No record exists")
	if vsts("BD").exists() do ADD("  if vpar[""/TRIGBEF/"" do "_vsts("BD"),"Before delete triggers")
	do ADD("  do vdelete(0)")
	if vsts("AD").exists() do ADD("  if vpar[""/TRIGAFT/"" do "_vsts("AD"),"After delete triggers")
	if hasLits do ADD("  do SET^UCLREGEN("""_fid_""",""*"")", "Literal references to "_fid_" exist")
	do ADD(" }")

	quit


SPLITROU(String file,		// Table name
	 String src(),		// Source code
	 Number rtnCnt,		// Routine number
	 String remap(),	// Remap tags array
	 String commands(,),	// PSL commands array
	 String PGMS)		// Generated program name(s)	/MECH=REFNAM:W
	 
	/*
	Split code into different routine
	*/

	type public Number ER

	type Number i, n
	type String z
	
	type SchemaTable tblrec = Db.getSchemaTable(file) if ER quit

	type String routine = tblrec.filerPGM
	set routine = routine.extract(1,routine.length()-1)_rtnCnt
	set rtnCnt = rtnCnt+1
	
	// Remap vload
	set n = ""
	for  set n = src(n).order() quit:n.isNull()  if src(n).isLike("%do vload%") set src(n) = src(n).replace("do vload", "do vload^"_tblrec.filerPGM)

	type String comment = "//"

	// Find the original linetag
	set n = ""
	for  set n = src(n).order() quit:n.isNull()  if src(n).extract(1)?1AN quit

	if 'n.isNull() do {
	
		type String subrou
		set subrou = src(n).translate($C(9)," ")
		if subrou.piece(" ", 1) = "public" set subrou = subrou.piece(" ", 2)
		if subrou.piece(" ", 1) = "private" set subrou = subrou.piece(" ", 2)
		set subrou = subrou.piece("(",1)
		if subrou.isLike("% //%") set subrou = subrou.piece(" //", 1)
		set remap(subrou)=routine
	}

	set src(.01) = routine_" "_comment_" "_file_" DATA-QWIK filer, part ("_(rtnCnt+1)_")"
	do ^SCACOPYR(.z)
	set src(.02) = " "_comment_" "_z.piece(";;",2,z.length())
	set src(.03) = ""
	set src(.04) = $C(9)_"quit"_$C(9,9)_"// Not called from top"
	set src(.05) = ""
	
	// Call PSL compiler
	do cmpA2F^UCGM(.src(),routine,,,.commands(,),,,file_"~Filer")
	
	set PGMS = PGMS_","_routine

	kill src

	quit	 


MAIN(	String file,	 // Build Main Filer Section
	SchemaTable tblrec)
	
	type public Number ER
	type public String PSFILE, RM

	type Boolean hasNegNd = tblrec.nodeQuotedList.isLike("%""v%")
	type String gblref, gblref1, gblref2, z
	type String keys = tblrec.primaryKeys
	type List MBNodes, NegNodes
	type Number rectyp = tblrec.recordType
	type Number del = tblrec.columnDelimiter

	type String objName = PSFILE.translate("_").lowerCase()
	type String gbl = $$getGbl^UCXDD(tblrec,objName)
	
	if tblrec.primaryKeys.isNull() do {	// CUVAR style
		
		if hasNegNd set gblref = gbl_"vn)"
		else  set gblref = gbl_"n)"
		set gblref1 = gbl.piece("(",1)
		set gblref2 = gbl
	}
	else  do {
		
		if hasNegNd set gblref = gbl_"vn)"
		else  set gblref = gbl_"n)"
		set gblref1 = gbl.extract(1, gbl.length() - 1)_")"
		set gblref2 = gbl
	}

	type String sn = "vobj("_objName_")"

	type Boolean isRDB = $$rdb^UCDB(PSFILE)
	type Boolean hasMB = (tblrec.hasMemo!tblrec.hasBlob)
	
	// Memos, blobs, and negative nodes have special handling
	set (MBNodes, NegNodes) = ""
	if hasMB do {
		
		type ResultSet rs = Db.select("DI","DBTBL1D","FID = :file and TYP ='B' or TYP = 'M'")

		while rs.next() set MBNodes = MBNodes.add(rs.getCol("DI"), , 0)
	}
	
	// Get list of negative nodes - only need one column per node
	if hasNegNd do {
		
		/* Note - need to use <'0' instead of LIKE '-%' since the M SQL optimizer
		   has problems with that.  Need '0' to avoid possible future problems on
		   the Oracle side since NOD is a text field.  Since this may also get
		   nodes that aren't negative, filter those.
		*/
		type ResultSet rs = Db.select("NOD,DI","DBTBL1D","FID = :file and NOD<'0'")

		while rs.next() do {
		
			if rs.getCol("NOD").beginsWith("-") do {
		
				type PSLColumn colrec = PSL.getPSLColumn(file, rs.getCol("DI"))
		
				set NegNodes = NegNodes.add(colrec.getCurrentNode(1), , 0)
			}
		}
	}
		
	type String sys = tblrec.systemName
	type String cdate = $$LOG(tblrec.dateCreated,sys,"D",objName)
	type String ctime = $$LOG(tblrec.timeCreated,sys,"T",objName)
	type String cuser = $$LOG(tblrec.userCreated,sys,"U",objName)
	type String udate = $$LOG(tblrec.dateUpdated,sys,"D",objName)
	type String utime = $$LOG(tblrec.timeUpdated,sys,"T",objName)
	type String uuser = $$LOG(tblrec.userUpdated,sys,"U",objName)
	
	do ADDSRC("")

	// If the same column us updates for new and update, promote logic
	if 'cdate.isNull(),cdate = udate do ADDSRC(" "_cdate) set (cdate,udate) = ""
	if 'ctime.isNull(),ctime = utime do ADDSRC(" "_ctime) set (ctime,utime) = ""
	if 'cuser.isNull(),cuser = uuser do ADDSRC(" "_cuser) set (cuser,uuser) = ""

	if 'cdate.isNull() do ADDSRC("  if %O = 0 "_cdate)
	if 'ctime.isNull() do ADDSRC("  if %O = 0 "_ctime)
	if 'cuser.isNull() do ADDSRC("  if %O = 0 "_cuser)
	if 'udate.isNull() do ADDSRC("  if %O = 1 "_udate)
	if 'utime.isNull() do ADDSRC("  if %O = 1 "_utime)
	if 'uuser.isNull() do ADDSRC("  if %O = 1 "_uuser)

	if tblrec.isAutoLog do {

		do ADDSRC("  if %O = 0, vpar'[""/NOLOG/"" do ^DBSLOGIT("_objName_",%O,.vxins())")
		do ADDSRC("  if %O = 1, vpar'[""/NOLOG/"" do ^DBSLOGIT("_objName_",%O,.vx())")
		do ADDSRC("")
	}

	if isRDB do { quit

		do ADDSRC("  type String del")
		do ADDSRC("  set del = "_del_".char()")
	 	do ADDSRC("  do VOBJ^DBSDBASE("_objName_",del)")

		#IF CUVAR.PUBLISH
		if 'tblrec.publishPGM.isNull() do ADDSRC("  if '(%SVCHNID.get() = 5)  do "_tblrec.publishPGM)
		#END

	}
	
	// ----- Remaining code is for M database updates ---------------------

	if rectyp>1 do {
		
		do ADDSRC("  type String n = -1")
		do ADDSRC("  type String x")
		if hasNegNd do ADDSRC("  type String vn")
 		do ADDSRC("")
 		
 		do MSAVE(0, tblrec, objName, MBNodes, NegNodes)
 		do MSAVE(1, tblrec, objName, MBNodes, NegNodes)

		
		// Top level for type 11
		if (rectyp = 11) do {
			
			do ADDSRC("  // Allow global reference and M source code")
			do ADDSRC("  #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
			do ADDSRC("  #BYPASS")
			do ADDSRC("  if $D(vobj("_objName_")) "_tblrec.getSaveCode(objName, "", -1))
			do ADDSRC("  #ENDBYPASS")
		}
	}

	if (rectyp = 1) do {
		
		do ADDSRC("  // Allow global reference and M source code")
		do ADDSRC("  #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
		do ADDSRC("  #BYPASS")
		do ADDSRC("  if $D(vobj("_objName_")) "_tblrec.getSaveCode(objName, "", -1))
		do ADDSRC("  #ENDBYPASS")
		
		if hasMB do {
			
			type String nodeRef
			
			// Will only be a single column
			type SchemaColumn colrec = Db.getSchemaColumn(file, MBNodes.elementAt(1))
			
			set nodeRef = colrec.getCurrentNode(1)
			
			do ADDSRC("   // Allow global reference and M source code")
			do ADDSRC("   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
			do ADDSRC("   #BYPASS")
			do ADDSRC("   if $D(vobj("_objName_","_nodeRef_")) "_tblrec.getSaveCode(objName, "*"_MBNodes.elementAt(1), -1))
			do ADDSRC("   #ENDBYPASS")
		}
	}
	
	#IF CUVAR.PUBLISH
	if 'tblrec.publishPGM.isNull() do ADDSRC("  if '(%SVCHNID.get() = 5)  do "_tblrec.publishPGM)
	#END
	
	quit
	
	
MSAVE(Number MODE,		// Record mode (0 or 1)
      SchemaTable tblrec,
      String objName,		// Object name
      List MBNodes,		// Memo/blob nodes
      List NegNodes)		// Negative nodes
      
	type Number I
	type String col
	
	// Code to file new type 10 or 11 record
	if (MODE = 0) do ADDSRC("  if %O = 0 for  set n = vobj("_objName_",n).order() quit:n.isNull()  do {")
	if (MODE = 1) do ADDSRC("  else  for  set n = vobj("_objName_",-100,n).order() quit:n.isNull()  do {")

	// Handle memos and blobs
	for I = 1:1:MBNodes.count() do {
	
		type String nodeRef
				
		set col = MBNodes.elementAt(I)
				
		type SchemaColumn colrec = Db.getSchemaColumn(tblrec.table, col)
		
		// Strip ,1 from CurrentNode
		if (MODE = 0) do {
			
			set nodeRef = colrec.getCurrentNode(1)
			set nodeRef = nodeRef.extract(1, nodeRef.length() - 2)
		}
		else  set nodeRef = colrec.getOldNode(1)		
		
		do ADDSRC("   if n = "_nodeRef_" do { quit")
		do ADDSRC("    // Allow global reference and M source code")
		do ADDSRC("    #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
		do ADDSRC("    #BYPASS")
		do ADDSRC("    "_tblrec.getSaveCode(objName, "*"_col, MODE))
		do ADDSRC("    #ENDBYPASS")
		do ADDSRC("   }")
	}
	
	// Handle negative nodes
	for I = 1:1:NegNodes.count() do {
		
		type String nodeRef = NegNodes.elementAt(I)
		
		do ADDSRC("   if n = "_nodeRef_" do { quit")
		do ADDSRC("   // Allow global reference and M source code")
		do ADDSRC("   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
		do ADDSRC("   #BYPASS")
		do ADDSRC("    "_tblrec.getSaveCode(objName, nodeRef, MODE))
		do ADDSRC("   #ENDBYPASS")
		do ADDSRC("   }")
	}
	
	// Top level or key - only need to deal with this on update when using -100
	if (MODE = 1) do ADDSRC("   quit:'$D(vobj("_objName_",n))")

	// Handle "non-special" nodes
	do ADDSRC("   // Allow global reference and M source code")
	do ADDSRC("   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
	do ADDSRC("   #BYPASS")
	do ADDSRC("   "_tblrec.getSaveCode(objName, "n", MODE))
	do ADDSRC("   #ENDBYPASS")
	do ADDSRC("  }")
	
	do ADDSRC("")
	
	quit


LOG(	String column,	// Procedure to generate PSL code for log columns
	String system,
	String typ,
	String objName)

	if column.isNull() quit ""

	type String return = " set "_objName_"."_column_" = "
	if typ = "D" quit return_$select(system = "PBS":"%SystemDate",1:"%CurrentDate")
	if typ = "T" quit return_"%CurrentTime"
	if typ = "U" quit return_$select(system = "DBS":"%UserName",1:"%UserID")

	quit ""


PARTBL(	String table,		// Return top of Recordclass hierarchy
	SchemaTable tblrec)

	if tblrec.parentTable.isNull() quit table
	for  set table = tblrec.parentTable,tblrec = Db.getSchemaTable(table) quit:tblrec.parentTable.isNull()
	quit table


KEYWHR(	String table,		// Table name
	String keys,		// Keys
	String objName,		// Object name
	Boolean isRDB,		// Is this a non-M database?
	Boolean asNATIVE,	// Return key query using native names
	String nattable)	// Native database table name
	
	/*
	Return SQL key query
	
	Because a non-M database may remap both table and key names to
	protect reserved words, the flag asNATIVE indicates to use the
	remapping scheme.  In that case, the table name may also change,
	so is returned in nattable.
	
	Note that for a non-M database that a table may also be remapped
	into multiple tables, returning nattable as a list.  The caller
	needs to deal with that issue.
	
	If objName is null, use "vkeyn" for variable assignment.  See
	vdelete coding for RBD.
	*/
	
	type public Boolean ER = 0
	type public String %DB
	
	type Number i
	type String col, di, ret

	if asNATIVE do {		// Remap table
		
		set nattable = table
		do MAP^DBMAP(%DB, .nattable)
	}

	if keys.get().isNull() quit ""

	set ret = ""

	for i = 1:1:keys.length(",") do { quit:ER

		if i>1 set ret = ret_" and "
		set di = keys.piece(",",i).lowerCase()
		set col = di.upperCase()
		
		if isRDB, asNATIVE do {
			
			do MAP^DBMAP(%DB, table, .col)
			
			if ER write " Aborted - ",table,".",col," not in DBMAP", !
		}
		
		if 'ER do {
			if 'objName.isNull() set ret = ret_col_" = :"_objName_"."_di
			else  set ret = ret_col_" =:vkey"_i
		}
	}
	
	quit ret
	

TAG(pslcode)	 // Inset program line tags
	
	do ADDSRC("")
	do ADDSRC(pslcode)
	do ADDSRC("")
	
	quit
	
	
ADDSRC(	String pslcode,		// Add code to SOURCE()
	String comment,
	Number line)

	// line is optional input, write only, to return location

	type public String SOURCE()
	
	if 'comment.get().isNull() set pslcode = pslcode_"".justify(55-pslcode.length())_" // "_comment

	// Replace leading spaces with tabs if not preformatted
	if pslcode'[$C(9),pslcode.beginsWith(" ") do {
		type Number n
		
		for n=1:1:pslcode.length() quit:pslcode.extract(n)'=" "
		set pslcode=pslcode.replace(" ",$C(9),n-1)
	}
	
	set line = SOURCE("").order(-1)+1
	set SOURCE(line) = pslcode.get()
	quit


ADDDOC(	String record,	// Add documentation
	Number element)

	type public Number sourceH
	type public String SOURCE()
	
	if record.get().isNull() quit

	type Number count = record.piece($C(9),1)
	type Date tld = record.piece($C(9),2)
	
	if 'count quit

	set element = "DBTBL"_element

	type RecordDBTBL1 rec = Db.getRecord("DBTBL1","'SYSDEV',:element")

	type String cmt = rec.des.extract(1,35)
	set cmt = cmt_" ("_count_") "
	set cmt = cmt.insert(tld.toString(),45)

	set sourceH = sourceH+.1
	set SOURCE(sourceH) = $C(9)_"// "_cmt
	quit


ADD(	String pslcode,		// Add procedural code in the output array
	String comment,
	Number line)

	type public String code()
 
	if 'line.get() set line = code("").order(-1)+1              // Next seqence 

	if 'comment.get().isNull() set pslcode = pslcode_"".justify(55-pslcode.length())_" // "_comment
	
	// Replace leading spaces with tabs if not preformatted
	if pslcode'[$C(9),pslcode.beginsWith(" ") do {
		type Number n
		
		for n=1:1:pslcode.length() quit:pslcode.extract(n)'=" "
		set pslcode=pslcode.replace(" ",$C(9),n-1)
	}	
	
	set code(line) = pslcode
	quit
	
	
private RDBRCTYP(String file)	// Reset record type for RDB

	type Number rectyp = 1

	if $$wide^DBSDBASE(file) set rectyp = 11
	
	quit rectyp


ERR(	String RM,		// Manage error display
	String expr)
	
	//       Tag+Line^Routine, SCA_[System_Name], msg: RM
	
	type public Number ER
	type public String %SN
	
	type String msg()
	
	ZSH "S":msg
	
	set ER=1,RM=msg("S",2)_", SCA_"_%SN.get()_", "_RM.get()
	
	if expr.exists() set expr=" // *ERR* "_RM
	use $P write !,$$MSG^%TRMVT(RM,,1)
	quit
	

PGMDIR(pgm)	// Return the directory location of the object file

	type String %ZE,%ZI(),%ZR()
	set %ZI(pgm) = "",%ZE = ".obj"
 
	do INT^%RSEL
 	quit %ZR(pgm).get()_pgm_".obj"
 	
 	
public SYSMAPLB(String tag,		// Line tag
		String comment)		// Comment on the line
		
	/*
	Used by UCSYSMAP to return the appropriate label reference for
	triggers from filer code being generated.  This information is
	used for storage in the SYSMAP* tables.
	*/
	
	type String RETURN = tag
	
	if tag.extract(1) = "v", comment.isLike("%Trigger%") do {
			
		set RETURN = comment.piece("Trigger", 2).piece("-", 1)
		set RETURN = tag_" (Trigger - "_RETURN.trim(0)_")"
	}
	
	quit RETURN

vSIG()	quit "60614^35241^Dan Russell^41234"	// Signature - LTD^TIME^USER^SIZE
