V01S334(%ProcessMode,RecordTTX fT)   // -  - SID= <ITFXV> Foreign Exchange Voucher Entry
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 11:55 - shetyes
 // This transaction entry screen permits the user to record an over-the-counter 
 // same-day foreign exchange deal or teller transaction.  
 // All transactions are against base currency at an input multiply or divide
 // rate. Settlement date is equal to or less than today's processing date.
 // To accommodate fees, commissions, and taxes, base currency amounts may
 // be distributed across numerous separate customer or general ledger accounts.  
 // However, general ledger postings to position accounts are automatically 
 // generated (spawned).  
 // Postings to nostro and customer accounts will be done realtime as with other 
 // PROFILE transactions. Projected nostro balances are also updated.
 // Inquiries are available on an individual voucher basis (FXVINQ)
 // or by browsing by currency (FXVLST).
  /*
ORIG: CHENARDP - 03/03/2003
DESC: PSL Screen Compiler Template

---- Comments --------------------------------------------------------
	This procedure is used as the base template for the PSL screen compiler.
	It is referenced by the PSL screen compiler - procedure DBS2PSL4
	
	
---- Revision History ------------------------------------------------
	02/23/06 - Pete Chenard - CR19551
		   Fixed routine label.
		   
	05/19/05 - Pete Chenard - CR 14146
		   Modified to type variables.
		   
	12/1/03 - Spier -cr7178
	   	     Modifications to correct dead code warnings and
	   	     other issues that occurred during mass compile of screens.

	09/24/03 - Pete Chenard - 45497
		       Created screen template for compiler.
----------------------------------------------------------------------

 */

 #WARN SCOPE OFF
	type Public String %MODS,%PAGE,%PG,%REPEAT,ER,RM
	type String KEYS(),KVAR,VFSN(),VO,VODFT,VPGM,vPSL,VSID,VSNAME

	// %O (0-Create  1-Modify  2-Inquiry  3-Delete  4-Print  5-Blank screen)

	set:'$D(%ProcessMode) %ProcessMode=5
 set KVAR="kill %TAB,VFSN,VO,VPTBL,vtab,DEALID,TRID,CUSTID,BS,MD,PM,PAYACC,ESTADO,CTY,ACNGL,ACNPST,DRCR,STAT,CNTRY",VSID="ITFXV",VPGM=$T(+0),VSNAME="Foreign Exchange Voucher Entry"
 set VFSN("ITSHLP")="zfITSHLP",VFSN("TTX")="zfT"
 set vPSL=1
 set KEYS(1)=fT.TJD
 set KEYS(2)=fT.BRCD
 set KEYS(3)=fT.UID
 set KEYS(4)=fT.TSEQ
 //
	// ==================== Display blank screen         (%O=5)

 if %ProcessMode=5 set %MODS=1,%REPEAT=7 do VPR(.fT),VDA1(.fT),V5^DBSPNT quit

 set ER=0 do VSCRPRE(.fT) if ER quit  // Screen Pre-Processor
 
 if '%ProcessMode do VNEW(.fT),VPR(.fT),VDA1(.fT)
 if %ProcessMode do VLOD(.fT) quit:$G(ER)  do VPR(.fT),VDA1(.fT)

	// ====================  Display Form
	do ^DBSPNT()
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	if %ProcessMode=2!(%ProcessMode=3) do ^DBSCRT8A X:'$D(%PAGE) KVAR quit  // Inquiry/Delete
	// ====================  Set up data entry control table


 if %ProcessMode<2 do VTAB(.fT)
	quit


VNEW(RecordTTX fT) // Initialize arrays if %O=0
 
 do VDEF(.fT)
 do VLOD(.fT)
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
	
VDEF(RecordTTX fT)
 if fT.CDT="" set fT.CDT=+$H
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
 ;
VLOD(RecordTTX fT) // Load data from disc - %O = (1-5)
 if '$D(%REPEAT) set %REPEAT=7
 if '$D(%MODS) set %MODS=1
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


	type Public String %MODS,%REPEAT
	quit
	

VPR(RecordTTX fT) // Display screen prompts
 set VO="21||13|"
 set VO(0)="|"
 set VO(1)=$C(3,4,13,0,0,0,0,0,0,0)_"01TPosting Date:"
 set VO(2)=$C(3,38,18,0,0,0,0,0,0,0)_"01T   Effective Date:"
 set VO(3)=$C(5,4,13,0,0,0,0,0,0,0)_"01T Tran Number:"
 set VO(4)=$C(5,41,15,1,0,0,0,0,0,0)_"01T Operations ID:"
 set VO(5)=$C(6,6,11,0,0,0,0,0,0,0)_"01T Trader ID:"
 set VO(6)=$C(6,38,18,1,0,0,0,0,0,0)_"01T Orig Cost Center:"
 set VO(7)=$C(7,1,16,0,0,0,0,0,0,0)_"01TCustomer Number:"
 set VO(8)=$C(7,42,14,0,0,0,0,0,0,0)_"01TCustomer Name:"
 set VO(9)=$C(9,7,10,1,0,0,0,0,0,0)_"01T Currency:"
 set VO(10)=$C(9,33,5,1,0,0,0,0,0,0)_"01T B/S:"
 set VO(11)=$C(9,47,9,1,0,0,0,0,0,0)_"01T  Amount:"
 set VO(12)=$C(10,2,15,1,0,0,0,0,0,0)_"01T Exchange Rate:"
 set VO(13)=$C(10,33,5,1,0,0,0,0,0,0)_"01T M/D:"
 set VO(14)=$C(10,43,13,1,0,0,0,0,0,0)_"01T Base Amount:"
 set VO(15)=$C(11,1,16,1,0,0,0,0,0,0)_"01TCurr Pay Method:"
 set VO(16)=$C(11,42,14,1,0,0,0,0,0,0)_"01T Payment Acct:"
 set VO(17)=$C(12,1,5,0,0,0,0,0,0,0)_"01TStat:"
 set VO(18)=$C(12,12,5,0,0,0,0,0,0,0)_"01TCtry:"
 set VO(19)=$C(13,26,28,1,0,0,0,0,0,0)_"01T Base Currency Distribution "
 set VO(20)=$C(14,1,79,2,0,0,0,0,0,0)_"01TGL  Account                   Base DR  Stat Ctry                               "
 set VO(21)=$C(15,1,79,2,0,0,0,0,0,0)_"01TACN   ID               Amount Curr CR  Code Code Narrative                     "
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VDA1(RecordTTX fT)  // Display screen data
 new V
 s %UID=$G(%UID)
 s ACCTTL=$G(ACCTTL)
 s ACNGL=$G(ACNGL)
 s ACNPST=$G(ACNPST)
 s BCURR=$G(BCURR)
 s BS=$G(BS)
 s CCY=$G(CCY)
 s CNTRY=$G(CNTRY)
 s CTY=$G(CTY)
 s CUSTID=$G(CUSTID)
 s DEALID=$G(DEALID)
 s DRCR=$G(DRCR)
 s EFD=$G(EFD)
 s ESTADO=$G(ESTADO)
 s MD=$G(MD)
 s NAM=$G(NAM)
 s PAYACC=$G(PAYACC)
 s PDATE=$G(PDATE)
 s PM=$G(PM)
 s STAT=$G(STAT)
 s TOPLINE=$G(TOPLINE)
 s TRID=$G(TRID)
 s TSEQ=$G(TSEQ)
 //
 set VO="44|22|13|"
 set VO(22)=$C(1,1,80,2,0,0,0,0,0,0)_"01T"_$G(TOPLINE)
 set VO(23)=$C(2,69,12,2,0,0,0,0,0,0)_"01T"_$G(%UID)
 set VO(24)=$C(3,18,10,2,0,0,0,0,0,0)_"01D"_$$DAT^%ZM($G(PDATE))
 set VO(25)=$C(3,57,10,2,0,0,0,0,0,0)_"01D"_$$DAT^%ZM($G(EFD))
 set VO(26)=$C(5,18,12,2,0,0,0,0,0,0)_"01N"_$G(TSEQ)
 set VO(27)=$C(5,57,10,2,0,0,0,0,0,0)_"00T"_$G(DEALID)
 set VO(28)=$C(6,18,4,2,0,0,0,0,0,0)_"00T"_$G(TRID)
 set VO(29)=$C(6,57,6,2,0,0,0,0,0,0)_"00N"_fT.CC
 set VO(30)=$C(7,18,12,2,0,0,0,0,0,0)_"00N"_$G(CUSTID)
 set VO(31)=$C(7,57,20,2,0,0,0,0,0,0)_"01T"_$G(NAM)
 set VO(32)=$C(9,18,3,2,0,0,0,0,0,0)_"00T"_$E(fT.CRCD,1,3)
 set VO(33)=$C(9,39,1,2,0,0,0,0,0,0)_"00U"_$G(BS)
 set VO(34)=$C(9,57,20,2,0,0,0,0,0,0)_"00T"_$E(fT.TAMT,1,60)
 set VO(35)=$C(9,76,3,2,0,0,0,0,0,0)_"01T"_$G(CCY)
 set V=$S(fT.RATE="":"",1:$J(fT.RATE,0,5)) set VO(36)=$C(10,18,10,2,0,0,0,0,0,0)_"00N"_$S(fT.RATE="":"",1:$J(fT.RATE,0,5))
 set VO(37)=$C(10,39,1,2,0,0,0,0,0,0)_"00U"_$G(MD)
 set V=$S(fT.BSEAMT="":"",1:$J(fT.BSEAMT,0,2)) set VO(38)=$C(10,57,18,2,0,0,0,0,0,0)_"00$"_$S(fT.BSEAMT="":"",1:$J(fT.BSEAMT,0,2))
 set VO(39)=$C(10,76,3,2,0,0,0,0,0,0)_"01T"_$G(BCURR)
 set VO(40)=$C(11,18,12,2,0,0,0,0,0,0)_"00T"_$G(PM)
 set VO(41)=$C(11,57,12,2,0,0,0,0,0,0)_"00N"_$G(PAYACC)
 set VO(42)=$C(12,6,5,2,0,0,0,0,0,0)_"00T"_$G(ESTADO)
 set VO(43)=$C(12,18,2,2,0,0,0,0,0,0)_"00T"_$G(CTY)
 set VO(44)=$C(12,42,30,2,0,0,0,0,0,0)_"01T"_$G(ACCTTL)
  
 set:'$D(%MODS) %MODS=1 set VX=$P(VO,"|",2)+22,DY=16 for I=%MODS:1:%REPEAT+%MODS-1 do VRDA(.fT)
 set $piece(VO,"|",1)=VX quit  // EOD pointer
 
VRDA(RecordTTX fT)  // Display data %REPEAT times
 //instantiate new object if necessary
 if %ProcessMode=5 new v1,v2,v3,v6,v4,v5
 if  set (v1,v2,v3,v6,v4,v5)=""
 else  new v1,v2,v3,v6,v4,v5
 else  set (v1,ACNGL(I))=$G(ACNGL(I)),(v2,ACNPST(I))=$G(ACNPST(I)),(v3,BCURR(I))=$G(BCURR(I)),(v6,CNTRY(I))=$G(CNTRY(I)),(v4,DRCR(I))=$G(DRCR(I)),(v5,STAT(I))=$G(STAT(I))
 
 set VO(VX+1)=$C(DY,1,1,0,0,0,0,0,0,0)_"00T"_v1
 set VO(VX+2)=$C(DY,5,12,0,0,0,0,0,0,0)_"00N"_$P(v2,"|",1)
 set V=$P(v2,"|",4) set VO(VX+3)=$C(DY,18,12,0,0,0,0,0,0,0)_"00$"_$S(V="":"",1:$J(V,0,2))
 set VO(VX+4)=$C(DY,31,3,0,0,0,0,0,0,0)_"01T"_v3
 set VO(VX+5)=$C(DY,36,2,0,0,0,0,0,0,0)_"00T"_v4
 set VO(VX+6)=$C(DY,39,5,0,0,0,0,0,0,0)_"00N"_v5
 set VO(VX+7)=$C(DY,45,2,0,0,0,0,0,0,0)_"00T"_v6
 set VO(VX+8)=$C(DY,50,30,0,0,0,0,0,0,0)_"00T"_$P(v2,"|",8)
 set DY=DY+1,VX=VX+8
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
	
	
VTAB(RecordTTX fT)
 
 kill VSCRPP,REQ,%TAB,%MOD,%MODOFF,%MODGRP,%REPREQ,vtab set %MODGRP=1
 set %MODOFF=23,%MOD=8,%MAX=(%MOD*%REPEAT)+%MODOFF,VPT=1,VPB=15+%REPEAT,BLKSIZ=(67*%REPEAT)+336,PGM=$T(+0),DLIB="SYSDEV",DFID="TTX",VSCRPP=1,VSCRPP=1
 set OLNTB=VPB*1000
 
 set VFSN("ITSHLP")="zfITSHLP",VFSN("TTX")="zfT"
 //
 for I=32:1:%MAX set %TAB(I)=""
	
	
 set %TAB(1)=$C(0,0,80)_"20T|*TOPLINE|[*]@TOPLINE"
 set %TAB(2)=$C(1,68,12)_"20T|*%UID|[*]@ooe10"
 set %TAB(3)=$C(2,17,10)_"21D|*PDATE|[*]@PDATE"
 set %TAB(4)=$C(2,56,10)_"20D|*EFD|[*]@EFD"
 set %TAB(5)=$C(4,17,12)_"20N|*TSEQ|[*]@TSEQ"
 set %TAB(6)=$C(4,56,10)_"01T|*DEALID|[*]@DEALID"
 set %TAB(7)=$C(5,17,4)_"00T|*TRID|[*]@[ITSHLP]TRID|[UTBLRADR]||do VP1^V01S334(.fT)"
 set %TAB(8)=$C(5,56,6)_"01N12420||[TTX]CC|[UTBLCCNTR]"
 set %TAB(9)=$C(6,17,12)_"00N|*CUSTID|[*]@[ITSHLP]CUSTI|||do VP2^V01S334(.fT)"
 set %TAB(10)=$C(6,56,20)_"20T|*NAM|[*]@NAM"
 set %TAB(11)=$C(8,17,3)_"01T12417||[TTX]CRCD|[CRCD]:QU ""[CRCD]CO=<<%CO>>,[CRCD]RETAIL=1""||do VP3^V01S334(.fT)"
 set %TAB(12)=$C(8,38,1)_"01U|*BS|[*]@[ITSHLP]BS|||do VP4^V01S334(.fT)"
 set %TAB(13)=$C(8,56,20)_"01T12404||[TTX]TAMT|||do VP5^V01S334(.fT)||||||60"
 set %TAB(14)=$C(8,75,3)_"20T|*CCY|[*]@CCY"
 set %TAB(15)=$C(9,17,10)_"01N12418||[TTX]RATE|||do VP6^V01S334(.fT)||||5"
 set %TAB(16)=$C(9,38,1)_"01U|*MD|[*]@[ITSHLP]MD|||do VP7^V01S334(.fT)"
 set %TAB(17)=$C(9,56,18)_"01$12425||[TTX]BSEAMT|||do VP8^V01S334(.fT)||||2"
 set %TAB(18)=$C(9,75,3)_"20T|*BCURR|[*]@BCURR"
 set %TAB(19)=$C(10,17,12)_"01T|*PM|[*]@[ITSHLP]PM|[UTBLITPAY]ACNGL,PAYDESC"
 set %TAB(20)=$C(10,56,12)_"01N|*PAYACC|[*]@[ITSHLP]PAYAC|||do VP9^V01S334(.fT)||||0"
 set %TAB(21)=$C(11,5,5)_"00T|*ESTADO|[*]@[ITSHLP]ESTAD|[UTBLESTAD]"
 set %TAB(22)=$C(11,17,2)_"00T|*CTY|[*]@[ITSHLP]CTRY|[STBLCNTRY]"
 set %TAB(23)=$C(11,41,30)_"20T|*ACCTTL|[*]@ACCTTL"
 set %TAB(24)=$C(15,0,1)_"00T|*ACNGL(1)|[*]@[ITSHLP]ACNGL|||do VP10^V01S334(.fT)"
 set %TAB(25)=$C(15,4,12)_"00N12401|*ACNPST(1)|[*]@ACNPST|||do VP11^V01S334(.fT)||||0"
 set %TAB(26)=$C(15,17,12)_"00$12404|*ACNPST(1)|[*]@[ITSHLP]ACNP|||do VP12^V01S334(.fT)||||2"
 set %TAB(27)=$C(15,30,3)_"20T|*BCURR(1)|[*]@BCURR"
 set %TAB(28)=$C(15,35,2)_"00T|*DRCR(1)|[*]@[ITSHLP]DRCR|||do VP13^V01S334(.fT)"
 set %TAB(29)=$C(15,38,5)_"00N|*STAT(1)|[*]@[ITSHLP]ESTAD|[UTBLESTAD]||||||0"
 set %TAB(30)=$C(15,44,2)_"00T|*CNTRY(1)|[*]@[ITSHLP]CTRY|[STBLCNTRY]"
 set %TAB(31)=$C(15,49,30)_"00T12408|*ACNPST(1)|[*]@[ITSHLP]NARR|||do VP14^V01S334(.fT)"
 do VTBL(.fT),VDEPRE(.fT) if $G(ER) quit
	do ^DBSCRT8 	// data entry
	quit


VREQ   // Create REQ() array
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VTBL(RecordTTX fT) //Create %TAB(array)
 	// 1 2 3  4 5   6   7-9 10-11
 	// DY,DX,SZ PT REQ TYPE DEL POS |NODE|ITEM NAME|TBL|FMT|PP|PRE|MIN|MAX|DEC

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VSPP   // screen post proc
 type Public RecordTTX fT
 do VSPP1(.fT)
 #ACCEPT Date=11/05/03; pgm=Screen Compilerxxx
 quit
VSPP1(RecordTTX fT)
	type public Boolean ER
	type public String BS, RM
	type Number CTR, CTL, DTL, TAMT
	set (DTL, CTL) = 0
	for CTR = 1:1:7 do {
		quit:'ACNPST(CTR).piece("|",1)
		quit:'ACNPST(CTR).piece("|",4)
		quit:ACNPST(CTR).piece("|",2).isNull()
		quit:DRCR(CTR).isNull()
		if (DRCR(CTR) = "DR") set DTL = DTL + ACNPST(CTR).get().piece("|", 4)
		if (DRCR(CTR) = "CR") set CTL = CTL + ACNPST(CTR).get().piece("|", 4)
	}
	if (BS = "S") set TAMT = -fT.bseamt
 	else  set TAMT = fT.bseamt
	if ((DTL - CTL) + TAMT '= 0) do {
	
		// Fill in the error message
		// If out of Balance, display values with 'DR' or 'CR' 
		type Number M1, M2, RESULT
		set RESULT = DTL - CTL
	
		if (TAMT < 0) set M1 = (-TAMT)_"CR"
		else  set M1 = TAMT_"DR"
		if (RESULT < 0) set M2 = (-RESULT)_"CR"
		else  set M2 = RESULT_"DR"
		set ER = 1
		// Screen is out of balance- Dist: ~p1  Base Amt: ~p2
		set RM = $$^MSG(6113, M2, M1)
	}
	quit
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
VDEPRE(RecordTTX fT)  // Data Entry Pre-processor
 
	if (%ProcessMode = 1) do PROTECT^DBSMACRO("@DEALID")
	quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


  //user-defined post procs
 //
VP1(RecordTTX fT) //
	type public Boolean ER
	type public String X

	if 'X.isNull() do {

		type RecordUTBLRADR utblradr=Db.getRecord("UTBLRADR","KEY=:X",1)
	
		// Trader not defined
		if (utblradr.getMode() = 0) do Runtime.setErrMSG("UTBLRADR", 6114)

		if 'ER, fT.cc.isNull() do DEFAULT^DBSMACRO("TTX.CC", utblradr.brcd)
	}

	quit
VP2(RecordTTX fT) //
	type public Boolean ER
	type public String NAM, X

 	set NAM=" "

	quit:X.isNull()

	do CUS^UACN1 quit:X.isNull()

	type RecordCIF cif = Db.getRecord("CIF", "ACN=:X", 1)

	if (cif.getMode() = 0) do { quit:ER

		// Invalid customer number
		do Runtime.setErrMSG("CIF", 1295)
		set X=""
	}

	set NAM = cif.lnm
	if NAM.isNull() set NAM = cif.nam.extract(1, 20) 

	// NO NAME
	if NAM.isNull() set NAM = $$^MSG(6115)

	do DEFAULT^DBSMACRO("@NAM", NAM)

	quit
VP3(RecordTTX fT) //
	type public String CCY, X

	if 'X.isNull() do DEFAULT^DBSMACRO("@CCY", X)

	quit
VP4(RecordTTX fT) //
	type public String V, X

	// Enter 'B' for buy or 'S' for sell
	if '((X = "B") ! (X = "S")) do Runtime.setErrMSG("TTX", 6116)

	quit
VP5(RecordTTX fT) //
	type public Number X

	// ENTER A POSITIVE NUMBER
	if (X '> 0) do Runtime.setErrMSG("TTX", 6109)

	quit
VP6(RecordTTX fT) //
	type public Boolean ER
	type public String X

	// Enter a positive Exchange Rate
	if (X < 0) do Runtime.setErrMSG("TTX", 6118) quit:ER

	type RecordCRCD crcd = Db.getRecord("CRCD", "CRCD=:fT.crcd,CO=:%CompanyName", 1)
	
	// Exchange rate value is below minimum for currency
	if ((crcd.minrate > 0) & (X < crcd.minrate)) do Runtime.setErrMSG("TTX", 6119) quit:ER

	// Exchange rate value is above maximum for currency
	if ((crcd.maxrate > 0) & (X > crcd.maxrate)) do Runtime.setErrMSG("TTX", 6120) quit:ER

	quit
VP7(RecordTTX fT) //
	type public String X
	
	// Enter 'M' for multiply or 'D' for divide
	if '((X = "M") ! (X = "D")) do Runtime.setErrMSG("TTX",6121)

	quit
VP8(RecordTTX fT) //
	type public String MD

	type Number DIFF, TEMPBC, TEMPFC

	if (MD = "M") do {

		set TEMPFC = (X / fT.rate)
		set TEMPBC = (fT.tamt * fT.rate)
	}
	else  do {

		set TEMPFC = (X * fT.rate)
		set TEMPBC = (fT.tamt / fT.rate)
	}

	set DIFF = fT.tamt - TEMPFC
	if (DIFF < 0) set DIFF = -DIFF
	
	// Invalid Exchange Calculation ( BASE)... ~p1
	if (DIFF > 2) do Runtime.setErrMSG("TTX",6123,TEMPBC)
 
	quit
VP9(RecordTTX fT) //
	type public Boolean ER
	type public String PM, RM, X

	type String ACINFO

	// PM is the payment method for target currency defined in screen 
	// driver procedure
	type RecordUTBLITPAY itpay = Db.getRecord("UTBLITPAY", "KEY=:PM", 1)
	
	if (itpay.acngl = "G") do {

		type RecordGLAD glad = Db.getRecord("GLAD", "ACN=:X", 1)

		// Invalid G/L account
		if (glad.getMode() = 0) do Runtime.setErrMSG("GLAD", 1364) quit:ER	
	
		// G/L account can only accept base currency transactions
		if ((glad.bonly = 1) & (CUVAR.%CRCD '= fT.crcd)) do Runtime.setErrMSG("GLAD", 6125) quit:ER

		set ACINFO = glad.desc1
		set RM = ACINFO

		do DEFAULT^DBSMACRO("@ACCTTL",ACINFO)
	}

	if itpay.acngl="A" do {

		type Number %EXT
		type String CRCD, ZCLS

		set %EXT = 1
		set ZCLS = "D"
		do CID^UACN1 quit:X.isNull()

		type RecordACN acn = Db.getRecord("ACN", "CID=:X", 1)

		// Invalid account
		if (acn.getMode() = 0) do Runtime.setErrMSG("ACN", 1259) quit:ER

		// Account closed
		if (acn.stat = 4) do Runtime.setErrMSG("ACN", 55) quit:ER

		// Check to see if there's an account close date
		// If there is, is it before the transaction posting date
		if ((acn.mdt < fT.tjd) & 'acn.mdt.isNull()) do { quit

			// Account is scheduled to close on ~p1.
			if (acn.mdt > (%CurrentDate - 1)) do Runtime.setErrMSG("ACN", 6127, acn.mdt.toString()) quit:ER
			
			// Account was scheduled to close on ~p1.
 			if (acn.mdt < %CurrentDate) do Runtime.setErrMSG("ACN", 6128, acn.mdt.toString()) quit:ER
		}

		set CRCD = acn.crcd
		if CRCD.isNull() set CRCD = CUVAR.%CRCD

		// Account does not match currency
		if (CRCD '= CCY) do Runtime.setErrMSG("ACN", 6129) quit:ER

		set ACINFO = acn.title1.extract(1,30)

		do DEFAULT^DBSMACRO("@ACCTTL",ACINFO)
		}

	quit
VP10(RecordTTX fT) //
	type public String X
	type public Number z1

	quit:(X.isNull() & (z1 <> 1))

	// Enter 'G' for General Ledger account or 'A' for IBS account
	if '((X = "G") ! (X = "A")) do Runtime.setErrMSG("TTX",6101)

	quit
VP11(RecordTTX fT) //
	type public Boolean %EXT, ER
	type public Number PAYACC, z1
	type public String ACNGL(), ACNPST(), BCURR, CCY, DCRCD, RM, V, X

	/*
	ACNGL - The array containing the ACNGL indicators for the base 
	        currency postings.
	PAYACC -The payment account number for the target currency
	*/

	if (X.isNull() & 'V.isNull()) do { quit

		// 'Remove' key has been hit - delete the array entry.
        	//  Array contains the lower postings in base currency.
 
		set ACNPST(z1).piece("|",4)=""
		set ACNPST(z1).piece("|",2)=""
 
		do DISPLAY^DBSMACRO("@ACNPST(z1)", ACNPST(z1))
	}

	// Must enter at least one distribution account
	if X.isNull() do { quit

		if 'ACNGL(z1).isNull() do Runtime.setErrMSG("TTX", 6139)
	}

	// Enter 'G' for General Ledger account or 'A' for IBS account
	if ACNGL(z1).isNull() do Runtime.setErrMSG("TTX",6101) quit:ER         

	quit:(X = V)

 	if (ACNGL(z1) = "G") do { quit
		
		type RecordGLAD glad = Db.getRecord("GLAD", "ACN=:X", 1)

		// Invalid G/L account
		if (glad.getMode() = 0) do Runtime.setErrMSG("GLAD", 1364) quit:ER

		set RM = glad.desc1
	}

	// ACNGL(z1) = "A"	
	set %EXT = 1
	do CID^UACN1 quit:ER

	// Distribution Account cannot be the same as the payment account.
	if (X = PAYACC) do Runtime.setErrMSG("TTX", 6132) quit:ER

	type RecordACN acn = Db.getRecord("ACN", "CID=:X")

	// Account closed
	if (acn.stat = 4) do Runtime.setErrMSG("ACN", 55) quit:ER

	if ((acn.mdt < fT.tjd) & 'acn.mdt.isNull()), (acn.mdt < %CurrentDate) do { quit:ER
		type Date MDT

		set MDT = acn.mdt

		// This account was scheduled to close on: ~p1
		do Runtime.setErrMSG("ACN", 6133, MDT.toString())
	}

	set CCY = acn.crcd
	if CCY.isNull() set CCY = DCRCD.get()
	if CCY.isNull() set CCY = CUVAR.%CRCD

	// This account denominated in ~p1.  Must match base.
	if (CCY '= BCURR) do Runtime.setErrMSG("TTX", 6134, CCY) quit:ER

	set RM = acn.title1 

	quit
VP12(RecordTTX fT) //
	type public Number X

	// ENTER A POSITIVE NUMBER
	if 'X.isNull(), (X '> 0) do Runtime.setErrMSG("TTX", 6109)

	quit
VP13(RecordTTX fT) //
	type public Number z1
	type public String ACNPST(), X

	quit:X.isNull()

	if (X = "DR") set ACNPST(z1).piece("|", 2) = 0
	else  if (X = "CR") set ACNPST(z1).piece("|", 2) = 1
	else  do {
		// Enter DR (Debit) or CR (Credit)
		do Runtime.setErrMSG("TTX", 6110)
	}

	quit

VP14(RecordTTX fT) //
	type public Boolean ER
	type public Number BS, BT, z1

	type Number CTR, CTTL, DTTL, RESULT
	type String M, M1, M2

	// Make sure at least one payment account is entered

	set ER = 0

 	if (z1 = 1) do { quit:ER

		// Test first entry of ACNPST to ensure something is entered
 
		// Must enter at least one distribution account
		if ACNPST(1).piece("|", 1).isNull() do Runtime.setErrMSG("TTX", 6139) quit:ER
 
		// Missing Amount on first distribution entry
		if ACNPST(1).piece("|", 4).isNull() do Runtime.setErrMSG("TTX", 6140) quit:ER

		// Missing Debit/Credit indicator
		if ACNPST(1).piece("|", 2).isNull() do Runtime.setErrMSG("TTX", 6141) quit:ER
 
	}

	set (CTTL, DTTL)=0
	for CTR = 1:1:7 if ACNPST(CTR).exists() do {
 
	        quit:ACNPST(CTR).piece("|",1).isNull()          // CID
 
        	quit:DRCR(CTR).get().isNull()
 
        	quit:(ACNPST(CTR).piece("|",4) = 0)             // TAMT
 
        	if (DRCR(CTR) = "CR") set CTTL = CTTL + ACNPST(CTR).piece("|",4)
        	if (DRCR(CTR) = "DR") set DTTL = DTTL + ACNPST(CTR).piece("|",4)
	}

	set RESULT = DTTL - CTTL

	// BS is by/sell indiicator
	if BS="S" set BT = -fT.bseamt
	else  set BT = fT.bseamt

	if (BT < 0) set M1 = (-BT)_"CR"
	else  set M1 = BT_"DR"
	if (RESULT < 0) set M2 = (-RESULT)_"CR"
	else  set M2 = RESULT_"DR"
	
	// Base Amount: ~p1  Base Distribution: ~p2
	set M = $$^MSG(6137, M1, M2)

	// (BALANCED) ~p1
 	if ((DTTL - CTTL) + BT = 0) set RM = $$^MSG(6112,  M)
	else  set RM = M

	quit

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit								// User defined post processor's


VRV(V,L) quit V_$J("",L-$L(V))
VREPRNT
 type Public RecordTTX fT
 do VPR(.fT)
 do VDA1(.fT)
 do ^DBSPNT()
 quit

VW(RecordTTX fT)
 do VDA1(.fT)
 do ^DBSPNT(10)
 quit

VDAPNT(RecordTTX fT)
 do VDA1(.fT)
 do ^DBSPNT(0,2)
 quit

VDA
 type Public RecordTTX fT
 do VDA1(.fT)
 quit

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
 
vSET(sn,di,X)
 type Public RecordTTX fT
 if sn="TTX" do vSET1(.fT,di,X)
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
vSET1(RecordTTX fT,di,X)
 do fT.setAuditFlag(1)
 set fT.@di=X
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
vREAD(fid,di)
 type Public RecordTTX fT
 if fid="TTX" quit $$vREAD1(.fT,di)
 quit ""
vREAD1(RecordTTX fT,di)
 quit fT.@di
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
 //
VSCRPRE(RecordTTX fT)  // Screen Pre-Processor
 new %TAB,vtab // Disable .MACRO. references to %TAB()
 //
	type public Number BRCD
	type public String %FN, TOPLINE
	type String DATE, SPACES
	type RecordSCATBL scatbl = Db.getRecord("SCATBL", "FN=:%FN", 1)
	type RecordUTBLBRCD utblbrcd = Db.getRecord("UTBLBRCD", "BRCD=:BRCD")
	set DATE = %SystemDate.toString()
	set SPACES = " ".justify(40 - utblbrcd.desc.length() - (.5 * scatbl.desc.length()))
	set TOPLINE = utblbrcd.desc_SPACES_scatbl.desc
	set TOPLINE = TOPLINE_" ".justify(80 - TOPLINE.length() - DATE.length())_DATE
	quit
 #ACCEPT date=11/05/03;PGM=Screen Compiler
 quit
