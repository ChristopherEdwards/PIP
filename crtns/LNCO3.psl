LNCO3		/*

	Computed Data Items

	---- Revision History ------------------------------------------------
	
	07/06/07 - SENTHIL.J KUMAR - CR 28017
		   Modified the CNAMT2 section to correct the formula used to 
		   calculate for the computed field "Computed Not Assessed".
		   Actually lnfee.asld should have been used to deduct from the 
		   %SystemDate rather than lnfee.asnd.
	
	03/11/07 - SmithCD - CR 24945
		   Fixed problem with BIL1(,) getting initialized instead of 
		   BIL(,), which is the one used later in the section. Cleaned 
		   up XLN29A, and anything that calls into it, to standards.
	
	02/28/07 - PUTTASWH - CR 25602
	 	   Modified CNAMT section to pass the ln object to a new 
	 	   section, CNAMT2,which will then call the LNFEECMP calculation
	 	   for the fee type specified.

	11/14/06 - NATRAJAH - CR 24061
		   Modifed XLN29A section to return the Total Miscellaneous
		   Charges Due(LN.MCHG) properly.

	07/19/06 - KELLYP - CR 22174
		   Modified TAMT section to return UAVB(5) properly & removed
		   third "H" parameter which was not being used.

	02/27/06 - KinI - CR 19809
		   Modified MCND section to use ln.cid instead of CID when 
		   ln object that is supposed to be passed in exists.

	01/05/06 - SmithCD - CR 18783
		   Scoped BIL, BIL1, and BIL5 arrays locally in XLN29A to 
		   prevent arrays from getting too large (was causing a 
		   problem when called ultimately from BTTDRV for computed 
		   columns ln.mchg and ln.mcnd). Replaced .getPointer() with 
		   .exists(). Removed old revision history.

	*/

	quit


public TAMT(Number CID,Number TSEQ)	// Return transaction components

	/*
	INPUT:
	.CID	Customer Account		/TYP=N/REQ

	.TSEQ	History Sequence		/TYP=N


	RETURNS:

	. UAVB(5) See [LNTAMT] file definition, or routine ^UAVB: UAVB(5) 
	  definition for list of returned values.
	*/

	type Date ADJEFD,EFD,FD
	type Number AV,BAL,DC,I,INCRS,NEGAMTRED,P,PRNCPLE,SEQ,TAMT,TRB,UNC
	type String CLS,CTL,ETC,HST,IND,ITC,TRN,TSO,UAVB()

	if (CID.get().isNull())!(TSEQ.get().isNull()) quit ""

	if TSEQ'>0 quit ""

	// Set this for calls to UAVB
	set SEQ=TSEQ

	type RecordHIST hist=Db.getRecord("HIST","CID=:CID,TSEQ=:TSEQ",1)
	if 'hist.getMode() quit ""
	
	set CTL="000000000000000001"

	type RecordLN ln=Db.getRecord("LN","CID=:CID",1)
	if 'ln.getMode() quit ""

	set BAL=hist.endbal
	set TRB=ln.trb
	set CLS=ln.cls
	set FD=0
	
	for I=51:1:59 set AV(I)=""
	for I=510:1:526 set AV(I)=""
	
	do LOADH^UAVB(.ln,.hist)
	do UAVB5^UAVB(.ln)
	do FILE5^UAVB

	quit UAVB(5)


public HIST(CID,TSEQ)	// Break history transaction down to component amounts

	/*
	INPUT:
	.CID	Customer Account		/TYP=N/REQ

	.TSEQ	History Sequence		/TYP=N


	RETURNS:

	.XH01	 

	*/
	
	type public Boolean ER

	new HISTSB,ITC,PRIN

	set PRIN=0
	set ER=""
	if 'Db.isDefined("HIST","CID,TSEQ") quit	
	type RecordHIST hist=Db.getRecord("HIST","CID,TSEQ")
	if '(hist.tamt),(hist.itc)="" set XH01="" quit

	if Db.isDefined("LN","CID=:CID") do {
		type RecordLN ln=Db.getRecord("LN","CID=:CID")
		if ln.type="" quit 
		set XH01=$S(hist.tamt["#":$P(hist.tamt,"#",2),1:(hist.tamt)) 
		set F=$P(hist.tamt,"#",9) 

		// Principle
		set PRIN=0
		// Undisbursed
		if ln.aruf set XH01=XH01+$P(hist.tamt,"#",5)
	
		// Internal Transaction Code
		set ITC=hist.itc
		if (ln.grp'="ESC") do {
			if (hist.tamt<0) do {
				do HIST2(.hist) 
				set:PRIN PRIN=-PRIN 
				}
			else  do {
				set HISTSB=""
				type ResultSet rs=Db.select("PE01,PE02,PE03,PE04,PE05","HISTSB","CID=:CID and SLN=:TSEQ")
				if rs.isEmpty() quit
				while rs.next() do { quit:ER
					set HISTSB=rs.getCol(1)_"|"_rs.getCol(2)_"|"_rs.getCol(3)_"|"_rs.getCol(4)_"|"_rs.getCol(5)_"|"
					do HIST1(HISTSB,.PRIN)
					}
				}
			}
		set $P(XH01,"|",1)=XH01-PRIN
		set $P(XH01,"|",2)=PRIN
		set $P(XH01,"|",5)=F
		}
	
	// Escrow
	set $P(XH01,"|",6)=$P(hist.tamt,"#",7)
	if '$P(XH01,"|",6) set $P(XH01,"|",6)=""
	
	/* 
	Interest - distinction between accrual adjustment and collection
	External Transaction Code
	*/

	set E=hist.etc 
	if '$L(E) quit
	type RecordTRN trn=Db.getRecord("TRN","ETC=:E")
	set PCF=trn.pcf
	if '$E(PCF,20) set $P(XH01,"|",3)=$P(hist.tamt,"#",3)
	else  set $P(XH01,"|",4)=$P(hist.tamt,"#",3)

	quit 
	

HIST1(HISTSB,PRIN)	// Lower level

	// Principal Only
	for J=2:1 quit:$P(HISTSB,"*#P#",J)=""  set PRIN=PRIN+$P(HISTSB,"*#P#",J)

	quit 
	

HIST2(RecordHIST hist)	// reversal

	/*
	
	   The history sequence that was reversed is only stored in the
	   primary error-correct transaction.  If the error-correct
	   generated secondary transactions, we have to look to the primary
	   to find the original record.
	*/
	
	type public Boolean ER

	if '$E(ITC,6) do {
		set S=""
		// Transaction Source of Funds
		if '$E(ITC,7) set S=hist.tso
		else  do { quit:'$E($P(ITC,"|",2),7)
			type ResultSet rs=Db.select("TSEQ,ITC,TSO","HIST","CID=:CID and TSEQ<:TSEQ","TSEQ DESC")
			if rs.isEmpty() quit
			while rs.next() do {
				set TSEQ=rs.getCol(1)
				set ITC=rs.getCol(2)
				set TSO=rs.getCol(3)
				}
			} 
		if TSO do {
			type ResultSet rs1=Db.select("PE01,PE02,PE03,PE04,PE05","HISTSB","CID=:CID and SLN=:TSEQ")
			if rs1.isEmpty() quit
			while rs1.next() do { quit:ER
				set HISTSB=rs1.getCol(1)_"|"_rs1.getCol(2)_"|"_rs1.getCol(3)_"|"_rs1.getCol(4)_"|"_rs1.getCol(5)_"|"
				do HIST1(HISTSB,.PRIN)
				}
			}
		}


	// error correct
	else  do {
		new XRCD,XETC,XITC,XTAMT,XTRC,XTSEQ,XUID

		set XITC=hist.itc
		set XTSEQ=hist.tseq
		set XETC=hist.etc
		set XTAMT=hist.tamt
		set XBRCD=hist.brcd 
		set XTRC=hist.tso
		set XUID=hist.uid
		type ResultSet rs=Db.select("TSEQ","HIST","CID=:CID and TSEQ<:XTSEQ and ITC=:XITC and ETC=:XETC and TAMT=:XTAMT and BRCD=:XBRCD and TRC=:XTRC and UID=:XUID","TSEQ DESC")
		if rs.isEmpty() quit
		while rs.next() do { quit:ER
			set TSEQ=rs.getCol(1)
			type ResultSet rs1=Db.select("PE01,PE02,PE03,PE04,PE05","HISTSB","CID=:CID and SLN=:TSEQ")
	 		if rs1.isEmpty() quit
			while rs1.next() do { quit:ER
		       		set HISTSB=rs1.getCol(1)_"|"_rs1.getCol(2)_"|"_rs1.getCol(3)_"|"_rs1.getCol(4)_"|"_rs1.getCol(5)_"|"
				do HIST1(HISTSB,.PRIN)
				}
			}
		}
	quit 
	

public	SCHPMT(CID) // Scheduled payment amount (next scheduled date)

	/*
	INPUT:
	.CID	Customer Account		/TYP=N/REQ

	.TSEQ	History Sequence		/TYP=N


	RETURNS:

	.SCHPMT	Scheduled payment amount	/TYP=$
	*/
	
	new BSEQ,ESCROW,KEY,PCHND,PMT,SCHSEQ

	type RecordLN ln=Db.getRecord("LN","CID=:CID")

	// current P & I
	set SCHPMT=ln.schpmt
	// No next scheduled date
	if 'ln.schnd quit
	// Schedule sequence
	set SCHSEQ=ln.schseq
	// Payment Change next date
	set PCHND=ln.pchnd
	// Payment Calculation method
	set KEY=ln.pcm
	
	// Use amount from bill file if record exists
	if ln.bseq>SCHSEQ,Db.isDefined("LNBIL1","CID=:CID,SCHSEQ=:SCHSEQ") do { quit
		type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:SCHSEQ")
		set SCHPMT=lnbil1.ctab
		}
	
	// Use last payment amount if PCM does not call for a P & I amount
	if 'Db.isDefined("STBLPCM","KEY") set SCHPMT=ln.pmt quit 
	
	// Use P & I amount from payment change file if appropriate
	if PCHND=ln.schnd,Db.isDefined("LNPTCHG","PCHND=:PCHND,CID=:CID") do {
		type RecordLNPTCHG lnptchg=Db.getRecord("LNPTCHG","PCHND=:PCHND,CID=:CID")
		set SCHPMT=lnptchg.npmt
		if '$L(SCHPMT) set SCHPMT=PMTPI
		}
	// Find next escrow payment amount for each escrow item
	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID")
	set INSTANT=lnbil0.pe01
	set ELENUM=0
	for  set ESCROW=$$ESCACT^BILFUNCS(.lnbil0,.ELENUM) quit:ESCROW=""  do {
		set ECID=$P(ESCROW,$C(9),1)
		if ECID="" quit
		type RecordDEP dep=Db.getRecord("DEP","CID=:ECID")
		if dep.stat=4 quit
		set SCHPMT=SCHPMT+$S($L(dep.recamt):dep.recamt,1:dep.curramt)
		}

	quit 

	
public MCHG(Number CID)	// Account number

	// Total fees due

	type String XLN29, XLN29()
	
	type RecordLN ln = Db.getRecord("LN", "CID=:CID")
	do XLN29(.ln, CID)
	
	quit +XLN29
	

public MCNB(RecordLN ln,		// Loan account			/REF:R/NOREQ
	    Number CID)			// Account number		/NOREQ

	/*
	Misc charges outstanding, not billed
	
	   Additional notes on ARGUMENTS:
	
	   . ln	
	      Passing in the LN object will indicate that the current values
	      of the ln object should be used.  If no object is passed in, a
	      new ln object will be created.
	
	   . CID
	      If the cid is passed in, the procedure will create a new
	      ln object based on this cid.  If the cid is Null and the object
	      has not been passed in, the system will create a new object based 
	      on what is currently defined in CID.  If both ln object and cid
	      are passed in, procedure will use the existing ln object and 
	      ignore the cid.
	*/
	
	type Number feend

	if 'ln.exists() do {
		if 'CID.get() set feend = "" quit

		type RecordLN ln = Db.getRecord("LN", "CID=:CID")
		do FEEND^LNPTS13(.ln, .feend, 1)
		}
	else  do FEEND^LNPTS13(.ln, .feend, 1)

	quit feend

	
public MCND(Number CTL,		// Control Parameter 		/NOREQ
            RecordLN ln,	// Loan account			/REF:R/NOREQ
            Number CID)		// Account number		/NOREQ
            
	/*
	Misc charges outstanding, not due
	
	Additional notes on ARGUMENTS
	
	   . CTL
	       1   0 - "N"ew array MCND(FeeType)
		   1 - Do Not "New" MCND
		   			
	   . ln
		Passing in the LN object will indicate that the current values
		of the ln object should be used.  If no object is passed in, a
		new ln object will be created.

	   . CID
		If the CID  is passed in, the procedure will create a new
		ln object based on this id is Null and the object
		has not been passed in, the system will create a new object based
		on what is currently defined in CID.  If both ln object and CID
		are passed in, procedure will use the existing ln object and
		ignore the CID.	

	   RETURNS:

	   . MCND(FEETYPE) Misc charge outstanding, not due by fee type	
	*/
	
	type Number return

	set CTL = CTL.get()

	if 'ln.exists() do {
		if 'CID.get() set return = "" quit
		type RecordLN ln = Db.getRecord("LN", "CID=:CID")

		do MCND1(.ln, CID, .return)
		}

	else  do MCND1(.ln, ln.cid, .return)

	quit return


MCND1(RecordLN ln,		// Loan account			/REF:R
      Number CID,		// Loan account number
      Number return)		// Return amount		/REF:W
	
	// Calculate Misc charge outstanding, not due by sutracting Current 
	// Misc Charges (LN.CUMC) from Uncollected Misc Charge (LN.UNMC)

	type public Number CTL

	type String FEE, XLN29, XLN29()

	if 'CTL.get() new MCND

	do XLN29(.ln, CID)

	set FEE = "" 
	for  set FEE = XLN29(FEE).order() quit:FEE.isNull()  do {
		set MCND(FEE) = XLN29(FEE) - XLN29(FEE).piece("|",4) - XLN29(FEE).piece("|", 5)
		}

	set return = XLN29 - XLN29.piece("|", 4) - XLN29.piece("|", 5)

	quit 
	

public UNMC(Number CTL,		// Control parameter		/NOREQ
	    Number CID)		// Account number

	/*
	Uncollected misc charge
	
	   Additional nmotes on ARGUMENTS:
	   . CTL
		 	0 - Do not "N"ew arrays
		 	1 - "N"ew arrays (currently used by BTTLN)
	*/
	
	type String XLN29, XLN29()
	
	set CTL = CTL.get()
	
	do XLN29(, CID)

	quit +XLN29.piece("|", 4)
	

public XLN29(RecordLN ln,		// Loan account			/REF:R
	     Number CID)		// Loan account number

	/*
	Calculate fee amounts
	
	Called directly from LNCO and internally from this procedure.
	
	Additional notes on ARGUMENTS:
	
	   . ln
	
	      Passing in the LN object will indicate that the current values
	      of the ln object should be used.  If no object is passed in, a
	      new ln object will be created.
 
	   . CID
	      If the CID number is passed in, the procedure will create a new
	      ln object based on this CID.  If the CID is Null and the object
	      has not been passed in, the system will create a new object based
	      on what is currently defined in CID.  If both ln object and CID
	      are passed in, procedure will use the existing ln object and
	      ignore the CID.	
	
	*/

	if 'ln.exists(), 'CID.get() quit ""
	if 'ln.exists() do XLN291(CID) quit

	do XLN29A(.ln, CID)

	quit


XLN291(Number CID)		// Account number

	// Creates an object if one doesn't exist

	type RecordLN ln = Db.getRecord("LN", "CID=:CID")

	do XLN29A(.ln, CID)

	quit


XLN29A(RecordLN ln,		// Loan Account			/REF:R
       Number CID)		// Loan account number
       
	/*
	Build XLN29 (loan fee data) string
	
	System Use - Miscellaneous Totals (LN.XLN29)
	
	Position:
	1 - Total Fees Due (LN.MCHG)
	2 - Miscellaneous Charge -- Year-to-Date (LN.MYTP)
	3 - Misc Charge Life (LN.MPL)
	4 - Uncollected Misc Charge (LN.UNMC)
	5 - Current Misc Charges (LN.CUMC)
	6 - Assessed Fees Financial YTD (LN.ASYTD)
	7 - Assessed Fees Life of Loan (LN.ASLF)
	8 - Assessed Fees Pr Financial Year (LN.ASPY)
	9 - Fee Amount Still Due
	10 - Misc Charge Prior Year (LN.MPY)
	11 - Assessed Fees Tax Year-to-date (LN.ASTYTD)
	12 - Assessed Fees Prior Tax Year (LN.ASPTY)
	13 - Paid Fess Tax Year To Date
	14 - Paid Fees Prior Tax Year
	*/

	type public Boolean ER = ""
	type public String XLN29 = "", XLN29()

	// Exclude Value Added Tax loan fees
	type DbSet ds = Db.selectDbSet("LNFEE", "CID=:CID")
	if ds.isEmpty() quit
	while ds.next() do {
		type RecordLNFEE lnfee = ds.getRecord("LNFEE")
		
		set XLN29(lnfee.feetyp).piece("|", 1) = lnfee.feerem
		
		set XLN29.piece("|", 1) = XLN29.piece("|", 1) + lnfee.feerem
		set XLN29.piece("|", 2) = XLN29.piece("|", 2) + lnfee.feeytd
		set XLN29.piece("|", 3) = XLN29.piece("|", 3) + lnfee.feelf
		set XLN29.piece("|", 6) = XLN29.piece("|", 6) + lnfee.asytd
		set XLN29.piece("|", 7) = XLN29.piece("|", 7) + lnfee.aslf
		set XLN29.piece("|", 8) = XLN29.piece("|", 8) + lnfee.aspy
		set XLN29.piece("|", 10) = XLN29.piece("|", 10) + lnfee.feepy
		set XLN29.piece("|", 11) = XLN29.piece("|", 11) + lnfee.astytd
		set XLN29.piece("|", 12) = XLN29.piece("|", 12) + lnfee.aspty
		set XLN29.piece("|", 13) = XLN29.piece("|", 13) + lnfee.feetytd
		set XLN29.piece("|", 14) = XLN29.piece("|", 14) + lnfee.feepty
		}

	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0", "CID=:CID", 1)
	if 'lnbil0.getMode() quit

	type String BIL0STR, BIL5STR, BILAMT, BILSTR, BIL(,), BL0, BRFAMT
	type String BIL5(,,), ELMNT, FEE = ""
	type Number BILSEQ, PC, SCHSEQ, SEQ
	type literal String TAB = $char(9)
			
	set BIL(CID, 0) = $$ELEMENT^BILFUNCS(.lnbil0)
	set BL0 = BIL(CID, 0)
	
	if ln.oseq < ln.schseq set SEQ = ln.oseq
	else  set SEQ = ln.schseq

	// Load BIL(,) for all applicable bills
	// Load BIL5(,,) for fees with Include Fee in Internal Bill Flag set (DUEAMT=1)
	for SCHSEQ = SEQ:1:ln.schseq do {
		type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:CID,SCHSEQ=:SCHSEQ", 1)
		if lnbil1.getMode() do {
			set BIL(CID, SCHSEQ) = $$BIL1ELE^BILFUNCS(.lnbil1)
			type DbSet ds = Db.selectDbSet("LNBIL5", "CID=:CID AND SCHSEQ=:SCHSEQ AND DUEAMT=1")
			while ds.next() do {
				type RecordLNBIL5 lnbil5 = ds.getRecord("LNBIL5")
				set BIL5(CID, SCHSEQ, lnbil5.feetyp) = lnbil5.bfamt_"|"_lnbil5.brfamt
				}
			}
		}
	
	set BILSEQ = ln.oseq - .000000000001
	for  set BILSEQ = BIL(CID, BILSEQ).order() quit:(BILSEQ.isNull()) ! (BILSEQ '< ln.schseq)  do {
		if BILSEQ '> 0 quit

		// Internal Bill for Loan Fees		
		set ELMNT = ""
		for  set ELMNT = BIL5(CID, BILSEQ, ELMNT).order() quit:ELMNT.isNull()  do {
			// Update Fee Amount Still Due
			set BRFAMT = BIL5(CID, BILSEQ, ELMNT).piece("|", 2)
			set XLN29(ELMNT).piece("|", 4) = XLN29(ELMNT).get().piece("|", 4) + BRFAMT
			set XLN29.piece("|", 4) = XLN29.piece("|", 4) + BRFAMT
			}

		// Fees specified in Internal Bill Control
		for PC = 2:1:BL0.length(TAB) set BIL0STR = BL0.piece(TAB, PC) if 'BIL0STR.isNull() do {
			set ELMNT = BIL0STR.piece("#", 1)

			// Exclude Interest, Principal, Late Charges, Value 
			// Added Tax, and Escrow bill elements
			if "-I-P-L-V".isLike("%-"_ELMNT_"-%") ! (BIL0STR.piece("#", 2)) quit

			// Update Fee Amount Still Due with Pmt Element - Amount Still Due
			set BILAMT = BIL(CID, BILSEQ).piece("|", PC).piece("#", 4)
			set XLN29(ELMNT).piece("|", 4) = XLN29(ELMNT).get().piece("|", 4) + BILAMT
			set XLN29.piece("|", 4) = XLN29.piece("|", 4) + BILAMT
			}
		}

	// For current scheduled sequence only
	if ln.schseq > 0 do {

		// Internal Bill for Loan Fees
		set ELMNT = ""
		for  set ELMNT = BIL5(CID, ln.schseq, ELMNT).order() quit:ELMNT.isNull()  do {
			set BRFAMT = BIL5(CID, ln.schseq, ELMNT).piece("|", 2)

			// Update Current Misc Charges with Fee Amount Still Due
			set XLN29(ELMNT).piece("|", 5) = XLN29(ELMNT).get().piece("|", 5) + BRFAMT
			set XLN29.piece("|", 5) = XLN29.piece("|", 5) + BRFAMT
			}

		// Fees specified in Internal Bill Control
		for PC = 2:1:BL0.length("|") do {
			set BIL0STR = BIL(CID,0).piece(TAB, PC) 
			set ELMNT = BIL0STR.piece("#", 1)

			// Exclude Interest, Principal, Late Charges, Value 
			// Added Tax, and Escrow bill elements
			if "-I-P-L-V".isLike("%-"_ELMNT_"-%") ! (BIL0STR.piece("#", 2)) quit

			// Update Current Misc Charges with Pmt Element - 
			// Amount Still Due
			set BILAMT = BIL(CID, ln.schseq).piece(TAB, PC).piece("#", 4)
			set XLN29(ELMNT).piece("|", 5) = XLN29(ELMNT).get().piece("|", 5) + BILAMT
			set XLN29.piece("|" ,5) = XLN29.piece("|", 5) + BILAMT
			}
		}

	// For all other applicable bills	
	for  set BILSEQ = BIL(CID, BILSEQ).order() quit:BILSEQ.isNull()  do {

		// Internal Bill for Loan Fees
		set ELMNT = ""
		for  set ELMNT = BIL5(CID, BILSEQ, ELMNT).order() quit:ELMNT.isNull()  do {
			set BIL5STR = BIL5(CID, BILSEQ, ELMNT)
			
			// Update Current Misc Charges with - (Fee Amount 
			// Original - Fee Amount Still Due)
			set XLN29(ELMNT).piece("|", 5) = XLN29(ELMNT).get().piece("|", 5) - (BIL5STR - BIL5STR.piece("|", 2))
			set XLN29.piece("|", 5) = XLN29.piece("|", 5) - (BIL5STR - BIL5STR.piece("|",2))
			
			// Update with Fee Amount Still Due
			set XLN29.piece("|", 9) = XLN29.piece("|", 9) + BIL5STR.piece("|", 2)
			}

		// Fees specified in Internal Bill Control
		for PC = 2:1:BL0.length(TAB) set BIL0STR = BL0.piece(TAB, PC) if 'BIL0STR.isNull() do {
			set ELMNT = BIL0STR.piece("#", 1)

			// Exclude Interest, Principal, Late Charges, Value 
			// Added Tax, and Escrow bill elements
			if "-I-P-L-V".isLike("%-"_ELMNT_"-%") ! (BIL0STR.piece("#", 2)) quit

			set BILSTR = BIL(CID, BILSEQ).piece(TAB, PC)
				
			// Update Current Misc Charges with - (Pmt Element 
			// Total Amount Billed - Pmt Element Total Amount Still Due)
			set XLN29(ELMNT).piece("|", 5) = XLN29(ELMNT).get().piece("|", 5) - (BILSTR.piece("#", 3) - BILSTR.piece("#", 4))
			set XLN29.piece("|", 5) = XLN29.piece("|", 5) - (BILSTR.piece("#", 3) - BILSTR.piece("#", 4))
				
			// Update with Fee Amount Still Due
			set XLN29.piece("|", 9) = XLN29.piece("|", 9) + BILSTR.piece("#", 4)
			}
		}

	quit


public EDV(CID)	// Computed operation [LN]XLN27 - Effective dated values.
 
	//  Returns WIRN array value of specified EFD.
	
	type public Boolean ER
 
	new UAVB,WIRN
	if '$G(%EffectiveDate) set %EffectiveDate=%SystemDate
	Type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	if %EffectiveDate<acn.odt quit ""
	do INIT^UAVB(.acn,CID,%EffectiveDate,%EffectiveDate,1000001)

	// Return nulls if UAVB returns error.
	if ER kill WIRN,RM set ER=0

	quit $G(WIRN(EFD))

        
public CNAMT(CID,FEETYP)    // Calculate computed - not assessed amount
        	
	type RecordLNFEEP lnfeep=Db.getRecord("LNFEEP","FEETYP=:FEETYP",1)
	if 'lnfeep.getMode() quit ""
        if 'lnfeep.basis.isNull() quit ""
        if (lnfeep.amth'=1),(lnfeep.amth'=3) quit ""
        if (lnfeep.dtst),(%SystemDate<lnfeep.dtst) quit ""
 
        type RecordLN ln=Db.getRecord("LN","CID=:CID")
	
	quit $$CNAMT2(.ln,.lnfeep)
	
        
CNAMT2(RecordLN ln,
	RecordLNFEEP lnfeep)
	
	type public String FEETYP
	type Date EFD
	type Number AMT,ARRAY(),FEEAMT,TAMT
	type String ELMNT,X
	
	set FEEAMT=""
	set AMT=""
	set ELMNT=""
	set EFD=%SystemDate
	
	#ACCEPT CR=7239;DATE=11/18/03;PGM=John Carroll
        set X="S TAMT=$$"_FEETYP_"^LNFEECMP(.ln)" xecute X
 
        set ARRAY(FEETYP)=ARRAY(FEETYP).get()+TAMT
        set ARRAY=ARRAY.get()+TAMT
	
        if lnfeep.amth do {	
		type RecordLNFEE lnfee=Db.getRecord("LNFEE","CID=:ln.cid,FEETYP=:FEETYP")
        	if lnfee.asnd'>lnfee.asld quit
        	set ARRAY(FEETYP)=(%SystemDate-lnfee.asld)/(lnfee.asnd-lnfee.asld)*(ARRAY(FEETYP).get())
        	set ARRAY(FEETYP)=ARRAY(FEETYP).roundCur(ln.crcd)
		}
        quit ARRAY(FEETYP).get()
	        
 #OPTION ResultClass ON
Public String vSIG()	quit "60817^19674^Senthilkumar Jeyaeasan^19548"	// Signature - LTD^TIME^USER^SIZE
