ANSIX92(IM)
	/*
	 Procedure ID: ANSIX92
	 DESC: MPS ANSI X9.2 Message Processor
	 ORIG: SIGDAE - 06/16/2000

	 This program re-formats ANSI X9.2 ATM messages received from the
	 network switch, "MPS", processes the transaction in PROFILE, and
	 builds the message structure expected back by the network switch.
	 ----------------------------------------------------------------------
	 This routine receives messages from the network switch in ASCII
	 characters and re-formats them into PROFILE structure for transaction
	 processing.
	
	 The messages are variable length, and the structure changes based on
	 the context of the message itself. Financial transaction messages
	 are similar, though not standard. In order to properly identify the
	 content of a particular message, a series of bitmaps are included
	 in the message. These bitmaps identify the data elements that are
	 contained in the message. Each bitmap is comprised of 16 hexadecimal
	 bytes, where each byte corresponds to 4 data elements that may appear
	 in the message.
	
	 Once the transaction is processed, an outgoing message is built
	 to be sent back to the ATM network.
	 ----------------------------------------------------------------------
	 Message Types:
	  *	Received from the network switch
	  **	Sent to the network switch

		*	0100	Pre-Authorization Request
		**	0110	Pre-Authorization Request Reply
		*	0120	Pre-Authorization Advice
		**	0130	Pre-Authorization Advice Reply

		*	0200	Financial Transaction Request
		**	0210	Financial Transaction Request Reply
		*	0220	Store and Forward Transaction Request
		**	0230	Store and Forward Transaction Reply

		*	0400	Transaction Reversal Request
		**	0410	Transaction Reversal Request Reply

		*	0700	Inquiry Request
		**	0710	Inquiry Request Reply

		*	0800	Network Management Request/Reply
	 ----------------------------------------------------------------------
	 The Online ATM processing is as follows:

	 The message is passed to an INCOMING subroutine, where the data
	 contained in the message is "translated" into local variables.

	 Once the message has been "translated", the transaction is then
	 processed using the local variables. If the message is a financial
	 transaction, the necessary variables are passed to a processing
	 subroutine, where PROFILE attempts to process the transaction. As
	 part of this process, the success or failure of the transaction is
	 determined.

	 The last step in this process is to construct an outgoing message
	 to be sent back to the network switch, "MPS". The outgoing message is
	 formatted using the information pertinent to the transaction and a
	 response code based on the success or failure of the transaction 
	 as determined by PROFILE.

	 There are four main line tags:
		INIT		- Initializes ATM and ANSIX92 variables
		INCOMING	- Receives and reformats incoming messages
		PROC		- Processes the transaction in PROFILE
		OUTGOING	- Reformats outgoing messages

	 There is one line tag that can be customized:
		GETBAL		- Balance Information
	 ----------------------------------------------------------------------
	 ---- Revision History ------------------------------------------------
	01/02/06 - chhabris - CR 18749
		   Removed "ORDER BY" from Db.select in the FINPRE section.

	09/26/05 - ALAGARSS - CR 16677
		   Removed deprecated method Db.getOneRow and replaced with
		   Db.getRecord. 
	 
	05/24/05 - RussellDS - CR16071
		   Converted M TP commands to PSL Runtime methods.
		   
		   Removed old revision history.

	 ----------------------------------------------------------------------
	*/
	type Public String RM,OM
	type Public Number ER
	type Number vtp
	new AMT2,ATMM,BIT,BCAL,BRCD,CODE,CRCD,CUTOFF,DELDUP,ETCCR,ETCDR
	new FCID,FINPRE,HLDID,INQUIRY,INTRFACE,MID,NETID,NETWORK,OMID
	new PAUTH,PC1,PCID,PHC,PHDAYS,POS,POSADJ,PRE,REV,RRC,RSPCD,RT
	new SAFUCLS,SPR,STF,TAMT,TBL,TCID,TCK,TCMT,TPD,TRACE,TRCD,TRTYP
	new TSO,VALID

	set ER=0,RM=""
	set RSPCD="500"				
	// Initialize to success
	set ATMM=$$NXTSEQ^ATMUTL()		
	// Unique message sequence
	set (FINPRE,INQUIRY,NETWORK,PCID,POS,POSADJ,PRE,REV,STF,VALID)=0
	set (AMT2,CODE,ETCCR,ETCDR,FCID,HLDID,MID,OMID,PC1,RRC,SPR)=""
	set (TAMT,TCID,TCK,TCMT,TPD,TRACE,TRCD,TRTYP,TSO)=""

	do INIT					
	// Initialize variables
	do INCOMING(IM,.TBL,.BIT)		
	// Format incoming message
	do PROC					
	// Process transaction
	do OUTGOING(.OM,.BIT)			
	// Build outgoing message
	
	// TRollback occured in application, issue new TStart
		
	set vtp = $Tlevel				// Is TP already on?
	
	if 'vtp do {
		do Runtime.start("CS", "*")
		do NSMLOG^PBSNSM("ANSIX92",ATMM,IM,OM,$E($G(RM),1,40))
		do Runtime.commit()
		}
	
	// Log Messages
	do NSMLOG^PBSNSM("ANSIX92",ATMM,IM,OM,$E($G(RM),1,40))
	quit OM
	

INIT
	/*
	 Initialize variables
	*/
	type Public String INTRFACE,TBL,CUTOFF,DELDUP,SAFUCLS,RT
	type Public Number BRCD,BCAL,PHC,PHDAYS,NETID
	new I

	type RecordUTBLEXTINT extint

	set INTRFACE="MPS"
	set extint=Db.getRecord("UTBLEXTINT","INTRFACE=:INTRFACE")
	
	#ACCEPT DATE=11/05/03;PGM=John Carroll
	set %SessionID=""			
	// Token, required for STFHOST
	set %UserID=extint.uid			
	// Teller id for ATM processing
	set BRCD=extint.brcd			
	// Branch code
	set SAFUCLS=extint.safucls		
	// Store and forward userclass
	set RT=extint.rt			
	// Hold table
	set BCAL=extint.bcal			
	// Business day calendar
	set NETID=extint.iin			
	// Network id
	set PHDAYS=extint.phdays		
	// Permanent hold days
	set PHC=extint.phc			
	// Permanent hold code
	set CUTOFF=extint.hldcuttim		
	// Hold Cutoff Time
	set DELDUP=extint.dupmsg		
	// Duplicate message option

	// Use default values if not defined
	if SAFUCLS="" do {
		type RecordCUVAR cuvar=Db.getRecord("CUVAR")
		set SAFUCLS=cuvar.dftstfucls
	}
	if SAFUCLS="" set SAFUCLS="MGR"		
	// Default store and forward userclass
	if PHC="" set PHC=92			
	// Default to 92
	if CUTOFF="" set CUTOFF=72000
	if DELDUP="" set DELDUP=1

	type RecordSCAU scau=Db.getRecord("SCAU","UID=:%UID")
	set %UserClass=scau.%ucls

	for I=1:1:128 set TBL(I)=""		  
	// Initialize TBL array

	set TBL(1)="21|N|Primary account number"  
	// Present in all financial transaction messages
	set TBL(2)="6|N|Processing code"	  
	// Present in all financial transaction messages
	set TBL(3)="8|N|Amount 1"
	set TBL(4)="8|N|Amount 2"
	set TBL(5)="8|N|Amount 3"
	set TBL(6)="6|N|Transaction Trace Number"
	set TBL(7)="4|D|Transaction Date"
	set TBL(8)="4|D|Terminal Cutoff Date"
	set TBL(9)="4|D|Transmission Date"
	set TBL(10)="6|N|Transaction Time"

	set TBL(13)="10|N|Terminal Owner ID"
	set TBL(14)="10|N|Cardholder Owner ID"
	set TBL(15)="3|N|Currency Code"

	set TBL(20)="2|N|Reason For Reversal Code"
	set TBL(21)="4|N|Original Message Type"

	set TBL(31)="7|T|Point of Transaction"
	set TBL(32)="3|N|Network Control Code"		
	// 800/810 only
	set TBL(33)="3|N|Response Code"
	set TBL(34)="25|T|Street Address"
	set TBL(35)="15|T|City/State"

	set TBL(39)="16|T|PIN Field"
	set TBL(40)="16|T|Password"			
	// 800/810 only

	set TBL(48)="40|T|Key Exchange"			
	// 800/810 only

	set TBL(50)="21|T|From Account Number"
	set TBL(51)="21|T|To Account Number"
	set TBL(52)="9|N|Date Information"
	set TBL(53)="6|T|Sharing Group"
	set TBL(54)="8|T|Owner IDs"
	set TBL(55)="8|T|Terminal Number"
	set TBL(56)="6|N|Terminal Sequence Number"
	set TBL(57)="20|T|Transaction Information One"
	set TBL(58)="20|T|Transaction Information Two"
	set TBL(59)="25|N|Geographic Point-of-Service Information and Sharing"

	set TBL(62)="39|T|Track II Information"
	set TBL(63)="22|T|Terminal Identifier"		
	// 15 + 7 leading "0"
	set TBL(64)="999|T|Variable Addenda"		
	// ******
	quit


INCOMING(IM,TBL,BIT)
	/*
	 Receives and parses incoming messages in variable "IM"
	 ARGUMENTS:
		. IM	Incoming message from the switch
		. TBL	Data element descriptions (see BITMAP section)
		. BIT	Data element values
	*/
	type Public String CRCD,RRC,OMID,%STFHOST,RSPCD,RM,MID
	type Public Number TAMT,AMT2,TRACE,SPR,STF,REV,VALID,NETWORK
	new BIT63,CRDNUM,CTY,CTYSTA,LEN,PRCD,STA,STREET,TRMNL,UTSO

	set IM=$E(IM,7,$L(IM))			
	// Strip message header
	set MID=$$BITMAP(IM,.TBL,.BIT)		
	// Set up array of data elements

	// Invalid transaction ~p1
	if "-0100-0120-0200-0220-0400-0420-0700-0800-"'[MID set VALID=0,RSPCD=$$RSPCD(1502,.RM,MID) quit
	set VALID=1				
	// Valid message id

	if $E(MID,2)="8" set NETWORK=1 quit	
	// Network transactions
	set NETWORK=0

	// Translate into return message ids for outgoing messages
	set OMID=MID				
	// Store original for return
	if MID="0100" set MID="0110"
	if MID="0120" set MID="0130",STF=1
	if MID="0200" set MID="0210"
	if MID="0220" set MID="0230",STF=1
	if MID="0400" set MID="0410",REV=1
	if MID="0700" set MID="0710"

	set %STFHOST=$G(%STFHOST)

	// Amount information
	set TAMT=BIT(3)/100			
	// Amount 1
	set AMT2=BIT(4)/100			
	// Amount 2
	set CRCD="USD"				
	// Currency code

	// Message information
	set SPR=(+BIT(10))_BIT(56)		
	// Transaction time & terminal sequence #
	set TRACE=+$G(BIT(6))			
	// Transaction trace number
	set RRC=$G(BIT(20))			
	// Reason for reversal code
	quit

PRCD	/*
	 Set up the process code and the transaction type (TRTYP).
	 The processing code contains three (3) pieces of information: the
	 transaction type or action code, the "from" account and the "to"
	 account.
	 	Transaction types:
	 	--------------
		10	Cash Withdrawal
		20	Deposit
		30	Balance Inquiry - ATM or POS
		40	Account Transfer
		70	POS Direct Debit
		71	POS Direct Credit
		72	POS Debit Inquiry
		73	POS Preauthorized Debit
		74	POS Preauthorized Request
		75	Check Card Purchase
		Account types:
		--------------
		0x	Checking
		1x	Savings
		4x	Installment Loan
		3x	Credit Card or Revolving Credit
		5x	Mortgage Loan
		6x	Certificate
	*/

	type Public Number ER,FINPRE,TSO,TCMT,ATMM,PRE,PAUTH,POSADJ,POS,PC1
	type Public Number CRDNUM,TRMNL,REV,STF,LEN 
	type Public String TRTYP,INQUIRY,ETCDR,ETCCR,TRCD,TCID,PCID,FCID,RSPCD
	type Public String INTRFACE,CODE,HLDID,UTSO,STREET,STA
	type Public String BIT63,BIT,CTYSTA,CTY,RM,PRCD
	
	type Public Cache %CACHE()

	// Define processing code. Default to checking if account type is "99"
	set PRCD=$G(BIT(2))
	if $E(PRCD,3,4)="99" set BIT(2)=$E(BIT(2),1,2)_"0100"
	if $E(PRCD,5,6)="99" set BIT(2)=$E(BIT(2),1,2)_"0001"

	set PC1=$E(PRCD,1,2)			
	// Transaction type

	if $E(PC1,1)=7 set POS=1		
	// POS
	if $E(PC1,1)=8 set POSADJ=1		
	// POS adjustments
	if PC1=73 set FINPRE=1			
	// Preauthorization debit
	if (PC1=74)!(PC1=75) set PRE=1		
	// Preauthorization

	// Define authorization hold id
	set BIT63=$$RTRIM^%ZS(BIT(63))		
	// Terminal id
	set LEN=$L(BIT63)
	set HLDID=$E(BIT63,(LEN-5),LEN)_+BIT(56)

	// Allow partial authorizations
	if PC1=74 set PAUTH=1
	else  set PAUTH=0

	// Default account type logic
	if (PC1'="71"),($E(PRCD,3,4)'="00"),(FCID'="") set PRCD=PC1_$$DEFAULT(FCID)_$E(PRCD,4,6) quit:ER	
	if (PC1="71"),($E(PRCD,5,6)'="00"),(FCID'="") set PRCD=$E(PRCD,1,4)_$$DEFAULT(FCID)_$E(PRCD,6) quit:ER
	if (PC1="40"),($E(PRCD,5,6)'="00"),(TCID'="") set PRCD=$E(PRCD,1,4)_$$DEFAULT(TCID)_$E(PRCD,6) quit:ER

	/*
	 Terminal Types
	 --------------
	 0 On-Us
	 1 Off-Us
	 7 Voice Responce

	 Determine ONUS/OFFUS for cash withdrawals, deposits, and transfers
		Card owner id - first 4 characters
		Terminal owner id - second 4 characters
	 Determine voice response for transfers
		Point of transaction - 07 voice response device
	*/
	set TRMNL=0
	if (PC1=10)!(PC1=20)!(PC1=40) do {
		if ($E(BIT(54),1,4)'=$E(BIT(54),5,8)) set TRMNL=1 quit
		if PC1=40,$E($G(BIT(31)),1,2)="07" set TRMNL=7 quit
		}

	set CODE=PC1_$E(PRCD,3)_$E(PRCD,5)_TRMNL
	set TRCD=$$GETTRN^ATMUTL(INTRFACE,CODE,STF)  
	if ER set RSPCD=$$RSPCD(RSPCD,.RM) quit

	// Determine accounts to use
	set FCID=+$E(BIT(50),3,$E(BIT(50),1,2)+2)	
	// Get "from" account
	set TCID=+$E(BIT(51),3,$E(BIT(51),1,2)+2)	
	// Get "to" account

	if PC1'=20,PC1'=71 set PCID=FCID
	else  set PCID=TCID

	// Transaction information
	set TRTYP=$P(TRCD,$C(9),1)

	// Determine if PCID is a valid PROFILE account
	if 'Db.isDefined("DEP","PCID") do {  quit:ER
		// Invalid FROM account number ~p1
		if 'STF set RSPCD=$$RSPCD(2095,.RM,PCID) quit
		if FCID'=0 quit
		if TRTYP'="CREDIT" set FCID="NULL"	    
		// Must process if STF
		else  set TCID="NULL"
		}

	if TRTYP="INQUIRY" set INQUIRY=1 quit	    
	// Account balance inquiry

	// If transfer, determine if TCID is a valid PROFILE account
	if PC1=40,'Db.isDefined("DEP","TCID") do {  quit:ER
		// Invalid FROM account number ~p1
		if 'STF set RSPCD=$$RSPCD(2095,.RM,TCID) quit
		if TCID=0 set TCID="NULL"	    
		// Must process if STF
		}

	// Debit and Credit transaction codes
	set ETCDR=$P(TRCD,$C(9),2)		    
	// Debit transaction code
	set ETCCR=$P(TRCD,$C(9),3)		    
	// Credit transaction code
	// Invalid transaction code ~p1
	if (ETCDR="")!(ETCCR="") set RSPCD=$$RSPCD(1498,.RM) quit

	/*
	 Determine default accounts based on first one with a value
		TRN.ACN		Default Account Number
		SCAU.TSDR	Transaction Suspense (DR)
		SCAU.TSCR	Transaction Suspense (CR)
		CUVAR.GLTS	Transaction Suspense
	*/
	if FCID=0 do {  if ER quit
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETCDR")
		set FCID=$$GLACN^TRNUTL(.trn,%UserID)
		// Invalid bank G/L account number
		if ER set RSPCD=$$RSPCD(1268,.RM)
		}
	if TCID=0 do {  if ER quit
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETCCR")
		set TCID=$$GLACN^TRNUTL(.trn,%UserID)
		// Invalid bank G/L account number
		if ER set RSPCD=$$RSPCD(1268,.RM)
		}

	set CRDNUM=$E(BIT(1),3,$E(BIT(1),1,2)+2)    
	// Primary card number
	set %UserStation="ATM-"_BIT63

	if REV quit				    
	// Finish processing in PROC

	// REG E information
	set STREET=$$RTB^%ZFUNC($G(BIT(34)))	    
	// Street address
	set CTYSTA=$G(BIT(35))			    
	// City/state
	set CTY=$$RTB^%ZFUNC($E(CTYSTA,1,13))	    
	// City
	set STA=$E(CTYSTA,14,15)		    
	// State
	set TCMT=STREET_" "_CTY_", "_STA	    
	// Teller comment

	// Build TSO field
	set UTSO("ATM")=BIT63			   
	// Terminal id
	set UTSO("ATMC")=CRDNUM			    
	// Primary card number
	set UTSO("ATMD")=$$JD^ATMUTL($G(BIT(7)))    
	// ATM transaction date
	set UTSO("ATMM")=ATMM			    
	// ATM message sequence
	set UTSO("TRNTYPE")=$S(POS:"POS",1:"ATM")   
	// Transaction type
	set UTSO("AD1")=STREET			    
	// Terminal street address
	set UTSO("CITY")=CTY			    
	// Terminal city
	set UTSO("STPRV")=STA			    
	// Terminal state
	do IN^UTSO(.UTSO,.TSO)

	quit


PROC
	/*
	 Process message
	*/
	type Public String CRCD,HLDID,RT,RSPCD,RM,NETWORK,INQUIRY
	type Public Number AMT2,FCID,TCID,PC1,ETCDR,ETCCR,TSO,TAMT,TCMT,PCID,VALID
	type Public Number POSADJ,BRCD,REV,PRE,FINPRE,BCAL,ATMM,TRACE,STF,SPR,ER
	new ttx,EFD,TPD

	type RecordTTX ttx()

	quit:ER					
	// Error already occurred
	quit:'VALID				
	// Invalid message type
	quit:INQUIRY				
	// Inquiry message
	quit:NETWORK				
	// Network message

	// Check the account's history for a duplicate message
	if STF,$$STFCHK^ATMUTL(PCID,SPR,TRACE,PRE,REV,FINPRE,ATMM,1) quit

	// Determine teller post date
	set TPD=$$TLRPDT^ATMUTL(BCAL,BRCD,.EFD)
	if ER set RSPCD=$$RSPCD("05") quit
	set ER=0,RM=""

	if REV do ATMREV quit			
	// Handle reversals separately
	if POSADJ do POSADJ quit		
	// Point of sale adjustments

	// Build transaction and offset transaction
	do TTX^ATMUTL(.ttx(),FCID,ETCDR,TAMT,EFD,TSO,TCMT,SPR,CRCD)
	do TTX^ATMUTL(.ttx(),TCID,ETCCR,TAMT,EFD,TSO,TCMT,SPR,CRCD)

	// Update check hold transaction if financial deposit
	if PC1=20 do CKTRN^ATMUTL(.ttx(),TSO,RT)
	if ER quit

	// Process the transactions
	do POST(.ttx(),PCID,.TAMT,TCMT,SPR,HLDID,AMT2,TSO)
	set RSPCD=$$RSPCD(RSPCD,.RM)

	quit 


POST(RecordTTX ttx(),CID,TAMT,TCMT,SPR,HLDID,AMT2,TSO)
	/*
	 Messages coming in as ADVICES have already been processed by the
	 ATM switch and must be processed as store and forward transactions
	 on PROFILE. This means that store and forward transactions MUST be
	 successfully processed on PROFILE since the transaction has already
	 been approved by the ATM switch. The supervisory override array,
	 TSPV, is set up so the PROFILE ATM teller has authorization over
	 all generated transactions. Also, bit 10 of ITC for each transaction
	 is turned on indicating that the transaction is off-line.
	 ARGUMENTS:
		CID	- PROFILE account number
		TAMT	- Transaction amount
		TCMT	- Transaction comment
		SPR	- Spray value
		HLDID	- Authorization hold id
		AMT2	- Correction amount
		TSO	- Transaction source of funds
	 INPUTS:
		ATMM	- Unique message sequence
		BRCD	- Branch code
		FINPRE	- POS preauthorized debit flag
		PHC	- Permanent hold code
		PHDAYS	- Permanent hold days
		PRE	- Preauthorization flag
		REV	- Reversal flag
		SAFUCLS	- PROFILE store and forward userclass
		STF	- ATM switch store and forward flag
		TPD	- Teller posting date
		TRTYP	- Transaction type
	*/
	type Public String CRCD,TRTYP,PHC,SAFUCLS,RSPCD
	type Public Number FINPRE,ER,BRCD,REV,PRE,STF
	type Public Date TPD
	new PAMT,TSPV

	set RSPCD="00"

	if STF set %UserClass=SAFUCLS
	set TSPV("*")=%UserID_"|"_%UserClass

	// Pre-authorizations place a hold
	set PAMT=""
	if PRE,'REV do ATMPRE^ATMUTL(.ttx(),CID,CRCD,TCMT,SPR,HLDID,TSO,TPD,BRCD,STF,1,.PAMT) quit
 
	// Remove hold if one exists
	if FINPRE,'REV do FINPRE(CID,HLDID,PHC,STF,TRTYP) quit:ER
	
	do POST^ATMUTL(.ttx(),CID,TPD,BRCD,.TSPV,STF)

	// Partial authorization
	if PAMT'="" set TAMT=PAMT

	quit


ATMREV
	/*
	 Reversal transactions
	 Reverse the original transaction. If the original amount was
	 incorrect, then process the transaction with the correct amount
	 after the original is reversed.
	 INPUTS:
		ATMM	- Unique message sequence
		AMT2	- Correction amount
		PCID	- PROFILE account number
		FINPRE	- POS preauthorized debit flag
		HLDID   - Authorization hold id
		PHC	- Permanent hold code
		PHDAYS	- Permanent hold days
		POSADJ	- POS adjustment flag
		PRE	- Preauthorization flag
		REV	- Reversal flag
		RRC 	- Reason for reversal code
		  00 Normal Completion
		  01 Time-out
		  02 Invalid response
		  03 Destination not available
		  07 Clerk cancelled transaction
		  08 Customer cancelled transaction
		  09 Original transaction amount incorrect, over/under dispense
		  10 Hardware failure
		  11 Original transaction amount incorrect, multi-check deposit
		  12 Original transaction amount incorrect, pre-authorized purchase
		SAFUCLS	- PROFILE store and forward userclass
		SPR	- Spray value
		STF	- ATM switch store and forward flag
		TAMT	- Transaction amount
		TCMT	- Transaction comment
		TRTYP	- Transaction type
	*/
	type Public Number ATMM,TSO,TCMT,PRE,ER,BRCD,SPR,HLDID,TAMT,POSADJ
	type Public Number PCID,AMT2
	type Public String RSPCD,RM,TRTYP,RRC
	new PARTIAL

	// Determine if it's a partial reversal
	if AMT2'=0,TAMT'=AMT2,'POSADJ,((RRC="09")!(RRC=11)!(RRC=12)) set PARTIAL=1
	else  set PARTIAL=0

	type RecordTTX ttx()

	do REV^ATMUTL(.ttx(),PCID,AMT2,SPR,HLDID,TRTYP,ATMM,BRCD,1,PARTIAL)
	if ER set RSPCD=$$RSPCD(RSPCD,.RM) quit

	if PRE quit

	// Process the transactions
	do POST(.ttx(),PCID,TAMT,TCMT,SPR,HLDID,AMT2,TSO)
	set RSPCD=$$RSPCD(RSPCD,.RM)
	if 'ER set RSPCD=501			
	// Return no balances

	quit 


POSADJ
	/*
	 Adjustments
	 Debit adjustments - if the original amount is less than the actual
	 amount, then an additional debit is required. However, if the
	 original amount is more than the actual amount, then an additional
	 credit is required. If a credit is required, then the credit
	 transaction codes are used.
	 Credit adjustments - if the original amount is less than the actual
	 amount, then an additional credit is required. However, if the
	 original amount is more than the actual amount, then an additional
	 debit is required. If a debit is required, then the debit
	 transaction code are used.
	 INPUTS:
		AMT2	 - Original transaction amount
		ATMM	 - Unique sequence number
		BRCD	 - Branch code
		CODE	 - External interface transaction code key
		FCID	 - From account number
		FINPRE	 - POS preauthorized debit flag
		HLDID    - Authorization hold id
		INTRFACE - Interface name (MPS)
		PHC	 - Permanent hold code
		PHDAYS	 - Permanent hold days
		PRE	 - Preauthorization flag
		REV	 - Reversal flag
		SAFUCLS	 - PROFILE store and forward userclass
		SPR	 - Spray value
		STF	 - ATM switch store and forward flag
		TAMT	 - Transaction amount
		TCID	 - To account number
		TCMT	 - Transaction comment
		TPD	 - Teller posting date
		TRCD	 - Transaction codes
		TRTYP	 - Transaction type
		TSO	 - Transaction source of funds
	*/
	type Public Date EFD
	type Public Number HLDID,CRCD,TSO,TCMT,SPR,TCID,FCID,PCID,STF
	type Public Number ER,TAMT,RSPCD,AMT2
	type Public String ETC1,ETC2,INTRFACE,TRTYP,TRCD,CODE,RM
	new ttx,AMT,ETC,ETCCR,ETCDR,PC1,TMP

	type Public Cache %CACHE()
	type RecordTTX ttx()

	// The original amount is required and must not equal the current amount
	// Invalid transaction amount
	if (AMT2="")!(AMT2=TAMT) set RSPCD=$$RSPCD(6070,.RM) quit

	// Determine transaction amount, transaction codes, transaction accounts
	if AMT2>TAMT do {  if 1
		set AMT=AMT2-TAMT
		set PC1=$E(CODE,1,2)		  // Transaction type
		if TRTYP="DEBIT" set TMP=$S(PC1=82:80,PC1=85:84,1:86)  if 1
		else  set TMP=$S(PC1=80:82,PC1=84:85,1:87)
		set CODE=TMP_$E(CODE,3,$L(CODE))  // Replace transaction type
		set TRCD=$$GETTRN^ATMUTL(INTRFACE,CODE,STF)
		if ER set RSPCD=$$RSPCD(RSPCD,.RM) quit
		set ETC1=$P(TRCD,$C(9),3),ETC2=$P(TRCD,$C(9),2)
		set ETCDR=$P(TRCD,$C(9),2),ETCCR=$P(TRCD,$C(9),3)
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETCDR")
		set FCID=$$GLACN^TRNUTL(.trn,%UserID)
		set TCID=PCID
		}
	else  do {				  
		// Original was less than current amount
		set AMT=TAMT-AMT2
		set ETCDR=$P(TRCD,$C(9),2),ETCCR=$P(TRCD,$C(9),3)
		}
	quit:ER

	// Build transaction and offset transaction
	do TTX^ATMUTL(.ttx(),FCID,ETCDR,AMT,EFD,TSO,TCMT,SPR,CRCD)
	do TTX^ATMUTL(.ttx(),TCID,ETCCR,AMT,EFD,TSO,TCMT,SPR,CRCD)

	// Process the transactions
	do POST(.ttx(),PCID,AMT,TCMT,SPR,HLDID,AMT2,TSO)
	set RSPCD=$$RSPCD(RSPCD,.RM)

	quit 


FINPRE(CID,HLDID,PHC,STF,TRTYP)

	/*
	Completions to previously placed pre-authorization holds.
	Delete PHLD and ATMHLD entries.

	ARGUMENTS:
		CID	- PROFILE account number
		HLDID	- Hold ID
		PHC	- Permanent hold code
		STF	- ATM switch store and forward flag
		TRTYP	- Transaction type
	*/

	new EXPDT,SEQ

	// Posted to suspense
	if STF,TRTYP["SUSP" quit

	type ResultSet rs
 
	// Delete PHLD and ATMHLD records
	set SEQ=""
	set rs=Db.select("SEQ,EXPDT","PHLD","CID=:CID AND PHC=:PHC AND AUTCODE=:HLDID","SEQ DESC")
	if 'rs.isEmpty(),rs.next() set SEQ=rs.getCol("SEQ"),EXPDT=rs.getCol("EXPDT")

	// No hold exists
	if SEQ="" quit

	// Remove the hold
	do Db.delete("PHLD","CID=:CID AND SEQ=:SEQ")
	do Db.delete("ATMHLD","EXPDT=:EXPDT AND CID=:CID AND SEQ=:SEQ")
 
	quit
	

RSPCD(CODE,RM,ARG1,ARG2)
	/*
	 Translate CHKRSP^ATMUTL codes into MPS codes

	 Incoming codes:
		. 00	- Transaction Approved - With Balances
		. 10	- Partial Preautorization
		. 1244	- Insufficient Funds
		. 3764	- Error Posting Transactions.

	 Outgoing codes:
		. 500 Transaction Approved - With Balances
		. 504 Transaction Approved - Approved for Partial Amount
		. 556 Transaction Denied - Account Problem
		. 558 Transaction Denied - Insufficient Funds (Negative Bal)
		. 559 Transaction Denied - Insufficient Funds (Positive Bal)
	*/
	type Public Number ER
	
	if CODE="00" quit 500

	// Not partial pre-auth
	if CODE'="10" set ER=1

	if $L(CODE)>2 set RM=$$^MSG(CODE,$G(ARG1),$G(ARG2))

	// Don't respond with default error response for partial authorization
	if CODE="05" quit 555
	if CODE=10 quit 504

	if CODE=1244 quit 559		
	// Insufficient funds
	if CODE=1268 quit 555		
	// Invalid bank G/L account number
	if CODE=1427 quit 557		
	// Invalid process ID
	if CODE=1498 quit 555		
	// Invalid transaction code ~p1
	if CODE=1502 quit 557		
	// Invalid transaction ~p1
	if CODE=2095 quit 556		
	// Invalid FROM account number ~p1
	if CODE=2676 quit 556		
	// Transaction already error-corrected
	if CODE=2793 quit 556		
	// Unable to locate transaction in account history
	if CODE=3764 quit 556		
	// Error Posting Transactions.
	if CODE=6070 quit 556		
	// Invalid transaction amount

	quit 556


BALFMT(BAL)
	/*
	 Format balance fields with leading zeros and sign
	*/

	new FILL

	set FILL="00000000"			
	// Field length is 8
	set BAL=(BAL*100)\1
	if BAL<0 set BAL=$TR(BAL,"-",0) set BAL="-"_$E(FILL,1,7-$L(+BAL))_+BAL
	else  set BAL=$E(FILL,1,8-$L(+BAL))_+BAL
	if $L(BAL)>8 set BAL="99999999"

	quit BAL


DEFAULT(CID)
	/*
	 Determine account type
	*/
	type Public Number RSPCD,ER
	type Public String RM
	
	type RecordACN acn

	// Invalid account ~p1
	if CID="" set ER=1,RM=$$^MSG(1259),RSPCD=556 quit
	if 'Db.isDefined("ACN","CID") set ER=1,RM=$$^MSG(1259,CID),RSPCD=556 quit

	set acn=Db.getRecord("ACN","CID=:CID")
	quit $S(acn.grp="DDA":0,acn.grp="SAV":1,acn.grp="RC":3,acn.grp="MTG":5,acn.grp="CD":6,1:0)


OUTGOING(OM,BIT)
	/*
	 Format outgoing message to be sent back to the switch network
	 ARGUMENTS:
		. BIT	Parsed message array
	 OUTPUT:
		. OM	Outgoing message
	*/
	type Public Number ATMM,TAMT,POS,PC1,OMID,STF,REV,POSADJ,ER,RSPCD,PCID
	type Public Number NETID,INQUIRY,VALID,NETWORK,MID,IM
	type Public String RM
	new BAL,BALAVL,DESC,PROC,SORT

	if 'VALID set OM=$$INVALID(MID,IM,.BIT) quit  
	// Invalid message id
	if NETWORK set OM=$$800(IM,NETID,.BIT) quit   
	// Network management
	if INQUIRY do {				      
		// Inquiry request
		// Invalid FROM account number ~p1
		if PCID=0 set RSPCD=$$RSPCD(2095,.RM) quit
		if 'Db.isDefined("DEP","PCID") set RSPCD=$$RSPCD(2095,.RM)
		}

	// Unknown error
	if ER,$E(RSPCD,2)'>0 do {
		set RSPCD=$$RSPCD("05")
		// Log a dayend exception error
		set PROC="ANSIX92"
		set SORT="*"
		set DESC="MPS ANSI X9.2 Message Processor"
		do LOG^UTLEXC(PROC,SORT,DESC,PCID,ATMM,$G(RM))
		}

	// Get balance information
	if 'REV,'STF,'POSADJ do {
		#if $$VALID^%ZRTNS("ZANSIX92")
		 do GETBAL^ZANSIX92(PCID,TAMT,PC1,POS,.BAL,.BALAVL)
		#else
		 do GETBAL(PCID,TAMT,PC1,POS,.BAL,.BALAVL)
		#endif
		set BIT(4)=$$BALFMT(BAL)
		set BIT(5)=$$BALFMT(BALAVL)
		}

	set BIT(21)=OMID			
	// Original message id
	set BIT(33)=RSPCD			
	// Response code
	set BIT(52)="1"_$$DAT^%ZM(%SystemDate,"MMDD")_$E(BIT(52),6,9)

	set OM=$$BLDOM(MID,.BIT)		
	// Build outgoing message

	quit 
	

INVALID(MID,IM,BIT)
	/*
	 Build outgoing message for invalid message id
	 ARGUMENTS:
		MID	Message id of incoming message
		IM	Incoming message
		BIT	Parsed message array
	 OUTPUT:
		Outgoing message
	*/

	new I,LEN,OM
	set I=""

	if $D(BIT(33)) set BIT(33)=557
	set OM=MID_$E(IM,5,20)
	for  set I=$O(BIT(I)) quit:I=""  set OM=OM_BIT(I)
	set LEN=$L(OM)

	quit "H"_$E("0000",1,4-$L(LEN))_LEN_"D"_OM


GETBAL(CID,TAMT,PC1,POS,BAL,BALAVL)
	/*

	 Determine account balances

	 This section can be customized by copying ANSIX92 to ZANSIX92.

	 Variable BAL will be mapped to Bit 4, and BALAVL will be mapped
	 to Bit 5 in the response message.

	 ARGUMENTS:
		CID	PROFILE account number
		TAMT	Transaction amount
		PC1	Transaction type
		POS	Point of sale indicator
	 OUTPUTS:
		BAL	Ledger balance, authorized amount, or maximum authorizable
		BALAVL	Account available balance
	 INPUTS:
		RSPCD	Response code
	*/
	type Public Number RSPCD,ER
	type Public String RM
	new data,ERROR

	set ERROR=$G(ER)
	new ER set ER=0

	set (BAL,BALAVL)=""

	// Invalid FROM account number ~p1
	if +CID=0 set:$G(RSPCD)=500 RSPCD=$$RSPCD(2095,.RM) quit
	if 'Db.isDefined("DEP","CID") set:$G(RSPCD)=500 RSPCD=$$RSPCD(2095,.RM) quit

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	set BAL=dep.bal
	set BALAVL=dep.balavl

	// Use TAMT as authorized amount when POS and no error occurs
	set BAL=$S('POS!(PC1=71)!(PC1=73):BAL,'ERROR:TAMT,BALAVL'<TAMT:TAMT,1:BALAVL)

	quit 


BLDOM(MID,BIT)
	/*
	 Build the outgoing message
	 ARGUMENTS:
		MID	Outgoing message id
		BIT	Parsed message array
	 OUTPUT:
		Outgoing response message
	*/

	new BM,LEN,OM

	set BM="FFCE1802E2007FE6"
	set OM=BIT(1)_BIT(2)_BIT(3)_BIT(4)_BIT(5)_BIT(6)_BIT(7)_BIT(8)	   
	// FF
	set OM=OM_BIT(9)_BIT(10)_BIT(13)_BIT(14)_BIT(15)_BIT(20)_BIT(21)   
	// CE18
	set OM=OM_BIT(31)_BIT(33)_BIT(34)_BIT(35)_BIT(39)		   
	// 02E200
	set OM=OM_BIT(50)_BIT(51)_BIT(52)_BIT(53)_BIT(54)_BIT(55)_BIT(56)  
	// 7F
	set OM=OM_BIT(57)_BIT(58)_BIT(59)_BIT(62)_"0000000"_BIT(63)	   
	// E6
	set OM=MID_BM_OM

	// Add message header
	set LEN=$L(OM)
	quit "H"_$E("0000",1,4-$L(LEN))_LEN_"D"_OM


800(IM,NETID,BIT)
	/*
	 Network management transactions
	 ARGUMENTS:
		IM	Incoming message
		NETID	Network id
		BIT	Parsed message arrary
	 OUTPUT
		Network response message
	*/

	new PASS

	set PASS=$G(BIT(40))			
	// Password
	// Response from P/A generated message
	if $E(PASS,1,4)=NETID quit ""
	
	// Quit with original message
	quit IM

	
GENNET(CODE,NETID,KEYEX)
	/*
	 Generate an outgoing network message requests (unsolicited)
	 ARGUMENTS:
		CODE	Network message code
			"001"	- Sign on request
			"002"	- Sign off request
			"101"	- PIN Encryption Key Change
			"102"	- PIN Encryption Key Change Request
			"301"	- Echo test
		NETID	Network id
		KEYEX	Key exchange
	*/

	new BM,DATE,MID,PWRD,TIME,TRACE

	if $G(KEYEX)="" set KEYEX="000000000000000",BM="04C0000101000000"
	else  set BM="04C0000101010000"

	set NETID=$G(NETID,"    ")
	if $G(CODE)="" set CODE="001"
	set MID="0800"
	set TRACE="000000"
	set DATE=$$DAT^%ZM(%CurrentDate,"MMDD")
	set TIME=$$TIM^%ZM(%CurrentTime,"2460SS")
	set PWRD=NETID_"000000000000"

	quit MID_BM_TRACE_DATE_TIME_CODE_PWRD_KEYEX


BITMAP(msg,TBL,BIT)
	/*
	 Translates data stored in 'msg' into individual fields BIT(n),
	 based on the bitmap which is present in the message. The bitmap
	 is a set of ASCII characters representing binary data.
	 (e.g., 0="0000", 1="0001", ..., F="1111")
	 ARGUMENTS:
		msg	Message to parse
		TBL	Field definition array where
			TBL(field)=length|type|description
	 OUTPUT:
		MID	Message id
		BIT	Parsed array of msg
	*/

	new BM,BMLEN,BVAL,END,FLD,I,ID,LEN,MAP,MID,STR

	kill BIT				      
	// Clean out BIT array
	set MID=$E(msg,1,4)			      
	// Define message id

	if $E(MID,2)'=3 set BM=$E(msg,5,20),BMLEN=16  
	// Primary bitmap only
	else  set BM=$E(msg,5,36),BMLEN=32	      
	// Primary and secondary

	set STR=21,FLD=1
	for BVAL=1:1:BMLEN set MAP=$$MAP($E(BM,BVAL)) do {
		if 'MAP set FLD=FLD+4 quit	      
		// '0000', so skip all
		for I=8,4,2,1 do {
			set LEN=$P(TBL(FLD),"|",1)
			if MAP\(I#2) set BIT(FLD)=$E(msg,STR,STR+LEN-1),STR=STR+LEN
			set FLD=FLD+1		      
			// Increase field counter
			}
		}
	if $D(BIT(63)) set BIT(63)=$E(BIT(63),8,22)   
	// Remove filler

	if $G(BIT(64))'="" do {
		set STR=1,END=2
		for  set ID=$E(BIT(64),STR,END) quit:ID=99!(ID="")  do {
			set LEN=$E(BIT(64),END+1,END+3)
			set BIT(64,ID)=$E(BIT(64),END+4,LEN+END+3)
			set STR=LEN+END+4,END=STR+1
			}
		}
	quit MID


MAP(BYTE)
	/*
	 Translate bitmap byte (0-9,A-F) to decimal
	*/

	quit $S(BYTE:BYTE,BYTE=0:0,1:$A(BYTE)-55)
	

DELHLDS
	/*
	 Delete daily holds
	*/
	type Public String VFMQ
	new rs,%READ,%TAB,CID,DATE,SEQ

	type ResultSet rs

	set DATE=%SystemDate+1
	set %TAB("DATE")="/DES=Hold Expiration Date/TYP=D/LEN=10"

	set %READ="@@%FN/CEN/REV,,DATE/REQ"

	do ^UTLREAD quit:VFMQ="Q"

	set rs=Db.select("CID,SEQ","ATMHLD","EXPDT=:DATE") 
	if 'rs.isEmpty() while rs.next() do {
		set CID=rs.getCol(1)
		set SEQ=rs.getCol(2)
		do Db.delete("PHLD","CID=:CID AND SEQ=:SEQ")
		}
	quit 
	

DEL92
	/*
	 Delete all MPS daily holds
	*/

	do Db.delete("PHLD","PHC=92") 
	quit 
	

ZT
	/*
	 Error trap - called from PBSNSM
	*/
	type Public String vzpkt,RM
	type Public Number ATMM
	
	set ATMM=$$NXTSEQ^ATMUTL()
	set RM=$ZS
	do NSMLOG^PBSNSM("ANSIX92",ATMM,$G(vzpkt),RM,$E(RM,1,40))

	quit ""
 #OPTION ResultClass ON
Public String vSIG()	quit "60274^26031^Sanjay Chhrabria^30509"	// Signature - LTD^TIME^USER^SIZE
