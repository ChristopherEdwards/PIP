private	RECALCFS(RecordDEP dep,		// Deposit account		/REF:R
		 RecordTTX ttx,		// Primary transaction		/REF:R
		 Date %EffectiveDate,	// Effective date
		 Number NPOSADJ,	// Net positive acr adj		/REF:W
		 Number NNEGADJ,	// Net negative acr adj		/REF:W
		 String INDXMC,		// Mass interest change
		 Number NBWAADJ)	// Net backup w/h amount adj	/REF:W

	/*
 	 PROCEDURE ID:	RECALCFS
 	     Original:	RUSSELL
		 Date:	03/13/94	
 	         Desc:	Fast Recalc - within five days of system date
 
 	---- Comments --------------------------------------------------------
 
	Attempts to perform a fast recalculation without reference to
	account's history. Only possible if effective date no more
	than five days ago.

	NOTE: Call to ADJ^RECALCFS is made by RECALC if the fast RECALC was not
	used. It updates the DBI, DAA, and CMP fields so that RECALCFS can be 
	used for later effective dated transactions.

	Additional notes on ARGUMENTS:

		. INDXMC
			Indicates if call is due to an index mass change 
			(^INDEXMC), and	if so, holds the index being changed.

	INPUTS:
		. All variables from INIT^RECALC section

	RETURNS:
		. $$  FASTCALC worked  			TYP=L
			0 - didn't work, use old method
			1 - worked, or failure but old method won't work either
		. ER  Error flag
		. RM  Return message if ER
 	
 	---- Revision History ------------------------------------------------

	07/16/07 - NATRAJAH - CR 28219
		   Modified GETTAMT section to change the condition check to
		   negate the existing condition for ttx.itc1, since the 
		   condition check should be for debit transaction.

	06/12/07 - Chaithra - CR 27169
		   Modified LOADFM section so that the file maintenance that occurred 
		   on %SystemDate is not reversed and reapplied. Previously, file 
		   maintenance on %SystemDate was being reversed but not reapplied, 
		   and later filed as the old value.
	
	05/03/06 - SmithCD - CR 21007
		   . Replaced origdep with dep so interest rate changes stick 
		     to the account
		   . Modified to update RATECHG() when applicable by calling 
		     FMIRN^RECALC (previously rate changes were not getting 
		     into account history)
		   . Cleaned up procedure

 	10/14/05 - Srinivar - CR 16890
 		   Retrofitted the following from p01:
			04/22/03 - STATTOND - CR2916.
		   Modified section FASTOK to quit with a value of 0 if
		   DEP.GRP="ESC". Escrow accounts should not be updated 
		   directly but instead updated through the associated 
		   loan account.		

        08/18/05 - S.Krishnan- CR16724
	           Corrected the scope of the label ADJ^RECALFS as private.

        08/11/05 - S.Krishnan- CR16724
		   Modified type for TAMTACR in the section CMPADJ to be 
		   public.

        07/26/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.
	*/

	type public Number ADJUNC,AUTOD,AWTP,BWF,ER,IOPT,IRCB,ITRF,MINOPT,MINACR
	type public Number NEGITRF,NEGMININ,ODLIM,RESIDUAL,UNCPST
	type public String AWTI,DCF,DRC,IACM,ICF,INTFRE,IPF,ODTERM
	type public Date DELDT,ICHND,SND

	type Number CMPDNG=0,TAMTACR,TAMTPR,XMINACR
	type Date DATE
	type String FM(,)

	// Initialize return parameters
	set ER=0
	set NNEGADJ=0
	set NPOSADJ=0
	set NBWAADJ=0

	// Daily or continuous compounded
	if DCF!(IACM.extract(1)=2) set CMPDNG=1

	// See if fast method OK
	if '$$FASTOK(.dep) quit 0

	// Get transaction amount
	do GETTAMT(.dep,.ttx,.TAMTPR,.TAMTACR)

	// See if dates allow fast method
	if '$$EFDOK(.dep) quit 0

	set XMINACR=$$GETMACR(.dep,%EffectiveDate)

	// Load file maintenance, if any and see if invalid data items
	do LOADFM(.dep,%EffectiveDate+1,0)
	// ER=2 => recalc ok but not fast
	if ER set:ER=2 ER=0 quit 0

	// Reverse all file maintenance
	do REVFM(.dep,"","")

	// Calculate one day at a time
	for DATE=%EffectiveDate:1:%SystemDate-1 do { quit:ER

		type Number NEWACR,NEWAWT,NEWBI,OLDACR,OLDAWT,OLDBI

		// Reapply file maintenance
		if FM(DATE).data() do REAPFM(.dep,DATE)

		// Calculate new info and save
		do CALCNEW(.dep,DATE) quit:ER

		// Calculate adjustments
		do CALCADJ(.dep)
		}

	// ER=2 => recalc ok but not fast
	if ER set:ER=2 ER=0 quit 0

	quit 1


CALCNEW(RecordDEP dep,		// Deposit account			/REF:R
	Date %EffectiveDate)	// Effective date

	// Calculate new accrual for this day

	type public Number CMPDNG,ER,NEWBI,NEWACR,NEWAWT,NPOSADJ
	type public Number OLDACR,OLDAWT,OLDBI,TAMTACR,TAMTPR

	type Number CMP,IRN,OLDCMP,TAXRATE

	// Balance for interest on EFD
	set OLDBI=$$GETDBI(.dep,%EffectiveDate)

	// No data, must use old method
	if OLDBI.isNull() set ER=2 quit

	// Day's accrual on EFD
	set OLDACR=$$GETDAA(.dep,%EffectiveDate)

	// Day's w/h accrual on EFD
	set OLDAWT=$$GETDAWA(.dep,%EffectiveDate)

	// Calculate compounded amount
	set CMP=$$CALCCMP(.dep,%EffectiveDate,.OLDCMP)

	// Adjust compounded amount
	if CMPDNG set CMP=CMP+TAMTACR+NPOSADJ

	// New balance for interest
	set NEWBI=OLDBI+TAMTPR

	// Get rate
	set IRN=$$GETRATE(.dep,%EffectiveDate,NEWBI) quit:ER

	// Get new accrual
	set NEWACR=$$GETACR(.dep,%EffectiveDate,NEWBI,CMP,IRN) quit:ER

	// Get new withholding
	set NEWAWT=$$GETAWT(.dep,%EffectiveDate,NEWACR,IRN,.TAXRATE) quit:ER

	// Save new data
	do SAVE1DAY(.dep,%EffectiveDate)

	quit


SAVE1DAY(RecordDEP dep,		// Deposit account			/REF:R
	 Date %EffectiveDate)	// Effective date

 	/*
 	Save one day's worth of info to account record

	Save new information to account record and update other necessary
	variables.

	. Keep XMINACR updated for potential use by MINACR/MINOPT
	. Always update new balance for interest and new daily accrued
	. If considering compounding, then:
		- always updated CMP (last night's compounded)
		- Update CMP1 and CMP2 if they had old value (values are stored
		  in CMP1 and CMP2 if we cannot recompute them from CMP + DAA's)
		- Update CMP1 and CMP2 if doing an accrual adjustment
	. Update new rate if it changed
	*/

	type public Number CMP,CMPDNG,IRN,NEWACR,NEWAWT,NEWBI,OLDCMP
	type public Number TAMTACR,TAXRATE,XMINACR

	if NEWACR'<0!'dep.negacrpo set XMINACR=XMINACR+NEWACR

	// Set Balance for Int/Div Accrual - X Day(s) Ago
	do SETDBI(.dep,%EffectiveDate,NEWBI)

	// Set Daily Accrued Int/Div - X Day(s) Ago
	do SETDAA(.dep,%EffectiveDate,NEWACR)

	// Set Daily Accrued Withholding - X Day(s) Ago
	do SETDAWA(.dep,%EffectiveDate,NEWAWT)

	// Set Compounded Int/Div - X days Ago
	if CMPDNG,(%EffectiveDate=(%SystemDate-1))!('OLDCMP.isNull())!TAMTACR do SETCMP(.dep,%EffectiveDate,CMP)

	// Nominal Int/Div Rate
	if +dep.irn'=(+IRN) set dep.irn=IRN

	// Accrued Withholding Tax Rate
	if +dep.awtr'=(+TAXRATE) set dep.awtr=TAXRATE

	quit


CALCADJ(RecordDEP dep)		// Deposit account			/REF:R

	// Add to adjustment totals based on result for one day.
	
	type public Number NBWAADJ,NEWACR,NEWAWT,NNEGADJ,NPOSADJ,OLDACR,OLDAWT

	// Difference variables
	type Number AWT=0,POS=0,NEG=0

	// Both non-negative
	if OLDACR'<0,NEWACR'<0 set POS=NEWACR-OLDACR
	// Accruing net
	else  if 'dep.negacrpo set POS=NEWACR-OLDACR
	// Must be accruing separately at this point
	// Both negative
	else  if OLDACR<0,NEWACR<0 set NEG=OLDACR-NEWACR
	// New neg, old non-neg
	else  if OLDACR<0,NEWACR'<0 set POS=NEWACR set NEG=OLDACR
	// OLDACR'<0,NEWACR<0
	else  set POS=-OLDACR set NEG=-NEWACR

	set AWT=NEWAWT-OLDAWT

	set NPOSADJ=NPOSADJ+POS
	set NNEGADJ=NNEGADJ+NEG

	// Net backup withholding amount adj
	set NBWAADJ=NBWAADJ+AWT

	quit


CALCCMP(RecordDEP dep,		// Deposit account			/REF:R
	Date EFDATE,		// Effective date
	Number OLDVAL)		// Old compounded amount		/REF:W

 	/*
 	Calculate compounded amount used on EFD

	Inputs:
		. CMPDNG	Daily or continuous compounded indicator
							TYP=L
	Returns:
		. $$		Compounded amount on effective date
							TYP=N

	Calculate compounded amount that was in play on EFD at time of
	accruals. This can either be calculated or is stored in CMP* field,
	for cases where it cannot be calculated (e.g., if an accrual
	adjustment had occured). Return OLDVAL (original value) to know if
	need to replace CMP* field with new value. If old value existed, must
	return new value to the field to allow future calculations.

	Calculation of compound amount for EFD is:
		TJD-1 = CMP
		TJD-2 = CMP1 or, if null, CMP-DAA1
		TJD-3 = CMP2 or, if null, CMP1-DAA2
		TJD-4 = CMP3 or, if null, CMP2-DAA3
		TJD-5 = CMP4 or, if null, CMP3-DAA4
	*/

	type public Number CMPDNG

	type Number CMP,CMP1,CMP2,CMP3,CMP4

	set OLDVAL=""

	// No compounding to consider
	if 'CMPDNG quit 0

	set CMP=dep.cmp
	if EFDATE=(%SystemDate-1) set OLDVAL=dep.cmp quit CMP

	set CMP1=$select('dep.cmp1.isNull():dep.cmp1,1:CMP-dep.daa1)
	if EFDATE=(%SystemDate-2) set OLDVAL=dep.cmp1 quit CMP1

	set CMP2=$select('dep.cmp2.isNull():dep.cmp2,1:CMP1-dep.daa2)
	if EFDATE=(%SystemDate-3) set OLDVAL=dep.cmp2 quit CMP2

	set CMP3=$select('dep.cmp3.isNull():dep.cmp3,1:CMP2-dep.daa3)
	if EFDATE=(%SystemDate-4) set OLDVAL=dep.cmp3 quit CMP3

	set OLDVAL=dep.cmp4
	set CMP4=$select('dep.cmp4.isNull():dep.cmp4,1:CMP3-dep.daa4)

	quit CMP4


GETRATE(RecordDEP dep,		// Deposit account			/REF:R
	Date %EffectiveDate,	// Effective date
	Number BAL)		// Account balance

 	/*
 	Calculate the rate to use for EFD and NEWBI. Same basic logic as
	INDEX section in accruals.

	If EFD is earlier than last rate change date, move last rate change
	date back to EFD or before

	Returns:
		. $$ Rate for this effective day and balance
	*/

	type public Number ER
	type public String INDXMC
	type public String IX()

	type Date ICHLD
	type String PAR()
	type Number RATE

	// Teaser rate
	if %EffectiveDate<dep.trexd quit dep.trate

	// Use rate on account
	if dep.index.isNull() quit dep.irn

	set RATE=dep.irn
	set ICHLD=dep.ichld
	
	// Get right date
	if %EffectiveDate<ICHLD for  set ICHLD=ICHLD.nextFreqDate("-"_dep.intfre) quit:ER!(%EffectiveDate'<ICHLD)
	if ER quit ""

	set PAR("NOTSER")=0		
	set PAR("IPMODE")=0
	set PAR("ROUND")=1

	// Handle mass change differently - RECALC must load IX	
	if 'INDXMC.get().isNull(),INDXMC=dep.index do {
		do LDINDEX^RECALC(.dep,INDXMC)
		set PAR("IXLOAD")=1
		}
	else  set PAR("IXLOAD")=0,PAR("LIMIT")=1

	/*
	UINDX will pick index,spread,matrix and rounding factor from account,
	so no need to pass it in as a parameter. UINDX returns RATE.
	*/
	do CTL^UINDX(.dep,ICHLD,BAL,.PAR()) quit:ER ""

	// If not tiered index and rate not scheduled to change, don't change it
	if IX(dep.index).piece("|",3)=0,%EffectiveDate'=ICHLD quit dep.irn
	
	do FMRATE^RECALC(dep.cid,%EffectiveDate,dep.irn,RATE,"IRN")

	quit RATE


GETACR(RecordDEP dep,		// Deposit account			/REF:R
       Date %EffectiveDate,	// Effective date
       Number BAL,		// Account balance
       Number CMP,		// Compound interest
       Number RATE)		// Interest rate

 	/*
 	Calculate new accrual amount with call to utility UIC

	Returns:
	   . $$ 		One day's accrual 	TYP=$
	   . ER 		Error flag  		TYP=L/COND
	*/

	type public Number ER
	type public Number IRN,TAMTPR,XMINACR
	
	type Number ACR

	if 'dep.minacr.isNull(),BAL<dep.minacr quit $select(dep.minopt:0,1:-XMINACR)

	set ACR=$$^UIC(BAL+CMP,%EffectiveDate,%EffectiveDate,dep.iacm,IRN,0,"",dep.ipf,dep.icpf,dep.inp,dep.ipld) quit:ER ""

	if ACR<0,(dep.idomi!(dep.sdomi)) do {
		type Number INIT=0,MIN=0
		if dep.idomi do { quit:ER
			type Number PREVBASE=0
			set PREVBASE=$$GETPRBA(.dep,%EffectiveDate,TAMTPR) quit:ER
			if (PREVBASE>(BAL+CMP)) set INIT=1 set MIN=-dep.idomi
			}
		if 'INIT set MIN=-dep.sdomi
		if MIN<ACR set ACR=MIN
		}

	quit ACR.roundDec(5)


GETAWT(RecordDEP dep,		// Deposit account			/REF:R
       Date %EffectiveDate,	// Effective date
       Number NEWACR,		// New accrued amount
       Number IRN,		// Interest rate
       Number TAXRATE)		// Withholding tax rate			/REF:W

 	/*
 	Calculate new accrued withholding

	This function will calculate the accrued withholding amount based
	on positive accrued interest if backup withholding flag (DEP.BWF)
	and accrued w/h tax processing (DEP.AWTP) are set.

	Inputs:
		. AWTIND	Accrued Withholding Tax array	TYP=T
		. ER		Error flag			TYP=T

	Returns:
		. $$  	One day's accrued withholding 	TYP=$
		. ER  	Error flag   			TYP=L/COND
	*/

	type public Number ER
	type public String AWTIND(,)

	type Number BWA
	
	set TAXRATE=""

	// Not accrued w/h processing
	if 'dep.awtp quit ""

	set BWA=""

	/*
	If backup withholding...
	ttx in the 2nd parameter is not required in DEPBW, it appears
	that this code does not need to pass it
	*/
	if dep.bwf,NEWACR>0 do {
		do ^DEPBW(.dep,,NEWACR,.BWA,,CUVAR.BWAPGM,dep.awti,IRN,.TAXRATE,.AWTIND(,)) quit:ER ""
		do FMRATE^RECALC(dep.cid,%EffectiveDate,dep.awtr,TAXRATE,"AWTR")
		}

	quit BWA.roundDec(5)


GETPRBA(RecordDEP dep,		// Deposit account			/REF:R
	Date EFDATE,		// Effective date
	Number AMT)		// Base amount

 	/*
 	Get previous day's accrual base amount

	Returns:
		. $$		Previous day's accrual base amount	TYP=N
	*/

	type public Number ER

	// Yesterday
	if EFDATE=(%SystemDate-1) quit dep.dbi1+AMT

	// Two days ago
	if EFDATE=(%SystemDate-2) quit dep.dbi2+AMT

	// Three days ago
	if EFDATE=(%SystemDate-3) quit dep.dbi3+AMT

	// Four days ago
	if EFDATE=(%SystemDate-4) quit dep.dbi4+AMT

	// Can't use fast recalc for T-5 & dep.idomi
	set ER=2 

	quit ""


FASTOK(RecordDEP dep)		// Deposit account			/REF:R

	/*
	Determine if fast recalc is OK

	Reasons shown prevent use of fast recalc.
	Compounding must be none, daily, continuous, or same as int posting

	Returns:
		. $$ 	Succeess flag	
			0 - falure
			1 - OK

	If IRCB or IACM have been file maintained no adjustments will be made
	*/

	type public Number CMPDNG,IRCB
	type public String IACM,ICF,IPF

	// No Accrual
	if IRCB=0 quit 0
	
	// No Int Accrual Calc Method
	if IACM.isNull() quit 0
	
	// Collected balance
	if IRCB=3 quit 0
	
	// Low balance
	if IRCB=5 quit 0
	
	// Low Balance on Collected
	if IRCB=6 quit 0
	
	// Possible residual interest   
	if dep.negbalop>0 quit 0
	
	// Can't handle compounding freq
	if '((ICF.isNull())!CMPDNG!(IPF=ICF)) quit 0
	
	// Can't handle int on uncollected
	if 'dep.ufindex.isNull() quit 0
	
	// Escrow Account
	if dep.grp="ESC" quit 0
	
	/*
	Within rate change period and interest rate change decrease/increase 
	limits in effect - can't handle Int/Div Chg Max % Dec - Life
	*/
	if %EffectiveDate'>dep.ichld,'(dep.intmxic_dep.intmxil_dep.intmxdc_dep.intmxdl).isNull() quit 0

	quit 1


EFDOK(RecordDEP dep)		// Deposit account			/REF:R

 	/*
 	Check that can do recalc based on effective date
	Prevented if EFD more than five days past, if before IPLD, or if we
	don't have all the necessary beginning balances

	Returns:
		. $$ 	0 = not OK
			1 = OK
	*/

	type public String ODTERM
	type public Number TAMTPR

	type Number DBI,I,LOW

	// Too far in past
	if %EffectiveDate<(%SystemDate-5) quit 0

	// Before IPLD
	if %EffectiveDate<(dep.ipld+CUVAR.IPD) quit 0

	// Before NEGIPLD
	if %EffectiveDate<(dep.negipld+CUVAR.IPD) quit 0

	set (DBI,LOW)=""
	for I=1:1:%SystemDate-%EffectiveDate do { quit:DBI.isNull()

		// Balance for Int/Div Accrual - 1 - 5 Day Ago
		do { quit:DBI.isNull()
			if I=1 set DBI=dep.dbi quit
			if I=2 set DBI=dep.dbi1 quit
			if I=3 set DBI=dep.dbi2 quit
			if I=4 set DBI=dep.dbi3 quit
			if I=5 set DBI=dep.dbi4
			}

		// Find the lowest balance field in period
		if ODTERM set LOW=$select(LOW.isNull():DBI,DBI<LOW:DBI,1:LOW)
		}

	// Req'd daily balance for interest fields not populated
	if DBI.isNull() quit 0

	/*
	Cannot use fast recalc if overdraft limit processing is used and
	any of the balances is less than zero or if the balance after
	the transaction is less than zero.
	*/

	if ODTERM,(LOW<0!(LOW+TAMTPR<0)) quit 0

	// Otherwise, fast recalc can be used
	quit 1


LOADFM(RecordDEP dep,		// Deposit account			/REF:R
       Date FROM,		// From date
       Number NOER2)		// Ignore ER=2

 	/*
 	Load file maint from DTJFM since FROM date

	Load file maintenance activity into FM array. Add node and piece.

	Additional notes on Arguments:
		. NOER2
			Used in ADJ section after old recalc

	Returns:
		. FM	File maintenance array	TYP=larray
			FM(date,seq)=DINAM|OLD|NEW

		. ER	Error flag 		TYP=N/COND
			0 => no errors
			1 => invalid data items - no recalc
			2 => invalid data items for fast recalc, 
			must do normal recalc

		. RM	Error message		TYP=T
			May encounter error if certain data items have been 
			modified
	*/

	type public Number ER
	type public String FM(,)

	// None to load
	if dep.fmld'>%EffectiveDate quit

	set FROM=FROM-1 

	// Load from file maintenance, within effective dated period (not including the end dates)	
	type DbSet ds=Db.selectDbSet("DTJFM","TJD>:FROM AND NOT (TJD>:dep.fmld) AND TJD<:%SystemDate AND CLS=:dep.cls AND GRP=:dep.grp AND TYP=:dep.type AND CID=:dep.cid AND FID='DEP' AND DI NOT='CRCD'")
	if 'ds.isEmpty() while ds.next() do { quit:ER

		type RecordDTJFM dtjfm=ds.getRecord("DTJFM")

		// Skip effective dated unless past change to IRN
		if 'dtjfm.efd.isNull(),dtjfm.di'="IRN"!(dtjfm.efd>FROM) quit

		/*
		If type change, must use regular RECALC since FM
		in different sections of DTJFM plus node 49 issues
		*/
		if dtjfm.di="TYPE",'NOER2.get() set ER=2 quit

		// Cannot EFD - ~p1 has been file maintained
		if ",DLR,ICF,INTFRE,"[(","_dtjfm.di_",") do Runtime.setErrMSG("DEP",8238,dtjfm.di) quit

		// Skip - EFD maintenance
		if 'dtjfm.tcmt.piece(":",4).isNull() quit

		/*
		For EFD IRN changes, remove all other intervening IRN changes
		(since this was supercedes them) and place this one on later of 
		FMEFD or EFD
		*/
		
		// Effective dated int/div rate change only
		if 'dtjfm.efd.isNull() do {
			type Date DATE
			type Number SEQ

			set DATE=dtjfm.efd-1 
			set SEQ=""
			for  set DATE=FM(DATE).order() quit:DATE.isNull()  do {
				for  set SEQ=FM(DATE,SEQ).order() quit:SEQ.isNull()  do {
					if FM(DATE,SEQ).piece("|",1)="IRN" kill FM(DATE,SEQ)
					}
				}
			if dtjfm.efd<%EffectiveDate set dtjfm.efd=%EffectiveDate
			}
		else  set dtjfm.efd=dtjfm.tjd

		set FM(dtjfm.efd,dtjfm.tseq)=dtjfm.di_"|"_dtjfm.tcmt.piece(":",2)_"|"_dtjfm.tcmt.piece(":",3)
		}

	quit


REVFM(RecordDEP dep,		// Deposit account			/REF:W
      Date RECENT,		// From most RECENT date
      Date OLDEST,		// To OLDEST date
      String LIST,		// Column list				/NOREQ
      Number HIT)		// Column-in-list indicator		/REF:W/NOREQ

 	/*
 	Reverse file maintenance activity

	Apply reversal of specified days file maintenance activity in FM array
	against .dep - in reverse order RECENT to OLDEST, including RECENT
	and OLDEST

	If LIST is not null, check for data items in list. If found, stop,
	return HIT=1. Used in ADJ section.

	Outputs:
		. FM(,)	File maintenance
			Node and piece added
			Records not needed deleted
	*/

	type public String FM(,)

	type String DINAM,SEQ

	if 'RECENT.isNull() set RECENT=RECENT+1
	
	set SEQ=""
	set LIST=LIST.get()
	set HIT=0

	for  set RECENT=FM(RECENT).order(-1) quit:RECENT.isNull()!(RECENT<OLDEST)  do { quit:HIT
		for  set SEQ=FM(RECENT,SEQ).order(-1) quit:SEQ.isNull()  do { quit:HIT
			set DINAM=FM(RECENT,SEQ).piece("|",1)

			if LIST.isLike("%,"_DINAM_",%") set HIT=1 quit

			set dep.@DINAM=FM(RECENT,SEQ).piece("|",2)
			}
		}

	quit


REAPFM(RecordDEP dep,		// Deposit account			/REF:W
       Date FMDT)		// File maintenance date
       
	// Reapply file maintenance in FM array done on effective date

	type public String FM(,)

	type String COLUMN,FMSEQ

	set FMSEQ=""
	for  set FMSEQ=FM(FMDT,FMSEQ).order() quit:FMSEQ.isNull()  do {
		set COLUMN=FM(FMDT,FMSEQ).piece("|",1)
		set dep.@COLUMN=FM(FMDT,FMSEQ).piece("|",3)
		}

	quit


GETTAMT(RecordDEP dep,		// Deposit account			/REF:R
	RecordTTX ttx,		// Transaction				/REF:R
	Number PR,		// Principal amount (signed)		/REF:W
	Number ACR)		// Accrual adjustment (signed)		/REF:W

 	/*
 	Determine transaction amount

	Determine amount of principal or accrual and sign as it relates to
	this transaction being recalculated. This can be determined from ttx.

	If transaction is not defined, call is from INDEXMC or other function
	asking for recalc not based on transaction.

	*********************************************************************
	NOTE:  Accrual adjustments cannot, currently, be effective dated,
	and therefore won't affect RECALC. However, this code is left
	here for possible future use in case we allow effective dated
	accrual adjustments. For now, the accrual adjustment is set to zero.
	*********************************************************************

	Negative accrual adjustments don't require a recalc -- they have
	no effect on principal or compounding within the five day window

	Positive accrual adjustments only require a recalc if account is
	daily or continuous compounding, since otherwise no effect on
	principal or compounding

	INPUTS:
		. CMPDNG	Daily or continuous compounded flag

	*/

	type public Number CMPDNG

	set PR=0
	set ACR=0

	// Not transaction based
	quit:'ttx.exists()

	// Negative accrual adjustment
	if ttx.tamt.piece("#",6) quit
	if 'ttx.tamt.isLike("%#%") set PR=+ttx.tamt
	else  set PR=+ttx.tamt.piece("#",2) set ACR=+ttx.tamt.piece("#",3)

	// Not compounded
	if 'CMPDNG set ACR=0

	// Debit - make negative
	if 'ttx.itc1 set PR=-PR set ACR=-ACR

	// If transaction to reduce balance - reverse
	if dep.trb set PR=-PR set ACR=-ACR

	// Force to zero
	set ACR=0

	quit


GETMACR(RecordDEP dep,		// Deposit account			/REF:R
	Date %EffectiveDate)	// Effective date

	// Revert MINACR in case need to invoke MINACR/MINOPT
	
	type Number MINACR
	
	// Yesterday
	set MINACR=dep.posacr-dep.daa
	
	// Two days ago
	if %EffectiveDate<(%SystemDate-1) set MINACR=MINACR-dep.daa1

	// Three days ago
	if %EffectiveDate<(%SystemDate-2) set MINACR=MINACR-dep.daa2

	// Four days ago
	if %EffectiveDate<(%SystemDate-3) set MINACR=MINACR-dep.daa3

	// Five days ago
	if %EffectiveDate<(%SystemDate-4) set MINACR=MINACR-dep.daa4

	quit MINACR


private ADJ(RecordDEP dep,		// Deposit account		/REF:RW
	    RecordTTX ttx,		// Pimary transaction		/REF:R
	    Date %EffectiveDate,	// Effective date
	    Number POSACR,		// Positive accrual adj
	    Number NEGACR,		// Negative accrual adj
	    Number POSPR,		// Positive principal adj
	    Number NEGPR,		// Negative principal adj
	    String INDXMC,		// Mass rate change
	    Number BWAACR)		// Backup w/h adjustment

	/*
	Update fast recalc fields

	ADJ is called by RECALC in the event that fast RECALC, ^RECALCFS
	was not used. If possible, it updates the DBI, DAA, and CMP
	fields so that RECALCFS can be used for later effective dated
	transactions.

	All changes other than the nodes needed for fast recalc are the
	responsibility of RECALC and will have taken place by now.

	Additional notes on Arguments:
		. INDXMC
				Indicates if call is due to an
				index mass change (^INDEXMC), and
				if so, holds the index being changed
	*/

	type public Number ADJUNC,AUTOD,AWTP,BWF,ER,IOPT,IRCB,ITRF,MINOPT,MINACR
	type public Number NEGITRF,NEGMININ,ODLIM,RESIDUAL,UNCPST
	type public String AWTI,DCF,DRC,IACM,ICF,INTFRE,IPF,ODTERM
	type public Date DELDT,ICHND,SND

	type String FM(,)

	type Number CMPDNG,NEWACR,NEWBI,NEWCMP,NEWDAA,NNEGADJ
	type Number NPOSADJ,OLDACR,OLDBI,OLDCMP,TAMTACR,TAMTPR,XMINACR
	type Date DATE

	set ER=0

	// Daily or continuous compounded
	if DCF!(IACM.extract(1)=2) set CMPDNG=1
	else  set CMPDNG=0

	// Get transaction amounts
	do GETTAMT(.dep,.ttx,.TAMTPR,.TAMTACR)

	// Add principal adjustment
	set TAMTPR=TAMTPR+POSPR-NEGPR

	// Neg accrual adj ignored unless
	if dep.negacrpo set TAMTACR=TAMTACR+POSACR

	// Netting pos + neg
	else  set TAMTACR=TAMTACR+POSACR-NEGACR

	// No effect on principal
	if 'CMPDNG quit:'(TAMTPR)

	// Negative acr adj only
	else  quit:'(TAMTPR!POSACR)

	quit:'$$FASTOK(.dep)

	// Not earlier than Int/Div Paid - Last Date
	if %EffectiveDate<(dep.ipld+CUVAR.IPD) set %EffectiveDate=dep.ipld+CUVAR.IPD quit:%EffectiveDate'<%SystemDate

	// Not earlier than Negative Interest Paid - Last Date
	if %EffectiveDate<(dep.negipld+CUVAR.IPD) set %EffectiveDate=dep.negipld+CUVAR.IPD quit:%EffectiveDate'<%SystemDate

	// Only worry about five days
	if %EffectiveDate<(%SystemDate-5) set %EffectiveDate=%SystemDate-5

	set XMINACR=$$GETMACR(.dep,%EffectiveDate)

	// Load file maintenance
	do LOADFM(.dep,%EffectiveDate+1,1) quit:ER

	// Handle if compounding
	if CMPDNG do CMPADJ(.dep) quit

	/*
	If no compounding, apply principal amount (net) as adjustment to
	update DBI, DAA, and CMP fields. Save dep.irn to make sure IRN
	doesn't change through this process.
	*/

	// Reverse all file maintenance
	do REVFM(.dep,"","")

	for DATE=%EffectiveDate:1:%SystemDate-1 do { quit:ER
		if FM(DATE).data() do REAPFM(.dep,DATE)
		
		// Calc and update %A
		do CALCNEW(.dep,DATE)
		
		// Keep going on ER=2
		if ER set:ER=2 ER=0 quit:ER
		}

	quit


CMPADJ(RecordDEP dep)		// Deposit account			/REF:R

	/*
	Compute adjustments to fast recalc fields for compounded accts

	Applies only to daily or continuous compounded accounts. Uses
	formula based on reversing interest calculation to determine new
	DAA* and CMP* fields.

	Moves from TJD back to EFD. Reverse file maintenance as we go.
	If MINACR or dep.negacrpo were modified, stop.

	If MINACR in use, stop if old or new balance for the day is
	less than MINACR.

	If dep.negacrpo=1, stop if old or new balance for the day is
	less than zero.

	Set DBI for any day we don't reach because of the above conditions
	to null, since we cannot adjust those figures. This will prevent
	attempts to use fast recalc for those days.

	Formula to compute day-1 DAA and CMP:
		new_tot_acr = old_cmp + old_daa + remaining_acr_adj

			  new_tot_acr - (new_bal * rate)
		new_cmp = ------------------------------
			  (rate + 1)

		new_daa = new_tot_acr - new_cmp
	*/

	type public Number ER,MINACR,TAMTPR,TAMTACR

	type Number DONE,SAVCMP,TAXRATE,USEDADJ
	type Date DATE

	set DONE=0 
	set USEDADJ=0
	for DATE=%SystemDate-1:-1:%EffectiveDate do { quit:ER!DONE
	
		type Number ACRADJ,IRN,NEWACR,NEWDAWA,NEWDAA,NEWBI,NEWCMP
		type Number OLDDAWA,OLDDAA,OLDBI,OLDCMP,RATE

		// Reverse next day's FM
		do REVFM(.dep,DATE+1,DATE+1,",MINACR,NEGACRPO,",.DONE)
		if DONE set DATE=DATE+1 quit

		// Amt of acr adj left
		set ACRADJ=TAMTACR-USEDADJ

		// Old balance
		set OLDBI=$$GETDBI(.dep,DATE)

		// Back as far as can go
		if OLDBI.isNull() set DONE=1 quit

		// Old compounded
		set OLDCMP=$$CALCCMP(.dep,DATE,.SAVCMP)

		// Old 1 day's accrual
		set OLDDAA=$$GETDAA(.dep,DATE)

		// Old 1 day's accrual
		set OLDDAWA=$$GETDAWA(.dep,DATE)

		// New balance
		set NEWBI=OLDBI+TAMTPR

		if 'MINACR.isNull(),OLDBI<MINACR!(NEWBI<MINACR) set DONE=1 quit
		if dep.negacrpo,OLDBI<0!(NEWBI<0) set DONE=1 quit

		// New accrued
		set NEWACR=OLDCMP+OLDDAA+ACRADJ

		// Rate
		set IRN=$$GETRATE(.dep,DATE,NEWBI) quit:ER

		// Get rate on 100000 to keep decimals
		set RATE=$$GETACR(.dep,DATE,100000,0,IRN) quit:ER

		// Factor down
		set RATE=RATE/100000

		// New computed
		set NEWCMP=(NEWACR-(RATE*NEWBI))/(RATE+1)
		set NEWCMP=NEWCMP.roundDec(5)

		// New 1 day's accrued
		set NEWDAA=NEWACR-NEWCMP

		// Amt of acr adj used
		set USEDADJ=USEDADJ+(NEWDAA-OLDDAA)

		// Get new w/hdo GETAWT(.dep)
		set NEWDAWA=$$GETAWT(.dep,DATE,NEWDAA,IRN,.TAXRATE) quit:ER

		// Update account record
		do SETDBI(.dep,DATE,NEWBI)
		do SETDAA(.dep,DATE,NEWDAA)
		do SETDAWA(.dep,DATE,NEWDAWA)
		if 'SAVCMP.isNull() do SETCMP(.dep,DATE,NEWCMP)
		}

	/*
	If didn't get through all five days, set older days DBIs to null
	to avoid fast recalc on these days with later EFD transactions
	*/
	if ER!(DONE) do {
		// Balance for Int/Div Accrual - 5 Days Ago
		if DATE>(%SystemDate-5) set dep.dbi4=""

		// Balance for Int/Div Accrual - 4 Days Ago
		if DATE>(%SystemDate-4) set dep.dbi3=""

		// Balance for Int/Div Accrual - 3 Days Ago
		if DATE>(%SystemDate-3) set dep.dbi2=""

		// Balance for Int/Div Accrual - 2 Days Ago
		if DATE>(%SystemDate-2) set dep.dbi1=""

		// Balance for Int/Div Accrual - 1 Day Ago
		if DATE>(%SystemDate-1) set dep.dbi=""
		}

	quit


GETDBI(RecordDEP dep,		// Deposit account			/REF:R
       Date EFDATE)		// Effective date

	/*
	Get Balance for Int/Div Accrual - X Day(s) Ago

	Returns:
		. $$		Balance for Int/Div Accrual - X Day(s) After
							TYP=N
	*/

	// Yesterday
	if EFDATE=(%SystemDate-1) quit dep.dbi

	// Two days ago
	if EFDATE=(%SystemDate-2) quit dep.dbi1

	// Three days ago
	if EFDATE=(%SystemDate-3) quit dep.dbi2

	// Four days ago
	if EFDATE=(%SystemDate-4) quit dep.dbi3

	// Five days ago
	quit dep.dbi4


GETDAA(RecordDEP dep,		// Deposit account			/REF:R
       Date EFDATE)		// Effective date

 	/*
 	Get Daily Accrued Int/Div - X Day(s) Ago

	Returns:
		. $$		Daily Accrued Int/Div - X Day(s) Ago
							TYP=N
	*/
	
	// Yesterday
	if EFDATE=(%SystemDate-1) quit dep.daa
	
	// Two days ago
	if EFDATE=(%SystemDate-2) quit dep.daa1
	
	// Three days ago
	if EFDATE=(%SystemDate-3) quit dep.daa2
	
	// Four days ago
	if EFDATE=(%SystemDate-4) quit dep.daa3
	
	// Five days ago
	quit dep.daa4


GETCMP(RecordDEP dep,		// Deposit account			/REF:R
       Date EFDATE)		// Effective date

 	/*
 	Get Compounded Int/Div - X days Ago

	Returns:
		. $$		Compounded Int/Div - X days Ago
							TYP=N
	*/

	// Yesterday
	if EFDATE=(%SystemDate-1) quit dep.cmp

	// Two days ago
	if EFDATE=(%SystemDate-2) quit dep.cmp1

	// Three days ago
	if EFDATE=(%SystemDate-3) quit dep.cmp2

	// Four days ago
	if EFDATE=(%SystemDate-4) quit dep.cmp3

	// Five days ago
	quit dep.cmp4


GETDAWA(RecordDEP dep,		// Deposit account			/REF:R
	Date EFDATE)		// Effective date

 	/*
 	Get Daily Accrued Withholding - X Day(s) Ago

	Returns:
		. $$		Daily Accrued Withholding - X Day(s) Ago
							TYP=N
	*/

	// Yesterday
	if EFDATE=(%SystemDate-1) quit dep.dawa

	// Two days ago
	if EFDATE=(%SystemDate-2) quit dep.dawa1

	// Three days ago
	if EFDATE=(%SystemDate-3) quit dep.dawa2

	// Four days ago
	if EFDATE=(%SystemDate-4) quit dep.dawa3

	// Five days ago
	quit dep.dawa4


SETDBI(RecordDEP dep,		// Deposit account			/REF:RW
       Date EFDATE,		// Effective date
       Number VALUE)		// New account balance value

	// Set Balance for Int/Div Accrual - X Day(s) Ago

	// Yesterday
	if EFDATE=(%SystemDate-1) set dep.dbi=VALUE quit

	// Two days ago
	if EFDATE=(%SystemDate-2) set dep.dbi1=VALUE quit

	// Three days ago
	if EFDATE=(%SystemDate-3) set dep.dbi2=VALUE quit

	// Four days ago
	if EFDATE=(%SystemDate-4) set dep.dbi3=VALUE quit

	// Five days ago
	set dep.dbi4=VALUE

	quit


SETDAA(RecordDEP dep,		// Deposit account			/REF:RW
       Date EFDATE,		// Effective date
       Number VALUE)		// New daily accrued value

	//  Daily Accrued Int/Div - X Day(s) Ago

	// Yesterday
	if EFDATE=(%SystemDate-1) set dep.daa=VALUE quit

	// Two days ago
	if EFDATE=(%SystemDate-2) set dep.daa1=VALUE quit

	// Three days ago
	if EFDATE=(%SystemDate-3) set dep.daa2=VALUE quit

	// Four days ago
	if EFDATE=(%SystemDate-4) set dep.daa3=VALUE quit

	// Five days ago
	set dep.daa4=VALUE

	quit


SETCMP(RecordDEP dep,		// Deposit account			/REF:RW
      Date EFDATE,		// Effective date
      Number VALUE)		// New compounded int/div value

	// Compounded Int/Div - X days Ago

	// Yesterday
	if EFDATE=(%SystemDate-1) set dep.cmp=VALUE quit

	// Two days ago
	if EFDATE=(%SystemDate-2) set dep.cmp1=VALUE quit

	// Three days ago
	if EFDATE=(%SystemDate-3) set dep.cmp2=VALUE quit

	// Four days ago
	if EFDATE=(%SystemDate-4) set dep.cmp3=VALUE quit

	// Five days ago
	set dep.cmp4=VALUE

	quit


SETDAWA(RecordDEP dep,		// Deposit account			/REF:RW
	Date EFDATE,		// Effective date
	Number VALUE)		// New acr withholding val

	// Set Daily Accrued Withholding - X Day(s) Ago

	// Yesterday
	if EFDATE=(%SystemDate-1) set dep.dawa=VALUE quit

	// Two days ago
	if EFDATE=(%SystemDate-2) set dep.dawa1=VALUE quit

	// Three days ago
	if EFDATE=(%SystemDate-3) set dep.dawa2=VALUE quit

	// Four days ago
	if EFDATE=(%SystemDate-4) set dep.dawa3=VALUE quit

	// Five days ago
	set dep.dawa4=VALUE

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60827^25797^Hari Natrajan^30591"	// Signature - LTD^TIME^USER^SIZE
