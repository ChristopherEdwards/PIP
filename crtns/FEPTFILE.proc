public FEPTFILE
	/*
	   DESC: 
	   This routine is called from a batch job that can run on the
	   host system all day, being resubmitted at some desired
	   frequency. It first establishes if there are any new table
	   changes that needs to be updated at the FEPs.  If so, it
	   builds RMS files for those table changes and makes an entry
	   in the que that will send these changes down to the FEPs.
	   It then sends any other que entry to the corresponding FEPs
	   set up in the queue.
	
	  ---- Revision History ------------------------------------------------

	   08/23/06 - KELLYP - CR 22808
		Removed the CHECKTMP section and the call to it from the top 
		level.  This prevents a problem where the TMPFTPHOLD record for 
		a FEP may have been deleted before it was host synch'd and 
		resulted in a truncated FEP being delivered to the branch.
		MRPC067 deletes the TMPFTPHOLD and TMPFTPCODE records when
		appropriate anyway.

 	   07/31/06 - KELLYP - CR 22048
	  	Modified SPLITBLD section to eliminate DYNAMIC warning.

	   01/23/06 - KELLYP - CR 19173
	   	Modified BUILD section and added new SPLITBLD section so that
	   	DBTBL1D is used instead of LOG1 to determine table schema to
	   	be transferred when in create mode for a wide table.  This is
	   	necessary because LOG1 does not store text-type columns that
	   	contain empty strings.  This may cause a problem where not all
	   	of the wide tables are populated which causes further problems
	   	when PFW tries to default data from the product level to the
	   	account level.

	   01/05/06 - KELLYP - CR 18761
		Modified entire procedure to correct several logic errors and to
		conform to current PSL standards.  Also removed REDO logic (since 
		same functionality was removed from MRPC067) and removed pre-2003 
		revision history.

	   12/08/03 Spier 7403
		PSL compiler message cleanup.

	*/
	
	type public Boolean ER
	type public String FEPTFILE
	
	type Date BDATE,DATE,EDATE
	type Number BSEQ,ESEQ,FIDSEQ
	type String CLIENT,DDPDIR,DIR,DREC(),FIDSEQ(),HOSTDIR,IO,IOLIST,NEWFILE,QUOTE
	type Time TIME
	
	do INIT^%ZM()
	set QUOTE=$C(34)
	
	set IO=""
	do FEPLIST

	/*
	 Update SFUPD table with changes to balances that have occurred since
	 the last time this function has run.
	*/
	do SFUPD

	// File locked by another user
	lock +FEPTFILE:1
	else  do Runtime.setErrMSG("DDPXLOG","1081") quit:ER

	// Determine Beginning Date and Seq number
	type RecordLOGUPD logupd=Db.getRecord("LOGUPD","KEY0=0",1)
	if 'logupd.getMode() do {
		set logupd.lastdate=0
		set logupd.lastseq=0
		}
	set BDATE=logupd.lastdate
	set BSEQ=logupd.lastseq

	// Get current date and sequence of the last entry in the LOG table
	// This will be the last entry we will process in this iteration of updates
	type ResultSet logdata=Db.select("TJD,SEQ","LOG","TJD>0","TJD DESC,SEQ DESC")
	if logdata.isEmpty() do {
		set EDATE=0
		set ESEQ=0
		}
	else  if logdata.next() do {
		set EDATE=logdata.getCol("TJD")
		set ESEQ=logdata.getCol("SEQ")
		}
	
	set logupd.lastdate=EDATE
	set logupd.lastseq=ESEQ

	lock -FEPTFILE

	// No changes have been filed
	if EDATE=BDATE,ESEQ=BSEQ do CLEANUP quit

	set DATE=%CurrentDate
	set TIME=%CurrentTime

	set DIR=$$DIR^DDPUTL if DIR.isNull() quit 
	set DDPDIR=$$DDPDIR^DDPUTL(DIR)
	if DDPDIR.isNull() set DDPDIR=$$SCAU^%TRNLNM("DDP")

	// Send any new BRACN entries down to the client
	do BRACNSND

	/*
	 The following code will setup routines used to consider
	 the differences between PFW builds and the host system. 
	 It is expected that some PFW clients will be on a build that is
	 not as up to date as the host and therefore changes to columns can
	 not be sent to that client until they are upgraded. Review arq 29958.
	*/
	#IF $$VALID^%ZRTNS("SCHEMCHG") do NEWFILE^SCHEMCHG
	#IF $$VALID^%ZRTNS("ZSCHEMCG") do NEWFILE^ZSCHEMCG

	do SORT
	do CLEANUP
		
	// Don't update the last date/seq until everything else finishes ok
	if 'ER do logupd.bypassSave()
	
	quit	


SORT	// Sorts the LOG table entries and files it to the HSYNC2 table 
	
	type public Date BDATE,EDATE
	type public Number BSEQ,ESEQ
	
	type Date XTJD
	type Number I,MODE,NL,XSEQ
	type String DI,FID,IDI,INV,KEY1,KEY2,KITEM,KVALUE,NV
	
	set KEY1=BDATE-1
	set KEY2=BSEQ

	do Db.fastDelete("HSTSYNC1","JOB=:%ProcessID")
	do Db.fastDelete("HSTSYNC2","JOB=:%ProcessID")

	type DbSet ds=Db.selectDbSet("LOG","TJD>:KEY1 AND SEQ>:KEY2","TJD DESC,SEQ DESC")
	while ds.next() do {
		type RecordLOG logdata=ds.getRecord("LOG")
		
		if (logdata.tjd=EDATE),(logdata.seq>ESEQ) quit
		
		set XTJD=logdata.tjd
		set XSEQ=logdata.seq
		
		set FID=logdata.fid
		if FID.isNull() quit
		
		set MODE=logdata.%o
		
		set KITEM=logdata.ackeys
		set KVALUE=logdata.keyvalue quit:KVALUE.isNull()
		
		set DI=""

		do BUILD

		if (KVALUE.extract(3)?.L),((FID="TRN")!(FID="TRNAUT")) quit 

		if FID="DBTBL33D" quit
		if DI.isNull() set DI=" "
		
		type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:FID",1)
		set NL=dbtbl1.netloc
		if '((NL=1)!(NL=2)) quit	// Data on server only
		
		for I=1:1:DI.length(",") do {
			set IDI=DI.piece(",",I) quit:IDI.isNull()
			set INV=NV.piece($C(1),I)

			if FID'["DBTBL" do {
				type RecordHSTSYNC2 hstsync2=Class.new("RecordHSTSYNC2")
				set hstsync2.job=%ProcessID
				set hstsync2.logdate=XTJD
				set hstsync2.seq=XSEQ
				set hstsync2.keys=FID
				set hstsync2.kvalue=KVALUE
				set hstsync2.columnid=IDI
				set hstsync2.kitem=KITEM
				set hstsync2.typ=NL
				set hstsync2.newvalue=INV
				set hstsync2.mode=MODE
				set hstsync2.FID=FID
				
				do hstsync2.bypassSave()
				}
			else  do DBTBL1
			}
		}

	do BLDFILE

	quit


BLDFILE	// Builds the transfer file from the HSTSYNC1,HSTSYNC2 tables

	type public Boolean ER
	type public String FID,IOLIST,QUOTE

	type Boolean SPLITFLG
	type Date DATE,ODATE
	type Number JOB,KEYCNT,OSEQ,SEQ
	type String KEYVALUE,OPT,RECTYPE,TABLE,TEMPFID
	type String TEMPREC,TEMPTREC,TREC,VER

	if 'IOLIST.data() do SETIOLIS

	type ResultSet hsync1=Db.select("LOGDATE,SEQ,KEYS,RECTYPE","HSTSYNC1","JOB=:%ProcessID and RECTYPE=1")
	while hsync1.next() do {
		set ODATE=hsync1.getCol(1)
		set OSEQ=hsync1.getCol(2)
		type RecordLOG log=Db.getRecord("LOG","TJD=:ODATE,SEQ=:OSEQ")
		set TABLE=log.keyvalue.translate("""","")
		set TABLE=TABLE.piece(",",2)
		do WRTDBTBL^HSYNCWRT(TABLE)
		do Db.delete("HSTSYNC1","JOB=:%ProcessID AND LOGDATE=:ODATE AND SEQ=:OSEQ AND KEYS=:TABLE")
		}

	set (KEYVALUE,TEMPREC,TEMPTREC,TEMPFID,OPT)=""

	type ResultSet rs=Db.select("DISTINCT LOGDATE,SEQ,KEYS","HSTSYNC2","JOB=:%ProcessID","LOGDATE,SEQ,KEYS")
	while rs.next() do {

		type String SPLITFLE()
		
		set DATE=rs.getCol("LOGDATE")
		set SEQ=rs.getCol("SEQ")
		set TABLE=rs.getCol("KEYS")

		do MAP^DBSDDMAP(TABLE,.SPLITFLE())

		// Tables too wide for Oracle 7.3 will be split later
		if SPLITFLE.data() quit  

		set SPLITFLG=0
		
		type ResultSet rs2=Db.select("DISTINCT KVALUE","HSTSYNC2","JOB=:%ProcessID AND LOGDATE=:DATE AND SEQ=:SEQ AND KEYS=:TABLE")
		while rs2.next() do {
			set KEYVALUE=rs2.getCol("KVALUE")
			set KEYCNT=KEYVALUE.length(",")
		
			if TEMPFID'=TABLE set TREC="T"_","_(%CurrentDate)_","_(%CurrentTime)_","_QUOTE_TABLE_QUOTE_","_KEYCNT
	
			do RMS	// Only call RMS once for each FID's key structure
			}
		}

	set JOB=%ProcessID	// Needed within HSYNCSPT
	do SPLIT^HSYNCSPT	// Modify RMS file for any split tables

	set VER=""
	for  set VER=IOLIST(VER).order() quit:VER.isNull()  close IOLIST(VER)

	do Db.delete("HSTSYNC1","JOB=:%ProcessID")
	do Db.delete("HSTSYNC2","JOB=:%ProcessID")
	
	if 'IOLIST.data() quit
	
	do HSYNCQUE

	quit


SETIOLIS	// Build a list of files and open them, store their names in array IOLIST

	type public Boolean ER
	type public String CLIENT(),IOLIST(),RM,VER
	
	type String X

	set VER=""

	for  set VER=CLIENT(VER).order() quit:VER.isNull()  do { quit:ER 
		set IOLIST(VER)=$$SCAU^%TRNLNM("DDP","RTFILE"_%ProcessID_"."_VER.translate(".","-"))
		set X=$$FILE^%ZOPEN(IOLIST(VER),"WRITE/NEWV",,2048)
		if 'X set ER=1,RM=X.piece("|",2) do ZE^UTLERR quit
		}

	quit


DBTBL1	// Set up proper location for tmp entry if the file is dbtbl1 or dbtbl1d
	
	type public Date XTJD
	type public Number MODE,XSEQ
	type public String FID,FIDSEQ(),KVALUE
	
	type Number SEQ,ZSEQ
	
	if FID="DBTBL1",MODE=3 do {
	 	set ZSEQ=XSEQ
		type ResultSet logdata=Db.select("FID,KEYVALUE,%O,SEQ","LOG","TJD=:XTJD AND SEQ<:ZSEQ","SEQ DESC")
	 	while logdata.next() do {
	 		set ZSEQ=logdata.getCol(4)
			if (logdata.getCol(3)=3&(logdata.getCol(2)[KVALUE)&(logdata.getCol(1)="DBTBL1D")) do {
				do Db.delete("HSTSYNC2","JOB=:%ProcessID AND LOGDATE=:XTJD AND SEQ=:ZSEQ")
				}
			}
		}
	
	if MODE=0,FID="DBTBL1" do {
		if FIDSEQ(KVALUE).exists() quit
		type RecordHSTSYNC1 hstsync1=Class.new("RecordHSTSYNC1")
		set hstsync1.job=%ProcessID
		set hstsync1.logdate=XTJD
		set hstsync1.seq=XSEQ
		set hstsync1.keys=FID
		set hstsync1.rectype=1
		do hstsync1.bypassSave()
		set FIDSEQ(KVALUE)=""
		}
	

	if FID="DBTBL1" do { quit 
		if FIDSEQ(KVALUE).exists() quit
		do INSSYNC2
		}
	
	/*
	 FID must be DBTBL1D, ignore all inserts,deletes,
	 updates related to this FID which have the same key value. Only the
	 insert of the file will be stored in the file.  The build routine will
	 generate the correct insert commands for all columns related to the
	 file schema.
	*/
	
	set ZSEQ=""
	for  set ZSEQ=FIDSEQ(ZSEQ).order(-1) quit:ZSEQ.isNull()  if KVALUE[ZSEQ quit 
	if ZSEQ.isNull() do INSSYNC2
	
	quit 


INSSYNC2	// Build HSTSYNC2 record

	type public Date XTJD
	type public Number MODE,NL,XSEQ
	type public String FID,IDI,INV,KITEM,KVALUE

	type RecordHSTSYNC2 hstsync2=Class.new("RecordHSTSYNC2")
	
	set hstsync2.job=%ProcessID
	set hstsync2.logdate=XTJD
	set hstsync2.seq=XSEQ
	set hstsync2.keys=FID
	set hstsync2.KVALUE=KVALUE
	set hstsync2.columnid=IDI
	set hstsync2.kitem=KITEM
	set hstsync2.typ=NL
	set hstsync2.newvalue=INV
	set hstsync2.MODE=MODE
	
	do hstsync2.bypassSave()
	
	quit
	
	
RMS	// Write to the RMS file from the DATA contained in the LOG table

	type public Boolean SPLITFLG
	type public String KEYVALUE,KITEM,NEWITEM(),RECTYPE,TABLE,TEMPFID,TEMPTREC,TREC

	type Boolean ERR = 0
	type Number ilist,MODE,OMODE,typ
	type String COLLIST,COLUMN,CREC,DATA,DBTBLFID,DREC,FID,FILENAME,FMTTYP,FREC,kdi
	type String NEWVAL,NV,SREC,SRECITM,VER

	set DATA=""
	set FILENAME=TABLE
	set FID=FILENAME

	if FID["DBTBL1" do {
		set DBTBLFID=KEYVALUE
		set DBTBLFID=DBTBLFID.piece(",",2)
		set DBTBLFID=DBTBLFID.translate("""","")
		do SPLITTST
		}
	else  set DBTBLFID=FID

	// Schema changes to split files will be dealt with in SPLIT section
	if SPLITFLG quit

	#if $$VALID^%ZRTNS("SCHEMCG") do CHGFILE^SCHEMCHG(DBTBLFID)
	#if $$VALID^%ZRTNS("ZSCHEMCG") do CHGFILE^ZSCHEMCG(DBTBLFID)

	if TEMPFID'=FID do { if ERR quit 
		set TREC.piece(",",6)="N"
		
		type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:DBTBLFID",1)
		
		if 'dbtbl1.getMode() set ERR=1 quit
		
		set RECTYPE=$$RECTYPE(dbtbl1.filetyp,FID)

		if (KEYVALUE?1.E1"@".E)&(FID="TRN"!(FID="TRNAUT")) set RECTYPE="C"

		set TREC.piece(",",7)=RECTYPE

		// Do not send GUI only files if a GUI is not in the FEP LIST
		if dbtbl1.filetyp=7 set ERR=1 quit 
		}

	set FREC="F"
	set SREC="S"
	set DREC="D"
	set CREC="C"

	type ResultSet rsmode=Db.select("MODE,KITEM","HSTSYNC2","JOB=:%ProcessID AND LOGDATE=:DATE AND SEQ=:SEQ AND KEYS=:TABLE AND KVALUE=:KEYVALUE")
	if rsmode.next() do {
		set MODE=rsmode.getCol("MODE")
		set KITEM=rsmode.getCol("KITEM")
		}
	else  set MODE=0,KITEM=""""	// Default to create

	set OMODE=$S(MODE=3:"D",MODE=1:"U",1:"I")
	set DREC=DREC_","_OMODE
	set VER=""
	for  set VER=DREC(VER).order() quit:VER.isNull()  set DREC(VER)=DREC(VER)_","_OMODE

	if KITEM'="" for ilist=1:1:KITEM.length(",") do {
		// Add keys to beginning of *REC strings
		set kdi=KITEM.piece(",",ilist)
		set typ=$$TYP^DBSDD(FID_"."_kdi)
		set NV=KEYVALUE.piece(",",ilist)
		set NV=$$nvchange(NV,typ)
		set DREC=DREC_","_NV
		for  set VER=DREC(VER).order() quit:VER.isNull()  set DREC(VER)=DREC(VER)_","_NV
		set FREC=FREC_","_kdi
		set SREC=SREC_","_typ
		for  set VER=SREC(VER).order() quit:VER.isNull()  set SREC(VER)=SREC_","_typ
		for  set VER=FREC(VER).order() quit:VER.isNull()  set FREC(VER)=FREC_","_kdi
		}

	// Need to add the data item length and type on for new/modified 
	// data items as it is required by PFW HostSync.
	if (FID="DBTBL1D"),(MODE'=3) do {
		type String DI,XFID
		
		set FREC=FREC_",LEN,TYP"
		set SREC=SREC_",N,T"
		set XFID=KEYVALUE.piece(",",2).translate("""","")
		set DI=KEYVALUE.piece(",",3).translate("""","")
		
		type RecordDBTBL1D dbtbl1d=Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=:XFID,DI=:DI")

		set NEWVAL=$$nvchange(dbtbl1d.len,"N")
		if DREC.length()+NEWVAL.length()>32000 set CREC=CREC_","_NEWVAL
		else  set DREC=DREC_","_NEWVAL
		
		set NEWVAL=$$nvchange(dbtbl1d.typ,"T")
		if DREC.length()+NEWVAL.length()>32000 set CREC=CREC_","_NEWVAL
		else  set DREC=DREC_","_NEWVAL
		}

	type DbSet ds=Db.selectDbSet("HSTSYNC2","JOB=:%ProcessID AND LOGDATE=:DATE AND SEQ=:SEQ AND KEYS=:TABLE AND KVALUE=:KEYVALUE","COLUMNID ASC")
	while ds.next() do {
		type RecordHSTSYNC2 hsync=ds.getRecord("HSTSYNC2")

		// Column name
		set COLUMN=hsync.columnid

		if COLUMN=" " quit

		set NV=hsync.newvalue
		
		set FREC=FREC_","_COLUMN
		set FMTTYP=$$TYP^DBSDD(FID_"."_COLUMN)
		set SREC=SREC_","_FMTTYP
		set NEWVAL=$$nvchange(NV,FMTTYP)
		if DREC.length()+NEWVAL.length()>32000 set CREC=CREC_","_NEWVAL
		else  set DREC=DREC_","_NEWVAL
		if NEWITEM(COLUMN).exists() do CHECKNEW
		do FRECNITM(COLUMN,FMTTYP)
		if 'NEWITEM(COLUMN).exists(),COLLIST(COLUMN).exists() do CHITMTYP(COLUMN)
		if SREC.data()>1 do CHGDATA(NV)
		if TEMPTREC.isNull() set TEMPTREC=TREC
		}

	set SRECITM=""
	
	// Write an entry to the rms file
	do wrtrec^HSYNCWRT

	set TEMPFID=FID

	do Db.delete("HSTSYNC2","JOB=:%ProcessID AND LOGDATE=:DATE AND SEQ=:SEQ AND KEYS=:TABLE AND KVALUE=:KEYVALUE")

	quit 


public CHGDATA(String nv)	// Based on format reset the data for this column

	type public String DREC(),SREC()

	type String FMTTYP,NV,VER

	set VER=""
	set VER=SREC(VER).order() quit:VER.isNull()  do {
		set FMTTYP=SREC(VER).piece(",",SREC(VER).length(","))
		set NV=$$nvchange(nv,FMTTYP)
		if 'DREC(VER).exists() set DREC(VER)=DREC.piece(",",(DREC.length(",")-1))
		set DREC(VER)=DREC(VER)_","_NV
		}

	quit 
	

nvchange(NV,FMTTYP)	// Return formatted data

	if "$LND"[FMTTYP set NV=NV.translate("""","")
	if "L"[FMTTYP set NV=+NV
	if "D"[FMTTYP set NV=$$INT^%ZM(NV,"D")
	if "C"[FMTTYP set NV=$$INT^%ZM(NV,"C")

	quit NV


public CHECKNEW
	/*
	 If a new field has been added in a version, do not send this field to
	 prior versions.
	*/

	type public String COLUMN,FREC(),IOLIST(),NEWITEM(,),SREC()

	type String VER

	set VER=NEWITEM(COLUMN,"").order()
	for  set VER=IOLIST(VER).order() quit:VER.isNull()  do {
		if 'FREC(VER).exists() set FREC(VER)=FREC.piece(",",(FREC.length(",")-1))
		if 'SREC(VER).exists() set SREC(VER)=SREC.piece(",",(SREC.length(",")-1))
		}
	
	quit 


public FRECNITM(String FVAL,String SVAL)

	/*
	 Add a field to any lower versions which are different
	 due to the addition of a new field in a higher version.
	*/

	type public String FREC(),SREC()

	type String VER
	
	set VER=""
	for  set VER=FREC(VER).order() quit:VER.isNull()  do {
		set FREC(VER)=FREC(VER)_","_FVAL
		set SREC(VER)=SREC(VER)_","_SVAL
		}
		
	quit 
	

public CHITMTYP(String COLUMN)	// Build Srec array when multiple versions os a client exist
	
	type public String CLIENT(),COLLIST(,,),SREC()
	
	type String TESTVAL,VER
	
	set VER=""
	for  set VER=CLIENT(VER).order() quit:VER.isNull()  do {
		set TESTVAL=COLLIST(COLUMN,"TYP",VER).order()
		if TESTVAL.isNull() quit 
		if 'SREC(VER).exists() set SREC(VER)=SREC
		set SREC(VER)=SREC(VER).piece(",",1,(SREC(VER).length(",")-1))_","_COLLIST(COLUMN,"TYP",TESTVAL).piece("|",1)
		}
	
	quit 

	
SPLITTST	// Determine if the table is a wide table that needs to be split

	type public Boolean SPLITFLG
	type public String DBTBLFID,SPLITFLE

	do MAP^DBSDDMAP(DBTBLFID,.SPLITFLE)
	
	if SPLITFLE(DBTBLFID).exists() set SPLITFLG=1
	else  set SPLITFLG=0

	quit 

	
BUILD
	/*
	 Build the list of DATA items and DATA values from 
	 the sub records of the LOG.
	*/
	
	type public Date XTJD
	type public Number MODE,XSEQ
	type public String DI,FID,NV

	type String DILIST,VALLIST,SPLITFLE()
	
	set (DILIST,VALLIST)=""

	do MAP^DBSDDMAP(FID,.SPLITFLE())

	// Use DBTBL1D for schema, not LOG1, when record was created 
	// for a wide table.
	if (MODE=0),(SPLITFLE.data()) do SPLITBLD(.DI,.NV) quit
	
	type ResultSet log1=Db.select("DILIST,DVLIST,OVLIST","LOG1","TJD=:XTJD and SEQ=:XSEQ")
	while log1.next() do {
		set DILIST=DILIST_","_log1.getCol(1)
		set VALLIST=VALLIST_$C(1)_log1.getCol(2)
		}
	set DI=DILIST.extract(2,DILIST.length())
	set NV=VALLIST.extract(2,VALLIST.length())

	if ((FID["PRODDFTL")!(FID["PRODDFTD")!(FID["PRODDFTC")!(FID["PRODCTL")),(DI'["TYPE") set DI=DI_",TYPE"

	quit 


SPLITBLD(String DI,String NV)
	/*
	 Builds DI and NV (for HSTSYNC2 records) when the system is 
	 transferring a newly created record for a wide table.
	*/

	type public String FID,KITEM,KVALUE

	type Number I,NUMCOLS
	type String COLS,WHERE

	set COLS=$$COLLIST^DBSDD(FID,0,1,1,)
	
	set WHERE=KITEM_"="_KVALUE
	set (DI,NV)=""

	#ACCEPT DATE=07/31/06;PGM=KELLYP;CR=unknown
	type ResultSet rs=Db.select(COLS,FID,WHERE)
	if rs.next() do {
		set NUMCOLS=COLS.length(",")
		for I=1:1:NUMCOLS do {
			set DI=DI_","_COLS.piece(",",I)
			set NV=NV_$C(1)_rs.getCol(I)
			}
		}

	set DI=DI.extract(2,DI.length())
	set NV=NV.extract(2,NV.length())

	quit

FEPLIST	// Get all of the clients associated with the host.

	// Array BRSFUPD,BRLIST is setup in order to provide a means to transfer high volume
	// account balances to client.

	type public String BRLIST(),BRSFUPD(),CLIENT(,),HOSTDIR

	type String FEP,VER
	
	set HOSTDIR=$$DIR^DDPUTL
	set VER="" 
	set FEP=""
	
	do FEPALL^DDPXFR
	for  set VER=CLIENT(VER).order() quit:VER.isNull()  do {
	
		for  set FEP=CLIENT(VER,FEP).order() quit:FEP.isNull()  do {

			set BRLIST(FEP)=""

			// Set up an array of sorted branch names for
			// use in the SFUPD update
			
			type ResultSet rs=Db.select("BRCD","UTBLBRCD","FEPDIR=:FEP")
			if rs.next() set BRSFUPD(FEP)=rs.getCol("BRCD")
			}
		}
	quit 
	

SFUPD	// Update SFUPD table with balances that have changed since last run
	
	// These are high volume transaction accounts that the bank prefers to
	// have current balances maintained on the client
	
	type public Cache %CACHE()
	type public String BRSFUPD(,)
	
	type Number BAL,BOO,CID
	
	type ResultSet sfupd=Db.select("SFUPD.CID,ACN.BAL,ACN.BOO","SFUPD LEFT OUTER JOIN (ACN) ON (SFUPD.CID=ACN.CID)","SFUPD.LASTBAL NOT = ACN.BAL")
	while sfupd.next() do {
		set CID=sfupd.getCol(1)
		set BAL=sfupd.getCol(2)
		set BOO=sfupd.getCol(3)
		
		type RecordUTBLBRCD ubrcd=%CACHE("UTBLBRCD").getRecord("UTBLBRCD","BRCD=:BOO")

		set BRSFUPD(ubrcd.fepdir,CID)=BAL

		type RecordSFUPD sfupd1=Db.getRecord("SFUPD","CID=:CID",1)
		set sfupd1.lastbal=BAL
		do sfupd1.bypassSave()
		}

	quit 

	
BRACNSND	// Send branch balance changes found in SFUPD to the appropiate branch

	type public Boolean ER
	type public Date DATE
	type public String BRSFUPD(),DDPDIR,RM
	type public Time TIME
	
	type Number BAL
	type String FEP,FEPDIR,GLOFILE,IO,X,XCID,%QN
	
	// Logical name of HOST directory
	set FEPDIR=""
	for  set FEPDIR=BRSFUPD(FEPDIR).order() quit:FEPDIR.isNull()  do {

		//  I $D<10 then not gui, I $D=1 then no accounts
		if BRSFUPD(FEPDIR).data()<10 quit 
		
		set %QN=$$GETQUE^DDPXFR1
		
		set IO=$$FILE^%TRNLNM("T"_%QN_".FEP",DDPDIR)
		set GLOFILE="T"_%QN_".FEP"
		set X=$$FILE^%ZOPEN(IO,"WRITE/NEWV",,5600)
		
		if 'X set ER=1,RM=X.piece("|",2) do ^UTLERR quit 
		
		use IO write "T,",%CurrentDate,",""BRACN"",CID,1,N,G",!

		set XCID=""
		for  set XCID=BRSFUPD(FEPDIR,XCID).order() quit:XCID.isNull()  do {
			set BAL=BRSFUPD(FEPDIR,XCID)
			write "F,CID",!,"S,N",!,"D,D,",XCID,!
			write "F,CID,LASTBAL,LASTDT,LASTTIME,ESTBAL",!
			write "S,N,$,D,N,$",!
			write "D,I,",XCID,",",BAL,",",DATE,",",TIME,",",BAL
			}
		close IO
		kill FEP set FEP(FEPDIR)=""
		do FILE^DDPXFR1
		}
	quit 


RECTYPE(String FILETYP,String FID)	// Record the type of record being written for inclusion into the TREC

	type public Boolean SPLITFLG

	if SPLITFLG quit "C"
	if FILETYP=7 quit "G"
	if Db.isDefined("STBLNOGUI","FID=:FID") quit "C"
	quit "B"

	
CLEANUP	// Delete RMS files from the host if all the copies were successful

	type String QN,X
	
	type ResultSet rs=Db.select("%QN,TBLRMS,DIRNAM","DDPTQUE")
	while rs.next() do {
		
		set QN=rs.getCol("%QN")
		
		type ResultSet rsque=Db.select("FEPDIR","DDPTQUE1","%QN=:QN")

		// Delete the rms file if no clients are attached to DDPTQUE
		if rsque.isEmpty() do {
			set X=$$DELETE^%OSSCRPT(rs.getCol("TBLRMS"),rs.getCol("DIRNAM"))
			do Db.delete("DDPTQUE","%QN=:QN")
			}
		}
        quit
	 
	 
HSYNCQUE	// Rename files and update tables DDPTQUE & DDPTWUE1

	/*
 	 This procedure creates its hostsync file names under a name different from 
 	 what is expected.  This procedure renames those files and completes other 
 	 housekeeping chores required for updates.
	*/

	type public Date BDATE,EDATE
	type public Number BSEQ,ESEQ
	type public String HOSTDIR,IO,IOLIST(),IONUMB()
	
	type Number SEQNO
	type String CFILE,DIR,QN,SAVELAST,VER,X
	
	// if 'HOSTDIR.exists() set HOSTDIR=$$DIR^DDPUTL
	
	type DbSet ds=Db.selectDbSet("CTBLCTC")
	while ds.next() do {

		type RecordCTBLCTC cty=ds.getRecord("CTBLCTC")

		if 'IO.isNull() do {

			set cty.fileno=cty.fileno+1
			do cty.bypassSave()
			
			type RecordDDPLOG ddplog=Class.new("RecordDDPLOG","SJD=:%CurrentDate")

			type ResultSet rs=Db.select("SEQNO","DDPLOG","SJD=:%CurrentDate","SEQNO DESC")
			if rs.next() set SEQNO=rs.getCol("SEQNO")+1
			else  set SEQNO=1

			set ddplog.seqno=SEQNO
			set ddplog.bdate=BDATE
			set ddplog.bseq=BSEQ
			set ddplog.edate=EDATE
			set ddplog.eseq=ESEQ
			set ddplog.ctyp=cty.ctyp
			set ddplog.daytime=%CurrentTime
			do ddplog.bypassSave()
			
			set DIR=$$TRNLNM^%ZFUNC(cty.dir,1)
			}

		if cty.ctyp="NATIVE" do {

			set VER="" 
			for  set VER=IOLIST(VER).order() quit:VER.isNull()  do {
				
				set QN=$$GETQUE^DDPXFR1
				
				set SAVELAST=BDATE_"~"_BSEQ_"~"_EDATE_"~"_ESEQ
				set IONUMB(VER)=QN
				set CFILE="T"_QN_".FEP"
				set DIR=cty.dir
				set DIR=$$TRNLNM^%ZFUNC(DIR)
				set X=$$FILE^%TRNLNM(CFILE,DIR)
				set X=$$COPYFIL^%OSSCRPT(IOLIST(VER),X)
				set X=$$DELETE^%OSSCRPT(IOLIST(VER))
				set IOLIST(VER)="T"_QN_".FEP"
				}
			}
		if cty.ctyp="NATIVE" do FILE^DDPXFR1
		}

	quit 

vSIG()	quit "60506^51497^Pat Kelly^21766"	// Signature - LTD^TIME^USER^SIZE
