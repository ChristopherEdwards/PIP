I18NTS //Create/Inquire/Delete Tset
  /*
	ORIG: kumarb - 10/25/2005
	DESC: Create/Inquire/Delete Tset

	 I18N=QUIT     This program does not need to follow I18N standards 
	 DESC:		This function program is used for management of  Tsets.
			Management includes creation, display and deletion.
	
			The program starts with prompting the user for a Tset
			name from an UTLREAD screen. The Tset name is from the
			UTLREAD screen testet against the I18NTSET global by 
			using the linetags utlpre and utlpost in this program.
	
			The I18NTS2 Screen is then called for user input.
	
			When returning from the screen this user input is 
			stored in the Tset global.
	
			The processing of selection criterias is basically
			divided into two disjunct parts. One part to run 
			directly thru the extracted phrases in I18NEXT and 
			another to run against a selected existing Tset.
			The latter gives the translator the opportunity to
			create a Tset as subset of another Tset.
	
			Both parts collate thru the source phrases for
			Tset creation and use selection criteria to verify
			if this phrase is to be included in the Tset.
			If it is, it is given an appropriate sequence number
			and stored in the I18NTS global. The sequencing 
			mechanism is incremental for both normalized and detail
			phrases within the scope of the Tset.
	
			The program contains a line tag for handling the sort
			selection criteria.  This is done after creating the
			Tset. 
	
			The last part of Tset creation is updating the Tset
			header with counter information. If no phrases were
			included in the Tset, it is killed.
	
			The program finally builds a return message in RM.
			
	 CALLED BY:	Menu system.  No other routines.
	 CALL TO:      $$DI^SCATAB		- Build %TAB for UTLREAD
			UTLREAD			- Get userinput acscesskeeys dB	
			OPEN^SCAIO		- Open output device
			I18NTS2 Screen program	- User input node dB 
			UTLERR			- Errorhandling
			CHANGE^DBSMACRO		- Field handling
			GETKEY^I18NUTL		- Get keys to extracted phrases
			$$TESTSEL^I18NUTL	- Test if phrase is valid
			PHRSPLIT^I18NUTL	- Split phrase into array
	
	 GLOBALS READ:
			I18NTS		- Tsets
	 GLOBALS SET:
			I18NTS		- Tsets
			I18NEXT		- Header level for normalized phrases
					  Detail level for detail phrases
	 ARGUMENTS:
	 INPUTS:
	
	 RETURNS:
	 EXAMPLE:
	 LIBRARY:
	
	---Revision History-------------------------------------------------
	
	10/21/05 - KUMARB - CR 16921
        	Converted to PSL.
        
	--------------------------------------------------------------------
	*/

	quit
	
NEW	// New

	type String HDG

	set %ProcessMode=0,HDG=$$^MSG(5899)
	do INIT

	quit
	
DIS	// Display

	type String HDG
	
	set %ProcessMode=2,HDG=$$^MSG(5900)
	do INIT

	quit
	
DEL	// Delete

	type String HDG
	
	set %ProcessMode=3,HDG=$$^MSG(5901)
	do INIT

	quit
	
INIT //

	type Boolean selsort,techword,wrdwrt,wrtnorm
	type Date extdt,extdt2,selextdt
	type Number act,cnt,cnth,detlcnt,normcnt,phrtyp,selnonorm,tsseqN,tsseqD,%PAGE,%PG
	type String np,OLNT,pw,selpmsk,selpt,seltset,src,x

	set %PG=0,%PAGE=1,normcnt=0,detlcnt=0,cnt=0,cnth=0

	do QUERY

	quit

QUERY // Set up

	type public Number %PG
	type public String HDG 

	type Number TSID
	type String IO,VFMQ,%NOPRMT,%READ,%TAB()

	set HDG=$J("",40-(HDG.length()/2))_HDG
	
	set %TAB("TSID")=$$DI^SCATAB("[I18NTS2]TSID","Tset ID",12,"[I18NTS2]","D utlrpost^I18NTS","D utlrpre^I18NTS","U")
	if (%ProcessMode=2) set %TAB("IO")=$$IO^SCATAB($I)
	
	set %READ="@HDG,,TSID#1"
	if %ProcessMode=2 set %READ=%READ_",,IO#1"
	set %NOPRMT="C"
	do ^UTLREAD if "Q"[VFMQ quit
	
	if %ProcessMode=2,IO'=$I do OPEN^SCAIO
	set %PG=%PG+1

	type RecordI18NTS2 i18nts2=Db.getRecord("I18NTS2","TSID=:TSID",1)

	if "CDFQ"[VFMQ do VER(.i18nts2) quit

	do SCREEN(.i18nts2)

	quit
	
SCREEN(RecordI18NTS2 i18nts2) // Screen

	type public String VFMQ

	type String SID
	
	set SID="I18NTS2"
	do DRV^USID(%ProcessMode,SID,.i18nts2)

	if "CDFQ"[VFMQ do VER(.i18nts2) quit

	quit

utlrpre	// UTLREAD pre-proc

	type public Number %OSAVE,act
	
	if %OSAVE.exists() set act=%OSAVE
	else  set act=%ProcessMode
	
	if act=0 do CHANGE^DBSMACRO("TBL","")
	else  do CHANGE^DBSMACRO("TBL","[I18NTS2]")
	
	quit
	
utlrpost // UTLREAD post-proc

	type public Number act,X
	
	if act=0 do CHANGE^DBSMACRO("TBL","")
	else  do CHANGE^DBSMACRO("TBL","[I18NTS2]")

	type RecordI18NTS2 i18nts2=Db.getRecord("I18NTS2","TSID=:X",1)
	// Tset already exists. Delete it or use another name.
	if (act=0),(i18nts2.getMode()) do Runtime.setErrMSG("I18NTS2",5439)
	
	quit
	
VER(RecordI18NTS2 i18nts2) //

	type public Boolean selsort,techword,wrtdet
	type public Date extdt,extdt2,selextdt
	type public Number normcnt,selnonorm,TSID
	type public String np,selpmsk,selpt,seltset,src,VFMQ
	
	if (%ProcessMode=1)!(%ProcessMode=2)!(%ProcessMode=4)!(VFMQ="Q") do END quit
	if %ProcessMode=3 do Db.fastDelete("I18NTS2","TSID=:TSID") do END quit
	
	//File header data(TS sel crit)
	do FILE1(.i18nts2)
	
	set selpmsk=i18nts2.selpmsk		// Phrasemask
	set selpt=i18nts2.selptype		// Phrasetype
	set techword=(i18nts2.selptype="10")	// Technical Word
	set selextdt=i18nts2.selextdt		// Extraction date
	set seltset=i18nts2.selsubts		// Tset
	set selsort=i18nts2.selsort		// Sort by # of occurence
	set selnonorm=i18nts2.selnonorm		// Number of normalized phr
	
	set (np,src)=""	
	
	// Collate thru ^I18NEXT
	if seltset="" do {
		if techword set i18nts2.selptype="*"
		type ResultSet rs
		if selextdt="" do {
			set (extdt,extdt2)=selextdt
			set rs=Db.select("NORMPHR","I18NEXTH")
			}
		if selextdt'="" do {
			set extdt=selextdt
			set rs=Db.select("NORMPHR","I18NEXTH","EXTDT=:selextdt")
			}

		// Collate extracted phrases
		while rs.next() do {
			set np=rs.getCol("NORMPHR")
			if (+selnonorm),(normcnt'<selnonorm) quit
			do phrase(.i18nts2)
			}
		}
	
	// Collate thru selected Tset in ^I18NTS
	if seltset'="" do {
		type DbSet ds=Db.selectDbSet("I18NTSETN","TSID=:seltset")
		while ds.next() do {
			if (+selnonorm),(normcnt'<selnonorm) quit

			kill src
			
			type RecordI18NTSETN i18ntsn=ds.getRecord("I18NTSETN")		
			// Get keys into ^I18NEXT for phrase with this sequence number
			do GETKEY^I18NUTL(.i18ntsn,.extdt,.np,.src)
		
			// Process this phrase in selected Tset
			type RecordI18NEXTD i18nextd=Db.getRecord("I18NEXTD","EXTDT=:extdt,NORMPHR=:np,GLOBREF=:src",1)
			// Object i18nts2 pieces 14-24
			if $$TESTSEL^I18NUTL(.i18nts2,extdt,np,0,.i18nextd) do phrase2(.i18nts2)
			}
		}
	
	// File counter information
	do FILE3(.i18nts2)
	
	// Sort the Tset if wanted
	if selsort do sort 		
	
	// Finished processing of Tset
	do END
	
	quit
	
phrase(RecordI18NTS2 i18nts2)	 // if other phrase types go on detail level
	
	type public Boolean techword,wrdwrt,wrtnorm
	type public Date extdt
	type public Number cnt,cnth,phrtyp
	type public String np,src
	
	set wrtnorm=0,src="",wrdwrt=1
	
	// Collate thru detail phrases in ^I18NEXT
	type DbSet ds=Db.selectDbSet("I18NEXTD","EXTDT=:extdt AND NORMPHR=:np")
	while ds.next() do {
		type RecordI18NEXTD i18nextd=ds.getRecord("I18NEXTD")
		set src=i18nextd.globref
		set cnt=cnt+1
		if cnt#1000=0 write $$MSG^%TRMVT(cnt_" Records Processed With "_cnth_" Matches")
		// Test if phrase meets selection criteria
		// Object i18nts2 pieces 14-24
		if $$TESTSEL^I18NUTL(.i18nts2,extdt,np,src,.i18nextd) do {
			set phrtyp=i18nextd.ptype
			
			// file normalized phrase just ones and not technical words
			if '(wrtnorm),'(techword) do FILE2N
			
			// File all detail phrases that meets selection criterias
			if 'techword do FILE2D
			
			// Write out phrase words if not already written
			if (techword),(wrdwrt) do FILE2W
			}
		}
	quit
	
phrase2(RecordI18NTS2 i18nts2) //

	type public Boolean wrtdet,wrtnorm
	type public Date extdt
	type public Number tsseqD
	type public String np,src()

	set wrtnorm=0,tsseqD=0
	
	// collate thru detail level of selected Tset
	for  set tsseqD=src(tsseqD).order() quit:tsseqD=""  do {
		set src=src(tsseqD)
		type RecordI18NEXTD i18nextd=Db.getRecord("I18NEXTD","EXTDT=:extdt,NORMPHR=:np,GLOBREF=:src",1)
		// Object i18nts2 pieces 14-24
		set wrtdet=$$TESTSEL^I18NUTL(.i18nts2,extdt,np,src,.i18nextd)
		
		// Write normalized phrase just ones if it meets selection criterias
		if ('wrtnorm),(wrtdet) do FILE2N
		
		// Write all detail phrases that meets selection criterias
		if wrtdet do FILE2D
		}
	quit
	
sort	// sort if flag selsort is set
	
	type public Boolean techword
	type public Date extdt
	type public Number TSID,tsseqN
	type public String np
	
	type Number CNT
	type String ptcnt
	
	type ResultSet rs=Db.select("NSEQ,EXTKEY2N,EXTKEY1N","I18NTSETN","TSID=:TSID")
	while rs.next() do {
		set tsseqN=rs.getCol("NSEQ")
		set extdt=rs.getCol("EXTKEY1N")
		set np=rs.getCol("EXTKEY2N")
		
		type RecordI18NEXTH i18nexth=Db.getRecord("I18NEXTH","EXTDT=:extdt,NORMPHR=:np",1)
		if techword do {
			set ptcnt=i18nexth.ptcnts
			set CNT=ptcnt.piece(",",10) 
			}
		else  do {
			set CNT=i18nexth.phrcnt
			}
		
		if 'CNT do {
			do Db.delete("I18NTSETN","TSID=:TSID AND NSEQ=:tsseqN")
			do Db.delete("I18NTSETD","TSID=:TSID AND NSEQ=:tsseqN")
			}
		}
	
	quit
	
FILE1(RecordI18NTS2 i18nts2) // File TS header data ( selections )
	
	do i18nts2.save()
	
	quit
	
FILE2N	 // File TSID,SEQN ( ^I18NEXT key )

	type public Boolean wrtnorm
	type public Date extdt
	type public Number cnth,normcnt,TSID
	type public String np
	
	set wrtnorm=1
	set normcnt=normcnt+1
	set cnth=cnth+1

	type RecordI18NTSETN i18ntsn=Db.getRecord("I18NTSETN","TSID=:TSID,NSEQ=:normcnt",1)
	set i18ntsn.extkey2n=np
	set i18ntsn.extkey1n=extdt
	do i18ntsn.save()
	
	quit
	
FILE2W	 // File Technical words 
	
	type public Boolean techword,wrdwrt
	type public Date extdt
	type public Number cnth,normcnt,phrtyp,TSID
	type public String np,pw,x
	
	if 'phrtyp.exists() quit
	if '(techword)!(phrtyp>5) quit
	
	// Set controlling variable to stop wordprocessing for this norm.phrase
	set wrdwrt=0
	
	// Get word array
	do WRDSPLIT(np,.pw)
	set x=""

	// Collate thru valid words in phrase
	for  set x=pw(x).order() quit:x=""  do {
		type RecordI18NEXTH i18nexth=Db.getRecord("I18NEXTH","EXTDT=:extdt,NORMPHR=:x",1)
		if (x'?.NP_" "_$C(9)_$C(127)),(i18nexth.getMode()) do {
			set normcnt=normcnt+1
			set cnth=cnth+1
			type RecordI18NTSETN i18ntsn=Db.getRecord("I18NTSETN","TSID=:TSID,NSEQ=:normcnt",1)
			set i18ntsn.extkey2n=x
			set i18ntsn.extkey1n=extdt
			do i18ntsn.save()
			}
		}

	quit
	
WRDSPLIT(String wphr,String wpw) // Splitt incoming phrase into array 

	type Number i
	
	kill wpw
	
	set wpw=""
	 
	if (wphr.get()).isNull() quit
	 
	// Cre arr wpw(word)=piece in orig phrase 
	for i=1:1:wphr.length(" ") if wphr.piece(" ",i)'="" set wpw(wphr.piece(" ",i))=i 
	
	quit 
	
FILE2D	 // File TSID,SEQN,SEQD ( ^I18NEXT key )

	type public Date extdt
	type public Number cnth,detlcnt,normcnt,TSID
	type public String np,src
	
	set detlcnt=detlcnt+1
	set cnth=cnth+1
	type RecordI18NTSETD i18ntsd=Db.getRecord("I18NTSETD","TSID=:TSID,NSEQ=:normcnt,DSEQ=:detlcnt",1)
	set i18ntsd.extkey3=src
	set i18ntsd.extkey2=np
	set i18ntsd.extkey1=extdt
	do i18ntsd.save()
	
	quit
	
FILE3(RecordI18NTS2 i18nts2) // File TS header data ( statistics )

	type public Number detlcnt,normcnt,TSID
	type public String VFMQ
	
	set i18nts2.nonorm=normcnt
	set i18nts2.nophr=detlcnt
	set i18nts2.lstphr=0
	do i18nts2.save()
		
	// Kill Tset if no phrases meet selection criteria
	if (normcnt<1) do {
		do Db.fastDelete("I18NTS2","TSID=:TSID")
		set VFMQ="Q"
		}
	quit

END	// Clean up and produce return message in RM

	type public Number detlcnt,normcnt,TSID
	type public String %TAB(),ER,RM,VFMQ
	
	if (ER.get())!(%ProcessMode=2)!(%ProcessMode=4) quit
	set ER="W"
	// Tset ~p1 ~p2
	set RM=$$^MSG(5462,TSID.get(),$S(VFMQ="Q":" not ",1:" ")_$S(%ProcessMode=0:"created: "_normcnt_" normalized phrases "_detlcnt_" detail phrases",%ProcessMode=3:"deleted",1:"done"))

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60235^24984^Balasubramonian Sankar^11365"	// Signature - LTD^TIME^USER^SIZE
