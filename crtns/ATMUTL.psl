ATMUTL		/*
	 Procedure ID: ATMUTL
	 DESC: ATM Utility Functions
	 ORIG: Ed Sigda - 08/30/2001

	 DESC:  ATM Utilities for use with the ANSI X9.2 and ISO 8583
		Online ATM interfaces.

	 The logic to support Split Day processing contained in this routine
	 is valid for versions V6.3 and above.

	 LIBRARY:
	 . POST		Post financial transactions
	 . ATMPRE	Pre-authorization
	 . FINPRE	Delete PHLD and ATMHLD entries.
	 . CHKRSP	Check for insufficient funds entries in SPV array
	 . REV		Reverse financial transactions
	 . TTX		Create a transaction record
	 . STFCHK	Determine if a transaction has already been posted
	 . FINDH	Find history entry matching SPR and TLO
	 . JD		Return date in julian format  (input = MMDD)
	 . GETTRN	Determine PROFILE transaction codes
	 . TLRPDT	Determine and validate TPD (teller posting date)
	 . NXTSEQ	Unique message sequence
	 . ADDPHLD	Insert entry into PHLD
	 . CKTRN	Update the CK transaction in the transaction set
	 . EXCHANGE	Create exchange transactions
	 . CNVAMT	Convert transaction amount
	 ----------------------------------------------------------------------
	 ---- Revision History ------------------------------------------------
	 08/2707 - Brandon Rickards - CR 28685
	 	o Removed SPV from new lists in sections ATMPRE and PROCSTF

	 06/23/07 - Brandon Rickards - CR 27711
	 	o Modified section REV to use $$TAMT^TRNUTL to determine
	 	  reversal transaction amount

	 06/07/07 - Brandon Rickards - CR 27424
	 	o Modified section NXTSEQ to fix undefined JOB variable.

	 05/11/07 - Brandon Rickards - CR 27068
	 	o Release including the following changes:

			Merged Profile_V72 version with most recent release version

			03/26/07 - Brandon Rickards
			Added section ATMSEQ to get and update next unique sequence
			number for a specific Process ID.
			Modified section NXTSEQ to call new section ATMSEQ

	 		07/20/06 - Brandon Rickards - CR 22312
	 		Modified section POST to use NSF error code (51) rather than
	 		generic error code (05) in Response Code BIT(39).

	 		14-Jan-2005 - Chris Rickards - CR 14035
			o Modified sections ATMPRE & PROCSTF to remove SPV from
		  	the new list

	 		30-Sep-2004 - Chris Rickards - CR 12012
			o Modified section POST to protect variable PAMT. Previously,
		  	the ISO interface was adding the partial authorization amount
		  	into bit 54 because PAMT was redefined within transaction
		  	processing (routine LNPTS2).

	 		20-May-2004 - Chris Rickards - CR 10259
			o Modified section ATMPRE to rebuild the ttx object array
		  	based on the transactions included in the TranSet object
		  	after the call to the postTset method.
			o Modified section REV and removed pre-auth reversal logic
			o Added section REVPRE to handle removing pre-auth holds

	 		20-Apr-2004 - Chris Rickards - CR 9652
			o Added the following enhancements:
			04-Nov-2003 - Ed Sigda
	 		o Modified section REV to set FLG=6 (error correct) when 
	 	  	RECTYP'="HIST".
	 	  
			09-Jun-2003 - Chris Rickards - patch for KTB ISO 8583 interface
			o Modified section POST to rebuild the ttx object array
		  	based on the transactions included in the TranSet object
		  	after the call to the postTset method.
			o Modified section REV to reverse all transactions on the
		  	Profile screen as determined by FINDH.
			o Modified section PROCSTF to rebuild the ttx object array
		  	based on the TR array returned by the call to
		  	STFHNDL^STFUTL.
			o Modified section FINDH to search primary transactions only.

			Retrofit of :
			08/24/05 - SIGDAE - 17045
			Modified section NXTSEQ to add the character "A" to the end
			of the unique sequence to insure order within GT.M.  
			MSGID's with more than 3 trailing zeros are treated as numeric 
			instead of strings.  This causes the order to be lost.  

	 01/09/07 - MBUIM
	 	When a posting error occurs, the error (and supervisory 
	 	override information) does not get returned from section 
	 	POST^ATMUTL, resulting in a successful response to the calling
	 	application.  The following variables are now typed public. 
	 	ER, RJ, SPV, and RSPCD.
	 	
	 05/18/05 - GIRIDHAL - CR 21297
	 	Modified section TLRPDT to remove references to Split Day 
	 	Processing as it is obsolete. Modified section FINDH to remove
	 	all references to SPLTDY and associated logic 
	 	
	 02/10/06 - KUMARB - CR 19502
	 	Modified all the Runtime.setErrMSG calls to pass the 
	 	correct parameters.

	 12/15/05 - PRAKASHJ - CR17423
	 	Removed PSL deprecited features and warnings.
	 	
	 10/27/05 - KELLYP - CR 16880
	 	Modified call to TRNSET^TRNDRV to correct parameters being 
	 	passed (RJ was being passed in PTRC's place).  Also removed
	 	"ORDER BY" from order by clause in multiple SQL selects to 
	 	prevent compilation errors and removed pre-2003 revision 
	 	history.

	 11/04/03 - CARROLLj - 51630
		Modified call to TRNSET^TRNDRV to pass correct parameters.

	 06/27/03 - ZWITKOWITSM - 51349
		Made changes to eliminate Tset processing.  Removed references
		to TTXP2 and general clean-up.
	 ----------------------------------------------------------------------
	*/
	quit



public POST(RecordTTX ttx(),Number CID,Date TPD,String BRCD,String TSPV,String STF)

	/*
	 Post financial transactions

	 Messages coming in as ADVICES have already been processed by the
	 ATM switch and must be processed as store and forward transactions
	 on PROFILE. This means that store and forward transactions MUST be
	 successfully processed on PROFILE since the transaction has already
	 been approved by the ATM switch. The supervisory override array,
	 TSPV, is set up so the PROFILE ATM teller has authorization over
	 all generated transactions. Also, bit 10 of ITC for each transaction
	 is turned on indicating that the transaction is off-line.

	 ARGUMENTS:
		TPD	- Teller posting date
		BRCD	- Branch code
		TSPV	- Teller supervisory array
		STF	- ATM switch store and forward flag

	 Called by: ANSIX92, ISO8583, and MRPC029
	*/

	type public Boolean ER
	type public String %STFHOST,RJ(),RSPCD,SPV()

	type String %IPMODE,CRT,LPSEQ,OVR(,,),par,UID,x
	type Number seq

	// If STF, modify transactions to off-line transactions
	if STF do {
		set seq=0
		while ttx(seq+1).exists() set seq=seq+1 if '(ttx(seq).itc).isNull() set ttx(seq).itc=$$ITC^TTXEXT(ttx(seq).itc,10)
		}

	if %STFHOST do { quit
		do PROCSTF(.ttx(),CID,TPD,BRCD,.TSPV,STF)
		set RSPCD=$$CHKRSP(CID,STF,.SPV,"",0)
	}

	// Define transaction trace number for error-correct transactions
	set UID=%UserID

	if %EffectiveDate'>%SystemDate do {
		type RecordTTXUID ttxuid=Db.getRecord("TTXUID","TPD,BRCD,UID",1)
		set LPSEQ=ttxuid.lpseq
		}
	else  do {
		type RecordTTXFDTUID ttxfdt=Db.getRecord("TTXFDTUID","TPD,BRCD,UID",1)
		set LPSEQ=ttxfdt.endseq
		}

	set LPSEQ=(LPSEQ+1)*1000

	// This code does not support secondary transactions
	set seq=1
	while ttx(seq).exists() do {
		set ttx(seq).trc=LPSEQ+seq	// Transaction trace 
		set seq=seq+1
		}

	set %IPMODE="NOINT"
	set CRT=0				// Mirror batch handling of overrides
	set par("IPMODE")=$S(STF:2,1:1)		// 1 - online, 2 - SAF
	set par("OPTION")=2			// Process and update database
	set par("UPDTTX")=1			// Create TTX entries
	set par("KEEPOVR")=1			// Keep override and reject info
	if %MCP set par("EXCHNG")=1		// Build currency exchange offsets

	/*
	 ***NOTE*** There is a bug in routine LNPTS2 that is not protecting
	 (newing) variable PAMT. This causes the ISO interface to add the
	 partial authorization amount into bit 54 (additional amounts).
	*/
	type Number PAMT

	// 1 - online, 3 - STF
	do TRNSET^TRNDRV(.ttx(),TPD,BRCD,$S(STF:3,1:1),,.RJ,.SPV,.OVR)

	if RJ.data() set ER=1

	if 'ER do SETPRF^TTXLOK			// Needs TPD,BRCD

	// Deny the transaction if error
	set RSPCD=$$CHKRSP(CID,STF,.SPV,"",0)

	quit 


public ATMPRE(RecordTTX ttx(),Number CID,String CRCD,Number TCMT,Number SPR,String AUTCODE,String TSO,Date TPD,String BRCD,String STF,String PAUTH,Number PAMT)
	/*
	Pre-authorization

	 A permanent hold (PHC=92) is placed on the account with an 
	 expiration date of today+PHDAYS.
	
	 ARGUMENTS:
		CID	- PROFILE account number
		CRCD	- Transaction currency code
		TCMT	- Transaction comment
		SPR	- Spray value
		AUTCODE	- Authorization code
		TSO	- Transaction source of funds
		TPD	- Teller posting date
		BRCD	- Branch code
		STF	- ATM switch store and forward flag
		PAUTH	- Partial authorizations allowed
		PAMT	- Partial authorization amount
	 INPUTS:
		PHC	- Permanent hold code
		PHDAYS	- Permanent hold days
		CUTOFF	- Hold cutoff time
	*/
	type public Boolean ER
	type public Number PHC,PHDAYS,RSPCD
	type public Date BCAL,CUTOFF
	type public String RM
	type String OVR(,,),par,RC,RJ(),SAVPTR,ts,x
	type Number TAMT

	set TAMT=ttx(1).tamt
	set PAMT=""

	// Transaction amount was converted
	if '(ttx(1).bseamt).isNull(),ttx(1).bseamt'=TAMT set TSO=$$FIELDIN^UTSO(TSO,"TCUR",ttx(1).bseamt_ttx(1).bcrcd)

	// If STF, just add hold to the account
	if STF do { quit
		do ADDPHLD(CID,TAMT,TCMT,SPR,AUTCODE,TSO,BCAL,PHC,PHDAYS,CUTOFF)
		if ER set RSPCD=3764
	}

	// Process only the first transaction in the transaction set
	do Runtime.start("CS","","SAVPTR")
	do TRNSINGL^TRNDRV(.ttx(1),,TPD,BRCD,1,.RJ,.SPV,.OVR)
	do Runtime.rollback("SAVPTR")

	if RJ.data() set ER=1

	set RSPCD=$$CHKRSP(CID,STF,.SPV,.PAMT,PAUTH)

	// Partial preauthorization
	if RSPCD=10 do {
		kill RJ,SPV
		set ER=0
		set RM=""

		set ttx(1).tamt=PAMT
		
		do Runtime.start("CS","","SAVPTR")
		do TRNSINGL^TRNDRV(.ttx(1),,TPD,BRCD,1,.RJ,.SPV,.OVR)
		do Runtime.rollback("SAVPTR")

		if RJ.data() set ER=1
		
		set RC=$$CHKRSP(CID,STF,.SPV,,PAUTH)
		if RC=10 set RSPCD=3764 quit	// Denied 2nd time, reject
		if RC'="00" set RSPCD=RC quit
		set TAMT=PAMT
	}

	quit:ER

	// Add hold to the account
	if 'ER do ADDPHLD(CID,TAMT,TCMT,SPR,AUTCODE,TSO,BCAL,PHC,PHDAYS,CUTOFF)
	// Error Posting Transactions.
	if ER set RSPCD=3764

	quit


public PREDEL(Number CID,Number SPR,String PHC,String STF,Number TRTYP)

	/*
	Completions to previously placed pre-authorization holds.
	Delete PHLD and ATMHLD entries.

	ARGUMENTS:
		CID	- PROFILE account number
		SPR	- Spray Number
		PHC	- Permanent hold code
		STF	- ATM switch store and forward flag
		TRTYP	- Transaction type
	*/

	type Date EXPDT
	type Number SEQ
	type String XTLO

	// Posted to suspense
	if STF,TRTYP["SUSP" quit

	type ResultSet rs
 
	// Delete PHLD and ATMHLD records
	set SEQ=""
	set XTLO=%UserStation
	set rs=Db.select("SEQ,EXPDT","PHLD","CID=:CID AND PHC=:PHC AND SPR=:SPR AND TLO=:XTLO","SEQ DESC")
	if 'rs.isEmpty(),rs.next() set SEQ=rs.getCol("SEQ"),EXPDT=rs.getCol("EXPDT")

	// No hold exists
	if SEQ.isNull() quit

	// Remove the hold
	do Db.delete("PHLD","CID=:CID AND SEQ=:SEQ")
	do Db.delete("ATMHLD","EXPDT=:EXPDT AND CID=:CID AND SEQ=:SEQ")
 
	quit


public CHKRSP(Number CID,String STF,String SPV,Number PAMT,Number PAUTH)
	/*
	 Check for insufficient funds entries in SPV array
	 ARGUMENTS:
		CID	- PROFILE account number
		STF	- ATM switch store and forward flag
		SPV	- Supervisory override array
		PAMT	- Partial amount
		PAUTH	- Partial authorizations allowed
	 RETURNS:
		Response code
		. 00	- Transaction Approved - With Balances
		. 10	- Partial Preautorization
		. 1244	- Insufficient Funds
		. 3764	- Error Posting Transactions.
	*/
	type public Boolean ER
	type public String RM
	type Number AMT
	type String RC,X

	set PAMT=""

	// Approved
	if 'ER!STF set ER=0 quit "00"

	// Error Posting Transaction.
	if RM.get().isNull() set RM=$$^MSG(3764)
 
	set RC=3764

	if '(SPV("").order()).isNull() quit RC

	// Collate through SPV array, set PAMT to smallest positive amount
	set X=""
	for  set X=SPV(1,CID,"OVR",X).order() quit:X.isNull()  do { quit:X="RSKAVL"
		if SPV(1,CID,"OVR",X).piece("|",1)'="*" quit
		if "-AVLBAL-BAL-BALAVL-BALCOL-ODUNAMT-RSKAVL-"[("-"_X_"-") do {
			set RC=1244
			if 'PAUTH set X="RSKAVL" quit
			set AMT=SPV(1,CID,"OVR",X).piece("|",2)
			if AMT<0 quit
			if PAMT.isNull()!(AMT<PAMT) set PAMT=AMT
		}
	}

	if PAUTH,PAMT>0 set RC=10
	quit RC

public REV(RecordTTX ttx(),Number PCID,Number AMT2,Number SPR,String AUTCODE,String ATMM,String BRCD,Number PSTDYS,String PARTIAL)
	/*
	 Reverse POS and financial transactions

	 Reverse the original transaction. If the original amount was
	 incorrect, then process the transaction with the correct amount
	 after the original is reversed.
	 ARGUMENTS:
		PCID    - PROFILE account number
		AMT2	- Correction amount
		SPR     - Spray value
		AUTCODE	- Authorization code
		ATMM	- Unique message sequence
		BRCD	- Branch code
		PSTDYS	- Number of days to search back in account history
		PARTIAL	- Partial reversal transaction
	 INPUTS:
		TCMT	- Transaction comment
		CRCD	- Currency code
		DELDUP	- Delete duplicates flag
	*/
	type public Boolean ER
	type public Number PHC,PHDAYS,PRE,RSPCD,STF
	type public Date BCAL,CUTOFF,HTJD
	type public String CRCD,DELDUP,REVTSO,RM,SAVTSO,TCMT,TRAN,TSO
	type Boolean FLG
	type Number CID,EXCAMT,MAXRATE,MAXSEQ,MINRATE,MINSEQ,MULTIPLY
	type Number RATE,RECTYP,SCREEN,seq,SEQ,STFSEQ,TAMT,TRSEQ,TSEQ,VARIANCE,XTRC
	type Date EFD,HTJD,TPD
	type String CLS,ETC,hist,ITC,TMPTSO,TRC,TRESREF,TRN,UID,XTLO

	type ResultSet rs1,rs2,rs3,rs4
	type RecordTRN trn
	type RecordTTXFDT ttxfdt
	type RecordSTFHOST stfhost

	// Initialization
	set XTLO=%UserStation
	set UID=%UserID
	set EFD=""

	// Check ATMDUP table for duplicate message to reverse
	set SEQ=Db.currVal("ATMDUP","XTLO,SPR")
	if DELDUP,('SEQ.isNull()) do Db.delete("ATMDUP","TLO=:XTLO AND SPR=:SPR AND SEQ=:SEQ") quit

	type RecordTTX ttxtmp=Class.new("RecordTTX")
	// Find original transaction, use TSEQ to get original TR's
	do FINDH(.ttxtmp,PCID,SPR,PSTDYS,.TSEQ,.STFSEQ,.TRSEQ,.RECTYP)
	// Unable to locate transaction in account history
	if RECTYP.isNull() set RSPCD=2793 do Runtime.setErrMSG("TTX",2793) quit

	// ASSERT: TRAN contains either a HIST or TR record 

	// Check if transaction has already been reversed or error corrected
	set ITC=ttxtmp.itc
	// Transaction already error-corrected
	if ITC.extract(6)!ITC.extract(12) set RSPCD=2676 do Runtime.setErrMSG("TTX",2676) quit

	// Reset message sequence & trace number
	set TSO=ttxtmp.tso
	set TMPTSO("ATMM")=ATMM
	if 'AUTCODE.isNull() set TMPTSO("AUTCODE")=AUTCODE
	do IN^UTSO(.TMPTSO,.TSO)

	// Transaction found in history
	if RECTYP="HIST" do {
		// Determine transaction trace number & posting date
		set HTJD=ttxtmp.tjd
		set TPD=ttxtmp.tjd+ITC.extract(8)
		set XTRC=ttxtmp.trc

		// Retrieve TTX transactions
		set SCREEN=XTRC\1000*1000
		set rs1=Db.select("TSEQ","TTX","TJD=:TPD AND BRCD=:BRCD AND UID=:UID AND TSEQ BETWEEN :SCREEN AND (:SCREEN+1000)")
		if rs1.isEmpty() set ER=1 quit
		while rs1.next() do { quit:ER
			set TRC=rs1.getCol("TSEQ")

			// Determine array sequence
			set seq=TRC#1000

			// Retrieve transaction information
			set ttx(seq)=Db.getRecord("TTX","TPD,BRCD,UID,TRC",1)
			if ttx(seq).getMode()=0 kill ttx(seq) set ER=1 quit

			// Retrieve transaction code information
			set ETC=ttx(seq).etc
			if ETC="" set ER=1,RM=$$^MSG(1498) quit

			set trn=Db.getRecord("TRN","ETC",1)
			// Invalid transaction code
			if trn.getMode()=0 do Runtime.setErrMSG("TRN",1498,ETC) quit

			// Determine Profile account history sequence
			set CID=ttx(seq).cid
			set TSEQ=""
			if trn.cls'="M" do {
				set TAMT=ttx(seq).tamt
				set rs2=Db.select("TSEQ","HIST","CID=:CID AND TJD=:HTJD AND ETC=:ETC AND TAMT=:TAMT AND TLO=:XTLO AND SPR=:SPR","TSEQ DESC")
				if 'rs2.isEmpty(),rs2.next() set TSEQ=rs2.getCol("TSEQ")
			}

			// Store history sequence and transaction sequence number
			set TRN(CID,TRC)=TSEQ_"|"_TRC
		}
	}

	// Transaction was found in TTXFDT
	if RECTYP="TTXFDT" do {
		// Determine transaction trace number & posting date
		set EFD=ttxtmp.efd
		set XTRC=ttxtmp.trc

		// Retrieve TTXFDT transactions
		set SCREEN=XTRC\1000*1000
		set rs3=Db.select("TSEQ","TTXFDT","TJD=:EFD AND BRCD=:BRCD AND UID=:UID AND TSEQ BETWEEN :SCREEN AND (:SCREEN+1000)")
		if rs3.isEmpty() set ER=1 quit
		while rs3.next() do { quit:ER
			set TRC=rs3.getCol("TSEQ")

			// Determine array sequence
			set seq=TRC#1000

			// Retrieve transaction information
			set ttxfdt=Db.getRecord("TTXFDT","EFD,BRCD,UID,TRC")

			// Translate TTXFDT object to a TTX object
			do ttxfdt.toArray("TRAN")
			set ttx(seq)=Class.new("RecordTTX")
			set ttx(seq).tjd=ttxfdt.tjd
			set ttx(seq).brcd=ttxfdt.brcd
			set ttx(seq).uid=ttxfdt.uid
			set ttx(seq).tseq=ttxfdt.tseq
			do ttx(seq).fromArray("TRAN")

			// Store history sequence and transaction sequence number
			set CID=ttx(seq).cid
			set TRN(CID,TRC)=""
		}
	}

	// Transaction was found in store and forward
	if RECTYP="STFHOST"  do {
		// Retrieve STFHOST transactions
		set rs4=Db.select("TRSEQ","STFHOST","STFSEQ=:STFSEQ AND TRSEQ BETWEEN 0 AND 1000")
		if rs4.isEmpty() set ER=1 quit
		while rs4.next() do { quit:ER
			set TRSEQ=rs4.getCol("TRSEQ")

			// Retrieve transaction information
			set stfhost=Db.getRecord("STFHOST","STFSEQ,TRSEQ")		

			// Translate STFHOST.TR to a TTX object
			set TRAN=stfhost.tr
			set ttx(TRSEQ)=Class.new("RecordTTX")
			set ttx(TRSEQ).tjd=stfhost.tjd
			set ttx(TRSEQ).brcd=stfhost.brcd
			set ttx(TRSEQ).uid=stfhost.uid
			set ttx(TRSEQ).tseq=stfhost.tseq
			do ttx(TRSEQ).fromArray("TRAN")
		}
	}
	if ER set RSPCD="05" quit

	// Save TSO for partial reversal transactions
	set SAVTSO=TSO

	// Modify original transactions with reversal information
	set seq=""
	for  set seq=$O(ttx(seq)) quit:seq=""  do { quit:ER
		// Verify transaction has not already been reversed
		if ttx(seq).itc6!ttx(seq).itc12 set ER=1 quit

		// Determine error-correct/reversal flag
		set FLG=$S(RECTYP'="HIST":6,ttx(seq).tjd=%SystemDate:6,1:12)

		set ttx(seq).itc=$$ITC^TTXEXT(ttx(seq).itc,FLG,1)

		// Add reversal fields to TSO
		set CID=ttx(seq).cid
		set TRC=ttx(seq).tseq
		if RECTYP="HIST",$D(TRN(CID)) do {
			if ttx(seq).tjd=%SystemDate set REVTSO("EC")=TRN(CID,TRC).piece("|",2)
			else  set REVTSO("REV")=+TRN(CID,TRC).piece("|",1)
			set ttx(seq).tcmt="ATM Reversal of "_+TRN(CID,TRC).piece("|",1)
			}
		if RECTYP="TTXFDT" do {
			set REVTSO("FDTSEQ")=TRC
			set REVTSO("EC")=TRC
			}
		if RECTYP="STFHOST" set REVTSO("EC")="STF"_STFSEQ_"-"_seq
		do IN^UTSO(.REVTSO,.TSO)

		// Reverse transaction amount
		set ttx(seq).tamt=$$TAMT^TRNUTL(ttx(seq).tamt)
		set ttx(seq).tso=TSO
		set ttx(seq).spr=SPR
	}
	if ER set RSPCD="05" quit

	// Build partial reversal transactions
	if PARTIAL for seq=1,2 do TTX(.ttx(),ttx(seq).cid,ttx(seq).etc,AMT2,EFD,SAVTSO,TCMT,SPR,CRCD)

	quit


public REVPRE(PCID,CRCD,TCMT,SPR,AUTCODE,TSO,TPD,BRCD,AMT2,ATMM,PARTIAL,TRTYP)

	/*
	 Reverse pre-authorization

	 ARGUMENTS:
		PCID    - PROFILE account number
		CRCD	- Currency code
		TCMT	- Transaction comment
		SPR     - Spray value
		AUTCODE	- Authorization code
		TSO	- Transaction source information
		TPD	- Teller posting date
		BRCD	- Branch code
		AMT2	- Correction amount
		ATMM	- Unique message sequence
		PARTIAL	- Partial reversal transaction
		TRTYP	- Transaction type
	 INPUTS:
		BCAL	- Business calendar
		CUTOFF	- Hold cutoff time
		ETCDR	- Debit transaction code
		PHC	- Permanent hold code
		PHDAYS	- Permanent hold days
		STF	- Advice flag
	*/

	new EXCAMT,MAXRATE,MINRATE,MULTIPLY,RATE,TRESREF,VARIANCE

	type RecordACN acn
	type RecordTTX ttx()

	// Remove hold if original transaction was a pre-authorization
	do PREDEL(PCID,SPR,PHC,STF,TRTYP)
	if ER quit
 
	if 'PARTIAL quit

	// Convert amount to the account's currency (buy margins, non-cash, midrate)
	set acn=Db.getRecord("ACN","CID=:PCID")
	if acn.crcd'=CRCD do {
		do EXC^CRCDUTL(CRCD,acn.crcd,AMT2,1,1,"00",acn.ccode,"",1)
		if ER quit
		set TSO=$$FIELDIN^UTSO(TSO,"TCUR",AMT2_CRCD)
		set AMT2=$$^SCARND(EXCAMT,0,"",acn.crcd)
		set CRCD=acn.crcd
	}

	// Add new hold for new amount
	set TSO=$$FIELDIN^UTSO($G(TSO),"ATMM",ATMM)
	do ADDPHLD(PCID,AMT2,TCMT,SPR,AUTCODE,TSO,BCAL,PHC,PHDAYS,CUTOFF)

	quit


public TTX(RecordTTX ttx(),Number CID,String ETC,Number AMT,Date EFD,String TSO,String TCMT,Number SPR,String CRCD)
	/*
	 Create a transaction record

	 ARGUMENTS:
		CID	- Account number
		ETC	- PROFILE transaction code
		AMT	- Transaction amount
		EFD	- Effective date
		TSO	- Transaction source of funds
		TCMT	- Transaction comment
		SPR	- Spray value
		CRCD	- Transaction currency code
	*/

	type public Boolean ER
	type public String %MCP,RM
	type Number BSEAMT,EXCAMT,MAXRATE,MINRATE,MULTIPLY,RATE,seq,TRESREF,TRNTYP,VARIANCE
	type String BSECRCD,CCODE

	type RecordACN acn
	type RecordTRN trn

	// Retrieve transaction code information
	set trn=Db.getRecord("TRN","ETC",1)

	// Invalid transaction code
	if trn.getMode()=0 do Runtime.setErrMSG("TRN",1498,ETC) quit

	// Default currency exchange transaction values
	set (CCODE,MULTIPLY,RATE)=""
	set BSEAMT=AMT
	set BSECRCD=CRCD

	// Profile account transactions must be in the account currency
	if trn.cls'="M" do {
		// Retrieve account information
		set acn=Db.getRecord("ACN","CID",1)

		// Invalid account
		if acn.getMode()=0 do Runtime.setErrMSG("ACN",1259,CID) quit

		// Conversion not needed
		if acn.crcd=CRCD quit

		// Convert amount to account currency (margins, non-cash, mid-rate)
		set CCODE=acn.ccode
		set TRNTYP=$S($E(trn.itc):0,1:1)
		do EXC^CRCDUTL(CRCD,acn.crcd,AMT,1,TRNTYP,"00",CCODE,EFD,1)
		if ER quit
		set AMT=EXCAMT.roundDec(acn.crcd)
		set CRCD=acn.crcd

		// Add TCUR to TSO
		set TSO=$$FIELDIN^UTSO(TSO,"TCUR",BSEAMT_BSECRCD)
	}
	if ER quit

	set seq=1
	while ttx(seq).exists() set seq=seq+1

	set ttx(seq)=Class.new("RecordTTX")
	set ttx(seq).cid=CID
	set ttx(seq).itc=trn.itc
	set ttx(seq).etc=ETC
	set ttx(seq).tamt=AMT
	set ttx(seq).efd=EFD
	set ttx(seq).tlo=%UserStation
	set ttx(seq).tso=TSO
	set ttx(seq).tcmt=TCMT
	set ttx(seq).spr=SPR
	set ttx(seq).crcd=CRCD

	if %MCP do {
		set ttx(seq).crcd=CRCD
		set ttx(seq).bseamt=BSEAMT
		set ttx(seq).bcrcd=BSECRCD
		set ttx(seq).rate=RATE
		set ttx(seq).mult=MULTIPLY
		set ttx(seq).custcd=CCODE
		}
	quit


public STFCHK(Number CID,Number SPR,String TRACE,Boolean PRE,Boolean REV,Boolean FINPRE,String ATMM,Number PSTDYS)
	/*
	 Determine if a transaction has already been posted

	 ARGUMENTS:
		CID	- PROFILE account number
		SPR	- Spray value
		TRACE	- Trace value
		PRE	- Preauthorization flag
		REV	- Reversal flag
		FINPRE	- POS preauthorized debit flag
		ATMM	- Unique message sequence
		PSTDYS	- Number of days to search back in account history
	*/
	type Boolean RFLG
	type Number TCMT,TSEQ
	type String ITC,RECTYP,TRAN,XTLO

	type RecordATMDUP dup
	type RecordTTX ttxtmp=Class.new("RecordTTX")

	do FINDH(.ttxtmp,CID,SPR,PSTDYS,.TSEQ,,,.RECTYP)
	if RECTYP.isNull() quit 0

	//set ITC=TRAN.piece("|",2)
	set ITC=ttxtmp.itc
	//set TCMT=TRAN.piece("|",8)
	set TCMT=ttxtmp.tcmt

	/*
	 The next section code has a hard coded phrase referenced - 
	 TCMT["deleted".  Need to determine a way to avoid this since 
	 this phrase can be translated.

	 STBL("MSG",5665)=Permanent hold Sequence Number ~p1 deleted
	*/
	if RECTYP'="PHLD" set RFLG=$S(ITC.extract(6)=1:1,ITC.extract(12)=1:1,1:0)
	else  set RFLG=$S(TCMT["deleted":1,1:0)
	
	// Not a duplicate
	if FINPRE,RECTYP="PHLD" quit 0
	if REV,'RFLG quit 0
	if 'REV,RFLG quit 0

	// Transaction is a duplicate - store duplicate hit in ATMDUP
	set dup=Class.new("RecordATMDUP")
	set dup.tlo=%UserStation
	set dup.spr=SPR
	set XTLO=%UserStation
	set dup.seq=Db.nextVal("ATMDUP","XTLO,SPR")
	set dup.cid=CID
	set dup.trace=TRACE
	set dup.tseq=TSEQ
	set dup.atmseq=ATMM
	set dup.sdt=%SystemDate
	do dup.bypassSave()

	// Log a dayend exception error
	do LOG^UTLEXC("ISO8583","*","",CID,ATMM,$$^MSG(4976))

	quit 1


PROCSTF(RecordTTX ttx(),Number CID,Date TPD,String BRCD,String TSPV,String STF)
	/*
	 Process transactions in PROFILE's store and forward

	 ARGUMENTS:
		CID	- Profile account number
		TPD	- Teller posting date
		BRCD	- Branch code
		TSPV	- Teller supervisory array
		STF	- ATM switch store and forward flag
	*/
	type public Boolean ER
	type public String %IPMODE,%STFHOST
	type Number seq
	type String context,CRT,TR,vzrec,vzstfflg

	set ER=0
	set context="",vzstfflg=STF		// STF processing variables
	set vzrec=$$FMTTSSP^STFUTL(.ttx(),,BRCD,TPD)

	set %IPMODE="NOINT"			// Not interactive
	set CRT=$S(STF:2,1:1)			// 1 - online, 2 - SAF
	new X set X=CRT				// Bug in ^STFUTL
	do STFHNDL^STFUTL(.ttx(),%STFHOST,1)

	quit


FINDH(RecordTTX ttxtmp,Number CID,Number SPR,Number PSTDYS,Number TSEQ,Number STFSEQ,Number TRSEQ,String RECTYP)
	/*
	 Find history entry matching SPR and TLO

	 ARGUMENTS:
		CID	- PROFILE account number
		SPR	- Spray value
		PSTDYS	- Number of days to search into an account's history
	 OUTPUTS:
		HIST, TTXFDT or STFHOST record
		TSEQ	- History transaction sequence number
		STFSEQ	- Host STF sequence number
		TRSEQ	- TTXFDT or STF TR sequence
		RECTYPE - Record Type
	*/
	type public Boolean ER
	type public Number BRCD
	type public String %STFHOST
	type Date DATE
	type String TSO,TRAN,XTLO

	type ResultSet rs1
	type RecordHIST hist

	set (RECTYP,STFSEQ,TRAN,TRSEQ,TSEQ)=""
	set XTLO=%UserStation
	if +CID=0 quit
	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	if 'acn.getMode() quit

	// Check in STFHOST for stored transaction
	if %STFHOST do {
		// Search primary transactions (ITC7=0)
		set rs1=Db.select("STFSEQ,TRSEQ,CID,ITC,ETC,TAMT,STFEFD,TLO,TSO,TCMT,SPR","STFHOST","CID=:CID AND TLO=:XTLO AND SPR=:SPR AND ITC7=0","STFSEQ DESC")
		if rs1.isEmpty()!('rs1.next()) quit
		set STFSEQ=rs1.getCol("STFSEQ")
		set TRSEQ=rs1.getCol("TRSEQ")
		set ttxtmp.cid=rs1.getCol("CID")
		set ttxtmp.itc=rs1.getCol("ITC")
		set ttxtmp.etc=rs1.getCol("ETC")
		set ttxtmp.tamt=rs1.getCol("TAMT")
		set ttxtmp.efd=rs1.getCol("STFEFD")
		set ttxtmp.tlo=rs1.getCol("TLO")
		set ttxtmp.tso=rs1.getCol("TSO")
		set ttxtmp.tcmt=rs1.getCol("TCMT")
		set ttxtmp.spr=rs1.getCol("SPR")

		set RECTYP="STFHOST"
		}
	if RECTYP="STFHOST" quit

	// Check in HIST for primary transactions (ITC7=0)
	set DATE=%SystemDate-PSTDYS
	type DbSet ds=Db.selectDbSet("HIST","CID=:CID AND TJD NOT <:DATE AND TLO=:XTLO AND SPR=:SPR AND ITC7=0","TSEQ DESC")

	if 'ds.isEmpty(),ds.next() do {
		set hist=ds.getRecord()
		set ttxtmp=hist.copy()
		if '(hist.etc).isNull() set RECTYP="HIST" quit
		set TSO=hist.tso

		set RECTYP="PHLD"
	}

	quit


public JD(Date DATE)
	/*
	 Return date in julian format  (input = MMDD)

	 ARGUMENT:
		DATE	- Message date (MMDD)
	 OUTPUT:
		Julian date

	 JD determines the correct year when the system date (%SystemDate) is
	 December (12) and a posting date of January (1) is sent.  In
	 addition, JD determines the correct year when the system is
	 January (1) and the posting date is still back in December (12)

	 Ex:	System		Posting		Date
		Date		Value		Calculated
		------		-------		----------
		12/31/1999	'0101'		01/01/2000
		01/01/2000	'1231'		12/31/1999
	*/

	type Number MON,MSGMON,YEAR

	set DATE=DATE.extract(1,4)
	if DATE="" quit ""

	set MON=$$MON^SCADAT(%SystemDate,1)
	set YEAR=$$YEAR^SCADAT(%SystemDate,1)
	set MSGMON=+DATE.extract(1,2)
	if (MON=12),(MSGMON=1) set YEAR=YEAR+1
	if (MON=1),(MSGMON=12) set YEAR=YEAR-1

	quit $$^SCAJD(DATE_YEAR,"MMDDYEAR")


public GETTRN(String INTRFACE,String CODE,String STF)
	/*
	 Determine PROFILE transaction codes

	 Determine PROFILE transaction codes using the processing code from the
	 message and the external interface table. If no entry in the external
	 interface table for CODE is found and the message is an STF message,
	 then the "SUSP" record is used if defined. The "SUSP" entry should
	 have two miscellaneous transaction codes so that an error occurs when
	 the transaction is posted since the account group does not match,
	 although, it is possible that an account could have the same number
	 as a GL account.

	 ARGUMENTS:
		INTRFACE	- Online ATM interface
		CODE		- Process code
		STF		- ATM network store and forward flag
	 RETURNS:
		TRCD		- PROFILE transaction codes
	*/
	type public Boolean ER
	type public Number RSPCD
	type public String RM
	type String TRCD

	set TRCD=""
	type RecordUTBLEXTTRN1 uexttrn1=Db.getRecord("UTBLEXTTRN1","INTRFACE,CODE",1)

	if '(uexttrn1.trtype).isNull() set TRCD.piece($C(9),1)=uexttrn1.trtype
	if '(uexttrn1.dretc).isNull() set TRCD.piece($C(9),2)=uexttrn1.dretc
	if '(uexttrn1.cretc).isNull() set TRCD.piece($C(9),3)=uexttrn1.cretc

	if 'TRCD.isNull() quit TRCD

	// Invalid process ID
	if 'STF set RSPCD=1427 do Runtime.setErrMSG("UTBLEXTTRN1",1427) quit ""

	set CODE="SUSP"

	type RecordUTBLEXTTRN1 uexttrn2=Db.getRecord("UTBLEXTTRN1","INTRFACE,CODE",1)

	if '(uexttrn2.trtype).isNull() set TRCD.piece($C(9),1)=uexttrn2.trtype
	if '(uexttrn2.dretc).isNull() set TRCD.piece($C(9),2)=uexttrn2.dretc
	if '(uexttrn2.cretc).isNull() set TRCD.piece($C(9),3)=uexttrn2.cretc

	// Invalid process ID
	if TRCD.isNull() set RSPCD=1427 do Runtime.setErrMSG("UTBLEXTTRN1",1427) quit ""

	quit TRCD


public TLRPDT(Number BCAL,String BRCD,Date EFD)
	/*
	 Determine and validate TPD (teller posting date)

	 If an error occurs, try to roll the date forward to the next 
	 business date if the error is one of the following:
	  1123 - Forward balancing date already assigned
	  1275 - Invalid business date
	  2208 - Posting file closed for
	  2573 - System has already balanced on
	  2618 - Teller posting file is closed for

	 ARGUMENTS:
		BCAL	- Business day calendar
		BRCD	- Branch code
		EFD  	- Effective Date      /REF:W
	   OUTPUTS:
		$$	- Teller Processing Date
	*/

	type public Boolean ER
	type public String %MSGID,%UID,RM
	type String ID,TPD,X

	type RecordSIGNON signon=Db.getRecord("SIGNON","%UID",1)

	set TPD=signon.tpd

	set ER=0
	set RM=""
	if TPD="" set TPD=$$NBD^UNBD(%SystemDate,1,0,BCAL)
	set X=TPD do TPD^SIGNON		// X,%UID,TJD,BRCD,TPD are needed
	if ER do {
		set ID=%MSGID.get().piece("|",1)
		if ",1123,1275,2208,2573,2618,"'[(","_ID_",") quit

		set ER=0
		set RM=""
		set TPD=$$NBD^UNBD(TPD+1,1,0,BCAL)
		set X=TPD do TPD^SIGNON
		}
	set EFD = ""
	quit TPD


public NXTSEQ()
	/*
	 Unique message sequence

	 OUTPUT:
		Unique message sequence
	*/

	/*
	type RecordNXTSEQ nxt=Db.getRecord("NXTSEQ","JOB",1)
	set VAL=nxt.unq+1
	set nxt.id=JOB
	set nxt.unq=VAL
	do nxt.bypassSave()
	*/
	type String TIME,VAL
	set JOB=%ProcessID

	set VAL=$$ATMSEQ(5)

	set TIME=%CurrentTime
	quit %CurrentDate_("00000".extract(1,5-TIME.length()))_TIME_("000000".extract(1,6-JOB.length()))_JOB_("00000".extract(1,5-VAL.length()))_VAL_"A"

ATMSEQ(LEN)
	/*
	 Get next sequence for Process ID

	 Get and update next unique sequence number for the Process ID. LEN must 
	 be less than or equal to 18. 18 is the maximum length of NXT.
	*/

	type Number NXT,VAL

	type RecordNXTSEQJ nxt

	if LEN.get()'>0 set LEN=""

	set nxt=Db.getRecord("NXTSEQJ","JOB=:%ProcessID",1)

	// Retrieve next sequence, check for first entry value of zero
	set VAL=nxt.unq
	if 'VAL set VAL=1
	set NXT=VAL+1
	if NXT.length()>18 set NXT=1

	// An ID could be used for more than one length (e.g., 6000000 with length of 6 is 0)
	if LEN set VAL=+VAL.extract(VAL.length()-LEN+1,18) if 'VAL set VAL=1,NXT=NXT+1

	set nxt.job=%ProcessID
	set nxt.unq=NXT
	do nxt.bypassSave()

	quit VAL

public ADDPHLD(Number CID,Number AMT,Number TCMT,Number SPR,String AUTCODE,String TSO,Number BCAL,String PHC,Number PHDAYS,String CUTOFF)

	/*
	 Insert entry into PHLD.
	 
	 The expiration date is set to one day after
	 the next BCAL business date. Today's date is considered the next
	 business date.
	 ARGUMENTS:
		CID	- PROFILE account number
		AMT	- Hold amount
		TCMT	- Teller comment
		SPR	- Spray value
		AUTCODE	- Authorization code
		TSO	- Transaction source of funds
		BCAL	- Business day calendar
		PHC	- Permanent hold code
		PHDAYS	- Permanent hold days
		CUTOFF	- Hold Cutoff Time
	 RETURNS:
		RSPCD	- Response code
	*/

	type public String %STFHOST
	type Date DATE

	set DATE=%SystemDate
	if 'CUTOFF.isNull(),(%CurrentTime'<CUTOFF)!(%SystemDate<%CurrentDate) set DATE=DATE+1

	type RecordPHLD phld

	set phld=Class.new("RecordPHLD")
	set phld.cid=CID
	set phld.seq=Db.nextVal("PHLD","CID")
	set phld.stdt=%SystemDate
	set phld.expdt=$$NBD^UNBD(DATE,PHDAYS,0,BCAL)+1
	set phld.amt=AMT
	set phld.phc=PHC
	set phld.tcmt=TCMT
	set phld.spr=SPR
	set phld.tlo=%UserStation
	set phld.autcode=AUTCODE
	set phld.stfhost=$S(%STFHOST:1,1:0)
	set phld.tso=TSO
	do phld.save("/NOVALDD")

	quit


public CKTRN(RecordTTX ttx(),String TSO,Number RT)
	/*
	 Update the CK transaction in the transaction set.
	 ARGUMENTS:
		TSO	- Transaction source of funds
		RT	- Routing and transit number
	*/

	type String CHKTYP,CKTSO,UTSO

	if RT.isNull() quit

	set CHKTYP=3
	do OUT^UTSO(.UTSO,TSO)			// Parse TSO field
	set UTSO("CHKTYP")=CHKTYP		// Hold based on RT number
	set UTSO("RT")=RT			// Routing and transit number
	do IN^UTSO(.UTSO,.CKTSO)		// Add check hold information

	// Add check information to the CK transaction
	set ttx(1).tso=CKTSO
	set ttx(1).chktyp=CHKTYP
	
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60870^23456^Brandon Rickards^31691"	// Signature - LTD^TIME^USER^SIZE
