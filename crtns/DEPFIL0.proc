DEPFIL0 // DEP DATA-QWIK filer, part (2)
 // Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 11:23 - shetyes

	quit		// Not called from top


VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	do vau2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do vau23 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do vau37 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() quit
	if vx("ACN").exists() do vau3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ACNRELC").exists() do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AIACRF").exists()!vx("IAF").exists()!vx("INTAVLR").exists() do vau4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AIINDEX").exists()!vx("AIINTFRE").exists()!vx("AIICHLD").exists()!vx("AIICHND").exists()!vx("AIRDET").exists() do vau5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AIIOPT").exists()!vx("AIINTTRF").exists()!vx("AIEXTSEQ").exists()!vx("AIEXTACN").exists() do vau6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AIIPF").exists()!vx("AIIPLD").exists()!vx("AIINP").exists() do vau7 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AIIRN").exists() do vau8 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANLCID").exists() do vau9 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANLTYP").exists() do vau10 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AWT").exists()!vx("AWTI").exists()!vx("AWTP").exists()!vx("AWTR").exists()!vx("BWF").exists() do vau15 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BGTOFFST").exists() do vau11 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BGTPRO").exists() do vau12 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BOO").exists() do vau13 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CC").exists() do vau16 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CCODE").exists() do vau17 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("COLELG").exists() do vau18 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CONVACN").exists() do vau19 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CTFGRP").exists() do vau20 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CURRAMT").exists() do vau21 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DARCOVR").exists() do vau22 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ELIGBPAY").exists()!vx("ACTIBPAY").exists() do vau14 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("EXTACN").exists()!vx("EXTSEQ").exists()!vx("INTDISETC").exists()!vx("INTMATETC").exists()!vx("PRIMATETC").exists() do vau24 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("FEEPLN").exists() do vau25 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("FLTP1").exists()!vx("FLTP2").exists()!vx("FLTP3").exists()!vx("FLTP4").exists()!vx("FLTP5").exists()!vx("FLTD1").exists()!vx("FLTD2").exists()!vx("FLTD3").exists()!vx("FLTD4").exists()!vx("FLTD5").exists()!vx("FLTTBL").exists() do vau26 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GCRS").exists()!vx("GCRCD").exists()!vx("MSCRTBL").exists()!vx("DSCRTBL").exists()!vx("SCRFREQ").exists()!vx("NSDATE").exists() do vau27 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GCRTFCID").exists() do vau28 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GLSC").exists() do vau29 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GRP").exists() do vau30 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("HLDP1").exists()!vx("HLDP2").exists()!vx("HLDP3").exists()!vx("HLDP4").exists()!vx("HLDP5").exists()!vx("HLDD1").exists()!vx("HLDD2").exists()!vx("HLDD3").exists()!vx("HLDD4").exists()!vx("HLDD5").exists()!vx("HLDTBL").exists() do vau31 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ICHND").exists()!vx("INTFRE").exists() do vau32 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("INC").exists()!vx("ICF").exists() do vau33 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("INCDR").exists() do vau34 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("INDEX").exists()!vx("ODLIM").exists()!vx("ODTERM").exists()!vx("INTMAT").exists()!vx("INTSPR").exists()!vx("RNDMTD").exists()!vx("INTRAMT1").exists()!vx("INTRAMT2").exists()!vx("INTRAMT3").exists()!vx("INTRRAT1").exists()!vx("INTRRAT2").exists()!vx("INTRRAT3").exists()!vx("INTREXP1").exists()!vx("INTREXP2").exists()!vx("INTREXP3").exists()!vx("INTSPRP").exists()!vx("INTSPRA").exists()!vx("INTSPRU").exists() do vau35 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("INP").exists()!vx("INTCHKFRE").exists()!vx("INTCHKND").exists()!vx("IPF").exists()!vx("LBCP").exists()!vx("LBCM").exists() do vau36 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("INTWCALC").exists() do vau38 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IOPT").exists()!vx("ITRF").exists()!vx("NEGITRF").exists() do vau39 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IRA").exists()!vx("RPASEQ").exists() do vau40 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IRCB").exists() do vau41 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IRN").exists() do vau42 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("LNM").exists() do vau43 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MDT").exists()!vx("TRM").exists() do vau44 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MINDR").exists() do vau45 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT900").exists()!vx("MT900THR").exists() do vau46 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT910").exists()!vx("MT910THR").exists() do vau47 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NEGACRPO").exists() do vau48 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NEGBALOP").exists() do vau49 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NEGINP").exists()!vx("NEGIPF").exists()!vx("NEGIPO").exists() do vau50 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NIAO").exists()!vx("UFINDEX").exists() do vau51 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NOTICE").exists()!vx("NOTMIN").exists()!vx("NOTMAX").exists() do vau52 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NR").exists() do vau53 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ODO").exists()!vx("LPSWP").exists() do vau67 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PERS").exists() do vau54 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PLDG").exists() do vau55 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("POPT").exists()!vx("SEGPOPT").exists()!vx("WDPRIO").exists() do vau56 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RENCD").exists()!vx("RACN").exists()!vx("PRENA").exists()!vx("IMO").exists()!vx("RRO").exists()!vx("INTMATITA").exists() do vau57 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("RSINTSPR").exists()!vx("RSRNDMTD").exists() do vau58 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SCFRE").exists() do vau59 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SCND").exists() do vau60 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SEGPER").exists() do vau61 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SFRE").exists() do vau62 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SGNCRD").exists()!vx("OSGNCRDC").exists()!vx("PSGNCRDR").exists() do vau63 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SMET").exists() do vau64 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STAT").exists() do vau65 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SVCFEECID").exists() do vau66 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SWPF").exists() do vau68 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SWPT").exists()!vx("SWPTR").exists()!vx("SWPI").exists()!vx("SWRI").exists()!vx("SWPROPT").exists() do vau69 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TITLE1").exists()!vx("TITLE2").exists()!vx("TITLE3").exists()!vx("TITLE4").exists() do vau70 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TYPE").exists() do vau71 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("UPFRE").exists() do vau72 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("UPNDT").exists() do vau73 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("USPL").exists() do vau74 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("WRKDTE").exists() do vau75 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBD //
	type public Number ER = 0
	type public String vx(),RM
	do vbd1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordDEP dep
	do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() do AUDIT^UCUTILN(dep,.vx(),10,"|") quit
	if vx("ACS").exists() do vbu2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AIIPF").exists()!vx("AIINP").exists()!vx("AIIPLD").exists() do vbu3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AIIRN").exists()!vx("AIRDET").exists()!vx("AIINTFRE").exists()!vx("AIICHND").exists()!vx("AIICHLD").exists()!vx("AIINDEX").exists()!vx("AIINTMAT").exists()!vx("AIINTSPR").exists()!vx("AIRNDMTD").exists() do vbu4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANLLSD").exists() do vbu5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANLSNL").exists() do vbu6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ANLSYS").exists()!vx("ANLTYP").exists() do vbu7 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AWTI").exists()!vx("IRN").exists()!vx("INTFRE").exists()!vx("ICHND").exists()!vx("ICHLD").exists()!vx("INDEX").exists()!vx("INTMAT").exists()!vx("INTSPR").exists()!vx("RNDMTD").exists() do vbu29 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("AWTP").exists()!vx("BWF").exists() do vbu11 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BGTCONTR").exists()!vx("BGTYRSD").exists() do vbu8 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BGTPRO").exists() do vbu9 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("BGTYRND").exists()!vx("BGTOFFST").exists() do vbu10 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CLS").exists() do vbu14 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("COLLST").exists()!vx("PCOLLST").exists()!vx("COLCDTE").exists() do vbu15 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CUMDEP").exists()!vx("NSCDEPDD").exists()!vx("NSCHDEPS").exists()!vx("SCHDEPA").exists()!vx("SCHDEPF").exists()!vx("SCHDEPLD").exists()!vx("SCHDEPN").exists()!vx("SCHDEPND").exists()!vx("SCHPROC").exists()!vx("TOTNOSDP").exists() do vbu44 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DARCOVR").exists() do vbu16 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("DEFINADJ").exists() do vbu17 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("EMPLBEN").exists()!vx("EMPLNO").exists() do vbu18 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GCRCV").exists() do vbu20 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GCRDOD").exists() do vbu21 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GCRLMNT").exists() do vbu22 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GCRPMNT").exists() do vbu23 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GCRS").exists()!vx("GCRCD").exists() do vbu19 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("GCRTFCID").exists() do vbu24 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("INTCHKFRE").exists()!vx("INTCHKND").exists()!vx("INTCHKLD").exists() do vbu25 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IOPT").exists()!vx("ITRF").exists() do vbu26 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IPF").exists()!vx("INP").exists()!vx("IPLD").exists()!vx("INTAF").exists() do vbu27 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("IRA").exists()!vx("DLKFLG").exists() do vbu28 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("LSP").exists()!vx("LAFM").exists()!vx("OBORIRP").exists()!vx("IEP").exists()!vx("LAFTFR").exists() do vbu30 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MMDA4").exists()!vx("MMDA3").exists()!vx("REGD").exists() do vbu32 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT320").exists() do vbu33 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT900").exists() do vbu34 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT910").exists() do vbu35 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT940").exists() do vbu36 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT942G1").exists()!vx("MT942G2").exists()!vx("MT942").exists() do vbu37 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MT950").exists() do vbu38 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("NEGIPF").exists()!vx("NEGINP").exists()!vx("NEGIPLD").exists() do vbu39 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ODT").exists() do vbu40 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("ODTERM").exists() do vbu41 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PBI").exists() do vbu42 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PBKSEQ").exists() do vbu13 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PROVOAMT").exists()!vx("PROVOPCT").exists()!vx("RACOVR").exists() do vbu43 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SCLD").exists()!vx("ANLOFFDY").exists() do vbu45 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SEGACR").exists() do vbu46 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SEGFLG").exists() do vbu47 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SGNCRD").exists()!vx("PSGNCRDR").exists()!vx("OSGNCRDC").exists() do vbu48 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STAT").exists() do vbu49 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TITLE1").exists()!vx("TITLE2").exists()!vx("TITLE3").exists() do vbu12 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TREXD").exists()!vx("TRATE").exists() do vbu50 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TRM").exists()!vx("MDT").exists() do vbu31 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("TYPE").exists() do vbu51 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("USRESTAT").exists() do vbu52 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(dep,.vx(),10,"|")
	quit


vau1 // Trigger ACNRELC - After Update Account Relationship Code

	type public RecordDEP dep
	/*
	   Revision History

	   10/12/99 - CHOK - 31126
		      Converted to PSL.
	*/

	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 
		/*
		   This is a transaction (core) account set up for percentage based
		   investment sweep - make identical change on corresponding non-
		   institutional investment accounts.
		*/
		new ACNRELC,ICID,ITYPE,SWPNI
	
		set ACNRELC=dep.acnrelc
		new rs
		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:CID")
		if rs.isEmpty() quit				// No linked investment accounts
		while rs.next() do { quit:ER  
			set ICID=rs.getCol(1)			// Investment Account Number
			set ITYPE=rs.getCol(2)			// Investment Product Type
			set SWPNI=Db.getOneRow("SWPNI","PRODDFTD","ITYPE")
			if SWPNI do Db.update("DEP","ACNRELC=:ACNRELC","CID=:ICID")
			}
		}
	quit

vai1 // Trigger AFTER_INSERT - Deposit After Insert Trigger

	type public RecordDEP dep

	/*
	---- Revision History---------------------------------------------------
	
	09/18/01 - MYERSK 47550
		   Removed AU_SGNCRD trigger since XSGNCRD is now an Index.
		   Needed to put Revision History somewhere.
	
 	06/26/00 - Terrie Dougherty - 40629
		   Moved all code and revision history comments from this
		   trigger into a new procedure, DEPAI, to prevent compilation
		   errors caused by the DEP filer being too large. Changes to
		   the AFTER_INSERT trigger should now be made to the DEPAI
		   procedure.
	*/ 

	do PROC^DEPAI(.dep)
	quit

vau2 // Trigger AU - After Update trigger for all columns

	type public RecordDEP dep

	/*
								---- Revision History ------------------------------------------------
	
								05/15/01 - VETSENM - 43026
																			Set error message for Non-PROFILE account if Conversion
																			Account (DEP.CONVACN) is not defined.

																			Set XBAD message if user attempts to perform file
																			maintenance on a Non-PROFILE account (PRODCTL.NONPA=1)
	
	07/29/01 - VETSENM - 46279
		   Code for DEP.CONVACN has been removed to AU_CONVACN.

	*/


	new NONPA,TYPE
	
								set TYPE=dep.type
								set NONPA=Db.getOneRow("NONPA","PRODCTL","TYPE")

								// File Maintenance Require Approval
								if NONPA=1 do Runtime.setErrXBAD("DEP",3005) quit:ER

								quit

vau3 // Trigger AU_ACN - After Update Customer Number

	type public RecordDEP dep
	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 
		/*
		   This is a transaction (core) account set up for percentage based
		   investment sweep - make identical change on corresponding non-
		   institutional investment accounts.
		*/
		new ACN,ICID,IDATA,ITYPE,LINKCNT,SWPNI
	
		set ACN=dep.acn
		new rs 
		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:CID")
		if rs.isEmpty() quit				// No linked investment accounts	
		while rs.next() do { quit:ER  
			set ICID=rs.getCol(1)			// Investment Account Number
			set ITYPE=rs.getCol(2)			// Investment Product Type
			set SWPNI=Db.getOneRow("SWPNI","PRODDFTD","ITYPE")
			if SWPNI do Db.update("DEP","ACN=:ACN","CID=:ICID")
			}
		}
	
	quit:'Db.getOneRow("LIMPRO","CUVAR")
	do START^LIMUPD(dep.cid,"DEPOSIT",dep.acn,dep.acn.oldVal)
	
	quit

vau4 // Trigger AU_AIACRF - After Update Avail Int Accrual Flag

	type public RecordDEP dep
	// trigger AU_AIACRF

	/*
	   ---- Revision History ------------------------------------------------

	   10/13/99 - CHOK - 31126
		      Converted to PSL.
	
	   05/26/99 - SWEENEYT - 32933
	              Added check for invalid combination IAF=2 and IOTP=2.	
	*/

	do TRIGCHK^AIACRF(CID,.dep)
	
	// IOPT - Interest Disbursement Option Verification.
	
	// Invalid field values ([DEP]IAF and [DEP]IOPT).
	if dep.iopt>0,dep.iaf=2 do Runtime.setErrMSG("DEP",8619) quit:ER 
	

	
								//Checking the Interest Available Option(IAF) with Reset Interest
								//Available on Renewal Flag(INTAVLR)
	
	
   	if dep.intavlr=3,dep.iaf'=2 do Runtime.setErrXBAD("DEP","INTAVLR") quit:ER
	if ((dep.intavlr=1)!(dep.intavlr=2)),dep.iaf'=1 do Runtime.setErrXBAD("DEP","INTAVLR")
	
	
								// Error if Renewal Code(RENCD) is not equal to 3 when Reset Interest
								//Available on Renewal Flag(INTAVLR) is other than Zero.
								if dep.intavlr,dep.rencd'=3 do Runtime.setErrMSG("DEP",4299) quit:ER
	
								//
	
								quit
	
	//
	
	quit

vau5 // Trigger AU_AIINDEX - After Update Available Interest Index

	type public RecordDEP dep
	// trigger AU_AIINDEX
	
	/*
	   ---- Revision History ----------------------------------------------
		
	   06/11/02 - VERTLIBA - 50561
		      Removed restriction for AIICHND (ARQ32998) which was
		      creating an integrity error when running the function
		      @UOPEN for the segmented accounts at the segment level.
	
	   10/27/00 - SMITHC - 42068:1
		      Moved "Do not use Values Relating to Change in Available 
		      Interest if DEP.AIRDET=0" error check from BU_AIINDEX.
	
	   10/14/99 - CHOK - 31126
		      Converted to PSL.
	
	   09/02/99 - MAGERAM - 32998
		      Added restriction "~p1 must be null when accruing at segment
	              level" for AIICHND.
	
	   4/19/99 -  DADAP - 32555
		      Made changes to check for AIINDEX or AIIRN for AIRDET=1.
	*/
	
	do TRIGCHK^AIACRF(CID,.dep) quit:ER 
	
	/*
	   If dep.airdet is zero (use principal interest rate), then we
	   shouldn't have values for information relating to available
	   interest changes, because the interest on available interest should
	   never change.

	   Do not use Values Relating to Change in Available Interest if 
	   DEP.AIRDET=0
	*/
	if ('dep.airdet)&((dep.aiichld'="")!(dep.aiichnd'="")!(dep.aiintfre'="")) do Runtime.setErrMSG("DEP",3987) if ER quit

	// Avail Int - Int Change Freq is required with Avail Int Index
	if dep.aiindex'="",dep.aiintfre="" do Runtime.setErrXBAD("DEP",186) quit:ER 

	// Avail Int - Int Rate required if Avail Int Rate Deter is 1
	if dep.airdet=1,dep.aiirn="",dep.aiindex="" do Runtime.setErrXBAD("DEP",235) quit:ER 

	// Avail Int Next Change Date cannot be earlier than sys date
	if dep.aiichnd,dep.aiichnd<%SystemDate do Runtime.setErrXBAD("DEP",191) quit:ER 

	quit 

vau6 // Trigger AU_AIIOPT - After Update of Available Interest

	type public RecordDEP dep
	// trigger AU_AIIOPT

	/*
	   ---- Revision History ------------------------------------------------
	   
	   09/26/05 - RADHIKA - 16891 
																						Eliminated PSL deprecated features and Warnings.
																						Removed revision history prior to 2004.
	*/
	
	type public Boolean ER
	type public Number CID
	
	do TRIGCHK^AIACRF(CID,.dep) quit:ER 
	
	if (dep.aiiopt=4) do { quit:ER 
		// Avail Int Ext Acct Seq required if Avail Int Disbmt Opt is 4
		if (dep.aiextseq="") do Runtime.setErrXBAD("DEP",188) quit:ER 

		// Avail Int Ext Tfr Cust ID required if Avail Int Disbmt Opt is 4
		if (dep.aiextacn="") do Runtime.setErrXBAD("DEP",189) quit:ER 
		}
	
	if (dep.aiiopt=2) do { quit:ER 
		// Avail Int Disbmt Opt 2 requires valid Avail Int Internal Tft
																if dep.aiinttrf.isNull()!'Db.isDefined("DEP","CID=:dep.aiinttrf") do Runtime.setErrXBAD("DEP",190) quit:ER
		}
	quit 

vau7 // Trigger AU_AIIPF - Available Interest Posting

	type public RecordDEP dep
	/*
	   ---- Revision History ------------------------------------------------
	   
	   09/26/05 - RADHIKA - 16891 
																						Eliminated PSL deprecated features and Warnings.
																					 
	   12/12/00 - SCHWARTZC - 43194
		      Roll Forward of the following change.
 		      07/12/00 - REEDD - 40953
             	       Added check to AIACRF.  This will avoid unecessary checks
		       and invalid overrides from being returned. Also removed 
		       extra check to AIINP.

	   10/14/99 - CHOK - 31126
		      Converted to PSL.

	   09/02/99 - MAGERAM - 32998
		      Added restriction "~p1 must be null when accruing at segment
	              level" for AIINP.
	
	   07/14/99 - SMITHC - 33309
		      Modified 6/10/99 change to set up DAYEND entries only if
		      not in verify mode.
	
	   06/10/99 - SMITHC - 32048
		      Maintain DAYEND entry of next interest posting dates
		      (int on available int) manually.  This coding replaces
		      the traditional filer index definitions for next interest
		      posting dates.	
	*/
	
	type public Number CID
	type public Boolean ER 
		
	do TRIGCHK^AIACRF(CID,.dep) quit:ER 
	
	// If the accrual flag has been turned off then the above check will verify
	// that all fields that must be NULL are indeed NULL and no further checks
	// are needed.
	if 'dep.aiacrf quit	//cds 12/12/00

	// ~p1 must be null when accruing at segment level
	if dep.segflg,'dep.segacr do { quit:ER 
		if dep.aiinp do Runtime.setErrXBAD("DEP",532,"DEP.AIINP") quit:ER 
		}
	// Avail Int Next Posting Date cannot be earlier than sys date
	if dep.aiinp<%SystemDate do Runtime.setErrXBAD("DEP",192) quit:ER 
	
	/*
	   Maintain DAYEND entry for next interest posting date manually
	   This coding replaces the traditional filer index definitions for
	   next interest posting dates.
	*/
	if '(%ProcessMode=2),dep.aiinp'=dep.aiinp.oldVal,dep.segflg,dep.segacr do { quit:ER 
		new TJD
		set TJD=dep.aiinp
	
		// Segmented interest on principal, accruing/posting at
		// account level
		new X
		set X=dep.aiinp.oldVal
		if dep.aiinp.oldVal'="" do Db.delete("DAYENDSEGIP","CID=:CID AND TJD=:X AND POSTING=3 AND SEG=-1")
		if dep.aiinp'="" do {
			type RecordDAYENDSEGIP dayend=Class.new("RecordDAYENDSEGIP")
			set dayend.tjd=TJD
			set dayend.cid=CID
			set dayend.posting=3
			set dayend.seg=-1
			do dayend.save()
			}
		}
	quit

vau8 // Trigger AU_AIIRN - After Update Available Interest Rate

	type public RecordDEP dep
	/*
	   --- Revision History -----------------------------------------------
											10/10/05 - RADHIKA - 16891        
																						.Removed revision history prior to 2004.
																						.Removed unused variables %A,A,DEP.
	   
	*/
	
	if dep.aiirn'="" do { quit:ER

		// Segments in Use Flag must be on
		if 'dep.segflg do Runtime.setErrMSG("DEP",7893) if ER quit 
	
		// Available Interest Option must be 2
		if dep.iaf'=2 do Runtime.setErrMSG("DEP",7891) if ER quit 
	
		// Available Interest Accrual Flag must be on
		if 'dep.airdet do Runtime.setErrMSG("DEP",7892) if ER quit 
		}

	if $G(%EffectiveDate),%EffectiveDate<%SystemDate do { quit:ER
	
		// Cannot effective-date prior to opening date
		if dep.odt>%EffectiveDate do Runtime.setErrMSG("DEP",450) if ER quit 
	
		// Cannot effective-date prior to date last renewed
		if dep.dlr>%EffectiveDate do Runtime.setErrMSG("DEP",449) if ER quit 
	
		if %EffectiveDate'>dep.hisctf do { quit:ER 
			type Date x 
			set x = dep.hisctf.toString()		
			// Must be after the history purge date of ~p1
			do Runtime.setErrMSG("DEP",1801,x) if ER quit
			}

		do EFDIRN^DEPIRN(dep.cid,.dep,1,dep.irn.oldVal)

		/*
		   Allow an accrual adjustment error to occur.  The messages 
		   displayed will tell the user about the problem. A manual 
		   adjustment will be required.
		*/
		if ER,$D(RM)>1 set ER="W" set RM=$G(RM(1))_" "_$G(RM(2))
		}
	quit

vau9 // Trigger AU_ANLCID - After Update of Analysis CID

	type public RecordDEP dep
	/*
	---- Revision History ------------------------------------------------
	08/26/05 - RussellDS - CR16911
 	    Eliminate PSL deprecated features
 	    
 	    Remove old revision history.
	----------------------------------------------------------------------
	
	If this is a sub account for combined account analysis, make sure
	that the lead CID is valid, and that it is a lead account.
	*/
	
	if (dep.anltyp=2)!(dep.anltyp=3) do { quit:ER
	new leadcid,tmp
	set leadcid=dep.anlcid

	//Valid lead account must be defined for earnings analysis
	set tmp=Db.isDefined("DEP","leadcid")
								if 'tmp do Runtime.setErrXBAD("DEP","ANLVAL") quit:ER

	type RecordDEP lead = Db.getRecord("DEP", "CID=:leadcid", 1)

   	if (lead.anltyp '= 1) do Runtime.setErrXBAD("DEP","ANLVAL") quit:ER
	}
	quit

vau10 // Trigger AU_ANLTYP - After Update Anltyp

	type public RecordDEP dep
	/* If the value of analysis type changes from a 1 to any other value, the
				filer will check the XREF file ANLLINK to make sure that there aren't any
				linked accounts before allowing the change.
	*/
	
	/*
	---- Revision History ------------------------------------------------
	08/26/05 - RussellDS - CR16911
 	    Eliminate PSL deprecated features
	----------------------------------------------------------------------
	*/
	
	if (dep.anltyp.oldVal=1) do { quit:ER
								set XCID=CID
								type ResultSet rs=Db.select("ANLTYP","DEP","ANLCID=:XCID")
								if rs.isEmpty() quit
								do Runtime.setErrXBAD("DEP","ANLXLK") quit:ER
	}
	
	//Valid lead account must be defined for earnings analysis

	if (dep.anltyp=2)!(dep.anltyp=3) do { quit:ER
								if 'dep.anlcid do Runtime.setErrXBAD("DEP","ANLVAL") quit:ER
	}

	//If analysis is 1, check if there are sub accounts.
	
	if dep.anltyp=1 do { quit:ER
								set ANLCID=dep.cid,NEWSCND=dep.scnd
								set XCID=dep.cid
								type ResultSet rs=Db.select("SCND,CID","DEP","ANLCID=:XCID")
								while rs.next() do {
																set data=rs.getRow()
																set SUBSCND=$P(data,$C(9),1)
																set SUBCID=$P(data,$C(9),2)
	
																		//If SCND of sub account is not same as lead, change sub acct.
	
  		if SUBSCND'=NEWSCND do {
  		
  			type RecordDEP subdep = Db.getRecord("DEP", "CID=:SUBCID")
  			
  			set subdep.scnd = NEWSCND
  			
  			do subdep.save()
        	}
	}
	}
	
								//if changing SCND on sub account (Acct. analysis) check that sub's
								//SCND = the lead account.  If the change is coming from Service Fee
								//processing, quit out of this check.
	
	if (dep.anltyp=2)!(dep.anltyp=3) do { quit:ER
								if dep.isChanged("SCND","SYSTEM") quit // SyStem changes allowed
								new LEADCID,NEWSCND
								set LEADCID=dep.anlcid
								set tmp=Db.isDefined("DEP","LEADCID")
								if 'tmp do Runtime.setErrXBAD("DEP","ANLVAL") quit:ER
							 
								type RecordDEP lead = Db.getRecord("DEP", "CID=:LEADCID", 1)
							 
								//"Accts next svc fee date must equal lead acct svc fee date"
								if (lead.scnd '= dep.scnd) do Runtime.setErrXBAD("DEP","ANLSVF") quit:ER
	}
	quit

vau11 // Trigger AU_BGTOFFST - Budget Offset Days

	type public RecordDEP dep
	// Verify Budget Offset Days - 41065 CPS 07/14/00
	if (dep.bgtpro) if (dep.bgtyrnd-dep.bgtyrsd)<dep.bgtoffst do Runtime.setErrXBAD("DEP","BGT") quit:ER 
	quit

vau12 // Trigger AU_BGTPRO - After update Budget Processing

	type public RecordDEP dep
								/*
								---- Revision History---------------------------------------------------
	
								05/04/06 - KELLYP - CR 21117
        	   Removed Db.getRecord on DEP which was causing a PSL compiler
        	   error.  Also cleaned up rest of trigger.
								*/
							 
								type public Boolean ER
							 
	// If Budget Account create first Budget Record 
	if dep.bgtpro do {
	        type Boolean FOUND = 0
	        
	        // Check to see if budget records exist for today
	        type ResultSet rst = Db.select("BGTSEQ","BUDGET","CID=:dep.cid AND BGTYRSD=:dep.bgtyrsd")
	        if 'rst.isEmpty() quit
	        
	        // Check to see if any budget records exist
	        type ResultSet rsa = Db.select("BGTSEQ","BUDGET","CID=:XCID")
	        if 'rsa.isEmpty() set FOUND=1	
	        
	        type RecordBUDGET budget = Db.getRecord("BUDGET","CID=:dep.cid,BGTYRSD=:dep.bgtyrsd,BGTSEQ=1",1)
	        do budget.save()

		// Turning budget processing on will create a new budget year
		if FOUND do Runtime.setErrXBAD("DEP","BGTREC") quit:ER
		}

 	// If Budget Processing Flag has been turn off
	if 'dep.bgtpro do {
		/*
		 Save DEBAUT and DEBAUT2 files - set BGTCID,BGTSEQ,BILLNBR with 
		 empty string.
		*/ 
		type DbSet ds=Db.selectDbSet("DEBAUT","BGTCID=:dep.cid AND ACN=:dep.acn")
		while ds.next() do {
			type RecordDEBAUT debaut=ds.getRecord("DEBAUT")
		
			set debaut.bgtcid = ""
			set debaut.bgtseq = ""
			set debaut.billnbr = ""
	
			do debaut.save()
			}
		
		type DbSet ds2=Db.selectDbSet("DEBAUT2","BGTCID=:dep.cid AND ACN=:dep.acn")
		while ds2.next() do {
 		
			type RecordDEBAUT2 debaut2=ds2.getRecord("DEBAUT2")
							 
		        set debaut2.bgtcid = ""
			set debaut2.bgtseq = ""
			set debaut2.billnbr = ""
	
		        do debaut2.save()
			}
		}
	quit

vau13 // Trigger AU_BOO - After Update - Branch of Ownership

	type public RecordDEP dep
	/*
	   ---------- Revision History ------------------------------------------
	   
	   03/30/06 - RussellDS - CR16892
	   	      Remove references to obsolete membership info.

	   10/14/99 - CHOK - 31126
		      Converted to PSL.

	   03/11/98 - Terrie Dougherty - 26685
		      Replaced DTYPE with PRODDFTD as part of single
		      database project.
	*/

	
	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 
		/*
		   This is a transaction (core) account set up for percentage based
		   investment sweep - make identical change on corresponding non-
		   institutional investment accounts.
		*/
		new ICID,ITYPE,SWPNI,TBOO
	
		set TBOO=dep.boo
		new rs 
		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:CID")
		if rs.isEmpty() quit				// No linked investment accounts
	
		while rs.next() do { quit:ER  
			set ICID=rs.getCol(1)			// Investment Account Number
			set ITYPE=rs.getCol(2)			// Investment Product Type
			set SWPNI=Db.getOneRow("SWPNI","PRODDFTD","ITYPE")
			if SWPNI do Db.update("DEP","BOO=:TBOO","CID=:ICID")
			}
		}
	quit

vau14 // Trigger AU_BPAYOPTS - After Update ACTIBPAY,ELIGBPAY Options

	type public RecordDEP dep
	;---- Revision History--------------------------------------------------------
	; 01/02/02 - PREMKUMARM - 48651
	;            Added check for account level bill pay option.
	;-----------------------------------------------------------------------------
	if dep.actibpay=1,dep.eligbpay'=1 do Runtime.setErrMSG("DEP",5093) quit:ER
	quit

vau15 // Trigger AU_BWF - After Update Backup Withholding

	type public RecordDEP dep
	// trigger AU_BWF
	 
	/*
	   ---- Revision History----------------------------------------------
	12/08/05 - ALAGARSS - CR 18006
 		   Modified the code to remove deprecated feature warnings.
 		   And removed the old history.
	
	*/

	type public Boolean ER
	type public Number BWF
	/*
	Select Backup Withholding Option to use Accrued Withholding 
	Tax Processing
	*/
	if 'dep.bwf,dep.awtp do Runtime.setErrMSG("DEP",5071) quit:ER

	/*
	Accrued Withholding Tax Processing not valid with interest 
	Withholding Calculation Method
	*/
	if dep.awtp,dep.intwcalc'="" do Runtime.setErrMSG("DEP",5072) quit:ER

	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 
		/*
		   This is a transaction (core) account set up for percentage based
		   investment sweep - make identical change on corresponding non-
		   institutional investment accounts.
		*/
		
		set BWF=dep.bwf

		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:CID")
		// No linked investment accounts
		if rs.isEmpty() quit				
	
		while rs.next() do { quit:ER
		
			type RecordPRODDFTD proddftd=Db.getRecord("PRODDFTD","TYPE=:rs.getCol(""ITYPE"")")
			if proddftd.swpni do {
				type RecordDEP dep1=Db.getRecord("DEP","CID=:rs.getCol(""ICID"")")
				do dep1.setAuditFlag()
				set dep1.bwf=BWF
				do dep1.save()
				
			}
			}
		}

	quit

vau16 // Trigger AU_CC - After Update Cost Center

	type public RecordDEP dep
	/*
	   ---------- Revision History ------------------------------------------
	  12/08/05 - ALAGARSS - CR 18006
 		     Modified the code to remove deprecated feature warnings.
 		   
	   10/14/99 - CHOK - 31126
		      Converted to PSL.
	*/
	type public Boolean ER
	type public Number CC
	
	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 
		/*
		   This is a transaction (core) account set up for percentage based
		   investment sweep - make identical change on corresponding non-
		   institutional investment accounts.
		*/

		set CC=dep.cc
		
		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:CID")
		if rs.isEmpty() quit				// No linked investment accounts
	
		while rs.next() do { quit:ER  

			type RecordPRODDFTD proddftd=Db.getRecord("PRODDFTD","TYPE=:rs.getCol(""ITYPE"")")
			if proddftd.swpni do {
				type RecordDEP dep1=Db.getRecord("DEP","CID=:rs.getCol(""ICID"")")
				do dep1.setAuditFlag()
				set dep1.cc=CC
				do dep1.save()
				}
			}
		}
	quit

vau17 // Trigger AU_CCODE - After Update Customer Code

	type public RecordDEP dep
	/*
	   ---------- Revision History ------------------------------------------
	   12/08/05 - ALAGARSS - CR 18006
 		   Modified the code to remove deprecated feature warnings.
 		   
	   10/14/99 - CHOK - 31126
		      Converted to PSL.
	*/
	type public Boolean ER
	type public String CCODE
	
	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 
		/*
		   This is a transaction (core) account set up for percentage based
		   investment sweep - make identical change on corresponding non-
		   institutional investment accounts.
		*/
			
		set CCODE=dep.ccode
		
		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:CID")
		// No linked investment accounts
		if rs.isEmpty() quit				
	
		while rs.next() do { quit:ER  
			type RecordPRODDFTD proddftd=Db.getRecord("PRODDFTD","TYPE=:rs.getCol(""ITYPE"")")
			if proddftd.swpni do {
				type RecordDEP dep1=Db.getRecord("DEP","CID=:rs.getCol(""ICID"")")
				do dep1.setAuditFlag()								
				set dep1.ccode=CCODE
				do dep1.save()
			}
			}
		}
	quit

vau18 // Trigger AU_COLELG - After Update Collateral Eligibility 

	type public RecordDEP dep
	/*
	---- Revision History---------------------------------------------------
	02/08/06 - TELIV - CR 19311
		Replaced reference to XREFDEPSC with LNCOL

	*/

	// Account is pledged as collateral

	if dep.colelg quit

	new rs 
	type ResultSet rs=Db.select("PLDGACN","LNCOL","CID=:CID") 	
	if 'rs.isEmpty() do Runtime.setErrMSG("DEP",3517) quit:ER 
	quit

vau19 // Trigger AU_CONVACN - After Update trigger for CONVACN column.

	type public RecordDEP dep
	/*
	---- Revision History ------------------------------------------------
	
	07/29/01 - VETSENM - 46279
																			Set error message for Non-PROFILE account if Conversion
																			Account (DEP.CONVACN) is not defined.
	
	*/



	new CONV,NONPA,TYPE

	//Conversion Account Required for Non-PROFILE Institution Account.
	set TYPE=dep.type
	set NONPA=Db.getOneRow("NONPA","PRODCTL","TYPE")
	set CONV=dep.convacn
	if NONPA=1,CONV="" do Runtime.setErrMSG("DEP",4896) quit:ER
	quit

vau20 // Trigger AU_CTFGRP - Inserts plans onto CTFPLNCID

	type public RecordDEP dep
	/*
					---- Revision History---------------------------------------------------
	06/27/01 - KESTELMANN - 46116
																			Added code to check plans of the updated CTFGRP. The code
																			will check if there are any plans within that group that
																			can be deleted from the account's CTFPLNCID table. If all
																			the  dollar fields on the CTFPLNCID table are 0 or null,
																			then that plan can be removed from the CTFPLNCID table.
	
								03/19/01 - STATTOND - 43390
								updates CTF plans on the account level, CTFPLNCID. (^ACN Node 123)
								when dep.ctfgrp (Group Name) is modified.  
	*/

	
	 
	new CTFPLN,GRPNAME,data

	set GRPNAME=dep.ctfgrp.oldVal    // get updated CTFGRP
	
	I GRPNAME'="" do { quit:ER
								type ResultSet rs=Db.select("CTFPLN","UTBLCTFGRP1","GRPNAME=:GRPNAME")
									while rs.next() do { quit:ER
																set CTFPLN=rs.getCol(1)
																if Db.isDefined("CTFPLNCID","CID,CTFPLN") do { quit:ER
																								set data=Db.getOneRow("DAYCALC,DAYCALCF,PYTD,PLIF,PPYR","CTFPLNCID","CID,CTFPLN")
																								if '$P(data,$C(9),1),'$P(data,$C(9),2),'$P(data,$C(9),3),'$P(data,$C(9),4),'$P(data,$C(9),5) do Db.delete("CTFPLNCID","CID=:CID AND CTFPLN=:CTFPLN") quit:ER
																								}
																}
	}

	set GRPNAME=dep.ctfgrp
	set CID=dep.cid

	if dep.ctfgrp'="" do {
 	type ResultSet rs=Db.select("CTFPLN","UTBLCTFGRP1","GRPNAME=:GRPNAME")
 	if rs.isEmpty() quit
	while rs.next() do {
		set CTFPLN=rs.getCol(1)
		if Db.isDefined("CTFPLNCID","CID,CTFPLN") quit
		
		//check initial query
		new query
		set query=Db.getOneRow("INTQUERY","UTBLCTFPLN","CTFPLN")
		if '$$CHECKCID^COMCALC() quit
		
		//check to see if end date on plan has past
																new ENDDATE
		set ENDDATE=Db.getOneRow("ENDDATE","UTBLCTFPLN","CTFPLN")
																if (ENDDATE'="")&(TJD>ENDDATE) quit

		do Db.insert("CTFPLNCID","CID,CTFPLN,ACTIVE",":CID,:CTFPLN,:1")

		}
	}


	quit
	

vau21 // Trigger AU_CURRAMT - After Update of Current Amount

	type public RecordDEP dep

	/* Revision history

	02/17/06 - SmithCD - CR 19637
		   Replaced UPDATE^PROCESC call, which no longer exists.

	*/

	if dep.aref.isNull() quit

	// Update Payment Escrow Amount on loan account related to escrow
	type RecordLN ln = Db.getRecord("LN", "CID=:dep.aref")
	set ln.pmttrs = ln.pmttrs + (dep.curramt - dep.curramt.oldVal)
	do ln.save()

	quit

vau22 // Trigger AU_DARCOVR - After Update Deposit Asset Class Overrid

	type public RecordDEP dep
	/*
	----Revision History---------------------------------------------------
 	08/10/05 - TITOVE - CR 16844
		   Cleaned up as part of DBI3 project. 
	
	*/

	// Asset Class Override has to have a valid value
	if 'dep.darcovr quit
	
	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE = :dep.type")
	
	// Deposit reclassification processing not valid for product type ~p1
	if 'prodctl.darcpo do Runtime.setErrMSG("DEP",3245,dep.type) quit 

	
	// Verify the value exist in UTBLACC: "Invalid table value ~p1"
	if 'Db.isDefined("UTBLACC","dep.cls,dep.darcovr") do Runtime.setErrMSG("DEP",1485,"UTBLACC.AC") quit 

	quit
	

vau23 // Trigger AU_DOD_INTEG - Date of Death/Disability Integrity Check

	type public RecordDEP dep
	/*
	---- Revision History -------------------------------------------------
	07/19/05 - RussellDS - CR16614
		   Remove reference to vpar("VALRI" and replaced with
		   just vpar reference.
		   
		   Cleaned up PSL
		   
		   Remove old revision history.
	-----------------------------------------------------------------------

	This trigger should never have a column name associated with it.  It should
	be called for any and all DEP maintenance.
	
	*/
	
	type public Boolean ER
	type public String verrors(,)
	
	type Boolean DISBRST, DODRST
	type String VERR1, VERR2

	quit:vpar.get().isLike("%/NOVALRI/%")
	
	type RecordCIF cif = Db.getRecord("CIF", "ACN=:dep.acn")
	
	// Verify that the CIFDOD and CIFDODSABL restrictions have not
	// been set.  Do not set the restrictions a second time.
	
	set (DODRST,DISBRST) = 0
	set (VERR1,VERR2) = ""
	for  set VERR1 = verrors(VERR1).order() quit:VERR1.isNull()  do {
		for  set VERR2 = verrors(VERR1,VERR2).order() quit:VERR2.isNull()  do {
			if verrors(VERR1,VERR2).piece("|", 3) = "CIFDOD" set DODRST=1
			if verrors(VERR1,VERR2).piece("|", 3) = "CIFDODSABL" set DISBRST=1
		}
	}
	
	if (cif.dod > 0), 'DODRST do Runtime.setErrXBAD("DEP","CIFDOD") quit:ER 
	if (cif.dodsabl > 0), 'DISBRST do Runtime.setErrXBAD("DEP","CIFDODSABL") quit:ER 

	quit

vau24 // Trigger AU_EXTACN - External Transfer Customer ID

	type public RecordDEP dep
	/*
	  ---- Revision History -----------------------------------------------
		08/06/01 - MAYLATHR - 45171
		Changed logic so that the principal maturity option is not
		dependent on the interest maturity option.

		09/07/00 - KINI - 41328
 	      	Roll forward changes by DADAP (ARQ 32293) to replace EXTACN & 
 	        EXTSEQ columns with INTDISETC & INTDISETS.
 	        Presence of the previous columns caused unwanted validation 
 	        message appearance during account update that has int/div 
 	        transferred to an external account when DEP.IOPT=4.           	

	  ---------------------------------------------------------------------
	*/ 

	// External Acct Sequence is required
	if dep.extacn'="",dep.extseq="" do Runtime.setErrXBAD("DEP",199) quit:ER 

	// External Acct Sequence is required
	if dep.intdisetc'="",dep.intdisets="" do Runtime.setErrXBAD("DEP",199) quit:ER

	// External Tfr  Cust ID required for external tfr
	if dep.intdisetc="",((dep.imo=4)!(dep.iopt=4)) do Runtime.setErrXBAD("DEP",202) quit:ER 

								// External Tfr  Cust ID required if Prin Mat Opt is 4
								if dep.primatetc="",dep.rencd=4 do Runtime.setErrXBAD("DEP",201) quit:ER 
	
	quit
	

vau25 // Trigger AU_FEEPLN - After update of Fee Plan

	type public RecordDEP dep
	if dep.grp="DBD",dep.feepln'="" do Runtime.setErrXBAD("DEP","XDBDFEE") quit:ER 
	quit 
	

vau26 // Trigger AU_FLT_INFO - After Update Float Hold Info

	type public RecordDEP dep
	/*
	   ---- Revision History ------------------------------------------------

	   11/22/05 - NATRAJAH - 13734
		      General DBI3 cleanup.

	   04/03/01 - TITOVE - 41199:001
		      Corrected setting of the error message 2852.

	   11/29/00 - TITOVE - 41199
	              Added check to make sure the percentage allocation for
        	      hold factors adds up to 100%, unless it is zero.

	   05/25/00 - LUS - 40263
																						Retrofitted change below:
		      04/03/00 - LUS -37723
																						Removed the check to verify the requied of Float Hold and
                      Check Hold.	
	   10/14/99 - CHOK - 31126
		      Converted to PSL.

	   08/06/99 - KONGJ - 34255
	              Added a check to ensure that either Float Hold or Factor
	              field contains value.
	*/

	// FLTP*/FLTD* - Float Hold verification
	type Public Boolean ER
	if dep.grp="DBD" quit 
	
	type Number D,P,J,K
	type String DESC
			
	// Float Hold
	set DESC=$$^MSG(6053)                  //float hold
	set P(1)=dep.fltp1
	set P(2)=dep.fltp2
	set P(3)=dep.fltp3
	set P(4)=dep.fltp4
	set P(5)=dep.fltp5
	set D(1)=dep.fltd1
	set D(2)=dep.fltd2
	set D(3)=dep.fltd3
	set D(4)=dep.fltd4
	set D(5)=dep.fltd5
	
	set P=0 for J=1:1:5 set P=P+P(J)
	// Total %HELD ~p1 exceeds 100%
	if P>100 do Runtime.setErrMSG("DEP",2668,DESC) quit:ER 
	// Sum of percentage allocations must be 0% or 100%  - TITOVE - 41199
	if P'=0,P'=100 do Runtime.setErrMSG("DEP",2852) quit:ER
	// Percent held ~p1 # ~p2 cannot be greater than # ~p3
	for J=5,4,3,2 if P(J),P(J)'<P(J-1) set K=J-1 do Runtime.setErrMSG("DEP",24,"DESC~J~K") quit:ER 
	// Days held ~p1 for factor #~p2 must be greater than #~p3
	for J=1,2,3,4 if P(J),P(J+1),D(J+1)'>D(J) set K=J+1 do Runtime.setErrMSG("DEP",762,"DESC~K~J") quit:ER 
	quit

vau27 // Trigger AU_GCR - After Update Good Customer Information

	type public RecordDEP dep
	/*
	   After Update verification for GCRS - Good Customer Status - If GCR status contains a
	   value, GCR processing is invoked.  Scoring tables, etc are required even
	   when the status is fixed or revoked.  When the status if fixed or revoked,
	   the account will not be automatically be scored in the monthly or
	   daily scoring processes.

	   Revision History
	
	   12/11/06 - SWARNALP - 22716
	   	      Replaced the incorrect condition check which checks GCR code's 
	   	      old value to be 1 while creating record in DTJFMMS table 
	   	      with the condition to check Next Scoring Date's(DEP.NSDATE) old 
	   	      value to be TJD-1 (the same condition check is used in the Batch 
	   	      BCHGCRMS) so that the record will be created in DTJFMMS table 
	   	      only on the date the batch BCHGCRMS (GCR Monthly Scoring) is 
	   	      executed.
	   	      
	   11/22/05 - NATRAJAH - 13734
		      General DBI3 cleanup.

	   03/21/00 - CHOK - 31126
		      Update DTJFMMS table

	*/
	type Public Boolean ER
	if dep.gcrs do { quit:ER 
		// GCR status is Revoked, GCR code not applicable"
		if dep.gcrs=3,(dep.gcrcd'="") do Runtime.setErrMSG("DEP",3283) quit:ER 
		// Monthly scoring table, GCR code, and Scoring Frequency
		// are required if GCR status is Dynamic or Fixed
		if dep.gcrs'=3 do { quit:ER 
			if dep.mscrtbl="" do Runtime.setErrMSG("DEP",7531,"DEP.MSCRTBL") quit:ER     // Data required in Data Item ~p1
			if dep.gcrcd="" do Runtime.setErrMSG("DEP",7531,"DEP.GCRCD") quit:ER         // Data required in Data Item ~p1
			if dep.scrfreq="" do Runtime.setErrMSG("DEP",7531,"DEP.SCRFREQ") quit:ER     // Data required in Data Item ~p1
			if 'Db.isDefined("UTBLGCRBAL","dep.mscrtbl,dep.gcrcd") do Runtime.setErrMSG("DEP",3284,"GCRCD~MSCRTBL") quit:ER 
			}
		if dep.gcrs=1 do { quit:ER 
			if (dep.gcrs.oldVal=1),dep.isChanged("GCRCD"),'dep.isChanged("GCRCD","SYSTEM") do Runtime.setErrMSG("DEP",3287) quit:ER

			// Update Monthly Scoring File Maintenance Journal
			if dep.isChanged("GCRCD","SYSTEM"),(dep.nsdate.oldVal=(%SystemDate-1)) do {
				new dtjfmms,zcid
				type RecordDTJFMMS dtjfmms=Class.new("RecordDTJFMMS")
				set dtjfmms.tjd=%SystemDate
				set zcid=dep.cid
				set dtjfmms.cid=dep.cid
				set dtjfmms.mseq=Db.nextVal("DTJFMMS","TJD,zcid")
				set dtjfmms.bal=dep.bal
				set dtjfmms.boo=dep.boo
				set dtjfmms.dtop=dep.odt
				set dtjfmms.dtpmnt=dep.gcrpmnt.oldVal
				set dtjfmms.gcrlbal=dep.gcrlbal
				set dtjfmms.newgcr=dep.gcrcd
				set dtjfmms.ngcrcov=dep.gcrcv
				set dtjfmms.ogcrcov=dep.gcrcv.oldVal
				set dtjfmms.oldgcr=dep.gcrcd.oldVal
				set dtjfmms.origopd=dep.origopd
				set dtjfmms.todcnt=dep.todcnt
				set dtjfmms.type=dep.type
				do dtjfmms.bypassSave()
				}

			// Daily scoring table and daily scoring option are required if GCR status is Dynamic
			if dep.dscrtbl="" do Runtime.setErrMSG("DEP",7531,"DEP.DSCRTBL") quit:ER     // Data required in Data Item ~p1
			if 'dep.dsopt do Runtime.setErrMSG("DEP",7531,"DEP.DSOPT") quit:ER	     // Data required in Data Item ~p1
			if dep.nsdate<%SystemDate do Runtime.setErrMSG("DEP",3285) quit:ER 
			}
		}
	
	if dep.scrfreq'="" do { quit:ER 
		type Date DATE
		set DATE=$$NJD^UFRE(Db.getOneRow("TJD","CUVAR"),dep.scrfreq,.AF) quit:ER 
		if AF'=12 do Runtime.setErrMSG("DEP",3286) quit:ER 
		}
	quit

vau28 // Trigger AU_GCRTFCID - After Update GCR Transfer Account

	type public RecordDEP dep
	if dep.gcrtfcid="" quit 
	/*
	   GCR transfer account holds the account from which GCR information is
	   transferred.  Move GCR Liability Package Balances from GCR transfer
	   account.
	   
	   Revision History
	
	   11/22/05 - NATRAJAH - 13734
		      General DBI3 cleanup.

	*/
	type Number GCID,LCID,XCID
	type Date SDATE
	set GCID=dep.gcrtfcid
	set XCID=dep.cid
	type ResultSet rs=Db.select("LCID,SDATE","GCRPKG","CID=:GCID")
	if rs.isEmpty() quit
	while rs.next() do { 
		set LCID=rs.getCol(1)
		set SDATE=rs.getCol(2)
		do Db.update("GCRPKG","CID=:XCID","CID=:GCID AND LCID=:LCID AND SDATE=:SDATE")
		}
	quit

vau29 // Trigger AU_GLSC - After update valid G/L set code.

	type public RecordDEP dep
	/*
	---- Revision History ------------------------------------------------

	06/01/05 - Kini - 16153
		   Added GLSC verification via GLCHK^ACNFUNCS to ensure that
		   the class and group of GLSC match the class and group of the
		   deposit. Removed 'Db.isDefined check on UTBLGLSC table as 
		   GLCHK^ACNFUNCS returns the same error if the set code isn't 
		   defined.

	02/17/05 - Kini - 13991	
		   Modified to replace UTBLGLSCX index table with UTBLGLSC
		   since UTBLGLSCX has been obsoleted.
	*/
	
	type public Boolean ER
	
	// Validate G/L Set Code
	do GLCHK^ACNFUNCS(dep.cls,dep.grp,dep.glsc) quit:ER
		
	quit
	

vau30 // Trigger AU_GRP - After Update Group

	type public RecordDEP dep
	new grp,XTYPE
	set XTYPE=dep.type
	set grp=Db.getOneRow("GRP","PRODCTL","XTYPE")

	// Product class or group does not match product type
	if dep.grp'=grp do Runtime.setErrMSG("DEP",8472) quit:ER
	quit
	

vau31 // Trigger AU_HLD_INFO - After Update Check Hold Info

	type public RecordDEP dep
	/*
	   ---- Revision History ------------------------------------------------
	
	   11/22/05 - NATRAJAH - 13734
		      General DBI3 cleanup.

	   04/03/01 - TITOVE - 41199:001
		      Corrected setting of the error message 2852.

											11/29/00 - TITOVE - 41199
																						Added check to make sure the percentage allocation for
																						hold factors adds up to 100%, unless it is zero.

	   05/25/00 - LUS - 40263
																						Retrofitted change below:
																						04/03/00 - LUS -37723
																						Removed the check to verify the requied of Float Hold and
																						Check Hold.
         	
	   10/14/99 - CHOK - 31126
		      Converted to PSL.

	   08/06/99 - KONGJ - 34255
	              Added a check to ensure that either Check Hold or Factor
	              field contains value.
	*/

	// HLDP*/HLDD* - Check Hold verification
	type Public Boolean ER
	if dep.grp="DBD" quit 
	
	type Number D,P,J,K
	type String DESC
					
	// Check hold
	set DESC=$$^MSG(6704)                  //Check hold ~p1
	set P(1)=dep.hldp1
	set P(2)=dep.hldp2
	set P(3)=dep.hldp3
	set P(4)=dep.hldp4
	set P(5)=dep.hldp5
	set D(1)=dep.hldd1
	set D(2)=dep.hldd2
	set D(3)=dep.hldd3
	set D(4)=dep.hldd4
	set D(5)=dep.hldd5
	
	set P=0 for J=1:1:5 set P=P+P(J)
	// Total %HELD ~p1 exceeds 100%
	if P>100 do Runtime.setErrMSG("DEP",2668,DESC) quit:ER 
	if P'=0,P'=100 do Runtime.setErrMSG("DEP",2852) quit:ER
	// Percent held ~p1 # ~p2 cannot be greater than # ~p3
	for J=5,4,3,2 if P(J),P(J)'<P(J-1) set K=J-1 do Runtime.setErrMSG("DEP",24,"DESC~J~K") quit:ER 
	// Days held ~p1 for factor #~p2 must be greater than #~p3
	for J=1,2,3,4 if P(J),P(J+1),D(J+1)'>D(J) set K=J+1 do Runtime.setErrMSG("DEP",762,"DESC~K~J") quit:ER 
	quit

vau32 // Trigger AU_ICHND - After Update Interest Change Next Date

	type public RecordDEP dep
	// ICHND - Interest Change - Next Date  and  INTFRE - Interest Change Frequency
	
	/*
	    Revision History

	    07/09/02 - BECKERJ - 50876
		       Added code to return an error if an account has no index
		       but has an interest change frequency.

												09/08/00 - ANTONOVS - 41669
																							Display an error message &&SetErrXBAD("INTFRE") when
																							there is ICHND and INTFRE is missing regardless of 
																							INDEX value.

	    10/14/99 - CHOK - 31126
		       Converted to PSL.

	    03/10/99 - NGUYENP - 28271
	              Display the Interest Change Frequency message
	              &&SetErrXBAD("INTFRE") only when the Interest Index exists
	              and the Interest Frequency is missing.
	*/

	if dep.ichnd'="" do { quit:ER 
		if dep.ichnd<%SystemDate do Runtime.setErrXBAD("DEP","ICHND") quit:ER 
		if dep.intfre="" do Runtime.setErrXBAD("DEP","INTFRE") quit:ER 
		}
	else  if dep.intfre'="" do Runtime.setErrXBAD("DEP","ICHND") quit:ER 

	if dep.intfre'="",dep.index="" do Runtime.setErrXBAD("DEP","INDEX16") quit:ER	// JMB - 50876

	quit
	

vau33 // Trigger AU_INC - After Update Interest Next Compounded

	type public RecordDEP dep
	/* 
	---- Revision History ------------------------------------------------

	01/15/01 - AHMEDS - 43469
		 Added check for the invalid combination of cumulative
		 deposit option set to 1 with interest compounding
		 frequency set to null.
	----------------------------------------------------------------- 
	*/
	// trigger AU_INC
	
	// Cumulative Deposits Require an Interest Compounding Frequency.
	if dep.cumdep,dep.icf="" do Runtime.setErrMSG("DEP",4694) quit:ER

	//
	if dep.inc'="" do { quit:ER 
		if dep.inc<%SystemDate do Runtime.setErrXBAD("DEP","INC") quit:ER 
		if dep.icf="" do Runtime.setErrXBAD("DEP","ICF") quit:ER 
		}
	else  if dep.icf'="" do Runtime.setErrXBAD("DEP","INC") quit:ER 

	// Int Compounding is not supported for segmented accts
	if dep.segflg=1,dep.icf'="" do Runtime.setErrXBAD("DEP",210) quit:ER 
	
	quit 

vau34 // Trigger AU_INCDR - After Update Incremental Debit Amount

	type public RecordDEP dep
	/*
	   INCDR - Incremental Debit Amount Verification
	   Overdraft Source Incremental Transfer Amount must be evenly
	   divisible by Incremental Debit Amount.

	   ---------- Revision History ------------------------------------------

	   09/23/05 - NATRAJAH - 17245
		      General DBI3 cleanup.

	*/
	if dep.incdr do { quit:ER 
		type Number ODSITR,TYPE
		set TYPE=dep.type
		type ResultSet rsodsitr=Db.select("ODSITR","PRODCTL","TYPE=:TYPE")
		set ODSITR=rsodsitr.getCol("ODSITR")
		if ODSITR,ODSITR#dep.incdr do Runtime.setErrXBAD("DEP","ODSITR") quit:ER 
		}
	quit
	

vau35 // Trigger AU_INDEX_ODLIM - After Update INDEX or ODLIM,ODTERM

	type public RecordDEP dep
	/*
	 ---- Revision History ------------------------------------------------
	
	08/14/02 - ANTONOVV - 43583
		   Modified parameters in LOADIX^UINDX call.
	
	07/09/02 - BECKERJ - 50876
		   Added code to return an error if an account has no index
		   but has an interest change frequency.

	09/19/01 - ARPAV - 47504
		   Added code before call into DICHECK^DEPAI to prevent 
		   undefined error in UINDX.  In ACN section of UINDX, CTL is 
		   supposed to be set.  From the DEP filer, the proper setting
		   is "001".
	
	05/02/01 - SHVACHKINAD - 44678
		   Removed check of expiration date that was called by
		   DICHECK^DEPAI.	

	01/29/01 - SHVACHKINAD - 42748
		   Added a loop through IX array that will call
		   DICHECK^DEPAI, which will match the data items specified
		   on the index with data items specified on the account,
		   for indexes with data item authorization set to YES.
	
	10/16/00 - ANTONOVV - 40364
	           Added code to check integrity and to validate Positive,
		   Auth/Unauth Negative Interest spreads.

	06/27/00 - Terrie Dougherty - 40629
		   Modified calls to $$TIERDI to use new DEP procedure
		   $$ITERDI^PROCDEP

	12/23/99 - OYEGUNZ - 36038
		   Return error message if ODLIM'="" and NEGIPO'=2.

	12/20/99 - SIVCHUKA - 36070
		   Modified to properly check ODLIM defined, ODTERM not defined.
		   Return error message if ODLIM'="" and NEGIPO'=2.
	
	10/14/99 - CHOK - 31126
		   Converted to PSL.

	09/24/99 - SIVCHUKA - 34902
		   Added 2 integrity errors:
		   1.  If there is an overdraft limit (DEP.ODLIM) and not term
		   (DEP.ODTERM), return fatal error "4001"
		   2.  If there is an overdraft term (DEP.ODTERM) and not limit
		   (DEP.ODLIM), return fatal error "4002"
	
	09/17/99 - MAGERAM - 34062
		   Modified to set &&SetErrSTBLER(ET) if ER.
	
	02/26/99 - KLINEB - 32058
		   Roll forward:
		   Added code to return error message if INTMAT, INTSPR, or
		   RNDMTD is defined and INDEX is not (roll forward from v60).
	
		   Added logic to not do index section if INDEX is null.
	*/
	
	if dep.index'=dep.index.oldVal&(dep.index'="") do { quit:ER 
		//INDEX has been modified
		new CTL,X
		set CTL="001"
		set X=dep.index
		if dep.ichld="" do Runtime.setErrXBAD("DEP","INDEX11") quit:ER 
		if dep.ichnd="" do Runtime.setErrXBAD("DEP","INDEX12") quit:ER 
		if dep.intfre="" do Runtime.setErrXBAD("DEP","INDEX13") quit:ER 
	
		/*
		   EDT^UINDX validates the following:
		   INDEX1 - Invalid index name
		   INDEX2 - Invalid index offset syntax
		   INDEX3 - Invalid rounding instruction
		   INDEX4 - Invalid index rounding percentage
		   INDEX5 - Extraneous index plan information entered
		*/
		set ZX=X
		do EDT^UINDX if ER do Runtime.setErrSTBLER("DEP",ET) quit:ER 
		set X=dep.intspr
		do SPRPP^UINDX if ER do Runtime.setErrSTBLER("DEP",ET) quit:ER 
		set X=dep.rndmtd
		do RNDPP^UINDX if ER do Runtime.setErrSTBLER("DEP",ET) quit:ER 
		set X=ZX
		}
	
	if dep.index'="" do { quit:ER 
		// Account has an index

		new BASE,DIAUTH,EFD,EFDATE,EXP,IRN,PAR,TIERDI,TIER
		set (BASE,EFD,TIER)=""
		set TIERDI=$$TIERDI^PROCDEP(.dep)
		if dep.odlim'="",TIERDI do Runtime.setErrXBAD("DEP","ODLIM") quit:ER 
	
		set IX=dep.index
		if '$D(IX(IX)) if '$$LOADIX^UINDX(.dep,dep.index,"",.EFDATE,.PAR) do Runtime.setErrSTBLER("DEP",ET) quit:ER 

		// Data Item Authorization Flag
		set DIAUTH=$P(IX(IX),"|",14)
		
		for  set EFD=$O(IX(IX,EFD)) quit:(EFD="")  do { quit:ER 
			for  set TIER=$O(IX(IX,EFD,TIER)) quit:(TIER="")  do { quit:ER 
				// Set CTL for processing within UINDX	VCA 9/19/01
				new CTL
				set CTL="001"
 				// Check tier
				do DICHECK^DEPAI(TIER,.dep,BASE,DIAUTH) quit:ER
				// Check interest rate
				set IRN=$P(IX(IX,EFD,TIER),"|",1)
				do DICHECK^DEPAI(IRN,.dep,BASE,DIAUTH) quit:ER
			}
		}
		if dep.odterm'="",dep.odlim="" do Runtime.setErrMSG("DEP",4002) quit:ER
		
		/*
																			Auth/Uauth Negative / Positive Int Spreads integrity check
																			//AV - ARQ 40364 - 10/3/00
																*/
																if (dep.intspra'="")!(dep.intspru'="") do { quit:ER
	
																								new INDEFD,TIER,VALID
																								set INDEFD=0
																								set VALID=0
																								set TIER=""
	
																								// If Index is not Incremental - error
																								if $P(IX(IX),"|",2)'="I" do Runtime.setErrMSG("DEP",4522) quit:ER
	
																								// Overdraft limit must be defined.
																								if dep.odlim="" do Runtime.setErrMSG("DEP",4522) quit:ER
	
																								// If DEP.ODLIM and DEP.ODEXP are not defined as an Ind tier.
																								set INDEFD=$O(IX(IX,INDEFD))
																								for  set TIER=$O(IX(IX,INDEFD,TIER)) quit:(TIER=""!VALID)  do { quit:ER
																																if TIER["DEP.ODLIM",$P(IX(IX,INDEFD,TIER),"|",4)="DEP.ODEXP" set VALID=1 quit
																								}
																								if 'VALID do Runtime.setErrMSG("DEP",4522) quit:ER
																}
	
																// If Index is not Incr or Cumul and Positive Int Spread is used - error
																if (dep.intsprp'=""),$P(IX(IX),"|",2)'="I",$P(IX(IX),"|",2)'="C" do Runtime.setErrMSG("DEP",4521) quit:ER
	
																// Check spread syntax. (+-*/ can only be used)&(/0 - error)
																if dep.intspra'=""  do { quit:ER
																								set X=dep.intspra
																								do SPRPP^UINDX
																								if ER do Runtime.setErrMSG("DEP",4523,"DEP.INTSPRA") quit:ER
			if dep.intspra["/0" do Runtime.setErrMSG("DEP",4538) quit:ER
																								}
																if dep.intspru'=""  do { quit:ER
																								set X=dep.intspru
																								do SPRPP^UINDX
																								if ER do Runtime.setErrMSG("DEP",4523,"DEP.INTSPRU") quit:ER
			if dep.intspru["/0" do Runtime.setErrMSG("DEP",4538) quit:ER
																								}
																if dep.intsprp'=""  do { quit:ER
																								set X=dep.intsprp
																								do SPRPP^UINDX
																								if ER do Runtime.setErrMSG("DEP",4523,"DEP.INTSPRP") quit:ER
			if dep.intsprp["/0" do Runtime.setErrMSG("DEP",4538) quit:ER 
																								}
																	/* End of Int Spreads integrity check */
		}
	// Auth/Uauth Neg Int Spreads can be used with C/I Index only. //AV - 40364
								if ((dep.intspra'="")!(dep.intspru'="")),dep.index="" do Runtime.setErrMSG("DEP",4521) quit:ER
	
								// Positive Int Spreads can be used with Incr Index only.  //AV - 40364
								if (dep.intsprp'=""),(dep.index="") do Runtime.setErrMSG("DEP",4522) quit:ER


	// If there is a limit, but no term.......
	if dep.odlim'="",dep.odterm="" do Runtime.setErrMSG("DEP",4001) quit:ER
		
		
	// Account does not have an index
	if dep.index="",(dep.odlim'=""!($$TIERDI^PROCDEP(.dep))) do Runtime.setErrXBAD("DEP","ODLIM2") quit:ER 
	if dep.index="",dep.intfre'="" do Runtime.setErrXBAD("DEP","INDEX16") quit:ER	// JMB - 50876
	
	//With O/D Limit, post +ve and -ve int/div interest accruals seperately;36038
	if dep.odlim'="",dep.negipo'=2 do Runtime.setErrMSG("DEP",4178) quit:ER

	// Update Consolidated Limits
	if dep.odlim'=dep.odlim.oldVal do {
		quit:'Db.getOneRow("LIMPRO","CUVAR") 
		new AMT,DEPDATA,BAL,BALCOL,TOTCOM,GRP,CRCD
		set BAL=dep.bal
		set BALCOL=dep.balcol
		set CRCD=dep.crcd
		set GRP=dep.grp
		set AMT=$S(BALCOL="":BAL,1:BALCOL)
		if AMT>0 quit 
		if GRP="DBD" quit 
		set TOTCOM=-AMT if -AMT<dep.odlim.oldVal set TOTCOM=dep.odlim.oldVal
		if dep.odlim'>-AMT,dep.odlim>dep.odlim.oldVal quit 
		if dep.odlim.oldVal'>-AMT,dep.odlim<dep.odlim.oldVal quit 

		new ACN,ACNDATA,ADJ,CNTRY,GOVT,SIC,TOTEXPC,X,NEW,OLD
		set NEW=dep.odlim
		set OLD=dep.odlim.oldVal
		if CRCD=%SystemCurrency do {
			set NEW=$$CONV^CRCDUTL(NEW,CRCD,%SystemCurrency,1)
			set OLD=$$CONV^CRCDUTL(OLD,CRCD,%SystemCurrency,1)
			set TOTCOM=$$CONV^CRCDUTL(TOTCOM,CRCD,%SystemCurrency,1)
			set AMT=$$CONV^CRCDUTL(AMT,CRCD,%SystemCurrency,1)
			}
		set ACN=dep.acn
		set ACNDATA=Db.getOneRow("PCNTRY,GOVT,SIC","CIF","ACN")
		set CNTRY=$P(ACNDATA,$C(9),1)
		set GOVT=$P(ACNDATA,$C(9),2)
		set SIC=$P(ACNDATA,$C(9),3)

		set TOTEXPC=Db.getOneRow("TOTCOMEXP","EXPCNTRY","CNTRY")
		if $E($G(SIC)) new TOTEXPI set TOTXPI=Db.getOneRow("TOTCOMEXP","EXPIND","SIC")
		if $G(GOVT) new TOTEXPS set TOTEXPS=Db.getOneRow("TOTCOMEXP","EXPCNSOV","CNTRY")

		if OLD'<TOTCOM do {
			if NEW>-AMT set ADJ=NEW-OLD
			else  set ADJ=-AMT-OLD
			}
		else  set ADJ=NEW-TOTCOM
		set TOTEXPC=$$^SCARND(TOTEXPC+ADJ,0,"",%SystemCurrency)

		do Db.update("EXPCNTRY","TOTCOMEXP=:TOTEXPC","CNTRY=:CNTRY")
		if $G(TOTEXPI) set TOTEXPI=TOTEXPI+ADJ do Db.update("EXPIND","TOTCOMEXP=:TOTEXPI","IND=:SIC")
		if $G(TOTEXPS) set TOTEXPS=TOTEXPS+ADJ do Db.update("EXPCNSOV","TOTCOMEXP=:TOTEXPC","CNTRY=:CNTRY")
		}
	
	// Updating Interest Matrix, Interest Spread, and Interest Rounding Method
	
	if (dep.intmat'="")!(dep.intspr'="")!(dep.rndmtd'="") do {
		if dep.index="" do Runtime.setErrMSG("DEP",8745) quit:ER 
		}
	quit

vau36 // Trigger AU_INTEREST - After Update Interest Fields

	type public RecordDEP dep
	/*
	   ---------- Revision History -----------------------------------------

	   10/15/02 - AHMEDS - 49754:01
		      Clean up of Interest Statements project (ARQ 34285). 
		      Removed code for integrity checks on Generate Int/Div
		      Statement (dep.gis).

	   05/03/02 - KELLYP - 49129
		      Removed previous change under this ARQ.  ACNDSD
		      functionality is now required in V6.4 up.

	   04/08/02 - KELLYP - 49129
		      Added code to check if INP or IPF has been file 
		      maintained.  If so, and if no ACNDSD record exists where
		      FRECOL="IPF" and SCHDT=0, then XBAD message CNVIDT1 or
		      CNVIDT2 will be returned.

	   02/26/01 - HALPINJ - 43406
		      Added code to check to make sure DAYENDINP does not exist
		      before trying to do the SQL insert.

	   08/29/00 - LUS - 41547
		      Retrofit of change below:
		      03/15/00 - AHMEDS - 35866
		      Put LBCM,LBCP in the Column names of the Control Page.
	
	   07/17/00 - SCOTTC - 41065
		      Old DAYEND "INP" entry not getting deleted when modifying
		      a non-segmented account.  Move code which sets X up so	
		      that both segmented and non-segmented have a value for X.

	   03/17/00 - CHOK - 31126
		      Converted isChanged method

	   01/06/99 - HAYMANP - 35866
		      Retrofit of change below:

		      12/18/99 - SMITHC - 35866
		      Added code to handle low balance verification.
		
	   12/30/99 - MAGERAM - 36270
		      Added integrity checks for Generate Interest Statement.
		      Roll forward for ARQ#34285	
			
	   10/14/99 - CHOK - 31126
		      Converted to PSL.

	   09/02/99 - MAGERAM - 32998
		      Added restriction "~p1 must be null when accruing at segment
	              level" for INP.
	
	   07/14/99 - SMITHC - 33309
		      Modified 6/10/99 change to set up DAYEND entries only if
		      not in verify mode.
	
	   06/10/99 - SMITHC - 32048
		      Maintain DAYEND entry of next interest posting dates
		      (regular, segment) manually.  This coding replaces the
		      traditional filer index definitions for next interest
		      posting dates.
	
	*/

	// ~p1 must be null when accruing at segment level
	if dep.segflg,'dep.segacr,dep.inp do Runtime.setErrXBAD("DEP",532,"DEP.INP") quit:ER 
	
	if dep.inp do { quit:ER 
		if dep.inp<%SystemDate do Runtime.setErrXBAD("DEP","INP") quit:ER 
		if dep.mdt'=dep.inp,dep.inp>%SystemDate,dep.ipf="" do Runtime.setErrXBAD("DEP","INPF") quit:ER 
		}
	else  if dep.ipf'="",('dep.segflg!(dep.segacr)) do Runtime.setErrXBAD("DEP","INP") quit:ER 
	
	if dep.intchknd,dep.intchknd<%SystemDate do Runtime.setErrXBAD("DEP","INTCHKND") quit:ER 
	else  if dep.intchkfre'="",dep.intchknd="" do Runtime.setErrXBAD("DEP","INTCHKND") quit:ER 
	
	// Verify Interest Posting and Check Data are Compatible
	if dep.inp,dep.ipf'="",dep.intchkfre'="",dep.intchknd'="" do { quit:ER 
		do VER^LNUSFV(dep.inp,dep.ipf,$$^MSG(3787),dep.intchknd,dep.intchkfre,$$^MSG(6796))   //Interest Posting
		if ER do Runtime.setErrXBAD("DEP","INTCHKINV") quit:ER 
		}

	// Call procedure DEPLBB if any critical low balance fields change
	if ((dep.isChanged("IPF"))!(dep.isChanged("LBCP"))!(dep.isChanged("LBCM"))) do {
		if dep.ircb'=5,dep.ircb'=6 quit
		do ALL^PROCLBB(dep.ircb,dep.ipf,dep.lbcp,dep.lbcm)
		}

	// Int Check Frequency is not supported for segmented accts
	if (dep.segflg=1)&(dep.intchkfre'="") do Runtime.setErrXBAD("DEP",209) quit:ER 

	/*
	   Maintain DAYEND entry for next interest posting date manually
	   This coding replaces the traditional filer index definitions for
	   next interest posting dates.
	*/
	if '(%ProcessMode=2),dep.inp'=dep.inp.oldVal do { quit:ER 
		new TJD	

		set TJD=dep.inp
		new X
		set X=dep.inp.oldVal

		if dep.segflg,dep.segacr do { quit:ER 
			// Segmented interest on principal, accruing/posting at
			// account level
			if dep.inp.oldVal'="" do Db.delete("DAYENDSEGIP","CID=:CID AND TJD=:X AND POSTING=2 AND SEG=-1")
			if dep.inp'="" do Db.insert("DAYENDSEGIP","TJD,CID,POSTING,SEG",":TJD,:CID,2,-1")
			}
		if 'dep.segflg do { quit:ER 
			// Regular interest
			if dep.inp.oldVal'="" do Db.delete("DAYENDINP","CID=:CID AND TJD=:X AND POSTING=0")
			if dep.inp'="",'Db.isDefined("DAYENDINP","TJD,CID,0") do Db.insert("DAYENDINP","TJD,CID,POSTING",":TJD,:CID,0")	// JMH - 02/26/01
			}
		}
	quit

vau37 // Trigger AU_INTMAT - After Update of Interest Matrix

	type public RecordDEP dep
	// trigger AU_INTMAT - Interest Matrix

	// Matrix must reference non segment data items when accruing at account level
	if dep.intmat'="" do { quit:ER 
		// Do not perform check if segmented account accruing at segment level
		if dep.segflg,'dep.segacr quit 
	
		new data,INTMAT,ROW,MATCOL
		set INTMAT=dep.intmat
	
		set data=Db.getOneRow("ROW,MATCOL","UTBLMATATT","INTMAT")
		set ROW=$P(data,$C(9),1)
		set MATCOL=$P(data,$C(9),2)
	
		new DEPITEM,ERFLAG,ITEM
		new rs 
		type ResultSet rs=Db.select("ITEM,DEP","STBLMATATT","DEP NOT LIKE 'DEPSEG%'")		
		set ERFLAG=1
		if 'rs.isEmpty() while rs.next() do { quit:'ERFLAG  
			set ITEM=rs.getCol(1)
			set DEPITEM=rs.getCol(2)
			// Checks if ROW or MATCOL have non segment data items
			if (ROW=ITEM)!(MATCOL=ITEM) set ERFLAG=0 quit 
			}
	
		if ERFLAG do Runtime.setErrMSG("DEP",3999) quit:ER 
		}
	
	quit

vau38 // Trigger AU_INTWCALC - After Update Int Withholding Calc Method

	type public RecordDEP dep
	//AU_INTWCALC

	/*

	------- Revision History --------------------------------------------
	12/08/05 - ALAGARSS - CR 18006
 		Modified the code to remove deprecated feature warnings.
 		Also removed old revision history.

	*/

	/*
	Accrued Withholding Tax Processing not valid with interest
	Withholding Calculation Method
	*/
	type public Boolean ER
	type public Number LINKCNT
	type public String IDATA,INTWCALC
	
	if dep.awtp,dep.intwcalc'="" do Runtime.setErrMSG("DEP",5072) quit:ER

	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 
		/*
		   This is a transaction (core) account set up for percentage based
		   investment sweep - make identical change on corresponding non-
		   institutional investment accounts.
		*/
		
	
		set INTWCALC=dep.intwcalc
		
		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:CID")
		if rs.isEmpty() quit				// No linked investment accounts
	
		while rs.next() do { quit:ER  			
			
			type RecordPRODDFTD proddftd=Db.getRecord("PRODDFTD","TYPE=:rs.getCol(""ITYPE"")")
			
			if proddftd.swpni do {
				type RecordDEP dep1=Db.getRecord("DEP","CID=:rs.getCol(""ICID"")")
				do dep1.setAuditFlag()	
				set dep1.intwcalc=INTWCALC
				do dep1.save()
			}
			}
		}
	quit

vau39 // Trigger AU_IOPT - After Update Interest Disb Option

	type public RecordDEP dep
	/*
	---- Revision History ------------------------------------------------
	
	06/27/00 - Terrie Dougherty - 40629
		   Moved TFRCID code to new DEP procedure. Modified calls to 
		   TFRCID to use new procedure TFRCID^PROCDEP.

	05/31/00 - MURRAY - 40250
		   Remove multi-currency exchange restriction.

	10/14/99 - CHOK - 31126
		   Converted to PSL.

	08/18/99 - SMITHC - 33996
		   Added additional restriction for segmented account with 
		   Transfer of Interest Adjustments (30444) processing.
	
	05/26/99 - SWEENEYT - 32933
		   Added check for invalid combination IAF=2 and IOPT=2.
	
	05/06/99 - SCOTTC - 30444
		   Modified to handle new interest disbursement options 5, 6
		   and 7.
	
	04/16/99 - HAYMANP - 30444
		   Added NEGBALOP check to IOPT verification.
	
	*/
	
	/*
		IOPT - Interest Disbursement Option (Verification)
		0)=Remain On Deposit
		1)=Pay By Check
		2)=Transfer to Another Account
		3)=Pay By Check (Consolidated)
		5)=Transfer Int Paid and Int Paid Adjmts
		6)=Transfer Int Charged and Charged Adjmts
		7)=Transfer All Int and All Int Adjmts
	*/

	new IOPT
	set IOPT=dep.iopt
	
	// Interest Disbursement/Transfer Account Error
	if (IOPT=2!(IOPT=5)!(IOPT=7)),dep.itrf="" do Runtime.setErrXBAD("DEP","IOPT") quit:ER 
	
	// Neg Acct Bal Opt cannot be 1, 2, or 3 with Neg Int Transfer
	if (dep.iopt=6!(dep.iopt=7)),dep.negbalop do Runtime.setErrXBAD("DEP","NABO") quit:ER 
	
	// Interest Disbursement/Transfer Account Error
	if IOPT=6,dep.negitrf="" do Runtime.setErrXBAD("DEP","IOPT") quit:ER 
	
	// Invalid field values ([DEP]IAF and [DEP]IOPT).
	if dep.iopt>0,dep.iaf=2 do Runtime.setErrMSG("DEP",8619) quit:ER 
	
	// Interest disbursement option ~p1 not supported for segmented accounts
	if dep.segflg,dep.iopt>4 do Runtime.setErrMSG("DEP",3990,dep.iopt) quit:ER 
	
	do TFRCID^PROCDEP(dep.itrf,.dep)
	do TFRCID^PROCDEP(dep.negitrf,.dep)
	quit

vau40 // Trigger AU_IRA - After Update IRA Flag Indicator

	type public RecordDEP dep
	/*
	   ---- Revision History -------------------------------------------------------
	
	   10/14/99 - CHOK - 31126
		      Converted to PSL.

	   05/27/99 - TITOVE - 32325
	              Logic added to allow updates to DEP.IRA if the Plan Type already
	              changed in IRATYPE and also to prevent changes to DEP.RPASEQ.
	
	   05/10/99 - TITOVE - 31637
	              Display appropriate error messages as part of De-link Retirement
	              Account processing.
	*/

	// Cannot add account to an IRA plan if not already an IRA
	if 'dep.ira.oldVal,dep.ira do Runtime.setErrMSG("DEP",8278) quit:ER 
	
	// Cannot set DEP.RPASEQ equal to 0 or null without setting DEP.IRA equal to 0
	if (dep.rpaseq.oldVal'=dep.rpaseq),'dep.rpaseq,'(dep.ira.oldVal'=dep.ira)!dep.ira do Runtime.setErrMSG("DEP",412,"DEP.RPASEQ") quit:ER 

	
	if dep.rpaseq do { quit:ER 
		// Change to column DEP.RPASEQ is not allowed
		if dep.rpaseq'=dep.rpaseq.oldVal do Runtime.setErrMSG("DEP",412,"DEP.RPASEQ") quit:ER 

		// Not a retirement account
		if 'dep.ira do Runtime.setErrMSG("DEP",2030) quit:ER 
		}
	
	// Account must remain in an IRA plan
	if 'dep.ira do { quit:ER 

		// Cannot de-link IRA account if not in a closed status
		if dep.stat'=4 do Runtime.setErrMSG("DEP",3865) quit:ER 

		// De-linking an IRA account may cause discrepancies in IRS reporting
		do Runtime.setErrXBAD("DEP","IRAREPDS") quit:ER 
		}
	
	// Cannot change DEP.IRA unless the Plan Type already changed in IRATYPE
	new MACN,MIRATYP,MRPASEQ
	set MACN=dep.acn
	if dep.ira,(dep.ira'=dep.ira.oldVal) do { quit:ER 
		set MRPASEQ=dep.rpaseq.oldVal
		if MRPASEQ do { quit:ER 
			set MIRATYP=Db.getOneRow("IRATYP","IRATYPE","MACN,MRPASEQ") quit:ER 
			// Change to column DEP.IRA is not allowed
			if MIRATYP,MIRATYP'=dep.ira do Runtime.setErrMSG("DEP",412,"DEP.IRA") quit:ER 
			}
		}	
	quit
	

vau41 // Trigger AU_IRCB - After Update Interest Rate Calc Base

	type public RecordDEP dep
	/*
	   ----------------------------------------------------------------------
	   Revision History

	   01/06/99 - HAYMANP - 35866
		      Retrofit of change below:

		      12/18/99 - SMITHC - 35866
		      Added code to handle new IRCB option 6 (Low Balance Based
		      on Collected Balance).
	
	   10/14/99 - CHOK - 31126
		      Converted to PSL.

	   02/03/99 - ROYTENBERGG - 28224
	              Added validation check for Nominal Interest Rate DEP.IRN
	*/
	
	// trigger AU_IRCB

	if dep.ircb=4 do { quit:ER 
		if dep.rencd'=5 do Runtime.setErrXBAD("DEP","RENCD11") quit:ER 
		if dep.ipf'="" do Runtime.setErrXBAD("DEP","IPF") quit:ER 
		if dep.iopt'="" do Runtime.setErrXBAD("DEP","IOPT") quit:ER 
		if dep.index'="" do Runtime.setErrXBAD("DEP","INDEX14") quit:ER 
		}
	
	if dep.irn="",dep.ircb>0 do Runtime.setErrXBAD("DEP","IRN") quit:ER 
	
	if (dep.ircb=5!(dep.ircb=6)),'Db.getOneRow("IPD","CUVAR") do Runtime.setErrXBAD("DEP","LBBIPD") quit:ER 
	
	if dep.segflg=1 do { quit:ER 
		// 206 Int Accr Flag must be 0 or 1 when accruing at segment level
		if dep.segacr=0,dep.ircb'=0,dep.ircb'=1 do Runtime.setErrXBAD("DEP",206) quit:ER 

		// Int Accr Flag must be 0, 1, or 3 when accruing at the acct level
		if dep.segacr=1,dep.ircb'=0,dep.ircb'=1,dep.ircb'=3 do Runtime.setErrXBAD("DEP",207) quit:ER 
		}
	quit	

vau42 // Trigger AU_IRN - After Update IRN, process accrual

	type public RecordDEP dep
	/*
	   ---- Revision History ----------------------------------------------

	   11/15/02 - Erik Scheetz - 43583
		      Wrapped %EffectiveDate with $G[et] where needed
		      due to compile changes in this version.

	   11/07/01 - ANTONOVV - 47535
		      Modified error handling after EFDIRN^DEPIRN call to 
		      display overridable message and log error to the dayend 
		      exception log.  

	   10/24/00 - SMITHC - 42068:1
		      Incorporated parts of BU_IRN into this trigger.

	   05/19/00 - LUS - 37758
																						Retrofitted change below:
																						03/10/00 - LUS - 37084
																						Added code to validate IRN against Minimun and Maximum
																						Rates.
									 
	   10/14/99 - CHOK - 31126
		      Converted to PSL.

	   02/16/99 - HAYMANP - 31263
	              Added OLD.IRN as fourth parameter in call to 
		      EFDIRN^DEPIRN.
	
	   02/03/99 - ROYTENBERGG - 28224
	              Added validation check for Nominal Interest Rate DEP.IRN
	*/
	
	// Validate IRN against the Min and Max Rates
	// Too low
								if dep.intmn'="",dep.irn<dep.intmn do Runtime.setErrXBAD("DEP","INVINTRTL") quit:ER
	// Too high
								if dep.intmx'="",dep.irn>dep.intmx do Runtime.setErrXBAD("DEP","INVINTRTH") quit:ER   

	if $G(%EffectiveDate),%EffectiveDate<%SystemDate do { quit:ER 
		new %A,A,CID,DEP

		// Cannot effective-date prior to opening date
		if dep.odt>%EffectiveDate do Runtime.setErrMSG("DEP",450) if ER quit 
	
		// Cannot effective-date prior to date last renewed
		if dep.dlr>%EffectiveDate do Runtime.setErrMSG("DEP",449) if ER quit 
	
		if %EffectiveDate'>dep.hisctf do { quit:ER 
			new x
			set x=$$DAT^%ZM(dep.hisctf)

			// Must be after the history purge date of ~p1
			do Runtime.setErrMSG("DEP",1801,x) if ER quit
			}

		do EFDIRN^DEPIRN(dep.cid,.dep,,dep.irn.oldVal)

		/*
		   Allow a accrual adjustment error to occur.  The messages 
		   displayed will tell the user about the problem. A manual 
		   adjustment will be required.
		*/
		if ER,$D(RM)>1 do { quit:ER
			new CID,DESCR
			set CID=dep.cid
			set DESCR=$G(RM(1))_" "_$G(RM(2))
			// "Accrual adjustment error|||0"
			do Runtime.setErrXBAD("DEP","ACRER")
			do LOG^UTLEXC($T(+0),"*",RM,CID,$G(%ZTSEQ),DESCR)
			}
		}
	
	if dep.irn="",dep.ircb>0 do Runtime.setErrXBAD("DEP","IRN") quit:ER 
	
	// Minimum Rate Differential Check
	if dep.pldg do { quit:ER 
		new DCID,LIRN,LCID,LMINR,XMSG
		set DCID=dep.cid
		new rs 
		type ResultSet rs=Db.select("CID","LNCOL","LNCOL.PLDGACN=:DCID")
		if rs.isEmpty() quit
		while rs.next() do { 
			set LCID=rs.getCol(1)
			set LNARY=Db.getOneRow("INDEX,IRN,MINRATE","LN","LCID")
			if $P(LNARY,$C(9),1)'="" quit 
			set LIRN=$P(LNARY,$C(9),2)
			set LMINR=$P(LNARY,$C(9),3)
			quit:'LMINR 
			if LIRN'<(dep.irn+LMINR) quit 
			set LIRN=dep.irn+LMINR
			do Db.update("LN","IRN=:LIRN","CID=:LCID") quit:ER 

			/* Loan Rate adjusted due to Minimum Rate Differential 
			   requirement */
			set XMSG=$$^MSG(2979)
			do Db.insert("DAYENDEXC","TJD,RTN,SORT,SEQ,RECID,ET,TIME,ROU","%SystemDate,%RoutineName,'*',DAYENDEXC.NEXTVAL,:LCID,:XMSG,%CurrentTime,%RoutineName") quit:ER 
			}
		}
	quit

vau43 // Trigger AU_LNM - After Update Report Short Name

	type public RecordDEP dep
	/*
	   ---------- Revision History ------------------------------------------

	   10/14/99 - CHOK - 31126
		      Converted to PSL.
	*/

	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 
		/*
		   This is a transaction (core) account set up for percentage based
		   investment sweep - make identical change on corresponding non-
		   institutional investment accounts.
		*/
		new ICID,ITYPE,LNM,SWPNI
	
		set LNM=dep.lnm
		new rs 
		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:CID")
		if rs.isEmpty() quit				// No linked investment accounts
	
		while rs.next() do { quit:ER  
			set ICID=rs.getCol(1)			// Investment Account Number
			set ITYPE=rs.getCol(2)			// Investment Product Type
			set SWPNI=Db.getOneRow("SWPNI","PRODDFTD","ITYPE")
			if SWPNI do Db.update("DEP","LNM=:LNM","CID=:ICID")
			}
		}
	quit

vau44 // Trigger AU_MDT_TRM - After Update Maturity Date or Term

	type public RecordDEP dep
	/*
	   ------------REVISION HISTORY------------------------------------------------
	
	   10/14/99 - CHOK - 31126	
		      Converted to PSL.

	   03/24/99 - MOHAMEDE - 31429
	              A restriction will occur if the maturity date or the override
	              maturity date change during collateral update and if colateral
	              matuures before loan account or the loan maturity date is equal
	              to that of the deposit account and if the action at renewal is
	              not set for option 3( automatic renew).
	
	   12/15/98 - JERUCHIMC - 28593
	              Check 'DEP.SEGFLG before checking DEP.MDT
	*/

	// MDT - Account Maturity Date Verification
	if dep.trm="",dep.mdt do Runtime.setErrXBAD("DEP","MDT1") quit:ER 
	if dep.trm'="" do { quit:ER 
	
		if 'dep.segflg,'dep.mdt do Runtime.setErrXBAD("DEP","MDT1") quit:ER 
		if 'dep.segflg,dep.mdt<%SystemDate do Runtime.setErrXBAD("DEP","MDT") quit:ER 
	
		// TRM - Deposit Term Verification
		// First character of term may not be '0'
		if $E(dep.trm)=0 do Runtime.setErrMSG("DEP",1113) quit:ER 

		// First character of term must be numeric
		if +dep.trm=0 do Runtime.setErrMSG("DEP",1114) quit:ER 

		// Term must contain character D, W, M, or Y
		if dep.trm=+dep.trm do Runtime.setErrMSG("DEP",2629) quit:ER 

		// Lowercase characters not allowed
		if dep.trm?.E1L.E do Runtime.setErrMSG("DEP",1662) quit:ER 

		// Term may only contain characters D, W, M, or Y
		for I=1:1:$L(dep.trm) if '("DWMY"[$E(dep.trm,I)!($E(dep.trm,I)?1N)) do Runtime.setErrMSG("DEP",2628) quit:ER 
	
		}
	/*
	   If maturity date of the deposit pledged account is the earliest
	   maturity date of all the pledged accounts securing the loan of which
	   this deposit account is securing, the update the deposit secured loan
	   with the matuirty date of the deposit pledged accout.
	*/
	if 'dep.segflg,dep.mdt,dep.pldg do { quit:ER 
		new DMDT,LMDT,LCID,OMDT,RECND
		set DMDT=dep.mdt
		new rs 
		type ResultSet rs=Db.select("MDT,CID,COLL","LNCOL,ACN","LNCOL.PLDGACN=:CID AND ACN.CID=LNCOL.CID")
		if rs.isEmpty() quit
		while rs.next() do { quit:ER  
			set LMDT=rs.getCol(1) quit:'LMDT 
			set LCID=rs.getCol(2)
			set COLL=rs.getCol(3)
			set OMDT=Db.getOneRow("OMDT","COL","COLL")
			set DMDT=$$PLDGMDT^LNCDI(LCID)
			if LMDT,'OMDT,DMDT'=LMDT do Db.update("LN","MDT=:DMDT","CID=:LCID") quit:ER 
			/*
			   If Override Maturity date flag so that the deposit maturity date ;ME
			   does not default to the loan maturity date, display override if the
			   pledged account's maturity date is less than the loan maturity date
			   if the pledged deposit maturity code is not set to automatically
			   renew.
			*/
			if OMDT,RENCD'=3,DMDT<LMDT do Runtime.setErrXBAD("DEP","CMBLTE") quit:ER
			}
		}
	quit

vau45 // Trigger AU_MINDR - After Update Minimum Debit Amount

	type public RecordDEP dep
	/*
	   MINDR - Minimum Debit Amount Verification
	   Overdraft Source Minimum Transfer Amount must be equal to or greater
	   than the Minimum Debit Amount.

	   ---------- Revision History ------------------------------------------

	   09/23/05 - NATRAJAH - 17245
		      General DBI3 cleanup.
	*/
	
	if dep.mindr do { quit:ER 
		type Number ODSMTR,TYPE
		set TYPE=dep.type
		type ResultSet rs=Db.select("ODSMTR","PRODCTL","TYPE=:TYPE")
		set ODSMTR=rs.getCol("ODSMTR")
		if ODSMTR,ODSMTR<dep.mindr do Runtime.setErrXBAD("DEP","ODSMTR") quit:ER 
		}
	quit
	

vau46 // Trigger AU_MT900THR - After Update MT900 Debit Threshold Trgr

	type public RecordDEP dep
	// Check to ensure that MT900 Debit Threshold is defined if Generate MT900='Y'
	
	if dep.mt900=1 do {
 	if dep.mt900thr="" do {
		new cif900thr,XACN
		set XACN=dep.acn
		set cif900thr=Db.getOneRow("MT900THR","CIF","XACN")
		if cif900thr="" do Runtime.setErrMSG("DEP",4077) quit:ER
	}
	}
	quit

vau47 // Trigger AU_MT910THR - After Update MT910 Credit Threshold Trgr

	type public RecordDEP dep
	// Check to ensure that MT900 Debit Threshold is defined if Generate MT900='Y'
	
	if dep.mt910=1 do {
								if dep.mt910thr="" do {
																new cif910thr,XACN
																set XACN=dep.acn
																set cif910thr=Db.getOneRow("MT910THR","CIF","XACN")
																if cif910thr="" do Runtime.setErrMSG("DEP",4078) quit:ER
								}
	}
	quit

vau48 // Trigger AU_NEGACRPO - After Update Negative Accrued Proc Opt

	type public RecordDEP dep
	// trigger AU_NEGACRPO
	/*
											---------- Revision History-----------------------------------------

	   08/17/00 - HALPINJ - 41378
		      Added an integrity check so that a user can not changed 
		      NEGACRPOto 1 when any of the accrual fields (POSACR, 
		      NEGACR & NEGACRUN) have a value less than 0.

											1/05/2000 - Anna Maltepes 35820
																						Added an integrety error "Neg Int Posting Option cannot
																						be 2 if Neg Accrual Option is 0"
	*/

	// Negative accrued value with net accrued processing
	if dep.negacrpo=0,dep.negacr>0 do Runtime.setErrXBAD("DEP","NEGACRPO") quit:ER 

	// 219 Positive and negative int must accrue net for segmented acct
	if dep.segflg=1,dep.negacrpo'=0 do Runtime.setErrXBAD("DEP",219) quit:ER 
	
	//Neg Int Posting Option cannot be 2 if Neg Accrual Option is 0
	if dep.negipo=2,'dep.negacrpo do Runtime.setErrMSG("DEP",249) quit:ER	

 	if dep.negacrpo=1 do {				// JMH - 08/17/00
		// Posting options does not allow negative amount to post.
		if dep.posacr<0 do Runtime.setErrMSG("DEP",7499) quit:ER
		// Posting option does not allow negative amount to post for neg. accrual
		if (dep.negacr<0)!(dep.negacrun<0)!(dep.uncacr<0) do Runtime.setErrMSG("DEP",7500) quit:ER
		}

	quit 
	

vau49 // Trigger AU_NEGBALOP - Negative Account Balance

	type public RecordDEP dep
	/*
	   ------ Revision History------------------------------------------------------
	
	   10/14/99 - CHOK - 31126
		      Converted to PSL.

	   04/16/99 - HAYMANP - 30444
	              Added IOPT/NEGBALOP check.
	
	*/
	
	// Neg Acct Bal Opt cannot be 1, 2, or 3 with Neg Int Transfer
	if (dep.iopt=6!(dep.iopt=7)),dep.negbalop do Runtime.setErrXBAD("DEP","NABO") quit:ER 
	
	// Residual Int Processing is not supported for segmented accts
	if dep.segflg=1,dep.negbalop=2 do Runtime.setErrXBAD("DEP",222) quit:ER 
	
	quit

vau50 // Trigger AU_NEGINP - After Update Negative Int Next Post Date

	type public RecordDEP dep
	
	/*
	   ---------- Revision History ------------------------------------------

	   05/03/02 - KELLYP - 49129
		      Removed previous change under this ARQ.  ACNDSD
		      functionality is now required in V6.4 up.

	   04/08/02 - KELLYP - 49129
		      Added code to check if NEGINP or NEGIPF has been file
		      maintained.  If so, and if no ACNDSD record exists where
		      FRECOL="NEGIPF" and SCHDT=0, then XBAD message CNVIDT3
		      or CNVIDT4 will be returned.

	   02/26/01 - HALPINJ - 43406
		      Added code to check to make sure DAYENDINP does not exist
		      before trying to do the SQL insert.
	
	   12/27/99 - OYEGUNZ - 36038
		      Return error if NEGIPO'=2 and ODLIM'=""	

	   10/14/99 - CHOK - 31126
		      Converted to PSL.

	   06/10/99 - SMITHC - 32048
		      Maintain DAYEND entry of next interest posting dates
		      (negative) manually.  This coding replaces the traditional
		      filer index definitions for next interest posting dates.
	
	*/
	
	if dep.negipf'="" do { quit:ER 
		// Next Neg Int post date missing or prior to sys date
		if dep.neginp="",('dep.segflg!(dep.segacr)) do Runtime.setErrXBAD("DEP","NEGINP") quit:ER 

		// Next Neg Int post date missing or prior to sys date
		if dep.stat'=4,dep.neginp<%SystemDate do Runtime.setErrXBAD("DEP","NEGINP") quit:ER 

		// Negative interest posting frequency not allowed
		if dep.negipo'=2 do Runtime.setErrXBAD("DEP","NEGIPFNAL") quit:ER 
		}

	// Neg interest posting frequency missing
	else  if dep.negipo=2 do Runtime.setErrXBAD("DEP","NEGIPFREQ") quit:ER 
	
	//Overdraft limit and Negative Interest Posting Option         ;36038
 	//With O/D limit, post +ve and -ve int/div interest accruals seperately
	if (dep.negipo'=2)&(dep.odlim'="") do Runtime.setErrMSG("DEP",4178) quit:ER

	/*
	   Maintain DAYEND entry for next negative interest posting date
	   manually.  This coding replaces the traditional filer index
	   definitions for next negative interest posting dates.
	*/
	if '(%ProcessMode=2),dep.neginp'=dep.neginp.oldVal do { quit:ER 
		new X

		set X=dep.neginp.oldVal
		if dep.neginp.oldVal'="" do Db.delete("DAYENDINP","CID=:CID AND TJD=:X AND POSTING=1")
		if dep.neginp'="" do {
			new TJD
			set TJD=dep.neginp
		        if Db.isDefined("DAYENDINP","TJD,CID,1") quit	// JMH - 02/26/01
			do Db.insert("DAYENDINP","TJD,CID,POSTING",":TJD,:CID,1")
			}
		}
	quit 

vau51 // Trigger AU_NIAO_UFINDEX - After update NIAO and/or UFINDEX

	type public RecordDEP dep
	/*
	------ Revision History ------------------------------------------------
	03/22/00 - ANTONOVV - 35503
		Added check on NIAO and UFINDEX. Neg Int Application Option
		has to have a value if Uncoll Funds Int Index has. And vice 
		versa.
	------------------------------------------------------------------------
								*/
	
								// NIAO (Neg Int Appl Opt) has to have value if UFINDEX (Uncoll Funds Int Index) does. And vise versa.
								if dep.niao'="",dep.ufindex="" do Runtime.setErrMSG("DEP",4257)
								if dep.niao="",dep.ufindex'="" do Runtime.setErrMSG("DEP",4258)
	
								quit

vau52 // Trigger AU_NOTICE - After Update Notice Information

	type public RecordDEP dep
	// Notice Account Flag
	quit:'dep.notice 

	// Notice Account Flag
	if dep.notice,'dep.notmax do Runtime.setErrMSG("DEP",1685) quit:ER 
	if dep.notice,'dep.notmin do Runtime.setErrMSG("DEP",1738) quit:ER 
	quit
	

vau53 // Trigger AU_NR - After Update Nonresident Indicator

	type public RecordDEP dep
	/*
	   ---------- Revision History ------------------------------------------
	   12/08/05 - ALAGARSS - CR 18006
 		      Modified the code to remove deprecated feature warnings.
 		      Also removed the old revision history.
	
	*/
	
	type public Boolean ER
	type public Number LINKCNT,NR
	type public String IDATA
		
	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 
		/*
		   This is a transaction (core) account set up for percentage based
		   investment sweep - make identical change on corresponding non-
		   institutional investment accounts.
		*/
	
		set NR=dep.nr
		
		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:CID")
		// No linked investment accounts
		if rs.isEmpty() quit				
	
		while rs.next() do { quit:ER  
			
			type RecordPRODDFTD proddftd=Db.getRecord("PRODDFTD","TYPE=:rs.getCol(""ITYPE"")")
			if proddftd.swpni do {
				type RecordDEP dep1=Db.getRecord("DEP","CID=:rs.getCol(""ICID"")")
				do dep1.setAuditFlag()
				set dep1.nr=NR
				do dep1.save()
			}
			}
		}
	quit

vau54 // Trigger AU_PERS - After Update Personal/Non-Personal Code

	type public RecordDEP dep
	/*
 	   ------------------------------------ Revision History ------------------------------------------
 	   12/08/05 - ALAGARSS - CR 18006
 		      Modified the code to remove deprecated feature warnings.
 		   
	   10/14/99 - CHOK - 31126
		      Converted to PSL.
	*/
	type public Boolean ER
	type public Number PERS
	
	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 

	/*
	  This is a transaction (core) account set up for percentage based
	  investment sweep - make identical change on corresponding non-
	  institutional investment accounts.
	*/
	
		
		set PERS=dep.pers
		
		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:CID")            // No linked investment accounts
		if rs.isEmpty() quit
		while rs.next() do {  quit:ER 
			
			
			type RecordPRODDFTD proddftd=Db.getRecord("PRODDFTD","TYPE=:rs.getCol(""ITYPE"")")
			
			if proddftd.swpni do {
				type RecordDEP dep1=Db.getRecord("DEP","CID=:rs.getCol(""ICID"")")
				do dep1.setAuditFlag()
				set dep1.pers=PERS
				do dep1.save()
			}
			}
		}
	quit 

vau55 // Trigger AU_PLEDGE - After Update Pledge

	type public RecordDEP dep
	/*
	  --------------------- Revision History ------------------------------------------------
	   03/11/99 - FINCHG - 27393
		If RENCD is 6, return an error message if we try to make
		this a non-pledged account.
	
	*/
	
	if 'dep.pldg,dep.rencd=6 do Runtime.setErrMSG("DEP",3847) if ER quit 
	
	quit 
	

vau56 // Trigger AU_POPT - After Update of Penalty Calc Method 

	type public RecordDEP dep
	/*
	  ------------------------- Revision History -------------------------------------------------------
	   05/29/01 - ITIGIB - 44340 - Withdrawal from Segmented Savings
																Modified trigger to display an error message when
																Withdrawal Priority (DEP.WDPRIO) Option 2 (Least Penalty)
																is not used in conjunction with Segment Penalty Calculation
																(DEP.SEGPOPT) Method 3 (Accrued interest on withdrawal amount
																since last segment interest interest posting date) and also
																vise versa.

	   11/17/98 - MAGERAM - 28591 - Segmented Account Creation
		Modified to replace DEP.SEGFLG=0 with 'DEP.SEGFLG

	*/
	
	// Penalty Method must be null for segmented accounts
	if dep.segflg=1,dep.popt'="" do Runtime.setErrXBAD("DEP",218) quit:ER
	
	// Segment Penalty Method may only be used for segmented accts
	if 'dep.segflg,dep.segpopt'="" do Runtime.setErrXBAD("DEP",228) quit:ER

	// Withdrawal Priority Option 2 must be used with Segment Penalty Calculation Method 3
	if dep.segpopt=3,dep.wdprio'=2 do Runtime.setErrMSG("DEP",4953) quit:ER
 	if dep.wdprio=2,dep.segpopt'=3 do Runtime.setErrMSG("DEP",4953) quit:ER

	quit

vau57 // Trigger AU_RENCD - After Update Renewal Code

	type public RecordDEP dep
	
	/*
	  ------------------------- Revision History ------------------------------------------------
	08/06/01 - MAYLATHR - 45171
		Replaced dep.extacn with dep.primatetc where principal maturity
		option is 4.
	
	09/01/99 - MAGERAM - 32998
		Removed restriction 'Int Maturity Opt can only be defined
		if Aval Int Opt is 2'.
	
	07/20/99 - MURRAY - 34103
		Modified to remove the check on whether the Maturity transfer
		account (dep.racn) is of a different currency.
	
	06/15/99 - MAGERAM - 31056
		Added a check for Interest Maturity Option=5.
	
	06/03/99 - DADAP - 32913
		Added a check for Interest Maturity Option=2.
	
	03/11/99 - FINCHG - 27393
		If RENCD is changed to 6, and this is not a pledged account,  return an error.
	
	*/
	
	// RENCD - Renewal Code Verification
	if dep.rencd=6,'dep.pldg do Runtime.setErrMSG("DEP",3847) if ER quit     // FINCHG 3/11/99
	if dep.rencd=2,dep.racn="" do Runtime.setErrXBAD("DEP","RENCD") quit:ER 
	if dep.racn'="" do { quit:ER 
		new values,XCID
		if dep.rencd'=2 do Runtime.setErrXBAD("DEP","RENCD") quit:ER 
		if 'Db.isDefined("DEP","dep.racn") do Runtime.setErrXBAD("DEP",530) quit:ER 
		if dep.racn=dep.cid do Runtime.setErrMSG("DEP",813) if ER quit 
		set XCID=dep.racn
		set values=Db.getOneRow("STAT,CLS,CRCD","DEP","XCID") quit:ER
	
		// Error if rollover account is closed or not a deposit account.
		if $P(values,$C(9),1)=4 do Runtime.setErrMSG("DEP",834,dep.racn) quit:ER 
		if $P(values,$C(9),2)'="D" do Runtime.setErrMSG("DEP",833) quit:ER 
		}

	// IMO - Interest Maturity Option
	if dep.imo=2,dep.intmatita="" do Runtime.setErrXBAD("DEP","RENCD") quit:ER 
	if dep.intmatita'="" do { quit:ER 
		new values,XCID
		if dep.imo'=2 do Runtime.setErrXBAD("DEP","RENCD") quit:ER 
		if 'Db.isDefined("DEP","dep.intmatita") do Runtime.setErrXBAD("DEP",531) quit:ER 
		if dep.intmatita=dep.cid do Runtime.setErrMSG("DEP",813) if ER quit 
		set XCID=dep.intmatita
		set values=Db.getOneRow("STAT,CLS,CRCD","DEP","XCID") quit:ER 
		}
	
	// Partial Renewal Amt must be null if Prin Mat Opt equals 0, 3, or 5
	if ((dep.rencd=0)!(dep.rencd=3)!(dep.rencd=5))&(dep.prena'="") do Runtime.setErrXBAD("DEP",216) quit:ER
	
	// For Int Maturity Option 5, Renewal Code must be 1, 2, or 4
	if ((dep.rencd=0)!(dep.rencd=3)!(dep.rencd=5))&(dep.imo=5) do Runtime.setErrMSG("DEP",3910) if ER quit
	
	// External Tfr Cust ID is required if  Prin Mat Opt is 4
	if (dep.rencd=4)&(dep.primatetc="") do Runtime.setErrXBAD("DEP",201) quit:ER
	
	// Rate Renewal Option cannot be 3 for segmented accounts
	if (dep.segflg=1)&(dep.rro=3) do Runtime.setErrXBAD("DEP",221) quit:ER 
	
	/*
	Error if Renewal Code(RENCD) is not equal to 3 when Reset Interest
	Available on Renewal Flag(INTAVLR) is other than Zero.
	*/

								if dep.intavlr,dep.rencd'=3 do Runtime.setErrMSG("DEP",4299) quit:ER
	
								quit
	

vau58 // Trigger AU_RSINTSPR_RSRNDMT - After Update RSINTSPR or RSRNDMTD

	type public RecordDEP dep
	/*  Revision History
		08/29/00 - LUS - ARQ41547
		Retrofitted change below:
								ORIG:LUS - ARQ38013 08/15/00
									Rate Schedule Int/Div Spread and Rounding Method Verification
	*/
	
	if dep.sch'="" do { quit:ER
								new X
								// INDEX2 - Invalid  offset syntax
								set X=dep.rsintspr
								do SPRPP^UINDX if ER do Runtime.setErrSTBLER("DEP",ET) quit:ER
								// INDEX3 - Invalid rounding instruction
								set X=dep.rsrndmtd
								do RNDPP^UINDX if ER do Runtime.setErrSTBLER("DEP",ET) quit:ER
								}
	quit

vau59 // Trigger AU_SCFRE - After Update Service Charge Frequency

	type public RecordDEP dep
	/*
	---- Revision History ------------------------------------------------
	08/26/05 - RussellDS - CR16911
 	    Eliminate PSL deprecated features
	----------------------------------------------------------------------
	*/

	if dep.feepln'="",dep.scfre="" do Runtime.setErrXBAD("DEP","SCFRE") quit:ER 

	new data,data1,LEADSCFRE,NEWSCFRE,NEXTDT,SPREAD,SUBCID,SUBSCFRE
	
	//verify that the value for offset days is not greater than the
	//intervals
	 
	if dep.anloffdy do {
	set NEXTDT=$$NJD^UFRE(dep.scnd,dep.scfre,.AF) quit:ER
	set SPREAD=NEXTDT-dep.scnd
	if SPREAD<dep.anloffdy do Runtime.setErrXBAD("DEP","ANLOFF") quit:ER
	}

								//If analysis is 1, check if there are sub accounts.

	if dep.anltyp=1 do { quit:ER
								set XCID=dep.cid,ANLCID=dep.cid,NEWSCFRE=dep.scfre
								type ResultSet rs=Db.select("SCFRE,CID","DEP","ANLCID=:XCID")
								while rs.next() do {
          	set data=rs.getRow()
          	set SUBSCFRE=$P(data,$C(9),1)
          	set SUBCID=$P(data,$C(9),2)
	
	        //If SCFRE of sub account is not same as lead, change sub acct.
	        
	        if SUBSCFRE'=NEWSCFRE do {
  		
  			type RecordDEP subdep = Db.getRecord("DEP", "CID=:SUBCID")
  			
  			set subdep.scfre = NEWSCFRE
  			
  			do subdep.save()
        	}
	}
	}
	
								//if changing SCFRE on sub account (Acct. analysis) check that sub's
								//SCFRE = the lead account
	
	if (dep.anltyp=2)!(dep.anltyp=3) do { quit:ER
 	set LEADCID=dep.anlcid
	set tmp=Db.isDefined("DEP","LEADCID")
	if 'tmp do Runtime.setErrXBAD("DEP","ANLVAL") quit:ER
	
								type RecordDEP lead = Db.getRecord("DEP", "CID=:LEADCID", 1)
							 
								//"Acct service fee frequency must equal lead acct frequency"
 	if (lead.scfre '= dep.scfre) do Runtime.setErrXBAD("DEP","ANLFEE") quit:ER
	}
	
	quit
	

vau60 // Trigger AU_SCND - After Update Service Charge Next Date

	type public RecordDEP dep

	/*
	---- Revision History ------------------------------------------------
	08/26/05 - RussellDS - CR16911
 	    Eliminate PSL deprecated features
	----------------------------------------------------------------------
	*/
	
	if dep.scnd="",dep.feepln'="" do Runtime.setErrXBAD("DEP","SCND2") quit:ER 
	else  if dep.scnd<%SystemDate,dep.scfre'="" do Runtime.setErrXBAD("DEP","SCND") quit:ER 
	new data,data1,LEADSCND,NEWSCND,SUBSCND
	
	//If analysis is 1, check if there are sub accounts.

	if dep.anltyp=1 do { quit:ER
	set ANLCID=dep.cid,NEWSCND=dep.scnd
	set XCID=dep.cid
	type ResultSet rs=Db.select("SCND,CID","DEP","ANLCID=:XCID")
								if 'rs.isEmpty() while rs.next() do {
		set data=rs.getRow()
	  	set SUBSCND=$P(data,$C(9),1)
	  	set SUBCID=$P(data,$C(9),2)

		  //If SCND of sub account is not same as lead, change sub acct.
		if SUBSCND'=NEWSCND do {
  		
  			type RecordDEP subdep = Db.getRecord("DEP", "CID=:SUBCID")
  			
  			set subdep.scnd = NEWSCND
  			
  			do subdep.save()
        	}
	}
	}

	//if changing SCND on sub account (Acct. analysis) check that sub's
	//SCND = the lead account.  If the change is coming from Service Fee
	//processing, quit out of this check.

	if (dep.anltyp=2)!(dep.anltyp=3) do { quit:ER
 	if dep.isChanged("SCND","SYSTEM") quit // SyStem changes allowed
 	new LEADCID
 	set LEADCID=dep.anlcid
 	set tmp=Db.isDefined("DEP","LEADCID")
 	if 'tmp do Runtime.setErrXBAD("DEP","ANLVAL") quit:ER
 	
 	type RecordDEP lead = Db.getRecord("DEP", "CID=:LEADCID", 1)
 	
	//"Accts next svc fee date must equal lead acct svc fee date"
	if (lead.scnd '= dep.scnd) do Runtime.setErrXBAD("DEP","ANLSVF") quit:ER
	}
	quit

vau61 // Trigger AU_SEGPER - Update Segment Period

	type public RecordDEP dep
	
	new SEGMENT
	
	new rs
	type ResultSet rs=Db.select("SEGMENT","DEPSEG","CID=:CID") 
	if 'rs.isEmpty() set SEGMENT=rs.next(),SEGMENT=rs.getRow()

	// Segment Period must contain a valid term
	if (dep.segper'="")&(SEGMENT'=0) do { quit:ER
	
		// First character of period may not be '0'
		if $E(dep.segper)=0 do Runtime.setErrXBAD("DEP",229) quit:ER
	
		// First character of period must be numeric
		if +dep.segper=0 do Runtime.setErrXBAD("DEP",229) quit:ER
	
		// Period must contain character D, W, M, or Y
		if dep.segper=+dep.segper do Runtime.setErrXBAD("DEP",229) quit:ER
	
		// Lowercase characters not allowed
		if dep.segper?.E1L.E do Runtime.setErrXBAD("DEP",229) quit:ER
 	
		for I=1:1:$L(dep.segper) if '("DWMY"[$E(dep.segper,I)!($E(dep.segper,I)?1N)) set ER=1 quit
	
		// Period may only contain characters D, W, M, or Y
		if ER do Runtime.setErrXBAD("DEP",229) quit:ER 
		}
	
	quit
	

vau62 // Trigger AU_SFRE - Maintain SFRE on account

	type public RecordDEP dep
	/*
	  ---------------------------- Revision History--------------------------------------------------------
	04/25/01 - SCOTTC - 44515
	      Modified order of update when frequency is changed on account.
	      Insert to CMBGRP is now being done first so that when the check
	      to see if frequency on account needs to be updated in CMBCID (it
	      gets the frequency from CMBGRP) it will quit out and not try to
	      update it.  Updating CMBSTM before CMBGRP was causing the system
	      to loop back into DEPFILE countless times with ambiguous results.
	      Removed delete of CMBCID as it was pointless.
	      *Added the call to UFRE to calculate the statement next date when
	      the statement frequency is modified on the account.  This
	      deviates from standard Profile practices due to the fact that
	      when default statement frequencies are being used, and a freq
	      changes and forces the creation of a new statement group, the
	      statement next date will change. Same action by the user,
	      different results.

	   08/21/00 - LAMY - 41370
		Added a check to make sure that sfre is not null if not smet.

	   09/23/99 - SCOTTC 34881
		Changed SQLSELECT statement to see if more than one account in
		statement group to search in CMBSTM instead of CMBCID
	*/
	
	if dep.smet&dep.sfre="" do Runtime.setErrMSG("DEP",2537) if ER quit 
	if 'dep.smet,dep.sfre="" quit 
	new CSTMGRP,FNDGRP,XACN,XDESC,XSFRE,XADDR,XREST,XSFRE
	set XCID=dep.cid 
	set XACN=dep.acn
	
	// find existing statement group
	set CSTMGRP=Db.getOneRow("STMGRP","CMBCID","XCID,XACN")
	if CSTMGRP="" quit

	// find out if more than one account in statement group
	
	new rs 
	type ResultSet rs=Db.select("ACN","CMBSTM","STMGRP=:CSTMGRP AND ACN=:XACN AND CID<>:XCID") 
	if rs.isEmpty() set FNDGRP=""
	else  set FNDGRP=rs.next(),FNDGRP=rs.getCol(1)

	// get information to pass to a new group
	if FNDGRP do {
		set XCMBGRP=Db.getOneRow("DESC,ADDR,REST,SFRE","CMBGRP","XACN,CSTMGRP")
		set XDESC=$P(XCMBGRP,$C(9),1) 
		set XADDR=$P(XCMBGRP,$C(9),2) 
		set XREST=$P(XCMBGRP,$C(9),3) 
		set XSFRE=$P(XCMBGRP,$C(9),4)
		if XSFRE'=dep.sfre do { quit:ER
	
			// find last statement group for CID
			new rs 
	    		type ResultSet rs=Db.select("STMGRP","CMBGRP","ACN=:XACN","STMGRP DESC") 
	    		if rs.isEmpty() set RETVAL=""
			else  set RETVAL=rs.next(),RETVAL=rs.getCol(1)
			// set new statement group number
			set NEWGRP=RETVAL+1
			set XSFRE=dep.sfre
			if XADDR="" set XADDR=XCID
			do Db.insert("CMBGRP","ACN,STMGRP,ADDR,SFRE",":XACN,:NEWGRP,:XADDR,:XSFRE")
			do Db.update("CMBSTM","STMGRP=:NEWGRP","ACN=:XACN AND CID=:XCID AND STMGRP=:CSTMGRP")
			}
		}

	if 'FNDGRP do {
		//Modify statement group's frequency
		new NJD
		set XSFRE=dep.sfre 
		set XACN=dep.acn
		set NJD=$$NJD^UFRE(%SystemDate,XSFRE,.AF)
		do Db.update("CMBGRP","SFRE=:XSFRE,SNDT=:NJD","STMGRP=:CSTMGRP AND ACN=:XACN")
		}
	quit 
	

vau63 // Trigger AU_SGNCRD - Signature Card Letter Processing

	type public RecordDEP dep
	/*
	
	 05/18/05 - KELLYP - CR 15268
		Re-introduced this trigger since the XSGNCRD table cannot be
		populated by an index in DBI.  XSGNCRD is now handled as a 
		"calculated" table and its records are created/modified by
		the filers.
	*/


	// Remove any records from XSGNCRD with old signature card values
	do Db.delete("XSGNCRD","CID=:dep.cid")
	
	// If SGNCRD>0 AND PSGNCRDR'=1 track this account in XSGNCRD
	if dep.sgncrd>0,dep.psgncrdr'=1 do {
		type RecordXSGNCRD xsgncrd=Class.new("RecordXSGNCRD")
		set xsgncrd.sjd=%SystemDate
		set xsgncrd.sgncrd=dep.sgncrd
		set xsgncrd.osgncrdc=+dep.osgncrdc
		set xsgncrd.psgncrdr=+dep.psgncrdr
		set xsgncrd.cid=dep.cid
		do xsgncrd.bypassSave()
		}	

	quit

vau64 // Trigger AU_SMET - After Update statement flag

	type public RecordDEP dep
	if dep.smet=0 do {
		new XACN,XCID,XSTMGRP
		set XCID=dep.cid
	
		new rs 
	    	type ResultSet rs=Db.select("STMGRP","CMBCID","CID=:XCID") 
	    	if rs.isEmpty() quit
		set XSTMGRP=rs.next(),XSTMGRP=rs.getRow()

		set XACN=dep.acn
	
		// Issue a delete to CMBSTM which will then delete CMBCID
		do Db.delete("CMBSTM","ACN=:XACN AND STMGRP=:XSTMGRP AND CID=:XCID")
		}
	quit
	

vau65 // Trigger AU_STAT - After Update Account Status

	type public RecordDEP dep
		/* Revision History
	
		06/26/02 - SCHWARTZA - 50421
													Priority sweeps do not enter status 5.  Modified the status 5
													check to ignore if DEP.SWPOPT'=1.
		*/
	if dep.stat=4 do { quit:ER 
		if dep.bal do Runtime.setErrXBAD("DEP","CLSDBAL") quit:ER 
		if dep.posacr do Runtime.setErrXBAD("DEP","CLSDACR") quit:ER 
		if dep.negacr do Runtime.setErrXBAD("DEP","CLSDACR") quit:ER 
		}
	// Status 5 is only for percentage sweep closeouts.
	if dep.stat=5,dep.swpf=1,dep.swpopt'=1 do { quit:ER 
		new COUNT,TICID,XCID
		set XCID=dep.cid set COUNT=""
		new rs 
		type ResultSet rs=Db.select("ICID","DEP101","CID=:XCID")
		if rs.isEmpty() quit
		while rs.next() do { 
			set XICID=rs.getCol(1)
			do Db.update("DEP","STAT=5","CID=:XICID") quit:ER 
			do Db.update("DEP101","PCT=0","CID=:XCID AND ICID=:XICID") quit:ER 
			}
		}
	quit
	

vau66 // Trigger AU_SVCFEECID - After Update Service Fee Account

	type public RecordDEP dep
	// SVCFEECID - Verify service fee charge account
	
	 /*
	---- Revision History ------------------------------------------------
	08/26/05 - RussellDS - CR16911
		   Eliminate PSL deprecated features
		   
		   Update logic to avoid errors if selected account is not
		   deposit account.
		   
		   Clean up error message
	----------------------------------------------------------------------
	*/

	if dep.svcfeecid'="" do { quit:ER 
		new values,XCID
		// If charge account is same as account, SVCFEECID should be null.
		// Invalid service fee account
		if dep.cid=dep.svcfeecid do Runtime.setErrMSG("DEP",836,dep.svcfeecid) if ER quit
	
		// Error if SVCFEECID does not exist
		// Invalid service fee account
		if 'Db.isDefined("ACN","dep.svcfeecid") do Runtime.setErrMSG("DEP",836,dep.svcfeecid) if ER quit 
		
		set XCID=dep.svcfeecid
		
		type RecordDEP xdep = Db.getRecord("DEP", "CID=:XCID", 1)
		
		// Error if fee account is closed or not a deposit account.

		// Service charge fee account must be a deposit account
		if (xdep.getMode() = 0) do Runtime.setErrMSG("DEP",803) if ER quit
		// Service charge fee account ~p1 is closed
		if (xdep.stat = 4) do Runtime.setErrMSG("DEP",457,dep.svcfeecid) if ER quit 
	}
	
	quit

vau67 // Trigger AU_SWEEP - Overdraft, Sweep

	type public RecordDEP dep
	
	// Overdraft processing for segmented accounts is not supported

	if (dep.segflg=1)&(dep.odo'=0) do Runtime.setErrXBAD("DEP",215) quit:ER
	
	// Loan Pmt Sweep Processing not supported for segmented accts

	if (dep.segflg=1)&(dep.lpswp=1) do Runtime.setErrXBAD("DEP",212) quit:ER 
	
	quit 

vau68 // Trigger AU_SWPF - After update of Sweep Indicateor Code.

	type public RecordDEP dep
	/*
	---- Revision History -------------------------------------------------
	05/23/00 - LUS - 40207
		   Retrofitted change below:
		   04/28/00 - LUS - 39637
		   Added edit check to verify if account is not set up for sweep
																			processing(DEP.SWPF'=1),the sweep thresholds cannot be defined.
																			Added edit check to verify if account is set up for sweep
																			processing(DEP.SWPF=1), the sweep thresholds amount are required.

	*/
			 
 	// Cannot define sweep thresholds if account does not allow sweep processing.
								if dep.swpt'="",dep.swpf'=1 do Runtime.setErrMSG("DEP",4328) quit:ER

								// Sweep Threshold amount required.
								if dep.swpf=1,((dep.swpt<0)!(dep.swpt="")) do Runtime.setErrXBAD("DEP","SWPAMT") quit:ER
	quit

vau69 // Trigger AU_SWPT - After update of Sweep Threshold Amount.

	type public RecordDEP dep
	/*
	   ---------- Revision History-----------------------------------------
	 12/08/05 - ALAGARSS - CR 18006
 		   Modified the code to remove deprecated feature warnings.
 		   And removed old revision history. 		   
	*/
	
	 type public Number POS1,POS2,THRSAMT
	 type public Boolean ER
	 
									if dep.swpt'=dep.swpt.oldVal do {
	 
	 
	 type RecordPRODDFTD proddftd=Db.getRecord("PRODDFTD","TYPE=:dep.type")
	 
	 // Sweep Threshold amt is less than the product default
	 if dep.swpt<proddftd.swpt do Runtime.setErrXBAD("DEP","SWPT") quit:ER
									}

	// Sweep Threshold Amount Verification  - ARQ40207
								// Purchase Threshold Amount is less than Redemption Threshold Amount
								if dep.swpt<dep.swptr do Runtime.setErrMSG("DEP",4280) quit:ER
	
								// Cannot define sweep thresholds if account does not allow sweep processing
								if dep.swpt'="",dep.swpf'=1 do Runtime.setErrMSG("DEP",4328) quit:ER

								// Sweep Threshold amount required
								if dep.swpf=1,((dep.swpt<0)!(dep.swpt="")) do Runtime.setErrXBAD("DEP","SWPAMT") quit:ER

	// Purchase Threshold Amount required for Purchase Increment
								if dep.swpi>0,((dep.swpt<0)!(dep.swpt="")) do Runtime.setErrMSG("DEP",4965) quit:ER

	// Redemption Threshold Amount required for Redemption Increment
								if dep.swri>0,((dep.swptr<0)!(dep.swptr="")) do Runtime.setErrMSG("DEP",4966) quit:ER
	
	//  Checking if DEP.SWPI or DEP.SWRI is a whole number
							 
								set POS1=$F(dep.swpi,".")
								set POS2=$F(dep.swri,".")
								/* Purchase Increment and Redemption Increment must be define in whole
											increment
								*/
								if (POS1'=0)!(POS2'=0) do Runtime.setErrMSG("DEP",4959) quit:ER

	// 48654 - Cannot define a redemption sweep option if account does not allow sweep processing
	if dep.swpf'=1,dep.swpropt'="" do Runtime.setErrMSG("DEP",5091) quit:ER

	quit

vau70 // Trigger AU_TITLE - After Update Title

	type public RecordDEP dep
	/*
	  --------------------------------- Revision History ------------------------------------------
	   01/06/04 - CARROLLJ - CR7658
		      XLCID variable undefined. 

	   11/03/99 - FINCHG - 27393
		      Put title match check on pledged account back in.

	   11/04/98 - HILLANBRAND - ARQ330562
		      Removed title match integrity check on pledged account.

	   03/11/98 - Terrie Dougherty - 26685
		      Replaced DTYPE with PRODDFTD as part of single
		      database project.


	   If title has changed and pledged account secures loan account, titles
	   between the pledged account and the loan account should be identical.
	*/

	if dep.pldg do { quit:ER 
		new count,data,XDEPO,XLCID,XLNO
		set XDEPO=dep.title1_$C(9)_dep.title2_$C(9)_dep.title3_$C(9)_dep.title4
		type ResultSet rs=Db.select("CID","LNCOL","LNCOL.PLDGACN=:CID")
		if rs.isEmpty() quit
		while rs.next() do { quit:ER 
			set XLCID=rs.getCol(1)
			set XLNO=Db.getOneRow("TITLE1,TITLE2,TITLE3,TITLE4","LN","XLCID")
			if XDEPO'=XLNO do Runtime.setErrXBAD("DEP","PCIF") quit:ER   // "Pledged account owners not owners of loan account"
			}
		}
	
	/*
	   This is a transaction (core) account set up for percentage based
	   investment sweep - make identical change on corresponding non-
	   institutional investment accounts.
	*/

	if dep.swpf=1,dep.swpopt=2,dep.crcd=%SystemCurrency do { quit:ER 
		new ICID,IDATA,ITYPE,LINKCNT,SWPNI,TITLE1,TITLE2,TITLE3,TITLE4,XCID	
		set TITLE1=dep.title1
		set TITLE2=dep.title2
		set TITLE3=dep.title3
		set TITLE4=dep.title4
		set XCID=dep.cid
		new rs 
		type ResultSet rs=Db.select("ICID,ITYPE","DEP101","CID=:XCID")	// No linked investment accounts
		if rs.isEmpty() quit
		while rs.next() do { quit:ER  
			set ICID=rs.getCol(1)           			// Investment Account Number
			set ITYPE=rs.getCol(2)          			// Investment Product Type
			set SWPNI=Db.getOneRow("SWPNI","PRODDFTD","ITYPE")
			if SWPNI do Db.update("DEP","TITLE1=:TITLE1,TITLE2=:TITLE2,TITLE3=:TITLE3,TITLE4=:TITLE4","CID=:ICID")
			}
		}
	quit 
	

vau71 // Trigger AU_TYPE - After Update Product Type

	type public RecordDEP dep
	/*
	  -------------------------- Revision History ------------------------------------------------
	   03/10/03 - Allan Mattson - 51351
																						Removed call to DELCF^CFMAIN (Cash Flow obsoleted
																						in V7.0).

	   02/11/99 - MAGERAM - 31831
		      Replaced PRODDFTC with PRODCTL
	
	   12/23/98 - KONGJ - 30071
		      Changed CIFTYP.INTYPRST to PRODDFTC.INTYPRST.
	*/
	
	// Check Institution Type Restriction at account maintenance
	
	new values,CIFTYPE,INTYPE,INTYPRST,XACN,XCRCD
	set XACN=dep.acn
	set values=Db.getOneRow("TYPE,INTYPE","CIF","XACN")
	set CIFTYPE=$P(values,$C(9),1)
	set INTYPE=$P(values,$C(9),2)
	
	// if INTYPE is null, do nothing; else check for Institution Type Restriction.
	
	if INTYPE'="" do { quit:ER 
		set XCRCD=%SystemCurrency
		set INTYPRST=Db.getOneRow("INTYPRST","PRODCTL","CIFTYPE")
	
		// If INTYPRST is set to Yes, check the user table UTBLTTBL for a valid combination.
	
		if INTYPRST do { quit:ER 
			if Db.isDefined("UTBLINTTBL","CIFTYPE,INTYPE,dep.type") quit 
			do Runtime.setErrXBAD("DEP","INTYPRST") quit:ER 
			}
		}
	quit
	

vau72 // Trigger AU_UPFRE - After Update Usage Credit Plan Frequency

	type public RecordDEP dep
	if dep.uspl'="",dep.upfre="" do Runtime.setErrXBAD("DEP","UPFRE") quit:ER 
	quit
	

vau73 // Trigger AU_UPNDT - After Update Usage Credit Plan Next Date

	type public RecordDEP dep

	 /*
	---- Revision History ------------------------------------------------
	08/26/05 - RussellDS - CR16911
		   Correct logic of if/else code
	----------------------------------------------------------------------
	*/

	if dep.upndt="",dep.uspl'="" do { quit:ER
		do Runtime.setErrXBAD("DEP","UPNDT2") quit:ER
	}
	else  if dep.upndt<%SystemDate,dep.upfre'="" do Runtime.setErrXBAD("DEP","UPNDT") quit:ER 
	
	quit

vau74 // Trigger AU_USPL - After Update Usage Credit Plan

	type public RecordDEP dep
	if dep.grp="DBD",dep.uspl'="" do Runtime.setErrXBAD("DEP","XDBDUSPL") quit:ER 
	quit
	

vau75 // Trigger AU_WRKDTE - After Update Work Date

	type public RecordDEP dep
	/*
	  --------------------- Revision History ------------------------------------------------
	   
	   11/11/05 - SATYANAS - 18007
	   	      Modified the code to PSL Standards.	
	   
	   06/03/99 - HILLANBRAND - ARQ33064
		      Added new trigger AU_WRKDTE for Collection Queue
	*/

	type public Boolean ER	

	// Update worked in Collection Report File
	
	type ResultSet rs=Db.select("QUEUE,CLS,WRKED","QCOLLREP","CID=:dep.cid") 
	if 'rs.getCol(3),('rs.getCol(1).isNull()) do { quit:ER
				
		type RecordQCOLLREP qcollrep=Db.getRecord("QCOLLREP","CID=:dep.cid,CLS=:rs.getCol(2),QUEUE=:rs.getCol(1)",1)
		if qcollrep.getMode() do {
			set qcollrep.wrked=1
			do qcollrep.save()
			}
		} 
	
	quit
	

vbd1 // Trigger BEFORE_DELETE - Before delete (check bal,status)

	type public RecordDEP dep
	/*
								---- Revision History ------------------------------------------------
							 
								07/19/05 - RussellDS - CR16614
        	   Replaced /SYSTEM qualifier with /FRMFILER.
        	   
        	   Minor PSL clean up.
        	   
        	   Removed old revision history.
	*/

	// Verify that if this is the lead account for Combined Account
	// Analysis, there are no sub accounts linked to it.
	
	type public Boolean ER
	
	type Number XACN, XCID
	
	set XCID = dep.cid

	//Cannot close the lead account used in account analysis
	if dep.anltyp = 1 do { quit:ER

		type ResultSet rs = Db.select("CID","DEP","ANLCID=:XCID")
	        if rs.isEmpty() quit 
		do Runtime.setErrXBAD("DEP","ANLCLS") quit:ER
	}
				
	// Delete RELCIF entries for this account
	set XACN = dep.acn
	do Db.delete("RELCIF", "CID=:XCID AND ACN=:XACN") quit:ER
	do Db.delete("CMBSTM", "CID=:XCID AND ACN=:XACN", "/FRMFILER") quit:ER
	
	// Check account status,balance and ytd int
	if dep.stat = 4, 'dep.bal, 'dep.acr, 'dep.iytd, 'dep.ira quit 
	do Runtime.setErrMSG("DEP", 76) quit:ER 
	
	quit

vbi1 // Trigger BEFORE_INSERT - Before Insert Trigger Deposit

	type public RecordDEP dep
	/*
 	---- Revision History ------------------------------------------------
	06/26/00 - Terrie Dougherty - 40629
		   Moved all code and revision history comments from this
		   trigger into a new procedure, DEPBI, to prevent compilation
		   errors caused by the DEP filer being too large. Changes to
		   the BEFORE_INSERT trigger should now be made to the DEPBI
		   procedure.
	*/

	do PROC^DEPBI(.dep)
	quit

vbu1 // Trigger BU - Before Update

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	// Revision History
	//------------------------------------------------------------------------
	// Orig: 11/10/99 - JERUCHIMC - 34287
	// This trigger created for MT320 SWIFT messages.  We need to check certain
	// data items and possibly generate an MT320.
	//------------------------------------------------------------------------
	new PTYPE,P320,FOUND,COLMN
	set PTYPE=dep.type
	set P320=Db.getOneRow("MT320","PRODDFTD","PTYPE")
	// Account AND product type must be set up for MT320 processing
	// in order to generate an MT320.
	// Cannot generate SWIFT MT320 message when product type is not eligible."
	if ('(P320=1))&(dep.mt320=1) set ER=1,RM=$$^MSG(4173) quit
	if ('(P320=1))!('(dep.mt320=1)) quit
	set DI="",FOUND=0
	// Loop through ^UTBL("MT320DI" and use changed macro to determine
	// if any of these data items are changing.
	new rs
	type ResultSet rs=Db.select("COL","UTBLMT320DI")
	if rs.isEmpty() quit
	while rs.next() do { quit:(FOUND=1)
 	set COLMN=rs.getCol(1)
	if dep.isChanged(COLMN) set FOUND=1
	}

	// Generate the MT320 message for an ammended or cancelled account.
	if FOUND=1 do ^SW320GEN(CID,"AMEND",dep.mdt) Q
	quit

vbu2 // Trigger BU_ACS - Before Update Accrual Indicator

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   Revision History

	   03/17/00 - CHOK - 31126
		      Converted isChanged method.
	*/

	// Change to column ~p1 not allowed

	if 'dep.isChanged("ACS","SYSTEM") do Runtime.setErrMSG("DEP",412,"dep.acs") if ER quit 
	quit
	

vbu3 // Trigger BU_AIIPF - Before Update Avail Int Posting Freq

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   --------------------------------------------------------------------
	   Revision History

	   10/27/00 - SMITHC - 42068:1
		      Created trigger to handle maintenance of Available 
		      Interest Posting Frequency (consistent with other 
		      frequency triggers).
	*/

	// Available Interest Posting Frequency is defined
	if dep.aiipf'="" do { quit:ER
		new NJD

		/* Avail Interest Next Posted and Avail Interest Paid - Last 
		   Date not applicable if segmented account accruing at 
		   segment level */
		if dep.segflg,'dep.segacr do { quit
			set dep.aiinp=""
			set dep.aiipld=""
			}

		// Default next date if not defined or in the past
		if dep.aiinp'>%SystemDate do { quit:ER
			new INTPOS
			set INTPOS=$S(Db.getOneRow("INTPOS","CUVAR")=1:1,1:0)
			set NJD=$$FRSTDATE^ACNFUNCS(dep.odt,dep.aiipf,INTPOS) quit:ER
			set dep.aiinp=NJD
			}

		// Default last date if not defined
		if dep.aiipld'="" do { quit:ER
			set NJD=$$NJD^UFRE(dep.aiinp,dep.aiipf,,"1") quit:ER
			if NJD<dep.odt S NJD=dep.odt
			set dep.aiipld=NJD
			}
		}

	quit

vbu4 // Trigger BU_AIIRN - Before Update Available Interest Rate

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   ----------------- Revision History ---------------------------------

	   10/30/03 - CARROLLJ - -CR7658
		      Modified calls to CTL^UINDX.

	   10/27/00 - SMITHC - 42068:1
		      Cleaned up code to be more consistent with before insert
		      and added code to handle changes to AIINTFRE and AIINDEX.
		      Incorporated BU_AIRDET into this trigger, and moved some
		      error checks dealing with effective date to AU_AIIRN.
	 
	   03/01/99 - SCHWARTZC - 28966
		      Modify previous comment to include a paramater to prevent
		      Fatal error reported in TW.
	
	   02/03/99 - ROYTENBERGG - 28224
		      Substituted $ZD with $$DAT^%ZM(DEP.HISCTF).
	*/

 	// Accounts tied to an index cannot be changed
	if dep.aiirn.oldVal'=dep.aiirn,dep.aiindex'="" do Runtime.setErrMSG("DEP",192) if ER quit

	if dep.aiintfre'="",dep.airdet do { quit:ER
		new NJD

		// Default next date if not defined or in the past
		if dep.aiichnd'>%SystemDate do { quit:ER
			new INTPOS
			set INTPOS=$S(Db.getOneRow("INTPOS","CUVAR")=1:1,1:0)
			set NJD=$$FRSTDATE^ACNFUNCS(dep.odt,dep.aiintfre,INTPOS) quit:ER
			set dep.aiichnd=NJD
			}

		// Default last date if not defined
		if dep.aiichld="" do { quit:ER
			set NJD=$$NJD^UFRE(dep.aiichnd,dep.aiintfre,,"1") quit:ER
			if NJD<dep.odt S NJD=dep.odt
			set dep.aiichld=NJD
			}
		}

	// If Avail Interest Index not defined, clear appropriate related fields
	if dep.aiindex="" do {
		set dep.aiintmat=""
		set dep.aiintspr=""
		set dep.airndmtd=""
		set dep.aiichnd=""
		}

	// Default AIIRN not defined and AIINDEX exists and AIRDET is set
	if dep.aiindex'="",dep.aiirn="",dep.airdet do { quit:ER
		set PAR("INDEX")=dep.aiindex
		set PAR("IPMODE")=1
		set PAR("NOTSER")=1
		set PAR("MATRIX")=dep.aiintmat
		set PAR("ROUND")=dep.airndmtd
		set PAR("SPREAD")=dep.aiintspr
		do CTL^UINDX(.dep,dep.aiichld,dep.intavlncr,.PAR)
		if ER&($P($G(IX(dep.aiindex)),"|",14)) do {
			new ERDT
			set (ER,RM)=""
			set ERDT=""
			set ERDT=$O(IX(dep.aiindex,ERDT))
			quit:ERDT=""
			set RATE=$P(IX(dep.aiindex,ERDT,0),"|",1)
			if RATE'?.N.1".".N do {
				set PAR("INDEX")=dep.aiindex
				set PAR("IPMODE")=1
				set PAR("NOTSER")=1
				set PAR("MATRIX")=dep.aiintmat
				set PAR("ROUND")=dep.airndmtd
				set PAR("SPREAD")=dep.aiintspr
				do CTL^UINDX(.dep,ERDT,dep.intavlncr,.PAR)
				}
			}
		if 'ER set dep.aiirn=RATE
		}

	quit

vbu5 // Trigger BU_ANLLSD - Before Update Net Loss Start Date

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	if 'dep.anllsd set dep.anlled="" quit

	//calculate Net Loss End Date 
	set dep.anlled=dep.anlsnl+dep.anllsd
	if dep.anlled<%SystemDate do Runtime.setErrMSG("DEP",4326,"DEP.ANLLED") quit:ER
	quit

vbu6 // Trigger BU_ANLSNL - Before Update Days to Settle Net Loss

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	if 'dep.anllsd quit
	
	//calculate Next Loss End Date.
	set dep.anlled=dep.anlsnl+dep.anllsd
	if dep.anlled<%SystemDate do Runtime.setErrMSG("DEP",4326,"DEP.ANLLED") quit:ER
	quit

vbu7 // Trigger BU_ANLSYS_ANLTYP - Before Update - ANLSYS & ANLTYP

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	if dep.isChanged("ANLSYS") do { quit:ER
	 if '(dep.anlsys) set dep.anltyp=0
	 if (dep.anlsys),'(dep.anltyp) set dep.anltyp=1
			  } 
	/* If the value of analysis type changes from a 2 or 3, to a 1, the
				following warning message will be displayed:
	
				Changing Analysis Type to Lead Account Will Remove the Lead Account Value.
	*/
	if (dep.anltyp=1)!(dep.anltyp=0) do { quit:ER
								if dep.anlcid do Runtime.setErrXBAD("DEP","ANLTYP") quit:ER
								set dep.anlcid=""
																					}
	quit

vbu8 // Trigger BU_BGTCONTR - Before Update Budget Contribution Freq

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/* 
		Revision History -------------------------------------------

			08/21/00 - SMITHC - 37960:1
  	      Modified the defaulting of DEP.BGTLCDT and 
  	      DEP.BGTLCDT from DEP.BGTCONTR to follow the 
  	      standard rules of initial frequency dates, and 
  	      to assume BOD instead of EOD.
	 
			01/14/00 - SWEENEYT - 34910
  	      Added trigger to compute next scheduled 
  	      contribution date.

		-------------------------------------------------------------
	*/

	// BGTNCDT - Next Scheduled Contribution Date
	if dep.BGTPRO,dep.BGTCONTR'="" do { quit:ER
 	new NJD

 	set NJD=$$FRSTDATE^ACNFUNCS(dep.odt,dep.bgtcontr,0) quit:ER
 	if dep.bgtncdt="" set dep.bgtncdt=NJD
	
 	if dep.bgtlcdt'="" quit
	
 	// Default BGTLCST - Last Scheduled Contribution Date
 	set NJD=$$NJD^UFRE(dep.bgtncdt,dep.bgtcontr,,"10001") quit:ER
 	if NJD<dep.odt set NJD=dep.odt
 	set dep.bgtlcdt=NJD
	}

	quit

vbu9 // Trigger BU_BGTPRO - Before Update Budget Processing

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	if dep.bgtpro do {
	new AF
	set dep.bgtyrsd=%SystemDate
	// Find budget year next date
	set dep.bgtyrnd=$$NJD^UFRE(dep.bgtyrsd,dep.bgtfreq,.AF)
	set dep.bgtrvudt=dep.bgtyrnd-dep.bgtoffst

	set dep.bgtlcdt=%SystemDate
 	// Default Next Scheduled Contribution Date
	set dep.bgtncdt=$$NJD^UFRE(dep.bgtlcdt,dep.bgtcontr,.AF)
	}
	quit

vbu10 // Trigger BU_BGTRVUDT - Before Update Budget Review Date

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	if dep.bgtpro set dep.bgtrvudt=dep.bgtyrnd-dep.bgtoffst

	quit

vbu11 // Trigger BU_BWF - Before Update Backup Withholding

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	 ----------- Revision History ---------------------------------------

	10/04/01 - AHMEDS - 46105
		 This is a new trigger. This trigger is added to nullify the
		 accrued withholding tax (DEP.AWT) and accrued withholding
		 tax rate (DEP.AWTR) when accrued withholding tax processing
		 (DEP.AWTP) changes from selected to not selected with
		 backup withholding (DEP.BWF) option selected.  

	11/20/01 - AHMEDS - 46105
		 Removed setting of DEP.AWTR (accrued withholding tax rate)
		 to null when DEP.AWTP (accrued withholding tax processing 
		 option) changes from selected to not selected with DEP.BWF 
		 (backup withholding option) selected.

	*/

	/* 
	When accrued withholding tax index (DEP.AWTI) is defined irrespective
	of what the accrued withholding tax processing (DEP.AWTP) option is
	,the system calculates an account's withholding tax daily during 
	interest accruals. The amount of interest withheld will equal the 
	total amount of withholding computed over the entire interest posting 
	period.  When DEP.AWTI is not defined, the system calculates an 
	account's total withholding tax over the entire interest posting period
	on the interest posting day.
	
	When DEP.AWTP changes from selected to not selected and the accrued 
	withholding tax index is still defined, the accrued withholding tax 
	must equal to null in order to exclude any previously calculated 
	daily accrued interest withholding. If DEP.AWTI is not defined, then
	the withholding amount for the entire interest/dividend posting period
	will be calculated at the next interest posting day.

	There is no G/L associated with accrued withholding tax (DEP.AWT).
	*/
	if dep.bwf,'dep.awtp set dep.awt=""

	quit

vbu12 // Trigger BU_CCLD - Before Update Last Contact Date - Title

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	---- Revision History---------------------------------------------------
	
	10/04/06 - KELLYP - CR 22341
		   Modified to remove the dep.ccld.oldVal check.  This prevented
		   the dep.ccld field from being updated when the dep.title*
		   fields were modified when dep.ccld already had a value.
	
	*/
	
	// CUVAR option for updating dep.ccld is disabled
	if 'CUVAR.LCCTIT quit
	
	// Already set to today
	if dep.ccld=%SystemDate quit
	
	set dep.ccld=%SystemDate
	
	quit
	

vbu13 // Trigger BU_CCLD_PBKSEQ - Before Update Contact Date on PBKSEQ

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	
	// Update Last Contact on Passbook Update

	type ResultSet rs
								set rs=Db.select("LCCPU","CUVAR")
	if rs.getCol("LCCPU"),dep.ccld'=%SystemDate set dep.ccld=%SystemDate
	quit
	

vbu14 // Trigger BU_CLS - Before update class

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	// Change to column ~p1 not allowed

	do Runtime.setErrMSG("DEP",412,"DEP.CLS") if ER quit 
	quit
	

vbu15 // Trigger BU_COLLST - Collection Queue Change

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	  ------------------- Revision History ------------------------------------------------
	   
	   11/15/05 - SATYANAS - 18007
	   	      Added the decaration for ER.
	   
	   06/10/99 - CARROLLJ  33064
		If [DEP]COLLST-Collsection Status is modified update the
		[DEP]PCOLLST-Previous Collection Status and [DEP]COLCDTE-
		Collection Status Change date.
		If collection status is changed update previous collection status and
		Collection Status Change Date
	*/
	
	type public Boolean ER
	
	if (dep.collst.oldVal'=dep.collst) do { quit:ER 
		if dep.colcdte'=%SystemDate set dep.colcdte=%SystemDate
		if dep.collst.oldVal'=dep.collst set dep.pcollst=dep.collst.oldVal
		}
	quit
	

vbu16 // Trigger BU_DARCOVR - Before Update Deposit Asset Class Overri

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   If Deposit Class Override is updated, update Suspect Indicator.
	   If DARCOVR > 0 set SUSPECT to 1.
	   If DARCOVR = Null and Expiration period exists set SUSPECT to 3, else set
	   SUSPECT to NULL
	*/

	set dep.suspect=$S(dep.darcovr>0:1,(dep.darcexpd&'dep.darcovr):3,1:"")
	quit
	

vbu17 // Trigger BU_DEFINADJ - Before Update Deferred Int Adjustments

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	// Defer Posting Interest Adjustments flag cannot be modified

	do Runtime.setErrMSG("DEP",3857) if ER quit
	
	quit
	

vbu18 // Trigger BU_EMPLBEN - Before Update of Employer Benefit Plan

	type public RecordDEP dep
	do dep.setAuditFlag(1)

	/*
	  --------------------- Revision History-----------------------------------------------------------
	
	  11/03/99 - MOTENJ - 31126
		Converted to PSL.
	           	  
	*/

	if (dep.emplben=1) do { quit:ER 
		// Employer Code is required when Employer Benefit Plan is Yes

		if dep.emplno="" do Runtime.setErrXBAD("DEP",198) quit:ER 

		new data,XACN,XEMPLNO,XTYPE
		set XACN=dep.acn 
		set XEMPLNO=dep.emplno 
		set XTYPE=dep.type
	
		new rs 
	    	type ResultSet rs=Db.select("CID","DEP","TYPE=:XTYPE AND EMPLNO=:XEMPLNO AND ACN=:XACN") 
	
		// Employer Benefit Plan already opened for this cust and prod

		if 'rs.isEmpty() do Runtime.setErrXBAD("DEP",197) quit:ER 
		}
	
	do { quit:ER 
		new data,emplben,TYPE
		set TYPE=dep.type
		set data=Db.getOneRow("EMPLBEN","PRODDFTD","TYPE")
		set emplben=$P(data,$C(9),1)

		//Employer Benefit flag must be consistent with the Product Type.

		if emplben=1,dep.emplben'=1 do Runtime.setErrMSG("DEP",3639) if ER quit 
		}
	quit 
	

vbu19 // Trigger BU_GCR - Before Update GCR

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   Revision History
	
	   11/22/05 - NATRAJAH - 13734
		      General DBI3 cleanup.

	   03/17/00 - CHOK - 31126
		      Converted isChanged method.
	*/

	type Public Boolean ER
	// If GCRS or GCRCD is changed, update GCR date last and previous maintained

	set dep.gcrlmnt=%SystemDate
	set dep.gcrpmnt=dep.gcrlmnt.oldVal
	
	// IF GCRS status is changed to Revoked, set the GCR code, coverage to null

	if dep.gcrs=3 set dep.gcrcd="",dep.gcrcv="",dep.sddepcvr=""
	
	// If user changes GCRCD update daily comment field for report with user ID.

	if 'dep.isChanged("GCRCD","SYSTEM") set dep.cngrs=""
	
	// IF GCRCD is changed and GCR status is fixed or dynamic, update coverage.

	if dep.isChanged("GCRCD"),(dep.gcrcd'=""),(dep.gcrs=2)!(dep.gcrs=1) do { quit:ER 
		type String MTBL
		type Number DGCRCD,DIF,GCRCV,NSDCVR,OSDCVR
		set MTBL=dep.mscrtbl
		set DGCRCD=dep.gcrcd
		type ResultSet rs=Db.select("SDDEPCVR,GCRCV","UTBLGCRBAL","TBLNM=:MTBL AND GCRCD=:DGCRCD")
		if 'rs.isEmpty() if rs.next() set dep.sddepcvr=rs.getCol("SDDEPCVR")
		set GCRCV=rs.getCol("GCRCV")+dep.inicvopt
		set dep.gcrcv=GCRCV
	
		// Update GCRAVL with changed amount

		set NSDCVR=dep.sddepcvr
		set OSDCVR=dep.sddepcvr.oldVal
		if NSDCVR<OSDCVR set DIF=OSDCVR-NSDCVR,NSDAVL=dep.sdavl-DIF
		else  set DIF=NSDCVR-OSDCVR,NSDAVL=dep.sdavl+DIF
		set dep.sdavl=$S(NSDAVL<0:0,1:NSDAVL)
		}
	quit
	

vbu20 // Trigger BU_GCRCV - Before Update GCRCV

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   Revision History
	
	   11/22/05 - NATRAJAH - 13734
		      General DBI3 cleanup.

	   03/17/00 - CHOK - 31126
		      Converted isChanged method.
	*/
	type Public Boolean ER
	// Change to column ~p1 not allowed

	if 'dep.isChanged("GCRCV","SYSTEM") do Runtime.setErrMSG("DEP",412,"DEP.GCRCV") if ER quit
	quit
	

vbu21 // Trigger BU_GCRDOD - Before Update GCR Daily Overdraft

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	if dep.gcrdod=1 set dep.odcnt=dep.odcnt
	quit
	

vbu22 // Trigger BU_GCRLMNT - Before Update GCR Date Last Maintained

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   Revision History
	
	   11/22/05 - NATRAJAH - 13734
		      General DBI3 cleanup.

	   03/17/00 - CHOK - 31126
		      Converted isChanged method.
	*/
	type Public Boolean ER

	// Change to column ~p1 not allowed

	if 'dep.isChanged("GCRLMNT","SYSTEM") do Runtime.setErrMSG("DEP",412,"DEP.GCRLNMT") if ER quit
	quit
	

vbu23 // Trigger BU_GCRPMNT - Before Update GCR Date Prev Maintained

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   Revision History
	
	   11/22/05 - NATRAJAH - 13734
		      General DBI3 cleanup.

	   03/17/00 - CHOK -31126
		      Converted isChanged method.
	*/
	type Public Boolean ER

	// Change to column ~p1 not allowed
	if 'dep.isChanged("GCRPMNT","SYSTEM") do Runtime.setErrMSG("DEP",412,"DEP.GCRPMNT") quit:ER 
	quit
	

vbu24 // Trigger BU_GCRTFCID - Before Update GCR Transfer Account

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	  -----------------------  Revision History -------------------------------------------------

   	   09/08/04 - KELLYP - CR 11982
		Replaced references to RELACN with RELCIF.  RELACN is an index
		and should not be directly referenced.  The RELACN table was 
		also obsoleted from the M database.

	   10/05/99 - HILLANBRAND 33754
		Removed setting of computed data items GCRLBAl and TODCNT
	*/

	if dep.gcrtfcid="" quit 
	
	/*
	   The GCR transfer account must be a closed account with status = 4, a valid
	   acount for a least one cif and currency the same.
	*/

	type Public String ER

	type Boolean ONECIF
	type Number GCID,RCIF
	
	if 'Db.isDefined("DEP","dep.gcrtfcid") do Runtime.setErrMSG("DEP",7774) if ER quit 
	set GCID=dep.gcrtfcid
	
	type RecordDEP depgcid=Db.getRecord("DEP","CID=:GCID")
	
	// Account ~p1 not closed
	if depgcid.stat'=4 do Runtime.setErrMSG("DEP",125,dep.gcrtfcid) if ER quit 

	// Must be a deposit account
	if depgcid.cls'="D" do Runtime.setErrMSG("DEP",1791) if ER quit 

	// Transfer account must be of the same currency
	if depgcid.crcd'=dep.crcd do Runtime.setErrMSG("DEP",2748) if ER quit 
	
	set ONECIF=0

	// CR 11982 - Replaced RELACN with RELCIF
	type ResultSet rs=Db.select("ACN","RELCIF","CID=:GCID")
	if 'rs.isEmpty() while rs.next() do { quit:ER
		set RCIF=rs.getCol(1)
		// CR 11982 - Replaced RELACN with RELCIF
		if Db.isDefined("RELCIF","RCIF,CID") set ONECIF=1
		}
	if 'ONECIF do Runtime.setErrXBAD("DEP","PCIF") quit:ER 
	
	/*
	   This coding is done in the before update so after update triggers on various data items will occur.
	   GCR transfer account holds the account from which GCR information is transferred. 
	   Move all GCR related fields and the GCR Liability Package Balances from GCR transfer account when
	   GCRTFCID is updated with a valid account number.
	   During GCR scoring, the system will read the Original Opening Date field on the account.  
	   If Original Opening Date contains a value, the system will use Original Opening Date to compute the 
	   account age.  Overdraft information will have been transferred to the new account, so normal processing
	   will apply. The system will compute the Six-Month Average GCR Liability Package Balance from the balances
	   transferred to the new account.
	*/
	 		
	// Update GCR colums
	set dep.odcnt1=depgcid.odcnt1
	set dep.odcnt2=depgcid.odcnt2
	set dep.odcnt3=depgcid.odcnt3
	set dep.odcnt4=depgcid.odcnt4
	set dep.odcnt5=depgcid.odcnt5
	set dep.odcnt6=depgcid.odcnt6
	set dep.odcnt7=depgcid.odcnt7
	set dep.odcnt8=depgcid.odcnt8
	set dep.odcnt9=depgcid.odcnt9
	set dep.odcnt10=depgcid.odcnt10
	set dep.odcnt11=depgcid.odcnt11
	set dep.odcnt12=depgcid.odcnt12
	set dep.odcnt13=depgcid.odcnt13
	set dep.odcnt14=depgcid.odcnt14
	set dep.odcnt15=depgcid.odcnt15
	set dep.odcnt16=depgcid.odcnt16
	set dep.odcnt17=depgcid.odcnt17
	set dep.odcnt18=depgcid.odcnt18
	set dep.odcnt19=depgcid.odcnt19
	set dep.odcnt20=depgcid.odcnt20
	set dep.odcnt21=depgcid.odcnt21
	set dep.odcnt22=depgcid.odcnt22
	set dep.odcnt23=depgcid.odcnt23
	set dep.odcnt24=depgcid.odcnt24
	set dep.odcnt25=depgcid.odcnt25
	set dep.odcnt26=depgcid.odcnt26
	set dep.odcnt27=depgcid.odcnt27
	set dep.odcnt28=depgcid.odcnt28
	set dep.odcnt29=depgcid.odcnt29
	set dep.odcnt30=depgcid.odcnt30
	set dep.odcnt31=depgcid.odcnt31
	set dep.odcnt32=depgcid.odcnt32
	set dep.odcnt33=depgcid.odcnt33
	set dep.odcnt34=depgcid.odcnt34
	set dep.odcnt35=depgcid.odcnt35
	set dep.odcnt36=depgcid.odcnt36	
	set dep.origopd=depgcid.odt
	set dep.gcrs=depgcid.gcrs
	set dep.gcrcd=depgcid.gcrcd
	set dep.gcrlmnt=depgcid.gcrlmnt
	set dep.gcrpmnt=depgcid.gcrpmnt
	set dep.mscrtbl=depgcid.mscrtbl
	set dep.dscrtbl=depgcid.dscrtbl
	set dep.inicvopt=depgcid.inicvopt
	set dep.scrfreq=depgcid.scrfreq
	set dep.odlimopt=depgcid.odlimopt
	set dep.lsovrdm=depgcid.lsovrdm
	set dep.hsovrdm=depgcid.hsovrdm
	set dep.dsopt=depgcid.dsopt
	set dep.gcrcv=depgcid.gcrcv
	set dep.sddepcvr=depgcid.sddepcvr
	set dep.nsdate=depgcid.nsdate
	set dep.lsdate=depgcid.lsdate
	set dep.gcrdod=depgcid.gcrdod
	set dep.rnamt=depgcid.rnamt
	set dep.odcnt=depgcid.odcnt
	set dep.convdt=%SystemDate

	quit

vbu25 // Trigger BU_INTCHKFRE - Before Update Interest Check Frequency

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   ---- Revision History ----------------------------------------------

	   10/27/00 - SMITHC - 42068:1
		      Cleaned up code to be more consistent with before insert
		      and other before update frequency triggers.
	*/

	if dep.intchkfre'="" do { quit:ER
		new NJD

		// Default next date if not defined or in the past
		if dep.intchknd'>%SystemDate do { quit:ER
			new INTPOS
			set INTPOS=$S(Db.getOneRow("INTPOS","CUVAR")=1:1,1:0)
			set NJD=$$FRSTDATE^ACNFUNCS(dep.odt,dep.intchkfre,INTPOS) quit:ER
			set dep.intchknd=NJD
			}

		// Default last date if not defined
		if dep.intchkld'="" do { quit:ER
			set NJD=$$NJD^UFRE(dep.intchknd,dep.intchkfre,,"1") quit:ER
			if NJD<dep.odt S NJD=dep.odt
			if dep.intchkld=NJD
			}
		}
	quit

vbu26 // Trigger BU_IOPT - Before Update Interest Disb. Option

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	
	/*
	  ------------------- Revision History ------------------------------------------------
	   05/20/99 - SCOTTC - 30444
		Modified to handle new interest disbursement options 5, 6 and 7.
	
	 	IOPT - Interest Disbursement Option
	      	0)=Remain On Deposit
	      	1)=Pay By Check
	      	2)=Transfer to Another Account
	      	3)=Pay By Check (Consolidated)
	      	5)=Transfer Int Paid and Int Paid Adjmts
	      	6)=Transfer Int Charged and Charged Adjmts
	      	7)=Transfer All Int and All Int Adjmts
	*/
	new IOPT
	set IOPT=dep.iopt
	
	// Interest disbursement option is not transfer to another account.

	if IOPT'=2,IOPT'=5,IOPT'=7,dep.itrf'="" set dep.itrf=""
	
	// Transfer to another account, transfer account required

	if dep.iopt=2,dep.itrf="" do Runtime.setErrXBAD("DEP","ITRF") quit:ER 
	
	// Interest disbursement option is not transfered negative interest to another account.

	if IOPT'=6,IOPT'=7,dep.negitrf'="" set dep.negitrf=""
	
	// Interest disbursement option is not pay by check.

	if dep.iopt'=3,dep.iopt'=1 do {
		if dep.intchkfre'="" set dep.intchkfre=""
		if dep.intchknd'="" set dep.intchknd=""
		if dep.intchkld'="" set dep.intchkld=""
		if dep.intchkmin'="" set dep.intchkmin=""
		}
	quit
	

vbu27 // Trigger BU_IPF - Before Update Int/Div Posting Frequency

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
 	   --------------------------------------------------------------------
	   Revision History
	   
	   08/02/06 - ratht - CR 19215
	   	      The value of NJD is kept in a loop till NJD not greater 
	   	      than current date where NJD is being set by procedure UFRE.
	   	      Added a condition by checking that the updation of columns 
	   	      IPLD and NEGIPLD is being done by SYSTEM ONLY
	   	      
	   04/03/02 - KELLYP - 49129
		      Modified the check that determines whether or not INP is
		      in the past when generating a new INP.  This check was
		      previously not considering CUVAR.INTPOS.

	   10/26/00 - SMITHC - 42068:1
		      Replaced BU_INTAF with this trigger.  Cleaned up code to
		      be more consistent with before insert.

	   09/22/00 - REEDD - 42068 (Roll forward 41188)
		      Modified code to calculate the next and last change date 
		      if the available interest frequency has changed.

	   01/13/99 - HAYMANP - 35866
		      Retrofit change below:

		      12/18/99 - SMITHC - 35866
		      removed code to handle low balance verification (moved
		      to AU_INTEREST trigger).
	 */

	 if dep.ipf'="" do { quit:ER 
	 	new AF,cuvar,INTPOS,NJD

		/*
		   Determine Int/Div - Annual Factor, regardless of whether
		   or not user specifies
		*/
		set NJD=$$NJD^UFRE(%SystemDate,dep.ipf,.AF,"00001") quit:ER 
		set dep.intaf=AF

		/*
		   Int/Div Next Posted and Int/Div Paid - Last Date not 
		   applicable if segmented account accruing at seg level
		*/
		if dep.segflg,'dep.segacr do { quit
			set dep.inp=""
			set dep.ipld=""
			}

		// 49129 - Get INTPOS (BOD/EOD Interest Posting Indicator)
		type RecordCUVAR cuvar=Db.getRecord("CUVAR","*")
		set INTPOS=cuvar.intpos

		// 49129 - Modified "if" below to consider INTPOS
		// Default next date if not defined or in the past
 		if dep.inp<(%SystemDate+INTPOS-1) do { quit:ER
			// 49129 - Reset INTPOS for CTL parameter of FRSTDATE
			set INTPOS=INTPOS#2
			set NJD=$$FRSTDATE^ACNFUNCS(dep.odt,dep.ipf,INTPOS) quit:ER
			set dep.inp=NJD
			}
		// Only change by system is allowed for this column
		if (dep.ipld.oldVal'=dep.ipld),('dep.isChanged("IPLD","SYSTEM")) do Runtime.setErrMSG("DEP",412,"DEP.IPLD") quit:ER

		// Default last date if not defined
		 if dep.ipld="" do { quit:ER
			set NJD=dep.inp
			for  set NJD=$$NJD^UFRE(NJD,dep.ipf,,"1") quit:ER  do { quit:NJD'>%SystemDate
				if NJD<dep.odt set NJD=dep.odt
				}
			set dep.ipld=NJD
			}
		}

	quit

vbu28 // Trigger BU_IRA - Before update IRA plan

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	  -------------------- Revision History -------------------------------------------------------
	   05/10/99 - TITOVE - 31637
		Update to IRA and RPASEQ fields allowed as a part of
		de-linking processing.
	*/
	
	// PFW De-link flag set IRA TYPE to zero

	if dep.dlkflg,dep.ira.oldVal set dep.ira=0
	
	/*
	   If IRA type is set to zero through de-link process or user change, set
	   the RPASEQ to null.  Integrity and error checking done in AU_IRA trigger.
	*/

	if 'dep.ira set dep.rpaseq=""

	quit
	

vbu29 // Trigger BU_IRN - Before update of IRN

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   ---- Revision History ----------------------------------------------
	   08/27/02 - ANTONOVV - 43583
		      Modified calls to UINDX to comly with new parameters.

	   11/20/01 - AHMEDS - 46105
		      The trigger has been modified to pass a 0 for the
		      interest amount in the call to ^DEPBW. Also removed
		      check for DEP.AWTP (accrued withholding tax processing)
		      option when DEP.AWTI (accrued withholding tax index) 
		      is defined in the call to ^DEPBW to calculate tax rate.

	   10/04/01 - AHMEDS - 46105
		      Modified to include a check to see if Accrued Withholding
		      Tax Processing option is on and Accrued Withholding Tax 
		      Index is defined. If the above is true then call into 
		      AWT^DEPBW to get the tax rate corresponding to the 
		      interest rate.		      

	   06/18/01 - SISONG - 45459
		      New(ed) DEP to be able to create accounts with ODLIM
		      Interest Index added.

	   10/27/00 - SMITHC - 42068:1
		      Cleaned up code to be more consistent with before insert.
		      Incorporated BU_INTFRE and BU_INDEX into this trigger,
		      and moved some error checks dealing with effective date
		      to AU_IRN.
	*/

	new DEP 
		
	// Accounts tied to an interest index cannot be changed
	if dep.irn.oldVal'=dep.irn,dep.index'="" do Runtime.setErrMSG("DEP",192) if ER quit 
	
	// Does not apply to segmented accounts accruing at the segment level
	if dep.intfre'="" do { quit:ER
 		new NJD

		if dep.segflg,'dep.segacr do { quit
			set dep.ichnd=""
			set dep.ichld=""
			}

		// Default next date if not defined or in the past
 		if dep.ichnd'>%SystemDate do { quit:ER
			set NJD=$$FRSTDATE^ACNFUNCS(dep.odt,dep.intfre,1) quit:ER
			set dep.ichnd=NJD
			}

		// Default last date if not defined
		if dep.ichld'="" do { quit:ER
			set NJD=$$NJD^UFRE(dep.ichnd,dep.intfre,,"1") quit:ER
			if NJD<dep.odt set NJD=dep.odt
			set dep.ichld=NJD
			}
		}

	// If Int/Div Index not defined, clear appropriate related fields
	if dep.index="" do {
		set dep.intmat=""
		set dep.intspr=""
		set dep.rndmtd=""
		set dep.ichnd=""
		}

 	/*
	   If Index is present;  find the Rate according to index, and place
	   it in IRN.  If error and DIAUTH is set, load rate from 0 balance
	   tier of the IX array.
	*/
	if dep.index'="",dep.irn="" do { quit:ER
		new BALINT,IRCB,MAXACR,PAR,RATE

		// Does not apply if accruing at segment level
		if dep.segflg,'dep.segacr quit

		set IRCB=dep.ircb
		set MAXACR=dep.maxacr
		do {
			if IRCB=1 set BALINT=dep.bal quit
			if IRCB=2 set BALINT=dep.bal-dep.intavl quit
			if IRCB=3 set BALINT=dep.balcol quit
			if IRCB=4,dep.bal S BALINT=dep.salesprc quit
			set BALINT=0
			}
		if MAXACR'="",BALINT>MAXACR set BALINT=MAXACR

		/* Define parameters for rate calculation:
		IX array not fully loaded; use teaser processing; coming in
		from BTTCORE; perform rounding; perform limit checks. */
		set PAR("IXLOAD")=0
		set PAR("NOTSER")=1	
		set PAR("IPMODE")=1	
		set PAR("ROUND")=0	
		set PAR("LIMIT")=1

		do CTL^UINDX(.dep,dep.ichld,BALINT,.PAR)

		if ER&($P($G(IX(dep.index)),"|",14)) do {
			new ERDT
			set (ER,RM)=""
			set ERDT=""
			set ERDT=$O(IX(dep.index,ERDT))
			quit:ERDT=""
			set RATE=$P(IX(dep.index,ERDT,0),"|",1)
			}
		if RATE'?.N.1".".N do CTL^UINDX(.dep,ERDT,BALINT,.PAR)
		if 'ER set dep.irn=RATE
		}

	/* 
	If Accrued Withholding Tax Index is defined call into AWT^DEPBW to 
	get the tax rate.
	*/
	if dep.awti'="" do { quit:ER

		// Not applied for segmented accounts
		if dep.segflg quit
	
		set dep.awtr=$$AWT^DEPBW(dep.awti,0,,dep.irn,%SystemDate) quit:ER 
		}
	quit

vbu30 // Trigger BU_LSP - Before Update for column Lease Sec.Proc.

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	---- Revision History --------------------------------------------
	
	  07/24/00 - VETSENM - 40799
	  Error message 4194 has been replaced by error message 1259.            	  
	 
	  06/30/00 - VETSENM - 40799
	  Add code to quit if LSP flag is 0 or null.          	  

										02/24/00 - VETSENM - 35995
																				This new trigger will be created to verify the following:
																				LAFM has been specified if LSP is Y.
																				OBORIRP has been specified if LAFM is 1, 2, 4 or 5. 
																				IEP has been specified if LAFM is 3, 4 or 5.
																				LAFTFR is a valid account (exists in ACN and 
																				the status is not closed) if LSP is Y
	                        		
	*/
								if 'dep.lsp quit 

	if (dep.lsp=1),(dep.lafm="") do Runtime.setErrMSG("DEP",4218) if ER quit
	if (dep.lafm=1)!(dep.lafm=2)!(dep.lafm=4)!(dep.lafm=5),(dep.oborirp="") do Runtime.setErrMSG("DEP",4198) if ER quit
	if (dep.lafm=3)!(dep.lafm=4)!(dep.lafm=5),(dep.iep="") do Runtime.setErrMSG("DEP",4195) if ER quit
	
								new XCID,xlsp,status,rcid
	set XCID=dep.laftfr
	set xlsp=dep.lsp
	
	;set rcid=Db.getOneRow("CID","DEP","XCID")
 	set status=Db.getOneRow("STAT","DEP","XCID")
 	if (status="")!(status=4),(xlsp=1) do Runtime.setErrMSG("DEP",1259,XCID) if ER quit
	
	quit

vbu31 // Trigger BU_MDT_TRM - Before Update Maturity Date or Term

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	if dep.trm'="",dep.mdt="" do { quit:ER 		
		new begin,dlr,mdt,odt
		// Find beginning date which is equal to later of opening date and last renewal date.
		set odt=dep.odt 
		set dlr=dep.dlr
		set begin=$S(dlr'<$S(odt'="":odt,1:dlr):dlr,1:odt)
	
		// Compute maturity date

		set mdt=$$EXT^UMDT(dep.trm,begin,0,dep.busopt,dep.nbdc) quit:ER 
		set dep.mdt=mdt
		}
	quit
	

vbu32 // Trigger BU_MMDA4 - Before Update MMDA4 (Regulation D Freq)

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	;---- Revision History ------------------------------------------------
	; 10/18/00 - SCOTTC - 42039
	;            Modify check for DEP.REGD=5,DEP.MMDA4="". Changed it to test
	;            to see if it is null rather that I 'DEP.MMDA4.
	;
	; 07/11/00 - SCOTTC - 40823
	;            Add code to set next cycle date if null
	;----------------------------------------------------------------------
	;
	if dep.regd=5,(dep.mmda4="") do Runtime.setErrMSG("DEP",4295) if ER quit
	// Regulation D processing - Set next cycle date        CPS 7/6/00
	if (dep.regd=5),(dep.mmda4),'(dep.mmda3) do {
 	new NJD
 	set NJD=$$FRSTDATE^ACNFUNCS(TJD,dep.mmda4,1) quit:ER
 	set dep.mmda3=NJD
								}
	
	quit

vbu33 // Trigger BU_MT320 - Before Update MT320 Trigger

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	
								/*
								---------------Revision History---------------------------------------

	09/16/05 - KELLYP - CR 17050
		   Modified to fix several logic issues.  Also removed pre-
		   2003 revision history.
								*/

	type public Boolean ER

	if dep.mt320=1,dep.mt320a.isNull() do { quit:ER
		
		type RecordCIF cif=Db.getRecord("CIF","ACN=:dep.acn")

		// SWIFT Address must be defined		
		if cif.swiftadd.isNull(),cif.mt320a.isNull() do Runtime.setErrMSG("DEP","4029") quit:ER
		}

								quit

vbu34 // Trigger BU_MT900 - Before Update trigger for MT900 column.

	type public RecordDEP dep
	do dep.setAuditFlag(1)
								/*
								---------------Revision History---------------------------------------

	09/16/05 - KELLYP - CR 17050
		   Modified to fix several logic issues.  Also removed pre-
		   2003 revision history.
								*/

	type public Boolean ER

								if dep.mt900=1,dep.mt900a.isNull() do { quit:ER

		type RecordCIF cif=Db.getRecord("CIF","ACN=:dep.acn")
		
		// SWIFT Address must be defined
		if cif.swiftadd.isNull(),cif.mt900a.isNull() do Runtime.setErrMSG("DEP","4029") quit:ER
		}

	quit

vbu35 // Trigger BU_MT910 - Before Update trigger for MT910 column.

	type public RecordDEP dep
	do dep.setAuditFlag(1)

								/*
								---------------Revision History---------------------------------------
	09/16/05 - KELLYP - CR 17050
		   Modified to fix several logic issues.  Also removed pre-
		   2003 revision history.
								*/

	type public Boolean ER

								if dep.mt910=1,dep.mt910a.isNull() do { quit:ER

		type RecordCIF cif=Db.getRecord("CIF","ACN=:dep.acn")
		
		// SWIFT Address must be defined
		if cif.swiftadd.isNull(),cif.mt910a.isNull() do Runtime.setErrMSG("DEP","4029") quit:ER
		}

								quit

vbu36 // Trigger BU_MT940 - Before Update trigger for MT940 column.

	type public RecordDEP dep
	do dep.setAuditFlag(1)
								/*
								---------------Revision History---------------------------------------

	09/16/05 - KELLYP - CR 17050
		   Modified to fix several logic issues.  Also removed pre-
		   2003 revision history.
								*/

	type public Boolean ER
	
	if dep.mt940=1,dep.mt940a.isNull() do {

		type RecordCIF cif=Db.getRecord("CIF","ACN=:dep.acn")

		// SWIFT Address must be defined
		if cif.swiftadd.isNull(),cif.mt940a.isNull() do Runtime.setErrMSG("DEP","4029") quit:ER
		}

	quit

vbu37 // Trigger BU_MT942TIME - Before Update trigger for MT942 column

	type public RecordDEP dep
	do dep.setAuditFlag(1)
								/*
								---------------Revision History---------------------------------------
	09/19/05 - KELLYP - CR 17050
		   Modified to correct logic errors throughout trigger
		   and removed pre-2003 revision history.
								*/

	type Date TMPDT
	type Time GTIME1,GTIME2,TMPTM

	if 'dep.mt942 quit

	type RecordCIF cif=Db.getRecord("CIF","ACN=:ACN")

	// SWIFT Address must be defined
	if dep.mt942a.isNull(),cif.mt942a.isNull(),cif.swiftadd.isNull() do Runtime.setErrMSG("DEP","4029") quit:ER

	// Use CIF level MT942 generation time if not defined at account level
	if dep.mt942g1.isNull() set GTIME1=cif.mt942g1
	else  set GTIME1=dep.mt942g1
	
	if dep.mt942g2.isNull() set GTIME2=cif.mt942g2
	else  set GTIME2=dep.mt942g2
		
	// GTIME1 has not passed
	if GTIME1>%CurrentTime do {
		set TMPDT=%SystemDate
		set TMPTM=GTIME1
		}
		
	// GTIME1 has passed but GTIME2 hasn't
	else  if GTIME1<%CurrentTime,GTIME2>%CurrentTime do {
		set TMPDT=%SystemDate
		set TMPTM=GTIME2
		}
		
	// GTIME1 and GTIME2 have both passed
	else  if GTIME1<%CurrentTime,GTIME2<%CurrentTime do {
		set TMPDT=%SystemDate+1
		set TMPTM=GTIME1
		}

	if 'TMPDT.isBusDate(dep.nbdc) do {
		set TMPDT=TMPDT.nextBusDate(1,dep.nbdc)
		set TMPTM=GTIME1
		}
			
	// Create the SW942 record
	type RecordSW942 sw942=Class.new("RecordSW942","SWDATE=:TMPDT,SWTIME=:TMPTM,CID=:dep.cid")
	set sw942.status=0
	do sw942.save()

	quit

vbu38 // Trigger BU_MT950 - Before Update trigger for column MT950.

	type public RecordDEP dep
	do dep.setAuditFlag(1)
								/*
								---------------Revision History---------------------------------------

	09/16/05 - KELLYP - CR 17050
		   Modified to fix several logic issues.  Also removed pre-
		   2003 revision history.
								*/

	type public Boolean ER

								if dep.mt950=1,dep.mt950a.isNull() do {
		
		type RecordCIF cif=Db.getRecord("CIF","ACN=:dep.acn")

		// SWIFT Address must be defined
		if cif.mt950a.isNull(),cif.swiftadd.isNull() do Runtime.setErrMSG("DEP","4029") quit:ER
		}
	
	quit

vbu39 // Trigger BU_NEGIPF - Before Update Neg Int Posting Freq

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
											--------------------------------------------------------------------
											Revision History
										 
	   08/02/06 - ratht - CR 19215
	   	      The value of NJD is kept in a loop till NJD not greater 
	   	      than current date where NJD is being set by procedure UFRE.
	   	      Added a condition by checking that the updation of columns 
	   	      IPLD and NEGIPLD is being done by SYSTEM ONLY
	   	      
	   04/03/02 - KELLYP - 49129
		      Modified the check that determines whether or not NEGINP
		      is in the past when generating a new NEGINP.  This check
		      was previously not considering CUVAR.INTPOS.

	   10/25/00 - SMITHC - 42068:1
		      Created trigger to handle maintenance of Negative 
		      Interest posting Frequency (consistent with other 
		      frequency triggers).
	*/

	/* Negative Interest Posting Frequency only applicable when Negative 
	   Interest Posting Option posts interest separately */
	if dep.negipf'="",dep.negipo=2 do { quit:ER
		new cuvar,INTPOS,NJD

		// 49129 - Get INTPOS (BOD/EOD Interest Posting Indicator)
		type RecordCUVAR cuvar=Db.getRecord("CUVAR","*")
		set INTPOS=cuvar.intpos

		// 49129 - Modified "if" below to consider INTPOS
		// Default next date if not defined or in the past
		if dep.neginp<(%SystemDate+INTPOS-1) do { quit:ER
			// 49129 - Reset INTPOS for CTL parameter of FRSTDATE
			set INTPOS=INTPOS#2	
			set NJD=$$FRSTDATE^ACNFUNCS(dep.odt,dep.negipf,INTPOS) quit:ER
			set dep.neginp=NJD
			}
		/* Only change by system is allowed for this column.
		  Message text: Change to column ~p1 not allowed  */
		  
		if (dep.negipld.oldVal'=dep.negipld),('dep.isChanged("NEGIPLD","SYSTEM")) do Runtime.setErrMSG("DEP",412,"DEP.NEGIPLD") quit:ER

		// Default last date if not defined
		if dep.negipld="" do { quit:ER
			set NJD=dep.neginp
			for  set NJD=$$NJD^UFRE(NJD,dep.negipf,,"1") quit:ER  do { quit:NJD'>%SystemDate
				if NJD<dep.odt set NJD=dep.odt
				}
			set dep.negipld=NJD
			}
		}

	quit

vbu40 // Trigger BU_ODT - Before Update Date Account Opened

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   ---- Revision History ----------------------------------------------
	
	   12/12/01 - PARRAS - 47926
	   Don't allow the change of the opening date to the future if the
	   account is funded. It will cause an out-of-balance.
	
	*/

	if dep.odt>%SystemDate,dep.bal>0 do Runtime.setErrMSG("DEP",8090) quit
	quit

vbu41 // Trigger BU_ODTERM - Before Update - Overdraft Term

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	if (dep.odterm.oldVal'=dep.odterm),dep.odterm'="" do {
		if 'dep.odstart do {
			// No start date - only need to verify frequency
			new TRM
			set TRM=dep.odterm
			do ^UMDT
			}
		else  do {
			// Cannot change overdraft term if expiration date precedes system date

			if (dep.odexp<%SystemDate) do Runtime.setErrMSG("DEP",2431) if ER quit 
			new EXPDT
			set EXPDT=$$EXT^UMDT(dep.odterm,dep.odstart)-1       // Recalulate exp date
			// Cannot change od. term if new expiration date will precede system date

			if (EXPDT<%SystemDate) do Runtime.setErrMSG("DEP",2441) if ER quit 
			set dep.odexp=EXPDT
			}
		}
	
	quit
	

vbu42 // Trigger BU_PBKBAL - Before Update Passbook Balance

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	
	if 'dep.pbi quit 
	if dep.pbkbal="" do {
		if dep.pbkbal'=0 set dep.pbkbal=0
		if dep.pbkld'=%SystemDate set dep.pbkld=%SystemDate
		}
	quit
	

vbu43 // Trigger BU_PROV - Before update of Provision fields

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
 	---- Revision History ------------------------------------------------
	
	04/19/05 - TITOVE - CR 15089
		   Modified as part of DBI2 project.	   

	*/

	type public Number ER

	// Data required in Data Item ~p1
	if dep.racovr.isNull(),(dep.provoamt!(dep.provopct)) do Runtime.setErrMSG("DEP",7531,"DEP.RACOVR") if ER quit 

	// Ovr provision amount and ovr provision percentage not allowed
	if dep.provoamt,dep.provopct do Runtime.setErrMSG("DEP",2759) if ER quit 

	quit
	

vbu44 // Trigger BU_SCHDEP - Scheduled Deposits

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	---------- Revision History -----------------------------------------

	01/15/01 - AHMEDS - 43469
	Added checks for error message 2476.
	---------------------------------------------------------------------
	*/
	//
	// Cannot update the data items CUMDEP, SCHDEPA, SCHDEPF, SCHDEPLD,
	// SCHDEPND and SCHPROC,TOTNOSDP if they are not NULL.

	// The following data items will not be updated if already defined.
	// Cannot update field ~p1
	if dep.isChanged("CUMDEP"),dep.cumdep.oldVal'="" do Runtime.setErrMSG("DEP",2476,"CUMDEP") quit:ER 
	if dep.isChanged("SCHDEPA"),dep.schdepa.oldVal'="" do Runtime.setErrMSG("DEP",2476,"SCHDEPA") quit:ER
	if dep.isChanged("SCHDEPF"),dep.schdepf.oldVal'="" do Runtime.setErrMSG("DEP",2476,"SCHDEPF") quit:ER
	if dep.isChanged("SCHDEPLD"),dep.schdepld.oldVal'="" do Runtime.setErrMSG("DEP",2476,"SCHDEPLD") quit:ER
	if dep.isChanged("SCHDEPND"),dep.schdepnd.oldVal'="" do Runtime.setErrMSG("DEP",2476,"SCHDEPND") quit:ER
	if dep.isChanged("SCHPROC"),dep.schproc.oldVal'="" do Runtime.setErrMSG("DEP",2476,"SCHPROC") quit:ER
	if dep.isChanged("TOTNOSDP"),dep.totnosdp.oldVal'="" do Runtime.setErrMSG("DEP",2476,"TOTNOSDP") quit:ER

	//Can not update the data items NSCDEPDD, NSCHDEPS and SCHDEPN
	//Cannot update field ~p1
	if dep.isChanged("NSCDEPDD") do Runtime.setErrMSG("DEP",2476,"NSCDEPDD") quit:ER
	if dep.isChanged("NSCHDEPS") do Runtime.setErrMSG("DEP",2476,"NSCHDEPS") quit:ER
	if dep.isChanged("SCHDEPN") do Runtime.setErrMSG("DEP",2476,"SCHDEPN") quit:ER
	//
	quit

vbu45 // Trigger BU_SCLD - Before Update Service Charge Last Date

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	if dep.anltyp'=1 quit 

	/* If the system is updating SCLD and there are no offset days, then there
				is no need to define the analysis offset end date, because when the
				offset days is 0, then the necessary analysis offset end process was 
				done during the service fee analysis process.   */

	if dep.isChanged("SCLD","SYSTEM"),'dep.anloffdy quit

	//if service fee last date is not defined, use todays date

	if dep.scld set firstdt=dep.scld,date=dep.scnd
	else  set firstdt=%SystemDate,date=$$NJD^UFRE(firstdt,dep.scfre,.AF) quit:ER
	
	/* Find the end date for analysis adjustment period.
				Per the recommendation by utility UNBD, the start date variable firstdt 
				will have a 1 added to insure the next business date is returned.  When
				anloffdy is 0, the next date is the same as the date in firstdt.  */

	if dep.anloffdy>0 set NJD=$$NBD^UNBD(firstdt+1,dep.anloffdy,0,"IBS") quit:ER
	else  set NJD=firstdt

 if dep.isChanged("SCLD","SYSTEM") do	{     // System changes
	 
	/* allow that offset period based on business calender
	   may generate a date after the scheduled next service 
	   fee date. If it does, set the Analysis offset days to
	   the day before the service fee will be calculated  */

	if dep.scnd'>NJD set NJD=(dep.scnd-1)
	}

	// The anlaysis offset end date must be less than SCND
	if date'>NJD do Runtime.setErrXBAD("DEP","ANLOFF") quit:ER

	/* If within the analysis offset period, the analysis offset end date
				must be greater than or equal to today's system date. 

				Else we are not within the analysis offset period, and if SCLD is not 
				being changed by the system, then anloffdy is being changed by the user, 
				and we don't want to update anloffed outside of the offset period as it 
				may have already be processed, and resetting anloffed may cause it to be 
				reset to run again.  */

	if (%SystemDate'<firstdt),(%SystemDate'>dep.anloffed) do { quit:ER
	if (NJD<%SystemDate) do Runtime.setErrMSG("DEP",4326,"DEP.ANLOFFED")
	}
	else  if 'dep.isChanged("SCLD","SYSTEM") quit

	set dep.anloffed=NJD

	quit

vbu46 // Trigger BU_SEGACR - Before Update Segment Accrual Option

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	  --------------- Revision History ------------------------------------------------
	
	   11/09/98 - CANFIELDS - 28591
		Moved error from AU_SEGACR to BU_SEGACR
	*/
	
	//Segment Accrual Option cannot be modified

	do Runtime.setErrXBAD("DEP",233) quit:ER 
	quit
	

vbu47 // Trigger BU_SEGFLG - Before Update Segments in Use Flag

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	
	/*
	  Segments in Use Flag cannot be modified on the account level
	  Change to column ~p1 not allowed
	*/

	do Runtime.setErrMSG("DEP",412,"DEP.SEGFLG") if ER quit 
	 
	quit
	

vbu48 // Trigger BU_SGNCRD - Set SGNCRDCHGDT when Sign Card Values Ch

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	09/28/01 - myersk - 47550 QAR 1
		   Created this trigger to correctly populate DEP.SGNCRDCHGDT
	*/
	set dep.sgncrdchgdt=%SystemDate
	quit

vbu49 // Trigger BU_STAT - Before update of status

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	   ----------------- Revision History ----------------------------------

	   03/09/06 - KELLYP - CR 19958
		Modified to remove the third parameter from the call to 
		REMOVE^PROCEFT.  Also removed pre-2003 revision history.

	*/
	
	// Set GCR Code to zero when status is not active

	if dep.stat,dep.gcrs set dep.gcrcd=0
	
	new exe,vsqlz,I
	set ER=0
	if dep.stat=4 do { quit:ER 
		if $$^SCARND(dep.bal,0,"","",2) do Runtime.setErrMSG("DEP",2784,dep.bal) quit:ER 
		if $$^SCARND(dep.posacr,0,"","",2) do Runtime.setErrMSG("DEP",2783,dep.posacr) quit:ER 
		if $$^SCARND(dep.negacr,0,"","",2) do Runtime.setErrMSG("DEP",2783,dep.negacr) quit:ER 
	
		new XCID
		set XCID=CID

		// Check for linked ODP loans
		new XTYPE,data,ltydata,sum,DATA
		type ResultSet rs=Db.select("ODACN","DEPODP","CID=:XCID")
		if 'rs.isEmpty() while rs.next() do { 
			new exe,vsql,cls                    	
			set DATA=rs.getCol(1)				
			set cls=Db.getOneRow("CLS","ACN","DATA")    				
			if cls="L" set data=Db.getOneRow("BAL,STAT,TYPE","LN","DATA")
			else  set data=Db.getOneRow("BAL,STAT,TYPE","DEP","DATA")
			if $P(data,$C(9),1) do Runtime.setErrMSG("DEP",8244) if ER quit         // Force error
			if $P(data,$C(9),2)=4 quit          					// Closed
			set XTYPE=$P(data,$C(9),3)
			set ltydata=Db.getOneRow("SWPF","PRODDFTD","XTYPE")	
			if ltydata do Runtime.setErrMSG("DEP",8244) if ER quit 
			}
	
		if ER quit 
		if dep.grp="ESC" do {
			//Make sure escrow is not still being billed

			new I,bildata,data,SEL

			// AREF not defined
                        // ESC not defined	
			if dep.aref=""!(dep.esc="") quit      	     	

			type ResultSet rs=Db.select("SCHSEQ,PE01EA,PE01AD,PE02EA,PE02AD,PE03EA,PE03AD,PE04EA,PE04AD,PE05EA,PE05AD,PE06EA,PE06AD,PE07EA,PE07AD,PE08EA,PE08AD,PE09EA,PE09AD,PE10EA,PE10AD,PE11EA,PE11AD,PE12EA,PE12AD,PE13EA,PE13AD,PE14EA,PE14AD,PE15EA,PE15AD,PE16EA,PE16AD,PE17EA,PE17AD,PE18EA,PE18AD,PE19EA,PE19AD,PE20EA,PE20AD","LNBIL1","CID=:XCID","SCHSEQ DESC")
			while rs.next() do { quit:ER
				set bildata=rs.getRow()				
				for I=1:1:20 do { quit:ER
					if $P(bildata,$C(9),I*2)'=dep.aref quit 
					if $P(bildata,$C(9),I*2+1)>0 do Runtime.setErrMSG("DEP",8242) if ER quit 
					}
				}
			}

		if ER quit 
		if dep.dtc'=%SystemDate set dep.dtc=%SystemDate
		set dep.bal.journal=0
		set dep.bal=0
		set dep.posacr.journal=0
		set dep.posacr=0
		set dep.negacr.journal=0
		set dep.negacr=0
		do REMOVE^PROCEFT(XCID,%SystemDate)         // remove standing payment orders for EFT.
		}
	
	/*
	   If the account is being reopened reset next dates for fields that we may
	   have passed. Null date closed and set accrial processed flag to yesterday.
	*/

	if dep.stat.oldVal=4 do {
		//Date Closed
		new ARND,FRE,OV,XCID,XCLS,XGRP,XTYPE
		if dep.dtc'="" set dep.dtc=""

		//accrual processed field

		if dep.acs'=(%SystemDate-1) set dep.acs=%SystemDate-1
	
		//Interest Compounding next date

		set ER=0
		set FRE=dep.icf 
		if FRE'="" do {
			set OV=dep.inc if OV'<%SystemDate quit 
			for  set OV=$$NJD^UFRE(OV,FRE) quit:OV'<%SystemDate!(ER) 
			if 'ER if dep.inc'=OV set dep.inc=OV
			}
	
		//  Int next posted
		// not applicable if segmented account accruing at seg level //abv-06/07/02

		if dep.segflg,'dep.segacr set dep.inp=""
		else  do {
			set ER=0
			set FRE=dep.ipf 
			if FRE'="" do {
				set OV=dep.inp if OV'<%SystemDate quit 
				for  set OV=$$NJD^UFRE(OV,FRE) quit:OV'<%SystemDate!(ER) 
				if 'ER if dep.inp'=OV set dep.inp=OV
				}
			}
	
		//  Neg Int next posted

		set ER=0
		set FRE=dep.negipf 
		if FRE'="" do {
			set OV=dep.neginp if OV'<%SystemDate quit 
			for  set OV=$$NJD^UFRE(OV,FRE) quit:OV'<%SystemDate!(ER) 
			if 'ER if dep.neginp'=OV set dep.neginp=OV
			}
	
		//  Avail Int Next Posting Date         //abv - 6/7/02
		//  not applicable if segmented account accruing at seg level

		if dep.segflg,'dep.segacr set dep.aiinp=""
		else  do {
			set ER=0
			set FRE=dep.aiipf 
			if FRE'="" do {
				set OV=dep.aiinp if OV'<%SystemDate quit
				for  set OV=$$NJD^UFRE(OV,FRE) quit:OV'<%SystemDate!(ER)
				if 'ER if dep.aiinp'=OV set dep.aiinp=OV
				}
			}
			
		//  Service change next date

		set ER=0
		set FRE=dep.scfre 
		if FRE'="" do {
			set OV=dep.scnd if OV'<%SystemDate quit 
			for  set OV=$$NJD^UFRE(OV,FRE) quit:OV'<%SystemDate!(ER) 
			if 'ER if dep.scnd'=OV set dep.scnd=OV
			}
	
		//  Interest check next date

		set ER=0
		set FRE=dep.intchkfre 
		if FRE'="" do {
			set OV=dep.intchknd if OV'<%SystemDate quit 
			for  set OV=$$NJD^UFRE(OV,FRE) quit:OV'<%SystemDate!(ER) 
			if 'ER if dep.intchknd'=OV set dep.intchknd=OV
			}
	
		//  Money Market cycle next date

		set ER=0
		set FRE=dep.mmda4 
		if FRE'="" do {
			set OV=dep.mmda3 if OV'<%SystemDate quit 
			for  set OV=$$NJD^UFRE(OV,FRE) quit:OV'<%SystemDate!(ER) 
			if 'ER if dep.mmda3'=OV set dep.mmda3=OV
			}
	
		//Interest change next date and last date

		set ER=0
		set FRE=dep.intfre 
		if FRE'="" do {
			set OV=dep.ichnd if OV'<%SystemDate quit 
			for  set OV=$$NJD^UFRE(OV,FRE) quit:OV'<%SystemDate!(ER) 
			if 'ER if dep.ichnd'=OV set dep.ichnd=OV
			set OV=$$NJD^UFRE(OV,FRE,,1)
			if 'ER if dep.ichld'=OV set dep.ichld=OV
			}

		// Avail Int change next date and last date     //abv - 6/7/02

		set ER=0
		set FRE=dep.aiintfre 
		if FRE'="" do {
			set OV=dep.aiichnd if OV'<%SystemDate quit
			for  set OV=$$NJD^UFRE(OV,FRE) quit:OV'<%SystemDate!(ER)
			if 'ER if dep.aiichnd'=OV set dep.aiichnd=OV
			set OV=$$NJD^UFRE(OV,FRE,,1)
			if 'ER if dep.aiichld'=OV set dep.aiichld=OV
			}

		// Delete DTJNA if it already exists so that user is able to reopen account
		set XCLS=dep.cls 
		set XGRP=dep.grp 
		set XTYPE=dep.type 
		set XCID=dep.cid
		set XTJD=%SystemDate
		if Db.isDefined("DTJNA","XTJD,XCLS,XGRP,XTYPE,XCID") do Db.delete("DTJNA","TJD=:XTJD AND CLS=:XCLS AND GRP=:XGRP AND TYP=:XTYPE AND CID=:XCID") Q:ER
		do Db.insert("DTJNA","TJD,CLS,GRP,TYP,CID,REOPN","%SystemDate,:XCLS,:XGRP,:XTYPE,:XCID,1") quit:ER
	
		// Bring any tickler's with a frequency up to date
	 	type ResultSet rs=Db.select("TKS,ARND,ARF,EXPD","TIKLACN","CID=:XCID")
 		if rs.isEmpty() quit
		while rs.next() do {
		   
			set ARND=rs.getCol(2)
			if ARND>%SystemDate quit 
			if ARND>(rs.getCol(4)) quit 
			set FRE=rs.getCol(3)
			set XTKS=rs.getCol(1)
			for  set ARND=$$NJD^UFRE(ARND,FRE) quit:ER!(ARND>%SystemDate) 
			if ER quit 
			do Db.update("TIKLACN","ARND=:ARND","CID=:XCID AND TKS=:XTKS")
			}
			//error will be defined if there is a freq error, allow integs to display
		set ER=0
		}
	quit
	

vbu50 // Trigger BU_TREXD - Before Update Teaser Rate and Expiration

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	  ---------------------------  Revision History ----------------------------------------------------------------------------
	   09/27/99 - ROYTENBERGE - 34627
		Added code to return error message if Promotional Rate
		Expiration Date is not greater than system date.
	*/

	if dep.trate'="",dep.trexd="" do Runtime.setErrMSG("DEP",2614) if ER quit
	if dep.trate="",dep.trexd'="" do Runtime.setErrMSG("DEP",2612) if ER quit 
	if '(dep.trexd.oldVal'=dep.trexd) quit 

	/*
	  Expiration Date should not be changed to null. The teaser rate expiration
	  date is needed to expire teaser rates when the beginning of day teaser
	  rate process (QUE047 - DEPTSR.M) is executed.
	*/

	if dep.trexd'="" quit 

	quit
	

vbu51 // Trigger BU_TYPE - Before Update Type

	type public RecordDEP dep
	do dep.setAuditFlag(1)

	/*
	  ----------------------- Revision History ------------------------------------------------

	   06/01/05 - KinI - 16153
		Removed comments regarding obsoleted GL filter functionality.
		Modified to comply with DBI standards.
		
	   11/17/98 - MAGERAM - 28591 - Segmented Account Creation
		Added an error check on product type maintenance that can
		only go segment to segment or non-segment to non-segment
	
	*/

	type public Boolean ER
	type Number XTYPE

	type RecordPRODDFTD proddftd = Db.getRecord("PRODDFTD","TYPE=:dep.type")

	set XTYPE = dep.type.oldVal
	type RecordPRODDFTD proddftdold = Db.getRecord("PRODDFTD","TYPE=:XTYPE")
	
	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL","TYPE=:dep.type")

	// Cannot change segmented account to non-segmented product
	if (dep.segflg = 1) & (proddftd.segflg '= 1) do Runtime.setErrMSG("DEP",3661) if ER quit
	
	// Cannot change non-segmented account to segmented product
	if ('dep.segflg) & (proddftd.segflg = 1) do Runtime.setErrMSG("DEP",3662) if ER quit
	
	// Be sure new type is still deposit class

	// Product type is not defined for this currency
	if (prodctl.cls = "") do Runtime.setErrMSG("DEP",2250) if ER quit 

	// Product class does not match product type
	if (prodctl.cls '= "D") do Runtime.setErrMSG("DEP",8472) if ER quit 
	
	// If type changes, change group automatically, if appropriate

	// Invalid GRP resulting from invalid change to TYPE
	if (proddftdold.grp = "ESC") , (proddftd.trb '= "ESC") do Runtime.setErrXBAD("DEP",179) quit:ER 
	else  if (proddftdold.grp '= "ESC") , (proddftd.grp = "ESC") do Runtime.setErrXBAD("DEP",179) quit:ER 

	if (dep.grp '= proddftd.grp) set dep.grp = proddftd.grp
	
	// Old product TRB should match new product type TRB	
	if (proddftdold.trb-proddftd.trb) do Runtime.setErrXBAD("DEP",180) quit:ER 
		
	quit
	

vbu52 // Trigger BU_USRESTAT - Before Update U. S. Residency Status

	type public RecordDEP dep
	do dep.setAuditFlag(1)
	/*
	  ------------ Revision History--------------------------------------------------------
	
	   08/16/99 - HAYMANP - 33049
		Added code to set NR based on the value of USRESTAT.
	*/
	
	if dep.usrestat=1 set dep.nr=1
	else  set dep.nr=0
	
	quit
	
