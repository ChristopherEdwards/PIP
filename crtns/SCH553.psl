SCH553(vhtid)	// Compiled from JOBSCH template

	/*
	PROCEDURE:  JOBSCH
	ORIG: MATTSON - 06/05/95
	DESC: Batch Job Scheduler Template

	---- Comments --------------------------------------------------------

	This procedure is never run independently.  It is used as a template
	by JOBMGR for the compilation of schedulers.

	Note:  Non-global scope variables used within the body of this
	procedure begin with the sentinal character 'v'.  This convention is
	used to avoid conflicts with application procedures that interface with
	this procedure.
		
	Note:  The arguments are used when the runtime routine is generated.

 	ARGUMENTS:

		. vhtid		Heavy thread ID		/TYP=T/REQ/MECH=VAL		
 	---- Revision History ------------------------------------------------
 	
 	05/22/05 - Erik Scheetz - 15677
 		   Modified top section to register the scheduler process in
 		   the PROCESSID table.
 		   
 	12/23/04 - RussellDS - CR13642
 		   Correct multiple type declarations to avoid new PSL warnings.
 		   
 		   Incorporate Profile 01 changes - Removed the  calls to JOBMON;
 		   these are now handled by the batch compiler (DBSBCH).  Also 
 		   removed variables vjobmon and vreccnt which are no longer used.
 		   
 	07/27/04 - RussellDS - CR11349
 		   Corrected scope issues to eliminate PSL warnings.
 		   
 		   Replaced new commands with type.

	04/26/02 - Dan Russell
		   Rewrote from M to PSL.

		   Removed history older than 1/1/2001.

	01/10/02 - Allan Mattson - 48839
		   Modified to always call $$INIT^JOBMON and CLOSE^JOBMON.
		   Previously, these were called only if 'vschrcnt' had a
		   value.

		   Modified the identifier passed to the Job Monitor from
		   '%FN' to 'vbatchid'.

	03/31/01 - Erik Scheetz - 46547
		   Modified top section to only call the scheduler exit
		   section if there is no error.  This way the ER flag will
		   be returned to the calling program.

	*/
	
	type Public Number ER,vmsgbufs,vthreads
	type Public String vbatchid,vpar1,vthr,vthrlvar,vx

	// Catch GT.M errors
	catch error {
		do ZE^UTLERR
		set ER=1
		}

	type Boolean vexit
	type Number verrcnt,vi
	type String verror,vjob,vprc,vstatus
	
	/*
	Register M process.  Note that an entry in PROCESSPID should already 
	exist for the current process.  This is a re-register of the 
	process as type BATCH and subtype SCH. As such, there is no 
	unregister call (CLOSE^IPCMGR) since this will be handled by the 
	calling routine (e.g. QUEPGM or SCADRV0).
	*/

	do REGISTER^IPCMGR("BATCH","SCH")

	// Execute scheduler initialization
	do schinit if $G(ER) quit

	// Initialize JOBCONTROL for this heavy thread id.  Use a structured do
	// to protect HTHRID since can't be lower case as host variable.
	do {
		new HTHRID
		set HTHRID=vhtid
		do Db.delete("JOBCONTROL","HTHRID=:HTHRID")

		type RecordJOBCONTROL jobctrl=Class.new("RecordJOBCONTROL")
		set jobctrl.hthrid=vhtid
		set jobctrl.infotype="header"
		set jobctrl.infonum=1
		set jobctrl.info=%ProcessID_$C(9)_%CurrentDate_","_%CurrentTime
		do jobctrl.bypassSave()
	}

	// Save variables to pass on to threads
	if vthrlvar'="" do {
		type RecordJOBCONTROL jobctrl=Class.new("RecordJOBCONTROL")
		set jobctrl.hthrid=vhtid
		set jobctrl.infotype="variables"
		set jobctrl.infonum=1
		set jobctrl.info=$$VSAV^PBSUTL(vthrlvar)
		do jobctrl.bypassSave()
	}

	// Fill message buffers
	for vi=1:1:vmsgbufs set vexit=$$exchmsg(.vpar1) quit:vexit

	// Define thread entry point, thread process name(s)
	set vjob="^"_vthr_"("""_vhtid_""")"
	set vprc=$P(vhtid,"_",2)_"_"
	set verror=0

	// Job processes
	for vi=1:1:vthreads do { quit:verror
		set vx=$$^%ZJOB(vjob,"PRO="_vprc_vi,1)
		if 'vx s verror=1 do err("JOBCREATE") if vi=1 set ER=1
	}

	// Quit if error
	if $G(ER) do close quit

	// Exchange messages with threads as buffers become available
	if 'vexit for  set vexit=$$exchmsg(.vpar1) quit:vexit

	// Signal threads to shutdown
	set vstatus=$$SCSHTDWN^%HTAPI
	if vstatus'="" do err(vstatus)

	set vexit=0
	set verrcnt=0
	for  do { quit:vexit
		// Get final thread replies
		set vstatus=$$SCGETMSG^%HTAPI(.vpar1)
		if vstatus="" do:vpar1'="" schpost quit

		if vstatus="HT_GETDONE" set vexit=1 quit
		if vstatus="HT_TIMEOUT" set vexit=$$exit(vstatus,.verrcnt) quit

		do err(vstatus) set vexit=1,ER=1
	}

	/* Wait for threads to shutdown.  If there are no threads still active
	   and the threads have not shutdown gracefully, log the error and
	   continue with the scheduler shutdown.
	*/

	if '$G(ER) do {
		type String HTHRID

		for  hang 10 quit:'$$active

		set HTHRID=vhtid
		type ResultSet jobctlrs=Db.select("INFONUM","JOBCONTROL","HTHRID=:HTHRID AND INFOTYPE='threads'")
		// If all threads done, execute scheduler exit, otherwise,
		// indicate error and exit without doing scheduler exit
		if jobctlrs.isEmpty() do schexit quit
		do err("JS_SHUTDOWN",1) set ER=1
	}

	do close
	quit


close	//Private - Perform cleanup before exiting the routine

	type Public String vhtid

	type String HTHRID

	// Delete Job Sceduler control file
	set HTHRID=vhtid
	do Db.delete("JOBCONTROL","HTHRID=:HTHRID")
	quit


exchmsg(vpar1)	//Private - Exchange messages (scheduler send/thread reply)
	/*
	ARGUMENTS:
		. vpar1	Scheduler message		/TYP=T/REQ
							/MECH=REFNAM:RW
	RETURNS:
		. $$	Completion flag			/TYP=L
	*/

	type Boolean vexit
	type Number verrcnt
	type String vpar2,vstatus

	set vpar2=""
	do schexec					// Scheduler exec
	if vpar1="" quit 1				// Signal to exit

	set vexit=0
	set verrcnt=0
	for  do { quit:vexit!(vstatus="")
		// Place message into available buffer; return reply
		set vstatus=$$SCSNDMSG^%HTAPI(vpar1,.vpar2)
		if vstatus="" do { quit
			if vpar2'="" do {
				type String vpar1=vpar2
				do schpost
			}
		}

		if vstatus="HT_TIMEOUT" set vexit=$$exit(vstatus,.verrcnt)
		// status will be HT_NOSCHINIT,HT_SHUTDOWN
		else  do err(vstatus) set vexit=1
	}

	quit vexit


exit(STATUS,ERRCNT)	//Private - Test if procedure should exit (verrcnt>10)
	/*
	ARGUMENTS:
		. STATUS	Status returned from	/TYP=T/REQ/MECH=VAL
				^%HTAPI
		. ERRCNT	Error count		/TYP=N/REQ/MECH=REF:RW
				Returned incremented by one

	RETURNS:
		. $$	Exit flag			/TYP=L/LEN=1
			0 = No  (Do not exit)
			1 = Yes (exit)

	----------------------------------------------------------------------
	If there is at least one valid thread process, do not set the exit
	flag.  Note that there is some risk that the threads may be in a
	loop and the scheduler will never complete because the message
	buffers are not available to place additional messages.
	*/

	if STATUS="HT_TIMEOUT",$$active quit 0

	// Increment the error counter; if greater than 10, log the error
	// and set the abort flag.  Otherwise do not set the abort flag.

	set ERRCNT=ERRCNT+1
	if ERRCNT<11 quit 0
	do err(STATUS,1)
	quit 1


err(ET,%htdata)	//Private - Log error
	/*
	ARGUMENTS:
		. ET		Error type		/TYP=T/REQ/MECH=VAL
		. %htdata	Log buffer data		/TYP=L/NOREQ/MECH=VAL
	*/

	if $G(%htdata) do schdata(.%htdata)
	do ^UTLERR
	quit


schdata(DATA)	//Private - Scehduler status/buffer data
	/*
	ARGUMENTS:
		. DATA	Scheduler status/buffer data	/TYP=ARRAY/REQ
							/MECH=REFARR:W
	*/
	
	type Boolean EXIT
	type Number BUFNO
	type String STATUS,X()

	set STATUS=$$SCSTAT^%HTAPI(.DATA)

	if STATUS'="" do err(STATUS)

	set EXIT=0
	set BUFNO=0
	for  set STATUS=$$SCBUFDAT^%HTAPI(BUFNO,.X) do { quit:EXIT
		if STATUS'="" do err(STATUS) set EXIT=1 quit
		set BUFNO=X("bufno") if BUFNO=0 set EXIT=1 quit
		set DATA("BUF",BUFNO,X("msgstat"))=X("thrpid")_"|"_X("data")
	}

	quit


active()	//Private - Is one or more threads active? (0=No, 1=Yes)

	type Public String vhtid
	
	type Boolean ACTIVE
	type String HTHRID,LIST

	do ^%ZPID(.LIST)

	set HTHRID=vhtid
	type ResultSet jobctlrs=Db.select("INFONUM","JOBCONTROL","HTHRID=:HTHRID AND INFOTYPE='threads'")

	set ACTIVE=0
	if 'jobctlrs.isEmpty() while jobctlrs.next() do { quit:ACTIVE
		if $D(LIST(jobctlrs.getCol(1))) set ACTIVE=1
	}

	quit ACTIVE


schinit	//Private - Scheduler initialization
	type Public String vpar1,vpar2
	type Number verrcnt,vexit
	do vSCHINIT^BCHREGCC(.vpar1,.vpar2)
	quit
schexec	//Private - Scheduler execution
	type Public String vpar1,vpar2
	type Number verrcnt,vexit
	do vSCHEXEC^BCHREGCC(.vpar1,.vpar2)
	quit
schpost	//Private - Scheduler post-proc
	quit
schexit	//Private - Scheduler exit
	type Public String vpar1,vpar2
	type Number verrcnt,vexit
	do vSCHEXIT^BCHREGCC(.vpar1,.vpar2)
	quit
