BCHFEEUT	 	/* 
	-------Revision History-------------------------------------------
	
	08/13/07 - NATRAJAH - CR 28228
		   Modified CBRCB section, added the rs2.next method before
		   using rs2.getRow method, so that the system will point 
		   to the record fetched by db.select method.
		   
	05/11/07 - DHANALAKSHMI R - CR 27060
		   Modified the section BUMP to replace dep.bypassSave 
		   with save() function and remove the existing dep.save()
		   and setAuditFlag() before setting DEP.SCLD, to
		   call the filer routine after DEP.SCLD udpate.

	03/20/07 - DHANALAKSHMI R - CR 25648
		   Modified section BUILDTR, to incorporate the rate type
		   defined at the institution level being passed as a
		   parameter to the extrinsic function $$CONV^CRCDUTL
		   instead of passing the default rate type (1-Mid Rate).

	12/27/06 - MBUIM - CR 24545
		   Retrofit CR 3110 from Profile01
		   Added EVENTTRM and FINDETC sections to return the
		   unique transaction code for an event related fee and
		   return it to the calling program. 
	
	07/06/06 - RussellDS - CR22120
		   Modified ANLCHG section for ANLCHG=1 to save NETFWD and
		   NETFWDO even if there is no fee, which was supposed to
		   be action under CR35500, per Rob Hellauer.
	
	06/15/06 - RussellDS - CR21785
		   In TOTFEE section, added order by clause to select to
		   get the correct base fee.
		   
		   Cleaned up "variable declared more than once" warnings.
	
	06/14/06 - RussellDS - CR21756
		   In ERNALL section, we were not considering whether
		   DEP.ANLIDX had a value when using DEP.ANLFPR to
		   determine whether to use the accrual calculation or
		   a flat rate.  This caused use to use the flat rate
		   calculation even if DEP.ANLIDX was set.
	
	03/28/06 - RussellDS - CR20421
		   Modified CBRCB section fix undefined.
		   
		   Eliminated use of $D - deprecated PSL feature.
	
	08/25/05 - RussellDS - CR16911
		   Removed BALANCED section.  No longer needed.  This is
		   handled by TRNDRV.
	
		   Add currency code to ADJTTX, fixing issue on call
		   without dep record.
	
		   Eliminated PSL deprecated features.  Scope warnings
		   remain.
		   
		   Added public typing to FILE and FSN tags, as called
		   by compiled fee programs.
		   
		   Removed old revision history.

	03/30/05 - KELLYP - CR 13667
		   Removed ETCINI section.  This section was referencing
		   the TRN.CPGM data item which is being obsoleted.  Since 
		   this section is no longer called, it was removed.  Also
		   removed pre-2003 revision history.

	01/13/04 - RussellDS - CR 7514
		   Eliminate use of table SRVSTP (obsoleted) since overlapped
		   SRVDTL.  Replaced with use of SRVDTL.

	----------------------------------------------------------------- 
	*/

	quit

public %UID(PLTP)	// retrieve teller information

	/* 
	 
	 This routine will be used to retrieve teller information 
	 It will be called from batch def BCHUSEAGE_CR, BCHSRVFEE,
	 UANTIC
 	
	 KEYWORDS:	BATCH

	 ARGUMENTS:
			. PLTP	Control Variable 	/TYP=N/REQ/MECH=VAL
				
				0 - Service Fee 
				1 - Credit Useage

	*/

	set ER=0
	set SRC=$S(PLTP=0:"FEE",1:"UCR")
	do SOURCE^BCHSOURC("FEE",SRC,.%UserID,.BRCD,.%UserClass,.TSDRCID,.TSCRCID,.%ODP)
	if ER quit
 
	type RecordSCAU scau = Db.getRecord("SCAU","%UID")
	set DFTCID=scau.rocr

	quit


public PROC(CID,CTL,SRVDT,TranSet ts,RecordDEP dep)	//Process account
	
	/*
	ARGUMENTS:
	
		. CID	Account Number		/TYPE=N/REQ/MECH=VAL
		. CTL	Control Variable	/TYPE=N/NOREQ/MECH=VAL
	
			Position 1: 0 - Inquiry only (EXEC line tag)
	
			Call to SRVSUM refers to:
			Position 1:
			0 - Accumulate through TJD-1	SRVSUM accumulation
			1 - Accumulate through TJD	SRVFEE at SCND
	
			Position 2: 
			0 - Updates globals directly
			1 - Update FSN for SRV,SRV0,SRVD,SRVDTL  ^DEPCL
		
			Position 3:
			1 - Adjustment from EFD transaction - Restate Fees
	
		. SCND	Service Charge Next Date  /TYPE=D/NOREQ
	*/
	

	set PLTP=+$G(PLTP)

	new FEE,CC,SRV,SRV0,SRVSUM,X
	set ER=0
	set SRVDT=$G(SRVDT)
	if dep.stat=4 quit	

	kill FEE,%TRN
	if PLTP do {
		set USPL=dep.uspl		// Usage Credit Plan
		if USPL="" quit
		set SCFRE=dep.upfre		// Usage Credit Plan Frequency
		set SCND=dep.upndt		// Usage Credit Plan Next Date
		set SCLD=dep.upldt		// Usage Credit Plan Last Date
		set CC=dep.cc			// Cost Center
		do CALC(.dep,.USPL,.ts)
		}
	
	else  do {
		set FEEPLN=dep.feepln		// Service Fee Plan
		if FEEPLN="" set RM=$$^MSG(4979) do ERR quit
		set SCND=dep.scnd		// Service Charge - Next Date
		set SCLD=dep.scld		// Service Charge - Last Date
		set SCFRE=dep.scfre		// Servcie Fee Plan Frequency
		set CC=dep.cc			// Cost Center
		do CALC(.dep,.FEEPLN,.ts)
		}
	quit
	
	
CALC(RecordDEP dep,FEEPLN,TranSet ts) //	Process fees for a given FEEPLN
	//	Calculate fees for charge options 2 and 3
	
	new ANLSYS,COMPFEE,CRCD,DLYINV,GLSC,INT,NETERN,NLOFF,TYPE

	set ANLSYS=0

	/* 
	   Need to set ANLSYS flag for analysis accounts prior to 
	   SRVSUM, so SRVSUM array contains balance fields 
	   for earnings analysis even if FEEPLN does not have a 
	   balance for fee computation or fee category 3 charges.
	*/

	if (dep.anltyp=1)!(dep.anltyp=2)!(dep.anltyp=3) set ANLSYS=1	
	
	//ttx not passed in the 2nd param, it does not appear to have
	// been passed in prior generation either.
	do EXT^SRVSUM(.dep,,.SRVSUM,.FEEPLN,.TRNGRP,CTL,,$G(SRVDT),PLTP) if ER do ERR quit
	
	set CRCD=dep.crcd	// Define Currency Code prior to $$AVGINV call
	set TYPE=dep.type	// Define TYPE prior to $$AVGINV call

	/*
	  Calculate avg investible balances for SRV0 file definition.
	  These values are based on reserve % on product type for account
	  so we pass in a 0. For CCA these may be recalculated in CBRCB
	  section to use lead accounts product reserve percentage.
	*/
 
	set $P(SRVSUM,"|",7)=$$AVGINV($P(SRVSUM,"|",6),0)
	set $P(SRVSUM,"|",12)=$$AVGINV($P(SRVSUM,"|",11),0)

	/* 
	  Handle ANLRCB 9 need daily inv balances for SRV0, using lead account
	  reserve percentage (this is not a fee balance option so we can
	  just use lead account percentage). This balance field is
	  stored in SRV0 for lead account analysis rate base calculations.
	  If it is a lead account, need to pass in a 0 to use accounts type
	  and if anl type 2 or 3 pass in 1 to get ANLCID prod type.
	*/

	if dep.anltyp set DLYINV=$$AVGINV(dep.balcol,$S(dep.anltyp=1:0,1:1))

	set (ERNALL,ERNMET,FEEUNP,NETFWD,NETFWDO,NETFWDP,SYSADJ)=""

	set BASE=$P(FEEPLN(FEEPLN),"|",2)
	set FEEMIN=$P(FEEPLN(FEEPLN),"|",3)
	set FEEMAX=$P(FEEPLN(FEEPLN),"|",4)
	set FEEBAL=$P(FEEPLN(FEEPLN),"|",5)
	set CURFLAG=$P(FEEPLN(FEEPLN),"|",9)
	set PLANCUR=$P(FEEPLN(FEEPLN),"|",10)
	set PLANEXC=$P(FEEPLN(FEEPLN),"|",11)
	set FEEBALRM=$P(FEEPLN(FEEPLN),"|",17)
	set FEEBALRF=$P(FEEPLN(FEEPLN),"|",18)

	
	if $G(CURFLAG)&(PLANCUR'=CRCD) do {
		if BASE set BASE=$$CONV^CRCDUTL(BASE,CRCD,PLANCUR,PLANEXC)
		if FEEMIN set FEEMIN=$$CONV^CRCDUTL(FEEMIN,CRCD,PLANCUR,PLANEXC)
		if FEEMAX set FEEMAX=$$CONV^CRCDUTL(FEEMAX,CRCD,PLANCUR,PLANEXC)
		}
	
	/*
	Balance fields from SRVSUM and their usage and alignments for other
	files and arrays. Numbers are pieces of the array or balance
	options selected for ANLRCB or STBLFEEFB. 
	
	FILE	 SRVSUM   DEP     SRV		 SRV0  STBLFEEFB 
	DI		 ANLRCB	 CALBAL
	VARNAM   SRVSUM  ANLRCB  ERNMET   RCB   
	----------------------------------------------------------------
	AVGLDG     5       4       1       1       2     1	avg ledger
	AVGCOL     6       5       2       2       3     2	avg collected - float holds
	AVGINV*    7       6       3       3       4     3	avg investible - float holds
	LOWIND     8       7       4       4       5     4 	low intra day
	LOWEOD     9       8       5       5       6     5	low end of day
	LEDGER     10      1       6       6       7 		dep.bal snapshot
	AVGCOLC    11      10      7       7       8     6	avg collected - check holds
	AVGRESC*   12      11      8       8       9     7	avg investible - check holds
	BALCOL*	    	   3       9       9       10		dep.balcol
	DLYINV*		   9       10      10      11		dep.balcol less lead account reserve percentage
	note - * = done inside BCHFEEUTL
	there is no dep.anlrcb option 2 in the system
	*/

	// Calculate earnings allowance and net earn allowance 
	if dep.anltyp=1,CTL do {
		set SCND=%SystemDate
		set SCLD=dep.scld		// Service Charge Last Date
		if SRVDT,(SCND'=SRVDT) set SCND=SRVDT,SCLD=""  
		if SCLD="" do {
			new NJD
			set NJD=$$NJD^UFRE(SCND,dep.scfre,,1) quit:ER
			set SCLD=$S(NJD'>dep.odt:dep.odt-1,1:NJD)
			}

		do ERNALL(0,$P(SRVSUM,"|",5,12))
		}
	
	// feebal fields to srvsum array, must keep balance fields lined up

	if $G(FEEBAL) do {
		if FEEBAL=1 set FEEBAL=$P(SRVSUM,"|",5)		// AVGLDG
		if FEEBAL=2 set FEEBAL=$P(SRVSUM,"|",6)		// AVGCOL float holds
		if FEEBAL=3 set FEEBAL=$P(SRVSUM,"|",7)		// AVGINV float holds
		if FEEBAL=4 set FEEBAL=$P(SRVSUM,"|",8)		// LOW intra day
		if FEEBAL=5 set FEEBAL=$P(SRVSUM,"|",9)		// LOW end of day
		if FEEBAL=6 set FEEBAL=$P(SRVSUM,"|",11)	// AVGCOLC check holds
		if FEEBAL=7 set FEEBAL=$P(SRVSUM,"|",12)	// AVGINVC check holds
		}

	else  set FEEBAL=dep.bal

	set FEEBAL=$$ROUND(FEEBAL,FEEBALRF,FEEBALRM)

	/*
	 Define the fee routine (PGM) which will get the most recent fee 
	 program for the period based on the SCND of the account. The fee
	 program is built once for each FEEPLN on each fee plan's effective
	 date. If called via transaction processing, the effective dated fee 
	 routine will be used based on the EFD of the transaction.
	*/

	set PGM=$$FEEPGM^UFID(FEEPLN,SRVDT)
	// Service fee plan ~p1 not compiled 
	if PGM="" set ER=1,RM=$$^MSG(2481,FEEPLN)
	if ER do ERR quit

	set FEE3A=0	// FEECAT=3 CHGOPT=2 fees
	set PGM="ENT^"_PGM_"(.dep,"_FEEBAL_",.SRVSUM,SRVDT)"

	do @PGM if ER do ERR quit

		
	set FREETRF=dep.ftrf			// Free Transaction Fee
	// Get from service fee plan
	if $G(FREETRF)="" set FREETRF=$P(FEEPLN(FEEPLN),"|",12)   	

	set MINTRF=dep.mintrf			// Minimum Transaction Fee
	// Get from service fee plan
	if $G(MINTRF)="" set MINTRF=$P(FEEPLN(FEEPLN),"|",13)     	
	
	set MAXTRF=dep.maxtrf			// Maximum Transaction Fee
	// Get from service fee plan
	if $G(MAXTRF)="" set MAXTRF=$P(FEEPLN(FEEPLN),"|",14)     	
	
	set OTRTRF=dep.otrtrf			//  Other Transaction Fee
	// Get from service fee plan
	if $G(OTRTRF)="" set OTRTRF=$P(FEEPLN(FEEPLN),"|",15)    
	
	if (FREETRF-FEE3A)<0 set COMPFEE=FEE3A-FREETRF

	if $G(COMPFEE)<MINTRF,MINTRF'="" set COMPFEE=MINTRF
	if $G(COMPFEE)>MAXTRF,MAXTRF'="" set COMPFEE=MAXTRF

	set COMPFEE=$G(COMPFEE)+OTRTRF
	
	set FEE(1)=$G(FEE(1))	// Direct charge
	set FEE(2)=$G(FEE(2))	// Charge at SCND
	set FEE(3)=$G(FEE(3))	// Offset with Earnings
	
	if FEE3A'=COMPFEE set FEE(2)=FEE(2)+(COMPFEE-FEE3A)
	
	// Calculate FEE for offset with earnings
	set FEE=BASE+FEE(3)	// Base from feeplan + chg option 3 fees


	if dep.anltyp=1, CTL do ANLCHG(.dep)

	if FEEMIN,FEE<FEEMIN set SYSADJ=FEEMIN-FEE,FEE=FEE+SYSADJ // Minimum fee
	if FEEMAX,FEE>FEEMAX set SYSADJ=FEEMAX-FEE,FEE=FEE+SYSADJ // Maximum fee
	
	// Add fees assessed at SCND

	if dep.anltyp=2 set FEEACT=FEE(2)	// do not add CHGOPT 3 fees
	else  set:FEE<0 FEE=0 set FEEACT=FEE+FEE(2) // add CHGOPT 2 & 3 fees

	set NLOFF=0
	
	do BUILDTR(CID,.ts,.dep,NLOFF)
	quit
 
public BUILDTR(CID,TranSet ts,RecordDEP dep,NLOFF)	//Process account

	set TYPE=dep.type
	set CRCD=dep.crcd
	set GLSC=dep.glsc
	set CC=dep.cc
	set FCID=dep.svcfeecid			// Service Charge Account Number
 	
	if FCID="" set FCID=CID
	type RecordDEP tempdep = Db.getRecord("DEP","FCID")	// Charge account 

	set FTYPE=tempdep.type
	set FCRCD=tempdep.crcd
	set FGLSC=tempdep.glsc
	set FCC=tempdep.cc

	if CTL set INT=$$INTPAID^DEPDI(dep.cid,(SCLD+1),SCND)
	if CTL set INT=$$^SCARND(INT,0,dep.cid,,,,1)

	if 'PLTP,dep.feeopt do FEEOPT(.tempdep,.dep)	// Added FEEOPT=4  JK 1/2000

	if CTL do UPDSRV(.dep) 

	if $E(CTL,2) quit

	if 'FEEACT quit
	
	// File transaction
	
	new TCMT,TSO,EXCAMT
	set ETC=$$ETC(FTYPE,PLTP)

	type RecordTRN trn = Db.getRecord("TRN","ETC")

	set ITC=trn.itc				// Internal Transaction Code	
	set TSO="SRVFEE#"

	// Get fee default reason code if a RPA account. 

	new RPAFEE		// ARQ 47938
	set RPAFEE=CUVAR.RPAFEE
	if tempdep.ira set TSO=$$FIELDIN^UTSO(TSO,"IRAD",RPAFEE) 
	
	/*
	msg 3506: Service fees
	msg 8435: Service for account CID.
	*/

	if FCID=CID set TCMT=$S(PLTP=0:$$^MSG(3506),1:$$^MSG(3145))
	else  set TCMT=$S(PLTP=0:$$^MSG(8435,CID),1:$$^MSG(3148)_CID)
	
	/*
	The following lines of code allow multicurrency fee assesments.
	Set exchange amount = to fee - redefined if currencies are different
	*/
	set EXCAMT=FEEACT			

	if FCRCD'=CRCD do {

		type Number RTYPE

		// FX Equivalence Position Rate from CUVAR
		set RTYPE=CUVAR.FXPOSRT
		if RTYPE.isNull() set RTYPE=1

		// Convert fee
		set EXCAMT=$$CONV^CRCDUTL(FEEACT,FCRCD,CRCD,RTYPE)
		set EXCAMT=$$^SCARND(EXCAMT,0,$G(FCID))
		do BLDEXCHG(CRCD,TYPE,"exchg0",CC,PLTP,FEEACT)			// Build exchange debit
		do BLDEXCHG(FCRCD,FTYPE,"exchg1",FCC,$S(PLTP=0:1,1:0),EXCAMT)	// Build exchange credit
		}	

	new TTXBLD,x
	set TTXBLD("CID")=FCID
	set TTXBLD("ITC")=ITC
	set TTXBLD("ETC")=ETC
	set TTXBLD("TAMT")=EXCAMT
	set TTXBLD("TLO")=%UserStation
	set TTXBLD("TSO")=TSO
	set TTXBLD("TCMT")=TCMT
	set TTXBLD("CRCD")=FCRCD

	type RecordTTX ttx = Class.new("RecordTTX")
	set x=ts.copyTran(ttx,.TTXBLD)

	set ttxset=1

	// Update G/L based on fee original account
	if FCRCD'=CRCD do TOTINI(CRCD,TYPE,GLSC,CC,FEEACT,PLTP)

	// Update G/L based on fee target account	
	if FCRCD=CRCD do TOTINI(FCRCD,FTYPE,FGLSC,FCC,EXCAMT,PLTP)

	quit
	

UPDSRV(RecordDEP dep)  // Update service fee files

	/*
	This will only create new objects if feeplan has not filed to global
	for fee categories (SRVD) in compiled fee program. If it has filed a
	lower SRV level (SRVD - ie "CHARGE" fee category 4) the isdefined 
	method will return a 10 and '10=0, thus going to Db.getRecord, even 
	though 3 key level (top of ^SRV) is not defined, and will get first 
	3 keys from 5 key level of ^SRV, and the global updates to ^SRV 
	can't be seen at this time due to TP fence.
	*/

	type RecordSRV srv = Db.getRecord("SRV","CID=:CID,PLTP=:PLTP,SCND=:SRVDT", 1)
 
	set srv.feechg=FEE(1)		// Total Fees - Direct At TimeOf Service
	set srv.feeanl=FEE(2)		// Total Fees -Charged Upon Analysis
	set srv.feeoff=FEE(3)		// Total Fees - Offset Earnings Allowance
	set srv.ernall=ERNALL		// Earnings Allowance
	if 'PLTP set srv.feeact=FEEACT	// Fee Charged (Actual)
	set srv.sysadj=SYSADJ		// System Adjustments
	set srv.netfwd=$G(NETFWD)	// Net Profit/(Loss) Carried Forward
	set srv.feeunp=FEEUNP		// Unapplied Fee Amount
	set srv.calbal=ERNMET		// Earnings Calculation Balance
	set srv.tseq=Db.currVal("HIST","CID")	// History Pointer (Calc Thru Sequence)
	if PLTP set srv.ucr=FEEACT	// Usage Credit
	set srv.netfwdo=$G(NETFWDO)     // Original Calculated NETFWD position
	set srv.netfwdp=$G(NETFWDP)     // Prior period carry forward
	set srv.irn=dep.irn		// Interest Rate
	set srv.int=$G(INT)		// Interest paid in peiod
 
	type RecordSRV0 srv0 = Db.getRecord("SRV0","CID=:CID,PLTP=:PLTP,SCND=:SRVDT", 1)

	set srv0.feebal=FEEBAL			// Fee Computation Bal
	set srv0.avgbal=$P(SRVSUM,"|",5)	// Avg ledger bal
	set srv0.avgcol=$P(SRVSUM,"|",6)	// Avg collected bal
	set srv0.avgres=$P(SRVSUM,"|",7)	// Avg investible bal
	set srv0.lwbal1=$P(SRVSUM,"|",8)	// Low balance (iod)
	set srv0.lwbal2=$P(SRVSUM,"|",9)	// Low balance (eod)
	set srv0.ledger=dep.bal			// Ledger balance css
	set srv0.avgcolc=$P(SRVSUM,"|",11)	// Avg col chk holds
	set srv0.avgresc=$P(SRVSUM,"|",12)	// Avg inv chk holds
	set srv0.balcol=dep.balcol		// Collected Balance
	set srv0.dlyinv=$G(DLYINV)		// Daily inv bal

	do srv.bypassSave() 
	do srv0.bypassSave() 

	quit

	
ETC(TYPE,DC)	// 	 Define transaction code
	
	new X

	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL","TYPE")

	if DC do {
		set X=prodctl.crtus		// CR Tran Code (Usage Credits)
		if X="" set X=prodctl.crtrgp	// CR General Purpose Tran Code
		}

	else  do {
		set X=prodctl.drtrsc		// DR Service Fee Tran Code
		if X="" set X=prodctl.drtrgp	// DR General Purpose Tran Code
		}

	quit X

	
TOTINI(CRCD,TYPE,GLSC,CC,FEEACT,PLTP)	// Initialize G/L fee income data or fee expense
	
	
	new CID

	type RecordUTBLGLSC utblglsc = Db.getRecord("UTBLGLSC","GLSC")

	if PLTP=0 set CID=utblglsc.dglf		// Dep G/L # (Fee Income)
	else  set CID=utblglsc.dglu		// Deposit G/L# (Usage Credit Expense)  

	set GLSC=GLSC_"pltp"_PLTP
	
	if 'TOT(CRCD,TYPE,GLSC,CC).exists() do {	// Check top level
		if 'PLTP set TOT(CRCD,TYPE,GLSC,CC)="||"_CID_"|MCR||"_$$^MSG(5545,TYPE,CC) ; Svc Fee and G/L credit
		if PLTP set TOT(CRCD,TYPE,GLSC,CC)=CID_"|MDR||||"_$$^MSG(3144,TYPE,CC)     ; Credit Use and G/L debit
		}
	set TOT(CRCD,TYPE,GLSC,CC,$S(PLTP=0:1,1:0))=FEEACT	

	do BCHOFF(PLTP,CRCD,TYPE,GLSC,CC,$S(PLTP=0:1,1:0))

	quit
	
BCHOFF(PLTP,CRCD,TYPE,GLSC,CC,DC)	// Add the offset from the current transaction to the offset global.

	new BCHID,glinfo,job
	set BCHID="BCHSRVFEE"
	set JOB=%ProcessID

	//I18N=OFF
	if 'Db.isDefined("TMPBCHOFF","TJD,BCHID,JOB,""fee"",CRCD,TYPE,GLSC,CC") do { quit:glinfo=""
	//I18N=ON
		set glinfo=$G(TOT(CRCD,TYPE,GLSC,CC))
		new CID,ETC,TCMT
		set CID=$S($p(glinfo,"|",1):$p(glinfo,"|",1),1:$p(glinfo,"|",3))
		set ETC=$s($p(glinfo,"|",2)'="":$p(glinfo,"|",2),1:$p(glinfo,"|",4))
		set TCMT=$p(glinfo,"|",6)
		do BDOFFSET^BCHSOURC("BCHSRVFEE","fee",CRCD,TYPE,GLSC,CC,CID,CID,ETC,ETC,TCMT)
		}

	/* 
	  Offset Record already exists, so update it with 
	  the amount from this transaction
	*/

	set FEEACT=$G(TOT(CRCD,TYPE,GLSC,CC,DC))
	if FEEACT=0 quit
	do UPOFFSET^BCHSOURC("BCHSRVFEE","fee",CRCD,TYPE,GLSC,CC,$S(DC=0:1,1:0),FEEACT)

	quit


BLDEXCHG(CRCD,TYPE,GLSC,CC,DC,FEEACT)	// Build exchange transaction

	new CID,ETC

	if 'TOT(CRCD,TYPE,GLSC,CC).exists() do {
		set CID=$$otcgl^CRCDUTL(CRCD)
		if CID="" set CID=CUVAR.GLTS
		set ETC=$S(DC=0:CUVAR.CEDR,1:CUVAR.CECR)
		if 'DC set TOT(CRCD,TYPE,GLSC,CC)=CID_"|"_ETC_"||||"_$$^MSG(5545,TYPE,CC)
		if DC set TOT(CRCD,TYPE,GLSC,CC)="||"_CID_"|"_ETC_"||"_$$^MSG(5545,TYPE,CC)
		}

	set TOT(CRCD,TYPE,GLSC,CC,DC)=FEEACT	

	// Build offset exchange transaction which will be opposite of offset 
	do BCHOFF($S(PLTP=1:0,1:1),CRCD,TYPE,GLSC,CC,DC)

	quit


public ANLCHG(RecordDEP dep)	// Earnings allowance adjustments/analysis charge option

	/*
	  Inputs:
 
	  .  FEE - Cost of Service - total FEES for analysis BASE+FEE(3)
	  .  NETERN - Net Earnings Allowance
 
	   ______________________________________________________________
	*/

	// Total of Fees for lead and type 2 linked acocunts
	set FEE=FEE+$$TOTFEE(CID,SCND)

	/* 
	  If net earnings credit (FEE) is a positive number then cost 
	  exceeds earnings and ends up as a negative position. If FEE is a
	  negative number, then earnings exceed cost and ends up as a 
	  positive position.
	  For Charge option 5 we store the position positive or negative for
	  offset processing.
	*/	

	set FEE=FEE-NETERN

	/* 
	  Charge net loss:
	  
	  If FEE is negative, it is a positive position so no charge, but save
	  NETFWD and NEWFWDO for both offset processing and for informational
	  purposes.  (NOTE.  This is a change from prior coding of setting
	  these two fields to 0 in there was no fee.)
	  
	  If FEE is positive (cost exceed earnings) and there are offset
	  days, store FEE as negative carryforward, as it will be added to next
	  periods calculation. Reset FEE so it is not charged today. Offset
	  batch processing will charge account at end of offset period if it
	  is still negative (BCHANLOFF).
	  
	  If FEE is positive and there are no offset days, leave FEE alone to
	  let FEE processing charge the account.
	*/
 
	if dep.anlchg=1 do {  quit
		
		if (FEE '> 0) set (NETFWD,NETFWDO) = -FEE, (FEE,FEEMIN) = 0
		
		// If offset days temporarily store fee in carryforward position
		else  if dep.anloffdy set (NETFWD,NETFWDO) = -FEE, (FEE,FEEMIN) = 0
		}
 
	/*
	  Do not Charge. Profit or loss will not be stored.
	  This option will not take into account offset days processing.
	  Use option 5 if modification to net position is desired.
	*/

	if dep.anlchg=0 set:FEE>0 FEEUNP=FEE set (FEE,FEEMIN)=0 quit

	// Carry net loss only. If there is a net profit, it will not be stored.

	if dep.anlchg=2 set:FEE>0 (NETFWD,NETFWDO)=-FEE,(FEE,FEEMIN)=0

	/*
	  Carry net profit only. If there is a net loss, it will not be stored
	  and will be charged to the account on the SCND. 
	*/

	if dep.anlchg=3 set:FEE<0 (NETFWD,NETFWDO)=-FEE,(FEE,FEEMIN)=0

	// Carry net profit or loss.  

	if dep.anlchg=4 set (NETFWD,NETFWDO)=-FEE,(FEE,FEEMIN)=0

	/* 
	   Carry forward offset net profit or loss

	   If no offset days, the net carryforward amount prior period
	   (NETFWDP) should reflect current period's adjusted carryforward 
	   amount (NETFWD). If there are offset days, NETFWDP will be the 
	   prior period's carryforward amount as defined in the ERNALL line
	   tag, until the end of the offset period, where offset processing
	   will reset this field.
	*/ 

	if dep.anlchg=5 do {

		/*
		If no offset days and are net loss days and neg position
		set up net loss days start date, only if it was not already
		set up last period. 
		If there are offset days the net loss dates are handled by 
		BCHANLOFF.
		If no offset days and positive position during netloss period
		and net loss end date has been set need to reset net loss 
		start and end dates to null.
		This option stores FEE + or  - for adjustments and or
		next periods net earnings credit calculations.
		*/
 
		if ('dep.anloffdy)&(dep.anlsnl)&(FEE>0) do {
			do dep.setAuditFlag(1)
			// Set up net loss dates if not already set up
			if dep.anlled="" set dep.anllsd=%SystemDate
 			}

		set (NETFWD,NETFWDO)=-FEE,(FEE,FEEMIN)=0 
		if 'dep.anloffdy set NETFWDP=$G(NETFWD)

		/* 
		new + position and net loss end date was set up in 
		prior period - get rid of net loss dates. If net loss end date
		set up prior period, and net loss days file maintained to 0 
		still delete net loss dates based on dep account attributes
		for current period
		*/

		if ('dep.anloffdy)&(NETFWDP'<0)&(dep.anlled'="") set dep.anllsd=""

		}
	quit
	

AVGINV(AVGCOL,LPCT)	// Calculate investible balances (Collected bal - reserve amount)
	
	/*
	 ARGUMENTS:
 
	  . AVGCOL	Collected balance field
	  . LPCT	Use lead account reserve percentage
 
	 RETURNS:
 
	  . Investible Balance - collected bal less reserve reqmt amount
	*/

	if 'AVGCOL quit 0

	new data,X,XTYPE

	set XTYPE=TYPE  // Might need to use Lead accounts Reserve Pct
	
	if $G(LPCT) do {
		new LCID
		
		type RecordDEP dep = Db.getRecord("DEP", "CID=:CID")
		set LCID = dep.anlcid
		
		if '$G(LCID) quit
		
		type RecordDEP dep2 = Db.getRecord("DEP", "CID=:LCID")
		set XTYPE = dep2.type     // Lead account % reserve
		}
	
	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL","TYPE=:XTYPE")
	
	set X=prodctl.resreq/100		// Percentage Reserve Requirement
	if 'X quit AVGCOL

	set X=$$^SCARND(AVGCOL*X,0,CID)
	if X<0 set X=0

	quit AVGCOL-X
	


public ERNALL(OPT,RCB)	//Calculate earnings allowance

	/*
	 Calculate the earnings allowance based upon the analysis rate
	 calculation base dep.anlrcb (ANLRCB) and the analysis interest accrual
	 method dep.anlicm (IACM).
	
	 NOTE:  This subroutine is also called from DATA-QWIK report
		SCA174 (Earnings Allowance Calculation Report).
	
	 INPUTS:
	     . A(CID,63)
	     . SCLD	Service charge last date (from date)
	     . SCND	Service charge next date (to date)
	
	 ARGUMENTS:
	     . CID	Lead Account Number		/TYP=N/REQ//MECH=VAL
	     . OPT	Return report detail		/TYP=L/NOREQ/MECH=VAL
			- 0 if from service fees		/DFT=0
			- RCB from SRVSUM
			RCB	|avgldg|avgcol|avginv|lowbal|loweod|ldg|avgcc|avgcr	

			- 2 if from DQ rpt SCA174
			- RCB from SRV0
			RCB	|avgldg|avgcol|avginv|lowbal|loweod|ldg|avgcc|avgcr|balcol|dlyinv	
	
	     . RCB	Analysis Rate calculation base array		/TYP=T/REQ/MECH=VAL

	SRV0	|avgldg|avgcol|avginv|lowbal|loweod|ldg|avgcc|avgcr|balcol|dlyinv	
	ANLRCB  | 4    |  5   |   6  |  7   |  8   | 1 |  10 | 11  |  3   |  9

	 RETURNS:
	
	     . ERNMET	Earnings method
	     . DTL(n)	Detail support of calculation (if OPT=2)
	*/
	
	new ACR,BASE,CBRCB
	
	type RecordDEP dep = Db.getRecord("DEP","CID")

	if dep.anltyp'=1 quit				// Not a lead account
	set CID=dep.cid
 
	if '(dep.anlrcb)!(dep.anlacm="") set (ERNALL,NETERN)=0 quit
	if dep.anlacm=0 set (ERNALL,NETERN)=0 quit	// No earnings option

	set DTL=$G(OPT)					// REP174 call
	
	set CBRCB=$$CBRCB(CID,dep.crcd,dep.anlrcb)      // Return Linked account bals

	if CBRCB="" set CBRCB=0

	/* 
	  For dep.anlrcb options 3 and 9, when called from service fees, there
	  is no balance in the RCB array to use (RCB is from SRVSUM), need to add collected
	  or daily investible balances that were just calculated in CALC section
	  to linked balances, as the SRV0 file for the balances is not 
	  updated yet. For REP174, the RCB array balance fields will come in
	  from SRV0 file, and will have snapshots of all balance fields 
	  from service fee processing date entered in report.
	  OPT is from REP174,  'OPT is from service fee processing
	*/

	do {
		if dep.anlrcb=1 set ERNMET=6,BASE=$P(RCB,"|",6)+CBRCB quit
		if (dep.anlrcb=3)&'(OPT) set ERNMET=9,BASE=dep.balcol+CBRCB quit	
		if (dep.anlrcb=3)&(OPT) set ERNMET=9,BASE=$P(RCB,"|",9)+CBRCB quit
		if dep.anlrcb=4 set ERNMET=1,BASE=$P(RCB,"|",1)+CBRCB quit
		if dep.anlrcb=5 set ERNMET=2,BASE=$P(RCB,"|",2)+CBRCB quit
		if dep.anlrcb=6 set ERNMET=3,BASE=$P(RCB,"|",3)+CBRCB quit
		if dep.anlrcb=7 set ERNMET=4,BASE=$P(RCB,"|",4)+CBRCB quit
		if dep.anlrcb=8 set ERNMET=5,BASE=$P(RCB,"|",5)+CBRCB quit
		if (dep.anlrcb=9)&'(OPT) set ERNMET=10,BASE=DLYINV+CBRCB quit
		if (dep.anlrcb=9)&(OPT) set ERNMET=10,BASE=$P(RCB,"|",10)+CBRCB quit
		if dep.anlrcb=10 set ERNMET=7,BASE=$P(RCB,"|",7)+CBRCB quit
		if dep.anlrcb=11 set ERNMET=8,BASE=$P(RCB,"|",8)+CBRCB quit
	}


	// Deduct lead and linked balances to exclude
	set BASE=BASE-$$BALEXLD^SRVCDI(CID,PLTP,SCND)

	/*
	  Earnings allowance should only be calculated on a positive balance
	  for analysis charge options 1-4. NETERN needs to be set here.
	*/

	if (BASE<0),(dep.anlchg'=5) set (ERNALL,NETERN)=0 quit

	/*
	   When BASE amount for earnings is negative and analysis charge
	   option is 5, need to get prior period carryforward amount
	   to add to current period calculations.
	*/

	else  if (BASE<0),(dep.anlchg=5) do PPNETFWD quit
	
	// Analysis rounding
	set BASE=$$ROUND(BASE,dep.anlbalrf,dep.anlbalrm)

	// RECALC returns ACR - accrued interest. 

	do ERNALL^RECALC(.dep,SCND,SCLD,.BASE) quit:ER

	// Normal process ERNALL is accruals
	if ('dep.anlfpr ! 'dep.anlidx.isNull()) set ERNALL=$$^SCARND($G(ACR),0,CID)

	// Flat monthly periodic rate calculation 
	else  set ERNALL=$$^SCARND((BASE*(dep.anlirn/100)),0,CID)

	// If REP174 and flat periodic rate, reset DTL array for earnings
	if dep.anlfpr,$G(OPT) do {
		new DTLNUM set DTLNUM=""
		set DTLNUM=$O(DTL(DTLNUM)) quit:DTLNUM=""  do {
			set $P(DTL(DTLNUM),"|",6)=ERNALL
			set $P(DTL(DTLNUM),"|",7)=ERNALL
			}
		}

	// Save Earnings allowance then calc net earn allowance
	set NETERN=ERNALL

	// Deduct total interest paid
	if dep.dedintpd set NETERN=NETERN-$$TOTINT(CID,SCLD,SCND)

	/*
	 Offset this periods net earnings with prior period's carry forward
	 amount (NETFWDP). NETERN will now become the net earnings credit.
	*/

	if dep.anlchg=5 do PPNETFWD

	quit
	
PPNETFWD //Prior Period carryforward

	/*
	    This section will go to prior fee period in the SRV global and 
	    retrieve the NETFWDP (carryforward) position, and add it in to 
	    the current net earnings calculation.
	*/

	if '$G(NETERN) set NETERN=0

	// Need prior period SRV global entry
	type ResultSet rs = Db.select("NETFWDP", "SRV", "CID=:CID AND PLTP=:PLTP AND SCND<:SCND", "SCND DESC")
	if rs.next() set NETFWDP = rs.getCol("NETFWDP")
	else  set NETFWDP = 0
	
	set NETERN=NETERN+NETFWDP

	quit

FEEOPT(RecordDEP tempdep,RecordDEP dep)	// Service charge option
	
	/*
	  The tempdep object is fee assessment account and dep object is account fee is being
	  calculated for.
	*/

	New BALAVL,COMPBAL,X
	Set (BALAVL,COMPBAL,X)=0

	// Determine fee waive amount for dep.feeopt 1 through 3; X=Waive Fee Amt
	if dep.feeopt'=4,FEEACT>tempdep.bal  do {

		// Waive Only The Fee Amount Exceeding The Ledger Balance
		if dep.feeopt=1 set X=$S(tempdep.bal<0:FEEACT,1:FEEACT-tempdep.bal)
 
		// Waive the Entire Fee Amount if the Fee Exceeds the Ledger Balance
		else  if dep.feeopt=2 set X=FEEACT
 
		// Waive Fee Exceeding Available Balance Plus OD Available Balance
		else  if dep.feeopt=3 do {
			set BALAVL=tempdep.balavl
			set COMPBAL=BALAVL+$$ODAVLF^DEPDI(tempdep.cid)
			set X=$S(FEEACT<COMPBAL:0,COMPBAL<0:FEEACT,1:FEEACT-COMPBAL)
			}
		}

	// Waive fee amount exceeding interest paid  - JK 1/21/00
	if dep.feeopt=4 do {

		if SCLD="" do {
			new FRE,NJD,ODT
			set ODT=dep.odt		// Date Account Opened
			set FRE=dep.scfre	// Service Charge Frequency
			set NJD=$$NJD^UFRE(SCND,FRE,,1) quit:ER
			set SCLD=$S(NJD'>ODT:ODT-1,1:NJD)
			}

		set X=$S(INT<0:FEEACT,INT>FEEACT:0,1:FEEACT-INT)
		}

	/*
	Determine unapplied fee, actual charged fee and interest amount
	Need $G on FEEUNP in case BCHANLOFF BCHNETLOSS call in here. 
	*/
	set FEEUNP=$G(FEEUNP)+X,FEEACT=FEEACT-X
	if 'FEEUNP quit
	if 'CTL quit
			
	// Unapplied fee amount (waived)
	set RM="$"_$$^SCARND(FEEUNP,0,tempdep.cid,,,,1)_$$^MSG(4982)

	do ERR1
	quit


CBRCB(CID,CRCD,ANLRCB)    // Sum of Linked balances for Rate calculation Base
 
	/*
	CBRCB returns sum of linked account balances. Balance returned
	is determined based on ANLRCB option. All balances will have
	been converted to lead account currency. If no linked accounts
	it will be returned as 0. If the linked account is closed, that 
	balance field for that linked account will not be used to calculated
	BASE amount for lead account earnings calculations.
 
 
	  Arguments
	  . CID		Lead Account Number		/TYP=N/REQ/MECH=VAL
	  . CRCD	Currency Code Lead Account 	/TYP=T/REQ/MECH=VAL
	  . ANLRCB	Analysis Rate Calcuation Base	/TYP=N/REQ/MECH=VAL
 
	  Inputs
	  . SCND	Service Charge Scheduled Next Date
 
	  Returns:
	  . $$ Total balance amount based on ANLRCB type from linked sub accounts /TYP=$
 
	  Example:
	  set CBRCB=$$CBRCB(112087689,"USD",5)
	*/

	type Number CBRCB,POS,XCID
	type public Date SCND
	
	if ('CID)!(CRCD="")!'(ANLRCB)!(SCND="") quit 0
 
	set CBRCB=0
 
	set XCID=CID		// Lead account number

	// Example AVGLDG from ANLRCB is  4 = position 1 returned from SRV0 call
	set POS=ANLRCB-3		// balance field to use
 
	if (ANLRCB=1) set POS=6		// Use ledger balances
	if (ANLRCB=3) set POS=9		// Collected balance
	if (ANLRCB=9) set POS=10	// Daily Inv

	/*
	  For the following 2 investible balance options, use the 
	  relevant collected balance because the product type 
	  reserve amount on link account could be different than lead account.
	  This situation will be handled after balances are summed
	*/ 
	if (ANLRCB=6) set POS=2		// AVGINV - Use AVGCOL	
	if (ANLRCB=11) set POS=7	// AVGINVC - Use AVGCOLC	

	type ResultSet rs = Db.select("CID,CRCD","DEP","ANLCID=:XCID")
	while rs.next() do {
		new anlrb,data,NCID,NCRCD,NPLTP
		set NCID=rs.getCol(1)
		set NCRCD=rs.getCol(2)
		set NPLTP=0
		
		type ResultSet rs2 = Db.select("AVGBAL,AVGCOL,AVGRES,LWBAL1,LWBAL2,LEDGER,AVGCOLC,AVGRESC,BALCOL,DLYINV","SRV0","CID=:NCID AND PLTP=:NPLTP AND SCND=:SCND")
		set anlrb=""
		if rs2.next() do {
			type Row rRow = rs2.getRow()
			set data=rRow.toString()
			set anlrb=$P(data,$C(9),POS)
		}
		if anlrb="" quit
		if NCRCD'=CRCD set anlrb=$$CONV^CRCDUTL(anlrb,CRCD,NCRCD,1)
		set CBRCB=CBRCB+anlrb
	}
 
	if CBRCB'>0 set CBRCB=0 quit CBRCB
 
	/* 
	  Handle average investible balances. For these 2 options CBRCB
	  is the sum of collected balances, and for analysis use 
	  the collected balances * lead accounts reserve percentage, so force it
	  to lead account's reserve percentage for investible balance.
	*/
 
	if (ANLRCB=6)!(ANLRCB=11) set CBRCB=$$AVGINV(CBRCB,1)
 
	set CBRCB=$$^SCARND(CBRCB,0,CID)
 
	quit CBRCB
 
public ROUND(AMT,FACTOR,METHOD)   // Computed Rounded Amount
 
	/*
	  ARGUMENTS:
	  . AMT		Amount to be rounded		/TYP=$/REQ/MECH=VAL
	  . FACTOR	Rounding factor to be used	/TYP=N/REQ/MECH=VAL
	  . METHOD	Rounding method from STBLRNDMTH /TYP=N/REQ/MECH=VAL
 
	  Returns:
	  . $$ Rounded amount				/TYP=$
 
	  Example:
	  set BASE=$$ROUND^BCHFEEUT(1112,100,2)
	  BASE=1200 rounded up to nearest 100

	  Rounding UP will mean round to a number greater than the original
	  and rounding down will mean rounding to a number less than the
	  original. Round UP -1211.10 to a factor of 10 = -1210 and rounding
	  down of the same scenario = -1220.  
	*/
	new DOWN,NEAR,NORND,UP
 	
	if '$G(AMT) quit 0

	//Method is 0 (No rounding) or missing parameter
	if '$G(METHOD)!'$G(FACTOR) quit AMT
 
	// If no remainder - amount is multiple of factor 
	// thus no rounding 
	set NORND=(AMT#FACTOR) if '$G(NORND) Q AMT

	if AMT<0 do {
		set UP=(AMT\FACTOR)*(FACTOR)
		set DOWN=((AMT\FACTOR)*(FACTOR))-(FACTOR)
		set NEAR=$S((AMT-DOWN)>(UP-AMT):UP,1:DOWN)
		}

	else  do {
		set UP=((AMT\FACTOR)*(FACTOR))+(FACTOR)
		set DOWN=(AMT\FACTOR)*(FACTOR)
		set NEAR=$S((AMT-DOWN)>(UP-AMT):UP,1:DOWN)
	 	}

	if METHOD=1 quit NEAR		// Round to nearest
	if METHOD=2 quit UP		// Round up
	if METHOD=3 quit DOWN		// Round down

	quit AMT
 
 
public TOTFEE(CID,SCND)	// Get total CHGOPT3 fees from sub accounts anltyp=2
 
	/*
	  Arguments
	  . CID		Lead Account Number		/TYP=N/REQ/MECH=VAL
	  . SCND	Lead Account SCND
 
	  Inputs
	  . CRCD	Lead Accounts Currency
 
	  Returns:
	  . $$ Total fees accumulated for linked accounts  /TYP=$
	       Amount will be in currency of Lead account
 
	  Example:
	  set FEE=$$TOTFEE(100,58112)
 
	*/
	new XCID,TOTFEE
 
	set XCID=CID
	set TOTFEE=0
 
	/*
	Linked accounts - get fees and convert to lead account CRCD
	Don't use any fee information from closed linked accounts
	and only from analysis type 2 accounts that contain a fee plan.
	*/ 
	type ResultSet rs=Db.select("CID,CRCD,FEEPLN","DEP","ANLCID=:XCID AND ANLTYP=2 AND STAT<>4 AND FEEPLN IS NOT NULL")
	while rs.next() do {
		new feesub,nbase,NCID,NRCD,PLANDAT
		set NCID=rs.getCol(1)
		set NCRCD=rs.getCol(2)
		// Need to get base amount from feeplan
		set NFEEPLN=rs.getCol(3)
		set PLANDAT=SCND+1
		
		type ResultSet rs2 = Db.select("BASE", "FEEPLN", "PLAN=:NFEEPLN AND FEEDT<:PLANDAT", "FEEDT DESC")
		quit:rs2.isEmpty()
		set nbase = rs2.getCol("BASE")
		
		type RecordSRV srv = Db.getRecord("SRV", "CID=:NCID,PLTP=:PLTP,SCND=:SCND")
		set feesub = srv.feeoff
		// Add fee plan base to chgopt 3 fees
		set feesub=feesub+nbase 
		if feesub="" quit
		if CRCD'=NCRCD set feesub=$$CONV^CRCDUTL(feesub,CRCD,NCRCD,1)
		set TOTFEE=TOTFEE+feesub
		}
 
	set TOTFEE=$$^SCARND(TOTFEE,0,CID)
	quit TOTFEE
 
public TOTINT(CID,SCLD,SCND)    // Get interest paid to accounts in service fee period
 
	/*
	  Arguments
	  . CID		Lead Account Number	/TYP=N/REQ/MECH=VAL
	  . SCLD	Lead Account SCLD	/TYP=T/REQ/MECH=VAL
	  . SCND	Lead Account SCND
 
	  Inputs
	  . CRCD	Lead Account Currency	/TYP=T/REQ/MECH=VAL
 
 
	  Returns:
	  . $$ Total interest paid to all linked accounts (Lead and sub) /TYP=$
	       Amount will be in currency of Lead account
 
	  Example:
	  set TOTINT=$$TOTINT(100,58080,58112)
 

	  New X because it is FEEPLN array coming in. It will be reset
	  in the DEPDI call if it is not newed, and all X references
	  will be invalid.
	*/

	new X,XCID,INTPD
 
	set XCID=CID
	set INTPD=0
 
	set INTPD=$$INTPAID^DEPDI(CID,SCLD+1,SCND)
	if INTPD<0 set INTPD=0
 
	// Linked accouts - get interest and convert to lead account CRCD

	type ResultSet rs=Db.select("CID,CRCD","DEP","ANLCID=:XCID AND ANLTYP=2 AND STAT<>4")
	while rs.next() do {
		new LNKINT,NCID,NRCD,NSTAT
		set NCID=rs.getCol(1)
		set NCRCD=rs.getCol(2)
		
		type RecordSRV srv = Db.getRecord("SRV", "CID=:NCID,PLTP=:PLTP,SCND=:SCND")
		set LNKINT = srv.int
		if (LNKINT<0)!(LNKINT="") quit
		if NCRCD'=CRCD set LNKINT=$$CONV^CRCDUTL(LNKINT,CRCD,NCRCD)
		set INTPD=INTPD+LNKINT
		}
 
	set INTPD=$$^SCARND(INTPD,0,CID)
	quit INTPD

public EXTERN(RecordDEP dep,CTL,SRVDT) // external entry point from M programs 
	
	new CID
	set CID=dep.cid
	type TranSet ts = Class.new("TranSet")
	do PROC(CID,CTL,SRVDT,.ts,.dep)

	quit


public ERR	// Log error in exception file
	
    	if '$E($G(CTL),2) quit // In batch mode let BCHSRVFEE log exceptions

	do ERR1
	quit

ERR1		// Log unapplied amount

	do LOG^UTLEXC($T(+0),"*",$$^MSG(4980),$G(CID),$G(%ZTSEQ),$G(RM))
	quit
	

EXEC(CID,CTL)	// External entry point to process 1 account.
	
	/*
	 ARGUMENTS:
	
		. CID   Account Number  	/TYPE=N/REQ/MECH=VAL
	
		 Profile/IBS Account Number
	
		. CTL   Control Variable	/TYPE=N/NOREQ/MECH=VAL
	
		 Control Variable
		 Position 1:    0 - Process is inquiry only (UANTIC)
	   			1 - Process is update
	
	*/
	type TranSet transet = Class.new("TranSet")
	
	do %UID(PLTP)

	do PROC(CID,$G(CTL),SRVDATE,.transet)

	quit
	

BUMP(RecordDEP dep)	// Bump the service charge dates

	if PLTP do BUMPU(.dep) quit
	
	new FRE,JD,NJD
	
	set FRE=dep.scfre			// Service Charge Frequency
	
	if FRE="" set RM="SCFRE" do ERR quit

	set NJD=$$NJD^UFRE(%SystemDate,FRE) if ER set RM="SCND2" do ERR quit	
	if NJD<%SystemDate set RM="SCND" do ERR quit

	// Check for scnd/scld system change
	do dep.setAuditFlag(1)

	if dep.mt900 set dep.mt900prd=0
	if dep.mt910 set dep.mt910prd=0

	//MOV - Name of column was changed
	if dep.mt940 set dep.sw940prd=0	   
	if dep.mt942 set dep.mt942prd=0
 
	set dep.scnd=NJD		// Service Charge - Next Date
	set dep.scld=%SystemDate	// Service Charge - Last Date
	
	do dep.save()
	
 	quit


BUMPU(RecordDEP dep)	// Bump Usage Credit dates
	
	new FRE,JD,NJD
	
	set FRE=dep.upfre if FRE="" set RM="UPFRE" do ERR quit	
	 	
	set NJD=$$NJD^UFRE(%SystemDate,FRE) if ER set RM="UPNDT2" do ERR quit	
	if NJD<%SystemDate set RM="UPNDT" do ERR quit

	set dep.upndt=NJD			// Usage Plan Next Date
	set dep.upldt=%SystemDate		// Usage Plan Last Date
	
	do dep.bypassSave()

	quit
	

public EFDFEE(CID,FEEPLN,EFD)	//

	/*
	  Finds service charge dates that should be adjusted
	  based on the effective date of the transaction.

	  Called by transaction processing.
	
	  ARGUMENTS:
	
		. CID		Account Number		/TYPE=N/REQ/MECH=VAL
		. FEEPLN 	Service Fee Plan	/TYPE=T/REQ/MECH=VAL
		. EFD		Trans Effecitive Date	/TYPE=D/REQ/MECH=VAL
	*/
	
	type RecordDEP dep = Db.getRecord("DEP","CID")
	

	new JD,ODT,SCFRE,SCND,SRVDT

	set SCND=dep.scnd			// Service Charge - Next Date
	set SCFRE=dep.scfre			// Service Charge Frequency
	set ODT=dep.odt  			// Date Account Opened

	for  set NJD=$$NJD^UFRE(SCND,SCFRE,,"1") quit:ER  quit:NJD<EFD  quit:NJD'>ODT  do {
		set SCND=NJD
		// Only adjust periods that have not been accumulated
		if SCND<%SystemDate set SCDT(NJD)=""
		}

	set SRVDT=""

	for  set SRVDT=$O(SCDT(SRVDT))  quit:SRVDT=""   do OL(CID,FEEPLN,SRVDT)

	quit
	

OL(CID,FEEPLN,SRVDT)	//

	/*
	 Process effective dated transaction to affect 
	 prior service fee period.
	
	 ARGUMENTS:
	
		. CID		Account Number		/TYPE=N/REQ/MECH=VAL
		. FEEPLN 	Service Fee Plan	/TYPE=T/REQ/MECH=VAL
		. SRVDT		Service Charge Date	/TYPE=D/REQ/MECH=VAL
	
	*/

	new CLS,FEEACT,FEER,FEET,SCLD,TAMT,TCMT,TSO

	type TranSet tsnopost = Class.new("TranSet")
	set PLTP=+$G(PLTP)		; ARQ 47938

	// Save the "before" image of the last service fee amounts computed.
	
	type RecordSRV0 srv0=Db.getRecord("SRV0","CID,PLTP,SRVDT")

	// Compute fee - PROC will return FEEACT.  PROC^BCHFEEUT calls SRVSUM
	// and the fee routine.  The fee routine will return FEER and FEET.
	type RecordDEP dep = Db.getRecord("DEP","CID=:CID")
	do PROC(CID,"111",SRVDT,.tsnopost,.dep)
	
	/*
	 Find the difference between what was just computed 
	 and the calculated dollar amount of the service fees 
	 actually charged to the account at the end of the 
	 service fee period.
	*/

	set FEEACT=FEEACT-srv0.lwbal2

	// Service Fee Adjustment
	set TCMT=$$^MSG(1974)_" "_$$DAT^%ZM(SRVDT)

	// Service Fee Adjustment SRVDT for account ~p1
	if FCID'=CID set TCMT=$$^MSG(1983,CID)_" "_$$DAT^%ZM(SRVDT)
	
	/*
	Set SRVADJ in primary transaction. SRVSUM uses this exclude this
	transaction for the current period.
	*/
	type RecordTTX ttx=Class.new("RecordTTX")
	set ttx=tsnopost.getTran(1)
	set TSO=ttx.tso
	set TSO=$$FIELDIN^UTSO(TSO,"SRVADJ",SRVDT)
	set ttx.tso=TSO
	
	set TSO="SRVADJ#"_SRVDT
	// Get fee default reason code if a RPA account. 

	new RPAFEE
	type RecordDEP tempdep=Db.getRecord("DEP","FCID")


        set RPAFEE = CUVAR.RPAFEE

	if tempdep.ira set TSO=$$FIELDIN^UTSO(TSO,"IRAD",RPAFEE) 	 	

	/*
	 If there is not an adjustment, quit after the primary transaction 
	 TSO field is updated with SRVADJ.  This transaction is to be 
	 considered with the effective dated service fee period.  The routine
	 SRVSUM needs to recognize that this effective dated transaction is 
	 not to be included with the current period. A situation where an 
	 adjustment will not occur is when a fee is based on a schedule and
	 the count has not reached a level to change the fee amount.
	*/

	if 'FEEACT quit
	
	// Determine the posting direction.
	set DIR=FEEACT<0 
	// Set FEEACT to abolute value for credit or debit posting.
	if FEEACT<0 set FEEACT=-FEEACT	
	
	/*
	 The fee adjustment generated from the transaction fee difference is
	 posted separately from the service fee adjustment.  A service fee
	 adjustment will only occur if the account did not go through the 
	 service analysis for that period (effective dated open, etc.).  If 
	 the transaction that generated the service fee adjustment is error
	 corrected or reversed, the service fee charge for the period will
	 remain.  FEET is the original transaction fees charged at analysis
	 and FEER is the restated transaction fees charged at analysis. FEEACT
	 is the computed fees charged at analysis. Use the ablosute value for
	 posting debit or credit amount.
	*/

	if FEER-FEET do BLDTR($FN((FEER-FEET),"-"),1)		// Transaction fee difference
	if FEEACT'=$FN((FEER-FEET),"-") do BLDTR((FEEACT-FEER),0)  // Service fee difference
	quit
	
	
BLDTR(FEEACT,HOPT)	// Build fee adjustment transaction and offset
	
	/*
	 ARGUMENTS:
	
		. FEEACT  Fee Amount		/TYPE=$/REQ/MECH=VAL
		. HOPT    History Option	/TYPE=L/REQ/MECH=VAL
			  0 - Do not build history lower level
			  1 - Build history lower level
	
	*/
	type Number GLCID, ITC
	type String CRCD
	
	set ER=0
	type public Cache %CACHE()
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN","ETC = :ETC")

	type RecordDEP tempdep=Db.getRecord("DEP","CID=:FCID")
	
	set CRCD = tempdep.crcd

	set ETC=$$ETC(FTYPE,DIR)
	do ADJTTX(FCID,.ETC,trn.itc, CRCD, .tempdep)
	
	// Post GL offset
	set FCC=tempdep.cc
	set FGLSC=tempdep.glsc
	
	type RecordUTBLGLSC utblglsc = Db.getRecord("UTBLGLSC", "GLSC=:FGLSC", 1)
	
	set GLCID = utblglsc.dglf

	// Flip DR/CR for offset
	set ITC='(trn.itc)
	set ETC=$S(ITC:"MCR",1:"MDR")
	set TRC=""
	do ADJTTX(GLCID,.ETC,ITC, CRCD)
	
	quit
	
	
ADJTTX(CID,ETC,ITC,CRCD, RecordDEP dep)	// Build TR for fee adjustment
	
	/*
	 ARGUMENTS:
		. CID   Account Number			/TYPE=N/REQ/MECH=VAL
		. ETC   External Transaction Code	/TYPE=T/REQ/MECH=VAL
		. ITC   Internal Transaction Code	/TYPE=T/REQ/MECH=VAL
	
	*/
	
	type public Cache %CACHE()
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN","ETC = :ETC")
	type RecordTTX ttx = Class.new("RecordTTX")
	
	set ttx.cid=CID
	set ttx.itc=ITC
	set ttx.etc=ETC
	set ttx.tamt=FEEACT
	set ttx.tso=TSO
	set ttx.tcmt=TCMT
	
	#if CUVAR.%MCP set ttx.crcd = CRCD
	
	if "DL"'[trn.cls do {
		set ttx.cc=$G(CC)
		do TRNSINGL^TRNDRV(.ttx,,,BRCD,5) 
		}
	else  do TRNSINGL^TRNDRV(.ttx,.dep,,BRCD,5) 
	else  
	quit
	
	
public OLP(CID,PLN,SCEFD,ETC)	// Do we perform on-line EFD posting?
	
	/*
	 ARGUMENTS:
		. CID   Account Number			/TYPE=N/REQ/MECH=VAL
		. PLN	Service Fee Plan		/TYPE=T/REQ/MECH=VAL
		. SCEFD	Service Charge Effective Date	/TYPE=D/REQ/MECH=VAL
		. ETC	External Transaction Code	/TYPE=T/REQ/MECH=VAL
	
	 For processing efficiency the recalculation of service fees will
	 occur as a result of a transaction when all of the following 
	 conditions are met:
	
	 1 Process Control Flag 11 equals 1 ([PCFD]PCF11 = Y)
	   (Check in transaction processing routine)
	 
	 2 The transaction is being effective-dated
	   (Check in transaction processing routine)
	
	 3 The Effective Date (EFD) of the transaction is less than or equal
	   to the Last Service Charge Date ([DEP]SCLD).
	
	 4 The Transaction Code (TRNCD) is contained within a Transaction
	   Code Group ([UTBLTRNGRP]TRNGRP in the Service Fee Plan related 
	   to the account.
	*/

	if $G(CID)="" quit 0
	if $G(PLN)="" quit 0		
	if $G(SCEFD)="" quit 0					  // #2
	if $G(ETC)="" quit 0
	
	new DATA,DATE,ODT,SCND,SCLD,SCFRE,T,TRNGRP
	set ER=0

	type RecordDEP dep = Db.getRecord("DEP","CID")
	
	set SCND=dep.scnd			// Service Charge - Next Date
	set SCLD=dep.scld			// Service Charge - Last Date	

	if SCLD="" do {
		set SCFRE=dep.scfre		// Service Charge Frequency
		if SCFRE="" quit 0
		set NJD=$$NJD^UFRE(SCND,SCFRE,,"1") if ER quit 0
		set ODT=dep.odt			// Date Account Opened
		set SCLD=NJD
		if SCLD'>ODT set SCLD=ODT-1
		}

	if SCEFD>SCLD quit 0			// #3
	
	type ResultSet rs1 = Db.select("FEEDT,PLTP", "FEEPLN", "PLAN=:PLN AND FEEDT<:SCEFD+1", "FEEDT DESC")
	set DATE = rs1.getCol("FEEDT")
	quit:DATE.isNull()
	set PLTP = rs1.getCol("PLTP")

	set T=""
	set TRNGRP=""
	set PLAN=PLN
	set FEEDT=DATE
	set FEECAT=3
	
	type ResultSet rs = Db.select("FEETYP","FEESRV","PLAN=:PLAN AND FEEDT=:FEEDT AND FEECAT=:FEECAT")

	while rs.next() do { quit
		if rs.getCol(1)="" quit
		set TRNGRP=rs.getCol(1)
		new feesrv
		type RecordFEESRV feesrv
		set feesrv=Db.getRecord("FEESRV","PLAN,FEEDT,FEECAT,TRNGRP")
		if feesrv.chgopt'=2 quit
		
		type ResultSet rs2 = Db.select("MAX(TRNGRPDT)", "UTBLTRNGRPT", "TRNGRP=:TRNGRP AND TRNGRPDT<:SCEFD+1", "TRNGRPDT DESC")
		if rs2.next() set DATA = rs2.getCol(1)
		else  quit		
       		if Db.isDefined("UTBLTRNGRP","TRNGRP,DATA,ETC") set T=1   // #4
		}
	
	if 'T quit 0

	quit 1

Public EVENTTRM(RecordPRODCTL prodctl,TYPE,FEETYP)  
  
        /* 
	 
          Arguments: 
	  . RecordPRODCTL prodctl	/TYP=RecordPRODCTL/REQ=Y/N 
	  . TYPE			/TYP=T/REQ=Y/N		 
		Product Type		 
	  . FEETYP			/TYP=T/REQ 
		Fee Type		 
  
	  Returns: 
	  . ETC			 
		Debit tran code for event related fee 
		 
	  Example: 
	  set ETC=$$EVENTTRM^BCHFEEUT(300,"AVL") 
  
	*/ 

	type String TMPETC 
	
	if prodctl.getPointer() set TMPETC=$$FINDETC(.prodctl,FEETYP) 
	else  set TMPETC=$$FINDPROD(TYPE,FEETYP) 
	  
	quit TMPETC 
	
FINDPROD(TYPE,FEETYP)	 
	 
	/* 
  
	Arguments 
	  . TYPE                        /TYP=T/REQ=Y/N 
		Product Type 
	  . FEETYP                      /TYP=T/REQ 
		Fee Type 
  
	Returns: 
	  . ETC 
		Debit tran code for event related fee 
 
	*/ 

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE") 
 
	set TMPETC=$$FINDETC(.prodctl,FEETYP) 
	
	quit TMPETC 

Public FINDETC(RecordPRODCTL prodctl,FEETYP)  
  
        /* 
	  find tran code for an event related fee 
 	  
          Arguments: 
          . RecordPRODCTL prodctl                /TYP=RecordPRODCTL/REQ 
          . FEETYP 				 /TYP=T/REQ 
  
          Returns: 
          . ETC                 Debit tran code for event related fee 
	 
	 */ 

	if (FEETYP="AVL"),(prodctl.dravl'="") quit prodctl.dravl  
	if (FEETYP="CRD"),(prodctl.drcrd'="") quit prodctl.drcrd  
	if (FEETYP="DLY"),(prodctl.drdly'="") quit prodctl.drdly  
	if (FEETYP="LDG"),(prodctl.drldg'="") quit prodctl.drldg  
	if (FEETYP="LIM"),(prodctl.drlim'="") quit prodctl.drlim  
	if (FEETYP="ODT"),(prodctl.drtrrc'="") quit prodctl.drtrrc  
	if (FEETYP="PATF"),(prodctl.drpatf'="") quit prodctl.drpatf  
	if (FEETYP="PATS"),(prodctl.drpats'="") quit prodctl.drpats  
	if (FEETYP="RET"),(prodctl.drret'="") quit prodctl.drret  
	if (FEETYP="STP"),(prodctl.drstp'="") quit prodctl.drstp  
	if (FEETYP="UNC"),(prodctl.drunc'="") quit prodctl.drunc  
	 
	 
	// general service fee trans code 
	if prodctl.drtrsc'="" quit prodctl.drtrsc 
	 
	// general debit tran code	 
	else  quit prodctl.drtrgp	 
	
	/* --------------------------------------------------------------------
	   The following sections are used by the compiled service fee routines.
	   These are private functions for those routines.
	*/

public FSN	/* Service fee plan detail information (on-line or o/d protection)
	   This section is only executed when the service fee routine is
	   called from the top, not when called by ENT (service fee driver 
	   entry point).
	
	   Called by compiled fee routine.

	   Makes use of the following local variable from the fee routine:

		CARDTYPE, CHGOPT, CID, FEEAMT, FEECAT, FEECNT, FEETYPE,
		MAXDLY, NOTFSN, PLTP, SCND, STPTYP, TR16
	*/ 

	// Direct Transaction fee - A fee plan not associated with account
	if CHGOPT=1,FEECAT=3,'SCND quit
	
	new SAVEMAXD
	type RecordSRVD srvd = Db.getRecord("SRVD","CID=:CID,PLTP=:PLTP,SCND=:SCND,FEECAT=:FEECAT,FEETYP=:FEETYP", 1)

	if CHGOPT=1,MAXDLY do {				// Max daily fee amount
		set SAVEMAXD=srvd.srvdlr_"#"_srvd.srvdly
		if srvd.srvdlr'=%SystemDate do {	// Init daily totals
			set srvd.srvdlr=%SystemDate
			set srvd.srvdly=0
		}
		if srvd.srvdly+FEEAMT>MAXDLY set FEEAMT=MAXDLY-srvd.srvdly
		if FEEAMT<0 set FEEAMT=0
		set srvd.srvdly=srvd.srvdly+FEEAMT
	}

	if FEETYP="CRD" do {			// Card fees
		type RecordSRVCRD srvcrd = Db.getRecord("SRVCRD","CID=:CID,PLTP=:PLTP,SCND=:SCND,CARDTYPE=:CARDTYPE", 1)
		set srvcrd.feecnt=srvcrd.feecnt+1
		do srvcrd.bypassSave()
	}
	
	if FEETYP="STP" do {			// Stop payment fees

		type RecordSRVDTL srvdtl=Db.getRecord("SRVDTL","CID=:CID,PLTP=:PLTP,SCND=:SCND,FEECAT=:FEECAT,FEETYP=:FEETYP,SEQ=:STPTYP",1)
		
		set srvdtl.count=srvdtl.count+1
		
		do srvdtl.bypassSave()
	}

	if NOTFSN quit				// Don't require file updates

	if CHGOPT=1 do {			// Update counts and amounts
		set srvd.srvcntd=srvd.srvcntd+FEECNT
		set srvd.srvcstd=srvd.srvcstd+FEEAMT
	}
	else  do {
		set srvd.srvcnta=srvd.srvcnta+FEECNT
		if FEECAT=2,FEETYP="DLY" do {
			set srvd.srvcsta=srvd.srvcsta+FEEAMT
			set FEEAMT=0
		}
	}

	do srvd.bypassSave()	
	
	// Save fee information for event fees where TR is built in TTXODC.
	if FEECAT=2,CHGOPT=1 do {
		set $P(TR16,"#",11)=CID
		set $P(TR16,"#",12)=FEECNT
		set $P(TR16,"#",13)=CHGOPT
		set $P(TR16,"#",14)=MAXDLY
		set $P(TR16,"#",15)=$G(FEEAMT)
		set $P(TR16,"#",16)=$G(FEEAMT)
		set $P(TR16,"#",17)=$G(SAVEMAXD)
		set $P(TR16,"#",24)=FEECAT
		set $P(TR16,"#",25)=FEETYP
	}
	
	quit
	
	
public FILE	/* File data

	   Called by compiled fee routine.

	   Makes use of the following local variable from the fee routine:

		CHGOPT, CID, CTL, FEE(), FEEAMT, FEECAT, FEECNT, FEER,
		FEETYP, PLTP, SCH(), SCND

	*/
	
	set CHGOPT=$G(CHGOPT)
	if '((CHGOPT=2)!(CHGOPT=3)) set CHGOPT=2 	// Plan modified
	if FEEAMT="*" do {
		new ET
		// Table value not set up, report error, change FEEAMT to null
		set FEEAMT=""
		// Fee for table value not found
		set ET=FEETYP_" "_$$^MSG(50)
		// Assess service fees
		do LOG^UTLEXC($T(+0),"*",$$^MSG(4980),$G(CID),"",ET)
	}

	set FEEAMT=$$^SCARND(FEEAMT,0,CID)
	
	if FEECAT=3,CHGOPT=2 set FEE3A=$G(FEE3A)+FEEAMT
	
	set FEE(CHGOPT)=FEE(CHGOPT)+FEEAMT
	quit:'$E(CTL)					// No updates
	
	if $E(CTL,3),CHGOPT=2,FEECAT=3 set FEER=FEER+FEEAMT
	
	type RecordSRVD srvd = Db.getRecord("SRVD","CID=:CID,PLTP=:PLTP,SCND=:SCND,FEECAT=:FEECAT,FEETYP=:FEETYP", 1)

	if FEECAT>2 set srvd.srvcnta=FEECNT
	set srvd.srvcsta=FEEAMT
	set srvd.chgopt=CHGOPT
	
	do srvd.bypassSave()

	quit:'FEEAMT
	quit:((FEECAT = 2) & (FEETYP = "STP"))	// No schedules supported for STP

	// File SCH info
	quit:'$D(SCH)
	new N
	set N=""
	for  set N=$O(SCH(N)) quit:N=""  do {
		type RecordSRVDTL srvdtl = Db.getRecord("SRVDTL","CID=:CID,PLTP=:PLTP,SCND=:SCND,FEECAT=:FEECAT,FEETYP=:FEETYP,SEQ=:N", 1)

		set srvdtl.count=$P(SCH(N),"|",1)
		set srvdtl.itm=$P(SCH(N),"|",2)
		set srvdtl.base=$P(SCH(N),"|",3)
		do srvdtl.bypassSave()
	}

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60855^32872^Hari Natrajan^50115"	// Signature - LTD^TIME^USER^SIZE
