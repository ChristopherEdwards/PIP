BCHUTL		/*
 
        Procedure ID:  BCHUTL
 
        Description:
 
        This procedure definition is compiled into run-time program BCHUTL.
	It is a library of utilities that are used by the batch definition
	compiler program DBSBCH and compiled batch programs.
 
 
        ---- Revision History ------------------------------------------------
        05/12/06 - RussellDS - CR20967
        	   Add private to labels called by generated batch code.
        	   
        	   Cleaned up scope warnings.
        	   
        	   Modified JOBMGR section to replace use of SQL with
        	   Db.getRecord.
        	   
        	   Modified STATUS section to clean up logic around
        	   Db.getRecord.
        	   
        	   Removed old revision history.
        	   
        05/22/05 - Erik Scheetz - 15676
        	   Removed STOP section and replaced with INTRPT section
        	   in order to use interrupt mechanism when checking to stop 
        	   rather than polling the QUECTRL table.  When thread process
        	   is interrupted %INTRPT will be set with the neccessary 
        	   action to be taken.
	----------------------------------------------------------------------

	*/

	quit
	

	//---------------------------------------------------------------------
public INIT(sysvar)	//Batch initialization
	//---------------------------------------------------------------------
	/*

	Called by compiled batch definition routines.
	ARGUMENTS:
	     . sysvar	System variable string		/TYP=T/REQ/MECH=REF:W

	*/
	
	type public Number %NET
	type public String %FN, %LOGID, TLO

	do SYSVAR^SCADRV0(.sysvar)
	set %LOGID=$$LOGID^SCADRV
	set TLO=$$TLO^UTLO,%NET=1
	set %FN=$G(%FN,"~")
	quit


	//---------------------------------------------------------------------
public STATUS(BCHID)	//Batch status
	//---------------------------------------------------------------------
	/*

	Called by compiled batch definition routines.

	ARGUMENTS:
	     . BCHID	Batch ID			/TYP=T/REQ/MECH=VAL

	INPUTS:
	     . %FN	Function name			/TYP=T/NOREQ
							/DFT="~"

	     . %SystemDate	System Processing date		/TYP=D/REQ

	RETURNS:
	     . $$	Batch status
		   <null> = Batch not run
			0 = Batch aborted
			1 = Batch still active
			2 = Batch has completed
	*/
	
	type public String %FN
	
	type String status

	set %FN=$G(%FN,"~")

	set status=""

	type RecordBCHSTS bchsts = Db.getRecord("BCHSTS", "TJD=:%SystemDate,FN=:%FN,BCHID=:BCHID", 1)

	if (bchsts.getMode() > 0) do {

		// Batch completed
		if bchsts.enddat set status=2

		// Batch still active
		else  if $$VALID^%ZPID(bchsts.job) set status=1

		// Batch aborted
		else  set status=0
	}

	if 'status do {
		set bchsts.job=%ProcessID
		set bchsts.begdat=%CurrentDate
		set bchsts.begtim=%CurrentTime

		do bchsts.save()
	}

	quit status


	//---------------------------------------------------------------------
public EXIT(BCHID)	//Batch exit
	//---------------------------------------------------------------------
	/*

	Called by compiled batch definition routines.

	ARGUMENTS:
	     . BCHID	Batch ID			/TYP=T/REQ/MECH=VAL
	*/
	
	type public String %FN

	set %FN=$G(%FN,"~")

	type RecordBCHSTS bchsts = Db.getRecord("BCHSTS","%SystemDate,%FN,BCHID")

	// Delete batch log
	do Db.fastDelete("BCHLOG","%SystemDate,%FN,BCHID")

	set bchsts.enddat=%CurrentDate
	set bchsts.endtim=%CurrentTime
	do bchsts.save()

	quit


	//---------------------------------------------------------------------
public JOBMGR(String %FN,	// Function name
	      String BCHID,	// Batch name
	      String input())	// Parameters array	/MECH=REFARR:W
	      
	/*
	Job Manager initialization
	*/
	
	type public Boolean ER
	type public String RM
	
	type RecordDBTBL33 dbtbl33 = Db.getRecord("DBTBL33", "%LIBS='SYSDEV',BCHID=:BCHID", 1)
	
	if (dbtbl33.getMode() = 0) do {
		
		set ER = 1
		// Invalid batch number ~p1
		set RM = $$^MSG(4427, BCHID)
		do ^UTLERR
	}
	
	kill input
	
	if 'dbtbl33.threads.isNull() set input("threads") = dbtbl33.threads	
	if 'dbtbl33.msgbufs.isNull() set input("msgbufs") = dbtbl33.msgbufs	
	if 'dbtbl33.maxsize.isNull() set input("maxsize") = dbtbl33.maxsize	
	if 'dbtbl33.thrlvar.isNull() set input("thrlvar") = dbtbl33.thrlvar_","
	set input("thrlvar") = input("thrlvar").get()_"%EVENT,vRESTART"	
	if 'dbtbl33.nonrand.isNull() set input("nonrand") = dbtbl33.nonrand	
	if 'dbtbl33.schrcnt.isNull() set input("schrcnt") = dbtbl33.schrcnt	
	if 'dbtbl33.thrrcnt.isNull() set input("thrrcnt") = dbtbl33.thrrcnt	
	if 'dbtbl33.schtimr.isNull() set input("schtimr") = dbtbl33.schtimr	
	if 'dbtbl33.thrtimr.isNull() set input("thrtimr") = dbtbl33.thrtimr

	set input("batchid")=%FN_"#"_BCHID
	set input("schinit")="vSCHINIT^"_dbtbl33.pgm
	set input("schexec")="vSCHEXEC^"_dbtbl33.pgm
	set input("schexit")="vSCHEXIT^"_dbtbl33.pgm
	set input("thrinit")="vTHRINIT^"_dbtbl33.pgm
	set input("threxec")="vTHREXEC^"_dbtbl33.pgm
	set input("threxit")="vTHREXIT^"_dbtbl33.pgm

	if Db.isDefined("DBTBL33D","""SYSDEV"",BCHID,""schpost"",1") do {
		set input("schpost")="vSCHPOST^"_dbtbl33.pgm
	}

	quit

	//----------------------------------------------------------------------
public INTRPT(%EVENT)	//Check Process Interrupts
	//----------------------------------------------------------------------

	type public String %INTRPT()
	
	if %INTRPT.data() > 1 do INTRPT^IPCMGR
	
	if %INTRPT.get().isNull() quit
	if %EVENT.get().isNull() quit

	type Boolean stop = 0

	if %INTRPT = "STOP" set stop = 1
	else  if %INTRPT = "CTRL" do {

		type RecordQUECTRL quectrl = Db.getRecord("QUECTRL","%EVENT",1)
		if quectrl.ctlmsg="STOP" set stop = 1
		}
	
	set %INTRPT = ""
	
	if stop = 1 do {
		type String ET = "BCHSTOP"
		do ^UTLERR
		do CLOSE^IPCMGR()
		halt
		}
	
	quit


	//---------------------------------------------------------------------
private LOG(LOGDATE,%FN,BCHID,ACCKEYS,ermsg)	// Log exceptions in batch processes
	//---------------------------------------------------------------------

	new dat,io,tim,x

	set io="BCHLOG_"_$S(%FN="~":"",1:%FN)_"_"_BCHID
	set io=io_"_"_$$DAT^%ZM(LOGDATE,"DDMONYY")_".LOG"
	set io=$$FILE^%TRNLNM(io,"SCAU$SPOOL")
	set x=$$FILE^%ZOPEN(io,"/APPEND")
	i 'x quit

	set x=$h
	set dat=$$DAT^%ZM(+x,"DD-MON-YEAR")
	set tim=$$TIM^%ZM($p(x,",",2),"24:60:SS")

	use io write dat_" "_tim_" "_ACCKEYS_" "_$g(ermsg)
	close io
	quit


	//---------------------------------------------------------------------
private CHKLOG(LOGDATE,%FN,BCHID,ACCKEYS)  // Check if record has been processed
	//---------------------------------------------------------------------

        if Db.isDefined("BCHLOG","LOGDATE,%FN,BCHID,ACCKEYS") quit 1
        quit 0


	//---------------------------------------------------------------------
private UPDLOG(LOGDATE,%FN,BCHID,ACCKEYS,CONTEXT)  // Update record in batch log
	//---------------------------------------------------------------------

        type RecordBCHLOG bchlog = Class.new("RecordBCHLOG")

	set bchlog.tjd=LOGDATE
	set bchlog.fn=%FN
	set bchlog.bchid=BCHID
	set bchlog.acckeys=ACCKEYS
	set bchlog.context=CONTEXT

	do bchlog.bypassSave()
	quit


	//---------------------------------------------------------------------
public DUMP(BCHID)	//Dump program stack and symbol table to log file
	//---------------------------------------------------------------------

	type String file

	catch vERROR {
		new ET,RM
		set ET=vERROR.type

		if ET["%GTM-" do ZE^UTLERR quit
		set ET=ET_"-"_vERROR.thrownAt
		set RM=vERROR.description
		do ^UTLERR
	}

	set file=$$FILE^%TRNLNM(BCHID_"_DUMP_"_$J_".LOG","SCAU$SPOOL")
	if '$$FILE^%ZOPEN(file,"WRITE/NEWV",2,1024) quit
	use file

	write !,"===================================================",!
	zshow "*"
	write !,"===================================================",!

	close file
	use 0

	quit

vSIG()	quit "60425^2339^Dan Russell^7455"	// Signature - LTD^TIME^USER^SIZE
