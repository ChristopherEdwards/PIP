public SCARND(AMT,JUS,CID,CRCD,DEC,OPT,NPLUS)	// Standard SCA rounding utility

	/*
		 ORIG:  ROTELLA - 21 JAN 1992
	
	   KEYWORDS: Formatting, Math

	   ARGUMENTS:
	   . AMT  Amount field  				/TYP=N/REQ/MECH=VAL
	
	   . JUS  Justification param 				/TYP=N/NOREQ/MECH=VAL
	     	  Replaces second $J parameter
	
	   . CID  PROFILE/IBS Account # 			/TYP=N/NOREQ/MECH=VAL
	     	  If passed will be used to extract the
	     	  currency code associated with a given
	     	  IBS account
	
	   . CRCD Currency code  				/TYP=T/NOREQ/MECH=VAL
	     	  Used to extract decimal precision factor
	     	  from currency code table (for the given code)
	
	   . DEC  Decimal precision 				/TYP=N/NOREQ/MECH=VAL
	     	  If passed used for decimal precision of
		    rounded amount
	
	   . OPT  Rounding option  				/TYP=T/NOREQ/MECH=VAL
	     	  Option to indicate rounding 'up', 'down', or
	     	  'to the nearest' where:
	     	  "+" = Round up
	     	  "-" = Round down
	     	  null = To the nearest
	
	   . NPLUS  Plus indicator  				/TYP=L/NOREQ/DFT=0
	     	    Indicates if return value should be +'d or
	     	    not (+'ing will remove leading spaces or
	     	    zeros).
	
	   INPUTS:
	   . System  %MCP - Multi currency processing indicator
	
	   RETURNS:
	   . $$  Returns rounded value  			/TYP=N
		   of amount passed to utility
	
	   DESC: Utility to replace dollar / decimal precision rounding
		   done by using MUMPs function $J(...,0,2), etc.
	
	  ======================================================================
	
	   Functions contained within this routine:
	
	    1) Call $$^SCARND(params)
	     -  This is $J mumps rounding function
	
	    2) Call $$FN^SCARND(params)
	     -  This $FN mumps function
	
	    3) Call $$LOAD^SCARND(params)
	     -  This will load a decimal precision
		array or return decimal precision by
		currency.  If %MCP is turned off the
		it will always return 2 or array for
		"USD" currency.
	
	    4) Call $$MOD^SCARND(params) to find modulo
	     divide factor.
	     -  For example:
		I PMT#.01 S PMT=$J(PMT,0,2)
		Replace with
		I PMT#($$MOD^SCARND(params)) S PMT=etc, etc	

	   This utility will be used as a rounding utility in place of
	   $J(AMT,0,2) , etc.  It will require paramters to be passed to
	   to it and will be used as $J
	
	   For Example:
	
	    Old Method with $J
	
	     $J(AMT,0,2) - Rounds AMT to 2 places
	
	    New Method with SCARND
	
	     $$^SCARND(AMT,CID,CRCD,DEC)
	
	     Where  AMT = Figure to be rounded
		CID  = Account number
		CRCD = Currency Code
		DEC = decimal precision
		OPT = round up, down, to nearest
		NPLUS = return value not +'d
	
	     NPLUS is as follows:
		1 = Don't Plus the return
		 null or 0 = plus return value (def)
	
	     OPT is as follows:
	
		null = to nearest
		"-" = up
		"+" = down	
	
	   The rounding priority is as follows:
	
	    If no parameters are passed then the rounding will
	    be based upon %CRCD or the default currency code of
	    the system.
	
	    If CID is passed and no other parameters then rounding
	    is based upon the currency of the account (or %CRCD in
	    a non multi-currency environment).
	
	    If CID is passed and one or more of the other parameters
	    is passed then it's priority is ass follows:
	
	     DEC  = Highest priority
	     CRCD = 2nd priority
	     CID  = 3rd priority
	     %CRCD = 4th priority
	     2 = 5th priority
		
	   In a normal environment this should be given the account number
	   and the utility will extract rounding factor and use it ...
	   the other parameters are provided as an override for the
	   system.
		
	   I18N=QUIT ; Exclude the routine from I18N standards
	
	---- Revision History ------------------------------------------------
	05/15/06 - RussellDS - CR21296
		   Changed to use cache array instead of %CACHE, which is
		   reserved for PSL record objects.
		   
		   Cleaned up scope warnings.
	
	11/22/04 - RussellDS - CR13365
		   Add public tag to SCARND line to eliminate@v PSL warnings.
		   
		   Cleaned up scope warnings.
		   
		   Eliminated DEC function and replaced uses of it with
		   exponentiation.
		
	12/13/02 - CARROLLJ - 51349
		   Modified CRCD section to Instansiate ACN if the record 
		   does not exist.  

	11/05/02 - CARROLLJ - 43583
		   PSL conversion cleanup.

	10/01/01 - MBUIM - 43583
		   Converted to PSL

	*/
	
	type public Boolean %MCP
	
	type Number DP,XAMT

     	set JUS=+$G(JUS)
	set OPT=$G(OPT)
	set NPLUS=+$G(NPLUS)
	set DEC=$G(DEC)

	// Never Plus Strings With Leading Blanks
	if JUS set NPLUS=1
	
	// Priority 1
	if DEC'="" do {	quit XAMT
		if 'NPLUS set XAMT=+$J($$AMT(AMT,OPT,DEC),JUS,DEC)
		else  set XAMT=$J($$AMT(AMT,OPT,DEC),JUS,DEC)
		}
	
	// Nothing else is valid if '%MCP
	if '+$G(%MCP) do { quit XAMT
		if 'NPLUS set XAMT=+$J($$AMT(AMT,OPT,DEC),JUS,2)
		else  set XAMT=$J($$AMT(AMT,OPT,DEC),JUS,2)
		}
	
	// Priority 2
	set CRCD=$G(CRCD)
	if CRCD'="" do { quit XAMT
		if 'NPLUS set DEC=$$LOAD(CRCD,.DP) set XAMT=+$J($$AMT(AMT,OPT,DEC),JUS,DEC)
		else  set DEC=$$LOAD(CRCD,.DP) set XAMT=$J($$AMT(AMT,OPT,DEC),JUS,DEC)
   		}

	// Priority 3
	set CID=$G(CID)
	if CID'="" do { quit XAMT
		if 'NPLUS do {
			if CRCD="" set CRCD=$$CRCD(CID)
			set DEC=$$LOAD(CRCD,.DP)
			set XAMT=+$J($$AMT(AMT,OPT,DEC),JUS,DEC)
			}
		else  do {
			if CRCD="" set CRCD=$$CRCD(CID)
			set DEC=$$LOAD(CRCD,.DP)
			set XAMT=$J($$AMT(AMT,OPT,DEC),JUS,DEC)
			}
		}
	
	// Priority 4
	set CRCD=%SystemCurrency
	if CRCD'="" do { quit XAMT
		if 'NPLUS set DEC=$$LOAD(CRCD,.DP) set XAMT=+$J($$AMT(AMT,OPT,DEC),JUS,DEC)
		else  set DEC=$$LOAD(CRCD,.DP) set XAMT=$J($$AMT(AMT,OPT,DEC),JUS,DEC)
 		}

	if 'NPLUS quit +$J($$AMT(AMT,OPT,2),JUS,2)
	
	// Last Chance
	quit $J($$AMT(AMT,OPT,2),JUS,2)
	

AMT(AMT,OPT,DEC)	// Return rounded amount

	/* Determine if we are going to round up or down and adjust
	   amount accordingly
	*/

	type public Boolean %MCP
	type public Number CID, DP
	type public String CRCD

	type Number LEN, PCE, X

	// No option given
	if $G(OPT)="" quit AMT

	// The number of digits including the decimal point, +1
	set PCE=$F(AMT,".")

	// No decimal place
	if PCE=0 quit AMT

	// If last digit is a 0, don't round
	if $E(AMT,$L(AMT))=0 quit AMT
	set DEC=$G(DEC)

	// Retrieve the number of decimal places
	if DEC="" do {
		if +$G(%MCP) do {
			set CRCD=$G(CRCD)
			if CRCD'="" set DEC=$$LOAD(CRCD,.DP) quit 
			set CID=$G(CID)
			if CID'="" do { quit 	
				if CRCD'="" set CRCD=$$CRCD(CID)
				set DEC=$$LOAD(CRCD,.DP)
				} 
			}
		// If no %MCP then DEC defaults to 2 places
		set DEC=2
		}

	// All digits after the decimal
	set LEN=$E(AMT,PCE,999)

	// No rounding needed
	if $L(LEN)'>DEC quit AMT

	// Round value to nearest
	set X=1/(10**DEC)/2

	if OPT="+" set AMT=AMT+X
	else  set AMT=AMT-X
		
	quit AMT
	

CRCD(CID)	// Find the Account Currency

	type public String cache()

	type String CACHE, CRCD
	

	set CACHE = cache("SCARND").get() 
	set CRCD = ""
	if $P(CACHE, "|", 1) = CID set CRCD = $P(CACHE, "|", 2) quit CRCD

	type RecordACN acn = Db.getRecord("ACN","CID=:CID",1)
	
	set CRCD = acn.crcd
	if CRCD.isNull() set CRCD = %SystemCurrency
	set cache("SCARND") = CID_"|"_CRCD
	
	quit CRCD
	

public FN(AMT,CODE,CID,CRCD,DEC,OPT)	// SCA version of MUMPS $FN

	/*
	
	   KEYWORDS: Formatting, Math
	
	   ARGUMENTS:
	   . AMT  Amount field  				/TYP=N/REQ/MECH=VAL
	
	   . CODE Mumps $FN code   				/TYP=T/MECH=VAL/DFT=","
			    (ie. + - , T P)
	
	   . CID  PROFILE/IBS Account # 			/TYP=N/NOREQ/MECH=VAL
	     	  If passed will be used to extract the
	     	  currency code associated with a given
	     	  IBS account
	
	   . CRCD Currency code  				/TYP=T/NOREQ/MECH=VAL
	     	  Used to extract decimal precision factor
	     	  from currency code table (for the given code)
	
	   . DEC  Decimal precision 				/TYP=N/NOREQ/MECH=VAL
	     	  If passed used for decimal precision of
	     	  rounded amount
	
	   . OPT  Rounding option  				/TYP=T/NOREQ/MECH=VAL
		    Option to indicate rounding 'up', 'down', or
		    'to the nearest' where:
		    "+" = Round up
		    "-" = Round down
		    null = To the nearest
	
	   INPUTS:
	   . System  %MCP - Multi currency processing indicator
	
	   RETURNS:
	   . $$  Returns formatted value   			/TYP=T
		   of amount passed to utility
	
	   DESC:
	   SCA version of $FN to change any place that use the following
	
	   Old Method:
	     $FN(AMT,",",2)
	
	   New Method:
	     $$FN^SCARND(AMT,CODE,CID,CRCD,DEC)
		
	   This function should be used where $FN is used as a rounding
	   tool with "," or sign insertion.
	
	   For Example:
	     $FN(10002.34,",",2) =  10,002.34
	
	   Priority should be same as above:
	
	     DEC  = Highest priority
	     CRCD = 2nd priority
	     CID  = 3rd priority
	     %CRCD = 4th priority
	     2 = 5th priority
	
	   To help with the use of this function we will always default
	   to "," for the code.
		

	*/
	
	type public Boolean %MCP
	type public Number DP
	
	set AMT=+AMT
	set OPT=$G(OPT)
	
	// Default to ","
	set CODE=$G(CODE)
	if CODE=""!("+-,TtPp"'[CODE) set CODE=","
	
	// Priority 1
	set DEC=$G(DEC)
	if DEC'="",DEC'<0 quit $FN($$AMT(AMT,OPT,DEC),CODE,DEC)

	// Want $Fn only with code
	if DEC'="",DEC<0 quit $FN(AMT,CODE)
	
	// Nothing else is valid
	if '+$G(%MCP) quit $FN($$AMT(AMT,OPT,DEC),CODE,2)
	
	// Priority 2
	set CRCD=$G(CRCD)
	if CRCD'="" set DEC=$$LOAD(CRCD,.DP) quit $FN($$AMT(AMT,OPT,DEC),CODE,DEC)
	
	// Priority 3
	set CID=$G(CID)
	if CID'="" do { quit $FN($$AMT(AMT,OPT,DEC),CODE,DEC)
		if CRCD="" set CRCD=$$CRCD(CID)
		set DEC=$$LOAD(CRCD,.DP)
		}
	
	// Priority 4
	set CRCD=%SystemCurrency
	if CRCD'="" set DEC=$$LOAD(CRCD,.DP) quit $FN($$AMT(AMT,OPT,DEC),CODE,DEC)
	
	// Last Priority

	quit $FN($$AMT(AMT,OPT,2),CODE,2)
	
LOAD(CRCD,DP)	// Load DP array by currency code

	/*
	
	   KEYWORDS: Formatting, Math
	
	   ARGUMENTS:
	   . CRCD Currency Code to be 				/TYP=T/NOREQ/MECH=VAL
	    	  loaded from disk.  
	    	  	
	   . DP Decimal precision array 			/TYP=ARY/REQ/MECH=REFARY:RW
	   	Format = DP(CRCD)=precision.
	   
	   INPUTS:
	   . System  %MCP - Multi currency processing indicator
	
	   RETURNS:
	   . $$  Returns decimal precision for rounding  	/TYP=N
		 amount fields if called extrinsically.
		 Note: If %MCP=0 then this will always return 2.
	
	   . DP  Returns DP array with precision amounts 	/TYP=ARY
		 by currency code.  This array can be loaded
		 and returned.
		 Note: If %MCP=0 then this will always return DP("USD")=2
	
	   RELATED:
	   . $$curdec^CRCDUTL Currency code exhange info utility
		 Call returns currency precision from CRCD table
	
	   DESC:
	    Call as follows:
	
	     S DEC=$$LOAD^SCARND(CRCD,.ARRAY)
	
	     CRCD is required for extrinsic return
	   	
	   Note: Always returns 2 or DP("USD")=2 when %MCP is not = 1

	*/
	set CRCD=$G(CRCD)
	// Default to 2
	if CRCD="" quit 2
	if $D(DP(CRCD)) quit DP(CRCD)
	if CRCD="USD" set DP("USD")=2 quit 2

	set DP(CRCD)=+$$curdec^CRCDUTL(CRCD)
	
	quit DP(CRCD)

public MOD(CID,CRCD,DEC)	// Modulo divide factor

	/*
	
	   KEYWORDS: Formatting, Math
	
	   ARGUMENTS:
	   . CID Account Number, used to extract 		/TYP=N/COND
	   	 currency code from Account record
	    	 to find currency decimal precision
	
	   . CRCD Currency Code, used to extract 		/TYP=T/COND
	     	  currency decimal precision from CRCD record
	
	   . DEC Decimal precsion factor  			/TYP=N/COND
	
	   Note:  Only one of three agruments are required.
	
	   INPUTS:
	   . System  %MCP - Multi currency processing indicator
	
	   RETURNS:
	   . $$ Returns factor needed to be used  		/TYP=N
	    	for modulo divide to determine if
	    	there is a remainder given a currecny's
	    	decimal precision.
	
	   DESC:
	   Find factor to determine if rounding is needed
	
	   For example:
	
	    Old Method:
	     PMT = 100.34987
	
	     I PMT#.01 S PMT=$J(PMT,0,2)
	
	     PMT#.01 would return .00987
	     therefore we would want to round in
	     this case.
	
	    New Method:
	     PMT = 100.34987
	
	    I PMT#($$MOD^SCARND(CID)) S PMT=$$^SCARND(PMT,0,CID)
	
	    This will enable the correct factor to be used by
	    the modulo divide (ie. decimal precision of 3 places
	    should use .001)

	*/
	
	type public Boolean %MCP
	type public Number DP

	set DEC=$G(DEC)
	if DEC'="" quit 1/(10**DEC)
	
	// Non Multi Curr
	if '+$G(%MCP) quit 1/100
	
	set CRCD=$G(CRCD)
	if CRCD'="" set DEC=$$LOAD(CRCD,.DP) quit 1/(10**DEC)
	set CID=$G(CID)
	if CID'="" set DEC=$$LOAD(CRCD,.DP) quit 1/(10**DEC)
		
	quit 1/100

vSIG()	quit "60401^67469^Dan Russell^11841"	// Signature - LTD^TIME^USER^SIZE
