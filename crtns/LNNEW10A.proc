public LNNEW10A(RecordLN ln,RecordLNPS1 lnps1(),RecordLNAMOAO lnamoao())

	/*

	   Calculate Disclosure Data, Call APR Calculator

	   ORIG:  Unknown
	
	   Part II of LNNEW10 -- variables used in LNNEW10 are active here.
	
	---- Revision History ------------------------------------------------
	
	07/31/06 - KELLYP - CR 22048
		   Modified A1A and P6 sections to eliminate PRECEDENCE warnings.
	
	01/26/06 - TITOVE - CR 19238
		   Modified DIS section to correct setting of DISAMF.

	02/11/05 - TITOVE - CR 13726
		   Moved code from P8 and P9 into P7, also fixed infinite loop
		   in P7 section. Made this procedure public.

	12/13/02 - CARROLLJ - 51349
		   Modified DIS section to fix undefined error on disamf and 
		   also modified call to LNAPR to not pass lnps1 and lnamoao.

	11/19/02 - APPLEYARDM - 50943
                   Modified section PCHG1: removed code calculating caf on
                   the basis of ln.pcfre. These payment change methods should
                   only use ln.caf, ln.ppinc and ln.numchg to calculate payment
                   amounts. Corrected logic setting number of payments into
                   P2 array. Removed code newing pcfre and code setting pcfre
                   in section PCHG. Payment change calculations for ln.pchm
                   equals 2 or 3 no longer require pcfre.
 
	07/08/02 - CARROLLJ - 43583
		   PSL conversion cleanup.

	02/07/02 - CARROLLJ - 43583
		   Convert to PSL.

	  ----------------------------------------------------------------------
	
	*/

	do DIS(.ln,.lnps1(),.lnamoao())
	
	quit


DIS(RecordLN ln,
    RecordLNPS1 lnps1(),
    RecordLNAMOAO lnamoao())
    
	// Calculate Loan Disclosure Data, call APR Calculator

	type public Date mdt, sldtd
	type public Number aprapp, ballamt, comfa, comfp, crlmt, dispmp, disppi
	type public Number idpf, iun, orgfa, orgfp, pchm, CID, COINT, TBAL
	type public String changes(), CF(), CRCD

	type Date CTRM
	type Number CRLMT, DISTPF, DISAMF, DISTFC, N, TP, X, Y
	type String P1, P2
	
	if (pchm = 2) ! (pchm = 3) do PCHG1(.ln)
	
	if 'orgfa do {
	
		set orgfa = $$^SCARND((crlmt * orgfp) / 100,0,CID)
		set ln.orgfa = orgfa
		set changes("ORGFA") = orgfa
		}
		
	if 'comfa do {
	
		set comfa = $$^SCARND((crlmt * comfp) / 100,0,CID)
		set ln.comfa = comfa
		set changes("COMFA") = comfa
		}
	
	set DISTPF = disppi + dispmp + orgfa + comfa
	set DISAMF = crlmt - iun - DISTPF 
	set DISTPF = DISTPF + aprapp
	set ln.disamf = DISAMF - aprapp
	set changes("DISAMF") = DISAMF - aprapp
	set DISTFC = 0
	
	do ^LNAPR(.ln)
	
	// Loop through CF array to calculate total interest charges, 
	// total of payments.
	set (N,TP) = 0	
	for  set N = CF(N).order() quit:N.isNull()  set TP = TP + (CF(N).piece("|",1) * CF(N).piece("|",2))
	
	if TP set TP = $$^SCARND(TP,0,,CRCD)
	
	// If the loan is a constuction loan, modify TP
	if idpf do A(.ln) quit
	
	set CTRM = sldtd
	
	if CTRM.isNull() do A(.ln) quit
	
	set CRLMT = crlmt - iun
	
	if ballamt set CRLMT = crlmt - iun - ballamt
	
	if (CTRM = mdt) do {
		
		set (TBAL,Y) = CRLMT
		set TP = TP + $$^SCARND(Y / 2,0,,CRCD)
		do A1(.ln) quit
		}
		
	set X = TP - TBAL + COINT 
	set X = X - TP + CRLMT 
	set TP = X + CRLMT 
	set TBAL = TBAL + X 

	do A1(.ln)
	
	quit
	

A(RecordLN ln)

	if ln.aprmthd=2,'TP,dist1fre="*" do A1A(.ln) quit
	if dist1fre="*" do A1(.ln) quit
	if ambas>1,$E(pcmval) do A1(.ln) quit
	if ln.aprmthd=2,'TP,'$E(pcmval),ambas>1,mdt'="" do A1A(.ln) quit
	if mdt'="" do A1(.ln) 
	quit
	

A1A(RecordLN ln)
	/*
	For APR Calculation Method 2, under certain conditions it is
	possible that TP (Total Payments) is not defined yet.  In these
	cases control must pass thru tag A1A to define TP.  Otherwise,
	on the loan create disclosure screen, Finance Charge will be the
	negative of Principal Amount and Total Note Amount will be zero.

	If the loan is a non-P+I loan, make the interest 1 full year.
	*/

	set TP=PRIN+lnamfees+$$^SCARND((PRIN+lnamfees)*(+irn)*DIY/(DIY*100),0,,CRCD)
	do A1(.ln) quit
	
A1(RecordLN ln)

	if $E(iam)=2 set TBAL=TBAL-distint+COINT
	set TP=$$^SCARND(TP,0,,CRCD)
	if 'flat do {
		set distint=TP-TBAL+COINT
		if ballamt set distint=(TP-(TBAL-ballamt))+COINT
		}
	set ln.distint=$G(distint)
	set changes("DISTINT")=$G(distint)
	if 'flat set distpmt=+TP
	set ln.distpmt=distpmt
	set changes("DISTPMT")=distpmt
	set DISTFC=DISTFC+DISTPF+$G(distint)+dismip
	if $E(iam)=2 set DISTNOT=distpmt
	else  set DISTNOT=crlmt+dismip+$G(distint)
	set DISTPTS=orgfa+comfa
	quit 
	

public	PCHG(RecordLN ln) //Set up P&I changes & pmt #'s for GEM and IEM's

	/*
	   Called from LNCALNF
	   This preserves the old calling mechanism with LN array for now
	*/

	new amtreq,caf,changes,CRCD,data,dist1af,I,irn,numch,onp,P1,P2,PCE
	new pchm,pmtpi,ppinc
	
	// Amount Requested
	set amtreq=ln.amtreq

	// Number of Payments Per Change
	set caf=ln.caf

	// Number of Payment Changes
	set numch=ln.numch

	// Payment Percentage Increase
	set ppinc=ln.ppinc

	// Currency Code
	set CRCD=ln.crcd

	// Distribution 1 Annual Factor
	set dist1af=ln.dist1af

	// Nominal Int/Div Rate
	set irn=ln.irn

	// Original Number of Payments
	set onp=ln.onp

	// Payment Change Method
	set pchm=ln.pchm

	// Principal and Interest Payment
	set pmtpi=ln.pmtpi

	do PCHG1(.ln)
	quit 
	

PCHG1(RecordLN ln)

	/*
	  Private; Entry point from above with needed variables defined
	  Define P1 as null if called from this routine for new loans
	*/

	new A,B,BCT,BN,C,CNTR,FV,J,NUMPMTS,PT,X

	set PT=pmtpi
	set NUMPMTS=onp 
	if 'NUMPMTS set NUMPMTS=ambas
	set FV=amtreq

	// Required if payment change method equals 2 or 3
	if caf="" do Runtime.setErrSTBLER("LN","LNGPMREQ") quit:ER

	set AM=NUMPMTS
	set CNTR=1
	set (A,C)=1 
	set P2="" 
	set BCT=-1 
	set BN=0
	for  do P(.ln) quit:(C>(numch+1))!(pchm=3&(FV<0))!(CNTR>15)	
	do P1(.ln) 
	quit

P(RecordLN ln)	

	set B=A+caf-1
	if C=(numch+1) set B=NUMPMTS
	set X=A_"|"_B_"|"_+PT_"|"
	set P2=P2_X 
	set BCT=BCT+3 
	set CNTR=CNTR+1
	if CNTR>15 quit
	if pchm=3 set Z=B-A+1 do P4(.ln)
	if pchm=3,FV<0 quit 
	set CF(C)=PT_"|"_(B-A+1)
	set PT=$$^SCARND(PT*(1+(ppinc/100))+.0099,0,,CRCD) 
	set C=C+1
	set A=B+1
	quit
	
P1(RecordLN ln)

	if pchm=3 do P7(.ln)
	if ln.pa1f="" do SETPA(.ln,P2) quit 
	set (I,J)=1 
	set X=""

	set P1=ln.pa1f_"|"_ln.pa1t_"|"_ln.pa1a_"|"_ln.pa2f_"|"_ln.pa2t_"|"_ln.pa2a_"|"_ln.pa3f_"|"_ln.pa3t_"|"_ln.pa3a
	set P1=P1_"|"_ln.pa4f_"|"_ln.pa4t_"|"_ln.pa4a_"|"_ln.pa5f_"|"_ln.pa5t_"|"_ln.pa5a_"|"_ln.pa6f_"|"_ln.pa6t_"|"_ln.pa6a
	set P1=P1_"|"_ln.pa7f_"|"_ln.pa7t_"|"_ln.pa7a_"|"_ln.pa8f_"|"_ln.pa8t_"|"_ln.pa8a_"|"_ln.pa9f_"|"_ln.pa9t_"|"_ln.pa9a
	set P1=P1_"|"_ln.pa10f_"|"_ln.pa10t_"|"_ln.pa10a_"|"_ln.pa11f_"|"_ln.pa11t_"|"_ln.pa11a_"|"_ln.pa12f_"|"_ln.pa12t
	set P1=P1_"|"_ln.pa12a_"|"_ln.pa13f_"|"_ln.pa13t_"|"_ln.pa13a_"|"_ln.pa14f_"|"_ln.pa14t_"|"_ln.pa14a_"|"_ln.pa15f
	set P1=P1_"|"_ln.pa15t_"|"_ln.pa15a
	for I=1:3:45 do P2
	do SETPA(.ln,X)
	quit

P2	
	set A=$P(P1,"|",I,I+2) 
	set B=$P(P2,"|",I,I+2) 
	if '+A,'+B quit
	set A1=$P(A,"|",1) 
	set B1=$P(B,"|",1) 
	set C1=$S(A1<B1:A1,1:B1)
	set A2=$P(A,"|",2) 
	set B2=$P(B,"|",2)
	set C2=$S(A1=B1:$S(A2<B2:A2,1:B2),1:$S(B1<A2:B1,1:B2))
	set A3=$P(A,"|",3) 
	set B3=$P(B,"|",3) 
	set C3=A3+B3
	set X=X_C1_"|"_C2_"|"_C3_"|"
	quit
	
P4(RecordLN ln)	

	/* 
	   Calculate the ending balance at each payment change if IEM, stop
	   calculations at the point where the balance goes negative
	*/

	if Z'>caf do P5 quit
	set N=Z\caf 
	set F=Z#caf
	for J=1:1:N set Z=caf set BN=BN+caf do P6 quit:FV<0 
	if FV<0 do { quit:FV<0 
		set FV=XFV 
		set BN=BN-caf 
		for I=1:1 set Z=1 set BN=BN+1 do P6 
		}
	if FV<0 set CF(C)=PT_"|"_(BN-((C-1)*caf)-1) set CF(C+1)=(PT+FV)_"|1"
	if FV<0 do { quit 
		set B=BN 
		set $P(P2,"|",BCT)=BN
		set onp=BN
		set ln.onp=onp
		set changes("ONP")=onp
		}
	else  if F for I=1:1:F do P6 quit:FV<0 
	if FV<0 do { quit 
		set B=BN set $P(P2,"|",BCT)=BN
		set onp=BN
		set ln.onp=onp
		set changes("ONP")=onp
		}
	quit 
	

P5	
	do P6 set BN=BN+caf quit 
	
P6	
	set BN=BN+1 
	set Z=1
	set IR1=+irn/(dist1af*100) 
	set EXP=1+IR1 
	set POW=EXP 
	set XFV=FV
	for I=2:1:Z set EXP=EXP*POW
	set FV=$$^SCARND((((1-EXP)/IR1)*PT)+(FV*EXP),0,,CRCD)
	quit 

	
P7(RecordLN ln)	

	type public Boolean flat
	type public Number amtreq, distint, distpmt, A, B, C, FV
	type public String changes(), CRCD, P2

	type Number P, ZPMT

	set C = 2 
	set ZPMT = FV.roundCur(CRCD)
	
	for  do { quit:(A.isNull()) ! (B.isNull()) ! (C.isNull())
		
		set A = P2.piece("|",C - 1) 
		set B = P2.piece("|",C) 
		set P = P2.piece("|",C + 1)
		
		if (A.isNull()) ! (B.isNull()) ! (C.isNull()) do { quit
			
			if 'flat do {
	
				set distpmt = +ZPMT
				set distint = ZPMT - amtreq
			}
	
			set ln.distint = distint
			set changes("DISTINT") = distint
			set ln.distpmt = distpmt
			set changes("DISTPMT") = distpmt
		}
		
		set ZPMT = ZPMT + ((B - A + 1)*P)
		set C = C + 3
	}

	quit

	
SETPA(RecordLN ln,PA)	//Private; Move values in X into PAn data items

	new PMTAMT

	for PNUM=1:1:15 set PMTAMT=PNUM*3 quit:$P(PA,"|",PMTAMT)=""  do ^LNGPM(.ln,PNUM,$P(PA,"|",PMTAMT-2),$P(PA,"|",PMTAMT-1),$P(PA,"|",PMTAMT))

vSIG()	quit "60477^65454^Pat Kelly^8617"	// Signature - LTD^TIME^USER^SIZE
