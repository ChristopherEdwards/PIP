BCHRETRY //Batch BCHTTXRTY - Retry Processing
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 12:47 - shetyes
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHTTXRTY Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit quit
 do JOBMGR^BCHUTL(%FN,"BCHTTXRTY",.vINPUT)
 do ^JOBMGR(.vINPUT)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(TJD,BRCD,UID,TSEQ) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHTTXRTY","*","",TJD.get()_","_BRCD.get()_","_UID.get()_","_TSEQ.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,TJD,BRCD,UID,TSEQ)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHTTXRTY","*","",TJD.get()_","_BRCD.get()_","_UID.get()_","_TSEQ.get(),"",et)
 }
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,TJD,BRCD,UID,TSEQ) //
	
	/*
	             Variables used :
	 
	    LJD           =  EXC's posted date
	    TJD           =  today (business date)
	    RTY           =  number of times remaining to retry
	    MARTY         =  maximum number of retries
	    RTUID         =  batch retry teller
	    BUID          =  original batch teller
	    BSEQ          =  retry batch sequence
	    CRCD          =  currency code
	    CID           =  account number
	    TSEQ          =  sequence number in the EXC file
	    SAVSQ         =  starting sequence number in EXC screen (TSEQ\1000)
	    ENDSQ	  =  ending sequence number EXC screen (TSEQ\1000+1*1000)
	    TSSEQ         =  sequence number in the new transaction set
	    SEQ		  =  sequence number in the new TTX file
	
	   Look at the exception files for both the original batch
	   teller and the retry teller (for previous retry exceptions).
	
	   Collate thru the Exception file, setting up a TTX batch
	   for the next business day for records that meet the following
	   conditions :
	 
	   1) The record has not been tried the maximum # of times.
 	   2) The reject reasons for the record are all contained
	      in the user table RETRY.

 	*/
	
	type public String par(), BUID, SRC, TSCRGL, TSDRGL
	type public Number %ODP,BSEQ, MAX, REJMET, SAVSQ
	type public Date LJD, SJD, TPD
	
	type Number CHCID, ENDSQ, RFLG, SEQ1, TSSEQ, STAT, TTXPTR()
	type Boolean FAIL,FOUND
	type String PATFEE, RJ(), RTY, TSO
	
	type RecordBCHLOG tmp = Class.new("RecordBCHLOG")
	type RecordTTX ttx()
	
	set tmp.tjd = SJD
	set tmp.fn = "BCHTTXRTY"
	set tmp.bchid = 1
	set tmp.acckeys = LJD_","_BRCD_","_BUID_","_TSEQ
	
	do tmp.bypassSave()

	set TSSEQ = 0
	set SEQ1 = TSEQ - 1
	set ENDSQ = ((TSEQ \ 1000) + 1) * 1000
	
	type DbSet ds = Db.selectDbSet("EXC", "TJD=:LJD AND BRCD=:BRCD AND UID=:BUID AND TSEQ>:SEQ1 AND TSEQ<:ENDSQ")
	if ds.isEmpty() quit
	set FOUND=0
	while ds.next() do {
		type RecordEXC exc = ds.getRecord()

		set TSEQ = exc.tseq
		//set RTY=exc.rty
		// Check # of times this record has remaining to retry.
		if (TSDRGL=exc.cid) ! (TSCRGL = exc.cid) quit
		if (exc.rty.isNull() ! (exc.rty = 0)), (%ODP '= 2), (MAX > 0) quit
		if exc.rty < 0, (%ODP = 2), (MAX > 0) quit				
		//if MAX > 0, 'exc.rty quit
		do PROC(.exc, .ttx())
		set FOUND=1
		}

	#ACCEPT DATE=03/31/05;PGM=SmithCD
	if FOUND=0 quit
	set %SystemDate = SJD
	do TRNSET^TRNDRV(.ttx(),%SystemDate,BRCD,4,,.RJ())
	
	set TSSEQ = ""
	set (PATFEE, RFLG) = 0
	for  set TSSEQ = ttx(TSSEQ).order() quit:TSSEQ.isNull()  do { quit:RFLG ! ('PATFEE)
		type String UTSO
		
		set RTY = ttx(TSSEQ).rty
		
		if {String}RTY.isLike("%*%") quit
		
		set TSO = ttx(TSSEQ).tso
        	set UTSO = ""
        	do OUT^UTSO(.UTSO, TSO)

        	if 'UTSO("PAT").data() quit 

		do PAT

		if 'PATFEE quit

		set FAIL = 0
	
		if REJMET > 0 set STAT = RJ.data(), RFLG = 1
		else  set STAT = RJ(TSSEQ).data()

		/*
		FAIL=0 (Successful) - Process PATS fee
		FAIL=1 (Failed no more retries) - Process PATF fee
		FAIL=2 (Failed with more retries) - No fee at this time	
		*/
	
		// Successful Batch - Calculate batch successful fee
		if 'STAT quit  	      // FAIL=0
	
		// Failed Batch (Rejected) - Only calculate fee when no
		// more retries are remaining.
		if STAT, RTY set FAIL = 2
	
		// Failed Batch (Rejected) - No more retries, calculate
		// batch fail fee. (STAT,'RTY)
		else  set FAIL=1
		}
	
	if 'PATFEE quit
	
	if FAIL = 0 do FEE^PATFEE("PATS", CHCID)
	if FAIL = 1 do FEE^PATFEE("PATF", CHCID)
		
	quit

	
PROC(RecordEXC exc,		// Exception record		/REF:R
     RecordTTX ttx())		// transaction object array	/REF:W
     
	// At this stage, the transaction will be set up for posting today
	
	type public String %SystemCurrency, BUID, SRC, XSRC
	type public Number TSSEQ, BRCD, TSCRGL, TSDRGL
	type public RecordTTX ttx()
	
	type String CRCD, TAMT, TSO
	type Boolean DC, ER
		
	set ER = 0
	set DC = exc.itc.extract()
	set TAMT = exc.tamt
	set CRCD = exc.crcd
	
	// Can't guarantee EXC record will contain CRCD
	if CRCD.isNull() set CRCD = %SystemCurrency

	set TSSEQ = TSSEQ + 1
	set ttx(TSSEQ) = exc.copy("CC=BEN,BCRCD=OTCMT,XPDO=OTSO,SYSBASE=DISC")

	set ttx(TSSEQ).tjd = %SystemDate
	set ttx(TSSEQ).brcd = BRCD
	set ttx(TSSEQ).uid = BUID
	set ttx(TSSEQ).cid = exc.cid

	//Reset TSO, TCMT to the original value

	set TSO = exc.otso

	set XSRC = $$FIELD^UTSO(TSO, "POSTSRC")
	if 'SRC.get().isNull(), XSRC.get().isNull() set TSO = $$FIELDIN^UTSO(TSO, "POSTSRC", SRC)

	set ttx(TSSEQ).tso = TSO
	set ttx(TSSEQ).tcmt = exc.otcmt		// Teller comment
	
	// Don't create offsets for non-financial transactions.
	if exc.itc.isNull() quit
	
	/* 
	This section will set up the individual balancing debit
	or credit to the GL suspense account of the teller that 
	had the transactions reject.
	 
	If the original transaction was a credit, use debit tran code,
	debit offset.  Otherwise, use credit tran code, offset.
	*/

	set TSSEQ = TSSEQ+1
	set ttx(TSSEQ) = Class.new("RecordTTX")		// Added by FRS
	
	if DC do {
		 set ttx(TSSEQ).cid = TSDRGL
		 set ttx(TSSEQ).etc = "TSDR"
		 }
	else  do {
		  set ttx(TSSEQ).cid = TSCRGL
		  set ttx(TSSEQ).etc = "TSCR"
		  }
	
	set ttx(TSSEQ).tamt = TAMT
	set ttx(TSSEQ).tlo = exc.tlo
	set ttx(TSSEQ).crcd = CRCD
	set ttx(TSSEQ).tso = exc.otso
	set ttx(TSSEQ).tcmt = exc.otcmt
	set ttx(TSSEQ).itc = 'DC
	set ttx(TSSEQ).rty = "*"
	
	quit


PAT     // If PAT transaction, assess PAT batch fee.
	
	type public String %UserID, UID
	type public Number ACN, CHCID
	type public String BATCH, PAT, UTSO
	type public Boolean PATFEE
	
	type RecordUTBLSRC utblsrc = Db.getRecord("UTBLSRC", "SRCTYP='PAT',KEY=:UTSO(""PAT"")")

	set PATFEE = utblsrc.patfee

	if 'PATFEE quit
	
	set PAT = UTSO("PAT")
	set ACN = UTSO("PATA").get()
	set BATCH = UTSO("PATB").get()
	set CHCID = UTSO("SRVCID").get()
	set UID = %UserID

	if CHCID.isNull() set PATFEE = 0

	quit


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
	
		
	type public String vRECORD
	type public Boolean ER
	
	type Number BRCD, BSEQ, SRC, SAVSQ, TSEQ
	type String BUID
	type Date LJD, SJD
	
	set SJD = %SystemDate
	set BSEQ = ""
        set vRECORD = vINPUT
        set BRCD = vRECORD.piece("#", 1)
        set BUID = vRECORD.piece("#", 2)
	
	do INIT quit:ER
	
	type DbSet ds = Db.selectDbSet("DAYENDRTY", "TJD=:%SystemDate AND BRCD=:BRCD AND BUID=:BUID")
	
	while ds.next() do {
		
		type RecordDAYENDRTY dayendrty = ds.getRecord("DAYENDRTY")

		set LJD = dayendrty.ljd
		set SAVSQ = 100
	
		type ResultSet rs = Db.select("TSEQ", "EXC", "TJD=:LJD AND BRCD=:BRCD AND UID=:BUID")
        
        	while rs.next() do {
        		type String ACCKEYS
        		
        		set TSEQ = rs.getCol("TSEQ")
        		set ACCKEYS = LJD_","_BRCD_","_BUID_","_TSEQ
			
			if (TSEQ \ 1000) * 1000 = SAVSQ quit
			
			if 'Db.isDefined("BCHLOG", "TJD=:%SystemDate,FN=""BCHTTXRTY"",BCHID=1,ACCKEYS=:ACCKEYS") do vPROC(LJD, BRCD, BUID, TSEQ)
			
			set SAVSQ = (TSEQ \ 1000) * 1000
			}
	
		/* 
		The status of each dayend entry is being set so that the
		exception file can be edited for those tellers not
		processed (TTXRTYE.M).  The setting of this column is not
		being used for restart purposes.
		*/
	
		set dayendrty.stat = "*"
		do dayendrty.bypassSave()
		}
	
        quit
	

INIT	// Initialize
	
	type public Boolean %ODP, %RET, ER, RTSN
	type public String %UserClass, %UserID, BUID, ETC, RTUID
	type public String SRC, RTSN()
	type public Number BRCD, MARTY, MAX, OCC, REJMET, TSCRGL, TSDRGL
	
	if 'ER.data() set ER = ""

	type RecordUTBLBRCD utblbrcd = Db.getRecord("UTBLBRCD", BRCD)
	set OCC = utblbrcd.ccdef
	 
	type RecordSCAU scau = Db.getRecord("SCAU", BUID)

	set RTUID = scau.rtuid
	if 'RTUID set RTUID = BUID
	
	set %UserID = RTUID

	/* 
	Much of the following initialization was previously done by
	%EXT^TTXPOS and ^TTXP1.  We will no longer be calling those
	programs in this retry process.  
	*/
	
	type RecordSCAU scaur = Db.getRecord("SCAU", "UID=:RTUID")
	
	set %UserClass = scaur.%ucls
	set (MAX,MARTY) = scaur.marty
	set REJMET = scaur.batrej
	set %RET = 0
	set TSDRGL = scaur.tsdr
	set TSCRGL = scaur.tscr
	set %ODP = scaur.odp
	set RTSN = scaur.sdrty

	type RecordTTXUID ttxuid = Db.getRecord("TTXUID", "TJD=:%SystemDate,BRCD=:BRCD,UID=:BUID",1)

	set SRC = ttxuid.src
        if 'SRC.isNull() do {
        	type RecordCTBLINC ctblinc = Db.getRecord("CTBLINC", "KEY=:SRC", 1)        	
        	set %RET = ctblinc.retsdr
        	}
	
	/* 
	If Same Day Retry is turned on, set RTSN = 1. There is no need
        to build the retry reason array, since ALL rejects will be
        reprocessed. Also, turn off overdraft protection since rejected
        transactions will be reprocessed later in the day.   
	*/
	
	if RTSN set %ODP = 0	// Same Day Retries
	else  do {
		
		type String grp, rest
		
		type ResultSet rs = Db.select("GRP,REST", "UTBLRETRY")
		
		while rs.next() do {
			set grp = rs.getCol("GRP")
			set rest = rs.getCol("REST")
			set RTSN(grp, rest) = ""
			}
		 }
	
	quit


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
	type public Number BRCD
	type public String BUID

	// Only pass one branch and one teller to each thread for processing.
	
	if vINPUT.get().isNull() set vINPUT = BRCD_"#"_BUID quit
	else  set vINPUT = ""

	do GETBUID

	if 'BUID.isNull() set vINPUT = BRCD_"#"_BUID quit

	do GETBRCD

	if 'BRCD.isNull() do GETBUID
	if 'BUID.isNull() set vINPUT = BRCD_"#"_BUID quit
	
	quit

	
GETBRCD	// Get branch code

	type public Number BRCD
	
	type ResultSet rs = Db.select("BRCD", "DAYENDRTY", "TJD=:%SystemDate AND BRCD>:BRCD", "BRCD ASC")
	
	if rs.next() set BRCD = rs.getCol("BRCD")
	else  set BRCD = ""
	
	quit


GETBUID	// Get user ID
	
	type public Number BRCD
	type public String BUID
	type ResultSet rs
	if BUID.isNull() do {
		set rs = Db.select("BUID", "DAYENDRTY", "TJD=:%SystemDate AND BRCD=:BRCD", "BUID ASC")
		}
	else  {
		set rs = Db.select("BUID", "DAYENDRTY", "TJD=:%SystemDate AND BRCD=:BRCD AND BUID>:BUID", "BUID ASC")
		}
	if rs.next() set BUID = rs.getCol("BUID")
	else  set BUID = ""
	
	quit
	

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	/*
	The calling of ^TTXP1 for batch postings resulted in an entry being 
	created in DAYEND for all tellers for which retry processing applied.  
	Since we will no longer call ^TTXP1 for all batch processing, an entry 
	will be created in DAYEND for all tellers that have retry processing 
	and that have an ^EXC file defined for the current date. This will set 
	up a retry entry in the DAYEND file for the next business date if it 
	doesn't already exist. See procedure definition SETRETRY.
	*/
	
	type public Boolean ER = 0
	type public Date TPD
	type public Number BRCD = -1
	type public String BUID = ""

	type ResultSet rs = Db.select("GRP,REST", "UTBLRETRY")

	// There are no reasons for retry set up
	if rs.isEmpty() set (ER, %BatchExit) = 1 quit   

	set TPD = %SystemDate
	
	do ^SETRETRY
	
	// Get the first branch and teller set up for retry processing

	do GETBRCD
	
      	// There are no entries to retry
	if BRCD.isNull() set %BatchExit = 1 quit

	do GETBUID

	quit

	
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("TJD,BRCD,UID,TSEQ","EXC","")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	type public String par()
	type public Date TPD

	set TPD = %SystemDate

	
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
	do Db.fastDelete("BCHLOG", "TJD=:%SystemDate,FN=""BCHTTXRTY""")

	
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
