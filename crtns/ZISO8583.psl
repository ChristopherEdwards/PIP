ZISO8583(IM)
	/*
	 Procedure Id: ZISO8583
	 DESC: Walmart ISO8583 Interface (Custom)
	 ORIG: Brandon Rickards
	 DATE: 02-January-2007

	 ---- Comments --------------------------------------------------------

	 ---- Revision History ------------------------------------------------

	08/22/07 - Brandon Rickards - CR 28685
		o Modified section ATMPROC to parse BIT(126) to determine new 
		  PIN Block for PIN Change Requests.
		o Added section DELUXE126 to parse BIT(126)
		o Modified section ATMPROC to include Card Type in call to
		  $$VEROFST^ZHSMAPI.
		o Modified section INIT2 to store the Original Process Code
		o Modified section NETWORK to pull dynamic Zone PIN Key from
		  incoming Prosa Network messages.

	07/27/07 - Brandon Rickards - CR 28380
		o Modified section FAPIN to not extract the message header if
		  the source of the transaction is the ISO Test Utility.

	07/03/07 - Brandon Rickards - CR 28011
		o Modified section APPND63 to increment the token counter
		  in the header of BIT(63).
		o Modified section POSPROC and ATMPROC to use the new position
		  of CVV in the Track 1 data. Also, if CVV2 validation 
		  was not attempted, send NULL in BIT(63) Token '04'.
		o Modified section POSTPST to reset PCID to avoid
		  returning available balance in BIT(54)
		o Modified FAPOUT to add Card Type to ZAUTHDTL
		o Modified section INIT2 to reset TRACE with retrieval
		  reference number in BIT(37) to uniquely identify a message.

	06/27/07 - Brandon Rickards - CR 27864
		o Modified section APPND63 to modify the header length
		  of BIT(63) to include additional tokens 'Q1' and '04'
		o Modified section POSPROC to skip daily withdrawal limit
		  validation for Loan cards because these limits do not apply.
		o Modified section FAPOUT to log Local Transaction Date in
		  Authorization Detail Log.
		o Modified to use %CurrentDate rather than %SystemDate when
		  comparing card expiration date.

	06/18/07 - Brandon Rickards - CR 27711
		o Modified section INIT2 in the following ways:
		  - Set PRE=1 if the transaction is a POS reversal to remove the 
		    online hold rather than post the transaction.
		  - Set POS Adjustment amount (AMT2) using BIT(55).
		  - Quit with 'Invalid Card' if Card Type is undefined.
		  - Manipulate the Process Code (PRCD) if transaction is a
		    Merchandise Return.
		o Modified section DELUXE63 to properly parse BIT(63) data according
		  to Prosa specifications.
		o Modified section POSTPST to restore the manipulated Process
		  Code (PRCD) to original value if transaction is a Merchandise
		  Return.
		o Modified BLDPRE to return available balance in BIT(44) for
		  ATM transactions.
		o Added section APPND63 to append addtional information onto 
		  BIT(63) in Token format for response message to Prosa.
		o Added sections POSPROC and ATMPROC to separate the POS and 
		  ATM specific processing including intializing variables and
		  performing validations.

	06/14/07 - Brandon Rickards - CR 27626
		o Modified section INIT2 to no longer use Draft Capture Flag
		  to determine if transaction is a Completion. Also, now place
		  Transaction Code in TSO("TRXCD") to be used in batch processing
		o Modified section POSTPST to update Cash Back daily withdrawal 
		  limit with Cash Back Amount only

	06/06/07 - Brandon Rickards - CR 27424
		o Modified section INIT2 to use BIT(60) to determine Network ID,
		  BIT(48) to determine Merchant ID. Also added BIN validation for
		  ATM transactions.
		o Modified section FAPOUT to avoid logging Network Messages in the
		  Authorization Detail Report.

	05/25/07 - Brandon Rickards - CR 27311
		o Modified section INIT2 to add BIN validation for ATM
		  transactions

	05/11/07 - Brandon Rickards - CR 27068
	 	o Wal-Mart Release including following modifications:

		o Modified section INIT2 to to handle the Prosa specific 
		  variation of ISO 8583 by modifying specific variables.
		o Modified section POSTPST to update Daily Withdrawl Limits.
		o Modified section FAPOUT to create an entry in ZAUTHDTL 
		  table to be used by Authorization Detail Report.
	 	o Modified section INITTBL by modifying the bit definitions
	 	  to match Prosa specifications.
	 	o Removed UTBLVISA references.

	*/

	quit $$^ISO8583(IM)


public BLDMSG(MID,BIT)

	/*
	 Vendor specific message bits

	 This section can be customized by copying ISO8583 to ZISO8583.

	 Define additional vendor specific message bits for the request 
	 message built by the ZISOTST testing utility and the Network
	 Management Message Generator in ZISOUTL.

	 ARGUMENTS:
		MID	- Message Type
			  . 0100 Pre-Authorization Request
			  . 0120 Pre-Authorization Advice
			  . 0200 Financial Transaction
			  . 0220 Financial Transaction Advice
			  . 0400 Pre-Authorization Request Adjustment
			  . 0420 Pre-Authorization Advice Adjustment
			  . 0800 Network Management Message
		BIT	- Message data array

	 For example:

	 if MID="0100"!(MID="0120") set BIT(60)="00"
	*/

	quit


public INITTBL

	/*
	 This section can be customized by copying ISO8583 to ZISO8583.

	 Initialize TBL array
	 Format - TBL(X)="lentyp|lenx|datatyp|des"
		lentyp	= type of length (variable,fixed,...)
		lenx	= length value
			  len = data length (if lentyp=V, len=byte length
			  of data length, i.e., LLVAR=2, LLLVAR=3)
			  x = variable length sub-field type
				null	- Length of formatted data
				a	- Length of data in message
		datatyp	= data type
		des	= description of data
	 Valid values:
		lentyp	F	Fixed Length
			V	Variable Length

		datatyp	A	ASCII
			N	Numeric
			T	Text
			B	Bitmap

	 RETURNS:
		TBL	- Data element definitons

	 RETURNS:
		EBC		EBCDIC text flag
		TBL		Data element definitons
		UPK		Unsigned packed numeric flag
		VLB		Binary variable length flag
	*/

	// Bit definitions
	set TBL("MID")="F|4|N|Message Type"
	set TBL("PBM")="F|16|B|Bit map, primary"

	set TBL(1)="F|16|B|Bit map, extended"
	set TBL(2)="V|2|N|Primary account number"
	set TBL(3)="F|6|N|Processing code"
	set TBL(4)="F|12|N|Amount, transaction"
	set TBL(5)="F|12|N|Amount, settlement"
	set TBL(6)="F|12|N|Amount, cardholder billing"
	set TBL(7)="F|10|N|Transmission date and time"
	set TBL(8)="F|8|N|Amount, cardholder billing fee"
	set TBL(9)="F|8|N|Conversion rate, settlement"
	set TBL(10)="F|8|N|Conversion rate, cardholder billing"
	set TBL(11)="F|6|N|System trace audit number"
	set TBL(12)="F|6|N|Time, local transaction"
	set TBL(13)="F|4|N|Date, local transaction"
	set TBL(14)="F|4|N|Date, expiration"
 	set TBL(15)="F|4|N|Date, settlement"
	set TBL(16)="F|4|N|Date, conversion"
	set TBL(17)="F|4|N|Date capture"
	set TBL(18)="F|4|N|Merchant category code"
	set TBL(19)="F|3|N|Acquiring institution country code"
	set TBL(20)="F|3|N|PAN, country code"
	set TBL(21)="F|3|N|Forwarding country code"
	set TBL(22)="F|3|N|Point-of-service entry mode"
	set TBL(23)="F|3|N|Card sequence number"
	set TBL(24)="F|3|N|Network international identifier"
	set TBL(25)="F|2|N|Point-of-service condition code"
	set TBL(26)="F|2|N|PIN capture code"
	set TBL(27)="F|1|N|Authorization identification response length"
	set TBL(28)="F|9|T|Amount transaction fee"
	set TBL(29)="F|9|T|Amount settlement fee"
	set TBL(30)="F|9|T|Amount transation processing fee"
	set TBL(31)="F|9|T|Amount settlement processing fee"
	set TBL(32)="V|2|N|Acquirer insitition identification code"
	set TBL(33)="V|2|N|Forwarding institution identification code"
	set TBL(34)="V|2|N|Reserved"
	set TBL(35)="V|2|N|Track 2 data"
	set TBL(36)="V|3|N|Reserved"
	set TBL(37)="F|12|T|Retrieval reference number"
	set TBL(38)="F|6|T|Authorization identification response"
	set TBL(39)="F|2|T|Response code"
	set TBL(40)="F|3|T|Service restriction code"
	set TBL(41)="F|16|T|Card acceptor terminal identification"
	set TBL(42)="F|15|T|Card acceptor identification code"
	set TBL(43)="F|40|T|Card acceptor name and location"
	set TBL(44)="V|2|T|Additional response data"
	set TBL(45)="V|2|T|Track-1 data"
	set TBL(46)="V|3|T|Additional data ISO"
	set TBL(47)="V|3|T|Additional data national"
	set TBL(48)="V|3|T|Additional data, private"
	set TBL(49)="F|3|N|Currency code, transaction"
	set TBL(50)="F|3|N|Currency code, settlement"
	set TBL(51)="F|3|N|Currency code, customer billing"
	set TBL(52)="F|16|B|PIN (personal identification number) data"
	set TBL(53)="F|16|N|Security control information"
	set TBL(54)="V|3|T|Additional amounts"
	set TBL(55)="V|3|T|Reserved ISO"
	set TBL(56)="V|3|T|Reserved ISO"
	set TBL(57)="V|3|T|Reserved national"
	set TBL(58)="V|3|T|Reserved national"
	set TBL(59)="V|3|T|Reserved national"
	set TBL(60)="V|3|T|POS Terminal Data"  
	set TBL(61)="V|3|T|POS Card Issuer category response code data"
	set TBL(62)="V|3|T|Custom payment services fields"
	set TBL(63)="V|3|T|POS Additional data"
	set TBL(64)="F|16|B|MAC"
	set TBL(65)="F|16|B|Bit map, extended"
	set TBL(66)="F|1|N|Reserved"
	set TBL(67)="F|2|N|Reserved"
	set TBL(68)="F|3|N|Reserved"
	set TBL(69)="F|3|N|Reserved"
	set TBL(70)="F|3|N|Network management information code"
	set TBL(71)="F|4|N|Reserved"
	set TBL(72)="F|4|N|Reserved"
	set TBL(73)="F|6|N|Reserved"
	set TBL(74)="F|10|N|Reserved"
	set TBL(75)="F|10|N|Reserved"
	set TBL(76)="F|10|N|Reserved"
	set TBL(77)="F|10|N|Reserved"
	set TBL(78)="F|10|N|Reserved"
	set TBL(79)="F|10|N|Reserved"
	set TBL(80)="F|10|N|Reserved"
	set TBL(81)="F|10|N|Reserved"
	set TBL(82)="F|12|N|Reserved"
	set TBL(83)="F|12|N|Reserved"
	set TBL(84)="F|12|N|Reserved"
	set TBL(85)="F|12|N|Reserved"
	set TBL(86)="F|16|N|Reserved"
	set TBL(87)="F|16|N|Reserved"
	set TBL(88)="F|16|N|Reserved"
	set TBL(89)="F|16|N|Reserved"
	set TBL(90)="F|42|N|Original data elements"
	set TBL(91)="F|1|T|Reserved"
	set TBL(92)="F|2|T|Reserved"
	set TBL(93)="F|5|T|Reserved"
	set TBL(94)="F|7|T|Reserved"
	set TBL(95)="F|42|T|Replacement amounts"
	set TBL(96)="F|8|T|Reserved"
	set TBL(97)="F|17|T|Reserved"
	set TBL(98)="F|25|T|Payee"
	set TBL(99)="V|2|N|Reserved"
	set TBL(100)="V|2|N|Receiving institution identification code"
	set TBL(101)="V|2|T|Reserved"
	set TBL(102)="V|2|T|Account identification 1"
	set TBL(103)="V|2|T|Account identification 2"
	set TBL(104)="V|3|T|Reserved"
	set TBL(105)="V|3|T|Reserved"
	set TBL(106)="V|3|T|Reserved"
	set TBL(107)="V|3|T|Reserved"
	set TBL(108)="V|3|T|Reserved"
	set TBL(109)="V|3|T|Reserved"
	set TBL(110)="V|3|T|Reserved"
	set TBL(111)="V|3|T|Reserved"
	set TBL(112)="V|3|T|Reserved"
	set TBL(113)="V|3|T|Reserved"
	set TBL(114)="V|3|T|Reserved"
	set TBL(115)="V|3|T|Reserved"
	set TBL(116)="V|3|T|Reserved"
	set TBL(117)="V|3|T|Reserved"
	set TBL(118)="V|3|T|Reserved"
	set TBL(119)="V|3|T|Reserved"
	set TBL(120)="V|3|T|POS Terminal Address-Branch"
	set TBL(121)="V|3|T|POS Authorization Indicators"
	set TBL(122)="V|3|T|Reserved"
	set TBL(123)="V|3|T|Private--Address verification"
	set TBL(124)="V|3|T|POS Batch and Shift Data/Settlement"
	set TBL(125)="V|3|T|POS Settlement Data/Settlement Record"
	set TBL(126)="V|3|T|Reserved"
	set TBL(127)="V|3|T|Private--Non-monetary update information"
	set TBL(128)="F|16|B|MAC"

	quit

POSPROC
	/*
	 The purpose of this section is to perform all processing related to
	 POS transactions including initializing/modifying required variables
	 and performing POS related validations.

	 ARGUMENTS:

	 INPUTS:
	 	AMT2		POS Adjustment Amount
	 	BIT		Parsed message array
	 	CRDTYP		Card Type
	 	POS		POS Flag
	 	PRCD		Process Code
	 	PRE		Pre Authorization Flag
	 	REV		Reversal Flag
	 	STF		Store and Forward Flag
	 	TRACK2		Track 2 Card Data
	 	TRANTYPE	Transaction Type
	 	TRMNL		On us/Off us Indicator (Used to set EXTCODE)

	 RETURNS:
	 	AMT2		Updated POS Adjustment Amount
	 	TRMNL		Updated On us/Off us Indicator
	 	TRANTYPE	Updated Transaction Type (POS or CSHBK)

	*/
	type public String DLXBIT,DTEI,ECTI,EXPDT,FIID,POSCAP,VLDDAT
	type public Number AMTBK,AMTDIFF,CVV2FLG
	type Number CLOSED,LMTSTAT,OWNSTAT
	type String CVV,CVV2,CVVSTAT,CVV2STAT,OWNRST,TRACK1,TRDATA

	// Initialize variables
	set (AMTBK,AMTDIFF,CLOSED,CVV2FLG,LMTSTAT,OWNSTAT)=0
	set (CVV,CVV2,DTEI,ECTI,EXPDT,FIID,MERCHID,OWNRST)=""
	set (POSCAP,TRACK1,TRANTYPE,TRDATA,VLDDAT)=""
	set (CVVSTAT,CVV2STAT)="00"

	// If Reversal, set PRE=1 to remove hold rather than post
	if REV set PRE=1

	// POS Entry Mode
	set POSEM=BIT(22).get().extract(1,2)

	// If POS Cash Advance, add "C" to Network ID to use proper Tran Code
	if PRCD.extract(1,2)="01" set CASHADV=1

	// Cash Adavance transaction - Add C to external transaction code
	if CASHADV set TRMNL=TRMNL_"C"

	// POS Adjustment amount
	if PRCD.extract(1,2)="02" set AMT2=BIT(95).get()/EXP

	// Merchandise Return swap To and From Account
	if PRCD.extract(1,2)="20" do {
		set PRCD="20"_PRCD.extract(5,6)_PRCD.extract(3,4)
		// Credit transactions hit account real time
		set FINPRE=1,PRE=0
	}

	// Merchant ID
	set MERCHID=BIT(48).get().extract(4,22)
	set MERCHID=$$RTB^%ZFUNC(MERCHID)

	// POS with Cashback
	if (PRCD.extract(1,2)="09") do {
		set TRANTYPE="CSHBK"
		set AMTBK=BIT(54).get()/EXP
		// BIT(54) contains Cashback Amount
		if AMTBK'=0 do {
			set UTSO("CSHBK")=AMTBK
			// Add Cashback amount to transaction amount
			set TAMT=TAMT+AMTBK
		}
	}
	else  set TRANTYPE="POS"

	// If Completion transaction retrieve original hold information if exists
	if STF do {
		type ResultSet rs1=Db.select("AMT,TSO","PHLD","CID=:XCID AND AUTCODE=:AUTCODE")
		// If reversal and no hold, post to account
		if rs1.isEmpty(),(REV) set PRE=0 quit
		if 'rs1.isEmpty() while rs1.next() do {
			type Number HLDAMT
			// Original Hold Transaction Amount
			set HLDAMT=rs1.getCol("AMT")
			// Calculate Hold/Completion Difference
			set AMTDIFF=HLDAMT-TAMT
			set UTSO("HOLDAMT")=HLDAMT
			// If Cash back, determine if amount has changed
			if TRANTYPE="CSHBK" do {
				type Number OAMTBK=0
				type String UXTSO,XTSO
				set XTSO=rs1.getCol("TSO")
				do OUT^UTSO(.UXTSO,.XTSO)
				// Original Cash Back amount
				set OAMTBK=UXTSO("CSHBK")
				if AMTBK>=OAMTBK quit
				// Cash back amount is less than original
				set AMTBK=AMTBK-OAMTBK
			}
		}
	}

	// Parse Bit 63
	do DELUXE63(BIT(63).get(),.DLXBIT)

	// CVV2 Indicator
	set CVV2FLG=DLXBIT("C0").get().extract(23)

	// If completion no validation will occur
	if STF do APPND63(" ") quit

	/*
	// Determine Valid BIN values
	type ResultSet rs2=Db.select("CLOSED","ZUTBLVLDBIN","BIN=:BIN")
	if 'rs2.isEmpty(),rs2.next() set CLOSED=rs2.getCol("CLOSED")

	// If Closed Card, validate Merchant ID
	if POS,(CLOSED=1),('Db.isDefined("ZVLDMID","MID=:MERCHID")) set ER=1,RSPCD="05" quit
	*/

	// Validate POS Entry Mode
	if POSEM'="90",(POSEM'="00"),(POSEM'="01") set ER=1,RSPCD="05" do APPND63(" ") quit

	if ((POSEM="00")!(POSEM="01")),(MERCH'=5068) do {  quit:ER=1
		set TRDATA=TRACK2.piece("=",2)
		// Card Expiration Date from Track 2
		set EXPDT=TRDATA.extract(1,4)
		/*
		Compare Card Expiration Date from Track 2 with card expiration
		date stored in database. If values do not match, quit with
		Response Code "54"=Expired Card
		*/ 
		if CRDEXP'=EXPDT set ER=1,RSPCD="54" do APPND63(" ") quit
		// Convert Current Date to 'YYMM' format for Expiration Date comparison
		set VLDDAT=$$^%ZD(%CurrentDate,"YYMM")
		// Validate Card Expiration Date (RSPCD "54"=Expired Card)
		if CRDEXP<VLDDAT set ER=1,RSPCD="54" do APPND63(" ") quit

		// If CVV2 Indicator is not '1', do not validate CVV2
		if CVV2FLG'=1 quit

		set CVV2=DLXBIT("C0").get().extract(2,4)
		// Validate CVV2 value
		set CVV2STAT=$$CVVCMP^ZHSMAPI(CRDNUM,CRDTYP,CVV2,"CVV2")
		// CVV2 validation successful - Add 'Y' to BIT(63)Token '04'
		if CVV2STAT="00" do APPND63("Y")
		// CVV2 validation unsuccessful - Add 'C' to BIT(63)Token '04'
		else  do {
			do APPND63("C")
			set ER=1,RSPCD="82"
		}
	}

	if POSEM="90" do {  quit:ER=1
		// Determine if Track 1 data is defined
		set TRACK1=BIT(45).get()
		if 'TRACK1.isNull() do {
			set TRDATA=TRACK1.piece("^",3)
			// Card Expiration Date from Track 1
			set EXPDT=TRDATA.extract(1,4)
			// CVV from Track 1
			set CVV=TRDATA.extract(13,15)
		}
		// If Track 1 data is not defined use Track 2 data
		else  do {
			set TRDATA=TRACK2.piece("=",2)
			// Card Expiration Date from Track 2
			set EXPDT=TRDATA.extract(1,4)
			// CVV from Track 2
			set CVV=TRDATA.extract(13,15)
		}
		// Validate CVV via call to HSM
		set CVVSTAT=$$CVVCMP^ZHSMAPI(CRDNUM,CRDTYP,CVV,"CVV")
		if CVVSTAT'="00" set ER=1,RSPCD="35" do APPND63(" ") quit
		/*
		Compare Card Expiration Date from Track 2 with card expiration
		date stored in database. If values do not match, quit with
		Response Code "54"=Expired Card
		*/
		if CRDEXP'=EXPDT set ER=1,RSPCD="54" do APPND63(" ") quit
		// Convert Current Date to 'YYMM' format for Expiration Date comparison
		set VLDDAT=$$^%ZD(%CurrentDate,"YYMM")
		// Validate Card Expiration Date (RSPCD "54"=Expired Card)
		if CRDEXP<VLDDAT set ER=1,RSPCD="54" do APPND63(" ") quit

		// If CVV2 Indicator is not '1', do not validate CVV2
		if CVV2FLG'=1 quit

		set CVV2=DLXBIT("C0").get().extract(2,4)
		// Validate CVV2 value
		set CVV2STAT=$$CVVCMP^ZHSMAPI(CRDNUM,CRDTYP,CVV2,"CVV2")
		// CVV2 validation successful - Add 'Y' to BIT(63)Token '04'
		if CVV2STAT="00" do APPND63("Y")
		// CVV2 validation unsuccessful - Add 'C' to BIT(63)Token '04'
		else  do {
			do APPND63("C")
			set ER=1,RSPCD="82"
		}
	}
	// If CVV2 validation was not attempted, send NULL in BIT(63) Token '04'
	if CVV2FLG'=1 do APPND63(" ")

	/*
	Loan Card Transactions - Daily Withdrawal Limits do not apply
	Loan card Purchases must use GRP="LN" (From Group - 92)
	*/
	if CRDTYP["PF" set PRCD="009200",FINPRE=1,PRE=0 quit

	// Check Cash Back daily withdrawal limit with Cash Back Amount
	if TRANTYPE="CSHBK" set LMTSTAT=$$LMTCHK^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,AMTBK)
	// Check POS Cash Advance daily withdrawal limit with Transaction Amount
	if CASHADV=1 set LMTSTAT=$$LMTCHK^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,TAMT)

	// If daily limits exceeded quit
	if LMTSTAT'=0 set ER=1,RSPCD=LMTSTAT quit

	// Merchant Country Code
	set CNTRY=$$RTB^%ZFUNC(REGE.extract(39,40))
	// FIID (Acquirer Bank ID)
	set FIID=BIT(60).get().extract(4,7)
	// ELECTRONIC COMMERCE TRANSACTION INDICATOR (TOKEN C0-FIELD 63)
	set ECTI=DLXBIT("C0").get().extract(20)
	// DEVICE TRANSACTION ENTRANCE INDICATOR (TOKEN Q2-FIELD 63)
	set DTEI=DLXBIT("Q2").get().extract(2,3)
	// POS CAPABILITIES,(TOKEN C4-FIELD 63)
	set POSCAP=DLXBIT("C4").get().extract(2)

	// Validate Own Restrictions
	set OWNRST=$$AUTH^ZISO

	// If Piece 1 of return is 0, restriction failed
	set OWNSTAT=OWNRST.extract(1)
	if OWNSTAT=0 set ER=1,RSPCD="05" quit

	if ACCTSTAT=1 set ER=1,RSPCD="01" quit
	if ACCTSTAT=4 set ER=1,RSPCD="36" quit
	if ACCTSTAT'=0 set ER=1,RSPCD="05" quit

	quit

ATMPROC
	/*
	 The purpose of this section is to perform all processing related to
	 ATM transactions including initializing/modifying required variables
	 and performing ATM related validations.

	 ARGUMENTS:

	 INPUTS:
		PRE		Pre Authorization Flag
		TRACK2		Track 2 Card Data
	 	TRANTYPE	Transaction Type	 	

	 RETURNS:
		TRANTYPE	Updated Transaction Type (ATM)
	*/
	type public String DLXBIT,EXPDT,VLDDAT
	type Number LMTSTAT,VLDATM
	type String CHGSTAT,CVV,CVVSTAT,TRDATA,PINBLK,PINSTAT,TRACK1

	// Initialize variables
	set (CHGSTAT,LMTSTAT,VLDATM)=0
	set (CVV,EXPDT,PINBLK,TRACK1,TRDATA,VLDDAT)=""
	set (CVVSTAT,PINSTAT)="00"

	set TRANTYPE="ATM"

	/*
	Since Transaction Type tied to transaction code is set to DEBIT so
	that the fee processing occurs, must reset PRE to post ATM withdrawal
	to account real time.
	*/
	set PRE=0

	// Determine Valid BIN values
	type ResultSet rs=Db.select("ATM","ZUTBLVLDBIN","BIN=:BIN")
	if 'rs.isEmpty(),rs.next() set VLDATM=rs.getCol("ATM")

	// If ATM transaction, determine if BIN allows ATM transactions
	if 'VLDATM set ER=1,RSPCD="05" quit

	// Determine if Track 1 data is defined
	set TRACK1=BIT(45).get()
	if 'TRACK1.isNull() do {
		set TRDATA=TRACK1.piece("^",3)
		// Card Expiration Date from Track 1
		set EXPDT=TRDATA.extract(1,4)
		// CVV from Track 1
		set CVV=TRDATA.extract(13,15)
	}
	// If Track 1 data is not defined use Track 2 data
	else  do {
		set TRDATA=TRACK2.piece("=",2)
		// Card Expiration Date from Track 2
		set EXPDT=TRDATA.extract(1,4)
		// CVV from Track 2
		set CVV=TRDATA.extract(13,15)
	}
	// Validate CVV via call to HSM
	set CVVSTAT=$$CVVCMP^ZHSMAPI(CRDNUM,CRDTYP,CVV,"CVV")
	if CVVSTAT'="00" set ER=1,RSPCD="35" quit

	// Convert Current Date to 'YYMM' format for Expiration Date comparison
	set VLDDAT=$$^%ZD(%CurrentDate,"YYMM")
	// Validate Card Expiration Date (RSPCD "54"=Expired Card)
	if EXPDT<VLDDAT set ER=1,RSPCD="54" quit

	// Account Status "Closed"
	if ACCTSTAT=4 set ER=1,RSPCD="36" quit
	// Account Status not "Active"
	if ACCTSTAT'=0 set ER=1,RSPCD="05" quit

	// PIN Block
	set PINBLK=BIT(52).get()

	// PIN Change Request
	if PRCD.extract(1,2)="96" do {  quit:ER=1
		// Parse Bit 126
		do DELUXE126(BIT(126).get(),.DLXBIT)
		set NPINBLK=DLXBIT("06").extract(22,37)
		set CHGSTAT=$$PINCHG^ZHSMAPI(CRDNUM,CRDTYP,PINBLK,NPINBLK,"ICHG")
		// 75 - Allowable number of PIN tries exceeded
		if CHGSTAT="-2" set ER=1,RSPCD="75"
		// Incorrect Personal Identification Number
		else  if CHGSTAT'=0 set ER=1,RSPCD="55"
	}
	else  do {  quit:ER=1
		set PINSTAT=$$VEROFST^ZHSMAPI(CRDNUM,CRDTYP,PINBLK,"ICHG")
		if PINSTAT="-2" set ER=1,RSPCD="75"
		else  if PINSTAT'=0 set ER=1,RSPCD="55" quit
	}

	// Check ATM daily withdrawal limit with Transaction Amount
	set LMTSTAT=$$LMTCHK^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,TAMT)
	// If daily limits exceeded quit
	if LMTSTAT'=0 set ER=1,RSPCD=LMTSTAT quit

	quit

	quit

APPND63(String VLDFLG)
	/*
	 The purpose of this section is to reset BIT(63) for response 
	 message to Prosa. Only return Token 'C0' (if it exists) from BIT(63)
	 in request message from PROSA. Also add additional tokens 'Q1' and '04'.
	 Prosa BIT(63) uses Tokens to separate different data elements within
	 the BIT.

	 ARGUMENTS:
	 	VLDFLG		Validation Flag
	 			'Y' = Validation Success
	 			'C' = Validation Failure
	 			' ' = No Validation attemped

	 INPUTS:
		BIT(63)		BIT(63) of incoming message
		DLXBIT()	BIT(63) array keyed by Token

	 RETURNS:
		Updated BIT(63) array with Tokens 'Q1' and '04'
	*/
	type String TMP63
	type Number BITLEN,C0LEN,TKCNT

	set (BITLEN,C0LEN)=0
	set TKCNT=1
	set TMP63=""

	// If Token 'C0' is in BIT(63), return the 'C0' Token
	if DLXBIT("C0").get()'="" do {
		set C0LEN=DLXBIT("C0").length()-1
		set TMP63="! C0"_C0LEN.zero(5)_DLXBIT("C0")
		set TKCNT=TKCNT+1
	}
	// Always send a value of 0 in 'Q1' Token
	set TMP63=TMP63_"! Q100002 0 "

	// '04' Token indicates Validation success or failure for CVV2
	set TMP63=TMP63_"! 0400020             "_VLDFLG.get()_"       "

	set TKCNT=TKCNT+2

	// Add length of Header to BIT length
	set BITLEN=TMP63.length()+12

	// Reset BIT(63)
	set BIT(63)="& "_TKCNT.zero(5)_BITLEN.zero(5)_TMP63

	quit

public INIT2

	/*
	 This section can be customized by copying ISO8583 to ZISO8583.

	 The purpose of this section is to allow for custom code that may be
	 necessary to handle vendor specific variations of the ISO 8583
	 interface.  The following list represents a few of the more common 
	 variables that may need to be modified.

		TLO		Teller Location - used to uniquely identify 
				a message.
		SPR		Spray Number - used to uniquely identify 
				a message.
		CC		Cost Center
		FCID		From Account Number
		TCID		To Account Number
		PRCD		Process Code
		TRMNL		On-us/off-us indicator
				. null	not used
				. 0	on-us
				. 1	off-us
		REGE		Card Acceptor Location
		UTSO(id)	Teller Source - where id equals a custom TSO
				field.
		MERCHNM		Merchant name (used in TCMT with REGE info)

	 For example:

	 new BIT48

	 // Reset TLO and SPR fields to FDR UK specifications
	 set %UserStation="ZISO8583"
	 set TRACE=""
	 set BIT48=$G(BIT(48))
	 set SPR=+$S($L(BIT48)=15:$E(BIT48,4,15),1:$E(BIT48,18,29))

	 // All transactions off-us
	 set TRMNL=1

	 INPUTS:
		BIT		Parsed message array
		FCID		From account number
		PRCD		Processing code
		TCID		To account number

	 RETURNS:
		AMT2FEE		Replacement fee
		CRDNUM		Card number
		FCID		From account number
		INCID		Incremental id
		MERCHNM		Merchant name
		NETID		Acquirer network id
		SPR		Spray value
		TAMTFEE		Transaction fee amount
		TCID		To account number
		TRACE		Trace value
		%UserStation	Transaction location
	*/

	catch vERROR {

		// Log GTM system errors
		set ET=vERROR.type
		if vERROR.type["%GTM-" do {
			do ZE^UTLERR
			set RM=vERROR.type_","_vERROR.description
		}

		// Build error message for thrown errors
		else  do {
			set RM=$S(RM.get()="":vERROR.description,1:RM)
			set RM=$S(ET="":RM,RM="":ET,1:ET_","_RM)
		}

		// Set error flag and general error
		set ER=1,RSPCD="05"
	}
	type public Number ACCTSTAT,CASHADV,CRDSTAT,XCID
	type public String CRDEXP,CRDTYP,OPRCD
	type String NTWKID

	// Initialize variables
	set (ACCTSTAT,CASHADV,CRDSTAT,XCID)=0
	set (CRDEXP,CRDTYP,NTWKID)=""

	// Determine the merchant name (used in TCMT)
	set MERCHNM=BIT(120).get()

	// TRACE will be stored in TLO field to uniquely identify a message
	set TRACE=+BIT(37).get()
	set %UserStation=INTRFACE.extract(4,INTRFACE.length())_"-"_TRACE

	// Transaction Type: POS("02") or ATM("01")
	if MSGHDR.extract(4,5)="02" set POS=1
	else  set POS=0

	// Store Original Process Code
	set OPRCD=PRCD

	// If STF=1, message is a Completion Transaction
	if STF set FINPRE=1,PRE=0
        else  set FINPRE=0,PRE=1

	// TRMNL used to separate Tran Codes for each Network ID
	set NTWKID=BIT(60).get().extract(4,7)
	if NTWKID="B134" set TRMNL="P"
	else  if NTWKID="VISA"!(NTWKID="BNET")!(NTWKID["MDS") set TRMNL="I"
	else  set TRMNL="R"

	// Determine Card Type using BIN number of card
	set BIN=CRDNUM.extract(1,6)
	type ResultSet rs1=Db.select("CARDTYPE","CRDTYP","BIN=:BIN")
	if 'rs1.isEmpty(),rs1.next() do {
		set CRDTYP=rs1.getCol("CARDTYPE")
	}

	// If Card Type undefined, quit RSPCD "14"=Invalid Card Number
	if CRDTYP="" set ER=1,RSPCD="14" quit

	// Determine Account Status
	type ResultSet rs2=Db.select("CID","CRDGRP","CRDNUM=:CRDNUM")
	if 'rs2.isEmpty(),rs2.next() do {
		set XCID=rs2.getCol("CID")
		type RecordACN acn=Db.getRecord("ACN","CID=:XCID",1)
		if acn.getMode()'=0 do {
			set ACCTSTAT=acn.stat
		}
	}
	// Invalid Card Number. No account linked to card.
	if XCID=0 set ER=1,RSPCD="14" quit

	// Validate Card Status
	set RSPCD=$$STAT^ZCRDUTL(CRDNUM,CRDTYP,.CRDSTAT,.CRDEXP)
	if RSPCD'="00" set ER=1 quit

	set CRDEXP=$$^%ZD(CRDEXP,"YYMM")

	// POS specific processing including initializing variables and validation 
	if POS do POSPROC
	// ATM specific processing including initializing variables and validation
	if 'POS do ATMPROC

	// If Error already occurred quit
	if ER quit

	// Add BIN number onto the end of the External Tran Code
	set TRMNL=TRMNL_BIN

	// Add transaction code to TSO for batch processing
	set UTSO("TRXCD")=PRCD_TRMNL

	quit


public FAPIN

	/*
	 This section can be customized by copying ISO8583 to ZISO8583.

	 Define the message header of the incoming message and remove it from
	 the incoming message

	 INPUTS:
		IM	- ISO 8583 Request Message

	 For example:

	 set MSGHDR=$E(IM,5,8)
	 set IM=$E(IM,1,4)_$E(IM,9,$L(IM))

	 INPUTS:
		IM		Incoming raw message

	 RETURNS:
		IM		Incoming message
		XOMID		Original message id
	*/

	// ISO Test Utility message will not contain a header
	if IM["ISO 8583 Test Utility" quit

	// Remove the message header from the incoming message
	set MSGHDR=IM.extract(1,12)
	set IM=IM.extract(13,IM.length())

	quit


public FAPOUT

	/*
	 This section can be customized by copying ISO8583 to ZISO8583.

	 Define the message header for the outgoing message and attach it
	 to the outgoing message

	 INPUTS:
		OM	- ISO 8583 Response Message

	 For example:

	 set OM=$E(OM,1,4)_MSGHDR_$E(OM,5,$L(OM))

	 INPUTS:
		OM		Outgoing message (ASCII)

	 RETURNS:
		OM		Outgoing message (EBCDIC)
	*/

	type String OMHDR,RSPDESC

	/*
	Modify Outgoing Message Header to set Responder Code = 5(Host)
	Responder Code is piece 12 of the Original Incoming Message Header
	*/
	set OMHDR=MSGHDR.extract(1,11)_"5"
	set OM=OMHDR_OM.extract(1,OM.length())

	// If Network Message don't log in Authorization Detail Report
	if MID.extract(2)=8 quit

	type RecordZAUTHDTL zauthdtl
	type RecordZUTBLRSPDES zrspdes

	// Determine a Description of the Response Code
	set zrspdes=Db.getRecord("ZUTBLRSPDES","RSPCD=:RSPCD",1)
	if zrspdes.getMode()=0 set RSPDESC=""
	else  set RSPDESC=zrspdes.desc

	// Create entry in ZAUTHDTL table for Authorization Detail Report
	set zauthdtl=Class.new("RecordZAUTHDTL")
	set zauthdtl.crdnum=CRDNUM.get()
	set zauthdtl.date=%CurrentDate
	set zauthdtl.seq=Db.nextVal("ZAUTHDTL","CRDNUM,%CurrentDate")
	// Original Process Code
	set zauthdtl.prcd=OPRCD.get()
	// POS Entry Mode
	set zauthdtl.posem=POSEM.get()
	// Response Code
	set zauthdtl.rspcd=RSPCD.get()
	// Authorization Number
	set zauthdtl.autcode=AUTCODE.get()
	// Card Status
	set zauthdtl.crdstat=CRDSTAT.get()
	// Account Number
	set zauthdtl.cid=XCID.get()
	// Account Status
	set zauthdtl.acctstat=ACCTSTAT.get()
	// Stored Card Expiration Date
	set zauthdtl.crdexp=CRDEXP.get()
	// Merchant Category Code
	set zauthdtl.mcc=MERCH.get()
	// Transaction Amount
	set zauthdtl.tamt=TAMT.get()
	// Unique Message ID
	set zauthdtl.atmm=ATMM.get()
	// Available Balance
	set zauthdtl.balavl=BALAVL.get()
	// Difference b/w Original Hold Amount and Completion Amount
	set zauthdtl.tol=AMTDIFF.get()
	// Response Code Description
	set zauthdtl.rspdesc=RSPDESC
	// Track Data Expiration Date
	set zauthdtl.trexpdt=EXPDT.get()
	// Merchant ID
	set zauthdtl.merchid=MERCHID.get()
	// Terminal ID
	set zauthdtl.atmid=ATMID.get()
	// Transaction Time
	set zauthdtl.ltt=ATMT.extract(1,2)_":"_ATMT.extract(3,4)_":"_ATMT.extract(5,6)

	// If Loan Card was successful, mark as completion
	if CRDTYP.get()["PF",(RSPCD="00") set zauthdtl.hldcmp=1
	// Hold or Completion (STF=0:Hold,STF=1:Completion)
	else  set zauthdtl.hldcmp=STF
	// Local Transaction Date
	set zauthdtl.ltd=ATMD.get()
	// Card Type
	set zauthdtl.crdtyp=CRDTYP.get()

	// Transaction is Pin-based
	if BIT(52).get()'="" set zauthdtl.pinflg="TRAN. CON NIP"
	// Transaction is Signature-based
	else  set zauthdtl.pinflg="TRAN. SIN NIP"

	do zauthdtl.bypassSave()

	quit


public GETBAL()

	/*
	 This section can be customized by copying ISO8583 to ZISO8583.

	 Balance information

	 INPUTS:
		CRCD	- Currency of original transaction amount
		PCID	- PROFILE account number
		PRCD	- Processing code
		TRTYP	- Transaction type

	 OUTPUT:
		Account balance information
	*/

	catch vERROR {

		// Log GTM system errors
		set ET=vERROR.type
		if vERROR.type["%GTM-" do {
			do ZE^UTLERR
			set RM=vERROR.type_","_vERROR.description
		}

		// Build error message for thrown errors
		else  do {
			set RM=$S(RM.get()="":vERROR.description,1:RM)
			set RM=$S(ET="":RM,RM="":ET,1:ET_","_RM)
		}

		// Set error flag
		set ER=1
	}

	//new BALS
	type public String BALS

	// Initialization
	set BALS=""

	set BALS=$$GETBAL^ISO8583()

	quit BALS

public HDR(IM)

	/*
	 Build Header Information

	 This section can be customized by copying ISO8583 to ZISO8583.

	 Define the message header for the request message built by the 
	 ZISOTST testing utility and the Network Management Message
	 Generator in ZISOUTL.

	 ARGUMENTS:
		IM	- ISO 8583 Request Message

	 OUTPUT:
		Request message with header

	 For Example:

	 quit $E(IM,1,4)_$$PKNS^ISO8583("02000000")_$E(IM,5,$L(IM))
	*/

	quit IM


public STMT

	/*
	 Statement request

	 This section can be customized by copying ISO8583 to ZISO8583.

	 INPUTS:
		CRDNUM	- Card Number
		PCID	- PROFILE account number
		PRCD	- Processing code
		TCODE	- Process code transaction type
	*/

	// No current standard statement code
	// ~p1 not supported
	set RSPCD=$$RSPCD^ISO8583(374,.RM,"Statement processing")

	quit


public RESPONSE

	/*
	 Response message processing

	 This section can be customized by copying ISO8583 to ZISO8583.
	*/

	quit


public POSTPRE

	/*
	 POST section pre-processor

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to format transactions (i.e., fee transactions)
	 in addition to the transactions formatted by ISO8583.

	 For example:

	 new FEE,FEEAMT

	 // Do not build fee transactions for non-partial reversals.
	 if REV,'PARTIAL quit

	 // Determine fee information for fee code 1
	 do ZFEEUTL(.FEE,$G(BIT(28)),$G(BIT(30)),TAMT,TRTYP,PCID,$G(BIT(25)))
	 if ER set RSPCD=$$RSPCD("05") quit

	 // Build fee transactions based on fee information
	 set FEEAMT=$P(FEE,"|",2)
	 if FEEAMT>0 do {
		do TTX^ATMUTL(.ttx,PCID,$P(FEE,"|",3),FEEAMT,EFD,"",$$^MSG(3507),"",%SystemCurrency)
		do TTX^ATMUTL(.ttx,$P(FEE,"|",5),$P(FEE,"|",4),FEEAMT,EFD,"",$$^MSG(3507),"",%SystemCurrency)
	 }
	 if ER set RSPCD=$$RSPCD("05") quit

	 // Determine fee information for fee code 2
	 do ZFEEUTL(.FEE,$G(BIT(29)),$G(BIT(31)),TAMT,TRTYP,PCID,$G(BIT(25)))
	 if ER set RSPCD=$$RSPCD("05") quit

	 // Build fee transactions based on fee information
	 set FEEAMT=$P(FEE,"|",2)
	 if FEEAMT>0 do {
		do TTX^ATMUTL(.ttx,PCID,$P(FEE,"|",3),FEEAMT,EFD,"",$$^MSG(3507),"",%SystemCurrency)
		do TTX^ATMUTL(.ttx,$P(FEE,"|",5),$P(FEE,"|",4),FEEAMT,EFD,"",$$^MSG(3507),"",%SystemCurrency)
	 }
	 if ER set RSPCD=$$RSPCD("05") quit

	 INPUTS:
		ttx()		Transaction object array
		ATMM		Unique message id
	 	BIT		Parsed message array
		BRCD		Branch code
		NETID		Acquirer network id
		PCID		Profile account
		PHC		Permanent hold code
		PRE		Preauthorization flag
		REV		Reversal flag
		SPR		Spray value
		STF		Advice flag
		TPD		Teller posting date
		TRTYP		Transaction type
		TSPV		Teller supervisory array

	 RETURNS:
		ttx()		Transaction object array
		PAUTH		Partial authorization flag		
	*/

	catch vERROR {

		// Log GTM system errors
		set ET=vERROR.type
		if vERROR.type["%GTM-" do {
			do ZE^UTLERR
			set RM=vERROR.type_","_vERROR.description
		}

		// Build error message for thrown errors
		else  do {
			set RM=$S(RM.get()="":vERROR.description,1:RM)
			set RM=$S(ET="":RM,RM="":ET,1:ET_","_RM)
		}

		// Set error flag
		set ER=1
	}

	// Allow partial authorizations for Interlink only 
	if PRE,(NETID'="ILK") set PAUTH=0

	/*
	Rebuild ttx() for STF POS transactions 
	For non-STF POS transactions, ATMPRE^ATMUTL handles rebuilding
	ttx(). For STF, ATMPRE^ATMUTL immediately places a hold for STF,
	and does not post/rollback the transactions and rebuild ttx().
	This section is necessary for STF to rebuild ttx() to determine
	if overdraft would be invoked.
	*/
	if PRE,'REV,STF do BLDTTX(.ttx(),TPD,BRCD)

	quit


public POSTPST

	/*
	 POST section post-processor

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to view all transactions (including secondary
	 and system-generated transactions) posted in Profile in
	 relation to an ISO8583 request message.

	 INPUTS:
		ttx()		Transaction object array
		ATMM		ATM message id
		AUTCODE		Authorization code
		BRCD		Branch code
		CRCD		Currency code
		EFD		Effective date
		ETCDR		'From' transaction code
		FCID		Profile account ('from' account)
		INCID		Incremental id
		PRE		Pre-authorization flag
		PSTDYS		History search days
		REV		Reversal flag
		SPR		Spray value
		STF		Advice flag
		TCMT		Teller comment
		TPD		Teller posting date
		TSO		Transaction source
		TSPV		Teller supervisory array
	*/

	catch vERROR {

		// Log GTM system errors
		set ET=vERROR.type
		if vERROR.type["%GTM-" do {
			do ZE^UTLERR
			set RM=vERROR.type_","_vERROR.description
		}

		// Build error message for thrown errors
		else  do {
			set RM=$S(RM.get()="":vERROR.description,1:RM)
			set RM=$S(ET="":RM,RM="":ET,1:ET_","_RM)
		}

		// Set error flag
		set ER=1
	}

	// Reset Process Code to Original value
	set PRCD=OPRCD.get()

	set (XCID,XSEQ)=""
	for  set XSEQ=SPV(XSEQ).order() quit:XSEQ.isNull()  do {
		for  set XCID=SPV(XSEQ,XCID).order() quit:XCID.isNull()  do {
			if $D(SPV(XSEQ,XCID,"OVR","BALAVL")) set RSPCD="51"
		}
	}

	// Do nothing if the main transaction failed
	if ER quit

	/*
	Update Daily Withdrawl Limits
	If Completion and amount is different from original hold, update the 
	limits using the amount difference.
	If transaction is not a completion, update the limits using the transaction
	amount.
	If transaction is a reversal, restore amount to withdrawal limits
	*/
	if REV,(RSPCD="00") do {
		// Update ATM daily withdrawal limit with Transaction Amount
		if TRANTYPE="ATM" do LMTUPD^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,-TAMT)
		// Update POS Cash Advance daily withdrawal limit with Transaction Amount
		if TRANTYPE="POS",(CASHADV=1) do LMTUPD^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,-TAMT)
		// Update Cash Back daily withdrawal limit with Cash Back Amount
		if TRANTYPE="CSHBK" do LMTUPD^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,AMTBK)
	}
	else  if STF,(RSPCD="00"),(AMTDIFF'=0) do {
		// Update POS Cash Advance daily withdrawal limit with Transaction Amount
		if TRANTYPE="POS",(CASHADV=1) do LMTUPD^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,AMTDIFF)
		// Update Cash Back daily withdrawal limit with Cash Back Amount
		if TRANTYPE="CSHBK" do LMTUPD^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,AMTBK)
	}
	else  if RSPCD="00" do {
		// Update ATM daily withdrawal limit with Transaction Amount
		if TRANTYPE="ATM" do LMTUPD^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,TAMT)
		// Update Cash Back daily withdrawal limit with Cash Back Amount
		if TRANTYPE="CSHBK" do LMTUPD^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,AMTBK)
		// Update POS Cash Advance daily withdrawal limit with Transaction Amount
		if TRANTYPE="POS",(CASHADV=1) do LMTUPD^ZCRDUTL(CRDNUM,CRDTYP,TRANTYPE,TAMT)
	}

	quit


public BLDPRE

	/*
	 BLDOM section pre-processor

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to add/modify the bits used to build outgoing
	 ISO8583 response messages.

	 INPUTS:
		MID		Outgoing message id
		OIM		Original input message
		PCID		Profile account
		STF		Advice flag
		TAMT		Transaction amount
		TRTYP		Transaction type
		VALID		Valid message flag
		XOMID		Original message id

	 RETURNS:
		BIT		Parsed message array
		MID		Outgoing message id
	*/

	catch vERROR {

		// Log GTM system errors
		set ET=vERROR.type
		if vERROR.type["%GTM-" do {
			do ZE^UTLERR
			set RM=vERROR.type_","_vERROR.description
		}

		// Build error message for thrown errors
		else  do {
			set RM=$S(RM.get()="":vERROR.description,1:RM)
			set RM=$S(ET="":RM,RM="":ET,1:ET_","_RM)
		}

		// Set error flag
		set ER=1
	}

	// If ATM transaction, return available balance in BIT(44)
	if POS=0 do {
		type String XBALS
		type Number XBALAVL

		kill BIT(52)
		if MID.extract(2)'=8 kill BIT(70)
		set XBALAVL=0
		if 'ER do {
			set XBALS=$$GETBAL
			set XBALAVL=BALAVL.get()
			set XBALAVL=XBALAVL*100
		}
		set BIT(44)="2"_XBALAVL.zero(24)
	}

	// Responses will NOT include balances in BIT(54)
	kill BIT(54)

	// Do not return BIT(44) if Network Message
	if MID="0810" kill BIT(44)

	quit


public VLDMSG(MID,BIT)

	/*
	 Validate message

	 ARGUMENTS:
		MID		Message id
		BIT		Parsed array of 'msg'

	 RETURNS:
		$$		Validation flag (0-invalid,1-valid)

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to add/modify the message validation logic.

	 For example:

	 new FLD,VALFLD,VALID

	 // Initialization
	 set VALID=1
	 set VALFLD=""

	 // Determine valid fields
	 if MID="0110" set VALFLD=",2,3,4,5,6,7,10,11,12,13,15,18,19,32,33,37,38,39,41,48,49,51,54,102,103,"
	 if MID="0130" set VALFLD=",2,3,4,5,6,7,10,11,12,13,15,18,19,32,33,37,38,39,41,49,51,102,103,"
	 if MID="0210" set VALFLD=",2,3,4,5,6,7,10,11,12,13,14,15,18,19,32,33,37,38,39,41,48,49,51,54,102,103,128,"
	 if MID="0230" set VALFLD=",2,3,4,5,6,7,10,11,12,13,14,15,18,19,32,33,37,38,39,41,49,51,102,103,128,"
	 if MID="0410" set VALFLD=",2,3,4,5,6,7,10,11,12,13,14,15,18,19,32,33,37,38,39,41,48,49,51,54,95,102,103,"
	 if MID="0430" set VALFLD=",2,3,4,5,6,7,11,12,13,15,18,19,32,33,37,38,39,41,48,49,54,102,103,"
	 if MID="0810" set VALFLD=",2,7,11,32,39,70,"

	 // Search for invalid fields
	 set FLD=""
	 if VALFLD'="" for  set FLD=$O(BIT(FLD)) quit:FLD=""  if VALFLD'[(","_FLD_",") set VALID=0  quit:'VALID

	 quit VALID
	*/

	quit $$VLDMSG^ISO8583(MID,.BIT)


public NETWORK(CODE)

	/*
	 Network Management Message Support

	 ARGUMENTS:
		CODE		Network Management Information Code
				"001" - Sign on request
				"002" - Sign off request
				"201" - Cutover
				"301" - Echo test
	 RETURNS:
		MID		Return Message ID

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to perform Network Management logic.

	 */
	type String BIT123,EXTINT,NEWKEY
	type Number FLDLOC
	type RecordZUTBLHSM hsm

	set FLDLOC=0

	// Bit(123) will contain Zone PIN Key
	set BIT123=BIT(123).get()
	// If BIT(123) is not defined the Zone PIN Key is not contained in message
	if BIT123="" quit
	// Pull the new Zone PIN Key from the message
	set FLDLOC=BIT123.find("KD/")
	set NEWKEY=BIT123.extract(FLDLOC,FLDLOC+32)

	set NEWKEY=$$TRNSZPK^ZHSMAPI(NEWKEY)
	if NEWKEY="-1" quit

	// Update HSM data with the New Zone PIN Key
	set EXTINT="HSM"
	set hsm=Db.getRecord("ZUTBLHSM","INTRFACE=:EXTINT")
	do hsm.setAuditFlag(1)
	set hsm.zpk=NEWKEY
	do hsm.bypassSave()

	quit


public RECON

	/*
	 Reconciliation Message Support

	 This section can be customized by copying ISO8583 to ZISO8583,
	 and may be used to perform Reconciliation logic.

	 */
	 
	// No current standard reconciliation code
	// ~p1 not supported
	set RSPCD=$$RSPCD^ISO8583(374,.RM,"Reconciliation processing")
	
	quit

DELUXE126(DATA,BIT)
	/*
	 Parse Deluxe field 126

	 ARGUMENTS:
		DATA		Bit 126 data

	 RETURNS:
		BIT		Parsed array of Bit 126
	*/
	type Number FLDLEN,FLDLOC
	type String TOKEN

	set TOKEN="06"
	set (FLDLEN,FLDLOC)=0
	set FLDLOC=DATA.find("! "_TOKEN)
	set FLDLEN=+DATA.extract(FLDLOC,FLDLOC+4)
	set BIT(TOKEN)=DATA.extract(FLDLOC+5,FLDLOC+5+FLDLEN)

	quit

DELUXE63(DATA,BIT)

	/*
	 Parse Deluxe field 63 (Deluxe Data Systems, Inc Data)

	 ARGUMENTS:
		DATA		Bit 63 data

	 RETURNS:
		BIT		Parsed array of Bit 63
	*/

	for TOKEN="C0","C4","Q2" do {
		type Number FLDLEN,FLDLOC
		set (FLDLEN,FLDLOC)=0
		set FLDLOC=DATA.find("! "_TOKEN)
		set FLDLEN=+DATA.extract(FLDLOC,FLDLOC+4)
		set BIT(TOKEN)=DATA.extract(FLDLOC+5,FLDLOC+5+FLDLEN)
	}

	quit


BLDTTX(RecordTTX ttx(),TPD,BRCD)

	/*
	 Build ttx() object array based on potential secondary transactions
	 This section is used to build the ttx object array for PRE STF
	 transactions because PRE STF transactions just place a hold.

	 ARGUMENTS:
		ttx()		Transaction object array
		TPD		Teller posting date
		BRCD		Branch code

	 RETURNS:
		ttx()		Transaction object array
	*/

	new par,seq,x,SPV,TR

	type TranSet ts

	// Process only the first transaction in the transaction set
	set ts=Class.new("TranSet")
	set x=ts.copyTran(ttx(1))

	// Online, do not update database, no TTX entries
	set par("IPMODE")=1
	set par("OPTION")=0
	set par("UPDTTX")=0

	// Process the transaction
	do ts.postTSet(TPD,BRCD,.par,.TR)

	// Ignore errors
	set ER=0
	set RM=""

	// Redefine ttx object array using the returned transaction set
	set seq=""
	for  set seq=TR(seq).order() quit:seq=""  set ttx(seq)=ts.getTran(seq)

	quit

ISOMAN
	/*
	This section is responsible for pre-populating NXTSEQ.UNQ for Manual
	Authorizations. Online Authorizations have maximum length of 5. The
	Manual Authorizations will have a length of 6 to differentiate them
	from online auth's. NXTSEQ.UNQ needs to be pre-populated with 100,000
	so the Manual Authorization numbers will be range 100,000-999,999.
	*/
	type String ID
	type RecordNXTSEQ nxt
	type ResultSet rs

	set ID="ISOMAN"

	/*
	If entry for 'ISOMAN' already exists in NXTSEQ then this process has
	already run and populated NXTSEQ.UNQ. Quit rather than resetting the
	value.
	*/
	set rs=Db.select("UNQ","NXTSEQ","ID=:ID")
	if 'rs.isEmpty() quit

	set nxt=Class.new("RecordNXTSEQ")
	set nxt.id=ID
	set nxt.unq=100000
	do nxt.save()

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60869^84833^Brandon Rickards^42321"	// Signature - LTD^TIME^USER^SIZE
