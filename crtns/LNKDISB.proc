LNKDISB
	/*
  ---- Revision History--------------------------------------------------------
	
	07/31/06 - KELLYP - CR 22048
		   Modified DISB section to eliminate PRECEDENCE warning.
	
	03/09/06 - TELIV - CR 19619
		   If the auto disbursement is though check payment, pick 
		   Credit account from utblchks
	
	11/13/03 - CARROLLJ - 51630
		   Correct call to TRNSET^TRNDRV.

	03/12/03 - CARROLLJ - 51349
		Removed the use of TR array and changed call to TTXP2.

	01/10/03 - Spier 51423
		Removed db.insert from code (replaced with class.new) to
		account for new error reported by compiler.

	*/

	quit

public EXTERN(CID)

	type RecordLN ln=Db.getRecord("LN","CID")
	do START(CID,.ln)
	quit ""

public	START(CID,RecordLN ln)	

	// Bring Loan Current if date of note is in the past
	if ln.dtnt<%SystemDate do {  quit:ER
		// First Delete all of the XBADs generated by the filers
		// they will have a second go around at this account after LNK010
		do Runtime.delErrXBAD("*")
	
		do {  quit:ER
			new %ProcessMode
			// LNK010
			do FILE^LNDE1(.ln) quit:ER
			// Need to run an integ on the account here (again).
			set %ProcessMode=2
			do VERIFY^LNIC(CID) quit:ER
		}
	}

	// If everything is peachy - auto-disb this account(if needed of course)
	do DISB(CID,.ln) quit:ER

	quit

DISB(CID,RecordLN ln)

	/*
	   Automatic Loan disbursement during loan creation
	
	   Automatic loan disbursement via Internal Account
	   This will build and post financial transaction to debit the loan
	   and credit another PROFILE account immediately upon filing.
	
	   Automatic loan disbursement via check.
	   This will build and post financial transaction to debit the loan
	   and credit a check G/L account immediately upon filing, and set up
	   XPDO for the check.
	   First check if a plan is defined , and if so, if the method is defined
	   and also allowed via this plan.
	*/

	if ln.aldp="",ln.aldm="" quit
 
	if ln.aldp'="" do { quit:ER 
		if ln.aldm="" do Runtime.setErrMSG("LN",3876) quit:ER 
		set ALDP=ln.aldp
		set DATA=Db.getOneRow("ALDM1,ALDM2,ALDM3","UTBLALDP","ALDP")
		set ALDM1=$P($G(DATA),$C(9),1)
		set ALDM2=$P($G(DATA),$C(9),2)
		set ALDM3=$P($G(DATA),$C(9),3)
	
		if ln.aldm=1 do { quit:ER 
			if ALDM1=0 do Runtime.setErrMSG("LN",3877) quit:ER 
			if ln.adtar="" do Runtime.setErrMSG("LN",3878) quit:ER 
			set ALDCID=ln.adtar
			if 'Db.isDefined("ACN","ALDCID") do Runtime.setErrMSG("LN",1259,ALDCID) quit:ER 
			set ALDST=Db.getOneRow("STAT","ACN","ALDCID") 
			if ALDST=4 do Runtime.setErrMSG("LN",1259) quit:ER   //closed acct
			if ln.aldext'="" do Runtime.setErrMSG("LN",3882) quit:ER 
			if ln.aldchk'="" do Runtime.setErrMSG("LN",3883) quit:ER 
	
			}
		if ln.aldm=2 do { quit:ER 
			if ALDM2=0 do Runtime.setErrMSG("LN",3877) quit:ER 
			if ln.aldext="" do Runtime.setErrMSG("LN",3879) quit:ER 
			if ln.adtar'="" do Runtime.setErrMSG("LN",3881) quit:ER 
			if ln.aldchk'="" do Runtime.setErrMSG("LN",3883) quit:ER 
	
			}
		if ln.aldm=3 do { quit:ER 
			if ALDM3=0 do Runtime.setErrMSG("LN",3877) quit:ER 
			if ln.aldchk="" do Runtime.setErrMSG("LN",3880) quit:ER 
			if ln.adtar'="" do Runtime.setErrMSG("LN",3881) quit:ER 
			if ln.aldext'="" do Runtime.setErrMSG("LN",3882) quit:ER 
			}
	}
	quit:ER

	if ((ln.aldm=1)!(ln.aldm=3)),ln.maxdrct=1 do { quit:ER 
		new EFD,TAMT,TCMT,CRCD,SAVCID,SEQ,TYPE,BCRCD,AMT,ITC,TSO,BRCD
		set EFD=ln.odd
		set TAMT=ln.amtreq
		set CRCD=ln.crcd
		set TYPE=ln.type
		set TSO=""
		set TCMT=""
		set ETC=Db.getOneRow("DRTRGP","PRODCTL","TYPE") 
		set ITC=Db.getOneRow("ITC","TRN","ETC")			// Internal Transaction Code

		type RecordTTX ttx()
		set ttx(1)=Class.new("RecordTTX")
		set ttx(1).uid=%UserID
		set ttx(1).cid=CID
		set ttx(1).itc=ITC
		set ttx(1).etc=ETC
		set ttx(1).tamt=TAMT
		set ttx(1).tlo=%UserStation
		set ttx(1).tso=TSO
		set ttx(1).tcmt=TCMT
		set ttx(1).cdt=%CurrentDate
		set ttx(1).tim=%CurrentTime
		set ttx(1).crcd=CRCD
		set ttx(1).uidt=%UserID
		if %SystemDate'=EFD set ttx(1).efd=EFD
		set SAVCID=CID
		set BCRCD=CRCD						// Save cid and crcd
	
		// Offsetting credit transaction
		if ln.aldm=1 do {
			set CID=ln.adtar
			Type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
			set CRCD=dep.crcd
			Type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=dep.type")
	    		set ETC=""
			set ETC=prodctl.crtrgp
			set ITC=Db.getOneRow("ITC","TRN","ETC")
			set TSO=$$FIELDIN^UTSO(TSO,"FCID",SAVCID)    	// Internal Transaction Code
			}
	
		if ln.aldm=3 do {
			set ALDCHK=ln.aldchk
			set CID=Db.getOneRow("CID","UTBLCHKS","ALDCHK") 
			set CRCD=ln.crcd
			set ETC=Db.getOneRow("SLDGLTC","CUVAR")
			if ETC="" set ETC="MCR"
			set ITC=Db.getOneRow("ITC","TRN","ETC") 	// Internal Transaction Code
			}
	
		// Currency exchange if needed.
		if CRCD'=BCRCD do {
			set par("EXCHNG")=1
			set AMT=TAMT
			do CAMT^CRCDUTL(BCRCD,CRCD,.AMT) quit:ER 
			set TAMT=AMT
			}
	
		set TCMT=$$^MSG(3939,SAVCID)				//Transfer from ~p1

		set ttx(2)=Class.new("RecordTTX")
		set ttx(2).uid=%UserID
		set ttx(2).cid=CID
		set ttx(2).itc=ITC
		set ttx(2).etc=ETC
		set ttx(2).tamt=TAMT
		set ttx(2).tlo=%UserStation
		set ttx(2).tso=TSO
		set ttx(2).tcmt=TCMT
		set ttx(2).cdt=%CurrentDate
		set ttx(2).tim=%CurrentTime
		set ttx(2).crcd=CRCD
		set ttx(2).uidt=%UserID
		if %SystemDate'=EFD set ttx(2).efd=EFD
		set BRCD=ln.boo
		
		// For checks, need XPDO for CHKBPNT to print manually
		if ln.aldm=3 do {
			set ALDCHK=ln.aldchk
			set TJD=%SystemDate
			type ResultSet rs=Db.select("CKSEQ","XPDO","TJD=:TJD AND CKTYP=:ALDCHK","TJD,CKTYP,CKSEQ DESC") 
	    		if rs.isEmpty() quit
	    		set ZCKSEQ=rs.next(),ZCKSEQ=rs.getCol(1)
			set ZCKSEQ=ZCKSEQ+1
			set UID=%UserID	
	    		type ResultSet rs=Db.select("TSEQ","TTX","TJD=:TJD AND BRCD=:BRCD AND UID=:UID","TTX.TSEQ DESC") 
	    		if rs.isEmpty() quit
	    		set X=rs.next(),X=rs.getCol(1)
			set X=((X\1000)+1)*1000+2
			set CID=ln.cid
			type RecordXPDO xpdo=Class.new("RecordXPDO")
			set xpdo.tjd=EFD
			set xpdo.cktyp=ALDCHK
			set xpdo.ckseq=ZCKSEQ
			set xpdo.brcd=BRCD
			set xpdo.uid=UID
			set xpdo.trc=X
			set xpdo.cid=ln.cid
			set xpdo.tamt=TAMT
			do xpdo.save()
			}
	
		// Place hold on internal account, if so desired, based upon value in UTBLALDP
		if ln.aldm=1 do {
			set ALDP=ln.aldp
			set ALDHLD=Db.getOneRow("ALDHLD","UTBLALDP","ALDP") 
			if ALDHLD do {
				do ^UTLO
				set CID=ln.cid
				set TCMT=$$^MSG(3939,CID)           //transfer from loan acct
				set ALDHLD=$$PUTHOLD^PHLD(ln.adtar,%SystemDate,"",TAMT,1,%UserID,UTLO,TCMT)
				}
			}

		// Distribution During Host Store and Forward
 		if $G(%STFHOST) do { quit
			new LN
			do Runtime.start("BA","","STACK")
			do TRNSET^TRNDRV(.ttx(),%SystemDate,BRCD,4)
			do Runtime.rollback("STACK")

			// return tssp record from ttx()
			new vzrec
			set vzrec=$$FMTTSSP^STFUTL(.ttx(),"",BRCD,%SystemDate)

			// Store STF record
			do STFREC^STFUTL(1,vzrec,.ttx())

			set CID=SAVCID
			set CRCD=BCRCD
			}

		do { quit:ER 
			new LN
			do TRNSET^TRNDRV(.ttx(),%SystemDate,BRCD,4)
			}
	
		set CID=SAVCID
		set CRCD=BCRCD
		}
	
	/*
	   Automatic Loan Disbursement via External Account
	   This will process an outgoing PO to debit the loan and credit the external
	   account immediately upon filing.  As the EFTOUT message will be created,
	   this disbursement will not be able to be reversed.
	*/

	if ln.aldm=2,ln.aldext'="" do { quit:ER 
		new XACN,XSEQ,EFD,TAMT,CRCD
		set XACN=ln.acn
		set XSEQ=ln.aldext
		set RINST=Db.getOneRow("EXTINST","CIFEXT","XACN,XSEQ")
		set RACCT=Db.getOneRow("EXTACCT","CIFEXT","XACN,XSEQ") 
		set EFD=ln.odd
		set TAMT=ln.amtreq
		set CRCD=ln.crcd

		if $G(%STFHOST) do ^EFTBUILD(ln.cid,"",RACCT,RINST,TAMT,CRCD,EFD,"","PO",0) quit
		do ^EFTBUILD(ln.cid,"",RACCT,RINST,TAMT,CRCD,EFD,"","PO",1) quit:ER 
		}
	
	quit 

vSIG()	quit "60477^65453^Pat Kelly^7481"	// Signature - LTD^TIME^USER^SIZE
