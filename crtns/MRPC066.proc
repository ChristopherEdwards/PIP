public MRPC066(String RETURN,Number VERSN,String FID,Number MET,String FEP)
	/*

	   ORIG: SPIER - 09/24/97
	   DESC: On Demand Transfer to Gui client of schema and data or data only
	   for a specific file, to a specific client.

	   KEYWORDS:

	   INPUTS:
	   . RETURN 	Data (see below)  		/TYP=T/REQ/MECH=REFNAM:W

	   . VERSN  	^MRPC066 version number		/TYP=N/REQ/MECH=VAL
	     		Current version = 1

	   . FID  	File Name to transfer		/TYP=T/REQ/MECH=VAL

	   . MET  	Type of transfer		/TYP=N/REQ/MECH=VAL
	     		1) SCHEMA + DATA  /MECH=VAL
	     		2) DATA only

	   . FEP  	Client Name to transfer to	/TYP=T/REQ/MECH=VAL



	   RETURNS:
	   . RETURN  Null if invalid parameters		/TYP=T
	     Transfer file name if data  is valid

	   RELATED:
	   . Function DDPXFR , interactive selection of files


	  ---- Revision History ------------------------------------------------

	   03/03/05 - KELLYP - CR 13664
	   	Modified top level of procedure to return an error message when
	   	the DDPHOST table does not contain a record for the host directory
	   	and FEP specified by the client.  This prevents a situation from
	   	occurring where a RECNOFL error was encountered by the BATCH section
	   	after the message was returned to the client indicating that the FEP
	   	was created successfully when it wasn't.  Also moved the host 
	   	directory edit check from BATCH to the top level for the same reason
	   	and modified the BATCH section to accept the host directory name
	   	as an input parameter.  Also modified top level of procedure to 
	   	conform to current PSL standards and removed pre-2003 revision 
	   	history.
	*/
	
	type Public Boolean ER
	type Public String RM
	
	type Number I,INVALID,%QN,VX
	type String DIR,FILE,FILETYP,MSG,ZJOB
	
	set ER=0
	set %ProcessMode=0 
	set RETURN="" 
	set MSG=""
	
	// Version number of client message is not compatible with server
	if VERSN.get()'=1 quit $$ERRMSG^PBSUTL($$^MSG(2951))

	// Invalid table value ~p1
	if FID.get().isNull() quit $$ERRMSG^PBSUTL($$^MSG(1485))

	// Verify that all files are valid for transfer
	for I=1:1 quit:FID.piece(",",I).isNull()  do {

		set FILE=FID.piece(",",I)
		if 'Db.isDefined("DBTBL1","'SYSDEV',FILE") set ER=1,MSG=MSG_$C(13,10)_$$^MSG(1485,FILE)      
		}	

	if ER quit $$ERRMSG^PBSUTL(MSG.piece($C(13,10),2,100))
	
	// Transfer option must be selected
	if MET.isNull() quit $$ERRMSG^PBSUTL($$^MSG(2509))       
	
	// Client name is required
	if FEP.isNull() quit $$ERRMSG^PBSUTL($$^MSG(2510))

	set DIR=$$DIR^DDPUTL
	
	// GT.M environment not defined
	if DIR.isNull() quit $$ERRMSG^PBSUTL($$^MSG(3434))

	// Error in DDP directory name
	if 'Db.isDefined("DDPHOST","HOSTDIR=:DIR,FEPDIR=:FEP") quit $$ERRMSG^PBSUTL($$^MSG(3413))

	set INVALID=0

	if MET=2 for I=1:1 quit:FID.piece(",",I).isNull()  do {
		set FILE=FID.piece(",",I)
		type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:FILE")
	
		// Index and dummy data and temporary is not sent to the client
		if dbtbl1.filetyp=4 set INVALID=INVALID+1 quit
		if dbtbl1.filetyp=5 set INVALID=INVALID+1 quit
		if dbtbl1.filetyp=7 set INVALID=INVALID+1 quit
	
		// If logging is not turned for this file then no data can be sent.
		if +dbtbl1.log=0 set INVALID=INVALID+1 quit 
		if +dbtbl1.netloc=0 set INVALID=INVALID+1 quit 
		}
	
	// Selected tables not available for data transfer
	if INVALID=FID.length(",") set ER=1 quit $$ERRMSG^PBSUTL($$^MSG(3983))     
	
	// Get [DDPTQUE] sequence number to pass back to client
	set %QN=$$GETQUE^DDPXFR1
	
	// Build string of routine and parameters to JOB this process
	set ZJOB="BATCH^MRPC066("_%QN_","""_FID_""","_MET_","""_FEP_""","""_DIR_""")"

	// Execute the transfer as a detached process to avoid TP issues
	set VX=$$^%ZJOB(ZJOB,"PRO=XFR",1)

	if VX=0 do {
		set ER=1
		set RETURN=RM.get()
		}
	
	// RETURN to client as we are processing the transfer request.
	else  set RETURN="F"_%QN_".FEP"
	
	set RETURN=$$V2LV^MSG(.RETURN)
	quit ""
	
	
BATCH(Number %QN,String FIDDATA,Number MET,String FEP,String DIR)	// Jobbed process to avoid TP errors while building transfer file

	/*
	   This label is executed by the detached process. It executes the
	   commands required to create a file which the client can read
	   It makes extensive use the the functionality created for native mode
	   function DDPXFR for table and schema transfer.
	

	   Initalize some variables required by DDPXFR1
	   The specific ones related to the data from the user are FEP and FLG
	
	*/
	
	new CLIENT,CTBL1,CURRDATA,DATE,DDPDIR,ER,exe,HOSTDIR,FID,FIDLIN,FLG,FOUND
	new I,IOLIST,IONUMB,KEYCNT,MISCT,MSG
	new REC2,RECTYPE,RM,SREC,SPLITFLG,STBL1,%SystemDate,TIME,TRECWRT,USERNAME,UTBL1,WRTREC,X

	catch vERROR {
	
		// log the error and quit
	
		do ZE^UTLERR
		}
	do SYSVAR^SCADRV0()
	set ER=0
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

	// Initialize a few variables
	set USERNAME=%UserName
	set DATE=%CurrentDate
	set TIME=%CurrentTime

	set DDPDIR=$$DDPDIR^DDPUTL(DIR)

	if DDPDIR="" set DDPDIR=$$SCAU^%TRNLNM("DDP")

	// logical name of HOST directory
	set HOSTDIR=DIR                        

	// I18N=OFF:
	
	/*
		 The FLG array is used in other procedures within this utility to determine
		 the types of data being requested. 
		 	2-Schema,10-Tran code,14=UTBL,15=CTBL, 16=STBL 18 miscellaneous
	*/
	for I=2,10,14,15,16,18 set FLG(I)=0


	if FEP'="*" do {
		set CLIENT=cuvar.%vn
		set FEP(FEP)=""

		type RecordDDPHOST ddphost=Db.getRecord("DDPHOST","HOSTDIR=:HOSTDIR,FEPDIR=:FEP")
		set CURRDATA=ddphost.rid
		if $P(CURRDATA,"-",2)="" set $P(CURRDATA,"-",2)="0"
		set CLIENT(CURRDATA,FEP)=""
		if $D(IOLIST(CURRDATA)) quit
		set IOLIST(CURRDATA)=$$FILE^%TRNLNM("F"_%QN_".FEP",DDPDIR)
		set IONUMB(CURRDATA)=%QN
		set X=$$FILE^%ZOPEN(IOLIST(CURRDATA),"WRITE/NEWV",,5600)
		if 'X set ER=1 set RM=$P(X,"|",2) do ^UTLERR quit 
		}
		
	I ER quit

	if FEP="*" do FEPALL^DDPXFR
	if MET=1 for I=1:1:$L(FIDDATA,",") do {
		set FID=$P(FIDDATA,",",I)
		set FLG(2)=1
		do SETENTRY^DDPXFR1(FID,.FID1)
		}
	
	// setup UTBL,CTBL,STBL,MISCT array for data transfer
	else  for I=1:1:$L(FIDDATA,",") do SETUP($P(FIDDATA,",",I))

	new FID,FIDDATA
	
	// Create the file based upon the data
	do BUILD^HSYNCFBD

	// Update the DDP global with the information
	do FILE^DDPXFR1
	quit 


SETUP(FID)	// Build required arrays in order to build a transfer file


	/* 

	 Based on user entered data, build arrays of data to be retrieved and request the file to be built

	Arguments:
 
	. FID			Table Name		/TYP=T/REQ/MECH=VAL
 

	*/

	new GLOBALKY,INDEX,REL
	type RecordDBTBL1 table=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:FID")

	// network location 0 then do not transfer
	if +table.netloc=0 quit

	// logging flag turned off
	if +table.log=0 quit
	
	// journal and dummy tables or undefined table types will not be sent to client
	// This types of data are not required on a client
	if table.filetyp=4!(table.filetyp="")!(table.filetyp=5) quit 
	       
	// do not send to GUI clients tables known to be of no use
	if Db.isDefined("STBLNOGUI","FID") quit
	
	if table.global="TRN" do { quit
		set FLG(10)=1
		type ResultSet rs=Db.select("ETC","TRN","ETC>'@z' AND ETC<'a'")
		if rs.isEmpty() quit
		while rs.next()  set TRAN1(rs.getCol(1))=""
		}

	set REL=$$FNDFKEYS^DDPXFR1(FID)
	for INDEX=1:1:$L(REL,",") do {
		if $P(REL,",",INDEX)="" quit 
		set GLOBALKY=$$LOCGBL^DDPXFR1($P(REL,",",INDEX))
		set $P(REL,",",INDEX)=$P(REL,",",INDEX)_"~"_GLOBALKY
		}

	set GLOBALKY=$$LOCGBL^DDPXFR1(FID)
	if table.global="UTBL" set UTBL1(FID)="SYSDEV"_"||"_REL_"|"_GLOBALKY set FLG(14)=1 quit 
	if table.global="STBL" set STBL1(FID)="SYSDEV"_"||"_REL_"|"_GLOBALKY set FLG(15)=1 quit 
	if table.global="CTBL" set CTBL1(FID)="SYSDEV"_"||"_REL_"|"_GLOBALKY set FLG(16)=1 quit 
	if FID="DBTBL" quit 
 
	set MISCT(FID)="SYSDEV"_"||"_REL_"|"_GLOBALKY 
	set FLG(18)=1
	
	quit 

vSIG()	quit "59962^59097^Pat Kelly^7496"	// Signature - LTD^TIME^USER^SIZE
