UCIDSCA
	// Find Next Account Number
	/*
		 ORIG:  Tom Locke (2424) - 06/06/86
	
	  ---- Revision History ------------------------------------------------
	12/10/04 - Georges - CR 13023
		 Modified section UPD to pass the value 'ACN' instead 
		 of the variable ACN. 
	  
	12/08/03 - spier 7403
			psl compiler warning message cleanup
			
	10/16/02 - Spier - 51089
		   Fixed db.update of utblncidt record which did
		   not compile under new psl compiler.
 	
	02/05/02 - MBUIM - 43583
		     Converted to PSL.
	
	*/

	set (CID,X)=""
	if '$G(%NOLOCK) do {
		if $$ALLOC("ACN") set (X,CID)=$$NXTCID("ACN") quit 

		type ResultSet rs=Db.select("CID","UTBLUCIDTYPE","CLS=:CLS AND GRP=:GRP AND TYPE=:TYPE")
		
		set V=""
		if CID="" do {
			type ResultSet rs=Db.select("CID","UTBLUCIDGRP","CLS=:CLS AND GRP=:GRP")
						
			if rs.next() set CID=rs.getCol(1)
			}

		if CID="" do { 
			type ResultSet rs=Db.select("CID","UTBLUCIDCLS","CLS=:CLS")
						
			if rs.next() set CID=rs.getCol(1) 
			}
		
		if CID="" do {
			type ResultSet rs=Db.select("CID","UTBLUCIDCLS","CLS='ACN'")
						
			if rs.next() set CID=rs.getCol(1) 
			}
		
		if CID="" set CID=Db.nextVal("ACN","CID")

		set (ER,RM)="" 
		do NCID
		}
	
	quit 

NCID	// Get next number if failure, called from Screen NEW

	set X=""
	for CID=CID:1 do { quit:'ER!(VFMQ="Q") 
		set (ER,RM)="" 
		set X=CID
		do VER
		if ER,CDM'="" set CID=SAVCID	    
		}
	quit 

VER	// Verify account number

	// Also called by account number post-processor
	if 'X,'V quit 
	if V'="",V=X quit 
	set CID=$S(X="":V,1:X)
	set SAVCID=CID

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
	set CDM=prodctl.cdm
	set PGM=""
	if CDM'="" do {
		type RecordUTBLCDM utblcdm=Db.getRecord("UTBLCDM","CDM")
		set PGM=utblcdm.pgm
		}
	if PGM'="" do EXEC quit:ER  set CID=X
	
	// Leading zeros not allowed
	if $E(CID)=0 set ER=1 set RM=$$^MSG(1598) quit	 
	
	// Account number must be positive integer
	if CID'>0!(CID#1) set ER=1 set RM=$$^MSG(88) quit    
	
	// Currently being set up
	if '$G(%NOLOCK) lock +ACN(CID):2 else  do Runtime.setErrMSG("ACN",684) quit:ER	 
	
	// Account already exists
	if Db.isDefined("ACN","CID") do Runtime.setErrMSG("ACN",53) quit:ER	 
	if ER,'$G(%NOLOCK) lock -ACN(CID) quit 

	// Account has been purged
	if Db.isDefined("PURGDACN","CID") do Runtime.setErrMSG("PURGDACN",3841) quit:ER     
	if ER,'$G(%NOLOCK) lock -ACN(CID) quit 

	quit 
	
EXEC	
	catch error {
		set ET=error.type
		set RM=error.description
		set FROM=error.thrownAt	
		do ZE^UTLERR
		set VFMQ="Q"
		set ER=1		
		}
	do @PGM

	quit 
		
Public UPD(CLS,GRP,TYPE,CID)	// Update account number file. Called by executive filers. Under TP.

	if Db.isDefined("UTBLUCIDTYPE","CLS,GRP,TYPE") do Db.update("UTBLUCIDTYPE","CID=CID+1","CLS=CLS AND GRP=GRP AND TYPE=TYPE") quit 
	
	if Db.isDefined("UTBLUCIDGRP","CLS,GRP") do Db.update("UTBLUCIDGRP","CID=CID+1","CLS=CLS AND GRP=GRP") quit

	if Db.isDefined("UTBLUCIDCLS","CLS") do Db.update("UTBLUCIDCLS","CID=CID+1","CLS=CLS") quit
	  
	if Db.isDefined("UTBLUCIDCLS","CLS='ACN'") do Db.update("UTBLUCIDCLS","CID=CID+1","CLS='ACN'") quit

	quit 

Public ALLOC(TBL)	// Use allocation method or not?

	new ALLOC,PGM,X

	set ALLOC=0
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

	set PGM=cuvar.ucid
	if PGM'="" set PGM=$$UPPER^%ZFUNC(PGM)
	if PGM="^UCIDSCA" set PGM=""
	if PGM'="" do { quit ALLOC
		if $E(PGM)'="^" set PGM="^"_PGM
		set X="S ALLOC=$$ALLOC"_PGM_"("_$C(34)_TBL_$C(34)_")"
		#accept pgm=spier;date=12/8/03
		xecute X
		}
	
	if TBL="" quit 0
	if Db.isDefined("UTBLNCIDT","TBL")=1 quit 1    
		
	quit 0
	
Public NXTCID(TBL)	// Get next available CIF or ACCOUNT #

	//  Emulates behavior of ^MRPC020()
	
	new ACTLEN,CDM,GLOB,NUMBER,PGM,PGM,PREFIX,X,Y

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
	
	set PGM=cuvar.ucid
	
	if PGM'="" set PGM=$$UPPER^%ZFUNC(PGM)
	if PGM="^UCIDSCA" set PGM=""
	if PGM'="" do { quit NUMBER
		if $E(PGM)'="^" set PGM="^"_PGM
		set X="S NUMBER=$$NXTCID"_PGM_"("_$C(34)_TBL_$C(34)_")"
		#accept pgm=spier;date=12/8/03
		xecute X
		}
	
	lock +UTBLNCIDT(TBL):5 else  set ER=1 set ET="RECLOC" do ^UTLERR quit ""   
	type RecordUTBLNCIDT utblncidt=Db.getRecord("UTBLNCIDT","TBL")

	set NUMBER=utblncidt.nnum
	if NUMBER="" set NUMBER=1
	
	set (PREFIX,CDM,ACTLEN)=""
	// Select Prefix and Check digitmethod
	if TBL'="CIF" do {
		type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
		
		set PREFIX=prodctl.prefix
		set CDM=prodctl.cdm
		set ACTLEN=prodctl.acctnumlen
		}
	
	// Check for check digit method
	type RecordUTBLCDM utblcdm
	if $G(CDM)'="" do {
		set utblcdm=Db.getRecord("UTBLCDM","CDM")
		set CKCDM=utblcdm.pos
		}
	else  set CKCDM=0
	
	// Add account number length, prefix, or check digit method
	set Y=$$ACCTNUM(.utblcdm)
	
	if TBL="CIF",Db.isDefined("CIF","Y") do {
		set NUMBER=NUMBER+1 
		set Y=$$ACCTNUM(.utblcdm)
		}

	if TBL="ACN",Db.isDefined("ACN","Y") do {
		set NUMBER=NUMBER+1 
		set Y=$$ACCTNUM(.utblcdm)
		}
	
	set NUMBER=NUMBER+1

	type RecordUTBLNCIDT cidt=Db.getRecord("UTBLNCIDT","TYPE=:TBL",1)
	if cidt.getMode()=1 do {
		set cidt.nnum=NUMBER
		do cidt.save()
		}

	lock -UTBLNCIDT(TBL)

	quit Y
	
ACCTNUM(RecordUTBLCDM utblcdm)	// Checks account number length and puts a prefix and/or check digit method on the account.

	new SEQ,SEQ1

	// Check for account number length and set account length
	if ACTLEN do {
		set SEQ=ACTLEN-$L(PREFIX)-CKCDM
		set SEQ1=10**SEQ*PREFIX+NUMBER
		}
	
	else  do {
		// Concatenate prefix to account number
		if PREFIX set SEQ1=PREFIX_NUMBER
	
		// If a prefix is not added set SEQ1 equal to number
		else  set SEQ1=NUMBER
		}
	
	set Y=SEQ1
	
	// Add check digit to account if it exists
	if CDM'="" do {
		set PGM=""
		if CDM'="",Db.isDefined("UTBLCDM","CDM") do {
			set utblcdm=Db.getRecord("UTBLCDM","CDM")
			set PGM=utblcdm.pgm
			}
		if PGM'="" do EXEC quit:ER 
		}

	quit Y

vSIG()	quit "59879^52006^Santosh George^5592"	// Signature - LTD^TIME^USER^SIZE
