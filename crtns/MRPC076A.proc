MRPC076A	// Transaction Set MRPC Code Generator
	/*
	DESC:  Generates procedure MRPC076B - compiled transaction sets
	
	---- Comments ---------------------------------------------------------
	This procedure generates MRPC076B.  The definitions associated
	with each transaction set from table UTBLTRNSET are built into MRPC076B,
	as well as the processing code to return the expanded transaction set
	in the proper TSSP return format for the MRPC.
	
	This procedure can be run independently to build MRPC076B, and is also
	rebuilt whenever MRPC076 is rebuilt through an XECUTE command in
	MRPC076.
	      
	RETURNS:
		. ER		Error indicator		/TYP=L
				 0 = no error
				 1 = no error
				 
		. RM		Error message		/TYP=T
		
	
	---- Notes ------------------------------------------------------------
	
	The following is the arguments definition section for the generated
	procedure MRPC076B.
	
	ARGUMENTS:
		. TRNSET	Transaction set ID	/REQ/MECH=VAL
 
                . ttx()		Transaction set		/REQ/MECH=REFNAM:RW
				contains one transaction
				on input, the full set
				on return
				
		. return	Return string fro	/REQ/MECH=REFNAM:W
				MRPC - LV TSSP
		
	RETURNS:
		. $$		Error message,		/TYP=L
				null indicates
				no error
				
				
	------ Revision History -----------------------------------------------
	01/11/07 - chhabris - CR
		   Retrofit from ICGWeb01_Dev_Profile view for Profile Direct
		   Enhancements.

	   	   12/01/06 - SigdaE - CR23919 (ICGWeb01_Dev_Profile)
		   	Added BRCD as an argument to MRPC76B.  Also remove
			code that was defining BRCD to the Back Office Branch
			Code.  Branch Code is defined in MRPC076 by the call
			to FMTTR^PBSTSSP.

	10/16/06 - KELLYP - CR 23624
		   Modified top level to use the order method instead of $O
		   on the ttx array.  This prevents a problem where MRPC076B
		   would not compile correctly in environments where PSL
		   object optimization was disabled.

	03/28/06 - ARPAVC - CR 20243
		   Updated code to consider a TAMT of -1.  This means
		   that the calling code was unable to process the transaction.
		   This does not necessarily mean that an error should be
		   generated but that the transaction should not be posted
		   to teller.
		   
	03/24/06 - TELIV - CR 19926
		   Modified section BLDFUNC to add a "()" when the function is 
		   supposed to return a Value
	
	02/27/06 - SPR - CR 17536
		   Modified this procedure to take care of semicolon in the
		   repeat field.
		
	12/26/05 - SPR - CR 15517
		   Section INTTX and calls to section INTTX were added 
		   to all BLD* sections to properly handle TTX fields
		   in the transaction set.
			
	-----------------------------------------------------------------------
	*/
	
	// I18N=OFF
	
	type Public Number ER = 0
	type Public String RM = ""
		
	type Number ID,LINE,SAVELINE()
	type String CMPERR(),CODE,pslcode(),N,TAB,TSLIST(),VARLIST()
	
	set ID = 1
	set TAB = $C(9)

	do addcode(0,"MRPC076B(String TRNSET,RecordTTX ttx(),Number BRCD,String return)"_TAB_"// Transaction Set Code Compiled Program")
	do addcode(1,"// Last compiled:  "_%CurrentDate.toString()_" "_$$TIM^%ZM_" - "_%UserName)
	do addcode(0,"")
	do addcode(1,"// THIS IS A COMPILED ROUTINE.  Compiled by procedure MRPC076A")
	do addcode(0,"")
	do addcode(1,"// See MRPC076A for argument definitions")
	do addcode(0,"")
	
	// Get each of the transaction sets and assign ID number to it
	type ResultSet rs = Db.select("DISTINCT TRNSET","UTBLTRNSET")
	
	// If there are no transets, just build in error return
	if rs.isEmpty() do { quit
		do addcode(1,"// No transaction sets defined")
		do addcode(0,"")
		do addcode(1,"quit $$^MSG(7609)"_TAB_TAB_"// Invalid value")
	}
	
	// Start building
	do addcode(1,"type public String CRCD")
	do addcode(1,"type Number NETAMTSQ = 0")
	do addcode(1,"type String ERMSG,PROT")
	do addcode(1,"// Save for other variable typing",.LINE)
	set SAVELINE(1)=LINE
	do addcode(0,"")
	
	// Assign IDs and build call section
	while rs.next() do {
		
		type String TRNSET = rs.getCol("TRNSET")
		
		set TSLIST(ID) = TRNSET
		set CODE = "if TRNSET = """_TRNSET_""" set ERMSG = $$ts"_ID_"(.ttx(),.PROT,.NETAMTSQ)"
		if ID > 1 set CODE = "else  "_CODE
		do addcode(1,CODE)
		set ID = ID + 1
		}
	
	// Last step on call list -- error
	do addcode(1,"else  set ERMSG = $$^MSG(7609)"_TAB_TAB_"// Invalid value")
	do addcode(0,"")
	
	// Section to deal with net amount and build return
	do addcode(1,"if ERMSG.isNull() do {")
	do addcode(0,"")
	do addcode(2,"// Calculate net amount")
	do addcode(2,"if NETAMTSQ do {")
	do addcode(0,"")
 	do addcode(3,"type Number N = """"")
	do addcode(3,"type Number NETAMT = 0")
	do addcode(0,"")
	do addcode(3,"for  set N = ttx(N).order() quit:N.isNull()  if N '= NETAMTSQ set NETAMT = NETAMT + ttx(N).tamt")
	do addcode(0,"")
	do addcode(3,"set ttx(NETAMTSQ).tamt = NETAMT ")
	do addcode(2,"}")
	
	// Note - old code renumbered ttx array at this point to make sure 
	// sequential, whole numbers.  This is no longer is necessary.
	
	do addcode(0,"")
	do addcode(2,"// Convert ttx array to TSSP message")
	do addcode(2,"set return=$$CLOUT^TTXRPC(.ttx())_$$V2LV^MSG(PROT)")
	do addcode(1,"}")
	do addcode(0,"")
	do addcode(1,"quit ERMSG")
	do addcode(0,"")
	do addcode(0,"")	
	
	// Build common code, BLDTTX
	do addcode(0,"BLDTTX(RecordTTX ttx(),Number SEQ)")
	do addcode(0,"")
	set LINE = ""
	do addcode(1,"// Save line for public data typing",.LINE)
	set SAVELINE(2)=LINE
	do addcode(0,"")
	do addcode(1,"if TSO.get().isNull() set TSO = ""#""")
	do addcode(1,"if TCMT.get().isNull() set TCMT = """"")
	do addcode(1,"if %EffectiveDate.isNull() set %EffectiveDate = %SystemDate")
	do addcode(0,"")
	do addcode(1,"// TTX^TTXEXT expects OCC for cost center")
	do addcode(1,"if OCC.get().isNull() set OCC = CC.get()")
	do addcode(0,"")
	do addcode(1,"set ttx(SEQ) = Class.new(""RecordTTX"")")
	do addcode(1,"do TTX^TTXEXT(.ttx(SEQ))")
	do addcode(0,"")
	do addcode(1,"// Transaction Source of Funds")
	do addcode(1,"if ttx(SEQ).tso = ""#"" set ttx(SEQ).tso = """"")	// TSO
	do addcode(0,"")
	do addcode(1,"quit")
	
	/* Build section for each transaction set.  Within each section, will step
	   through each SEQ record within the transaction set and deal with it per
	   its definition.
	*/
	
	set ID = 0
	for  set ID = TSLIST(ID).order() quit:ID.isNull()  do {
		
		type String TRNSET,TSVARLST()
		
		set TRNSET = TSLIST(ID)

		do addcode(0,"")
		do addcode(0,"")
		do addcode(0,"ts"_ID_"(RecordTTX ttx(),String PROT,Number NETAMTSQ)  // Transaction set "_TRNSET)
		do addcode(0,"")
		do addcode(1,"type Public Number ER")
		do addcode(1,"type Public String RM")
		set LINE = ""
		do addcode(1,"// Save for public typing",.LINE)
		set SAVELINE(3) = LINE
		do addcode(0,"")
		do addcode(1,"type Date %EffectiveDate = ttx(1).efd")
		do addcode(1,"type Number SEQ")
		do addcode(1,"type String ERMSG,SEQPROT,VALUE")
		do addcode(0,"")
		do addcode(1,"set ERMSG = """"")
		do addcode(1,"set PROT = 0_$C(9)_0_$C(13,10)")
		
		type ResultSet rs = Db.select("DISTINCT SEQ", "UTBLTRNSET", "TRNSET = :TRNSET", "SEQ")
		while rs.next() do {
			
			type Boolean DISZERO = 0
			type Number SEQ,TABS
			type String REPEAT
			
			set SEQ = rs.getCol("SEQ")
			
			// Repeat indicator for the sequence is only on TRNFIELD "CID"
			type RecordUTBLTRNSET cidfld = Db.getRecord("UTBLTRNSET", "TRNSET = :TRNSET, SEQ = :SEQ, TRNFIELD = 'CID'")
			set REPEAT = cidfld.repeat		// Repeat is a user function
			
			//  Only consider repeat field before comment indicator ";"
			set REPEAT=REPEAT.piece(";",1)
																		
			do addcode(0,"")
			do addcode(1,"// ----- SEQ="_SEQ_" ----------")
			do addcode(1,"set SEQ = "_SEQ)
						
			set TABS = 1			// If no REPEAT, don't need FOR loop
			if 'REPEAT.isNull() do {
				set TABS = 2
				do addcode(1,"type Number I")	
				do addcode(1,"for I = 1:1:"_REPEAT_" do { quit:'ERMSG.isNull()")
				do addcode(0,"")
			}
			
			do addcode(TABS,"set SEQPROT = 0_$C(9)_0")

			// Handle each TRNFIELD within SEQ
			type DbSet ds = Db.selectDbSet("UTBLTRNSET", "TRNSET = :TRNSET AND SEQ = :SEQ", "TRNFIELD")
			while ds.next() do {
				
				type RecordUTBLTRNSET trnset = ds.getRecord("UTBLTRNSET")
				
				if 'trnset.tso.isNull() do BLDTSO(.trnset,TABS,.TSVARLST())
				if 'trnset.function.isNull() do BLDFUNC(.trnset,TABS,.TSVARLST(),REPEAT)
				if 'trnset.tablecol.isNull() do BLDTC(.trnset,TABS,.TSVARLST())
				if 'trnset.fixedval.isNull() do BLDFVDTE(.trnset,TABS,.TSVARLST(),0)
				if 'trnset.dte.isNull() do BLDFVDTE(.trnset,TABS,.TSVARLST(),1)
				
				if trnset.prot do {
					if trnset.trnfield = "CID" do addcode(TABS,"set SEQPROT.piece($C(9),1) = 1"_TAB_TAB_"// Turn on CID protection")
					if trnset.trnfield = "TAMT" do addcode(TABS,"set SEQPROT.piece($C(9),2) = 1"_TAB_TAB_"// Turn on TAMT protection")
				}
				
				/* DISZERO can be set on any TRNFIELD within the SEQ, however,
				   since it only applies to transaction amount, coded to only
				   consider that value.  In prior code, the last TRNFIELD's value
				   was used, which didn't make sense.
				*/
				if trnset.trnfield = "TAMT" set DISZERO = trnset.diszero
			}
			
			// Done with all TRNFIELDS
			do addcode(0,"")
			
			// Check for non-negative TAMT.
			do addcode(TABS,"if TAMT.get()'<0 do {"_TAB_TAB_"// Skip if Negative TAMT")
			set TABS=TABS+1

			// Add public variables that have been set and will be returned
			set (CODE,N) = ""
			for  set N = TSVARLST(N).order() quit:N.isNull()  do {
				set CODE = CODE_N_","
				set VARLIST(N) = ""		// Master list
			}
			set CODE = CODE.extract(1,CODE.length()-1)
			do addcode(1,"type Public String "_CODE,SAVELINE(3))
			
			do addcode(TABS,"if ETC.get().isNull() set ERMSG = $$^MSG(3113,""ETC"")"_TAB_TAB_"// Missing ETC")
			do addcode(TABS,"if CID.get().isNull() set ERMSG = $$^MSG(3113,""CID"")"_TAB_TAB_"// Missing CID")
			
			if 'REPEAT.isNull() do {
				do addcode(TABS,"quit:'ERMSG.isNull()")
			}
			else  do addcode(TABS,"if 'ERMSG.isNull() quit ERMSG")

			do addcode(0,"")
			
			// Handle no display if DISZERO not set and TAMT is zero
			if 'DISZERO do {
				do addcode(TABS,"// Only display if not zero")
				do addcode(TABS,"if (TAMT <> 0) do {")
				set TABS = TABS + 1
			}
			
			do addcode(TABS,"do BLDTTX(.ttx(),SEQ)"_TAB_TAB_"// Add to ttx array")
			do addcode(0,"")

			do addcode(TABS,"set PROT = PROT_SEQPROT_$C(13,10)")
			
			if 'REPEAT.isNull() do addcode(TABS,"set SEQ = SEQ + .01")
			
			if 'DISZERO do {
				set TABS = TABS - 1
				do addcode(TABS,"}")			// Close do
			}
			set TABS = TABS - 1
			do addcode(TABS,"}")                    // Close do for non-negative TAMT
			
			if 'REPEAT.isNull() do {
				do addcode(1,"}")		// Close FOR loop
				do addcode(0,"")
				do addcode(1,"if 'ERMSG.isNull() quit ERMSG")
			}
		}
		
		do addcode(0,"")
		do addcode(1,"quit """"")
	}
	
	// Add variable scoping to main section and BLDTTX
	for N = "CC","OCC","TCMT","TSO" set VARLIST(N) = ""
	
	set (CODE,N) = ""
	for  set N = VARLIST(N).order() quit:N.isNull()  do {
		if N'="CRCD" set CODE = CODE_N_","
	}
		
	set CODE = CODE.extract(1,CODE.length()-1)
	
	do addcode(1,"type String "_CODE,SAVELINE(1))
	do addcode(1,"type Public String "_CODE,SAVELINE(2))
		
	// Build compiled routine
	do BUILDRTN^UCGM(.pslcode,"MRPC076B",.CMPERR)
	if CMPERR.data() do {
		
		type String N = ""

		for  set N=CMPERR(N).order() quit:N=""  do {
			if 'ER set ER=1,RM=CMPERR(N)
			write CMPERR(N),!
		}
	}
	
	//Completed at ~p1
	if 'ER set ER="W",RM=$$^MSG(591,$$TIM^%ZM(%CurrentTime))
	
	quit
	
	
BLDTSO(RecordUTBLTRNSET trnset,		// Build TSO code
	       String TABS,
	       String TSVARLST())
	
	type Boolean isINTTX 
	type String CODE,REFTRAN,TAB,TRNFIELD,TSO
	    
	set REFTRAN = trnset.reftran
	set TRNFIELD = trnset.trnfield
	
	quit:REFTRAN.isNull()
	
	type RecordSTBLTSO stbltso=Db.getRecord("STBLTSO","KEY = :TRNFIELD",1)
	
	do addcode(0,"")
	do addcode(TABS,"// SEQ="_trnset.seq_" TRNFIELD="_TRNFIELD_" type=TSO")
	
	// Get TSO from reference transaction
	set TSO = $$addqotes(trnset.tso)
	do addcode(TABS,"set VALUE = $$FIELD^UTSO(ttx("_REFTRAN_").tso,"_TSO_")")
 	
 	set isINTTX = $$INTTX(TRNFIELD)
 	
 	if TRNFIELD = "CC" set CODE = "set CC = VALUE"
 	else  if TRNFIELD = "OCC" set CODE = "set OCC = VALUE"
 	else  if TRNFIELD = "TCMT" set CODE = "set TCMT = VALUE"
 	else  if isINTTX set CODE = "set "_TRNFIELD_" = VALUE"
 	else  if 'stbltso.getMode() set CODE = "set "_TRNFIELD_" = VALUE"
 	else  do {
 		set CODE = "set TSO = $$FIELDIN^UTSO(TSO.get(),"""_TRNFIELD_""",VALUE)"
 		set TSVARLST("TSO") = ""
 	}
 	
 	do addcode(TABS,CODE)
 	set TSVARLST(TRNFIELD) = ""

 	quit
 	
 	
BLDFUNC(RecordUTBLTRNSET trnset,	// Build function call code
		String TABS,
		String TSVARLST(),
		Number REPEAT)
	
	type Boolean isINTTX 
	type String CODE,FUNC,TAB,TRNFIELD
	    
	set TAB = $C(9)
	set FUNC = trnset.function
	set TRNFIELD = trnset.trnfield
	
	type RecordSTBLTSO stbltso=Db.getRecord("STBLTSO","KEY = :TRNFIELD",1)
	
	do addcode(0,"")
	do addcode(TABS,"// SEQ="_trnset.seq_" TRNFIELD="_TRNFIELD_" type=Function")
	
 	if (TRNFIELD="TAMT")&(FUNC="$$NETAMT^TRNSET") do {
 		
 		// I believe that this is a runtime test since REPEAT is a function
 		// call and values may vary at runtime.  (DSR)
 		
 		do addcode(TABS,"// You can only use $$NETAMT^TRNSET once per transaction set")
 		set CODE = "if NETAMTSQ set ERMSG = $$^MSG(5342) "
 		if 'REPEAT.isNull() set CODE = CODE_"quit"
 		else  set CODE = CODE_"quit ERMSG"
 		do addcode(TABS,CODE)
 		do addcode(0,"")
 		do addcode(TABS,"set NETAMTSQ = SEQ")
 		// Set a value for now to avoid DISZERO handling -- will be replaced
 		do addcode(TABS,"set TAMT=1")
 		
 		set TSVARLST("TAMT") = ""
  	}
  	
  	if (FUNC.extract(1,2)="$$") do {
  		if (FUNC.extract(FUNC.length(),FUNC.length())=")") do addcode(TABS,"set VALUE = "_FUNC)
  		else  do addcode(TABS,"set VALUE = "_FUNC_"()")
  		}
  	else  do addcode(TABS,"set VALUE = "_FUNC)
  	
  	set CODE = "if ER.get() do { "
  	if 'REPEAT.isNull() set CODE = CODE_"quit"
  	else  set CODE = CODE_"quit ERMSG"
  	do addcode(TABS,CODE)
	do addcode(TABS+1,"if RM.get().isNull() set ERMSG = $$^MSG(7599)"_TAB_TAB_"// Function not executed")
	do addcode(TABS+1,"else  set ERMSG=RM")
	do addcode(TABS,"}")
	
 	set isINTTX = $$INTTX(TRNFIELD)
 	
 	if TRNFIELD = "CC" set CODE = "set CC = VALUE"
 	else  if TRNFIELD = "OCC" set CODE = "set OCC = VALUE"
 	else  if TRNFIELD = "TCMT" set CODE = "set TCMT = VALUE"
 	else  if isINTTX set CODE = "set "_TRNFIELD_" = VALUE"
 	else  if 'stbltso.getMode() set CODE = "set "_TRNFIELD_" = VALUE"
 	else  do {
 		set CODE = "set TSO = $$FIELDIN^UTSO(TSO.get(),"""_TRNFIELD_""",VALUE)"
 		set TSVARLST("TSO") = ""
 	}
 	
 	do addcode(TABS,CODE)
 	set TSVARLST(TRNFIELD) = ""

 	quit


BLDFVDTE(RecordUTBLTRNSET trnset,		// Build fixed value or date code
	         String TABS,
	         String TSVARLST(),
	         Boolean DTE)
	         
	type Boolean isINTTX = 0	 
	type String CODE,FIXEDVAL,TRNFIELD
		
	// DTE must be in the form of T, T-1, T+1, etc
	if DTE set FIXEDVAL = trnset.dte.replace("T","%SystemDate")
	else  set FIXEDVAL = $$addqotes(trnset.fixedval)
	
	set TRNFIELD = trnset.trnfield
	
	type RecordSTBLTSO stbltso=Db.getRecord("STBLTSO","KEY = :TRNFIELD",1)
	type RecordUTBLZTSO utblztso=Db.getRecord("UTBLZTSO","KEY = :TRNFIELD",1)
		
	do addcode(0,"")
	
	set CODE = "// SEQ="_trnset.seq_" TRNFIELD="_TRNFIELD_" type="
	if DTE set CODE = CODE_"Date"
	else  set CODE = CODE_"Fixed Value"
	
	do addcode(TABS,CODE)
	
	set isINTTX = $$INTTX(TRNFIELD)
 	
	if TRNFIELD = "CC" set CODE = "set CC = "_FIXEDVAL
 	else  if TRNFIELD = "OCC" set CODE = "set OCC = "_FIXEDVAL
 	else  if TRNFIELD = "TCMT" set CODE = "set TCMT = "_FIXEDVAL
 	else  if isINTTX set CODE = "set "_TRNFIELD_" = "_FIXEDVAL
 	else  if stbltso.getMode() do {
 		set CODE = "set TSO=$$FIELDIN^UTSO(TSO.get(),"""_TRNFIELD_""","_FIXEDVAL_")"
 		set TSVARLST("TSO") = ""
 	}
 	else  if utblztso.getMode() do {
 		set CODE = "set TSO=$$FIELDIN^UTSO(TSO.get(),"""_TRNFIELD_""","_FIXEDVAL_")"
 		set TSVARLST("TSO") = ""
 	}
 	else  set CODE = "set "_TRNFIELD_" = "_FIXEDVAL
 	
 	do addcode(TABS,CODE)
 	set TSVARLST(TRNFIELD) = ""

 	quit


BLDTC(RecordUTBLTRNSET trnset,		// Build table.column code
	      String TABS,
	      String TSVARLST())
	      
	// The only valid tables are CIF, DEP, LN, and TTX
	
	type Boolean isINTTX      	 
	type String CIDREF,CODE,COLUMN,OBJREF,REFTRAN,TABLE,TRNFIELD
	    
	set TABLE = trnset.tablecol.piece(".",1)
	set COLUMN = trnset.tablecol.piece(".",2)
	set REFTRAN = trnset.reftran
	set TRNFIELD = trnset.trnfield
	
	quit:REFTRAN.isNull()
	
	do addcode(0,"")
	do addcode(TABS,"// SEQ="_trnset.seq_" TRNFIELD="_TRNFIELD_" type=table.column")
	
	if TABLE = "TTX" do { quit
		
		set CODE = "set "_TRNFIELD_" = ttx("_REFTRAN_")."_COLUMN
		set TSVARLST(TRNFIELD) = ""
		do addcode(TABS,CODE)
		
		type RecordSTBLTSO stbltso=Db.getRecord("STBLTSO","KEY = :TRNFIELD",1)
		type RecordUTBLZTSO utblztso=Db.getRecord("UTBLZTSO","KEY = :TRNFIELD",1)
		
		if stbltso.getMode() ! utblztso.getMode() do {
			do addcode(TABS,"set TSO=$$FIELDIN^UTSO(TSO.get(),"""_TRNFIELD_""","_TRNFIELD_")")
			set TSVARLST("TSO") = ""
 		}
	}

	set CIDREF = "ttx("_REFTRAN_").CID"
 		
 	if TABLE = "CIF" do {
 		
 		// Get customer number
 		do addcode(TABS,"type RecordACN acn = Db.getRecord(""ACN"",""CID = :"_CIDREF_""")")
 		do addcode(TABS,"type RecordCIF cif = Db.getRecord(""CIF"",""ACN = :acn.acn"")")
 		set OBJREF = "cif."_COLUMN
 	}
 	
	else  if TABLE = "LN" do {
		
		do addcode(TABS,"type RecordLN ln = Db.getRecord(""LN"",""CID = :"_CIDREF_""")")
		set OBJREF = "ln."_COLUMN
	}
	
	else  do {		// DEP
		
		do addcode(TABS,"type RecordDEP dep = Db.getRecord(""DEP"",""CID = :"_CIDREF_""")")
		set OBJREF = "dep."_COLUMN
	}
	type RecordSTBLTSO stbltso=Db.getRecord("STBLTSO","KEY = :TRNFIELD",1)
	set isINTTX = $$INTTX(TRNFIELD)
	
 	if TRNFIELD = "CC" set CODE = "set CC = "_OBJREF
 	else  if TRNFIELD = "OCC" set CODE = "set OCC = "_OBJREF
 	else  if TRNFIELD = "TCMT" set CODE = "set TCMT = "_OBJREF
 	else  if isINTTX set CODE = "set "_TRNFIELD_" = "_OBJREF
 	else  if 'stbltso.getMode() set CODE = "set "_TRNFIELD_" = "_OBJREF
 	else  do {
 		set CODE = "set TSO = $$FIELDIN^UTSO(TSO.get(),"""_TRNFIELD_""","_OBJREF_")"
 		set TSVARLST("TSO") = ""
 	}
 	
 	do addcode(TABS,CODE)
 	set TSVARLST(TRNFIELD) = ""
 
 	quit
 	
 	
addqotes(String X)	// Add quotes to value, if necessary

	// If not a number, a function, or already quoted, add quotes
	if 'X.isNumber(),'X.isLike("%$$^%"),X.extract(1)'="""" set X=X.addQuotes()
	
	quit X
 	

addcode(Number TABS,		// Add new line to CODE array
		String CODE,
		Number LINENO)
		
	/*
	ARGUMENTS:
		. TABS		Number of tabs to add		/REQ/MECH=VAL
		
		. CODE		Code to add to array		/REQ/MECH=VAL
		
		. LINENO	Line number in array		/NOREQ/MECH=REF:RW
				Default is to end of array
	*/

	type Public String pslcode()
	
	type Number I
	
	if 'LINENO.get() set LINENO = pslcode("").order(-1) + 1 	// Add to end
	
	if TABS for I = 1:1:TABS set CODE=$C(9)_CODE
	
	set pslcode(LINENO) = CODE

	quit
	
	
INTTX(String TRNFIELD)	// Is this field a non-TSO/non-computed in TTX?
	
	
	type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D", "%LIBS=""SYSDEV"",FID=""TTX"",DI=:TRNFIELD", 1)
	
	if (dbtbl1d.getMode() > 0), dbtbl1d.cmp.isNull() quit 1
	
	quit 0

vSIG()	quit "60645^64239^Vanitha Krishnasamy^18678"	// Signature - LTD^TIME^USER^SIZE
