public LNPTS4(RecordLN ln,		// Loan account			/REF:RW
	      RecordTTX ttx,		// Transaction			/REF:RW
	      RecordTRN trn)		// Transaction code		/REF:R

	/*
	Process Principal Only Payments

		INPUTS:
		CTL position 1 updates UDBAL on revolving commitment.		
			(set to 1 in LNPTS2)
			2 updates ln.crlmt - Credit Limit - Current
			3 updates ln.poamt - Total Principal Only Payments
			4 updates ln.tdr -   Total Disbursement Amount
			5 Modifies pmt schedule

		ZAMT -  Remaining amount after all outstanding bills are satisfied
		ETC  -  Transaction Code

	---- Revision History ------------------------------------------------
	
	08/23/07 - KUMARB - CR 28857
		   Modified procedure LNPTS4, section EXEC to add a check to
		   reset ZAMT only if BALCMP is less than ZAMT. Previously ZAMT
		   was incorrectly set to BALCMP for the payment grid 2,27,4,6.
	
	05/11/07 - DHANALAKSHMI R - CR 27061
		   Modified the sections EXEC, UPDSCH and PEN to use ln.cvcid
		   instead ln.cid in OVR() for problem sub-loan account. This
		   avoids popping up the same override restriction infinitely.

	01/05/07 - KUMARB - CR24680
		   Modified section EXEC to update the principal amounts on 
		   loans with Segments Allowed (LN.SEGMENTS) selected by
		   calling PAYBAL^LNSEG.

	09/21/06 - SANTHUMS - CR 23160
		   . Modified RB section to pass parameters in correct order
		     since ttx object is getting overwritten with trn object.
		   . Modified RB section to prevent UNDEFINED error on
	  	     CNT variable.
		
	06/29/06 - TITOVE - CR 21957
		   Modified PEN section to pass BLAMT as an argument to
		   CALCPEN^LNPO2A. This ensures payment amount is used when
		   calculating penalty amount instead of loan balance. Also
		   added another argument, Compute Penalty as Net of Trans,
		   restoring V6.4 logic.

	04/06/06 - SmithCD - CR 20510
		   . Replaced trn.pcfd* checks with trn.pcfl*. Prevents (among 
		     other things) problem where a penalty was not calculated 
		     even though trn.pcfl23 was set on the transaction code
		   . Removed SDD variable from IDGP section (was attempting to 
		     select records with SDD="")
		   . Replaced deprecated Db.nextKey()
		   . Removed error checks for indefined transaction code (will 
		     be checked in ^LNTRB)
		   . Performed some cleanup, including replacing FM section 
		     with .setAuditFlag(1)
	
	03/07/06 - KUMARB - CR 19957
		   Modified section PMRO, to use ln.pmtpi in the call of 
		   $$NP^UFINC in block "Recalculate maturity date" and also 
		   define NP as local to this block.
		   
	01/03/06 - SANTHUMS - CR 19710
		   Modified LNNOT section to use OLD.get() and NEW.get() to
		   avoid undefined error when Generate Acct Projected Act 
		   Report Flag is set.
	
	02/28/06 - KELLYP - CR 19791
		   Rewrote most of the PMRO section as it contained many logic
		   errors that were causing endless loops and UNDEFINED errors.  
		   Also modified LNNOT section to use Db.getRecord(,,1) instead 
		   of Class.new() when creating a DAYENDLNNOT record.  Also 
		   modified HSEQ section to use HSEQ instead of TSEQ.
	
	01/25/06 - SmithCD - CR 19343 (16890)
		   Made IDGP and UNPPRN section public and performed some 
		   other minor cleanup.

	11/28/05 - SATYANAS - 16994
		   To avoid undefined error AMT and P in the RB section.
		   Assigned the amt value of LNCYCINS,LNCYCDLD,LNCYCMSC AND LNCYCPTS
		   to AMT variable. 		   
	
	04/23/05 - JERUCHIMC - 14057
		   Initialize PC variable in section BSEQ.
	
	*/
	
	type public String CTL

	set CTL=CTL.extract(1,2)_"00".extract(2-CTL.length())_1_CTL.extract(4,99)

	do EXEC(.ln,.trn,.ttx)

	quit


EXEC(RecordLN ln, RecordTRN trn, RecordTTX ttx)

	type public Cache %CACHE()
	type public Boolean ER
	type public String CTL,LTC,OVR(,,),PSTR,STRC
	type public Number RFLAG,ZAMT

	type Number %ZAMT,BALCMP,CVCID,EPPEN,PPF,PVAR,PRNAMT
	
	// Customer view account should be considered for problem sub-loan account 
	// while processing the OVR().
	if ln.pcidstat,'ln.cvcid.isNull() set CVCID = ln.cvcid
	else  set CVCID = ln.cid

	// Advances to Reduce Undisbursed Flag
	set BALCMP=ln.bal 
	if ln.aruf set BALCMP=ln.bal-ln.udbal

	// Verify that remaining bills will not be left with prin > BALCMP
	set %ZAMT=ZAMT	

	// if trn.pcfl5 is defined - Payoff
	if 'trn.pcfl5,'ln.peba do {	
		// ln.peba is defined- prin pmt may exceed billed prin

		type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:ln.type")
		
		if CTL.extract(3),prodctl.fbp'=2 do {
			// Find outstanding principal amount in payment file

			type Number UNPPRN=$$UNPPRN(.ln)
			if UNPPRN,(BALCMP-%ZAMT)<UNPPRN set ZAMT=BALCMP-UNPPRN
			}
		}

	// Calculate possible Early Prin Penalty
	if trn.pcfl23 set EPPEN=$$PEN(.ln,.trn,.ttx) quit:ER

	// If negative balance flag is 0, then only take out principle amount
	// and send the remainder back in ZAMT.

	set RFLAG=RFLAG.get()  
	if RFLAG,'trn.pcfl5,BALCMP'>ZAMT set ZAMT=BALCMP

	if trn.pac.isNull(),('PSTR.piece($char(9),STRC+1).isNull()),(BALCMP'>ZAMT) set ZAMT=BALCMP

	set BALCMP=BALCMP-ZAMT
	set PRNAMT=ZAMT

	/* ln.revf - Revolving Account Flag
	   ln.aruf - Advances to Reduce Undisbursed Flag
	   ln.udbal - Unadvanced Balance
	   ln.idgp - Interest on Disburs Grace Period (Days)
	   ln.dist1nd - Distribution 1 Next Due
	*/
	if ln.revf,'CTL.extract(2) set ln.udbal=ln.udbal+ZAMT if ln.aruf do GL^LNPTSU(.ttx,ZAMT,5)
	else  do {
		set ln.bal=ln.bal-ZAMT
		
		#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
			if ln.segments do PAYBAL^LNSEG(.ln, .ttx, ZAMT, 0)
		#ENDIF
		
		do GL^LNPTSU(.ttx,ZAMT,2)
		}

	if BALCMP'>0,'trn.pcfl5 do LBF^LNPTSU(.ln,.BALCMP) quit:ER
	if ln.ppf=2,ln.dist1nd'>ln.schld set OVR(CVCID,"OVR","PPFDL")=""
	if 'ln.idgp do {
		/* ln.bal at this time is adjusted with transaction amount.
		   ln.balint - Adjusted Balance for Accrual Calculation
		   Stop Payments
		*/
		if ln.stp,((ln.bal+ZAMT)>ln.crlmt) set ln.balint=$S(ln.bal'>ln.crlmt:ln.bal,1:ln.crlmt)
		else  set ln.balint=ln.balint-ZAMT
		}
	if ln.idgp do IDGP(.ln,PRNAMT)
	// Collected Balance
	set ln.balcol=ln.balcol-ZAMT

	if 'ln.ppf do {
		// Prepayment Flag
		set PPF=ln.ppf
		if ln.rdt.isNull() set OVR(CVCID,"OVR","PPF")=""
		else  do {
			// ln.rdt - Return Date
			// ln.rnflg - Return Notification Flag
			if ln.rdt'=%EffectiveDate set OVR(CVCID,"OVR","RDTNVD")=""
			if 'ln.rnflg set OVR(CVCID,"OVR","RNFNVD")=""
			}
		}

	// Collected Balance
	set ln.balcol=ln.balcol-ZAMT

	if 'CTL.extract(3) do FBP^LNPTSU(.ln,-ZAMT)

	// Reset ln.habl2 (high balance between zero balances)
	if BALCMP<.01,(BALCMP+ZAMT>0) set ln.habl2=BALCMP

	// Update credit limit
	if CTL.extract(2) set ln.crlmt=ln.crlmt-ZAMT

	// Update principal only payment amount (if this is not a payoff)
	if CTL.extract(3),'trn.pcfl5 set ln.poamt=ln.poamt+ZAMT

	// Update total disbursement amount
	if CTL.extract(4) set ln.tdr=ln.tdr-ZAMT

	type RecordTRN trn1=%CACHE("TRN").getRecord("TRN","ETC=:LTC")
	
	if trn1.pcfl12 do {
		type String UTSO(),TSO

		set TSO=ttx.tso
		do OUT^UTSO(.UTSO(),.TSO)
		set UTSO("PVAR")=UTSO("PVAR").get()+ZAMT
		do IN^UTSO(.UTSO(),.TSO)		
		set ttx.tso=TSO

		// Principal Variance
		set ln.pvar=ln.pvar+ZAMT
 		}

	if BALCMP do {
		type Number %INTA
		
		do IRNC^LNPTS7(.ln,.trn1)

		// Interest adjustment per principal change
		do INTA^LNPTSU(.ttx,.ln,ZAMT)
		
		// Interest Adjustment
		set ln.inta=ln.inta-%INTA

		// ln.genprjrep - Generate Acct Projected Act Report Flag
		if ln.genprjrep=1 do LNNOT(ln.cid,4)

		// Check the value of ln.pmro, If 1 recalc ln.pmtpi, If 2 recalc ln.mdt
		// Calculate the balance as of ln.lbdd.
		if ln.pmro>0 do PMRO(.ln,.ttx)
		}

	do %HSEQ^LNPTSU(.ttx,"*#P#"_ZAMT)

	if CTL.extract(5) do UPDSCH(.ln,.ttx)

	set ZAMT=%ZAMT-ZAMT

	do FILE(.ln,PRNAMT,.ttx) 

	quit


BSEQ(RecordLN ln, Number UNPPRN)

	// Find principal amounts not included in ln.cupr or ln.unpr

	type public Boolean ER

	type String BIL0
	type Number I, PC
	
	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID=:ln.cid")
	set BIL0=$$ELEMENT^BILFUNCS(.lnbil0)
	set PC=""
	
	for I=1:1:20 quit:BIL0.piece($char(9),I).isNull()  do { quit:ER
		if BIL0.piece($char(9),I).piece("#",1)="P" set PC=I quit
		}

	if 'PC quit

	type DbSet ds=Db.selectDbSet("LNBIL1","CID=:ln.cid AND SCHSEQ NOT>:ln.schseq")
	while ds.next() do {
		type RecordLNBIL1 lnbil1=ds.getRecord("LNBIL1")
		set BIL0=$$GETELEMENT^BILFUNCS(PC,.lnbil1)	
		set UNPPRN=UNPPRN+BIL0.piece("#",4)
		}

	quit


FILE(RecordLN ln, Number PRNAMT, RecordTTX ttx)

	// Find fees associated with this transaction
	
	type public String LTC

	do FEEDUE^LNFEEU(.ln,.ttx,ln.cid,2,10001,%EffectiveDate,"",PRNAMT,"P",LTC)
	do FEEDUE^LNFEEU(.ln,.ttx,ln.cid,2,10001,%EffectiveDate,"",PRNAMT,"",LTC)

	// Interest on Partial Principal Repayments      
	// Apply Interest on Principal Repayment
	if ln.aipr do IPPR(.ln,.ttx)

	quit


public RB(RecordLN ln, RecordTTX ttx, RecordTRN trn)

	/*
	Rebate Insurance/Add-on
	
	Called by rebate transaction codes (Posting Action Control)
	*/

	type public String CTL,RM,TSO()
	type public Boolean ER
	type public Number CNT,ZAMT
	
	type Number AMT,CALTD,CNTR,IRLA,PDBY,PREREB,RB(,),REB,REBPDBY,TERM
	type String AOINO,FREQ,LCITEM,PAYEE,PLAN

	do OUT^UTSO(.TSO(),TSO)
	set AOINO=TSO("AOI").get()
	
	// No add-on type specified
	if AOINO.isNull() do Runtime.setErrMSG("LN",1891) quit

	/*
	  Only one of the following four LNCYC* tables is going to be loaded
	  and updated.  This is determined by the value of AOINO.
	*/

	type RecordLNCYCPTS lncycpts
	type RecordLNCYCDLD lncycdld
	type RecordLNCYCMSC lncycmsc
	type RecordLNCYCINS lncycins
	
	// Load LNCYC* table
	
	if AOINO.extract(1)="P" do { quit:ER.get()
		set LCITEM="PTS"
		set lncycpts=Db.getRecord("LNCYCPTS","TYP=:AOINO,CID=:ln.cid",1)

		// Invalid add-on type
		if lncycpts.getMode()=0 do Runtime.setErrMSG("LNCYCPTS",1264) quit	
		
		set CALTD=lncycpts.caltd
		set REB=lncycpts.reb
		set PAYEE=lncycpts.payee
		set PLAN=lncycpts.plan
		set PDBY=lncycpts.pdby
		set IRLA=""
		set TERM=lncycpts.term
		set CNTR=lncycpts.cntr
		set FREQ=lncycpts.freq
		set AMT=lncycpts.amt
		}
		
	if AOINO.extract(1)="D" do { quit:ER
		set LCITEM="DLD"
		set lncycdld=Db.getRecord("LNCYCDLD","TYP=:AOINO,CID=:ln.cid",1)

		// Invalid add-on type
		if lncycdld.getMode()=0 do Runtime.setErrMSG("LNCYCDLD",1264) quit	
		
		set CALTD=lncycdld.caltd
		set REB=lncycdld.reb
		set PAYEE=lncycdld.payee
		set PLAN=lncycdld.plan
		set PDBY=lncycdld.pdby
		set IRLA=""
		set TERM=lncycdld.term
		set CNTR=lncycdld.cntr
		set FREQ=lncycdld.freq
		set AMT=lncycdld.amt
		}
	if AOINO.extract(1)="M" do { quit:ER.get()
		set LCITEM="MSC"
		set lncycmsc=Db.getRecord("LNCYCMSC","TYP=:AOINO,CID=:ln.cid",1)

		// Invalid add-on type
		if lncycmsc.getMode()=0 do Runtime.setErrMSG("LNCYCMSC",1264) quit	
		
		set CALTD=lncycmsc.caltd
		set REB=lncycmsc.reb
		set PAYEE=lncycmsc.payee
		set PLAN=lncycmsc.plan
		set PDBY=lncycmsc.pdby
		set IRLA=""
		set TERM=lncycmsc.term
		set CNTR=lncycmsc.cntr
		set FREQ=lncycmsc.freq
		set AMT=lncycmsc.amt
		}
	
	if AOINO.extract(1)="I" do { quit:ER.get()
		set LCITEM="INS"
		set lncycins=Db.getRecord("LNCYCINS","TYP=:AOINO,CID=:ln.cid",1)
		// Invalid add-on type
		if lncycins.getMode()=0 do Runtime.setErrMSG("LNCYCINS",1264) quit	
		
		set CALTD=lncycins.caltd
		set REB=lncycins.reb
		set PAYEE=lncycins.payee
		set PLAN=lncycins.plan
		set PDBY=lncycins.pdby
		set IRLA=lncycins.irla
		set TERM=lncycins.term
		set CNTR=lncycins.cntr
		set FREQ=lncycins.freq
		set AMT=lncycins.amt
		}

	if REB,trn.pcfl5 do { quit
		set CTL=CTL.extract(1,2)_"00".extract(1,2-CTL.length())_1_CTL.extract(4,99)
		do EXEC(.ln,.trn,.ttx)
		}
	// Item ~p1 already rebated
	if REB do Runtime.setErrMSG("LN",1576,AOINO) quit

	// Paid By Code
	if PDBY.isNull() quit

	// Item ~p1 cannot be rebated to borrower
	type RecordSTBLIPDBY stblipdby=Db.getRecord("STBLIPDBY","KEY=:PDBY")		
	if 'stblipdby.rebate do Runtime.setErrMSG("STBLIPDBY",1577,AOINO) quit

	set (PREREB,CNT)=0

	do RBX^LNPO2(.ln,LCITEM,AOINO,AMT,CALTD,REB,PAYEE,PLAN,PDBY,IRLA,TERM,CNTR,FREQ) 

	// Error in rebate calculation
	if ER set RM=RM.get() set:RM.isNull() RM=$$^MSG("985") quit

	// Rebate amount is equal to zero
	if 'RB(ln.cid,AOINO).exists() do Runtime.setErrMSG("LN",2319) quit

	// Calculated rebate of $~p1 differs from amount entered
	if ZAMT-RB(ln.cid,AOINO) do Runtime.setErrMSG("LN",402,+RB(ln.cid,AOINO).roundCur(ln.crcd)) quit

	// Rebate amount is equal to zero
	if '+RB(ln.cid,AOINO) do Runtime.setErrMSG("LN",2319) quit

	// Save LNCYC* table

	if LCITEM="PTS" do {
		set lncycpts.caltd=CALTD+RB(ln.cid,AOINO)
		set lncycpts.reb=+RB(ln.cid,AOINO)
		set lncycpts.npda=0
		do lncycpts.bypassSave()
		}

	else  if LCITEM="DLD" do {
		set lncycdld.caltd=CALTD+RB(ln.cid,AOINO)
		set lncycdld.reb=+RB(ln.cid,AOINO)
		set lncycdld.npda=0
		do lncycdld.bypassSave()
		}

	else  if LCITEM="MSC" do {
		set lncycmsc.caltd=CALTD+RB(ln.cid,AOINO)
		set lncycmsc.reb=+RB(ln.cid,AOINO)
		set lncycmsc.npda=0
		do lncycmsc.bypassSave()
		}

	else  if LCITEM="INS" do {
		set lncycins.caltd=CALTD+RB(ln.cid,AOINO)
		set lncycins.reb=+RB(ln.cid,AOINO)
		set lncycins.npda=0
		do lncycins.bypassSave()
		}
	
	set CTL=CTL.extract(1,2)_"00".extract(1,2-CTL.length())_1_CTL.extract(4,99)

	do EXEC(.ln,.trn,.ttx)

	quit


public	UNPPRN(RecordLN ln)

	// Calculate billed/unpaid principal

	type Number UNPPRN=""

	// Scheduled Internal Bill Sequence Number	
	// Billing - Last Sequence Number

	if ln.bseq>ln.schseq do BSEQ(.ln,.UNPPRN)
	
	// ln.cupr - Current Principal	
	// ln.unpr - Uncollected Principal
	if ln.cupr+ln.unpr>0 set UNPPRN=UNPPRN+ln.cupr+ln.unpr

	quit UNPPRN


public CTO(RecordLN ln, RecordTTX ttx, RecordTRN trn)

	/*
	Commitment transfer out
	
	Called by Commitment transfer out transaction codes (Posting Action 
	Control)
	*/

	// Set CTL to update ln.crlmt and ln.tdr  

	type public String CTL

	set CTL="0101"_CTL.get().extract(5,99)

	do EXEC(.ln,.trn,.ttx)

	quit


public PMTSCH(RecordLN ln, RecordTRN trn, RecordTTX ttx)

	// Modify payment schedule

	type String CTL="00101" 

	do EXEC(.ln,.trn,.ttx)
	
	quit
	
	 
UPDSCH(RecordLN ln, RecordTTX ttx)

	type public Boolean ER
	type public String OVR(,,)
	type public Number CVCID,ZAMT

	type Number %PMT,DIFF,FPA,HSEQ,I,NPMT,PMT,REM,X
	type Date JD
	type String BIL0

	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID=:ln.cid")
	set BIL0=$$ELEMENT^BILFUNCS(.lnbil0)

	for I=1:1:20 quit:BIL0.piece($char(9),I).isNull()  do { quit:ER
		set X=BIL0.piece($char(9),I) quit
		if BIL0.piece($char(9),I).piece("#",1)'="P" quit

		// Find anticipated history sequence
		do HSEQ^LNPTSU(.ttx)
		set REM=ZAMT	
		// Distribution 1 Frequency	
		if ln.dist1fre'="*" quit
		// Last Bill - Loan Due Date Billed	
		set JD=ln.lbdd
		// Fixed Principal Amount
		set (NPMT,FPA)=ln.fpa

		type DbSet rs=Db.selectDbSet("LNPS1","CID=:ln.cid AND PDD>:JD")
		if rs.isEmpty() do { quit
			// Unable to complete payment schedule modifications
			if REM do Runtime.setErrMSG("LNPS1",2787)
			set OVR(CVCID,"OVR","PMTUPD")=""
			}

		while rs.next() do { if ('REM),PMT.get().isNull() quit
			type RecordLNPS1 lnps1=rs.getRecord("LNPS1")
                	if lnps1.fpc do {
   				set PMT=lnps1.fpc
				/*
				If no remainder, we're finished reducing the 
				payment schedule. Now we have to start the 
				current payment back up.
				*/
				
				if 'REM,PMT.isNull() quit
                        	if 'REM do {
                        		set %PMT=NPMT 
                        		set DIFF=0  

                        		do UPDSCH3(.ln)
					}
                                             
                        	// Skip if this prin pmt amount is already zero
                        	if PMT.isNull() set NPMT=PMT
                        	if PMT do {
                                	// Calculate the adjustment for this due date
                                	set DIFF=REM 
                                	set:REM>FPA DIFF=FPA 
                                	set:REM>NPMT DIFF=NPMT
                                	set %PMT=NPMT-DIFF
                                	set REM=REM-DIFF

                                	do UPDSCH3(.ln)
					}
				}
			}
       
		}
	
 	quit


UPDSCH3(RecordLN ln)

        // ~p1 pmt; Prin:~p2:~p3
        
        type public Date JD
        type public String SPR
        type public Number %PMT,HSEQ,PMT

        type RecordHIST hist=Class.new("RecordHIST")

        set hist.cid=ln.cid
        set hist.tseq=Db.nextVal("HIST","CID=:ln.cid")
        set hist.cid=ln.cid
        set hist.tjd=%SystemDate
        set hist.efd=%EffectiveDate
        set hist.tlo=%UserStation
        set hist.tcmt=ln.cid_JD.toString()_" pmt;"_" prin:"_PMT_%PMT_"|"_HSEQ
        set hist.cdt=%CurrentDate
        set hist.time=%CurrentTime
        set hist.uid=%UserID
        set hist.spr=SPR.get()
 
        do hist.bypassSave()

        quit


PEN(RecordLN ln, RecordTRN trn, RecordTTX ttx)

	// Calculate early principal payment penalty
	
	type public Number %ZAMT,CVCID,ZAMT
	type public Boolean ER
	type public String OVR(,,)

	type Number BLAMT,EPPEN,PPACP,PPAL,PPNOPL,PPNOPP
	type Boolean PPDPLF
	
	// Amount subject to penalty	
	set BLAMT=0
	// Penalty amount (returned)	
	set EPPEN=0

	// Unscheduled Principal Pmt Penalty Method must be defined
	if ln.uppen.isNull() quit 0
	
	// Maturity Date passed as of Effect Dt	
	if ln.mdt,(ln.mdt'>%SystemDate) quit 0

	// Number Payments Current Period	
	set PPNOPP=ln.ppnopp
	// Number Payments Life	
	set PPNOPL=ln.ppnopl
	// Prepayment Amount Curr Period	
	set PPACP=ln.ppacp
	// Prepayment Amount Life	
	set PPAL=ln.ppal
	// Use full principal amount	
	if ln.ppdpl.isNull() set BLAMT=ZAMT
	// Calculate BLAMT
	else  do PPDPL(.ln) if 'BLAMT!(ER) quit 0
	
	type RecordUTBLLNPPN lnppn = Db.getRecord("UTBLLNPPN", "METHOD = :ln.uppen")
	
	set EPPEN=$$CALCPEN^LNPO2A(.ln, ln.uppen, BLAMT, lnppn.net)
	
	if 'EPPEN!(ER) quit 0	
	
	// Generate an override message with the penalty amount
	if 'OVR(CVCID,"OVR","INVSCH").exists() set OVR(CVCID,"OVR","EPPEN")=EPPEN

	type Boolean DIR,TRB
	type Number TAMT

	// Reverse direction if CBL
	if trn.itc.extract(1)-ln.trb set DIR=-1
	else  set DIR=1
	
	set TAMT=EPPEN*DIR
		
	// Pass Through Suspense
	do GL^LNPTSU(.ttx, TAMT, 7)
	
	set %ZAMT=%ZAMT-EPPEN
	set ZAMT=ZAMT-EPPEN
	
	do PENMSC(.ln, .ttx, lnppn.feetyp) quit:ER 0
	
	do PPFILE(.ln, .trn)
	
	quit EPPEN
	
	
PPDPL(RecordLN ln)

	// Penalty Determination Plan

	// ZAMT is the remaining amount after all outstanding bills are 
	// satisfied	
	type public Number BLAMT,ZAMT
	type public Boolean PIFLG,PPDPLF
	
	type Date SDATE
	type Number P,TOBA
	
	if '%EffectiveDate set %EffectiveDate=%SystemDate
	
	// Prepayment Penalty Determination Plan
	type RecordUTBLPPDPL utblppdpl=Db.getRecord("UTBLPPDPL","PLAN=:ln.ppdpl")

	// Prepmt Cur Determ Start Date
	set SDATE=ln.ppld
	
	// Check if prior to start date or after grace period. If so penalty
	// is always on full principal amount
	if SDATE,(%EffectiveDate<SDATE) set BLAMT=ZAMT quit
	if SDATE,%EffectiveDate>(SDATE+utblppdpl.ppgrc-1) set BLAMT=ZAMT quit
	
	// Updated prepayment amounts
	set PPDPLF=1
	
	// Calculate the scheduled P&I amounts being satisfied (TOBA)

	// Total outstanding bill amount
	set TOBA=0
	
	type DbSet ds=Db.selectDbSet("HISTSB","CID=:ln.cid AND SLN=:SEQ")	
	if ds.isEmpty() quit
	   
	while ds.next() do {
		type RecordHISTSB histsb=ds.getRecord("HISTSB")
		
		if (histsb.pe01ea="P")!(histsb.pe01ea="I") set TOBA=TOBA+histsb.pe01amt
		if (histsb.pe02ea="P")!(histsb.pe02ea="I") set TOBA=TOBA+histsb.pe02amt
		if (histsb.pe03ea="P")!(histsb.pe03ea="I") set TOBA=TOBA+histsb.pe03amt
		if (histsb.pe04ea="P")!(histsb.pe04ea="I") set TOBA=TOBA+histsb.pe04amt
		if (histsb.pe05ea="P")!(histsb.pe05ea="I") set TOBA=TOBA+histsb.pe05amt
		}
	
	// Check P&I Flag, process only if set to 1 by a preprocessor on the
	// transaction code
	if PIFLG.get()=1 do { quit
		type Number PIMAX,PIAMT
		// If no outstanding bills, penalty is on full principal amount
		if TOBA=0 set BLAMT=ZAMT quit
		// Prepayment Max Percentage P&I
		set PIMAX=utblppdpl.ppmppi
		if PIMAX.isNull() quit
	
		type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID=ln.schseq,SCHSEQ=:ln.schseq",1)
		if 'lnbil1.getMode() quit
		set PIAMT=lnbil1.cpib
	
		/* 
		BLAMT is the amount subject to penalty. It is used by ^LNPO2A
		to calculate the penalty. Here it will equal the prepayment
		amount minus the percentage of the P&I amount allowed.
		*/
		set BLAMT=ZAMT-(PIAMT*PIMAX/100)
		if BLAMT<0 set BLAMT=0		
		// Reset PIFLG
		set PIFLG=0
		}
	
	do LIMITS(.ln,.utblppdpl)

	quit

	
LIMITS(RecordLN ln, RecordUTBLPPDPL utblppdpl)

	// Period and Life Limits
	
	/*
	This section checks to see if the prepayment amount violates period
	or life limits.
	*/
	
	type public Number BLAMT,PPNOPP,PPNOPL,TAMT,TOBA

	// Max amount per period
	if 'utblppdpl.ppmdp.isNull() do PENALTY(.ln,.BLAMT,utblppdpl.ppmdp,0,0)
	
	// Max amount Life
	if 'utblppdpl.ppmdl.isNull() do PENALTY(.ln,.BLAMT,utblppdpl.ppmdl,0,1)

	// Pct Orig Balance Per Period
	if 'utblppdpl.pppobp.isNull() do PENALTY(.ln,.BLAMT,utblppdpl.pppobp,1,0)

	// Pct Orig Balance Life
	if 'utblppdpl.pppobl.isNull() do PENALTY(.ln,.BLAMT,utblppdpl.pppobl,1,1)

	// Pct Renewal Balance Per Period
	if 'utblppdpl.ppprbp.isNull() do PENALTY(.ln,.BLAMT,utblppdpl.ppprbp,2,0)
	
	// Pct Renewal Balance Life
	if 'utblppdpl.ppprbl.isNull() do PENALTY(.ln,.BLAMT,utblppdpl.ppprbl,2,1)
	
	// Number of Payments Per Period
	if 'utblppdpl.pppmtp.isNull(),PPNOPP+1>utblppdpl.pppmtp do {
		type Number PMTP
		// Current prepayment amount
		set PMTP=TAMT-TOBA
		if PMTP>BLAMT set BLAMT=PMTP
		}
	
	// Number of Payments Life
	if 'utblppdpl.pppmtl.isNull(),PPNOPL+1>utblppdpl.pppmtl do {
		type Number PMTL
		// Current prepayment amount
		set PMTL=TAMT-TOBA
		if PMTL>BLAMT set BLAMT=PMTL
		}

	quit

	
PENALTY(RecordLN ln, Number BLAMT, Number PENAMT, Number METHOD, Boolean LIFE)

	/*
	   Calculate prepayment penalty

	   Calculates the prepayment penalty according to METHOD for
	   period or life.

	   KEYWORDS: Prepayment, Penalty

	   ARGUMENTS:
	   . BLAMT  Bill amount			/TYP=T/REQ/MECH=VAL
	     Amount subject to penalty

	   . PENAMT Current Penalty amount	/TYP=T/REQ/MECH=VAL
	     (period or life)

	   . METHOD Calculation Method
	     0 - Maximum amount
	     1 - Percentage of original balance
	     2 - Percentage of renemal balance

	   . LIFE  Life flag			/TYP=L/REQ/MECH=VAL
	     0 - Calculate for period
	     1 - Calculate for life
		
	   INPUTS (from account):
	   . PPACP  Prepayment Amt Curr Per	/TYP=$
	   . PPAL  Prepayment Amt Life		/TYP=$

	   RETURNS:
	   . BLAMT Amount subject to penalty	/TYP=$

	   EXAMPLE:
		   do PENALTY(.ln,.BLAMT,PENAMT,2,1)

	*/
	
	type public Number PPACP,PPAL,TAMT,TOBA
	
	type Number CURPPA,NEWPPA,PEN,TOTPPA
	
	// Percentage of original balance
	if METHOD=1 set PENAMT=PENAMT*ln.amtreq/100
	
	// Percentage of renemal balance
	if METHOD=2 set PENAMT=PENAMT*ln.lrpb/100
	
	// Determine current prepayment amount
	if LIFE.get() set CURPPA=PPAL
	else  set CURPPA=PPACP	
	
	// New prepayment amount	
	set NEWPPA=TAMT-TOBA
	
	// Total prepayment amount
	set TOTPPA=CURPPA+NEWPPA

	// Determine amount to calculate penalty from
	set PEN=0
	if CURPPA>PENAMT set PEN=NEWPPA
	else  if TOTPPA>PENAMT set PEN=TOTPPA-PENAMT	

	// Use highest amount
	if PEN>BLAMT set BLAMT=PEN
	
	quit


PENMSC(RecordLN ln, RecordTTX ttx, String FEETYPE)

	// Set up transactions for misc payoff charges
		
	type public Cache %CACHE()
	type public Boolean ER
	type public Number EPPEN
		
	type Number TAMT
	type String TC,TSO,DATA

	set TAMT=EPPEN
	if FEETYPE.isNull() set FEETYPE="EPPEN"
	set TSO="LNFEEIN#"_FEETYPE_":"_TAMT	
		
	// if trn.pcld5 is defined - Payoff
	// ln.peba is defined- prin pmt may exceed billed prin
	type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:ln.type")
	
	type RecordUTBLGLSC utblglsc=%CACHE("UTBLGLSC").getRecord("UTBLGLSC","GLSC=:ln.glsc")
	
	// Assess misc fee
	// DR Prin-Only Prepmt Penalty 
	do POST^LNTRB(.ttx,ln.cid,prodctl.drtrppp,TAMT,%EffectiveDate,%UserStation,TSO,,ln.crcd) quit:ER
	
	// Credit to penalty income
	// Loan G/L # (Early Pmt Pen Inc)
	do POST^LNTRB(.ttx,utblglsc.lglp,"MCR",TAMT,%EffectiveDate,%UserStation,TSO,,ln.crcd) quit:ER
	
	// Pay fee.  CR Miscellaneous Income Tran
	do POST^LNTRB(.ttx,ln.cid,prodctl.crtrmi,TAMT,%EffectiveDate,%UserStation,TSO,,ln.crcd) quit:ER
	
	// Offset to pay fee to pass through suspense
	// Loan G/L # (Pass through Susp)
	do POST^LNTRB(.ttx,utblglsc.lgl6,"MDR",TAMT,%EffectiveDate,%UserStation,TSO,,ln.crcd) quit:ER
	
	quit


PPFILE(RecordLN ln, RecordTRN trn)

	type public Number PPACP,PPAL,PPNOPP,PPNOPL,ZAMT
	type public Boolean PPDPLF

	// File prepayment penalty data
	
	// Update Prepayment Amounts
	// trn.pcfl5 - Close Account And Prohibit Further Processing
	if 'trn.pcfl5,PPDPLF.get() do {
		set PPNOPP=PPNOPP+1
		set PPNOPL=PPNOPL+1
		set PPACP=PPACP+ZAMT
		set PPAL=PPAL+ZAMT
		}
	
	// Number Payments Current Period	
	set ln.ppnopp=PPNOPP
	// Number Payments Life	
	set ln.ppnopl=PPNOPL
	// Prepayment Amount Curr Period	
	set ln.ppacp=PPACP
	// Prepayment Amount Life
	set ln.ppal=PPAL

	quit


IPPR(RecordLN ln, RecordTTX ttx)

	// Interest on Partial Principal Repayments (Auto Loan Payment)
	
	type public Cache %CACHE()
	type public Number TAMT
	
	type Number COLINT,EXCAMT,INTD
	type Date FROMDT,TODT
	type String TSO,UAVB(),WIRN()
			
	// Automatic Loan Payment Account not defined
	if ln.auptcid.isNull() quit

	set (FROMDT,TODT)=""

	// Include Payment Date
	if ln.ipd do {
		// Include Payment Date
		// Interest (1/1 -1/15)   15 days
		// Create complete WIRN()
		do INIT^UAVB(.ln,ln.cid,ln.schld,%EffectiveDate,1)

		for  set FROMDT=WIRN(FROMDT).order() quit:FROMDT.isNull()  do {
			type Number IRN 

			set IRN=WIRN(FROMDT).piece("|",1)
			set TODT=WIRN(FROMDT).order()
			if TODT.isNull() set TODT=%EffectiveDate+1

			set COLINT=COLINT.get()+$$^UIC(TAMT,FROMDT,TODT-1,ln.iacm,IRN,0,ln.dist1af,ln.dist1fre,ln.icpf,ln.schnd,ln.schld)
			}

		set COLINT=COLINT.roundCur(ln.crcd)

		// Interest (1/14 -1/15) 1 day
		set INTD=$$^UIC(TAMT,%EffectiveDate,%EffectiveDate,ln.iacm,ln.irn,0,ln.dist1af,ln.dist1fre,ln.icpf,ln.schnd,ln.schld)
		set INTD=INTD.roundCur(ln.crcd)
		}
	else  do {
		// Exclude Payment Date
		// Interest (1/1 - 1/14) 14 days
		if ln.schld'>(%EffectiveDate-1) do {
			// Create complete WIRN() array
			do INIT^UAVB(.ln,ln.cid,ln.schld,%EffectiveDate-1,1)
			for  set FROMDT=WIRN(FROMDT).order() quit:FROMDT.isNull()  do {
				type Number IRN 

				set IRN=WIRN(FROMDT).piece("|",1)
				set TODT=WIRN(FROMDT).order()
				if TODT.isNull() set TODT=%EffectiveDate

				set COLINT=COLINT.get()+$$^UIC(TAMT,FROMDT,TODT-1,ln.iacm,IRN,0,ln.dist1af,ln.dist1fre,ln.icpf,ln.schnd,ln.schld)
				}
			set COLINT=COLINT.roundCur(ln.crcd)
			}
		else  set COLINT=0
		set INTD=0
		}

	if 'COLINT,'INTD quit

	// Build Transactions

	type RecordPRODCTL prodctll=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:ln.type")

	/*
	1. Pmt Interest Only
	Interest due on principal repayment (CR Interest Tran Code to loan 
	account) to loan account
	*/
	do POST^LNTRB(.ttx,ln.cid,prodctll.crtrin,COLINT,%EffectiveDate,%UserStation,,$$^MSG(3143),ln.crcd)

	type RecordDEP dep=Db.getRecord("DEP","CID=:ln.auptcid")

	type RecordPRODCTL prodctld=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:dep.type")
	
	if ln.crcd'=dep.crcd do {
		do EXC^CRCDUTL(ln.crcd,dep.crcd,COLINT,1,2,00,,%EffectiveDate)
		set COLINT=EXCAMT
		set COLINT=COLINT.roundCur(dep.crcd)
		}

	set TSO=$$FIELDIN^UTSO("","FCID",ln.cid)

	/*
	2. Wash Account Withdrawal
	   Interest due on principal repayment (DR General Purpose Tran Code) 
	   to auto loan payment deposit account
	*/
	do POST^LNTRB(.ttx,ln.auptcid,prodctld.drtrgp,COLINT,%EffectiveDate,%UserStation,TSO,$$^MSG(3143),dep.crcd)

	// Interest for Payment Day
	if INTD=0 quit

	/*
	3. Increase Interest Accrual
	   Include payment day interest adjustment (DR Adj Accrued Int/Div 
	   Tran Code) to loan account
	*/
	do POST^LNTRB(.ttx,ln.cid,prodctll.dradin,INTD,,%UserStation,,$$^MSG(3142),ln.crcd)

	type RecordUTBLGLSC utblglc=%CACHE("UTBLGLSC").getRecord("UTBLGLSC","GLSC=:ln.glsc")

	/*
	4. Miscellaneous Credit (MCR)
	   Include payment day interest adjustment (MCR) to G/L account
	*/
	do POST^LNTRB(.ttx,utblglc.lgli,"MCR",INTD,,%UserStation,,$$^MSG(3142),ln.crcd)

	quit


public IDGP(RecordLN ln, Number PRNAMT)

	// Repay disbursement records and adjust ln.balint
	
	type Number AMT,REMAIN,REPAY
	
	set REPAY=PRNAMT

	//notice that no columns are listed for retrieval
	type DbSet rs=Db.selectDbSet("LNDS1","CID=:CID")
	while rs.next() do { quit:'REPAY
		type RecordLNDS1 lnds1=rs.getRecord("LNDS1")
		set REMAIN=lnds1.sda-lnds1.repymt
		if REMAIN>REPAY set AMT=REPAY
		else  set AMT=REMAIN
		set lnds1.repymt=lnds1.repymt+AMT
		if lnds1.expdt<%SystemDate set ln.balint=ln.balint-AMT
		set REPAY=REPAY-AMT
		do lnds1.bypassSave()
		}

	quit


PMRO(RecordLN ln, RecordTTX ttx)

	// Payment/Maturity Recalculation Option

	type public Boolean ER
	type public Number OIACM

	type Number NWBALCMP,OLDPMT,PMTPI
	
	set NWBALCMP=$$NWBALCMP(.ln)

	// Original Principal and Interest Payment
	set OLDPMT=ln.pmtpi

	// Recalculate Principal and Interest Payment
	if ln.pmro=1 do {  quit:ER
		type Date JD
		type Number NP

		set JD=ln.lbdd

		for NP=0:1 quit:JD'<ln.mdt  set JD=JD.nextFreqDate(ln.dist1fre) quit:(JD.isNull()!ER)
		quit:ER
		if NP do {
			if NP>ln.ambas set NP=ln.ambas
			set OIACM=OIACM.get()
			if ln.idp set PMTPI=$$UPI^UFINC(NWBALCMP,ln.irn,NP,,%SystemDate,ln.iacm,ln.dist1fre,OIACM,ln.dist1af,ln.dist1nd,ln.acr) if 1
			else  set PMTPI=$$UPI^UFINC(NWBALCMP,ln.irn,NP,,ln.amodt,ln.iacm,ln.dist1fre,OIACM,ln.dist1af,ln.dist1nd,ln.inta)
			set PMTPI=PMTPI.roundCur(ln.crcd) quit:ER

			// File PMTPI change to account history
			do ln.setAuditFlag(1)

			// Principal and Interest Payment
			set ln.pmtpi=PMTPI
			
			do ln.save()

			do LNNOT(ln.cid,2,OLDPMT,PMTPI)
			}
		}

	// Recalculate maturity date
	else  if ln.pmro=2 do {
		type Date NMDT
		type Number I, NP
		
		// UFINC will use standard formula to compute number of payments
		set NP=$$NP^UFINC(NWBALCMP,ln.irn,ln.pmtpi,"",ln.dist1af)
		set NP=NP.roundDec(0,"+")

		// Calculate ln.mdt - Account Maturity Date
		set NMDT=ln.lbdd
		for I=1:1:NP set NMDT=NMDT.nextFreqDate(ln.dist1fre) quit:ER
		if ln.mdt'=NMDT do {
			do ln.setAuditFlag(1)
			// Account Maturity Date			
			set ln.mdt=NMDT
			do ln.save()
			}
		}

	quit


NWBALCMP(RecordLN ln)

	// Calculate new balance to use for maturity date or P&I^
	
	type public Number BALCMP
	
	type Date CUVAR2
	type Number CPID,INT,NWBALCMP,PIDUE,PRIN

	set CUVAR2=%SystemDate

	if 'ln.idp do { quit NWBALCMP
		set NWBALCMP=BALCMP
		if ln.cupr'<0 set NWBALCMP=BALCMP-ln.cupr-ln.unpr
		else  set NWBALCMP=BALCMP
		}

	// Return loan balance after ln.lbdd is satisfied
	set PIDUE=0

	type DbSet ds=Db.selectDbSet("LNBIL1","CID=:ln.cid AND SCHSEQ NOT>:ln.schseq")
	while ds.next() do {
		type RecordLNBIL1 lnbil1=ds.getRecord("LNBIL1")
		set PIDUE=lnbil1.cpid+PIDUE
		}

	// Calculate current balance after delq amounts are paid
	set INT=ln.acr-PIDUE
	if INT<0 set INT=ln.acr
	set INT=INT.roundCur(ln.crcd)
	set PRIN=PIDUE-INT if PRIN<0 set PRIN=0
	set NWBALCMP=BALCMP-PRIN

	// Project interest
	if ln.lbdd>CUVAR2 do {
		type Number ANTINT
		set ANTINT=$$^UIC(NWBALCMP,%SystemDate,ln.lbdd-1,ln.iacm,ln.irn,0,ln.dist1af,ln.dist1fre,ln.icpf,ln.schnd,ln.schld)
		set ANTINT=ANTINT.roundCur(ln.crcd)
		set NWBALCMP=NWBALCMP-(ln.pmtpi-(ln.acr-INT+ANTINT))
		}

	quit NWBALCMP


LNNOT( Number CID,		// Account Number
       Number ID,		// Identifier
       Number OLD,		// Old Principle payment		/NOREQ
       Number NEW)		// New Principle payment		/NOREQ

	// The function is used to insert an entry into DAYENDLNNOT

	type RecordDAYENDLNNOT delnnot=Db.getRecord("DAYENDLNNOT","DT=:%SystemDate,CID=:CID,ID=:ID",1)

	set delnnot.oldpmt=OLD.get()
	set delnnot.newpmt=NEW.get()

	do delnnot.bypassSave()
	
	quit
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60865^9358^Balasubramonian Sankar^30862"	// Signature - LTD^TIME^USER^SIZE
