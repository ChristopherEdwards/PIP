STFUTL	
	//Public;Host Store and Forward Utilities
	/*
	  ;Copyright(c)2001 Sanchez Computer Associates, Inc.  All Rights Reserved - 09/21/01 11:23:49 - JOYNER
	   ORIG: JOYNER - 01/12/00
	   DESC: Host Store and Forward Utilities

	   KEYWORDS: 24x7,SERVER

	   LIBRARY:
	   . STFHNDL - Replay previous messages and play and record new message.
	   . STFREC  - Record new message into STF* files.
	   . FMTTSSP - Format TSSP service class message
	   . FMTMSQL - Format MSQL service class message

	  ---- Revision History ------------------------------------------------
	   05/30/05 - CARROLLJ - CR 14189
	  	      Added incremental rollback in STFHNDL section and did 
	  	      conversion cleanup.

	   01/29/04 - CARROLLJ - CR7997
		      Corrected parameter mismatch errors.

	   10/21/02 - Spier 51089

		      Corrected PSL syntax errors reported by new compiler
	
	   03/07/02 - SIVCHUKA - 43583
	              Converted to PSL.
		      Remove pre-2001 revision history.
                      Remove sections UPDACN, ZT and ZTEXT

	   09/20/01 - JOYNER - 47575
	        Modified section STFREC. The variable %TOKEN is
	        no longer used by STFMON. There was a problem
	        whenever %TOKEN would contain a "|" character.

	  ----------------------------------------------------------------------

	*/
	quit
	//----------------------------------------------------------------------
STFHNDL(RecordTTX ttx(),%STFHOST,vzsrvcls,sql,par,cid,notspv)	//Public;Proc 24x7 Msg
	//----------------------------------------------------------------------
	/*
	   STFHNDL will handle tssp and msql request in a memo post fashion.
	   The technique used is to start a tp fence, replay previous messages,
	   and process the new message. Finally a trollback is issued to undo
	   any changes to the database. If the replay and process of the 
	   incomming message is successful or the message is a store and forward
	   message then STFREC is call to store the message in the Host Store 
	   and Forward file.

	   For TSSP the array of ttx() objects is passed implicitly and the effected
	   accounts are derived from ttx() and the cid() parameter.

	   For MSQL the affected accounts are derived from the cid()
	   parameter.

	   ARGUMENTS:
	   . ttx()     Array of ttx() objects	/REQ
	   . %STFHOST  24x7 status		/NOREQ
	   . vzsrvcls  Service class		/REQ
	   . sql       SQL Statement		/NOREQ	
	   	       (Required for srvcls=5)
	   . par       SQL parameters		/NOREQ
	   . cid    Account(s)affected by this	/NOREQ	
	   	      message. Not required for TSSP.
	   . notspv    Donot Create a TSPV() array /NOREQ

	   INPUTS:
	   . vzrec     Service Class Message	/REQ

	   RETURNS: Service Class 1
	   . ER     Error Status		/TYP=T
	   . RM     Error Message		/TYP=T
	   . RJ()     Rejected Trans Array
	   . SPV()     Override Failures
	   . OM()     Output Array from TRNDRV

	   RETURNS: Service Class 5
	   . ER     Error Status		/TYP=T
	   . RM     Error Message		/TYP=T
	   . sqlsta    SQL status		/TYP=N
	   . sqldta    SQL response		/TYP=T
	  ----------------------------------------------------------------------
	  Passed parameters is RecordTTX ttx(),%STFHOST,vzsrvcls,sql,par,cid,notspv
	  ----------------------------------------------------------------------
	*/
	// Error trap for normal functions
	catch vError {		
		new ET
		set ET=vError.type
		//set ET=$$ETLOC^%ZT
		do ZE^UTLERR         
		}

	new seq,%STFPLAY
	kill OM

	if $G(TPD)<%SystemDate new TPD set TPD=%SystemDate	// Teller Posting Date

	if '$G(%STFHOST) set ER=1 set RM=$$^MSG("2212") quit	// Host STF not active
	new %STFHOST
	set %STFHOST=0 set ER=0 set RM=""

	set vzstfflg=$G(vzstfflg)
	if vzstfflg="" new vzstfflg set vzstfflg=+$G(stfflg)

	set %STFPLAY=0

	kill RM set ER=0 set RM=""

	do Runtime.start("CS",,saveptr)
	
	if vzsrvcls=1 do hndltssp(.ttx())
	if vzsrvcls=5 do hndlmsql

	do Runtime.rollback(saveptr)
	
	if ER,'vzstfflg quit

	// Record Transactions in STFHOST
	do STFREC(vzsrvcls,$G(vzrec),.ttx(),$G(sql),.par,.cid)

	quit

	//----------------------------------------------------------------------
hndltssp(RecordTTX ttx())	//Private; Handle playing a new array of ttx() objects
	//----------------------------------------------------------------------
	/*
	   INPUTS:
	     . ttx()	Array of ttx() objects  /REQ
	   OUTPUTS:
	     . ttx()	Array of ttx() objects
	     . RJ()	Rejected Trans Array
	     . SPV()	Override Failures
	     . OM()	Output Array from TRNDRV
	  ----------------------------------------------------------------------
	*/
	new mode,par,REJMET,x
	kill RJ,OM	
	set REJMET=1	// Reject entire screen if error.

	// Search ttx for ec/rev of STF sequences
	if $$ecrev(.ttx()) set STFECREV=1 quit

	// Establish correct value for CRT
	set x=$G(CRT) new CRT set CRT=x
	if CRT="" set CRT=0
	if CRT,$G(vzstfflg)=2 set CRT=2
	if CRT,$G(stfflg)=2 set CRT=2

	// Setup supervisory override
	if '$G(notspv) new TSPV set TSPV("*")=%UserID_%_%UserClass

	// CALL TRNDRV TO PROCESS CURRENT ttx().
	// process only
	set mode=$S(vzstfflg:2,1:1)
	do TRNSET^TRNDRV(.ttx(),$G(TPD),$G(BRCD),mode,,.RJ(),.SPV(),.OVR(),.OM()) quit:ER

	// Transactions rejected with violations: ~p1
	if $D(RJ)>1 set ER=1 set RM=$$^MSG(7848) quit

	/* Since only the primary transactions are saved into STFHOST
	   recompute the ending balance of each primary to show the
	   result of the primary and all applicable 2ndaries. It doesn't
	   matter that the before balance plus the tran does not equal
	   the end balance. Since it now shows the end bal of the last
	   2ndary.
	   Eaxmple:

	   Original picture:
	   BAL=$500
	   ttx(1)      CID=1 ETC=SW AMT=700 ENDBAL=$-200
	   ttx(1.001)  CID=2 ETC=SD AMT=300 ENDBAL=$100 (overdraft)
	   BAL=$100

	   New picture stored in STFHOST
	   BAL=$500
	   ttx(1)      CID=1 ETC=SW AMT=700 ENDBAL=$100
	   BAL=$100
	*/

	do {
		new i,tr,x,TRC,TNSEQ
		// TRC-Client transaction #

		set i=""
		for  set i=$O(ttx(i)) quit:i=""  do {
			set ttx(i).cdt=+%CurrentDate
			set ttx(i).tim=%CurrentTime
			set ttx(i).brcde=BRCD
			set ttx(i).uidt=%UserID

			if i#1  do {
				new ITC
				set ITC=ttx(i).itc
				if i*1000#1=0  do ITC^TRNDRV(ITC,7,2)	// 2ndary
				else  do ITC^TRNDRV(ITC,7,1)
				}

			}
		for  set i=$O(ttx(i)) quit:i=""  if i#1=0  do {
			set (TRC,TNSEQ)="" 
			set OM(i)=$$OM^TRNUTL(ttx(i))	// Construct an output message for client processes.
							
			}
		}

	if '$D(vzrec) set vzrec=$$FMTTSSP(.ttx(),$G(SPV),$G(BRCD),$G(TPD))

	quit

	//----------------------------------------------------------------------
hndlmsql	//Private; Handle playing a new msql message
	//----------------------------------------------------------------------
	//   . sqlsta    SQL status   /TYP=N
	//   . sqldta    SQL response  /TYP=T

	set ER=$$^SQL($G(sql),.par,.sqlsta,.sqldta)
	if ER quit
	if '$D(vzrec) set vzrec=$$FMTMSQL(sql,.par)
	quit


	//----------------------------------------------------------------------
ecrev(RecordTTX ttx())	//Private; Identify if TTX() contains any STF  EC or REV trans
	//----------------------------------------------------------------------
	new i,hit
	set hit=0 set i=""
	for  set i=$O(ttx(i)) quit:i=""  do { quit:hit
		new utso,tso,key,seq,stfseq,trseq		
		if ttx(i).itc6+ttx(i).itc12=0 quit	// identify ec/rev
		set key=$S(ttx(i).itc6:"EC",1:"REV")
		do OUT^UTSO(.utso,ttx(i).tso)
		if '$D(utso(key)) quit
		set seq=utso(key) set utso(key)=""		
		if $E(seq,1,3)'="STF" quit		// Not STFHOST ref, quit
		set hit=1
		}
	quit hit

	//----------------------------------------------------------------------
xecrev(RecordTTX ttx())	//Private; Xlate any REV=STFx-y entries
	//----------------------------------------------------------------------
	new i,hit,SEQ,ec
	set i="" set ec=0
	for  set i=$O(ttx(i)) quit:i=""  do {  quit:ec
		new CID,utso,tso,x,key,SEQ,STFSEQ,TRSEQ,done	
		if ttx(i).itc6+ttx(i).itc12=0 quit	// identify error correct/reversal
		set key=$S(ttx(i).itc6:"EC",1:"REV")
		do OUT^UTSO(.utso,ttx(i).tso)
		if '$D(utso(key)) quit
		set SEQ=utso(key) 
		set utso(key)=""		
		if $E(SEQ,1,3)'="STF" quit	// Not STFHOST ref, quit
		do IN^UTSO(.utso,.tso)		
		set ttx(i).tso=tso		// remove STF identifer
		set x=$E(SEQ,4,99)
		set STFSEQ=$P(x,"-",1) 
		set TRSEQ=$P(x,"-",2)
		if key="EC" set ec=1 set trseq=1
		if STFSEQ=""!(TRSEQ="") quit		
		if TRSEQ#1 quit			// No ec/rev of 2nd
		set SEQ=TRSEQ-.0001 set done=0
					
		type ResultSet rs
		set rs=Db.select("TRSEQ","STFHOST","STFSEQ=:STFSEQ AND TRSEQ>:SEQ")		
		if rs.isEmpty() quit		   
		while rs.next() do { quit:done
			set SEQ=getCol(1)
			if key="REV",(SEQ\1)'=TRSEQ set done=1 quit
			new AMT,CID
			if 'Db.isDefined("STFHOST","STFSEQ,SEQ") quit
			type RecordSTFHOST  stfhost=Db.getRecord("STFHOST","STFSEQ,SEQ")
			set CID=stfhost.cid if 'CID quit
			set AMT=stfhost.trnet if 'AMT quit
			type RecordACN  acn=Db.getRecord("ACN","CID")
			if 'acn.cid  quit
			set acn.stfnet=acn.stfnet-AMT
			do acn.bypassSave()
			}
		}
	quit

	//----------------------------------------------------------------------
STFREC(vzsrvcls,vzrec,RecordTTX ttx(),expr,par,cid)	//Public; Rec msg in [STFHOST]
	//----------------------------------------------------------------------
	/*
	   Record msg in [STFHOST]. This Will be used by STFMON to
	   process records.

	   INPUTS:
	     . vzsrvcls Service class   /REQ
	     . vzrec Service class msg  /REQ
	     . ttx() Array of ttx() objects   /NOREQ
	    Required if srvcls=1
	     . expr SQL statement   /NOREQ
	     . par SQL parameters   /NOREQ
	     . cid Related accounts  /NOREQ

	     . acctlst Comma Sep account list /NOREQ
	     . TJD Transaction Date  /REQ
	     . TLO Transaction Location  /NOREQ
	     . %UID User ID    /REQ
	     . %UCLS User Class   /REQ
	     . context Context data   /NOREQ
	     . vzfaps Fap information   /NOREQ
	    service class faps
	     . vzmssgid Client specified message id /NOREQ
	  ----------------------------------------------------------------------
	*/
	// Error trap for normal functions
	catch vError {		
		new ET
		set ET=vError.type
		//set ET=$$ETLOC^%ZT
		do ZE^UTLERR
		}

	new MSGSEQ,seq,trs,segm,i,var,acctlst,x
	set ER=0 set RM=""

	if '$D(vzsrvcls) new vzsrvcls set vzsrvcls=$G(vz1)
	if vzsrvcls="" set ET="STF_INVLDCLS" do ^UTLERR quit

	// Message ~p1 not found
	if $G(vzrec)="" do { if ER!($G(vzrec)="") set ER=1 set RM=$$^MSG(1721) quit
		if vzsrvcls=1 set vzrec=$$FMTTSSP(.ttx(),$G(SPV),$G(BRCD),$G(TPD)) quit
		if vzsrvcls=5 set vzrec=$$FMTMSQL(expr,.par) quit
		}

	do Runtime.start(BA,,saveptr)

	type RecordSTFHOST1 stf1=Db.getRecord("STFHOST1","STARKEY='*'",1)
	set MSGSEQ=stf1.last+1
	set stf1.last=MSGSEQ
	do stf1.save()

	// Each service class section is responsible for establishing
	// or verifying "acctlst"

	if vzsrvcls=1 do rectssp(MSGSEQ,.acctlst,.ttx()) // Passed parameters not declered
	if vzsrvcls=5 do recmsql(.cid,.vzrec,$G(expr),.par)

	// Store original record
	// vzrec     Service Class Message
	new RECORD
	for i=1:400:$L(vzrec) do {
		set RECORD=$E(vzrec,i,i+399)
		do Db.insert("STFMSG","STFSEQ,MSG",":MSGSEQ,RECORD")
		}

	// Store all accts involved and static info at top level.
	// [STFHSEQ] - ^STFHOST(STFSEQ)
	if $G(%UserStation)="" new TLO set %UserStation=ttx(1).tlo
	if %UserStation="" set %UserStation=$$TLO^UTLO

	new stfhseq
	type RecordSTFHSEQ stfhseq=Db.getRecord("STFHSEQ","STFSEQ=:MSGSEQ",1)
	set stfhseq.accts=$G(acctlst)
	set stfhseq.stftjd=%SystemDate
	set stfhseq.uid=%UserID
	set stfhseq.ucls=%UserClass
	set stfhseq.brcd=$G(BRCD)
	set stfhseq.mssgid=$G(vzmssgid)
	set stfhseq.tlo=%UserStation
	set stfhseq.fap=$G(vzfaps)
	set stfhseq.context=$G(context)
	set stfhseq.srvcls=vzsrvcls
	do stfhseq.save()
	
	do Runtime.commit()
	quit

	//----------------------------------------------------------------------
rectssp(MSGSEQ,acctlst,RecordTTX ttx())	// Private; Save the TSSP specific fields in STFHOST
	//----------------------------------------------------------------------
	/*
	   INPUTS:
	   . MSGSEQ Message sequanse			/REQ
	   . ttx()  Array of ttx() objects  		/TYP=T/MECH=REF:RW 

	   . STFECREV Identifies if STFHOST controlled  /NOREQ
	     transaction exist

	   . NET  Array by cid of net amounts that 	/NOREQ
	     must be updated. This is required if STFECREV is on.

	   RETURNS:
	   . acctlst List of affected accounts /TYP=T/MECH=REF:W
	  ----------------------------------------------------------------------
	*/
	new acn,acctlst,CID,ecrev,SEQ,stfnet,stfhost,sep
	set ecrev=0

	if $G(STFECREV)  do {			
		do xecrev(.ttx())		// to werify.
		kill STFECREV
		set ecrev=1
		} 

	set (sep,SEQ)=""
	for  set SEQ=$O(ttx(SEQ)) quit:SEQ=""  do {
		new x,CID,net,tso
		set CID=ttx(SEQ).cid
		set net=$$NETAMT(CID,.ttx(SEQ))

		if net,'ecrev do {
			if 'Db.isDefined("ACN","CID") quit
			type RecordACN  acn=Db.getRecord("ACN","CID")
			set acn.stfnet=acn.stfnet+net
			set acctlst=""
			set acctlst=acctlst_sep_CID set sep=","
			do acn.bypassSave()
			}

	        type RecordSTFHOST stfhost=Db.getRecord("STFHOST","MSGSEQ,SEQ",1)
		set stfhost.cid=ttx(SEQ).cid
		set stfhost.itc=ttx(SEQ).itc
		set stfhost.etc=ttx(SEQ).etc
		set stfhost.tamt=ttx(SEQ).tamt
		set stfhost.stfefd=ttx(SEQ).efd
		set stfhost.tcmt=ttx(SEQ).tcmt
		set stfhost.cdt=ttx(SEQ).cdt
		set stfhost.trc=ttx(SEQ).trc
		set stfhost.spr=ttx(SEQ).spr
		set stfhost.tsb=ttx(SEQ).tsb
		set stfhost.xhs16=ttx(SEQ).lnerc
		set stfhost.crcd=ttx(SEQ).crcd
		set stfhost.rate=ttx(SEQ).rate
		set stfhost.vdt=ttx(SEQ).vdt
		set stfhost.ben=ttx(SEQ).ben
		set stfhost.dir=ttx(SEQ).dir
		set stfhost.endbal=ttx(SEQ).endbal
		set stfhost.mult=ttx(SEQ).mult
		set stfhost.bseamt=ttx(SEQ).bseamt
		set stfhost.custcd=ttx(SEQ).custcd
		set stfhost.tresref=ttx(SEQ).tresref
		set stfhost.glsc=ttx(SEQ).glsc
		set stfhost.udprin=ttx(SEQ).udprin
		set stfhost.sysbase=ttx(SEQ).sysbase
		set stfhost.cmpsav=ttx(SEQ).cmpsav
		if SEQ#1=0 set stfhost.primary=1	// mark as primary

		if ttx(SEQ).tso'="" set stfhost.tso=ttx(SEQ).tso
		if net set stfhost.trnet=net

		if net set stfhost.trnet=net

		do stfhost.bypassSave()
		}
		
	quit

	//----------------------------------------------------------------------
recmsql(cid,vzrec,expr,par)	// Private; Save the MSQL fields in STFHOST
	//----------------------------------------------------------------------
	/*
	   PARAMS:
	   . cid  Array of account #'s  /TYP=T/MECH=REF:R
	   SYMBOL TABLE:
	   . acctlst List of accounts affected /TYP=T/MECH=VAL
	   . msgsq Message Sequence #  /TYP=N/REQ
	   RETURNS:
	  ----------------------------------------------------------------------
	*/
	new acctlst,i,sep
	if 'cid quit
	if $G(vzrec)="",$G(expr)'="" set vzrec=$$FMTMSQL(expr,.par)
	set i="" for  set i=$O(cid(i)) quit:i=""  do {
		set acctlst(i)=""
		set acctlst(i)=acctlst(i)_sep_cid set sep=","
		}
	quit

	//----------------------------------------------------------------------
NETAMT(cid,RecordTTX ttx)	//Public;Compute Net amount from TTX entry
	//----------------------------------------------------------------------
	/*
	   PARAMS:
	     . cid Account Number		/REQ/MECH=VAL
	     . ttx() Array of ttx() objects	/REQ/MECH=VAL

	  ----------------------------------------------------------------------
	*/

	new ETC,acn,TRB,net,type,dc,trn

	set ETC=ttx.etc
	if ETC="" quit 0

	type RecordTRN trn=Db.getRecord("TRN","ETC")
	if trn.cls="M"!((trn.cls="*")&('trn.trntyp)) quit 0

	type RecordACN  acn=Db.getRecord("ACN","CID")
	set TRB=acn.trb
	if TRB="" do {
		new prodctl
		set type=acn.type
		type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
		set TRB=prodctl.trb
		}
	set net=ttx.tamt
	set:net["#" net=$P(net,"#",2)
	set dc=$E(ttx.itc)
	if dc-TRB=0 set net=net*-1
	quit net

	//----------------------------------------------------------------------
FMTMSQL(expr,par)	//Public;Format MSQL message
	//----------------------------------------------------------------------
	/*

	   ARGUMENTS:
	   . expr SQL Expression  /TYP=T/REQ
	   . par SQL parameters  /TYP=T/NOREQ

	   RETURNS:
	   . $$ MSQL message  /TYP=T

	  ----------------------------------------------------------------------
	*/
	new vzfld,vzmsg
	if $G(expr)="" quit ""
	if $G(par)="",$D(par)>1 do {
		set I=""
		for  set I=$O(par(I)) quit:I=""  do {
			set X=$G(par(I)) quit:X=""
			set par=$G(par)_$S($G(par)="":"",1:"/")_X
			}
		}
	set vzfld(1)=expr
	set vzfld(2)=$G(par)
	set vzmsg=$$V2LV^MSG(.vzfld)
	quit vzmsg

	//----------------------------------------------------------------------
FMTTSSP(RecordTTX ttx(),SPV,BRCD,TPD)	//PUBLIC; Create TSSP Message
	//----------------------------------------------------------------------
	/*

	   This will create a TSSP message from the parameters provided and
	   from the lvn's mentioned below.

	INPUTS:
		. ttx()  -  Array of ttx() objects 	/TYP=T/REQ

		. BRCD -    				/TYP=N/TBL=[UTBLBRCD]/REQ 
	           	Branch Code where transaction is being processed.

		. SPV -  Supervisory Authorization array.	/TYP=T/NOREQ
		. TPD -  Teller Posting Date  		/TYP=D/REQ	           
		. %LOGID System variable  		/TYP=T/REQ
	     	. %NET   System variable  		/TYP=T/REQ
		. %UID   Current userid  		/TYP=T/REQ


	RETURNS:

		. $$ -  Formatted transactions in financial transaction record
		structure.       			/TYP=T

	  ----------------------------------------------------------------------

	    PROFILE Financial Transaction Record

	    Pos  Name Req Description             Type      Max Len

	     1   BRCD    Y   Branch code             N         6
	     2   TPD     Y   Teller Posting date     D         5
	     3   ACN     Y   Account number  (CID)   N         12
	     4   ETC     Y   Transaction code        T         12
	     5   TAMT    Y   Transaction amount      $         14
	     6   TRC     Y   Client transaction #    N         12
	    *7   CRCD    N   Currency code info      T
	     8   EFD     N   Effective date          D         5
	     9   VDT     N   Value date              D         5
	   *10   SPV     N   Supervisor auth.        T
	   *11   QLF     N   Transaction qualifiers  T
	   *12   PSI     N   Payment system instr.   T
	   *13   MSC     N   Miscellaneous info.     T
	    14   TCMT    N   Transaction comment     T         40
	    15   HISTN   N   Transaction Notes       T
	   *16   CKREG   N   Check Register Info     T
	    34   SYSBASE N   System Base Equiv.      N         12

	   * indicates complex fields containing one or more sub-fields

	  ----------------------------------------------------------------------
	*/
	    
	// Error trap for extrinsic functions
	do {
		catch vError {		
			new ET
			set ET=vError.type
			//set ET=$$ETLOC^%ZT
			do ZE^UTLERR
			}	
		
		new ETC,CHKTYP,CID,CUSTCD,FTF,MSC,OCC,PSI,QLF,REC,SEQ,SYSBASE,trn,TSO,tso
		new clpkt,zmsc

		do POBS^TTXRPC(.POBS)			//initialize POBS array	
		if %LOGID do context^TTXRPC(.ttx,SEQ,%LOGID)	//Check if context is still valid
		for SEQ=1:1 do {  quit:'SEQ	
			if SEQ#1 quit			//Ignore 2ndaries
			new fld,itc,msd,tso
			set itc=ttx(SEQ).itc		
			set msd=ttx(SEQ).msd	  	//Misc screen data
			set (MSC,PSI,QLF)=""		
			set fld(1)=$$BRCD^TTXRPC 	//Branch code		
			set fld(2)=$$TPD^TTXRPC    	//Teller posting date
			set fld(3)=ttx(SEQ).cid	  	//Account number		
			set fld(4)=ttx(SEQ).etc		//External Transaction code		
			set fld(5)=+ttx(SEQ).tamt		//Transaction Amount		
			if ttx(i).itc6+ttx(i).itc12  do {	//E/C or reversal - set amt positive
				set fld(5)=$$TAMT^TRNUTL(fld(5))
				}		
			set fld(6)=ttx(SEQ).trc		//Transaction Trace (reference) number		
			set CUSTCD=ttx(SEQ).custcd		//Customer code

			set ETC=ttx(SEQ).etc		//External Transaction code

			type RecordTRN trn=Db.getRecord("TRN","ETC")
			if trn.cls="M" set CUSTCD=""	// Transaction Class
					
			set fld(7)=$$CRCD^TTXRPC(.ttx(),SEQ)	//Currency info		
			set fld(8)=ttx(SEQ).efd		//Effective date		
			set fld(9)=ttx(SEQ).vdt		//Value date		
			set OCC=ttx(SEQ).cc			//Override cost center		
			set CHKTYP=ttx(SEQ).chktyp		//Check type		
			set TREF=ttx(SEQ).tresref		//Treasury reference #
			set TSO=ttx(SEQ).tso		//Transaction Sourse of Funds		
			set SPR=ttx(SEQ).spr		//Spray Number ; DFM 2/26/97
			do OUT^UTSO(.tso,TSO) if TSO="" set tso=""		
			set fld(10)=$$SPV^TTXRPC(.trn,.ttx(),SEQ,CID)	//Supervisor authorizations		
			set fld(11)=$$QLF^TTXRPC(SEQ,.tso)	//Transaction qualifiers		
			set fld(12)=$$PSI^TTXRPC(SEQ,.tso)	//Payment system instructions		
			set fld(13)=$$MSC^TTXRPC(SEQ,.tso,msd)	//Miscellaneous fields		
			set fld(14)=ttx(SEQ).tcmt			//Transaction comment		
			set fld(15)=$$HISTN^TTXRPC(SEQ,.HISTN)	//Transaction notes		
			set fld(16)=$$CKREG^TTXRPC(SEQ,.CK)	//Check register information		
			set fld(17)=ttx(SEQ).sysbase		//System base equivalent amount ;pc 7/21/97		
			for i=17:-1:7 quit:fld(i)'=""  kill fld(i)	//pc 7/21/97		
			set REC(SEQ)=$$V2LV^MSG(.fld)		//Build length-value record
			}
		set clpkt=$$V2LV^MSG(.REC)
		}
	quit clpkt

vSIG()	quit "60051^49946^John Carroll^20198"	// Signature - LTD^TIME^USER^SIZE
