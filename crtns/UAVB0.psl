UAVB0	
	/*
	
	Calculate weighted interest rate

	  ---- Revision History -----------------------------------------------

	   07/29/07 - CHHABRIS - CR27841
	   	      Modified NOEVENT section to make the M variable local in
	   	      the 'if' block. This was causing an issue while making a
	   	      LPOO (Payoff-keep a/c open) transaction. LNPTS26 has a
	   	      call to VATINT^PROCLNB1 section which calls into UAVB0.
	   	      In LNPTS26 the variable M holds the fees for the loan
	   	      a/c and was getting wrong values because of NOEVENT
	   	      section.

	   04/18/07 - RussellDS - CR26387
	   	      Eliminate use of UHFETCH.

	   11/30/06 - KELLYP - CR 24328
		      Modified LOAD section not to set SEQ = ZEROSEQ + 1.  This
		      prevents an issue with backdated rate maintenance changes
		      made via @IND001 caused by the fact that the next sequence
		      after SEQ needs to be considered for WIRN processing but
		      wasn't due to the "+1".
	
	   04/06/06 - SkariahV - CR 20380
	              Modified the HIST record retrieval to the ascending order 
	              of TSEQ in BLDWIRN section to return the correct values 
	              for WIRN.
	              
	   03/15/06 - Hillanbrand - CR 20073
	              Corrected logic in LNINIT and LNIT sections to return the
	              correct values for wirn. 
	              
	   12/10/05 - CHHABRIS - CR16677
	   	      Modified sections LOAD, RATE, SETUPHST. Changed the code to
	   	      instantiate a new DEP or LN object instead of trying to 
	   	      type-cast the proper type onto the existing acn object as
	   	      it was throwing host errors.

	   05/10/05 - Carol Scott - CR 15816
	   	      Added WIRN to parameters being passed into
	   	      sections LOAD, EXEC, %WIRN.

	   04/19/05 - SmithCD - CR15305
	   	      . Modified RATE section to pass parameters to CTL^UINDX 
	   	        in the proper sequence by removing an extra comma
	   	      . Removed call to INDDATA section of ^LNU and ^DEPFUNCS, 
	   	        and otherwise cleaned up the section
	   	      . Additional changes made in various other sections to 
	   	        eliminate parsing of INDEX
	   	      . Removed all occurrences of "ORDER BY" in order by b/c 
	   	        they can cause problems in an eOracle environment
	   	        clauses of select and selectDbset statements

	   04/12/05 - Hillanbrand - CR13281
	              Modified section LNINIT to correct undefined on JD.  Need
	              to define WIRN(FD).  JD may not be found if there are no
	              bill records within the FD and TD.

	   02/01/05 - SmithCD - CR13661
	   	      Modified section LNINIT to properly initialized lnbil1 if 
	   	      it is not defined, by replacing Class.new with classNew 
	   	      (Db.getRecord) and getMode() logic. Fixes a problem where 
	   	      lnbil1 record-level was not defined when calling into 
	   	      SUB^BILFUNCS. Also modified BLDWIRN section to exclude the 
	   	      same kinds of HIST records as the LOAD section does. Fixes 
	   	      an undefined error on the efdhist array.

	   12/30/03 - CARROLLJ - CR7658
		      Corrected paramter mismatch errors.

	   10/07/03 - CARROLLJ - 51630
		      Remove fromArray method.

	   08/08/03 - ZWITKOWITSM - 51349
	   	      Changed passing and use of ln and dep to acn.

	   03/06/02 - SCHWARTZC - 43583
		      PSL Conversion
		      Remove pre-2000 revision history

		      Removed section %RD2, the code has been merged with %RDAYS
		      Removed section RATE1, the code now exists where the call
		      was originally made from


	----------------------------------------------------------------------
	*/

	quit	

	//-----------------------------------------------------------------------
public EXEC(RecordACN acn,WIRN)	// Entry point from UAVB
	//-----------------------------------------------------------------------
	/*

	Arguments:
 
	. acn		Account object		/TYP=RecordACN/MECH=REF

	. WIRN array - interest rates, balances by date (optional)
	Output:

		HIST - History sequence array
		AV(21) - Weighted interest rate
		The WIRN array contains 4 pieces:
		WIRN(JD)=RATE | BALANCE | FLAG | BALINT

			Values for FLAG
			0 - Rate set by account activity
			1 - Rate set by file maintenance
			2 - Rate set by scheduled change

 
	Example:
 
	do EXEC^UAVB0(.acn,WIRN)

	 -----------------------------------------------------------------------
	*/

	// Calculate the weighted interest rate (nominal)
	set %RDAYS=0
	set NDAYS=0

	kill WIRN

	set AF=360
	set WIRN=1

	do LOAD(.acn,.WIRN)

	quit

	//-----------------------------------------------------------------------
LOAD(RecordACN acn,WIRN)	//
	//-----------------------------------------------------------------------

	new HIST,HISTCTF,HIT,INPTJD,INTOFF,IRN,ISEQ,ORIGIND,ORIGRT
	new SEQ,TAMT,TMPWIRN,TRATE,TREXD,TRB,TSEQ

	type RecordHIST efdhist(,)

	do INIT(.acn)

	set RT=IRN

	// Use teaser rate if teaser expiration date not reached
	if TREXD>TD set RT=TRATE

	set IX=INDEX

	if acn.cls="L" do {

		type RecordLN ln={RecordLN}acn

		if ln.aruf set BALCMP=BALCMP-ln.udbal

		do LNINIT(.ln)

		// Store and delete WIRNs created in LNINIT
		new N
		set N=""
		for  set N=$O(WIRN(N)) quit:N=""  do {
			set TMPWIRN(N)=WIRN(N)
			kill WIRN(N)
			}
		}
	
	/*
	   Creating effective dated history with Teller posting date balances.
	   This will be used to obtain an accurate WIRN array needed for
	   rate and index processing.
	*/

	set ZEROSEQ=0
	set ZEROLBAL=0
	set STDT=""

	type ResultSet rs=Db.select("JD","HIST0","CID=:CID AND JD<:FD","JD DESC")
	if 'rs.isEmpty(),rs.next() set STDT=rs.getCol(1)

	if STDT'="" do {
		
		type RecordHIST0 hist0 = Db.getRecord("HIST0", "CID=:CID,JD=:STDT", 1)

		// Start HIST SEQ, Default ZEROSEQ to 0 if null
		set ZEROSEQ = +hist0.seqzero

		// Starting balance
		set ZEROLBAL = hist0.bal

		if CLS="L" do {
			type RecordLN ln={RecordLN}acn
			if ln.aruf set ZEROLBAL = ZEROLBAL - hist0.udbal
			}
		if '$D(ZEROLBAL) set ZEROLBAL=0

		// Create efdhist object for first date after cutoff
		set efdhist(STDT+1,0)=Class.new("RecordHIST")
		set efdhist(STDT+1,0).tjd=STDT+1
		set efdhist(STDT+1,0).endbal=ZEROLBAL
		}

	set SEQ=ZEROSEQ
	set RUNBAL=ZEROLBAL

	// Set up HIST and efdhist(,) arrays
	type ResultSet rs2=Db.select("TSEQ","HIST","CID=:CID AND TSEQ>:SEQ")
	if 'rs2.isEmpty() while rs2.next() do {
		set SEQ=rs2.getCol(1)
		type RecordHIST hist=Db.getRecord("HIST","CID,SEQ")

		// Use calendar date if not effective dated
		set HEFD=$S(hist.efd="":hist.tjd,1:hist.efd)

		// Ignore future EFD HIST recs
		if HEFD>hist.tjd quit

		do SETUPHST(.acn,.hist,.efdhist(,))
		}

	do BLDWIRN(.acn,.efdhist(,),ZEROSEQ)

	quit

	//-----------------------------------------------------------------------
INIT(RecordACN acn)	//
	//-----------------------------------------------------------------------
	/*
	Initialize values from Loan and Deposit accounts.
	*/

	set ICHND=acn.ichnd
	set ICHLD=acn.ichld
	set INDEX=acn.index
	set BALCMP=acn.bal
	set TREXD=acn.trexd
	set TRATE=acn.trate
	set IRN=acn.irn
	set HISTCTF=acn.hisctf	
	set TRB=acn.trb

	if acn.cls="D" do {

		type RecordDEP dep={RecordDEP}acn

		set IRCB=dep.ircb
		set REVF=""
		set CRLMT=""
		set TDR=""
		set INTOFF=dep.intoff
		}

	else  do {

		type RecordLN ln={RecordLN}acn

		set IRCB=ln.ircb
		set REVF=ln.revf
		set CRLMT=ln.crlmt
		set TDR=ln.tdr
		set INTOFF=ln.intoff
		}

	quit
		

	//----------------------------------------------------------------------
BLDWIRN(RecordACN acn,RecordHIST efdhist(,), SEQ)	
	// Create WIRN entries for index & rate changes in history
	//----------------------------------------------------------------------
	/*

	   Collate forward through HIST to find any index or rate changes
	   For each entry found, build a WIRN entry from EFD:Date entered.
	   This will reflect actions which cover a date range, rather than a
	   particular date.  Since HIST is used, later entries will simply
	   overwrite earlier entries.  Duplicates will be removed in NOEVENT.
	*/
	type ResultSet rs=Db.select("TSEQ,TJD,EFD","HIST","CID=:CID AND TSEQ>:SEQ","TSEQ ASC")

	while rs.next() do {

		//Date entered
		set INPTJD=rs.getCol("TJD")
		
		set %EffectiveDate=rs.getCol("EFD")
		if %EffectiveDate="" set %EffectiveDate=INPTJD

		//Ignore future-dated history records
		if %EffectiveDate>INPTJD quit
		
		set SEQ=rs.getCol("TSEQ")

		// HIST doesn't store BAL for file maintenance.  Use efdhist
		// for BAL because it has already been modified to store it.
		set BAL=efdhist(EFD,SEQ).endbal

		set DT=%EffectiveDate
		set TCMT=efdhist(EFD,SEQ).tcmt

		// Index changes
		if TCMT["]INDEX:" do {
			// New index
			set INDEX=$P(TCMT,":",3)

			if INDEX'="",'$D(WIRN(DT)) do RATE(.acn,DT,BAL,.RT)

			/*
			   Even though we may have a WIRN entry for this date
			   we should overwrite it, since this transaction
			   occurred later.
			*/
			set WIRN(DT)=RT_"|"_BAL_"||"_INDEX
			set $P(WIRN(DT),"|",28)=INPTJD

			// Update WIRN for the date range from EFD - Input date.
			for DT=%EffectiveDate:1:INPTJD set WIRN(DT)=WIRN(%EffectiveDate)
			}

		if TCMT["]IRN:" do {
			new X
			set RT=$P(TCMT,":",3)
			set X=RT_"|"_BAL_"|1|"_INDEX
			set WIRN(DT)=X
			set $P(WIRN(DT),"|",28)=INPTJD
			set $P(X,"|",3)=""

			for DT=%EffectiveDate+1:1:INPTJD set WIRN(DT)=X
			}
		}

	/*
	   Collate forwards through efdhist, and find the first history
	   entries for changes to INDEX or IRN.  Get the original values to
	   ensure that the first WIRN entry truly reflects the state of the
	   account at that time.
	*/
	set DT=""
	set HIT=0
	kill ORIGIND,ORIGRT
	for  set DT=$O(efdhist(DT)) quit:DT=""  do { quit:HIT=2
		set SEQ=""
		for  set SEQ=$O(efdhist(DT,SEQ)) quit:SEQ=""  do { quit:HIT=2
			set TCMT=efdhist(DT,SEQ).tcmt
			if '$D(ORIGIND),(TCMT["]INDEX:") set ORIGIND=$P(TCMT,":",2) set HIT=HIT+1
			if '$D(ORIGRT),(TCMT["]IRN:") set ORIGRT=$P(TCMT,":",2) set HIT=HIT+1
			}
		}
	if $D(ORIGIND) set INDEX=ORIGIND
	if $D(ORIGRT) set RT=ORIGRT

	/*
	   Create WIRN entry for first record in efdhist.
	   This is needed as a base value for later processing.
	   Index, Rate and BAL values are at their earliest values right now.
	       (ie: we've collated to the start of efdhist)
	*/

	set DT=$O(efdhist(""))

	//  Get BAL from last efdhist rec for that DT
	if '$D(WIRN(DT)) do {
		set SEQ=$O(efdhist(DT,""),-1) quit:SEQ=""
		set BAL=efdhist(DT,SEQ).endbal

		// If other WIRN entries exist from maintenance, RT value is okay
		// Otherwise, get value of RT from index if one exists
		if '$D(WIRN),INDEX'="" do RATE(.acn,DT,BAL,.RT)
		set WIRN(DT)=RT_"|"_BAL_"||"_INDEX
		}

	// This value is needed for later processing in NOEVENT
	set HFIRSTDT=DT

	do NOEVENT(.efdhist(,))

	quit

	//-----------------------------------------------------------------------
NOEVENT(RecordHIST efdhist(,))	// Create WIRN for FD if it doesn't exist
	//-----------------------------------------------------------------------
	/*
	   In case no history exists for date range.  This can
	   occur through loan modeling (function LNC020).
	*/
	if $D(efdhist)'>0 do {
		if '$D(WIRN(FD)),$D(TMPWIRN(FD)) set WIRN(FD)=TMPWIRN(FD)
		if '$D(WIRN(TD)),$D(TMPWIRN(TD)) set WIRN(TD)=TMPWIRN(TD)
		}

	if '$D(WIRN(FD)) do {
		quit:'$D(efdhist)
		set DT=FD+1
		set DT=$O(efdhist(DT),-1)

		// This is necessary for Loans, since disbursements FD can
		// occur before ODT in efdhist
		if DT="" set DT=$O(efdhist(DT))
		set SEQ=$O(efdhist(DT,""),-1)
		set BAL=efdhist(DT,SEQ).endbal
		set DT=FD

		// There is always a WIRN for the first record in efdhist
		set DT=$O(WIRN(DT),-1)

		// This is necessary for Loans, since disbursements FD can
		// occur before ODT in efdhist
		if DT="" set DT=$O(WIRN(DT))
	
		set WIRN(FD)=WIRN(DT)
		set $P(WIRN(FD),"|",2)=BAL
		set $P(WIRN(FD),"|",3)=""
	
		if FD>HFIRSTDT quit

		if $D(ORIGRT) set $P(WIRN(FD),"|",1)=ORIGRT
		if $D(ORIGIND) set $P(WIRN(FD),"|",4)=ORIGIND
		}

	// Create WIRN for TD if it doesn't exist
	if '$D(WIRN(TD)) do {
		quit:'$D(efdhist)
		set DT=TD+1
		set DT=$O(efdhist(DT),-1)

		// This is necessary when open date is after TD
		if DT="" set DT=$O(efdhist(DT))
		set SEQ=$O(efdhist(DT,""),-1)
		set BAL=efdhist(DT,SEQ).endbal
		set DT=TD

		// There are previous WIRN already created
		set DT=$O(WIRN(DT),-1)

		// No need to check since previous WIRN values are defined
		set WIRN(TD)=WIRN(DT)
		set $P(WIRN(TD),"|",2)=BAL
		set $P(WIRN(TD),"|",3)=""
		}

	// Create WIRN for balance changes in history between FD and TD
	set DT=TD+1
	for  set DT=$O(efdhist(DT),-1) quit:(DT="")!(DT<FD)  do {
		set SEQ=$O(efdhist(DT,""),-1)
		set BAL=efdhist(DT,SEQ).endbal

		if '$D(WIRN(DT)) do {
			set PREVWIRN=$O(WIRN(DT),-1)
			set WIRN(DT)=WIRN(PREVWIRN)
			set $P(WIRN(DT),"|",2)=BAL
			set $P(WIRN(DT),"|",3)=""
			}
		}

	// Purge WIRN values that are before the FD
	set DT=FD
	for  set DT=$O(WIRN(DT),-1) quit:DT=""  kill WIRN(DT)

	// Purge WIRN values that are after the TD
	set DT=TD
	for  set DT=$O(WIRN(DT)) quit:DT=""  kill WIRN(DT)

	// Check if there was a teaser rate and adjust WIRNs
	if TREXD'="" do {
		if TREXD<FD quit

		new SAVEWRN

		// Save entry on/before TREXD
		set DT=$O(WIRN(TREXD+1),-1) quit:DT=""
		set SAVEWRN=WIRN(DT)

		// Change rates on all WIRNs which occur during teaser period
		set DT=""
		for  set DT=$O(WIRN(DT)) quit:(DT="")!(DT'<TREXD)  do {
			set $P(WIRN(DT),"|",1)=TRATE
			}
		quit:$D(WIRN(TREXD+1))

		//Reset rate for the following day
		set WIRN(TREXD+1)=SAVEWRN
		}

	// Create absolute set of WIRN dates composed of WIRN and TMPWIRN
	// entries for loans
	if CLS="L" do {
		
		type Date M
		new N,PDT,WIRNDATS
		set N=""
		set PDT=""

		for  set N=$O(WIRN(N)) quit:N=""  set $P(WIRNDATS(N),"|",1)=N
		for  set N=$O(TMPWIRN(N)) quit:N=""  if '$D(WIRNDATS(N)) set $P(WIRNDATS(N),"|",1)=N

		// Use absolute WIRN dates array (WIRNDATS) to merge WIRN and
		// TMPWIRN entries for loans
		for  set N=$O(WIRNDATS(N)) quit:N=""  do {
			set PDT=$P($G(WIRN(N)),"|",28)

			if $D(WIRN(N))&($D(TMPWIRN(N))) do { quit
				set WIRN(N)=WIRN(N)_"|"_$P(TMPWIRN(N),"|",5,99)
				set $P(WIRN(N),"|",28)=PDT
				}

			if $D(WIRN(N)) do { quit
				set M=$O(TMPWIRN(N),-1)
				set:M'="" WIRN(N)=WIRN(N)_"|"_$P(TMPWIRN(M),"|",5,99)
				set $P(WIRN(N),"|",28)=PDT
				}

			// only TMPWIRN exists if processing reaches here
			set M=$O(WIRN(N),-1) quit:M=""
			set WIRN(N)=$P(WIRN(M),"|",1,4)_"|"_$P(TMPWIRN(N),"|",5,99)
			set $P(WIRN(N),"|",28)=PDT
			}
		}

	do SETBAL(.efdhist(,))

	// Remove duplicates
	set X=$O(WIRN(""))
	set Y=X

	for  set X=$O(WIRN(X)) quit:X=""  do {
		if WIRN(X)=WIRN(Y),X'=TD kill WIRN(X)
		else  set Y=X
		}

	quit

	//-----------------------------------------------------------------------
public %WIRN(RecordACN acn,WIRN)	//
	//-----------------------------------------------------------------------
	/*
	Arguments:
 
	. acn	Account object	/TYP=RecordACN/NOREQ/MECH=REF

	. WIRN array - interest rates, balances by date (optional)
	Example:
 
	do %WIRN^UAVB0(.acn,.WIRN)
 
	*/

	new TREXD
	
	// Skip if not daily rate changes or no index
	if AF<360!(INDEX="") do %RDAYS quit
	
	set TREXD=acn.trexd

	set ZINDEX=INDEX
	set RTCHNG=FD
	
	if FD<TREXD set RTCHNG=TREXD

	do RTCHNG

	quit

	//-----------------------------------------------------------------------
RTCHNG	//
	//-----------------------------------------------------------------------

	for  set RTCHNG=$O(IX(ZINDEX,RTCHNG)) quit:RTCHNG=""!(RTCHNG>TD)  do {
		// Tran on same day as rate change
		if $D(WIRN(RTCHNG)) quit

		set BEFORE=$O(WIRN(RTCHNG),-1)
		if BEFORE="" quit

		set WIRN(RTCHNG)=WIRN(BEFORE)
		}

	do %RDAYS

	quit

	//-----------------------------------------------------------------------
%RDAYS	//
	//-----------------------------------------------------------------------

	set N=$O(WIRN(0))
	set DY=N
	set RT=$P(WIRN(N),"|",1)

	for  set N=$O(WIRN(N)) quit:N=""  do {
		set %RDAYS=%RDAYS+(RT*(N-DY))
		set DY=N
		set RT=$P(WIRN(N),"|",1)
		}

	set %RDAYS=%RDAYS+(RT*(TD-DY+1))
	set AV(21)=$J(%RDAYS/DIV,0,5)

	quit

RATE(RecordACN acn,	// Account object			/REF:R
     Date XEFD,		// Effective date of current WIRN
     Number BAL,	// Account balance
     Number RT)		// Interest rate			/REFNAM:W

	// Determine interest rate
	
	type public Date TREXD
	type public Number CTL, ICHLD, INTMN, INTMX, INTOFF, IRN, TRATE
	type public String INDEX, WIRN()

	type Date JD, NEXTDT, ODD, XDT
	type Number RATE, RRATE, SRATE, URATE
	type String PAR()

	if 'INDEX.isNull(), ICHLD, ICHLD < %EffectiveDate set RT = +IRN quit

	set JD = WIRN(%EffectiveDate + 1).order(-1)
	if JD > XEFD, WIRN(JD).piece("|", 3) = 1 set RT = +WIRN(JD) quit

	if %EffectiveDate < TREXD set RT = TRATE quit

	if INDEX.isNull() do { quit
		set NEXTDT = WIRN(%EffectiveDate + 1).order(-1)
		if NEXTDT set RT = +WIRN(NEXTDT) quit

		set RT = IRN
		}

	// Do not get value prior to oringial date
	set XDT = XEFD - INTOFF

	if acn.cls = "D" set ODD = ""
	else  do {
		type RecordLN ln = {RecordLN}acn
		set ODD = ln.odd
		}

	if XDT < ODD set XDT = ODD

	set PAR("INDEX") = INDEX
	set PAR("IXLOAD") = CTL.extract(12)

	do CTL^UINDX(.acn, XDT, BAL, .PAR())
	
	set RT = RATE
	if RT < INTMN set RT = INTMN
	if INTMX.isNull(), RT > INTMX set RT = INTMX

	if RT.isNull() set RT = IRN

	quit

	//-----------------------------------------------------------------------
LNINIT(RecordLN ln)	// Loan init section.
	//-----------------------------------------------------------------------

	type public Number BALCMP, RT
	type public Date FD, JD, TD
	type public String INDEX, WIRN()
	type Number I, PC, INT, SCHSEQ, SEQ
	type String %ESC, %INT, %PRN, %WIRN, B, X
	
	set SCHSEQ=ln.schseq
	set X=RT_"|"_BALCMP_"||"_INDEX_"||"_ln.cuin_"|"_ln.unin_"|"_ln.cupr_"|"_ln.unpr_"|"_ln.cues_"|"_ln.unes
	
	set X.piece("|",12)=ln.teb
	set X.piece("|",13)=ln.lchg_"|"_ln.mchg
	set X.piece("|",15)=ln.dic

	type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","ln.cid,SCHSEQ",1)
	
	// If bill record does not exist, set any piece to cause the record to 
	// be defined as an empty record.
	if lnbil1.getMode()=0 set lnbil1.pe01=""
	
	set PC=""
	set INT=""

	for I=1:1 set B=$$SUB^BILFUNCS(I,.lnbil1) quit:B=""  if B.piece("#",1)="I" do {  quit
		set INT=B.piece("#",3)
		set PC=I
		}

	if ln.idp do {
		set X.piece("|",16)=INT
		set X.piece("|",17)=lnbil1.cpib-INT
		}

	set X.piece("|",18)=lnbil1.ctab-lnbil1.cpib
	set X.piece("|",19)=ln.icpa
	set X.piece("|",24)=ln.crlmt
	set X.piece("|",25)=ln.tdr
	set X.piece("|",26)=ln.revf

	set %WIRN=X

	do MCHGINI(.ln)

	set %WIRN.piece("|",22)=ln.unapf

	set %WIRN.piece("|",23)=ln.pvar

	set %ESC=0
	set %INT=0
	set %PRN=0

	if ln.cuin<0 set %INT=-ln.cuin
	if ln.cupr<0 set %PRN=-ln.cupr
	if ln.cues<0 set %ESC=-ln.cues

	if SCHSEQ<1 do { quit
		set SEQ=SCHSEQ
		do LNIT(.lnbil1)
		set WIRN(FD)=%WIRN
		if '$D(WIRN(TD)) do {
			set X=WIRN(TD).order(-1)
			set WIRN(TD)=WIRN(X)
			}
		}

	set SEQ=SCHSEQ+1
	set WIRN(FD)=""

	type ResultSet rs=Db.select("SCHSEQ","LNBIL1","CID=:CID AND SCHSEQ<:SEQ","SCHSEQ DESC")
	if 'rs.isEmpty() while rs.next() do { quit:$G(JD)'<FD
		set SEQ=rs.getCol(1)
		type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","ln.cid,SEQ")
 
		do LNIT(.lnbil1)
 		
		set %WIRN.piece("|",20)=1
		set WIRN(JD)=%WIRN
		}

	if JD.get()'=FD set WIRN(FD)=%WIRN.get()

	if '$D(WIRN(TD)) do {
		set X=WIRN(TD).order(-1)
		set WIRN(TD)=WIRN(X)
		}

	quit

	//-----------------------------------------------------------------------
LNIT(RecordLNBIL1 lnbil1)	//
	//-----------------------------------------------------------------------

	type public Date JD
	type public Number %ESC, %INT, %PRN, PC, SEQ, SCHSEQ
	type public String %WIRN
	type Number ESC1, ESC2, INT1, INT2, PRN1, PRN2
	type String X
	
	set JD=lnbil1.cdpd

	set ESC1=lnbil1.ctab-lnbil1.cpib

	set ESC2=lnbil1.casd-lnbil1.cpid

	set X=$$SUB^BILFUNCS(PC,.lnbil1)

	// INT1 and PRN1 are the original interest and principal amts for this bill
	// INT2 and PRN2 are the remaining amounts for this bill

	set INT1=X.piece("#",3)
	set INT2=X.piece("#",4)

	set PRN1=lnbil1.cpib-INT1
	set PRN2=lnbil1.cpid-INT2

	// CUPR for this due date is equal to the original principal amount of the
	// bill minus principal paid

	set %INT=%INT+(INT1-INT2)
	set %PRN=%PRN+(PRN1-PRN2)
	set %ESC=%ESC+(ESC1-ESC2)

	set %WIRN.piece("|",16)=INT1
	set %WIRN.piece("|",17)=PRN1
	set %WIRN.piece("|",18)=ESC1

	if SCHSEQ=SEQ quit

	set %WIRN.piece("|",6)=INT1-%INT
	set %WIRN.piece("|",8)=PRN1-%PRN
	set %WIRN.piece("|",10)=ESC1-%ESC

	quit

	//-----------------------------------------------------------------------
MCHGINI(RecordLN ln)	//
	//-----------------------------------------------------------------------

	set $P(%WIRN,"|",21)=$$MCNB^LNCO3(.ln)
	quit

	//-----------------------------------------------------------------------
SETBAL(RecordHIST efdhist(,))	// Set balances into WIRN array
	//-----------------------------------------------------------------------
	/*

	   Not all balances are set into WIRN array correctly.  Collate through
	   WIRN and set all balances from efdhist.

	*/
	new EJD,SEQ,WJD
	set WJD=""

	for  set WJD=$O(WIRN(WJD)) quit:WJD=""  do {
		set EJD=$O(efdhist(WJD+1),-1)
		quit:EJD=""

		set SEQ=$O(efdhist(EJD,""),-1)
		set BAL=efdhist(EJD,SEQ).endbal

		set JD=WJD-1
		for  set JD=$O(WIRN(JD)) quit:JD=""  set $P(WIRN(JD),"|",2)=BAL
		}
	quit

	//----------------------------------------------------------------------
SETUPHST(RecordACN acn,RecordHIST hist,RecordHIST efdhist(,))
	// Set up HIST and efdhist arrays with rate/balance info
	//----------------------------------------------------------------------

	set HIST(CID,SEQ)=HEFD
	set efdhist(HEFD,SEQ)=hist.copy()

	// bal ok since not effective  dated
	if (hist.endbal'="")&(hist.efd=""),acn.cls="D" quit

	//  Check if undisbursed transaction
	if (hist.endbal'="")&(hist.efd=""),acn.cls="L" do { quit
		set TAMT=hist.tamt
		if TAMT["#" set TAMT=$P(TAMT,"#",2)+$P(TAMT,"#",5)
		if TAMT="" set efdhist(HEFD,SEQ).endbal=RUNBAL quit

		if '($E(hist.itc)-TRB) set TAMT=-TAMT

		set RUNBAL=RUNBAL+TAMT
		set efdhist(HEFD,SEQ).endbal=RUNBAL
		}

	// Get balance from nearest posting date of history
	if hist.efd'="" do { quit
		set DT=HEFD+1
		set DT=$O(efdhist(DT),-1)

		// Need to get efdhist before this SEQ
		set TSEQ=SEQ

		// Eff dating only done for past so collate back to find bal on that date
		set TSEQ=$O(efdhist(DT,TSEQ),-1)
		if TSEQ="" set DT=$O(efdhist(DT),-1) do {
			// No balance at eff date
			if DT="" set efdhist(HEFD,SEQ).endbal=0 quit

			// Get last rec for prior DT
			set TSEQ=SEQ
			set TSEQ=$O(efdhist(DT,TSEQ),-1)
			}

		if DT'="" set efdhist(HEFD,SEQ).endbal=efdhist(DT,TSEQ).endbal

		// Make adjustments to ending balances if EFD transaction changed the balance
		set TAMT=efdhist(HEFD,SEQ).tamt

		if TAMT'="" do {
			if acn.cls="L",TAMT["#" set TAMT=$P(TAMT,"#",2)+$P(TAMT,"#",5)

			if acn.cls="D",($P(TAMT,"#",3)) do {
				if $P(TAMT,"#",2) set TAMT=$P(TAMT,"#",2)
				else  set TAMT=0
				}

			if '($E(hist.itc)-TRB) set TAMT=-TAMT

			if acn.cls="L" set RUNBAL=RUNBAL+TAMT
			/*
			   Posting date from which efdhist ending
			   balances must be modified, ending with the
			   effective date
			*/
			set THRUDT=hist.tjd
			set DT=THRUDT+1
			for  set DT=$O(efdhist(DT),-1) quit:DT<HEFD  do {
				set TSEQ=""
				for  set TSEQ=$O(efdhist(DT,TSEQ),-1) quit:TSEQ=""  do {
					set efdhist(DT,TSEQ).endbal=efdhist(DT,TSEQ).endbal+TAMT
					}
				}
			}
		}

	set TSEQ=SEQ
	set BAL=""

	// Get previous hist rec balance
	Type DbSet rs=Db.selectDbSet("HIST","CID=:CID AND TSEQ<:TSEQ","TSEQ DESC")
	if rs.isEmpty() quit
	while rs.next() do { quit:BAL'=""
		type RecordHIST ohist=rs.getRecord("HIST")
	
		if acn.cls="L" do {

			type RecordLN ln={RecordLN}acn

			if 'ln.aruf quit

			set BAL=ohist.endbal
			if BAL="" set efdhist(HEFD,SEQ).endbal=RUNBAL quit

			set TAMT=ohist.tamt

			if TAMT["#" set TAMT=$P(TAMT,"#",2)+$P(TAMT,"#",5)
			if TAMT="" set efdhist(HEFD,SEQ).endbal=RUNBAL quit
			if (efdhist(HEFD,SEQ).tamt=""),(efdhist(HEFD,SEQ).itc="") set TAMT=0

			if '($E(ohist.itc)-TRB) set TAMT=-TAMT

			set RUNBAL=RUNBAL+TAMT
			set efdhist(HEFD,SEQ).endbal=RUNBAL
			}

		// UDBAL
		if BAL'="" quit
		set BAL=ohist.endbal
		if BAL'="" set efdhist(HEFD,SEQ).endbal=BAL quit
		}

	if BAL="" set efdhist(HEFD,SEQ).endbal=ZEROLBAL

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60841^67383^Sanjay Chhabria^23376"	// Signature - LTD^TIME^USER^SIZE
