public	DEPPI(RecordDEP dep, RecordTTX ttx, RecordTRN trn)

	/*
	Deposit Account Paid-In
	
	       ORIG: Allan Mattson
	       DESC:  Deposit account paid-in (credit) transaction processor.

	---- Revision History ------------------------------------------------
	
	05/25/06 - DESHPANDE S K - CR 20748
		   Replaced global public transaction variables (%TRNMODE,
		   %TRNHSEQ, %TRNPRIM) with transaction stored values. 
		   Replaced conditional check (%TRNSEQ#1 '= 0) with 
		   (if not ttx.getStoredValue("isPrimary")).
		   
	03/09/06 - NATRAJAH - CR 19838
		   Modified condition for the call SPAWN, to avoid to process
		   SPAWN section for secondary and system generated transactions.

	01/22/06 - TITOVE - CR 19098
		   Replaced Class.new with Db.getRecord when creating
		   DAYENDFNDT record, to prevent unique constraint violation
		   errors.

	09/16/05 - ARPAVC - CR 17206
		   Changed conditions before inserting into DAYENDFNDT 
		   to consider dep.trb.  If trb=0, then a debit reduces the
		   balance and the initial funding date should reflect the credits.
		   If trb=1, then a credit reduces the balance and the initial 
		   funding date should reflect credits.  In the same section, code 
		   was added to set dep.ftd (Funding Date) when the initial funding
		   occurs.
		  
	08/24/05 - KELLYP - CR 16684
		   Modified code that retrieves RELIR.LNCID when LNIRCID is
		   not present in TSO.  This corrects a problem where RELIR
		   was not being updated with the correct IRAMTR because
		   LNCID was being set equal to the result of rs.next() 
		   instead of rs.getCol("LNCID").
	
	03/14/05 - SmithCD - CR 13782
		   . Replaced %ttxmode with %TRNMODE to correctly recognize 
		     the transaction mode
		   . Replaced HISTSEQ usage with %TRNHSEQ (PTRNHSEQ) to fix 
		     incorrect value when generating secondary transactions, 
		     and for improved efficiency
		   . Modified STOP section to handle possibility of undefined 
		     ttxuid level
		   . Made top of procedure private (to the Transaction Posting 
		     system area; it is called by TRNDRV)
		   . Modified to comply with current standards
		   . Removed old revision history
		   
	*/

	type public Boolean ER
	type public String OVR(,,)

	type Number CID, LNCID, PTRNHSEQ, SEGEUR
	type String TSO()
			
	// Save primary transaction history sequence for use in Teller 
	// Transaction table (HISTDST) when generating secondary transactions
	set PTRNHSEQ = ttx.getStoredValue("HistSeq")

	set CID = dep.cid

	// Backdated transaction to a segmented account
	if dep.segflg, %EffectiveDate, %EffectiveDate < %SystemDate do ^RECALSEG(.dep, .ttx) quit

	// Value date to next accrual calculation date for low balance based on collected balance
	if trn.pcfd21, dep.ircb = 6 do { quit:ER

		type Date TRNDT

		// Value Date
		set ttx.vdt = $$VALNACP^DEPLBB(.dep, %EffectiveDate)
		if ER quit

		set TRNDT = $S(%EffectiveDate:%EffectiveDate, 1:%SystemDate)

		// Value date forward offset limit exceeded 
		if ttx.vdt > (TRNDT + CUVAR.VDTFWD) set OVR(dep.cid, "OVR", "VDTFWD") = ""
		}

	// Set up all TSO fields in TSO array to avoid extra calls to FIELD^UTSO
	do OUT^UTSO(.TSO(), ttx.tso)

 	do AUT(.dep, .ttx)
 	if ER quit

	type Boolean ISPRIM = ttx.getStoredValue("isPrimary") 
	// Direct transaction fees and effective dated service fee adjustment
	if ISPRIM do {
		// Transaction Fee
		if trn.pcfd10 do ^SRVTRN2(.dep, .ttx, .trn, +ttx.tamt)

		// Restate Service Fee
		if trn.pcfd13, 'dep.feepln.isNull() do {
			if %EffectiveDate, %EffectiveDate - %SystemDate = 0 quit

			// Service Fee Plan
			if '$$OLP^BCHFEEUT(dep.cid, dep.feepln, %EffectiveDate, ttx.etc) quit

			// Service Fee Adjustment
			do EFDFEE^BCHFEEUT(dep.cid, dep.feepln, %EffectiveDate)
			}
		}

	// Update Funds Ineligible for Investment
	if trn.pcfd14, dep.swpf = 1 set dep.swpile = dep.swpile + ttx.tamt 

	// Segmented Account Euro Conversion
	set SEGEUR = TSO("SEGEUR").get()

	if dep.segflg, 'SEGEUR do DEPOSIT^DEPPISEG(.dep, .ttx) quit:ER

	// Calculate Employer/Employee Contributions unless transferring to SEG 0
	if 'dep.segacr, TSO("SEGP").get().piece(":", 1) '= 0, dep.emplben do EMP(.dep, .ttx, 1) quit:ER

	// Ledger Balance
	set dep.bal = dep.bal + ttx.tamt

	// Last Transaction Date
	set dep.tld = %SystemDate

	// If the hold has expired, update the collected balance.
	if (ttx.vdt '> %SystemDate) ! (ttx.vdt.isNull()) set dep.balcol = dep.balcol + ttx.tamt

	// Call DEPSCH section when the Scheduled Deposit Processing flag is on.
	if dep.schproc do DEPSCH(.dep, .ttx, +ttx.tamt) quit:ER

	if %EffectiveDate.isNull() ! (%EffectiveDate = %SystemDate) do UPDAVB(.dep, .ttx) quit:ER

	// Get the earliest effective date of today's transactions to this account
	if 'dep.commfper.isNull(), '%EffectiveDate.isNull() do {

		if dep.commefd.isNull(), %EffectiveDate '= %SystemDate set dep.commefd = %EffectiveDate quit

		if %EffectiveDate < dep.commefd set dep.commefd = %EffectiveDate
		}

	// Original Amount
	if 'dep.org set dep.org = +ttx.tamt

	/*
	 If a transaction is system generated AND the MDT is today, then
	 we do NOT want to have the MDT extended.
	*/
	if dep.mdtext, ((ttx.getStoredValue("TranMode") '= 3) ! (dep.mdt '= %SystemDate)) do ^DEPMDT(.dep) quit:ER

	// Add initial credit to DAYENDFNDT
	if (('dep.trb)&('dep.cntcr))!((dep.trb)&('dep.cntdr)) do {

		set dep.fdt = %SystemDate

                type RecordDAYENDFNDT defndt = Db.getRecord("DAYENDFNDT","FDT=:%SystemDate,CLS=:dep.cls,GRP=:dep.grp,TYP=:dep.type,CID=:dep.cid",1)

		// Record already created
		if defndt.getMode() quit
		
		do defndt.bypassSave() 
		}

	// If Debit reduces balance, increment credit counter.
	if 'dep.trb do {
		set dep.cntcr = dep.cntcr + 1
		set dep.lcamt = +ttx.tamt
		set dep.lcdt = %SystemDate
		}

	// If Credit reduces balance, increment debit counter.
	else  do {
		set dep.cntdr = dep.cntdr + 1
		set dep.ldamt = +ttx.tamt
		set dep.lddt = %SystemDate
		}

	do START^TTXCOM(.dep, .ttx)
	if ER quit
	
	// Only spawn secondary transactions if this is not itself a secondary
	if ((ttx.getStoredValue("TranMode") '= 4) ! (ttx.getStoredValue("TranMode") '= 5)) do SPAWN(.dep, .ttx, .trn, PTRNHSEQ) quit:ER

	if %EffectiveDate, %EffectiveDate - %SystemDate do { quit:ER
		/*
		   Effective dated transaction
		   We only recalculate interest on a deposit transaction for:
		   1. Primary transactions
		   2. Secondary interest transfer adjustments
		*/

		if (ISPRIM '=1), 'TSO("INTTRFADJ").exists() quit

		// No int adjustments allowed
		if TSO("NOADJ").get() = 1 quit

		do ENT^RECALC(.dep, .ttx)
		}

	// Date of First Deposit
	if dep.cntcr = 1 do {
		if '%EffectiveDate.isNull() set dep.dfdep = %EffectiveDate
		else  set dep.dfdep = %SystemDate

		set dep.afdep = +ttx.tamt
		}

	// Update account status.
	do ^UPDSTAT(.dep, .trn)
	if ER quit

	// Budget Account Processing
	if 'TSO("BGT").get().isNull() do {

		do BGTPROC^DEPPO(.ttx, +ttx.tamt, TSO("BGT"), 1, trn.pcfd33, trn.pcfd34)

		// Save data for Error Correct
		type String SAVEEC

		set SAVEEC = ttx.lnerc
		// Budget Payment
		set SAVEEC.piece("#", 32) = trn.pcfd33
		// Miscellaneous Budget Contribution
		set SAVEEC.piece("#", 33) = trn.pcfd34

		set ttx.lnerc = SAVEEC
		}

	// Interest Reserve Processing
	set LNCID = TSO("LNIRCID").get()

	if LNCID.isNull() do {
		type ResultSet rs = Db.select("LNCID", "RELIR", "IRCID=:CID")

		if rs.next() set LNCID=rs.getCol("LNCID")
		}

	if 'LNCID.isNull() do {

		type RecordRELIR relir = Db.getRecord("RELIR", "IRCID=:CID,LNCID=:LNCID", 1)
		if relir.getMode() = 0 quit

		set relir.iramtr = relir.iramtr + ttx.tamt

		do relir.bypassSave()
		}

	quit


AUT(RecordDEP dep, RecordTTX ttx)

	// Deposit paid in authorization

	type public Boolean ER
	type public String OVR(,,)

	type Number BAL, TYPE

	set TYPE = dep.type

	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE=:TYPE")

	if dep.rflg do ^UFLG(.dep) quit:ER

	// Stop flag
	if 'dep.stp.isNull() do STOP(.dep, .ttx) quit:ER

	// IRA Account
	if dep.ira do ^IRA(.dep, .ttx) quit:ER

	if dep.flg do FLG^UFLG(.dep, ttx.itc) quit:ER

	// Lease Admin. Fee & Paid Int\Div may need manual adjusting 
	if dep.lsp = 1, '%EffectiveDate.isNull(), %EffectiveDate < %SystemDate set OVR(dep.cid, "OVR", "LSP") = ""

	// would-be ledger balance
	set BAL = dep.bal + ttx.tamt

	// Status other than active
	if dep.stat set OVR(dep.cid, "OVR", "STAT"_dep.stat) = ""

	// New balance is less than minimum allowed of $<MINBAL>|Balance of $0 or less requires approval 
	if 'dep.minbal.isNull(), BAL < dep.minbal set OVR(dep.cid, "OVR", "MINBAL") = $$^SCARND(dep.minbal, 0, dep.cid)

	if BAL < 0, 'dep.odlim.isNull() do {

		// Authorized Overdraft Limit Expiration Date
		if 'dep.odexp.isNull(), dep.odexp < %SystemDate set OVR(dep.cid, "OVR", "ODEXP") = ""

		// Balance is within authorized overdraft limit $<ODLIM> 
		if BAL '< -dep.odlim set OVR(dep.cid, "OVR", "ODLIM") = $$^SCARND(dep.odlim, 0, dep.cid)

		// Balance exceeds authorized overdraft limit $<ODUNAMT> 
		if BAL < -dep.odlim set OVR(dep.cid, "OVR", "ODUNAMT") = $$^SCARND(dep.odlim, 0, dep.cid)
		}

	// New balance would exceed maximum of $<MAXBAL> 
	if 'dep.maxbal.isNull(), dep.bal > dep.maxbal set OVR(dep.cid, "OVR", "MAXBAL") = $$^SCARND(dep.maxbal, 0, dep.cid)

	// Deposit amount is less than minimum of $<MINCR> 
	if +ttx.tamt < dep.mincr set OVR(dep.cid, "OVR", "MINCR") = $$^SCARND(dep.mincr, 0, dep.cid)

	// Deposit amount is greater than maximum of $<MAXCR> 
	if dep.maxcr, +ttx.tamt > dep.maxcr set OVR(dep.cid, "OVR", "MAXCR") = $$^SCARND(dep.maxcr, 0, dep.cid)

	// Deposit amount must be in increment of $<INCCR> 
	if dep.inccr, (ttx.tamt # dep.inccr) set OVR(dep.cid, "OVR", "INCCR") = $$^SCARND(dep.inccr, 0, dep.cid)

	// Initial opening deposit requirement is $<MINODA> 
	if 'dep.cntcr, +ttx.tamt < prodctl.minoda set OVR(dep.cid, "OVR", "MINODA") = $$^SCARND(prodctl.minoda, 0, dep.cid)

	// Outstanding anticipated int/div check <AECOUT> 
	if dep.ircb, dep.intchk set OVR(dep.cid, "OVR", "AECOUT") = dep.intchk

	// New balance is less than minimum to accrue $<MINACR> 
	if 'dep.minacr.isNull(), BAL < dep.minacr set OVR(dep.cid, "OVR", "MINACR") = ""

	quit


SPAWN(RecordDEP dep, RecordTTX ttx, RecordTRN trn, Number PTRNHSEQ)
	// Spawn secondary transactions (if necessary) off of primary

	type public Boolean ER

	if dep.ircb, dep.resint, trn.pcfd8 do { quit:ER

		// Effective-dated secondary residual interest transactions handled by RECALC
		if %EffectiveDate, %EffectiveDate - %SystemDate quit

		do REDRI(.dep, .trn, .ttx, PTRNHSEQ) quit:ER
		}

	/*
	  Check CUVAR.LSP (loan sweep priority) to find out if loan sweep or
	  overdraft sweep is invoked first.
	*/

	// If LSP, Loan Payment Sweep first
	if dep.lpswp, dep.lpdue, CUVAR.LSP do ^TTXODS(.dep, .ttx, 0) quit:ER

	// Overdraft Sweep
	if dep.odsi, +dep.bal '< dep.odsm do ^TTXODS(.dep, .ttx, 1) quit:ER

	// If 'LSP, Loan Payment Sweep last
	if dep.lpswp, dep.lpdue, 'CUVAR.LSP do ^TTXODS(.dep, .ttx, 0) quit:ER

	quit


Public STOP(RecordDEP dep, RecordTTX ttx)	// Stop payments
	/*
	  ARGUMENTS:
		dep - Deposit Account object		/TYP=RecordDEP/REQ
		ttx - Transation object			/TYP=RecordTTX/REQ
	*/

	type public Number BRCD
	type public String SRC()
	type public Date TPD
	type public Boolean ER
	
	type String UID

	set UID = ttx.uid
	if UID.isNull() set UID = %UserID
	if 'SRC(UID).exists() do {

		type RecordTTXUID ttxuid = Db.getRecord("TTXUID", "TJD=:TPD,BRCD=:BRCD,UID=:UID", 1)

		set SRC(UID) = ttxuid.src
		}

	// Stop ACH transaction
	if SRC(UID).find("ACH") ! (ttx.tlo.extract(1, 4) = "ACH-") do ACH^DEPSTP(.dep, .ttx) quit:ER

	do DEP^DEPSTP(.dep, .ttx) quit:ER

	quit


REDRI(RecordDEP dep, RecordTRN trn, RecordTTX ttx, Number PTRNHSEQ)
	// Create secondary transactions to reduce residual interest
	
	type public Boolean ER

	type String ETC, SAVEC, TAMT
	type Number RESADJ, TYPE

	if +dep.resint > +ttx.tamt set RESADJ = +ttx.tamt
	else  set RESADJ = +dep.resint

	set TYPE = dep.type

	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE=:TYPE")

	// Hit principal bal G/L
	set TAMT = RESADJ_"#"_RESADJ

	// DR Adj Neg Interest
	if dep.negipo = 2 set ETC = prodctl.dradni
	// DR Adj Pos Interest
	else  set ETC = prodctl.drtrin

	// Hit bal, int buckets
	do TRN(.dep, ETC, TAMT, ttx.crcd, PTRNHSEQ)
	if ER quit

	set TAMT = RESADJ
	// Hit res int G/L
	set TAMT.piece("#", 10) = RESADJ
	// CR ADJ Residual Int
	set ETC = prodctl.cradres

	// Hit resid int bucket
	do TRN(.dep, ETC, TAMT, ttx.crcd, PTRNHSEQ)
	if ER quit

	// Set residual amount into SAVEC of primary transaction
	set SAVEC = ttx.lnerc
	set SAVEC.piece("#", 26) = RESADJ
	set ttx.lnerc = SAVEC

	quit


TRN(RecordDEP dep, String ETC, String TAMT, String CRCD, Number PTRNHSEQ)
	// Create transaction entry

	type public Cache %CACHE()
	type public Number CID, BRCD, DIR, TYPE
	type public String TCMT
	
	type public Date TPD

	// Type ~p1: Interest posting tran code not defined
	if ETC.isNull() do Runtime.setErrMSG("DEP", 8463, TYPE) quit

	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")

	type RecordTTX ttx = Class.new("RecordTTX")

	set ttx.cid = CID
	set ttx.itc = trn.itc
	set ttx.etc = ETC
	set ttx.tamt = TAMT
	set ttx.tlo = %UserStation
	set ttx.tcmt = TCMT.get()
	set ttx.crcd = CRCD
	// Reserved - Balance after Transaction
	set ttx.endbal = +dep.bal

	// Set secondary transactions into lower levels of history
	type RecordHISTDST histdst = Class.new("RecordHISTDST")

	set histdst.cid = CID
	set histdst.tseq = PTRNHSEQ
	set histdst.dstseq = Db.currVal("HISTDST", "CID,PTRNHSEQ") + .01
	set histdst.acct = ttx.cid
	set histdst.itc = ttx.itc
	set histdst.etc = ttx.etc
	set histdst.tamt = ttx.tamt
	set histdst.tlo = ttx.tlo
	set histdst.tcmt = ttx.tcmt
	set histdst.crcd = ttx.crcd
	set histdst.endbal = ttx.endbal

	do histdst.bypassSave()
	
	do TRNSINGL^TRNDRV(.ttx, .dep, TPD, BRCD, 5)

	quit


Public EMP(RecordDEP dep, RecordTTX ttx, DIR)	// Employer/Employee Contributions
	/*
	  ARGUMENTS:
		dep - Deposit Account object		/TYP=RecordDEP/REQ
		ttx - Transaction object		/TYP=RecordTTX/REQ
		DIR - Direction:			/TYP=N/REQ/MECH=VAL
			1  - Deposit
			-1 - Error correct
	*/

	type Number EMPEE, EMPLYR

	set EMPLYR = $$FIELD^UTSO(ttx.tso, "EMPLOYER")

	if DIR > 0 set EMPEE = ttx.tamt - EMPLYR
	else  set EMPEE = (ttx.tamt + EMPLYR) * DIR

	// Update Employer YTD
	if EMPLYR > 0 do EMPRYTD(.dep, EMPLYR)

	// Update Employee YTD
	if EMPEE > 0 do EMPYTD(.dep, EMPEE)

	quit


EMPRYTD(RecordDEP dep, Number AMT)	// Emplyer Contribution YTD update

	type public String OVR(,,)
	type public Number DIR

	type Number YEARC, YEARE

	set AMT = $$^SCARND(AMT, 0, dep.cid)
	set YEARC = $$YEAR^SCADAT(%SystemDate, 1)

	if %EffectiveDate.isNull() set YEARE = YEARC
	else  set YEARE = $$YEAR^SCADAT(%EffectiveDate, 1)

	// This Year
	if YEARC = YEARE do {

		set dep.emprytd = dep.emprytd + (AMT * DIR)

		if dep.maxemprc.isNull() quit

		// Transaction exceeds max employer contribution for <MAXEMPY> 
		if dep.maxemprc < dep.emprytd set OVR(dep.cid, "OVR", "MAXEMPY") = YEARC
		}

	// In the past
	else  do {

		type RecordDEPYR depyr = Db.getRecord("DEPYR", "CID=:dep.cid,YEAR=:YEARE")

		set depyr.emprytd = depyr.emprytd + (AMT * DIR)

		do depyr.bypassSave()

		if depyr.maxemprc.isNull() quit

		// Transaction exceeds max employer contribution for <MAXEMPY> 
		if depyr.maxemprc < depyr.emprytd set OVR(dep.cid, "OVR", "MAXEMPY") = YEARE
		}
	quit


EMPYTD(RecordDEP dep, Number AMT)	// Employee Contribution YTD update
	//   INPUT:        AMT - Contribution Amount
	
	type public Number DIR
	type public String OVR(,,)

	type Number YEARE, YEARC

	set AMT = $$^SCARND(AMT, 0, dep.cid)
	set YEARC = $$YEAR^SCADAT(%SystemDate, 1)

	if %EffectiveDate.isNull() set YEARE = YEARC
	else  set YEARE = $$YEAR^SCADAT(%EffectiveDate, 1)

	// This Year
	if YEARC = YEARE do {

		set dep.empytd = dep.empytd + (AMT * DIR)

		if dep.maxempc.isNull() quit

		// Transaction exceeds max employee contribution for <MAXEMP> 
		if dep.maxempc < dep.empytd set OVR(dep.cid, "OVR", "MAXEMP") = YEARC
		}

	// In the Past
	else  do {

		type RecordDEPYR depyr = Db.getRecord("DEPYR", "CID=:dep.cid,YEAR=:YEARE")

		set depyr.empytd = depyr.empytd + (AMT * DIR)

		do depyr.bypassSave()

		if depyr.maxempc.isNull() quit

		// Transaction exceeds max employee contribution for <MAXEMP> 
		if depyr.maxempc < depyr.empytd set OVR(dep.cid, "OVR", "MAXEMP") = YEARE
		}

	quit


Public UPDAVB(RecordDEP dep, RecordTTX ttx) // Update the Average Balance fields

	/*
	   This section will update the current dollar days balance field
	   based on the transaction amount.

	  ARGUMENTS:
		dep - Deposit Account object		/TYP=RecordDEP/REQ
		ttx - Transation object			/TYP=RecordTTX/REQ
	*/

	type Number DLIM, PRIN
	type Date EOMJD

	// Get the principle amount from the transaction
	set PRIN = ttx.tamt
	set PRIN = $S(PRIN [ "#":+PRIN.piece("#", 2), 1:+PRIN)

	// If there is no principle adjustment, quit
	if PRIN = 0 quit

	// Determine positive or negative based on debit-credit indicator
	if dep.trb - ttx.itc1 = 0 set PRIN = -PRIN

	// Date of the last day in month
	set EOMJD = $$EOMJD^SCADAT(%SystemDate, 1)
	// Days left in the month
	set DLIM = EOMJD - %SystemDate + 1

	// Dollar Days Balance For current Period
	set dep.ddbalcur = dep.ddbalcur + (DLIM * PRIN)

	quit


Public DEPSCH(RecordDEP dep, RecordTTX ttx, Number PRIN)

	/*
	Update scheduled deposit information

	ARGUMENTS:
		dep - Deposit Account object		/TYP=RecordDEP/REQ
		ttx - Transation object			/TYP=RecordTTX/REQ
		PRIN - Principle amount			/TYP=N/REQ/MECH=VAL
	*/
	
	type public Date TEFD
	type public Boolean ER

	type Number CID, CTL, DEPSAT, DIR, SATADV, SCHSAT
	type Date EOCM, JD, LSTNSCDD
	type Boolean QUIT

	// Set direction of processing (deposit or error correct)
	set DIR = 1 
	set CTL = 0

	if PRIN < 0 do {
		set DIR = -1
		set CTL = 1
		}

	if 'TEFD.exists() set TEFD = $S(%EffectiveDate:%EffectiveDate, 1:%SystemDate)

	// Deposits not allowed after maturity date has expired
	if DIR > 0, TEFD > dep.mdt do Runtime.setErrMSG("DEP", 4657) quit

	// End of current month
	set EOCM = $$EOMJD^SCADAT(TEFD, 1)
	if ER quit

	set DEPSAT = PRIN \ dep.schdepa
	// No sched deposits satisfied
	if 'DEPSAT quit

	// Total deposits cannot exceed total amount of scheduled deposits for term
	if DIR > 0, (dep.nschdeps + DEPSAT) > dep.totnosdp do Runtime.setErrMSG("DEP", 4658) quit

	set SATADV = 0
	set (SCHSAT, QUIT) = 0

	for  set JD = $$NJD^UFRE(dep.nscdepdd, dep.schdepf, , CTL) quit:ER ! (QUIT)  do {
		// A deposit transaction
		if DIR > 0, SCHSAT '< DEPSAT set QUIT = 1 quit

		// An error correct of a deposit transaction
		if DIR < 0, SCHSAT '> DEPSAT set QUIT = 1 quit

		// Number of Scheduled Deposits Satisfied - Add/subtract 1
		set SCHSAT = SCHSAT + DIR

		// Storing the last value of Next Schedule Deposit Due Date
		set LSTNSCDD = dep.nscdepdd
		set dep.nscdepdd = JD

		// Count number of scheduled deposits satisfied by this tran
		if DIR > 0, (dep.odt = dep.schdepld) ! (TEFD > dep.schdepld) do {
			if dep.cumdep, dep.nscdepdd > EOCM set SATADV = SATADV + 1
			if 'dep.cumdep, dep.nscdepdd > dep.schdepnd set SATADV = SATADV + 1
			}

		// Final scheduled deposit satisfied
		if JD '< dep.mdt do EXTMDT(.dep, .ttx) set QUIT = 1 quit
		}
	if ER quit

	// Number of Scheduled Deposits Satisfied
	set dep.nschdeps = dep.nschdeps + SCHSAT

	// Evaluate max in advance restrictions only if processing a deposit
	if DIR > 0, SATADV do MAXADV(.dep, EOCM, .SATADV) quit:ER

	set CID = dep.cid

	type RecordDEPSCH depsch = Db.getRecord("DEPSCH", "CID=:CID,DEPDT=:TEFD", 1)

	set depsch.schdepa = depsch.schdepa + (dep.schdepa * SCHSAT)

	do depsch.bypassSave()

	quit 


EXTMDT(RecordDEP dep, RecordTTX ttx)
	// Extend maturity date for cumulative deposit accounts
	
	type public Date JD, LSTNSCDD, TEFD
	type public Boolean ER

	type Date OMDT
	type String XHS16
	
	// Not a Cumulative Deposit account
	if 'dep.cumdep quit

	// Final scheduled deposit not satisfied
	if JD > dep.mdt quit

	// Deposit not made after the final due
	if TEFD '> LSTNSCDD quit

	// Deposit not made before maturity date
	if TEFD '< dep.mdt quit
	
	// Save old dep.mdt value
	set OMDT = dep.mdt

	// Extend maturity date
	do ^DEPMDT(.dep)
	if ER quit

	// Save old maturity date with transaction
	set XHS16 = ttx.lnerc
	set XHS16.piece("#", 34) = OMDT
	set ttx.lnerc = XHS16

	quit


MAXADV(RecordDEP dep, Date EOCM, Number SATADV)
	// Evaluate maximum in advance restrictions for scheduled account
	
	type public Boolean ER
	type public Date TEFD
	type public String OVR(,,)

	type Date DEPDT, EOPM, SCHDT
	type Number SATADVA, SCHNUM, TOTFEE, TOTFEEOV, TOTAMTOV
	type String SCHINFO()

	// End of prior month
	set EOPM = $$BOMJD^SCADAT(TEFD, 1) - 1 quit:ER

	/*
	 Call SCHFEE to get SCHINFO array for life of account, ignoring
	 other returned (fee-related) info
	*/
	do FEE^SCHFEE(.dep, dep.cid, dep.mdt, .SCHINFO, .TOTFEE, .TOTFEEOV, .TOTAMTOV) quit:ER 

	set SCHNUM = 0
	// Total number of scheduled deposits satified this month
	for  set SCHNUM = SCHINFO(SCHNUM).order() quit:SCHNUM.isNull()  do {
		set SCHDT = SCHINFO(SCHNUM, "").order() quit:SCHDT.isNull() 
		set DEPDT = SCHINFO(SCHNUM, SCHDT).piece("|", 1) quit:DEPDT.isNull() 

		// Deposit not made in current month
		if dep.cumdep, (DEPDT '> EOPM ! (DEPDT > EOCM)) quit 

		// This scheduled date was satisfied in advance
		if dep.cumdep, SCHDT > EOCM set SATADV = SATADV + 1
		if 'dep.cumdep, DEPDT > SCHDT set SATADV = SATADV + 1
		}

	/*
	 Determine amount satisfied in advance based on number of deposits
	 satisfied in advance and the scheduled deposit amount
	*/
	set SATADVA = SATADV * dep.schdepa

	/*
	 If deposit results in the total number of scheduled deposits
	 satisfied in advance of the Scheduled Deposit Next Date (for
	 that calendar month if a cumulative account) exceeding the
	 Maximum Number of Scheduled Deposits in Advance, restriction
	 MAXNUM has been breeched.  (Similar requirement for MAXAMT)
	*/

	// Transaction exceeds maximum number in advance of <MAXNUM>
	if 'dep.maxsnadv.isNull(), SATADV > dep.maxsnadv set OVR(dep.cid, "OVR", "MAXNUM") = dep.maxsnadv

	// Transaction exceeds maximum amount in advance of $<MAXAMT>
	if 'dep.maxsaadv.isNull(), SATADVA > dep.maxsaadv set OVR(dep.cid, "OVR", "MAXAMT") = $$^SCARND(dep.maxsaadv, 0, dep.cid)

	quit

vSIG()	quit "60463^38556^Shriram Deshpande^21570"	// Signature - LTD^TIME^USER^SIZE
