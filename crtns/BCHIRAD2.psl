BCHIRAD2 //Batch BCHIRADIS2 - Retirement Auto-Distribution
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/30/2007 15:08 - joynerd
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHIRADIS2 Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 set vBCHSTS=$$STATUS^BCHUTL("BCHIRADIS2")
 if vBCHSTS=1 set ER=1,RM=$$^MSG(3410) quit
 if vBCHSTS=2 set ER=1,RM=$$^MSG(3414) quit
 if vBCHSTS=0 set %BatchRestart=1
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit do EXIT^BCHUTL("BCHIRADIS2") quit
 do JOBMGR^BCHUTL(%FN,"BCHIRADIS2",.vINPUT)
 do ^JOBMGR(.vINPUT)
 do EXIT^BCHUTL("BCHIRADIS2")
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(ACN,RPASEQ) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHIRADIS2","*","",ACN.get()_","_RPASEQ.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 if %BatchRestart,$$CHKLOG^BCHUTL(%SystemDate,%FN,"BCHIRADIS2",ACN.get()_","_RPASEQ.get()) do { quit
 do LOG^BCHUTL(%SystemDate,%FN,"BCHIRADIS2",ACN.get()_","_RPASEQ.get(),"Record already processed")
 }
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,ACN,RPASEQ)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHIRADIS2","*","",ACN.get()_","_RPASEQ.get(),"",et)
 }
 do UPDLOG^BCHUTL(%SystemDate,%FN,"BCHIRADIS2",ACN.get()_","_RPASEQ.get(),vCONTEXT)
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,ACN,RPASEQ) //
	do DTL

	quit
	
DTL	// Process an RPA Sequence
	
	new CLOSED,CLOSEOUT,IRADRC,IRAP,ETC
	new SORT,RC,RPATYPE,RSPSEQ,TEMPCID,TOTDIS,TOTMAD
	new UTSO,TSO

	set RSPSEQ=RPASEQ
	set TRC=TRC\1000+1*1000
	set (CLOSEOUT,ER)=0

	type RecordIRATYPE iratype
	set iratype=Db.getRecord("IRATYPE","ACN,RPASEQ")
	do iratype.setAuditFlag(1)
	set RPATYPE=iratype.iratyp
	set IRADRC=iratype.iraaut
	set CONDIST=iratype.condist	// Consolidate Distribution Code  
	set AUTDND=iratype.autdnd

	type RecordUTBLRSPDEF respdef
	set respdef=Db.getRecord("UTBLRSPDEF","RPATYPE")

	if IRADRC="" set IRADRC=respdef.iraaut
        if IRADRC="" set IRADRC=IRAAUT
	set AMT=$$^SCARND($$LASTAMT(.iratype,ACN,RPASEQ,IRADRC,.TOTMAD),0,$G(CID))
	
	set TOTDIS=AMT-TOTMAD
	if TOTDIS<0 set TOTDIS=0
	
	set RC=iratype.iraaut
	if RC="" set RC=iratype.iradis
	if RC="" set RC=DFTCODE			
	
	do BENEF(.iratype)
	
	new ANTCHK,DISMTC,CKTYP

	set NCK=0
	set DISMTC=iratype.dismtc
	set ANTCHK=iratype.antchk if ANTCHK,'RPANET set AMT=ANTCHK
	
	if DISMTC'="",'ANTCHK do {
		type RecordTRN trn
		set trn=Db.getRecord("TRN","DISMTC")

		set CKTYP=trn.cktyp
		set CT=CKTYP,NCK=1
		}

	set NJD=$$NJD^UFRE(%SystemDate,iratype.autfre) if ER do EXC quit
	
	set iratype.autdnd=NJD
	set iratype.autdld=%SystemDate

	do iratype.save()
	
	type RecordUTBLIRADIS iradis
	set iradis=Db.getRecord("UTBLIRADIS","KEY=:RC")
	
	set WHCALC=iradis.wh
	if iratype.rspwind=1 do {
		set WA=iratype.wthamt
		set WP=iratype.wthpct
		set SWA=iratype.stwhamt
		set SWP=iratype.stwhpct
		}
	else  set (WA,WP,SWA,SWP)=""


	if 'ANTCHK,(AMT>0),((WA+SWA)'<AMT) do { quit
		new CID
		// Withholding exceeds distribution (Member=~p1; RPA=~p2)
                set (RM)=$$^MSG(3750,ACN,RPASEQ)
		do EXC
		}

	/*
	 Setting up the ANTCHK piece of the IRAP array to fool
	 the system into believing there is no anticipated check.
	 This is done because transaction processing will log an error
	 when there is an existing anticipated check.  Since this batch
	 is posting the anticipated check transaction we need to set this
	 piece to 0.
	*/
	set iratype.antchk=0
	do DISOPT(.iratype) if ER quit
	do BAL(.iratype) if ER quit
	
	type TranSet ts
	set ts=Class.new("TranSet")

	do TR(.CLOSED,.ts,.iratype,.PRODCTL,.TRN) if ER quit
	do OFF(.iratype,.ts,.PRODCTL,.TRN)

	new IRAP

	set par("IPMODE")=3
	set par("OPTION")=2
	do ts.postTSet(TPD,BRCD,.par)

	if $D(CLOSED) do {
		new CID,ET,RM
		set CID=""
		for  set CID=$O(CLOSED(CID)) quit:CID=""  do {
			// Account closed during IRA Auto Distribution
			set (RM)=$$^MSG(8461,CID)
			do EXC
			}
		}
	quit

DISOPT(RecordIRATYPE iratype)	//  Disbursement Option

	// If DISOPT=1, disburse in reverse interest rate order
	// If DISOPT=2, disburse interest available
	
	new ACTIVE,AUTDND,BAL,CONDIST,DISCID,DISMTC,XFRCRCD,TOTBAL
	type Number RATE
	set TOTBAL=0
	set ACTIVE=0

	set DISOPT=iratype.autopt
	set DISMTC=iratype.dismtc
	set DISCID=iratype.discid

	if DISMTC="",DISCID'="" do {
		type RecordDEP dep
		set dep=Db.getRecord("DEP","DISCID")

		set XFRCRCD=dep.crcd
		}

	else  set XFRCRCD=""

	type ResultSet relcif=Db.select("CID","RELCIF,ACN","ACN=:ACN AND ACN.CID=RELCIF.CID AND ACN.CLS='D'")

	while relcif.next() do {
		set CID=relcif.getCol(1)

		type RecordDEP dep1
		set dep1=Db.getRecord("DEP","CID")

		if dep1.acn'=ACN quit

		if dep1.stat=4 quit
		if dep1.iraexc quit
		if dep1.rpaseq'=RPASEQ quit

		if XFRCRCD'="",dep1.crcd'=XFRCRCD do { quit
			 new RM set RM=$$^MSG(8462,CID)
                         do EXC
                         }

		set INDEX=dep1.index
		set RATE=+dep1.irn

		if INDEX'="" do {
			set EFD=TPD
			set BASE=dep1.bal
			set par("INDEX")=INDEX
			set par("MATRIX")=dep1.intmat
			set pat("IXLOAD")="000101"
			do CTL^UINDX(.dep1,EFD,BASE,.par)
			if ER do EXC quit
			set RATE=+RATE
			}

		set BAL=$S(DISOPT=2:dep1.intavl,1:dep1.bal)
		if BAL<0 quit
		if DISOPT=2 set SORT(RATE,CID)=BAL,$P(SORT(RATE,CID),"|",5)=1
		else  set SORT(RATE,CID)=BAL
		set TOTBAL=TOTBAL+BAL
		set ACTIVE=1
		}
        if (WA),((WA+SWA)'<TOTBAL),(ACTIVE) do { quit
                // Insufficient Funds
                set (ET,RM)=$$^MSG(3996,ACN,RPASEQ),ER=1
                do EXC
                }

	quit
	
BAL(RecordIRATYPE iratype)	//  Generate the transaction componenets

	/*
	 	SORT(RATE,CID)=
				Piece 1 = Balance
				      2 = Closeout amount
				      3 = Tran Option
				      4 = Amount to credit earnings
				      5 = Accrual is available
				      6 = Transaction amount
				      7 = Stop flag
				      8 = Net
				      9 = Federal Withholding Amount
				     12 = State Withholding Amount
	*/

	type Number RATE
	set RATE=""

	for  set RATE=$O(SORT(RATE)) quit:RATE=""!(AMT'>0)  do {

		set CID="",SKIP=0

		for  set CID=$O(SORT(RATE,CID)) quit:CID=""!(SKIP)  do {
			type RecordDEP dep
 			set dep=Db.getRecord("DEP","CID")

			if ER do EXC quit

			type RecordPRODCTL prodctl
			set prodctl=Db.getRecord("PRODCTL","dep.type")
			set CRCD=dep.crcd
			set TYPE=dep.type

			set PRODCTL(TYPE)=prodctl.drirad_"|"_prodctl.drtrgp_"|"_prodctl.dradin_"|"_prodctl.cradie_"|"_prodctl.drtrci_"|"_prodctl.crtrgp

			new DRTRCI,PGM
			set CLOSEOUT=1
			set DRTRCI=prodctl.drtrci			// DR Closeout Tran Code

			type RecordTRN trn
			set trn=Db.getRecord("TRN","DRTRCI")
			set ETC=trn.etc

			set TRN(ETC)=trn.etc_"|"_trn.itc_"|"_trn.cls_"|"_trn.acn

			set PGM=trn.pgm
			if $E(PGM)="^" set PGM=$E(PGM,2,99)
			
			set CR=0
			if $P(SORT(RATE,CID),"|",5) do ACRAVL(.iratype) quit
			
 			// Calculate closeout amount if interest remains 
			// on deposit
			
			/*
			PGM will always contain DEPCL because CLOSEOUT=1
			is set above.
			*/
			if PGM["DEPCL"  do DEPCL(110,.iratype) if SKIP quit
 
			// Consider State w/h amount (DSWA)
                        if RPANET S TMPAMT=AMT-DWA-DSWA
                        else  S TMPAMT=AMT
 
                        /*
                          If the distribution amount is greater than the
                          available balance then account will be closed
                        */
 
 			if TMPAMT'<$P(SORT(RATE,CID),"|",2) do { quit
				set TAMT=$P(SORT(RATE,CID),"|",2)
				set OPT=2
				set NET=+TAMT
				set TAMT=+TAMT+DWA+DSWA
				if RPANET set AMT=AMT-TAMT
				else  set AMT=AMT-NET
				do UPDATE(.iratype)
				}

			do {
				// Add new SWA,SWP,SAVSDWA,STTAX
				new TAMT,WA,WP,SAVDWA,SWA,SWP,SAVDSWA,STTAX
				set TAMT=AMT
                                if $P(SORT(RATE,CID),"|",9)'<0 do {
					set SAVDWA=iratype.wthamt
					set iratype.wthamt=$P(SORT(RATE,CID),"|",9)
                                        }
				if $P(SORT(RATE,CID),"|",12)'<0 do {
					set SAVDSWA=iratype.stwhamt
					set iratype.stwhamt=$P(SORT(RATE,CID),"|",12)
                                        }
				// Calculate Fed and State W/H
				for STTAX=0:1:1 do CLOSE^IRAWH(.dep)
				set iratype.wthamt=SAVDWA
				// Set State w/h fixed amount
				set iratype.stwhamt=SAVDSWA 
				}
	
			// set DWA=$$^SCARND((AMT/(1-(WP/100)))-AMT+WA,0,$G(CID))

			if RPANET set TMPAMT=AMT
			else  set TMPAMT=AMT+DWA+DSWA
 			if SORT(RATE,CID)'<(TMPAMT) do { quit
				set TAMT=AMT
				if RPANET set NET=TAMT-DWA-DSWA
				else  set NET=TAMT
				set AMT=0,OPT=0
				do UPDATE(.iratype)
				set SKIP=1
				}

			set CR=AMT+DWA+DSWA-SORT(RATE,CID)
			set TAMT=AMT+DWA+DSWA
			set NET=TAMT-DWA-DSWA
			set AMT=0,OPT=1
			do UPDATE(.iratype)
			}
		}
  	quit
	
ACRAVL(RecordIRATYPE iratype)	// Accrual is available
	
	type public Number RATE
        new IRA
        type RecordDEP dep2
        set dep2=Db.getRecord("DEP","CID")
 
        set IRA=dep2.ira
        set EFD=TPD

	do {
		new TAMT,WA,WP,SWA,SWP,STTAX
		set TAMT=AMT
		// Calculate Fed and State W/H
		for STTAX=0:1:1 do CLOSE^IRAWH(.dep2)
		}
	
	if (AMT+DWA+DSWA)'>SORT(RATE,CID) do { quit

		set TAMT=AMT+DWA+DSWA
		set AMT=0,OPT=0
		set NET=TAMT-DWA-DSWA
		do UPDATE(.iratype)
		}
	
	if SORT(RATE,CID)'>(WA+SWA) do { quit

		kill SORT(RATE,CID)
		// Insufficient funds
		set RM=$$^MSG(1244)
		do EXC
		}

	new BAL,DWA,WA,WP,DSWA,SWA,SWP,STTAX
	set BAL=SORT(RATE,CID)
	set TAMT=+BAL
	// 46454 - Calculate Fed and State W/H
	for STTAX=0:1:1 do CLOSE^IRAWH(.dep2)

	set AVL=BAL-DWA-DSWA
	set NET=AVL
	set AMT=AMT-AVL
	set OPT=0
	
	do UPDATE(.iratype)
	quit
	
UPDATE(RecordIRATYPE iratype)	// Update SORT, IRAP arrays

	type public Number RATE

	set $P(SORT(RATE,CID),"|",3)=OPT
	set $P(SORT(RATE,CID),"|",4)=CR
	set $P(SORT(RATE,CID),"|",6)=$$^SCARND(TAMT,0,$G(CID))
	set $P(SORT(RATE,CID),"|",8)=NET
	set $P(SORT(RATE,CID),"|",9)=DWA
        set $P(SORT(RATE,CID),"|",10)=$G(PEN)
        set $P(SORT(RATE,CID),"|",11)=$G(INT)
	set $P(SORT(RATE,CID),"|",12)=DSWA
  	quit
	
TR(closed,TranSet ts,RecordIRATYPE iratype,prodctl,trn)		//  File the transactions

	type Number RATE

	set TT=0
	set RATE=""
	for  set RATE=$O(SORT(RATE)) quit:RATE=""  do {

		set CID=""
		for  set CID=$O(SORT(RATE,CID)) quit:CID=""  do {

			new UTSO
			set TCMT=""
			if '$P(SORT(RATE,CID),"|",8)&'$P(SORT(RATE,CID),"|",9) quit
			set DWA=$P(SORT(RATE,CID),"|",9)
			if $P(SORT(RATE,CID),"|",12) set DSWA=$P(SORT(RATE,CID),"|",12)
			type RecordACN acn
			set acn=Db.getRecord("ACN","CID")

			set TYPE=acn.type

			set TSO=IRADRC
			// No auto-distribution reason code
			if TSO="" set ET="ACCD" do EXC quit
			// Must be a valid LIF Code

			type RecordUTBLIRADIS iradis
			set iradis=Db.getRecord("UTBLIRADIS","TSO")
			
			if RPATYPE=7,'iradis.lif do { quit
				set RM=$$^MSG(908)
				do EXC
				}
	
			set TSO("IRAD")=TSO
			set TSO="IRAD#"_TSO

			if $D(DWA) set TSO=$$FIELDIN^UTSO(.TSO,"RPAWH",DWA)
			// Set TSO with State W/H amount
			if $D(DSWA) set TSO=$$FIELDIN^UTSO(.TSO,"RPASWH",DSWA)

			if iratype.discid'="" do {
				set TCMT=""
				new TCID set TCID=iratype.discid
				if 'Db.isDefined("DEP","TCID") quit
				//  MSG # 3940 - Transfer To ~p1
				set TCMT=$$^MSG(3940,TCID)
				}

			set OPT=$P(SORT(RATE,CID),"|",3)
			set TT=TT+$P(SORT(RATE,CID),"|",8)
			if iratype.ben'="" do {
        			set BEN=iratype.ben
	 			set TSO=$$FIELDIN^UTSO(.TSO,"BEN",BEN)
				}

			else  if iratype.iraben'="" do {
				set BEN=iratype.iraben
				set TSO=$$FIELDIN^UTSO(.TSO,"BEN",BEN)
				}
			
			// Withdrawal
			if 'OPT do { quit

				set ETC=$P(PRODCTL(TYPE),"|",1)
				if ETC="" set ETC=$P(PRODCTL(TYPE),"|",2)
		
				set TAMT=$$TAMT($P(SORT(RATE,CID),"|",6),.TSO,.TT)
				do FILE(.ts,.iratype,.TRN) 
				quit
				}

			// Credit Earnings
			if OPT=1 do { quit

				set TAMT=$P(SORT(RATE,CID),"|",4)
				set ETC=$P(PRODCTL(TYPE),"|",3)
				set SST=TSO,TSO=""
				do FILE(.ts,.iratype,.TRN)
				set ETC=$P(PRODCTL(TYPE),"|",4)
				do FILE(.ts,.iratype,.TRN)
				set TSO=SST
				set TAMT=$P(SORT(RATE,CID),"|",8)
				set ETC=$P(PRODCTL(TYPE),"|",1)
				if ETC="" set ETC=$P(PRODCTL(TYPE),"|",2)
				set TAMT=$$TAMT($P(SORT(RATE,CID),"|",8),.TSO,.TT)
				do FILE(.ts,.iratype,.TRN)
				}

			if OPT=2 do { quit

				set ETC=$P(PRODCTL(TYPE),"|",5)
				set TAMT=$$TAMT($P(SORT(RATE,CID),"|",6),.TSO,.TT)
				do FILE(.ts,.iratype,.TRN)
				set closed(CID)=""
				quit
				}
			}
		}
	quit

FILE(TranSet ts,RecordIRATYPE iratype,trn)	// Set up TTX, XPDO files

	type Public Cache %CACHE()
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN","ETC = :ETC")
	set ITC=trn.itc
	
	set TRC=TRC+1
	
	do BENEF(.iratype)
	set TEMPCID(CID)=TAMT
	
	do TTXTRN1(.ts)
	if 'NCK quit			// XPDO Anticipated Checks already exists
	
	// set CAMT=TAMT_"#"_TAMT_"###"_DWA   // " "#"_TAMT_"###"_DWA " part is redundant

	set CAMT=TAMT                   // Value returned from function $$TAMT
 
        set $P(TAMT,"#",1)=TAMT-DWA-DSWA	// Net amt to customer
        set $P(TAMT,"#",2)=+TAMT	// Prin reduction for full amt
        set $P(TAMT,"#",5)=DWA		// DWA amt
	set $P(TAMT,"#",15)=DSWA	// DSWA amt, 46454 - AS
	
	if CONDIST do TMP quit		// Consolidated Check Distribution Process
	
	type RecordXPDO xpdo
	set CKSEQ=Db.nextVal("XPDO","%SystemDate,CT")
	
	type RecordXPDO xpdo1=Class.new("RecordXPDO")
	set xpdo1.tjd=%SystemDate
	set xpdo1.cktyp=CT
	set xpdo1.ckseq=CKSEQ
	set xpdo1.cid=CID
	set xpdo1.tamt=CAMT
	set xpdo1.efd=%SystemDate
	set xpdo1.tso=RC
	do xpdo1.bypassSave()

	//  File to CIFH, CIFD, and DAYEND
	if 'TT quit
	// Anticipated retirement plan distribution check $~p1
	set %TRN=$$^MSG(1080,$$^SCARND(TT,0,$G(CID)))
 
	do CIFHBLD^CIFFUNCS(%TRN)                       // *** CIF history filer
 
	quit


TMP	// Build temporary file for check consolidation

	/*  The temporary file will save off the variables to be used later on
	for consolidated check distribution process.  See section SCHEXIT.	
	*/ 

	type String REC

	type RecordTMPRPT2 tmprpt2=Db.getRecord("TMPRPT2","PID=:SCHPID,KEY1=:ACN,KEY2=:CONDIST",1)
	if 'tmprpt2.getMode() set tmprpt2.data="||||"_AUTDND_"|"_RC_"|"_CT

	set REC=tmprpt2.data
	
	
	set REC.piece("|",1)=REC.piece("|",1)+TAMT	// consolidated check amt to customer
	set REC.piece("|",2)=REC.piece("|",2)+TAMT
	set REC.piece("|",3)=REC.piece("|",3)+DWA	// consolidated DWA amt
	set REC.piece("|",4)=REC.piece("|",4)+DSWA	// consolidated DSWA amt, 46454
	set REC.piece("|",8)=REC.piece("|",8)+CAMT	// consolidated total used for history file

	set tmprpt2.data=REC

	do tmprpt2.bypassSave()

        quit
        
	
OFF(RecordIRATYPE iratype,TranSet ts,prodctl,trn)		// Post Offset to TTX

	/*
	The following will cause an MCR to be generated as a offset if
	there is a problem with the transfer account in the auto-dist
	record.  It will also log an exception in DAYEND("EXC" for the
	error - "Error in Offset Posting - IRAD".  This will clear up a
	balancing problem that could occur if an error is encountered with
	the transfer account.
	*/

	new CLOSED
	
	set CID=""
	set TAMT=TT,TSO="",ETC=iratype.dismtc,TCMT=""
	if 'TT quit
	if ETC="" do {
		set CID=iratype.discid
		if (CID="")!('Db.isDefined("DEP","CID")) do {
			set CID="",ETC="MCR"
			// Error in offset posting - IRAD
			set RM=$$^MSG(984)
			do EXC
			}
		}

	if CID'="" do { quit
		//  msg# 8460 - IRA Auto Dist Transfer
		set TCMT=$$^MSG(8460)
	
		type RecordDEP dep
		set dep=Db.getRecord("DEP","CID")

		type RecordPRODCTL prodctl
		set prodctl=Db.getRecord("PRODCTL","dep.type")
		set ETC=prodctl.crtrgp

		type RecordTRN trn
		set trn=Db.getRecord("TRN","ETC=:ETC")
		set ITC=trn.itc
	
		do TTXTRN1(.ts)
		}

	if '$D(TRN(ETC)) do {
		type RecordTRN trn=Db.getRecord("TRN","ETC")
		set ITC=trn.itc
		set TRC=TRC+1
		if trn.cls="M" set CID=trn.acn
		if CID="" set CID=$$GLACN^TRNUTL(.trn,%UserID)
		set DRCR=$E(ITC,1)

		}
	else  set ITC=$P(TRN(ETC),"|",2),TRC=TRC+1


	set XCID=""
	for  set XCID=$O(TEMPCID(XCID)) quit:XCID=""  do {
		type RecordDEP dep=Db.getRecord("DEP","CID=:XCID")

		set TAMT=TEMPCID(XCID)
		do BLDTOT(.dep,TAMT)
		}

	set iratype.antchk=""
	do iratype.save()
	quit
	
INITTX	// Delete ^TTX,^TPRF if STAT=1 (create batch restart)
	
	do Db.fastDelete("TTX","%SystemDate,BRCD,%UserID")
	do Db.fastDelete("TPCTRL","BRCD,%UserID,%SystemDate")
	do SETPRF^TTXLOK
	quit
	
ZT	// Mumps error
	
	set %ZTHALT=0
	do ZE^UTLERR // Log MUMPS error
	// System processing error
	set RM=$$^MSG(2575)
	do EXC
	quit

EXC	// Log error in exception file
	
	// IRA Auto-dist Exclusion Flag

	new XBAL,XIRAEXC

	if $G(CID) do {
		type RecordDEP dep3
		set dep3=Db.getRecord("DEP","CID")

		set XBAL=dep3.bal
		set XIRAEXC=dep3.iraexc
		}
	if $G(CID),XIRAEXC quit

	new BALER
	set BALER=$S($G(CID):XBAL,1:"")

	// Dayend post of IRA
	do LOG^UTLEXC($T(+0),"*",$$^MSG(3679),$G(CID),$G(%ZTSEQ),$G(RM),BALER)
	kill RM,%ZTSEQ
	quit
	
DEPCL(CTL,RecordIRATYPE iratype)	// Calculate closeout amount based upon CTL 
	
	type public Number RATE
	new TMP set TMP=AMT 
	new AMT set AMT=TMP
	
	type RecordDEP dep5
	set dep5=Db.getRecord("DEP","CID")

	set PRIN=dep5.bal
	set iraflg=dep5.ira
      
	// Create empty transaction to pass to UMAT.
        type RecordTTX ttx=Class.new("RecordTTX")
       
	do ^UMAT(.dep5,.ttx)

	set INT=$S($E(CTL):INT,1:0)
	set PEN=$S($E(CTL,2):PEN,1:0)
	set X=PRIN+INT-PEN
	
	// Calculate close-out default amount
	set SKIP=0

	do {
		new TAMT,WA,WP,WS,MYAMT,A,SWA,SWP,SWS
		set (AMT,TAMT)=X
		do INIT^IRAWH(.dep5)
		if 'iratype.rspwind set DWA=0,DSWA=0 quit
		if '$D(IRA)#10 set IRA=iraflg
		// WS - [IRATYPE]RSPWSCH - withholding schedule

		if $G(WS)'="" do {
			set MYAMT=AMT
			if $G(UTSO("TOTDIS")) set MYAMT=UTSO("TOTDIS")
			new X
			set X=MYAMT-.001
			set W=Db.nextKey("UTBLRSPWSCH","WS,X")
			if $G(W)="" quit  // if witholding higher than Tier Distribution Ceiling then process will stop 
			type RecordUTBLRSPWSCH rspwsch
			set rspwsch=Db.getRecord("UTBLRSPWSCH","WS,W")
			set WP1=rspwsch.pct
			}
		set A=(AMT*(WP/100))+(AMT*($G(WP1)/100))+WA   // if RPANET is "Y"
		if A<0 set A=0
		set DWA=$$^SCARND(A,0,CID)

		// Calculate State W/H amount (DSWA) considering SWS
		if $G(SWS)'="" do {
			set MYAMT=AMT
			if $G(UTSO("TOTDIS")) set MYAMT=UTSO("TOTDIS")
			new X
			set X=MYAMT-.001
			set W=Db.nextKey("UTBLRSPWSCH","SWS,X")

			// if witholding higher than Tier Distribution Ceiling then process will stop
			if $G(W)="" quit
			type RecordUTBLRSPWSCH rspwsch
			set rspwsch=Db.getRecord("UTBLRSPWSCH","SWS,W")
			set WP1=rspwsch.pct
			}
		set A=(AMT*(SWP/100))+(AMT*($G(WP1)/100))+SWA   // if RPANET is "Y"
		if A<0 set A=0
		set DSWA=$$^SCARND(A,0,CID)

		// Consider State w/h (DSWA)
                if AMT<(DWA+DSWA) do {
			if AMT'<DWA set iratype.stwhamt=AMT-DWA
			else  do {
				set iratype.wthamt=AMT
				set iratype.stwhamt=0
				}			
                        if DWA'>AMT set DSWA=AMT-DWA
			else  set DWA=AMT,DSWA=0
                        }
                else  do {
			set iratype.wthamt=0
			set iratype.stwhamt=0
			}
		set $P(SORT(RATE,CID),"|",9)=WA
		set $P(SORT(RATE,CID),"|",12)=SWA
		}

        /*
          Computation of available balance for a close out should always
          subtract DWA regardless of the value of RPANET.
        */
        set AVL=$$^SCARND(X-DWA-DSWA,0,$G(CID))	// 46454 - AS
        set $P(SORT(RATE,CID),"|",2)=AVL
 	quit
	
LASTAMT(RecordIRATYPE iratype,ACN,RPASEQ,DTSO,MAD)	//

	/*
	 If last then make sure MADAMT is satisfied. 
	
	 OUTPUT:
	 	MAD - MAD amount is passed out
	*/
	
	new AMT,CYR,DISTAMT,FRE,JD,MADAMT,MADAVL,MADCY,MADSAT,NJD,NYR
	new PERIODIC,PLN,SVAMT,TSO
	new TYE

	set MAD=0
	set ER=$G(ER)

	/*
	Set AMT to either the normal auto-distribution amount (piece 8), 
	(option 1) or interest available (option 2), from subroutine INTAVL.
	INTAVL would only return an amount if option 2 (use available 
	interest) is being used.
	*/

	set (SVAMT,AMT)=iratype.autamt+$$INTAVL(.iratype)
	set TAG=iratype.autopt
	set TSO="IRAD#"_DTSO			// Get reason cd & TSO field


	/*
	Take the distribution frequency, and find out if the next distribution
	is next year.  If it is, then this is the last one for this year, 
	so make sure to satisfy the MAD amount.
	*/

	set NJD=$$NJD^UFRE(%SystemDate,iratype.autfre) quit:ER AMT
	set CYR=$$YEAR^SCADAT(%SystemDate,1)
	set TYE=$$EOTY^SCADAT(%SystemDate,1)            
	
	/*
	MADAMT represents the MADAMT (minimum annual distribution) required,
	MADCY is how much has already been satified.  MADAVL, the amount
	still needed, is the difference between the two.
	*/

	type RecordIRA ira

	if 'Db.isDefined("IRA","ACN,RPASEQ,CYR") do {
		set ira=Class.new("RecordIRA")
		set ira.acn=ACN
		set ira.rpaseq=RPASEQ
		set ira.taxyr=CYR
		}
	else  do {
		set ira=Db.getRecord("IRA","ACN,RPASEQ,CYR")
		}

	set MADCY=ira.madcy
	set MADAMT=ira.madamt

	/* 
	To compute the total dist for W/H needs. take the  total dist minus the
	mad. To get the mad take the lessor of MADAVL, or AMT. Then call 
	PMADAMT with that amount as the default amt. PMADAMT will return either
	this amount or a periodic amount if appropriate. 
	*/

	set MADAVL=MADAMT-MADCY
	set DISTAMT=MADAVL I AMT<DISTAMT set DISTAMT=AMT
	set MAD=$$PMADAMT^IRA(ACN,RPASEQ,CYR,TSO,DISTAMT)
	
	/*
	If MAD has already been satisifed, or this is not the last
	distribution for this year, use the normal distribution amount.
	*/

	set MADSAT=iratype.madsat quit:'MADSAT AMT	// Satisfy MADCY
	if TYE>%SystemDate,TYE>NJD quit AMT             // Same year
 	
	// For distribution option 2 - interest available, use the
	// the interest available amount.

	if iratype.autopt quit AMT
	
	/*
	For this final distribution of the current year, use either
	the normal distribution amount, or the amount left to satisfy
	MAD, whichever is greater.
	*/

	if MADAVL>AMT quit MADAVL
	quit AMT
	
INTAVL(RecordIRATYPE iratype)	// Disburse available interest
	
	new CID,INTAVL
	
	if iratype.autopt'=2 quit 0
	set INTAVL=0
	
	type ResultSet relcif=Db.select("CID","RELCIF,ACN","ACN=:ACN AND ACN.CID=RELCIF.CID AND ACN.CLS='D'")

	while relcif.next() do {
		set CID=relcif.getCol(1)

		type RecordDEP dep
		set dep=Db.getRecord("DEP","CID")

		if dep.acn'=ACN quit
		
		// Interest Available Flag
		if 'dep.iaf quit

		if dep.stat quit		  // Account Status
		if dep.rpaseq'=RPASEQ quit        // RPA Sequence
		
		// IRA Auto-dist Exclusion Flag
		if dep.iraexc quit
		
		set INTAVL=INTAVL+dep.intavl
		}

	quit INTAVL
	
TTXTRN1(TranSet ts)	//

        /*
        Build an array containing fields required for a transaction
        CID    Customer number
        ETC    Transaction code
        TAMT   Transaction amount
        EFD    Effective date
        TSO    Source
        TCMT   Transaction comment
        */

	new TTXBLD,x

        type RecordTTX ttx=Class.new("RecordTTX")	

        set TTXBLD("CID")=CID
        set TTXBLD("ETC")=ETC
        set TTXBLD("TAMT")=TAMT
        set TTXBLD("EFD")=$G(EFD)
        set TTXBLD("TSO")=TSO
        set TTXBLD("TCMT")=$G(TCMT)

        if $G(CRCD)="" do {
		type RecordACN acn
		set acn=Db.getRecord("ACN","CID")

		set CRCD=acn.crcd
		}

	set TTXBLD("CRCD")=CRCD
        set TTXBLD("TLO")=%UserStation
        set x=ts.copyTran(ttx,.TTXBLD)

        quit
	
BLDTOT(RecordDEP dep,TAMT)	//Build offset array to include the amounts posted to each individual account

	new BCHID,CC,CLS,CRCD,DESC,GLSC,GRP,JOB,TYPE

	set BCHID="IRADIS2"
	set JOB=%ProcessID
	set CRCD=dep.crcd
	set GLSC=dep.glsc
     	set TYPE=dep.type
	set CLS=dep.cls
	set GRP=dep.grp
        set CC=dep.cc

        /* 
	Build global with the standard information required for posting
        the offset, track the existence of the global with an array using
        the significant keys of the global.  After creating the entry,
        fall into the code which follows to update the global with the
        amount of the transaction.*/
	 
	if 'Db.isDefined("TMPBCHOFF","TJD,BCHID,JOB,""inc"",CRCD,TYPE,GLSC,CC") do {
                do BDOFFSET^BCHSOURC("IRADIS2","inc",CRCD,TYPE,GLSC,CC,CID,CID,ETC,ETC,TCMT) 
		}

        /*
	Offset Record already exists, so update it with the amount from this
	transaction
        */
  
        do UPOFFSET^BCHSOURC("IRADIS2","inc",CRCD,TYPE,GLSC,CC,DRCR,TAMT)
        quit

TAMT(TAMT,TSO,OFFAMT)	//  Determine transactions for witholding, etc.

	type public String ETC,SORT()
	type public Number ACN,CID,CLOSEOUT,ER,MADSAT,OPT,RATE,RPASEQ

	if 'TAMT quit 0				// No TAMT

	set ER=$G(ER)				// Init ER

	type Number DSWA,DWA,INT,IRA,ITC,NET,PEN
	type String UTSO()
	
	do OUT^UTSO(.UTSO,.TSO)			// Extract TSO into UTSO aray
	set UTSO("IRADIS")=1			// Flag as from Dist process
	do IN^UTSO(.UTSO,.TSO)			// Reset TSO value
	
	set ITC=0
        set PEN=$P(SORT(RATE,CID),"|",10)
        set INT=$P(SORT(RATE,CID),"|",11)
        set NET=$P(SORT(RATE,CID),"|",8)

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	type RecordTTX ttx=Class.new("RecordTTX")
	
	set ttx.tso=TSO
	set ttx.etc=ETC
	set ttx.tamt=TAMT
	set ttx.itc=ITC
	
	do ^IRA(.dep,.ttx) quit:ER TAMT

	set DWA=$P(SORT(RATE,CID),"|",9)
	set DSWA=$P(SORT(RATE,CID),"|",12)

	if DWA set $P(TAMT,"#",5)=DWA		// Add DWA amount
	else  if CLOSEOUT set $P(TAMT,"#",5)=0

	if DSWA set $P(TAMT,"#",15)=DSWA
	else  if CLOSEOUT set $P(TAMT,"#",15)=0

	// set OFFAMT=OFFAMT-DWA		// Back off DWA from offset amt
	
	set $P(TAMT,"#",2)=+TAMT		// Prin reduction for full amt
	set $P(TAMT,"#",1)=NET			// NET to customer
	
	if OPT=2 do {
		set $P(TAMT,"#",3)=INT		// Add in INT amt for closeout
		set $P(TAMT,"#",4)=PEN
		}

	quit TAMT
	
BENEF(RecordIRATYPE iratype)	// Beneficiary Code
	
	set BEN=""   
	
	if iratype.ben'="" do {
		set BEN=iratype.ben
		set TSO=$$FIELDIN^UTSO(.TSO,"BEN",BEN)
		}

	else  if iratype.iraben'="" do {
		set BEN=iratype.iraben
		set TSO=$$FIELDIN^UTSO(.TSO,"BEN",BEN)
		}
	
	/* 
	Now, BEN should be either a CIF number or null.
	If BEN="" and the reason code is "death", log the error and quit.
	*/

	type RecordUTBLIRADIS radis
	set radis=Db.getRecord("UTBLIRADIS","RC")	

	if BEN="",radis.rsn=6 do {       
		// Beneficiary is required for death reason code
		set (RM)=$$^MSG(8439)
		do EXC
		}
	quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
	for  set vRECORD=vINPUT.piece("|",1),vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD.isNull()  do {

		type Number ACN,RPASEQ

		set ACN=vRECORD.piece($C(9),1)
		set RPASEQ=vRECORD.piece($C(9),2)

		do vPROC(ACN.stripQuotes(), RPASEQ.stripQuotes())
		 }


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
	type Public String vBUFOVFL
	type String vRECORD,vrow,ACN,RPASEQ
	type Public String current
	type Number vcur,vlen
	set vINPUT=vBUFOVFL.get()
	set vBUFOVFL="""",vlen=0
	type Public ResultSet vRESULT
	for  do { quit:'vcur
		set vcur=vRESULT.next() if 'vcur quit
		set vrow=vRESULT.getRow()_"|"
		if vrow=$g(current) quit
		set current=vrow
		set vlen=vlen+vrow.length()
		if vlen>32767 set vBUFOVFL=vrow,vcur=0 quit
		set vINPUT=vINPUT_vrow if vlen+26>32767 set vcur=0 quit
		}
	set vINPUT=vINPUT.extract(1,vINPUT.length()-1)

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	set SCHPID=%ProcessID
	
	do Db.fastDelete("TMPRPT2","PID=:SCHPID")

	do SOURCE^BCHSOURC("IRAD","IRAD",.%UserID,.BRCD,.%UserClass) if ER set %BatchExit=1 quit

	type Public ResultSet vRESULT=Db.select("ACN","IRATYPE","IRATYPE.AUTDND=:%SystemDate")
	if vRESULT.isEmpty() set %BatchExit=1


 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("ACN,RPASEQ","IRATYPE","IRATYPE.AUTDND=:TJD")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	do SOURCE^BCHSOURC("IRAD","IRAD",.%UserID,.BRCD,.%UserClass)
	set TPD=%SystemDate

	set IRAAUT=CUVAR.IRAAUT		//Auto-Distribution Reason Code
	set DFTCODE=CUVAR.IRADIS	//IRA Default Distribution Code
	set RPANET=CUVAR.RPANET		// Net Withholding Flag

	set (TCMT,TSO)=""
	kill ETC,MAXADJ,TC

   	set BCHID="IRADIS2"
        set JOB=%ProcessID
	set TRC=0

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
	set TPD=%SystemDate
	do INITTX

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
	do OFFSET^TTXBLD(%SystemDate,BRCD,%UserID,"IRADIS2")

	/* Data will be retrieved from the temporary table TMPRPT2 to
	set up XPDO file for consolidated check distribution.
	*/

	// Retrieve data from the temporary TMPRPT2 table
	// Add TPAMT15 for State Withholding Amount
	type ResultSet rs=Db.select("KEY1,DATA","TMPRPT2","PID=:SCHPID")

	if rs.isEmpty()  quit
	while rs.next()  do {
		type String REC
		set ACN=rs.getCol("KEY1")
		set REC=rs.getCol("DATA")
		set TPAMT1=REC.piece("|",1)		// Net distribution to customer
		set TPAMT2=REC.piece("|",2)		// Prin reduction for full amt
		set TPAMT5=REC.piece("|",3)		// DWA amt
		set TPAMT15=REC.piece("|",4)		// DSWA amt 51245
		set TA=TPAMT1_"#"_TPAMT2_"###"_TPAMT5_"##########"_TPAMT15
		set AUTDND=REC.piece("|",5)		// Next Day
		set IRAD=REC.piece("|",6)		// Distribution Reason Code
		set CT=REC.piece("|",7)			// Check Type
		set TT=REC.piece("|",8)			// Consolidated Total
		do CXPDO
		}

	do Db.fastDelete("TMPRPT2","PID=:SCHPID")	// Delete temp table
 
	quit
 
CXPDO	//  Cosolidate CHECK into XPDO
 
	type RecordXPDO xpdo
	set CKSEQ=Db.nextVal("XPDO","%SystemDate,CT")
 
	type RecordXPDO xpdo1=Class.new("RecordXPDO")
	set xpdo1.tjd=%SystemDate
	set xpdo1.cktyp=CT			// Check Type
	set xpdo1.ckseq=CKSEQ			// Check Sequence
	set xpdo1.cid=ACN			// Customer ID		
	set xpdo1.tamt=TA			// Distribution Amounts
	set xpdo1.efd=AUTDND			// Next Day
	set xpdo1.tso=IRAD			// Distribution Reason Code
	do xpdo1.bypassSave()
 
 
	// File total amount to CIFH/CIFD history files
	if 'TT quit
	// Anticipated retirement plan distribution check $~p1
	set %TRN=$$^MSG(1080,$$^SCARND(TT,0,$G(ACN)))
 
	do CIFHBLD^CIFFUNCS(%TRN)                       // *** CIF history filer
 
	quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
