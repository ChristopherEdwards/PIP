UKILL	  /*
	ORIG: MATTSON - 02/18/2003
	DESC: Purge Daily Files


---- Comments --------------------------------------------------------

---- Revision History ------------------------------------------------

        12/05/05 - Satyanas - 18155
        	   Modified the code to PSL standards. 
        
        07/27/05 - SkariahV - CR16679
	           Removed #WARN directive.
	
	02/20/03 - Allan Mattson - 51351
	           Converted to PSL; eliminated the code that saved purged
	           data to system files (the restore functionality was
	           obsoleted in V5.0).

 */
	do INIT
	quit
	

INIT	//

	type public String COLLIST(),%READ,SEL(),%TAB(),VFMQ
	type Number ALL
	type String FID,OLNTB,X
	
	type public IO io = Class.new("IO")

	set %TAB("SEL")=".SEL1/TBL=[SYSDEV,UTBLKILL]/XPP=D POST^UKILL(X)"

	set %READ="@@%FN,,,SEL/REP=18"
	do ^UTLREAD if VFMQ="Q" quit

	set ALL=0
	
	set X=""
	for  set X=SEL(X).order() quit:X.isNull()  if SEL(X)="*" do ALL(.SEL) set ALL=1 quit
	if 'ALL set X="" for  set X=SEL(X).order() quit:X.isNull()  if SEL(X).isNull() kill SEL(X)
		
	set FID=""
	for  set FID=SEL(FID).order() quit:FID.isNull()  do {
		set FID=SEL(FID)
		
		set io.fileName ="SAV."_FID
	 	set io.openParams = "NEWV/WRITE"
		set io.timeout = 5
	
		catch ioExc {
			// catch exception error
			if ioExc'["%PSL-E-IO" throw ioExc

			// Error opening ~p1. Process stopped for type ~p2
			write $$^MSG(992,io.fileName,ioExc.type), !
			}
		do io.open()
		
		// Writing deleted files to ~p1
		do io.write($$^MSG(6969, io.fileName))
		
		do io.write($$HEADER(FID,.COLLIST()))
		
		do io.write("EOH")
		
		do PROC(FID,.COLLIST())

		do io.write("EOD")
		
		do io.close()
		}
	quit

HEADER(	String TABLE, 
       	String COLLIST())	// write header
	
	set COLLIST = $$COLLIST^DBSDD(TABLE,1,1,1)
	set COLLIST(TABLE) = COLLIST

	quit (TABLE_9.char()_COLLIST.translate(",",9.char()))
	

PROC( String FID,
      String COLLIST())	//Purge Table

	type public Boolean ER
	type public String RM
	type Date ENDJD,JD
	type String EXPR,DATE,DTFMT,DTKEY
	
	type RecordUTBLKILL utblkill=Db.getRecord("UTBLKILL","FID=:FID")

	set DTKEY=utblkill.dtkey
	set DTFMT=utblkill.dtfmt
	set ENDJD=%SystemDate-utblkill.svdys
	
	// Julian date format
	if DTFMT="NNNNN" do {
		
		do DATA(COLLIST(FID),FID)
		
		do DELETE^SQL(FID_" WHERE "_DTKEY_"<"_ENDJD)
		}
		
	else  do {

		#ACCEPT Date=03/17/2003;PGM=Allan Mattson;CR=Dan Russell
		type ResultSet rs=Db.select("DISTINCT "_DTKEY,FID)

		while rs.next() do {
					
			set DATE=rs.getCol(1)
			
			/*
			Convert string date to julian date; quit on error or
			if the date exceeds the purge cut-off date (ENDJD).
			*/
			set JD=DATE.toDate(DTFMT) if ER!(JD>ENDJD) quit
			
			do DATA(COLLIST(FID),FID)
			
			do DELETE^SQL(FID_" WHERE "_DTKEY_"='"_DATE_"'")
			}
		}

	quit

DATA( String COLLIST,
      String TABLE)
        	// write data

	type public IO io
	type String DATA

	#ACCEPT Date=02/13/2006; PGM=Satyanarayan Sethy
	type ResultSet rs = Db.select( COLLIST,TABLE)
	
	while rs.next() do {

		type Row rw = rs.getRow()

		set DATA = TABLE_9.char()_rw.toString()

		do io.write(.DATA)
		}

	quit
	
POST( String X)	//File name post-processor

	type public String ER,I,RM
	
	//All daily files
	if X="*" set I(3)="",I(5)="",ER="W",RM=$$^MSG(240)
	quit


ALL( String SEL())	//All files selected

	kill SEL
	
	type ResultSet rs=Db.select("FID","UTBLKILL")
	while rs.next() set SEL(rs.getCol("FID"))=""
	quit
	
	
TBLINIT( Number OPT)	// Initialize UTBLKILL
	/*
	This subroutine is used to initialize UTBLKILL with date-keyed
	tables.  If an entry does not already exist in UTBLKILL for a
	particular table, this subroutine will initialize the value of
	UTBLKILL.SVDYS to 90 days.

	ARGUMENTS:
	     . OPT	Initialization Option	/REQ/MECH=VAL
	     
	     		0 = Initialize only those tables that do not
	     		    have an entry in UTBLKILL.  Any existing
	     		    entries in UTBLKILL will not be deleted
	     		    prior to initialization.
	     		    
	     		1 = Initialize all tables.  Any exitsing enties
	     		    in UTBLKILL will be deleted prior to
	     		    initialization.
	*/
	
	type Number DONE,KEYNBR
	type String ACCKEYS,DES,DI,FID

	/*
	If initialization option equals '1', delete the
	existing entries in UTBLKILL.
	*/

	if OPT do Db.delete("UTBLKILL")
	
	type ResultSet rs=Db.select("FID,DES,ACCKEYS","DBTBL1","%LIBS='SYSDEV'")
	while rs.next() do {
		
		set FID=rs.getCol("FID")
		set DES=rs.getCol("DES")
		set ACCKEYS=rs.getCol("ACCKEYS")

		// Already defined in UTBLKILL
		type RecordUTBLKILL utblkill1=Db.getRecord("UTBLKILL","FID=:FID",1)
		if utblkill1.getMode() quit
				
		set DONE=0
		for KEYNBR=1:1:ACCKEYS.length(",") do { quit:DONE
			set DI=ACCKEYS.piece(",",KEYNBR)

			
			type RecordDBTBL1D dbtbl1d=Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=:FID,DI=:DI")

			// Data type is not D[ate]
			if dbtbl1d.typ'="D" quit

			type RecordUTBLKILL utblkill=Class.new("RecordUTBLKILL")
			set utblkill.fid=FID
			set utblkill.desc=DES
			set utblkill.dtkey=DI
				
			set utblkill.dtfmt="NNNNN"
			set utblkill.svdys=90

			do utblkill.save()
				
			set DONE=1
			}
		}
		
	quit
	
	
	

vSIG()	quit "60309^29716^Sethy, Satyanarayan^4903"	// Signature - LTD^TIME^USER^SIZE
