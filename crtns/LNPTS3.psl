public LNPTS3(RecordLN ln, RecordTTX ttx, RecordTRN trn)

	/*
	Apply Payment According to Payment String
	
	   INPUTS:
	       . ZAMT Amount to apply
	       . PF   Partial/Full pmt
		      Full = 1, Partial = 0	
		      (set in ^LNPTS2)
	
	---- Revision History -------------------------------------------------
	08/24/07 - VARGAJ - CR 25601
		   The BILL5 array was setup incorrectly causing the percentage
		   calculation of linked fees and elements to be bypassed.
		   	
	08/20/07 - PUTTASWH - CR 28626
		   Modified UPDVAT section to type it as public and moved the
		   code to reduce REMAIN to the extent of VATAMT to APPLY
 		   section since this variable is used only during loan payment 
		   that is processed as per the PMT String.  This is not used
		   when VAT On Interest is paid due to interest processing as a
		   result of the seperate Interest element in the Payment Due
		   Action Grid.
		   
	07/02/07 - KinI - CR 27213
		   Modified FEETSO section to correctly set TSO field for 
		   multiple linked fees.
		   
	06/28/07 - PUTTASWH - CR 27530
		   Modified APPLY section to pick the VATAMT to be deducted 
		   from LNBIL5 table.  Modified UPDVAT section to update LNBIL5 
		   record specific to VAT On Interest payments.
	
	05/21/07 - PUTTASWH - CR 27130
		   Modified APPLY section to invoke PROVATPMT^LNPTSU to pay 
		   interest and VAT on Interest due proportionally, if 
		   applicable. Deleted VATPROC section and added UPDVAT 
		   section to update VAT details.
	
	04/16/07 - PUTTASWH - CR 25723
		   Modified the PAYTOLCH section to prevent payment tolerance
		   processing from being used on the last bill before maturity
		   as well as post-maturity bills.
	
	03/24/07 - PUTTASWH - CR 24945
		   Added VATPROC section for VAT processing on interest amount
		   during loan payments. Modified APPLY section to invoke VATPROC.
		   
	03/21/07 - VANITHAK - CR 25758
		   Replicated the CR 25289 from Profile04.
		   
		   03/06/07 - KELLYP - CR 25289
		   Modified the CNTCR section to plus the month value for 
		   determining which month the full payment was made.  This
		   prevents an issue where the full payment counters were not
		   updated for single-digit months (Jan-Sep).  Also modified 
		   the CNTCR section to do comparisons for updating FPC* vs.
		   FPP* based on the financial year-end dates, not on calendar
		   year values.
		   		   
	01/05/07 - KUMARB - CR24680
		   Modified section PRN and INT to update the principal and 
		   accrued interest amounts on loans with Segments Allowed 
		   (LN.SEGMENTS) selected by calling PAYBAL^LNSEG and 
		   PAYACR^LNSEG respectively.

	12/15/06 - SANTHUMS - CR 20525
		   Modified DUI section to declare DUI variable before 
		   calling LNPTS3. Also modified INT section to check the flag 
		   Update Interest Paid(LN.RPIDC) and DUI varaible before 
		   setting the interest paid fields. This is required since 
		   interest paid fields were getting updated when LN.RPIDC flag 
		   is "N" during the interest capitalization process. 
		     	
	12/14/06 - KinI - CR 24193
		   Modified IND0 section to quit with null before calling 
		   $$GETELEMENT^BILFUNCS if there is no more bills to apply
		   the payment amount. This prevents undefined lnbil1() object.

	12/14/06 - KELLYP - CR 24236
		   Modified PAYTOLCH section to quit when ZAMT > 0.  Payment
		   tolerance processing should only be invoked after the full
		   payment amount has been applied.

	11/16/06 - KELLYP - CR 24123
		   Modified DCC section to call new DCCUPD section to decrement
		   a loan's delinquency counters according to CUVAR.DCCUP.  If
		   CUVAR.DCCUP = 0 or null, the counters will be updated based
		   on only the oldest delinquent bill.  If CUVAR.DCCUP = 1, the 
		   counters will be updated for all delinquent bill records.

	11/07/06 - NATRAJAN/KELLYP - CR 23882
		   Modified ZAMT section to properly delete bill records 
		   generated in advance that have a $0 amount billed.  Also 
		   removed setting of ln.dpmt in ZAMT for partial payments
		   since the calls to EXEC and/or REMOVE of LNBLDE will
		   update ln.dpmt properly.
		   
	10/19/06 - KELLYP - CR 19960
		   Retrofit of payment tolerance functionality.  Added call to 
		   new section, PAYTOLIN, from INIT to retrieve bill records 
		   previously satisfied by payment tolerance processing and to 
		   load them into LNBIL1.  This allows the system to properly 
		   satisfy the remaining due amounts as per the loan's grid, 
		   path, and string setup.  Also added call to new section,
		   PAYTOLCH, from RESET to determine if payment tolerance 
		   functionality can be used to satisfy any outstanding bill
		   records once payment processing has completed.

	10/13/06 - Ravindra Rathi - CR 23494
	           Modified the START section to call INIT for setting the correct values
	           of OLDSEQ variable and corrected the CNTCR section to 'set CNT = CNT - 1' 
	           when 'CNT > 0' as the number of payments satisfied (LN.CNTCR) 
	           were getting incorrectly set due to wrong values of OLDSEQ and 
	           CNT variables.

	10/09/06 - KELLYP - CR 23512
		   Modified the FEETSO section to remove the SEQ parameter and
		   removed the same parameter in the calls to FEETSO from APPLY
		   and APPLYFEE.  This corrects an UNDEFINED error on the SEQ
		   variable when applying payments to a loan that has fees in
		   the payment string.  SEQ was TR(SEQ) which is no longer used.

	09/25/06 - KELLYP - CR 23237
		   Modified DCC section to perform date-based comparisons
		   instead of year-based comparisons for updating delinquency
		   counters.  This prevents problems where the prior-year
		   buckets were not updated correctly for transactions EFD'd
		   for the previous financial year.

	09/19/06 - KELLYP - CR 22898
		   Multiple changes to get payment application to work properly:

		   . Modified PDC section to return the appropriate ln.ppdcat*
		   number.  The code was previously always returning the first
		   category number because it was comparing the payment due
		   status (numeric) to the path (string) instead of comparing 
		   it to the path's corresponding status (numeric).  

		   . Modified IDP1 to save the lnbil1 record after changing the
		   amount due back to 0 for IDP=1 loans.  Changes made to lnbil1
		   records by the IDP1 section were never filed causing integs.
		   
		   . Modified PPF section to pass BSEQ instead of BSEQ+1 to PDC 
		   (apparent typo from conversion).
		   
		   . Modified IND0 section to remove change made under CR 22415
		   below and removed the LNBIL1 (bill sequence) variable from 
		   the IND0 section entirely in favor of just using the ND var.
		   (which is how it used to work).

	09/05/06 - KELLYP - CR 22796
		   Modified IDP1 section to pass the third parameter to 
		   SETELMT^BILFUNCS to correct an UNDEFINED error that occurred
		   when applying payments and LN.IDP=1.  Modified IDP0 section
		   to put a tab at the front of the ROW variable.  This prevents
		   a problem where the system was not finding "I" at the front of
		   the ROW string because it was not preceded by a tab. 

	08/02/06 - KELLYP - CR 22318
		   Modified START section to remove TPART restriction check.
		   This restriction check is being moved to OVR^LNPTS1 so that
		   any transactions (not just payments) that affect the balance
		   of a loan have the restriction returned when ln.tflg=1.

	07/28/06 - KELLYP - CR 22415
		   Modified IND0 section to prevent an infinite loop that 
		   occurred when processing advance loan payments to a loan
		   that used online bill generation and horizontal paths for 
		   all due categories.  The system should treat the "Advance"
		   category as vertical for current loans with online bills
		   being generated.  It was trying to do so, but was quitting 
		   out of NEXTELMNT instead of going back into IND0 with the
		   IND variable equal "v".

	06/15/06 - KELLYP - CR 20910
		   Modified the conditions under which the top level stops 
		   calling the START section.  Also modified the START section
		   to declare the DONE flag as public so that it can be set
		   under certain situations.  These changes were made to 
		   preserve the changes made under CR 21025 noted below but
		   to correct an issue where payments to revolving accounts
		   w/o the on-line bill generation flag enabled resulted in
		   infinite loops.

	05/04/06 - KELLYP - CR 21025
		   Modified the top level to change the conditions under which
		   the DONE flag is set.  The code was quitting when REMAIN=0 
		   which prevented the generation of multiple on-line bills.

	04/28/06 - chhabris - CR20486
		   Modified INT section to subtract subsidy amount from the 
		   total interest accrued. This will reflect when a payment
		   is made for the bills for subsidy loan accounts.

	03/27/06 - KELLYP - CR 20341
		   Modified PPF section to return 0 when PPF is null.  This 
		   prevents infinite loops from occurring when processing a 
		   backdated loan payment against a loan account that had a 
		   payment element added (non-EFD) after the account was opened.
		   The LNBIL0 and LNBIL1 records will contain the additional 
		   payment element, but the LN.PPDCAT* fields will not since the 
		   FM's logged to HIST for these columns are unwound.  This 
		   caused PC not to get bumped so the PPF section got called 
		   over and over again for the payment element that was added.

	03/15/06 - KELLYP - CR 20132
		   Modified PPF section to make the PC variable public to correct
		   an UNDEFINED error.  PC should be public as it is set by 
		   labels that call into PPF and PPF doesn't define it.

	03/02/06 - TITOVE - CR 19733
		   Modified GETPRCNT section to instantiate an LNFEEP object with
		   a "create-if-needed" qualifier.

	02/09/06 - KinI - CR19503
		   Modified ZAMT section to send lnbil1 record to EXEC^LNBLDE.	
	
	02/03/06 - KELLYP - CR 19343
		   Modified PE section to protect the BILL5 reference with a 
		   .get().  This prevents an UNDEFINED error that would occur
		   under certain situations.  The BILL5 array structure 
		   referenced isn't always defined so it was appropriate to
		   protect this with a .get().
	
	01/28/06 - SmithCD - CR 19343 (19343)
		   . Fixed ESCTRN section to prevent undefined error on TYPE, 
		     to use escrow account information instead of loan account
		     information, and to pass %EffectiveDate to POST^LNTRB so 
		     the transaction is filed into history with an effective 
		     date
		   . Corrected typo on INTTX in section INTDEFTX
		   . Removed code involving TOLFLG ($$TOLCAL^LNPTS2 no longer 
		     exists)
		   . Performed some cleanup, including reducing reliance on 
		     local variables, to simplify code

	01/13/06 - KELLYP - CR 19018
		   Modified ZAMT section to use BSEQ instead of I (which was null)
		   when retrieving LNBIL5 records.  This prevents an "Insufficient 
		   Values" Oracle error.  Also removed pre-2003 revision history.

	12/21/05 - TELIV - CR 17251
		   Modified Section INTDEF to initialize variables PEOAB and PEOAD.
		   The variables were earlier defined as public, should have been 
		   local to INTDEF

	09/02/05 - TITOVE - CR 16844
		   Modified IAM section to pass four new arguments to
		   TP^LNAMOAO1.

	08/29/05 - KinI - 16715
		   Modified PE section to start looping through the bills 
		   collecting total due starting from OSEQ instead of BILLSEQ.

	05/06/05 - KinI - 15524
		   Modified APPLY section to replace lnbil1.bp1 piece with 
		   direct lnbil1 sub-field update per DBI standards.
	  	   Modified IDP0 section to set V variable before setting
	  	   amount due into "I" and "P" payment elements.
	  	   Made DCC public section and declared DCC(), DL(), DY(), 
	  	   DP(), FRE, PRETRN() as public.
	  	   Modified START section to select the bills based on 
	  	   SCHSEQ<=:I (not SCHSEQ>=:I) condition in order to get
	  	   all current bills and not only the last one.
	  	   Modified CNTCR section to remove lnbil() parameter as this
	  	   section is called from other places where lnbil() array is
	  	   not specifically built.
	  	   
	08/01/04 - GEORGES - CR8447
		   Modified FILE^LNPTS3 to pass "CID" instead of "ID"
		   to FEEDUE^LNFEEU. Modified code to remove warning
		   messages during compilation. 
	
	  -----------------------------------------------------------------------
	*/

	type public Boolean ER, PF
	type public Number ZAMT
	
	type literal String TAB = $char(9)
	
	type Date FINB, FINE, SAVDIST, TAXB, TAXE
	type Number BILLAMT = 0, OLDSEQ, REMAIN = 0
	type Boolean DONE = 0

	
	for  do { quit:ER ! (DONE)
		do START(.ln, .ttx, .trn) quit:((ER)!(DONE))
		
		if (BILLAMT),(ZAMT'<BILLAMT) quit 	// Repeat the loop
		
		set DONE=1	// DONE also set in START under some scenarios
		}
		
	quit

	
public START(RecordLN ln,		// Loan account			/REF:RW
	     RecordTTX ttx,		// Transaction			/REF:R
	     RecordTRN trn) 		// Transaction code		/REF:R
	
	type public String OVR(,,), PRETRN()
	type public Number BILLAMT, REMAIN, ZAMT
	type public Boolean DONE, ER, PF, RFLAG

	type RecordLNBIL1 lnbil1()
	type RecordLNBIL5 lnbil5()
	type String AM(), DATA, FEETYP, IND, LNERC, UTSO()
	type Number BALCMP, BILL(), BILL5(,,), BILLSEQ, BILL5SEQ
	type Number DUEAMT, IAMAMT, LASTSEQ, LIM, ND, PC, PDC, PDS
	type Boolean STDONE = 0
	
	set (BILLSEQ, BILL5SEQ) = 0
	
	do INIT(.ln)
	
	type RecordLNBIL0 lnbil0 = Db.getRecord("LNBIL0", "CID=:ln.cid")

	do LNKFEE^LNBLDE(ln.cid)
	
	// Save Daily Late Charge Action flag into error correct save
	if ln.dlcaf do {
		set LNERC = ttx.lnerc
		set LNERC.piece("#", 8) = 1
		set ttx.lnerc = LNERC
		}
	
	do OUT^UTSO(.UTSO(), ttx.tso)
	if 'UTSO("PE").get().isNull() set PF = 0
	
	set PDS = $$PDS^LNUBIL1(ln.dseq, ln.schseq)	// Payment due status
	set PDC = $$PDC(ln.dseq, .ln)			// Payment due category	
	
	// Always load in current payment file records (bill records)
	set LASTSEQ = $select(ln.schseq > ln.oseq:ln.schseq, 1:ln.oseq)
	if ln.bseq > LASTSEQ set LASTSEQ = ln.bseq

	// Load internal bill detail records
	type ResultSet rs = Db.select("SCHSEQ", "LNBIL1", "CID=:ln.cid AND SCHSEQ<=:LASTSEQ")
	while rs.next() do {
		set BILLSEQ = rs.getCol("SCHSEQ")
		set lnbil1(BILLSEQ) = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:BILLSEQ")
		set BILL(BILLSEQ) = ""
		}

	// Load internal bills for loan fees		
	type ResultSet rs1 = Db.select("SCHSEQ,DUEAMT,FEETYP", "LNBIL5", "CID=:ln.cid AND SCHSEQ<=:LASTSEQ")
	while rs1.next() do {
		set BILL5SEQ = rs1.getCol("SCHSEQ")
		set DUEAMT = rs1.getCol("DUEAMT")
		set FEETYP = rs1.getCol("FEETYP")
		set lnbil5(BILL5SEQ) = Db.getRecord("LNBIL5", "CID=:ln.cid,SCHSEQ=:BILL5SEQ,DUEAMT=:DUEAMT,FEETYP=:FEETYP")
		set BILL5(BILL5SEQ,DUEAMT,FEETYP) = BILL5SEQ
		}

	if 'BILLSEQ set BILLSEQ = LASTSEQ
	if 'BILL5SEQ set BILL5SEQ = LASTSEQ

	// Adjust ZAMT to required payment amount
	do ZAMT(.ln, .ttx, .lnbil1(), .lnbil5(), .BILL5(,,)) quit:ER  

	if 'REMAIN set DONE=1 quit

	// Used by TP^LNAMOAO1
	set IAMAMT = REMAIN
	
	// RFLAG = 1 indicates loan payment sweep
	if 'RFLAG.get() do {
		// Partial payment requires approval
		if 'PF, 'ln.paf set OVR(ln.cid, "OVR", "PPA") = ""
		// Excess payments require approval
		if PF, 'ln.epa, ZAMT > (ln.dpmt - ln.ppa) set OVR(ln.cid, "OVR", "EPA") = ""
		}

	// For bills where IDP=1, set up P and I
	do IDP0(.ln, .lnbil1(), .lnbil0) quit:ER 
	
	set (ND, PC) = 0
	for  do { quit:ER ! (STDONE)
		do APPLY(.ln, .lnbil1(), .ttx, .lnbil0, .lnbil5(), .BILL5(,,)) quit:ER
		
		if IND = "*" ! ('REMAIN) ! (DATA.isNull()) set STDONE = 1
		}
	if ER quit 

	// For bills where IDP = 1, remove P and I
	do IDP1(.lnbil1(), .lnbil0) quit:ER 
	
	// Low balance condition
	set BALCMP = ln.bal
	if ln.aruf set BALCMP = BALCMP - ln.udbal
	if BALCMP '> 0 do LBF^LNPTSU(.ln, BALCMP) quit:ER 
	
	if (PRETRN("BALCMP") '> 0),(ln.bal > 0) set ln.habl2 = BALCMP
	
	do FILE(.ln, .ttx)
	
	do PMTSCH(.ln, .ttx, .trn)
	
	do IAM(.ln, .ttx, .lnbil1())

	// Payment is complete - now reset LN variables
	do RESET(.ln, .lnbil1()) 
	
	set BILLAMT = 0
	
	if ln.bseq '< LIM set DONE=1 quit
	
	if PF,PDS > 0, ZAMT set BILLAMT = $$AMT^LNBLDE(.ln, .ttx, ln.cid)

	quit 

	
ZAMT(RecordLN ln,		// Loan account				/REF:RW
     RecordTTX ttx,		// Transaction				/REF:R
     RecordLNBIL1 lnbil1(),	// Internal bill detail			/REF:
     RecordLNBIL5 lnbil5(),	// Internal bill for loan fees		/REF:
     Number BILL5(,,))		// Internal bill for loan fees seqs	/REF:

	/*	
	Adjust ZAMT for required payment amount

	   DESC: REMAIN is the amount remaining to be applied.
	         Adjust it as follows:
	
	           o If this is a partial payment (PF=0), set it to ZAMT,
	             unless a $0 future bill was generated, in which case
	             set it to zero because in this case there are no more
	             payment elements to apply it to.
	           o If this is a full payment, adjust it according
	             to the amount to be paid within the appropriate
		     payment due category	
	*/
	
	type public Boolean ER
	type public String BILL(), OVR(,,), STBL(,), UTSO()
	type public Number BILL5SEQ, BILLSEQ, LIM, PDC, PDS, PF
	type public Number REMAIN, ZAMT
	
	type Boolean REMOVE = 0
	type Number BILLNUM

	if 'ln.limit.isNull() set LIM = ln.schseq + ln.limit
	else  set LIM = 9999
	
	// Full payment
	set REMAIN = ln.dpmt - ln.ppa
	if PF, (ZAMT < REMAIN) set REMAIN = 0 quit

	if 'UTSO("PE").get().isNull() set REMAIN = $$PE(.ln, .lnbil1(), .lnbil5(), .BILL5(,,))

	set BILLNUM = ln.dseq
	for  set BILLNUM = lnbil1(BILLNUM).order() quit:BILLNUM.isNull()  do { if BILLNUM = $select(LIM < ln.bseq:LIM, 1:ln.bseq) quit 
		if $$PDC(BILLNUM, .ln) = PDC,REMAIN + lnbil1(BILLNUM).ctab '> ZAMT set REMAIN = REMAIN + lnbil1(BILLNUM).ctab
		}
	
	if 'PF, ZAMT < REMAIN set REMAIN = ZAMT
	
	// Can on-line bills be generated?
	if PF, 'REMAIN, STBL("PCM", ln.pcm).extract(5) do { quit:ER
		if ln.bseq '< LIM quit
		if PDS < 0 quit
		
		type RecordLNBIL1 bil1=Class.new("RecordLNBIL1")
		
		do EXEC^LNBLDE(.ln, .ttx, ln.cid, %SystemDate, 1, .bil1) quit:ER

		type ResultSet rs = Db.select("SCHSEQ", "LNBIL1", "CID=:ln.cid AND SCHSEQ>=:ln.bseq")
		while rs.next() do {
			set BILLSEQ = rs.getCol("SCHSEQ")
			set lnbil1(BILLSEQ) = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:BILLSEQ")
			set BILL(BILLSEQ) = ""

			if 'lnbil1(ln.bseq).ctab ! ((REMAIN + lnbil1(ln.bseq).ctab) > ZAMT) set REMOVE = 1
			else  set REMAIN = REMAIN + lnbil1(ln.bseq).ctab

			if REMOVE do {
				do REMOVE^LNBLDE(.ln, BILLSEQ)
				kill BILL(BILLSEQ)
				kill lnbil1(BILLSEQ)
				}
			}
		}	
		
	// Calculate partial payment bills
	if 'PF, (ln.oseq > ln.bseq), STBL("PCM", ln.pcm).extract(5) do {
		if ln.bseq '< LIM quit 
		
		type RecordLNBIL1 bil1=Class.new("RecordLNBIL1")
		
	  	do EXEC^LNBLDE(.ln, .ttx, ln.cid, %SystemDate, 1, .bil1) quit:ER

		// Load internal bill detail records
		type ResultSet rs = Db.select("SCHSEQ", "LNBIL1", "CID=:ln.cid AND SCHSEQ>=:ln.bseq")
		while rs.next() do {
			set BILLSEQ = rs.getCol("SCHSEQ")
			set lnbil1(BILLSEQ) = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:BILLSEQ")
			set BILL(BILLSEQ) = ""
			
			// Allow partial bill satisfaction but don't allow
			// $0 bill generation
			if 'lnbil1(ln.bseq).ctab set REMOVE = 1
			else  set REMAIN = REMAIN + lnbil1(ln.bseq).ctab

			if REMOVE do {
				do REMOVE^LNBLDE(.ln, BILLSEQ)
				kill BILL(BILLSEQ)
				kill lnbil1(BILLSEQ)
				}
			}

		// Load internal bills for loan fees		
		type DbSet ds = Db.selectDbSet("LNBIL5", "CID=:ln.cid AND SCHSEQ>=:ln.bseq")
		set BILL5SEQ = 1
		while ds.next() do {
			set lnbil5(BILL5SEQ) = ds.getRecord("LNBIL5")
			set BILL5(lnbil5(BILL5SEQ).schseq, lnbil5(BILL5SEQ).dueamt, lnbil5(BILL5SEQ).feetyp) = BILL5SEQ
			set BILL5SEQ = BILL5SEQ + 1
			}
			
		if 'UTSO("PE").get().isNull() set REMAIN = $$PE(.ln, .lnbil1(), .lnbil5(), .BILL5(,,))
		else  set REMAIN = ln.dpmt - ln.ppa
		if ZAMT < REMAIN set REMAIN = ZAMT
		}

	// Extent of due date advance requires approval	
	if 'ln.olimit.isNull(), ln.bseq > (ln.schseq + ln.olimit) set OVR(ln.cid, "OVR", "OLIMIT") = ln.olimit

	quit 

	
NXTELMNT(RecordLN ln,			// Loan record			/REF:R
	 RecordLNBIL1 lnbil1(),		// Internal bill detail		/REF:R
	 RecordLNBIL0 lnbil0,		// Internal bill control	/REF:R
	 Number ND,			// Bill node 
	 Number PC)			// Piece of bill node

	// Find next element based upon path indicators

	type public Number MAXPC, MINPC
	type public String IND
	
	type literal String TAB = $char(9)

	type String DATA, ROW
	type Number NUMELEMNT, ROWPC
	
	set ND = ND.get() 
	set PC = PC.get()

	// Strip blanks from ROW (0-level of bill)
	set ROW = $$ELEMENT^BILFUNCS(.lnbil0)
	set NUMELEMNT = ROW.length(TAB)
	for ROWPC = NUMELEMNT:-1:1 if ROW.piece(TAB, ROWPC).isNull() set ROW = ROW.piece(TAB, 1, ROWPC - 1) else  quit
	set NUMELEMNT = ROW.length(TAB)

	// If ND and PC not defined, return first element from first due bill
	if 'ND, 'PC do {
		set PC = NUMELEMNT
		set IND = "v"
		set MAXPC = 99
		set MINPC = 1
		}
	
	if IND = "*" quit ""
	for  set DATA = $$IND0(.ln, .lnbil1(), .lnbil0)  quit:DATA '= -100

	quit DATA

	
IND0(RecordLN ln,			// Loan account
     RecordLNBIL1 lnbil1(),		// Internal bill detail
     RecordLNBIL0 lnbil0)		// Internal bill control
	
	type public String BILL(), ELMNT, IND
	type public Number MAXPC, MINPC, ND, NUMELEMNT, PC, PDC
	
	type String DATA
	
	// Vertical
	if IND = "v" do {
		set PC = PC + 1 
		if PC > NUMELEMNT do {
			set ND = BILL(ND).order()
			set PC = 1 
			if PC < MINPC set PC = MINPC
			set ln.oseq = ND
			}
		if PC > MAXPC do {
			set MINPC = PC 
			set MAXPC = 99 
			set ND = ln.oseq
			}
		}

	// Horizontal	
	if (IND = ">") ! (IND = "#") do {
		set MAXPC = PC
		set PC = MINPC 
		set ND = BILL(ND).order()
		if ND.isNull() do {
			set ND = ln.oseq
			set (MINPC, PC) = MAXPC + 1 
			set MAXPC = 99
			}
		}

	if IND = "#", ($$PDC(ND, .ln) > PDC) do {
		set ND = ln.oseq
		set (MINPC,PC) = MAXPC + 1 
		set MAXPC = 99
		}

	if ND.isNull() set IND = "v" quit ""

	set ELMNT = $$GETELEMENT^BILFUNCS(PC, .lnbil1(ND))
	
	set IND = $$PPF(.ln, .lnbil1(ND), ELMNT, ND)
	if IND = 0 set IND = "v" quit -100
	
	set DATA = $$GETFIELD^BILFUNCS(PC, .lnbil1(ND))	

	quit DATA

	
PE(RecordLN ln,			// Loan account
   RecordLNBIL1 lnbil1(),	// Internal bill
   RecordLNBIL5 lnbil5(),	// Internal bill for loan fees
   Number BILL5(,,))		// Internal bill for loan fees seqs

	// Return total that can be applied toward "PE"
	
	type String BIL5
	type Number ND, TOT
	type public String UTSO()

	set ND = ln.oseq - 0.000000000001	// Start collating from OSEQ
	set TOT = 0
	for  set ND = lnbil1(ND).order() quit:ND.isNull()  quit:(ND > ln.bseq)  do {
		// lnbil1 record
		set TOT = TOT + $$AMTDUE^BILFUNCS(.lnbil1(ND), UTSO("PE"))
		set BIL5 = BILL5(ND, 1, UTSO("PE").get()).get()
		if BIL5 set TOT = TOT + lnbil5(BIL5).brfamt
		}

	quit TOT	


INIT(RecordLN ln)		// Loan account				/REF:R

	// Initialization
	
	type public Date CUVAR2, FINB, FINE, SAVDIST, TAXB, TAXE
	type public Number OLDSEQ
	type public String STBL(,)
	
	// Financial year beginning	
	set FINB = $$BOFY^SCADAT(CUVAR2, 1)

	// Financial year end
	set FINE = $$EOFY^SCADAT(CUVAR2, 1)

	// Tax year beginning
	set TAXB = $$BOTY^SCADAT(CUVAR2, 1)

	// Tax year end	
	set TAXE = $$EOTY^SCADAT(CUVAR2, 1)

	// Payment Calculation Method
	if 'STBL("PCM", ln.pcm).exists() do {
		type RecordSTBLPCM stblpcm = Db.getRecord("STBLPCM", "KEY=:ln.pcm")
		set STBL("PCM", ln.pcm) = stblpcm.pcmp
		}

	// Load previously satisfied bills with payment tolerance amounts
	do PAYTOLIN(.ln)

        // Internal Bill Seq Nbr Next Due Date
        set OLDSEQ = ln.dseq
	
	set SAVDIST = ln.dist1nd

	quit 

	
PDC(Number BSEQ,		// Billing - last sequence number
    RecordLN ln)		// Loan account				/REF:R

	// Return payment due category of this bill record
	
	type Number CATEGORY, NUMCAT, PDS
	type String PPDCAT
	
	set PDS = $$PDS^LNUBIL1(BSEQ, ln.schseq)

	set PPDCAT = ln.ppdcat1_"|"_ln.ppdcat2_"|"_ln.ppdcat3_"|"_ln.ppdcat4
	set PPDCAT = PPDCAT_"|"_ln.ppdcat5_"|"_ln.ppdcat6_"|"_ln.ppdcat7
	set PPDCAT = PPDCAT_"|"_ln.ppdcat8_"|"_ln.ppdcat9_"|"_ln.ppdcat10

	set NUMCAT=+ln.npc

	// Need to compare PDS to status in PPDCAT string, not to path
	//  e.g., PPDCAT = I-#-P-#|I->-P->|I-v-P-v|-2|-1|999||||
	//   So need to loop through pieces 4 through 6, not 1 through 3
	for CATEGORY = 1:1:NUMCAT if PDS '> PPDCAT.piece("|", CATEGORY+NUMCAT) quit 

	quit CATEGORY

	
APPLY(RecordLN ln,		// Loan account
      RecordLNBIL1 lnbil1(),	// Internal bill detail
      RecordTTX ttx,		// Transaction
      RecordLNBIL0 lnbil0,	// Internal bill control
      RecordLNBIL5 lnbil5(),	// Internal bill for loan fees
      Number BILL5(,,))		// Internal bill for loan fees seqs

	// Apply REMAIN amount towards payment file
	
	type public Number APPLY, CTAB, FACTOR, ND, PC, TOTELMNT
	type public Number REMAIN, ZAMT
	type public String AM(), DATA, ELMNT, ESCELMT, LTC, UTSO()

	type Number VATAMT
	type String PRCNT()
	type String APPLIED = 0
	
	set DATA = $$NXTELMNT(.ln, .lnbil1(), .lnbil0, .ND, .PC) 
	if DATA.isNull() quit
	
	set ELMNT = DATA.piece("#", 1)

	/*
	======================================================================	
	The following lines will prove very useful when debugging payment
	processing and following the path a payment will take when it
	calculates the next element to process, and for which payment record.
	
	It will display the bill record, "piece" within the payment record
	and the elemnt being processed.  It will then prompt for the
	carriage return.  USE THIS ONLY IN A TESTING ENVIRONMENT !
	Do not leave these lines uncommented within a production
	environment.
	
	do {
		type String X
		write !,ND," ",PC," ",DATA R X
		}
		
	=======================================================================
	*/

	set TOTELMNT = 0
	if UTSO("PE").get() = ELMNT ! (UTSO("PE").get().isNull()) set TOTELMNT = DATA.piece("#",4)
	
	do GETPRCNT(ELMNT, TOTELMNT, 1, .TOTELMNT, .lnbil5(), .BILL5(,,)) 

	set FACTOR = 1 	
	
	// Regular payment, not a direct "only" transaction
	if ('LTC.get().isNull())&(ttx.etc'=LTC)&(ELMNT = "I") do {
		
		// Process VAT on Interest element
		
		type RecordLNBIL5 lnbil5 = Db.getRecord("LNBIL5", "CID = :ln.cid, SCHSEQ = :ND, DUEAMT = 0, FEETYP = 'VI'",1)
		set VATAMT = lnbil5.brfamt		
		
		if 'VATAMT quit
		
		// Apply payment to Interest element and VAT on Interest 
		// proportionally, if applicable
		do PROVATPMT^LNPTSU(.ln, .ttx, .TOTELMNT, .VATAMT)
		
		// Update VAT on Interest
		do UPDVAT(.ln, .ttx, VATAMT)
		
		set REMAIN = REMAIN - VATAMT
		}
		
	if 'TOTELMNT quit
	
	set APPLY = TOTELMNT
	if APPLY > REMAIN do {
		set APPLY = REMAIN
		if UTSO("PE").get().isNull() set FACTOR = APPLY / TOTELMNT
		}
		
	set REMAIN = REMAIN - APPLY 
	set ZAMT = ZAMT - APPLY
	
	set CTAB = DATA.piece("#", 4)
	if 'CTAB set CTAB = APPLY
	if 'UTSO("PE").get().isNull(), UTSO("PE") '= ELMNT set CTAB = APPLY
	do APPLYFEE(.ln, .lnbil5(), .ttx, ELMNT, (CTAB * FACTOR), .BILL5(,,))
	
	if ln.iam, ELMNT = "P" set AM(ND).piece("|", 2) = AM(ND).get().piece("|", 2) + APPLY
	
	set lnbil1(ND).casd = lnbil1(ND).casd - APPLY
	set APPLY = APPLY - APPLIED
	
	set DATA.piece("#", 4) = DATA.piece("#", 4) - APPLY
	do SETELMT^BILFUNCS(lnbil1(ND), PC, DATA)
		
	if (ELMNT = "I") ! (ELMNT = "P") set lnbil1(ND).cpid = lnbil1(ND).cpid - APPLY

	do lnbil1(ND).bypassSave()

	if Db.isDefined("LNFEE", "CID=:ln.cid,FEETYP=:ELMNT") do {	
		do FEETSO(.ttx, APPLY, ELMNT)
		do FEEUPD^LNPTS13(.ln, ELMNT, APPLY, 0)
		}
	
	if APPLY do %HSEQ^LNPTSU(.ttx, ND_"#"_ELMNT_"#"_APPLY)
	
	// Update TAMT positions
	do {
		if ELMNT = "P" do PRN(.ln, .ttx, APPLY) quit 
		if ELMNT = "I" do INT(.ln, .ttx, .lnbil1(), APPLY) quit 
		
		set ESCELMT = $$BIL0^BILFUNCS(.lnbil0, ELMNT)
		
		if ESCELMT.piece("#", 2) do { quit 
			do GL^LNPTSU(.ttx, APPLY, 7)
			do ESCTRN(.ln, .ttx, APPLY, ESCELMT)
			}
		do GL^LNPTSU(.ttx, APPLY, 6) quit 
		}
	
	type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP=:ELMNT", 1)
	if lnfeep.basis.isNull() do FEEDUE^LNFEEU(.ln, .ttx, ln.cid, 2, "11001", %EffectiveDate, "", APPLY, ELMNT, LTC, , ND)

	quit 

	
PRN(RecordLN ln,		// Loan account			/REF:RW
    RecordTTX ttx,		// Transaction			/REF:R
    Number AMT)			// Pincipal amount
    
	// Update principal
	
	if ln.revf set ln.udbal = ln.udbal + AMT
	if   if ln.aruf do GL^LNPTSU(.ttx, AMT, 5) quit
	
	set ln.bal=ln.bal - AMT 
	
	#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
		if ln.segments do PAYBAL^LNSEG(.ln, .ttx, AMT, 0)
	#ENDIF
	
	set ln.balcol=ln.balcol - AMT
	
	do GL^LNPTSU(.ttx, AMT, 2)
	
	if 'ln.idgp.isNull() do IDGP^LNPTS4(.ln, AMT)

	quit 

	
INT(RecordLN ln,		// Loan account			/REF:RW
    RecordTTX ttx,		// Transaction			/REF:R
    RecordLNBIL1 lnbil1(),	// Internal bill detail		/REF:W
    Number AMT)			// Interest amount
    
    	// Update interest
	
	type public Boolean DUI
	type public Date CUVAR2, FINB, TAXB
	
	set ln.acr = ln.acr - AMT - ln.subamt
	
	#IF ('CUVAR.NOSEGMENTS!(CUVAR.NOSEGMENTS=3))!($$SEGUSE^BTTOPTMZ("L"))
		if ln.segments do PAYACR^LNSEG(.ln, .ttx, AMT)
	#ENDIF
	
	set ln.ipl = ln.ipl + AMT
	
	/*
	  If decreasing unpaid interest, and Recognize Paid Int During 
	  Capitalization is not selected, don't update
	*/
	if 'DUI.get()!(DUI.get()&(ln.rpidc)) do {
		if (CUVAR.YEOFF) & (%EffectiveDate < FINB) & (CUVAR2 '> (FINB + CUVAR.YEOFF - 1)) set ln.ipy = ln.ipy + AMT
		else  set ln.iytd = ln.iytd + AMT
	
		if (CUVAR.TAXYEOFF) & (%EffectiveDate < TAXB) & (CUVAR2 '> (TAXB + CUVAR.TAXYEOFF-1)) set ln.ipty = ln.ipty + AMT
		else  set ln.itytd = ln.itytd + AMT
		}	
	
	do GL^LNPTSU(.ttx, AMT, 3)
	
	do INTDEF(.ln, .lnbil1())

	quit 

	
INTDEF(RecordLN ln,			// Loan account			/REF:RW
       RecordLNBIL1 lnbil1())		// Internal bill detail		/REF:W

	type public Boolean ER
	type public Date CUVAR2, FINB, FINE
	type public String SUBELE, STBL(,)
	type public Number AMT, ND

	type Date DUEDT, FD, TD
	type Number FACTOR, INT, PEOAB, PEOAD
	
	set (PEOAB, PEOAD) = ""	
	
	/*
	 Do not calculate ln.intdef and ln.intdeftytd if not calculated interest 
	 and not anticipated.  E.g. do not calculate if paying the accrual 
	 balance.
	*/
	if 'STBL("PCM", ln.pcm).extract(2), 'STBL("PCM", ln.pcm).extract(4) quit

	// Calculate ln.intdef
	// Find period being satisfied (FD to TD)

	set DUEDT = lnbil1(ND).cdpd

	if 'ln.icm set TD = DUEDT - 1 quit:TD '> FINE  do {
		type Number LAST = lnbil1(ND).order(-1)
		if 'LAST do {
			set LAST = ND - 1
			if LAST < 1 quit
			set lnbil1(LAST) = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:LAST", 1)
			}
		if LAST set FD = lnbil1(LAST).cdpd quit 
		set FD = DUEDT.nextFreqDate(ln.dist1fre,,1) quit:ER 
		}
		
	if ln.icm set FD = DUEDT do { quit:TD '> FINE 
		type Number NEXT = lnbil1(ND).order()
		if 'NEXT do {
			set NEXT = ND + 1
			set lnbil1(NEXT)=Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:NEXT", 1)
			}
		if lnbil1(NEXT).getMode() do { quit
			set TD = lnbil1(NEXT).cdpd - 1
			}
		set TD = DUEDT.nextFreqDate(ln.dist1fre) quit:ER 
		}
	
	set FACTOR = 1
	if FD '> FINE do {
		type Number PEOAD, PEOAB, CURYRINT, AMTSAT, NXTYRINT
		
		set FACTOR = (TD - FINE) / (TD - FD + 1)
	
		/*
		The following code will determine the amount of the interest
		payment that should be credited for current fin. yr's int vs. 
		next fin. yr's int.  The code's intent is to set variable INT,
		which reflects the amount of interest deferred until the next
		fin. year.  INT is set once the current fin. year's exected 
		interest amount has been satisfied.
		*/

		set SUBELE = $$SUB^BILFUNCS("I", .lnbil1(ND))

		// Total Int Amt Billed
		set PEOAB = SUBELE.piece("#", 3)

		// Amt of Billed Int still due
		set PEOAD = SUBELE.piece("#",4)

		// Total possible next fin year int
		set NXTYRINT = (PEOAB * FACTOR).roundCur()

		// Total possible current fin year int
		set CURYRINT = PEOAB - NXTYRINT

		// Bill Amt already satisifed
		set AMTSAT = PEOAB - PEOAD - AMT
		if AMTSAT '< CURYRINT set INT = AMT quit 
		if AMTSAT < CURYRINT do { quit 
			if (AMTSAT + AMT) '>CURYRINT set INT = 0 quit 
			if (AMTSAT + AMT) >CURYRINT set INT = AMTSAT + AMT - CURYRINT
			}
		}
	else  set INT = AMT * FACTOR set INT = INT.roundCur()
	
	set ln.intdef = ln.intdef + INT
	if (CUVAR.YEOFF) & (%EffectiveDate < FINB) & (CUVAR2 '> (FINB + CUVAR.YEOFF-1)) set ln.ipy = ln.ipy - INT
	else  set ln.iytd = ln.iytd - INT

	// Calculate Tax Year Interest Deferred
	do INTDEFTX(.ln, PEOAB, PEOAD)

	quit 



INTDEFTX(RecordLN ln,		// Loan account				/REF:R
	 Number PEOAB,		// Payment element amount billed
	 Number PEOAD)		// Payment element amount due

	// Calculate ln.intdeftytd

	type public Number AMT, FACTOR
	type public Date CUVAR2, FD, TAXB, TAXE, TD

	type String FACTORTX, INTTX

	quit:TD '> TAXE

	set FACTORTX = 1
	
	if FD '> TAXE do {
		type Number AMTSAT, CURTXYRI, NXTTXYRI
		set FACTORTX = (TD - TAXE) / (TD - FD + 1)
 
		/*
		The following code will determine the amount of the interest
		payment that should be credited for current tax yr's int vs.
		next tax yr's int.  The code's intent is to set variable INTTX,
		which reflects the amount of interest deferred until the next
		tax year.  INTTX is set once the current tax year's exected
		interest amount has been satisfied.
		*/
 
		// Total possible next tax year int
		set NXTTXYRI = (PEOAB * FACTOR).roundCur()

		// Total possible current tax year int
		set CURTXYRI = PEOAB - NXTTXYRI

		// Bill Amt already satisifed
		set AMTSAT = PEOAB - PEOAD - AMT
		if AMTSAT '< CURTXYRI set INTTX = AMT quit
		if AMTSAT < CURTXYRI do { quit
			if (AMTSAT + AMT) '> CURTXYRI set INTTX = 0 quit
			if (AMTSAT + AMT) > CURTXYRI set INTTX = AMTSAT + AMT - CURTXYRI
			}
		}
	else  set INTTX = (AMT * FACTOR).roundCur()
 
	set ln.intdeftytd = ln.intdeftytd + INTTX
	if (CUVAR.TAXYEOFF) & (%EffectiveDate < TAXB) & (CUVAR2 '> (TAXB + CUVAR.TAXYEOFF - 1)) set ln.ipty = ln.ipty - INTTX
	else  set ln.itytd = ln.itytd - INTTX	
	
	quit


INTIAM(RecordLN	ln,		// Loan account				/REF:RW
       RecordTTX ttx,		// Transaction				/REF:R
       Number AMT)		// Amount
	
	type public Number ER
	type public String STBL(,)
	type public Date FINE, SAVDIST
	
	type Number %SCHERN, INT1, INT2, FACTOR
	type Date FD, TD
	
	set ln.acr = ln.acr - AMT 
	set ln.ipy = ln.ipy + AMT 
	set ln.iytd = ln.iytd + AMT
	set ln.itytd = ln.itytd + AMT
	
	do GL^LNPTSU(.ttx, AMT, 3)
	
	// Do not calculate ln.intdef and ln.intdeftytd if not calculated interest and 
	// not anticipated.  E.g. do not calculate if paying the accrual balance.

	if STBL("PCM", ln.pcm).extract(2), 'STBL("PCM", ln.pcm).extract(4) quit

	// Calculate ln.intdef
	set FD = SAVDIST.nextFreqDate(ln.dist1fre, ,1) quit:ER 
	set TD = ln.dist1nd.nextFreqDate(ln.dist1fre, , 1) - 1 quit:ER

	set FACTOR = 1
	if FD '> FINE, (TD > (FINE + CUVAR.YEOFF)) do {
		type Number %PMTREM, CNT
		type Date DATE, FDATE
		set CNT = 0 
		set DATE = FD
		// Find # of due dates
		for  do { quit:DATE > (FINE + CUVAR.YEOFF) 
			set FDATE = DATE
			set DATE = DATE.nextFreqDate(ln.dist1fre) quit:ER  
			set CNT = CNT + 1
			}

		// Total interest up to the end of the financial year
		set FACTOR = (DATE - (FINE + CUVAR.YEOFF)) / (DATE - FDATE)
		set %PMTREM = (ln.onp - (ln.cntcr + CNT)) + FACTOR

		type Number XIAM
		set XIAM = ln.iam.extract(2)
		if XIAM = 0 do 0^LNACR3 set INT1 = %SCHERN
		if XIAM = 1 do 1^LNACR3(.ln) set INT1 = %SCHERN
		if XIAM = 2 do 2^LNACR3(.ln) set INT1 = %SCHERN
		if XIAM = 3 do 3^LNACR3(.ln) set INT1 = %SCHERN
		if XIAM = 4 do 4^LNACR3(.ln) set INT1 = %SCHERN

		// Total interest up to to-date
		set %PMTREM = ln.onp - ln.cntcr
		if XIAM=0 do 0^LNACR3 set INT2 = %SCHERN
		if XIAM = 1 do 1^LNACR3(.ln) set INT2 = %SCHERN
		if XIAM = 2 do 2^LNACR3(.ln) set INT2 = %SCHERN
		if XIAM = 3 do 3^LNACR3(.ln) set INT2 = %SCHERN
		if XIAM = 4 do 4^LNACR3(.ln) set INT2 = %SCHERN

		set ln.intdef = ln.intdef + (INT2 - INT1) 
		set ln.intdef = ln.intdef.roundCur()
		set ln.iytd = ln.iytd - (INT2 - INT1) 
		set ln.iytd = ln.iytd.roundCur()
		}
	
	if FD > (FINE + CUVAR.YEOFF), (TD > (FINE + CUVAR.YEOFF)) do {
		set ln.intdef = ln.intdef + AMT
		set ln.iytd = ln.iytd - AMT
		}	

	do INTIAMTX(.ln, AMT, FD, TD)	// Tax year calculation

	quit 
	
  
INTIAMTX(RecordLN ln,		// Loan account				/REF:RW
	 Number AMT,		// Amount
	 Date FD,		// From date
	 Date TD)		// Thru date

	// Tax year calculation
	
	type public Number INT1, INT2
	type public Date TAXE
	type public Boolean ER

	type Number %SCHERN, FACTORTX
	
	set FACTORTX = 1
	if FD '> TAXE, (TD > (TAXE + CUVAR.TAXYEOFF)) do { quit:ER
		type Number CNT = 0, %PMTREM
		type Date DATE = FD, FDATE

		// Find # of due dates
		for  do { quit:DATE > (TAXE + CUVAR.TAXYEOFF)
			set FDATE = DATE
			set DATE = DATE.nextFreqDate(ln.dist1fre) quit:ER  
			set CNT = CNT + 1
			}

		// Total interest up to the end of the tax year
		set FACTORTX = (DATE - (TAXE + CUVAR.YEOFF)) / (DATE - FDATE)
		set %PMTREM = (ln.onp - (ln.cntcr + CNT)) + FACTORTX

		type Number XIAM
		set XIAM = ln.iam.extract(2)
		if XIAM = 0 do 0^LNACR3 set INT1 = %SCHERN
		if XIAM = 1 do 1^LNACR3(.ln) set INT1 = %SCHERN
		if XIAM = 2 do 2^LNACR3(.ln) set INT1 = %SCHERN
		if XIAM = 3 do 3^LNACR3(.ln) set INT1 = %SCHERN
		if XIAM = 4 do 4^LNACR3(.ln) set INT1 = %SCHERN

		// Total interest up to to-date
		set %PMTREM = ln.onp - ln.cntcr
		if XIAM = 0 do 0^LNACR3 set INT2 = %SCHERN
		if XIAM = 1 do 1^LNACR3(.ln) set INT2 = %SCHERN
		if XIAM = 2 do 2^LNACR3(.ln) set INT2 = %SCHERN
		if XIAM = 3 do 3^LNACR3(.ln) set INT2 = %SCHERN
		if XIAM = 4 do 4^LNACR3(.ln) set INT2 = %SCHERN
 
		set ln.intdeftytd = ln.intdeftytd + (INT2 - INT1)
		set ln.intdeftytd = ln.intdeftytd.roundCur()
		set ln.itytd = ln.itytd - (INT2 - INT1)
		set ln.itytd = ln.itytd.roundCur()
		}

	if FD > (TAXE + CUVAR.TAXYEOFF), (TD > (TAXE + CUVAR.TAXYEOFF)) do {
			set ln.intdeftytd = ln.intdeftytd + AMT
			set ln.itytd = ln.itytd - AMT
			}

	quit


ESCTRN(RecordLN	ln,		// Loan account				/REF:RW
       RecordTTX ttx,		// Primary transaction			/REF:R
       Number TAMT,		// Transaction amount
       String ESCELMT)		// Escrow element

	// Post secondary escrow transaction using the General Purpose Tran 
	// Code
	
	type public RecordDEP dep, dep()
	
	type Number ESCCID
	
	set ESCCID = ESCELMT.piece("#", 2)

	// Ensure we're using the correct dep object
	if 'dep.exists() ! (dep.exists() & (ESCCID '= dep.cid)) do {
		if dep(ESCCID).exists() set dep = dep(ESCCID)
		else  set dep = Db.getRecord("DEP", "CID=:ESCCID")
		}
	
	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE=:dep.type")

	// General Purpose Tran Code (escrow)
	do POST^LNTRB(.ttx, ESCCID, prodctl.crtrgp, TAMT, %EffectiveDate, %UserStation, , , dep.crcd)

	quit


IDP0(RecordLN ln,		// Loan account				/REF:R
     RecordLNBIL1 lnbil1(),	// Internal bill detail			/REF:RW
     RecordLNBIL0 lnbil0)	// Internal bill control		/REF:RW

	// Set prin and int breakdown into bills where IDP = 1

	type public String BILL(), DATA, ROW, STBL(,)
	
	type literal String TAB = $char(9)
	
	type Number BIL1, CPID, INT, NUM
	
	// Tab must appear in front of row for it to find "I"
	set ROW = TAB_$$ELEMENT^BILFUNCS(.lnbil0)
	if 'ROW.isLike("%"_TAB_"I"_TAB_"%"), 'ROW.isLike("%"_TAB_"P"_TAB_"%") quit
	
	set INT = $$UNPINT(.ln, .lnbil1())
	set INT = (ln.acr - INT).roundCur()
	if INT < 0 set INT = 0
	if STBL("PCM", ln.pcm).extract(2) = 3 set INT = ln.fia

	set NUM = 0
	for  set NUM = BILL(NUM).order() quit:NUM.isNull()  do { 
		set BIL1 = $$IDP(.lnbil1(NUM))
		if 'BIL1 quit
	
		set CPID = INT
		
		if ROW.isLike("%"_TAB_"I"_TAB_"%") do {
			if CPID > lnbil1(NUM).cpid set CPID = lnbil1(NUM).cpid
			
			if STBL("PCM", ln.pcm).extract(2) '= 3 set INT = INT - CPID
			
			set DATA = $$SUB^BILFUNCS("I",.lnbil1(NUM))
			set DATA.piece("#", 4) = CPID
			do SETELMT^BILFUNCS(.lnbil1(NUM), "I", DATA)
			}
			
		if ROW.isLike("%"_TAB_"P"_TAB_"%") do {
			set DATA = $$SUB^BILFUNCS("P", lnbil1(NUM))
			set DATA.piece("#", 4) = lnbil1(NUM).cpid - CPID
			
			do SETELMT^BILFUNCS(.lnbil1(NUM), "P", DATA)
			}
		}
	quit 
	
	
IDP1(RecordLNBIL1 lnbil1(),	// Internal bill detail			/REF:R
     RecordLNBIL0 lnbil0)	// Internal bill control		/REF:R

	// Remove prin and int breakdown from bills where IDP=1 after payment
	
	type literal String TAB = $char(9)
	
	type String ROW
	
	set ROW = $$ELEMENT^BILFUNCS(.lnbil0)

	if 'ROW.isLike("%"_TAB_"I"_TAB_"%"), 'ROW.isLike("%"_TAB_"P"_TAB_"%") quit
	
	type Number NUM = 0

	for  set NUM = lnbil1(NUM).order() quit:NUM.isNull()  do {  
		if '$$IDP(lnbil1(NUM)) quit
		do SETELMT^BILFUNCS(.lnbil1(NUM), "I", "I")
		do SETELMT^BILFUNCS(.lnbil1(NUM), "P", "P")
		
		do lnbil1(NUM).bypassSave()
		}
	quit 

	
public	IDP(RecordLNBIL1 lnbil1)	// Internal bill detail		/REF:R

	// Return Interest Determination Point value for this bill
	
	type Number VAL

	// Checking payment elements total amount billed
	if lnbil1.cpib do { quit VAL
		type Number IAMT, PAMT
		set IAMT = $$SUB^BILFUNCS("I", .lnbil1).piece("#", 3)
		set PAMT = $$SUB^BILFUNCS("P", .lnbil1).piece("#", 3)
		if 'IAMT, 'PAMT set VAL =1
		else  set VAL = 0
		}
		
	quit 0
	

UNPINT(RecordLN ln,		// Loan account				/REF:R
       RecordLNBIL1 lnbil1())	// Internal bill detail			/REF:R

	/*
	Calculate unpaid interest
	
	   This will not include any part of the accrual balance.

	   RETURNS:
	       . $$  Amount of billed/unpaid interest	
	*/

	type String BILL, REC
	type Number BILLNUM, BILLSEQ, UNPINT
	
	set UNPINT = ""
	if ln.bseq > ln.schseq do {
		set BILLNUM = ln.schseq - 1
		set BILLNUM = lnbil1(BILLNUM).order()
		if BILLNUM.isNull() quit

		set BILL = $$SUB^BILFUNCS("I", .lnbil1(BILLNUM))
		if BILL.isNull() quit

		set BILLNUM = ln.schseq - 1 
		for  set BILLNUM = lnbil1(BILLNUM).order() quit:BILLNUM.isNull()  do {
			set REC = $$SUB^BILFUNCS("I", .lnbil1(BILLNUM))
			set UNPINT = UNPINT + REC.piece("#", 4)
			}
		}
		
	if (ln.cuin + ln.unin) > 0 set UNPINT = UNPINT + ln.cuin + ln.unin

	quit UNPINT

	
public DUI(RecordLN ln,			// Loan account			/REF:RW
	   RecordTTX ttx,		// Transaction			/REF:RW
	   RecordTRN trn)		// Transaction code		/REF:R

	// Decrease Unpaid Interest
	
	type Boolean DUI
	type String TSO
	
	set TSO = ttx.tso
	set TSO = $$FIELDIN^UTSO(TSO, "PE", "I")
	set ttx.tso = TSO

	set DUI = 1
	do LNPTS3(.ln, .ttx, .trn)

	quit 

	
RESET(RecordLN ln,			// Loan account			/REF:RW
      RecordLNBIL1 lnbil1())		// Internal bill detail		/REF:RW

	type public Number OLDSEQ

	type Number PC, CNT
	
	// Mark bills satisfied as per payment tolerance functionality
	do PAYTOLCH(.ln,.lnbil1())
	
	// Reset variables in loan record
        do CALC^LNUBIL(.ln, "01001")
	
	// Increase CNTCR and full pmt counter
	do CNTCR(.ln, OLDSEQ)

	quit 

	
IAM(RecordLN ln,			// Loan account			/REF:RW
    RecordTTX ttx,			// Transaction			/REF:RW
    RecordLNBIL1 lnbil1()) 		// Internal bill detail		/REF:R

	// Calculate earned interest for add-on / discount loans

	type public String AM()
	
	type Number %AMT, NUM
		
	if 'ln.iam quit

	set NUM = ""
	for  set NUM = AM(NUM).order() quit:NUM.isNull()  set AM(NUM).piece("|", 1) = lnbil1(NUM).cpib

	do TP^LNAMOAO1(.ln, 1, 0, ln.cntcr, 0)

	do GL^LNPTSU(.ttx, -%AMT, 8)

	do INTIAM(.ln, .ttx, %AMT)
	
	quit 

	
PMTSCH(RecordLN	ln,		// Loan account			/REF:RW
       RecordTTX ttx,		// Transaction			/REF:RW
       RecordTRN trn) 		// Transaction code		/REF:R

	// Principal payment on a payment schedule loan

	type public Number ZAMT
	type public String UTSO()
	
	if UTSO("PE").get() '= "P" quit 
	if 'ZAMT quit
	if ln.dist1fre '= "*" quit
	
	do PMTSCH^LNPTS4(.ln, .trn, .ttx)

	quit 

	
FILE(RecordLN ln,		// Loan account			/REF:W
     RecordTTX ttx) 		// Transaction			/REF:R
	
	type public String LTC

	do FEEDUE^LNFEEU(.ln, .ttx, ln.cid, 2, 11, %EffectiveDate, , , , LTC)

	quit 
	

public FILE2(RecordLN ln)	// Loan account			/REF:W

	// File delinquency counters
		
	type public String DL(), DP(), DY()
	
	// Update Delinquency Category * Previous & Current Financial Year
	set ln.dp1 = DP(1)
	set ln.dp2 = DP(2)
	set ln.dp3 = DP(3)
	set ln.dp4 = DP(4)
	set ln.dp5 = DP(5)
	set ln.dp6 = DP(6)
	set ln.dp7 = DP(7)
	set ln.dy1 = DY(1)
	set ln.dy2 = DY(2)
	set ln.dy3 = DY(3)
	set ln.dy4 = DY(4)
	set ln.dy5 = DY(5)
	set ln.dy6 = DY(6)
	set ln.dy7 = DY(7)
	
	// Update Delinq - Category * LTD
	set ln.dl1 = DL(1)
	set ln.dl2 = DL(2)
	set ln.dl3 = DL(3)
	set ln.dl4 = DL(4)
	set ln.dl5 = DL(5)
	set ln.dl6 = DL(6)
	set ln.dl7 = DL(7)

	quit 

	
GETPRCNT(String ELMNT,		// Bill element acronym
	 Number REMAMT,		// Remaining amount
	 Number FACTOR,		// Factor
	 Number TOTELMNT,	// Total for element
	 RecordLNBIL5 lnbil5(),	// Internal bill for loan fees		/REF:R
	 Number BILL5(,,))	// Internal bill for loan fees seqs	/REF:R

	// Get percent of fees

	type public Number ND
	type public String PRCNT()
	
	type String DATA, FEE = "", UTSO()
	type Number FEESEQ = 0, PRCNTAGE
	
	for  set FEE = BILL5(ND, 1, FEE).order() quit:FEE.isNull()  do {
		set FEESEQ = BILL5(ND, 1, FEE)

		type RecordLNFEEP lnfeep = Db.getRecord("LNFEEP", "FEETYP=:FEE", 1)
		if lnfeep.basis = ELMNT do {
 			// Applied towards a single element?
			if 'UTSO("PE").get().isNull() do {
				if UTSO("PE").get() '= FEE set PRCNTAGE = 1 quit
				set (PRCNTAGE, PRCNT(FEE)) = 1
				set TOTELMNT = TOTELMNT + lnbil5(FEESEQ).brfamt
				}
			if UTSO("PE").get().isNull() do {
				if 'REMAMT set PRCNTAGE = 1
				else  set PRCNTAGE = (lnbil5(FEESEQ).brfamt / REMAMT * FACTOR).roundDec(10)
				set PRCNT(FEE) = PRCNTAGE
				set TOTELMNT = TOTELMNT + lnbil5(FEESEQ).brfamt
				}

			do GETPRCNT(FEE, lnbil5(FEESEQ).brfamt, PRCNTAGE, .TOTELMNT, .lnbil5(), .BILL5(,,))
			}
		}
	quit 
	

APPLYFEE(RecordLN ln,		// Loan account				/REF:R
	 RecordLNBIL5 lnbil5(),	// Internal bill for loan fees		/REF:Rw
	 RecordTTX ttx,		// Transaction				/REF:RW
	 String ELMNT,		// Element acronym
	 Number BASE,		// Base amount
	 Number BILL5(,,))	// Internal bill for loan fees seqs	/REF:R
	
	type public Number APPLIED, PRCNT(), ND
	
	type Number FEEAMT, FEESEQ = 0
	type String FEE = ""
	
	for  set FEE = BILL5(ND, 1, FEE).order() quit:FEE.isNull()  do {
		set FEESEQ = BILL5(ND, 1, FEE)
		if 'PRCNT(FEE).exists() quit
		
		set FEEAMT = (PRCNT(FEE) * BASE).roundCur()
		set lnbil5(FEESEQ).brfamt = lnbil5(FEESEQ).brfamt - FEEAMT
		do lnbil5(FEESEQ).bypassSave()

		if FEEAMT do %HSEQ^LNPTSU(.ttx, ND_"#"_FEE_"#"_FEEAMT)
		set APPLIED = APPLIED + FEEAMT
		do FEEUPD^LNPTS13(.ln, FEE, FEEAMT, 0)
		do GL^LNPTSU(.ttx, FEEAMT, 6)
		do FEETSO(.ttx, FEEAMT, FEE)
		}
	
	quit 

	
FEETSO(RecordTTX ttx,		// Transaction				/REF:RW
       Number FEEAMT,		// Fee amount
       String FEE)		// Fee type
	
	quit:'FEEAMT
	
	type String ARRAY(), FEEPC, FEETSO, TSO, UTSO()
	type Number PC, NUM
	
	do OUT^UTSO(.UTSO(), ttx.tso)
	set FEETSO = $$FIELD^UTSO(ttx.tso, "LNFEE")
	
	for PC = 1:1:FEETSO.length(",") do {

		/* With multiple fees paid, FEETSO may look as following: 
		   FEETSO="LNFEE1:20,LNFEE2:30,LNFEE3:200" which needs to be 
		   considered when extracting the fee plan and amount for the 
		   fee array 'ARRAY'. 
		*/
		set FEEPC = FEETSO.piece(",", PC).piece(":", 1)
		if 'FEEPC.isNull() set ARRAY(FEEPC).piece(":", 1) = FEETSO.piece(",",PC).piece(":",2)

		}

	set ARRAY(FEE) = ARRAY(FEE).get() + FEEAMT
	
	set UTSO("LNFEE") = ""
	set NUM = ""
	
	for  set NUM = ARRAY(NUM).order() quit:NUM.isNull()  set UTSO("LNFEE") = UTSO("LNFEE")_NUM_":"_ARRAY(NUM)_","

	set UTSO("LNFEE") = UTSO("LNFEE").extract(1, (UTSO("LNFEE").length() - 1))

	do IN^UTSO(.UTSO, .TSO)
	
	set ttx.tso = TSO

	quit 

	
public	DCC(RecordLN ln)	// Loan account		/REF:RW

	/*
	 Decrement delinquency counters. These counters were updated as
	 part of normal end-of-day processing. Had this payment been applied
	 on its effective date the counter might never have been incremented.
	*/

	type public Boolean ER
	type public Number DCC(), DL(), DP(), DY()
	type public String PRETRN()
	
	type Date FINYEL, FINYEL2, NJD
	type Number CNTR
	
	do DCC^LNPTS2A(.ln)
	
	set FINYEL = CUVAR.FINYEL
	set FINYEL2 = FINYEL.nextFreqDate("-1YA") quit:ER

	for CNTR = 1:1:7 do {
	
		if DCC(CNTR).isNull() quit 
		
		/*
		 For each due date that was satisfied by this payment
		 interrogate each delinquency counter (The payment may
		 have satisfied multiple due dates).
		*/	

		set NJD = PRETRN("DIST1ND") 

		#IF 'CUVAR.DCCUP
			/*
			 Decrement each counter that was originally incremented
			 for the formerly most delinquent bill.  This will decrement
			 all counters that were incremented for this bill.
			*/
			do DCCUPD
			
			// Then increment each counter for the newly most delinquent bill.
			set NJD = ln.dist1nd
			do DCCUPD^LNPTSR
		#ENDIF
		#IF CUVAR.DCCUP=1
			// Decrement each counter for all delinquent bills
			for  do DCCUPD set NJD = NJD.nextFreqDate(ln.dist1fre) quit:ER ! (NJD '< ln.dist1nd)
		#ENDIF
		}
	
	quit


DCCUPD	// Decrement delinquency counters for a specified category and due date

	type public Date FINYEL, FINYEL2, NJD
	type public Number CNTR, DCC(), DL(), DP(), DY()

	// Was this counter incremented?
	if NJD + DCC(CNTR) '> %SystemDate do {
	
		// If yes, should it be decremented?
		if (NJD + DCC(CNTR)) > %EffectiveDate do {
					
			// Decrement the counter for LTD, YTD
			if DL(CNTR) < 1 quit
			set DL(CNTR) = DL(CNTR) - 1
					
			// Date occurs after CUVAR.FINYEL, update current year bucket
			if (NJD+DCC(CNTR)) > FINYEL do {
				if DY(CNTR) < 1 quit  
				set DY(CNTR) = DY(CNTR) - 1
				}
			// Date occurs before CUVAR.FINYEL, and falls in that prior fin. year
			else  if ((NJD+DCC(CNTR)) '> FINYEL),((NJD+DCC(CNTR)) > FINYEL2) do {
				if DP(CNTR) < 1 quit
				set DP(CNTR) = DP(CNTR) - 1
				}
			// Otherwise, the date would have fallen prior to the end of the
			// previous financial year; only the life counters should be incremented.
			}
		}

	quit


PPF(RecordLN ln,		// Loan acount				/REF:R
    RecordLNBIL1 lnbil1,	// Internal bill detail			/REF:R
    String ELMNT,		// Element acronym
    Number BSEQ)		// Bill - last sequence number
	
	type public Cache %CACHE()
	type public Number ER, PC, XPDC
	type public String ESCELMT, ETC, PRI()

	type Number SEQ, PPF
	type String STRING

	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")

	// Force Vertical Payment Application
	if trn.pcfl17 set STRING = "-"_PRI(ln.npc)_"-"
	else  do {
		set XPDC = $$PDC(BSEQ,.ln) 
		set STRING = "-"_$select(XPDC = 1:ln.ppdcat1, XPDC = 2:ln.ppdcat2, XPDC = 3:ln.ppdcat3, XPDC = 4:ln.ppdcat4, XPDC = 5:ln.ppdcat5, XPDC = 6:ln.ppdcat6, XPDC = 7:ln.ppdcat7, XPDC = 8:ln.ppdcat8, XPDC = 9:ln.ppdcat9, XPDC = 10:ln.ppdcat10)
		}

	set PPF = STRING.piece("-"_ELMNT_"-", 2).extract(1)
	if PPF.isNull() do {
		type String XELMNT = ELMNT
		if XELMNT.extract(XELMNT.length())?.N set XELMNT = ELMNT.extract(1, ELMNT.length() - 1)
		set ESCELMT = $$BIL1ELMT^BILFUNCS(PC, .lnbil1)
		if ESCELMT do {
			for SEQ = 1:1:99 if 'STRING.piece(XELMNT_SEQ_"-", 2).extract(1).isNull() do { quit
				set PPF = STRING.piece(XELMNT_SEQ_"-", 2).extract(1)
				}
			}
		}
	
	/*
	 If PPF is null at this point, it means that the ELMNT does not exist
	 in any of the ln.ppdcat* columns (as can happen during a backdated payment
	 on an account that had escrow added on the current date).  Return 0 so 
	 that IND0 will set IND='v', which will force IND0 to be called again and 
	 increment PC so that the next payment element is picked up. 
	*/
	if PPF.isNull() quit 0
	
	quit PPF

	
public	CNTCR(RecordLN ln,	// Loan Record				/REF:RW
	      Number OLDSEQ)	// Previous LN.DSEQ

	/*	
	   This section is called by payments and reversals.
	
	   OUTPUTS:
	   . ln.bal    updated with correct CNTCR value
	   . ln.pvar  updated with correct FPCnn value	
	*/
	
	type public Date CUVAR2, FINB
	type public Number BILLSEQ
	type public String CTL

	type Date FINYELB
	type Number CNT, FROM, MM, TO
	
	set OLDSEQ = OLDSEQ.get()
	set CTL = CTL.get()
	
	// Find difference in "due" sequences. In most cases, this difference
	// will be the adjustment to ln.cntcr.

	set CNT = ln.dseq - OLDSEQ if 'CNT quit 
	
	/*
	The following section will subtract out the number of zero bills within 
	the bill sequence range. These zero bills (billed 0) should not affect 
	the count.
	*/

	// Count is negative - reversal
	if CNT < 0 do {
		set TO = OLDSEQ
		for BILLSEQ = ln.dseq:1:TO quit:BILLSEQ > ln.bseq  do {  
			type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:BILLSEQ", 1)
			if 'lnbil1.ctab set CNT = CNT + 1
			}
		}
	
	// Count is positive - payment
	if CNT > 0 do {
		set FROM = OLDSEQ 
		for BILLSEQ = FROM:1:ln.dseq quit:BILLSEQ > ln.bseq  do {
			type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:ln.cid,SCHSEQ=:BILLSEQ", 1)
			if 'lnbil1.ctab set CNT = CNT - 1
			}
		}
			
	if CNT < 0 set ln.cntcr = ln.dseq - 1	
	else  set ln.cntcr = ln.cntcr + CNT
	
	// Previous financial year end beginning date
	set FINYELB = FINB.nextFreqDate("-1YA")
	
	// Month payment was made or reversed
	set MM = +%SystemDate.toString("MM") 	

	// Effective date of transaction is in the current financial year
	// so the current financial year counters need to be incremented.
	if (%SystemDate '< FINB) do {
		if MM = 1 set ln.fpc01 = ln.fpc01 + CNT
		if MM = 2 set ln.fpc02 = ln.fpc02 + CNT
		if MM = 3 set ln.fpc03 = ln.fpc03 + CNT
		if MM = 4 set ln.fpc04 = ln.fpc04 + CNT
		if MM = 5 set ln.fpc05 = ln.fpc05 + CNT
		if MM = 6 set ln.fpc06 = ln.fpc06 + CNT
		if MM = 7 set ln.fpc07 = ln.fpc07 + CNT
		if MM = 8 set ln.fpc08 = ln.fpc08 + CNT
		if MM = 9 set ln.fpc09 = ln.fpc09 + CNT
		if MM = 10 set ln.fpc10 = ln.fpc10 + CNT
		if MM = 11 set ln.fpc11 = ln.fpc11 + CNT
		if MM = 12 set ln.fpc12 = ln.fpc12 + CNT
		}	
	
	// Effective date of transaction is in the prior financial year
	// so the prior financial year counters need to be incremeneted.
	else  if (%SystemDate '< FINYELB) do {
		if MM = 1 set ln.fpp01 = ln.fpp01 + CNT
		if MM = 2 set ln.fpp02 = ln.fpp02 + CNT
		if MM = 3 set ln.fpp03 = ln.fpp03 + CNT
		if MM = 4 set ln.fpp04 = ln.fpp04 + CNT
		if MM = 5 set ln.fpp05 = ln.fpp05 + CNT
		if MM = 6 set ln.fpp06 = ln.fpp06 + CNT
		if MM = 7 set ln.fpp07 = ln.fpp07 + CNT
		if MM = 8 set ln.fpp08 = ln.fpp08 + CNT
		if MM = 9 set ln.fpp09 = ln.fpp09 + CNT
		if MM = 10 set ln.fpp10 = ln.fpp10 + CNT
		if MM = 11 set ln.fpp11 = ln.fpp11 + CNT
		if MM = 12 set ln.fpp12 = ln.fpp12 + CNT
		}
		
	quit 
	
PAYTOLIN(RecordLN ln)	// Reset bill records for tolerance amount due

	/*
	 This sections handles setting up bill records with the tolerance amounts
	 due that were originally moved out of the bill records so that those
	 bills could be considered satisfied.  This is done so that the tolerance
	 amounts due are handled as per the loans's grid/path/string.
	*/

	if 'ln.toldue quit	// No tolerance amount due
	
	// If a tolerance amount exists, it must come from the bill record
	// that is currently due.
	type RecordLNBILTOL lnbiltol = Db.getRecord("LNBILTOL","CID=:ln.cid AND SCHSEQ=:ln.schseq",1)
	if 'lnbiltol.getMode() quit
	
	type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1","CID=:ln.cid,SCHSEQ=:lnbiltol.schseq")
		
	// Restore the bill record to its original state before
	// pmt tolerance functionality kicked in
	set lnbil1 = lnbiltol.copy()
		
	do lnbil1.setMode(1)
	do lnbil1.bypassSave()
		
	// Delete this Pmt Tolerance record only.  Others may
	// be needed for reversals.
	do Db.delete("LNBILTOL","CID=:ln.cid AND SCHSEQ=:lnbil1.schseq")
		
	set ln.toldue=0
	
	// Reset the loan record based on bill record changes above
	do CALC^LNUBIL(.ln,"01001")

	quit
	
	
PAYTOLCH(RecordLN ln,		// Loan Record			RW	 
	 RecordLNBIL1 lnbil1())	// Loan Bill Record Array	REFARR:RW

	/*
	 This section collates through the bill records to see if any of
	 them (usually the last) can be satisfied by loan payment tolerance
	 functionality.  If a bill does meet this criteria, a copy of the 
	 bill is saved to the LNBILTOL table and the amounts due on the
	 bill are brought to zero.
	*/
	
	type public Boolean ER
	type public Number PMT,ZAMT

	type Boolean STOP = 0
	type Date NXTDUE
	type Number I,PAYTOL,SEQ,TOLDUE
	type String blamt(),DATA

	// Do not utilize payment tolerance processing if the
	// whole payment amount hasn't been applied yet.
	if ZAMT > 0 quit

	// Pmt tolerance functionality not enabled
	if ('ln.paytol),('ln.paytolp) quit
	
	// Pmt tolerance can be an amount (ln.paytol) or a percentage (ln.paytolp)
	set PAYTOL = ln.paytol
	if 'PAYTOL,ln.paytolp do {  quit:'PAYTOL
		if PMT.get().isNull() set PMT = ln.pmt
		set PAYTOL = (PMT*(ln.paytolp/100)).roundCur()
		}

	set SEQ = 0
	set TOLDUE = 0

	for  set SEQ=lnbil1(SEQ).order() quit:(('SEQ)!STOP)  do {

		if 'lnbil1(SEQ).casd quit	// No amount due on this bill

		/*
		 The amount of tolerance already taken plus the amount
		 outstanding on this bill exceeds the payment tolerance.
		 Stop processing immediately.
		*/
		
		if ((TOLDUE+lnbil1(SEQ).casd) > PAYTOL) set STOP = 1 quit
		
		set NXTDUE = lnbil1(SEQ).cdpd.nextFreqDate(ln.dist1fre) quit:ER

		/*
		 If the next bill's due date occurs after maturity, then the bill 
		 being processed represents either the last bill before maturity or 
		 a post-maturity bill.  If this is the case, then stop processing 
		 because the bill is not eligible for payment tolerance processing.
		*/
		if ln.mdt,(NXTDUE > ln.mdt) set STOP = 1 quit
		
		set TOLDUE = TOLDUE + lnbil1(SEQ).casd
		
		// Save off the existing bill so it can be restored later
		type RecordLNBILTOL lnbiltol = Class.new("RecordLNBILTOL","CID=:ln.cid,SCHSEQ=:lnbil1(SEQ).schseq")
		set lnbiltol = lnbil1(SEQ).copy()
		do lnbiltol.bypassSave()

		// P&I amounts aren't stored for IDP loans, so the whole P&I
		// due amount needs to be reduced in the bill record.
		if ln.idp = 1 do SETBIL^LNBLDE(.ln,.lnbil1(SEQ),-lnbil1(SEQ).cpid,"P",1)

		// Finally, zero out the individual element amounts so the bill
		// can be considered satisfied.
		for I=1:1:20 do {
			set DATA = $$GETFIELD^BILFUNCS(I,.lnbil1(SEQ))
			if 'DATA.piece("#",4) quit	// No amount due
			do SETBIL^LNBLDE(.ln,.lnbil1(SEQ),-DATA.piece("#",4),DATA.piece("#",1),1)
			}

		do lnbil1(SEQ).bypassSave()
		}

	set ln.toldue = TOLDUE

	quit

	
public UPDVAT(RecordLN ln,	// Loan account			/REF:RW
       RecordTTX ttx,		// Transaction			/REF:RW
       Number VATAMT)	        // Value added tax amount

	type public Number ZAMT

	// Update Tran Detail: L:Val Tax Int (ttx.swhld)
	do GL^LNPTSU(.ttx, VATAMT, 15)

	set ZAMT = ZAMT - VATAMT		
	
	// Pay down VAT on interest level on bill file
	do REDUCBL^LNPTS13(.ln, .ttx, "VI", VATAMT)	
	
	// Add VAT on Interest Amount Due entry into History of bills for 
	// satisfied (HISTSB)
	do %HSEQ^LNPTSU(.ttx, "*#VI#"_VATAMT)
	
	set ln.vatintpd = ln.vatintpd + VATAMT	
	set ln.vatintdue = ln.vatintdue - VATAMT	
	
	quit
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60866^33688^John Varga^56823"	// Signature - LTD^TIME^USER^SIZE
