SRVCMP(FEEPLAN,FEEDATE)
  /*
	ORIG: RUSSELL - 01/02/2002
	DESC: Deposit service fee compiler
	PROCEDURE ID:  SRVCMP

---- Comments -----------------------------------------------------------------
	
	This procedure compiles service fee plan run-time code, using the
	template code defined in procedure SRVCMP1.

	ARGUMENTS:

		. FEEPLAN 	Fee plan name		/TYP=T/REQ/MECH=VAL
							/TBL=[FEEPLN]
		. FEEDATE 	Fee plan date		/TYP=D/REQ/MECH=VAL
							/TBL=[FEEPLN]

	RETURNS:
	
		. $$		Compiled routine name	/TYP=T
		. ER		Error flag		/TYP=N
		. RM		Error message		/TYP=T

	---- Revision History -------------------------------------------------
	
	11/02/06 - Hillanbrand - CR 23709
	           Modified FEESCH section to Pass dep object 
	           if PGM is standard Service Fee Exemption Plans.
	
	08/23/05 - RussellDS - CR16911
		   Fix %TAB issue in COMPILE1 section.
	
		   Minor PSL clean-up - still scoping issues.  Changes to
		   reduce warnings for compiled fee plans.
		   
		   Add errors in the event transaction codes are invalid.
		   
		   Eliminate use of %TRMVT to display messages on mass compile,
		   just scross so messages don't get overlayed.
		   
		   Removed old revision history.
	*/

	// Catch GT.M errors
	catch error {
		do ZE^UTLERR
		set ER=1
		}

	set ER=0
	new BASE,CODE,CURFLAG,DESC,FEEBAL,FEEMIN,FEEMAX,FEETBLNO,HITCOPT3
	new N,NEWLINE,PLANCUR,PLANEXC,QRY,QRYNO,SCH,SCHNO,TAB,TAGS,TBL

	/* Load template into array CODE and create cross-reference for //tags
	   and remove any lines marked //*DELETE*
	*/

	do ^ULODTMPL("SRVCMP1","CODE")
	set N=""
	for  set N=$O(CODE(N)) quit:N=""  do {
		if CODE(N)["//*DELETE*" kill CODE(N) quit
		quit:CODE(N)'["//tag"
		set TAGS($P($P(CODE(N),"//tag",2)," ",1))=N
	}

	set (BALCMP,ER,FEETBLNO,QRYNO,SCHNO)=0
	set TAB=$C(9)

	// Build the fee program

	type RecordFEEPLN feepln = Db.getRecord("FEEPLN","PLAN=:FEEPLAN,FEEDT=:FEEDATE")

	set HITCOPT3=0
	set BASE=feepln.base			// Base fee amount
	set FEEMIN=feepln.feemin		// Minimum fee amount
	set FEEMAX=feepln.feemax		// Maximum fee amount
	set FEEBAL=feepln.feebal		// Balance for fee computation
	set CURFLAG=feepln.curflg		// Convert amounts
	set PLANCUR=feepln.plancur		// Plan currency 
	set PLANEXC=feepln.planexc		// Exchange rate
	if 'PLANEXC set PLANEXC=1

	// Insert fee plan type (PLTP)
	set CODE($$LINE("plan"))=TAB_"type public Number PLTP"
	set CODE($$LINE("plan"))=TAB_"set PLTP="_+feepln.pltp

	// If converting amount insert code to get currency code
	if CURFLAG set CODE($$LINE("plan"))=TAB_"set CRCD=dep.crcd"

	do FEECAT quit:ER

	// Balance for fee computation not required
	if FEEBAL,'BALCMP do ERR(12) quit
	// Balance for fee computation required
	if 'FEEBAL,BALCMP do ERR(13) quit
	// Minimum fee amount not required
	if FEEMIN,'BASE,'HITCOPT3 do ERR(18) quit
	// Maximum fee amount not required
	if FEEMAX,'BASE,'HITCOPT3 do ERR(19) quit

	set DESC="Plan:  "_FEEPLAN_"; for date:  "_$$DAT^%ZM(FEEDATE,$G(%MSKD))_"; Desc:  "_feepln.desc
	do CMP

	// File date, time and user id into service fee plan definition
	set feepln.cmpdate=%CurrentDate
	set feepln.cmptime=%CurrentTime
	set feepln.cmpuid=%UserID

	do feepln.save()

	quit


FEECAT	// Fee category

	new feesrvrs,NEXTCATS

	set ER=0,QN=0,FEEQRY=""

	type ResultSet feesrvrs=Db.select("FEECAT,FEETYP,DESC,CHGOPT,FEEAMT,FEESCH,MAXDLY,FEEPRCT,FEETBL","FEESRV","PLAN=:FEEPLAN AND FEEDT=:FEEDATE","FEECAT,FEETYP")

	while feesrvrs.next() if 'ER do {
		new CHGOPT,DESC,FEEAMT,FEECAT,FEEPRCT,FEESCH,FEETBL,FEETYP
		new LINE,LINETAG,MAXDLY
		set FEECAT=feesrvrs.getCol(1)
		set FEETYP=feesrvrs.getCol(2)
		set DESC=feesrvrs.getCol(3)
		set CHGOPT=feesrvrs.getCol(4)
		if CHGOPT=3 set HITCOPT3=1
		set FEEAMT=feesrvrs.getCol(5)
		if CURFLAG,FEEAMT set FEEAMT=$$CONVERT(FEEAMT)
		set FEESCH=feesrvrs.getCol(6)
		set MAXDLY=+feesrvrs.getCol(7)
		if CURFLAG,MAXDLY set MAXDLY=$$CONVERT(MAXDLY)
		set FEEPRCT=feesrvrs.getCol(8)/100
		set FEETBL=feesrvrs.getCol(9)

		if FEECAT=1 do {
			new trn
			type RecordTRN trn
			set trn=Db.getRecord("TRN", "ETC=:FEETYP", 1)
			// Fee category ~p1, type ~p2 has an invalid tran code
			if (trn.getMode() = 0) do ERR(7)
			// Fee category ~p1, type ~p2 is not a valid misc tran code
			if (trn.getMode() <> 0), (trn.cls '= "M") do ERR(1)
			}
		quit:ER

		// Fee category ~p1, type ~p2 has an invalid charge option (1)
		if FEECAT>3,CHGOPT=1 do ERR(2) quit

		// Direct Transaction Fees
		if FEECAT=3,CHGOPT=1!(CHGOPT=2) do {
			new ETC,I,TRNLIST
			set TRNLIST=$P($$TRNGRP^SRVSUM(FEETYP,0,FEEDATE),"|",2)
			for I=2:1 set ETC=$P(TRNLIST,",",I) quit:(ETC="")!ER  do {
				new trn
				type RecordTRN trn
				set trn=Db.getRecord("TRN", "ETC=:ETC", 1)
				// Fee category ~p1, type ~p2 has an invalid tran code
				if (trn.getMode() = 0) do ERR(7) quit
				// Type ~p1, transaction code ~p2 does not consider direct transaction fees.
				if CHGOPT=1,'trn.pcfd10 do ERR(15) quit
				// Type ~p1, transaction code ~p2 does not contain a transaction fee plan
				if CHGOPT=1,trn.feepln="" do ERR(16) quit
				// Type ~p1, close-out transaction code ~p2 fee charge at analysis is invalid
				if CHGOPT=2,trn.pcfd5 do ERR(20) quit
				}
			}
		quit:ER

		// Get next category section - sections are, e.g., 3000, 3001, etc.
		set LINETAG=(FEECAT*1000)+$G(NEXTCATS(FEECAT))
		set NEXTCATS(FEECAT)=$G(NEXTCATS(FEECAT))+1

		set CODE($$LINE(FEECAT))=TAB_"if FEETYP="""_FEETYP_""" do "_LINETAG_"(.dep) quit 1"
		set CODE($$LINE("typ"))=LINETAG_"(RecordDEP dep)"_TAB_"// Fee type:  "_FEETYP_" - "_DESC
		set CODE($$LINE("typ"))=TAB_"type public Boolean ONLINE"
		set CODE($$LINE("typ"))=TAB_"type public Number CHGOPT, CID, FEEAMT, FEECNT, MAXDLY, TAMT"
		set CODE($$LINE("typ"))=TAB_"type public String CRCD"

		do FEEAMT("typ","") quit:ER
		do FEEQRY quit:ER

		/* Do not want to update SRV when table returns an error ("*")
		   and query not true.  Processing quits out to SRVSTP
		   proc. and table error not logged. If no fee amount reset fee 
		   counter, to allow counter updates based on queries for DLY 
		   type when not on SCND for account.
		*/

		if (FEETYP="DLY")!(FEETYP="STP") set CODE($$LINE("typ"))=TAB_"if (FEEAMT=0)!(FEEAMT=""*"") set FEECNT=0 quit"
		set CODE($$LINE("typ"))=TAB_"quit"
	}

	quit



FEEQRY	// Build queries for FEETYP

	new FEEAMT,FEEPRCT,feeqryrs,FEESCH,FEETBL,MAXDLY,QRYNAME

	type ResultSet feeqryrs
	set feeqryrs=Db.select("QRYNAME,FEEAMT,FEESCH,MAXDLY,FEEPRCT,FEETBL","FEEQRY","PLAN=:FEEPLAN AND FEEDT=:FEEDATE AND FEECAT=:FEECAT AND FEETYP=:FEETYP")
	if feeqryrs.isEmpty() quit

	/* Note that FEEAMT may be zero, so we don't want to plus it and turn
	   a null into zero.  On the other hand, percent must be greater than
	   zero, so we can plus it and treat it as a number throughout.
	*/
	while feeqryrs.next() if 'ER do {
		set QRYNAME=feeqryrs.getCol(1)
		set FEEAMT=feeqryrs.getCol(2)			// Do not plus
		set FEESCH=feeqryrs.getCol(3)
		set MAXDLY=+feeqryrs.getCol(4)
		set FEEPRCT=feeqryrs.getCol(5)/100
		set FEETBL=feeqryrs.getCol(6)
		if CURFLAG,FEEAMT set FEEAMT=$$CONVERT(FEEAMT)
		if CURFLAG,MAXDLY set MAXDLY=$$CONVERT(MAXDLY)

		if '$D(QRY(QRYNAME)) do BLDQRY quit:ER

		do FEEAMT("qry","Q"_QRY(QRYNAME))
	}

	quit


BLDQRY	// Build query code

	new DBQRY,N,PRIMTBL,PSLOBJ,PSLQRY,TABLES,WHERE

	set QRYNO=QRYNO+1
	set QRY(QRYNAME)=QRYNO			// Save to use again, if needed
	
	set CODE($$LINE("qry"))="Q"_+QRY(QRYNAME)_"(RecordDEP dep)"_TAB_"// "_QRYNAME

	// Convert query to PSL code
	do ^UCQRYBLD(QRYNAME,"DEP=dep",.TABLES,.PSLOBJ,.PSLQRY)
	// Fee category ~p1, type ~p2 has an invalid query linkage (~p3)
	if ER!TABLES.get().isNull() do ERR(8) quit

	set PRIMTBL=$P(TABLES,",",1)
	// Fee category ~p1, type ~p2 (query ~p3) primary file not [DEP] or [LN]
	if '((PRIMTBL="DEP")!(PRIMTBL="LN")!(PRIMTBL="CRDTYP")!(PRIMTBL="UTBLSTPFEE")) do ERR(9) quit

	set N=""
	// Insert lines to instantiate new objects
	for  set N=$O(PSLOBJ(N)) quit:N=""  set CODE($$LINE("qry"))=TAB_PSLOBJ(N,1)

	// Insert the query lines
	for  set N=$O(PSLQRY(N)) quit:N=""  do {
		set CODE($$LINE("qry"))=TAB_"if "_PSLQRY(N)
		set CODE($$LINE("qry"))=TAB_"else  quit"
		}

	set CODE($$LINE("qry"))=TAB_"quit"

	quit


FEEAMT(TAG,QRYID)	// Fee amount

	new NEWLINE,TMPDATE
	if FEESCH'="" do {
		new feeschrs
		type ResultSet feeschrs
		set feeschrs=Db.select("FEESCHDT","UTBLFEESCH","FEESCH=:FEESCH AND FEESCHDT NOT > :FEEDATE","FEESCHDT DESC")
		// Fee category ~p1, type ~p2 has an invalid fee schedule (~p3)
		if feeschrs.isEmpty() do ERR(3) quit
		if 'feeschrs.next() do ERR(3) quit
		set TMPDATE=feeschrs.getCol(1)
		}
	quit:ER

	// Check that only one of these has a value
	// Fee category ~p1, type ~p2 has both a fixed fee amount and a fee schedule
	if FEEAMT'="",(FEESCH'="")!FEEPRCT!(FEETBL'="") do ERR(4) quit
	if FEESCH'="",FEEPRCT!(FEETBL'="") do ERR(4) quit
	if FEEPRCT,FEETBL'="" do ERR(4) quit

	// Fee category ~p1, type ~p2 (CHGOPT'=1) - max daily amount does not apply
	if CHGOPT'=1,MAXDLY do ERR(5) quit

	if TAG="typ" do {
		set CODE($$LINE("typ"))=TAB_"set CHGOPT="_+CHGOPT
		/* Do not check ONLINE for DLY fee type or will quit before query execution
		   which will not update SRV correctly. Add 'FEECNT Q for DLY/STP fee to allow
		   SRVCMP1 to get CHGOPT from EXEC section when no fee counter maintenance
		   done during period.
		*/
		if CHGOPT'=1,FEECAT<4 do {
			// Do not check ONLINE for DLY or STP or will quit before
			// query execution which will not update SRV correctly.
			if '((FEETYP="DLY")!(FEETYP="STP")) set CODE($$LINE("typ"))=TAB_"if $D(ONLINE) set FEEAMT=0 quit"
			/* Add 'FEECNT quit for DLY and STP to allow SRVCMP1 to
			   get CHGOPT from EXEC section when no fee counter
			   maintenance done during period.
			*/
			if (FEETYP="DLY")!(FEETYP="STP") set CODE($$LINE("typ"))=TAB_"if 'FEECNT quit"
		}
	}

	// Create a single line, place query code around it if there is a query
	set NEWLINE="set MAXDLY="_MAXDLY
	if FEEAMT'="" set NEWLINE=NEWLINE_",FEEAMT=("_FEEAMT_"*FEECNT)"
	else  if FEEPRCT do {
		if CHGOPT=1 set NEWLINE=NEWLINE_",FEEAMT="_"$$^SCARND("_+FEEPRCT_"*TAMT*FEECNT,,CID)"
		else  set NEWLINE=NEWLINE_",FEEAMT="_"$$^SCARND("_+FEEPRCT_"*TAMT,,CID)"
		}
	else  if FEETBL'="" do {
		if '$D(TBL(FEETBL)) do FEETBL(FEETBL) quit:ER
		set FEEAMT="$$T"_+TBL(FEETBL)
		if $P(TBL(FEETBL),"|",2)="DEP" set FEEAMT=FEEAMT_"(.dep)"
		if CURFLAG set NEWLINE="set MAXDLY="_MAXDLY_",FEEAMT="_FEEAMT_",FEEAMT=$S(FEEAMT="""":""*"",1:"_$$CONVERT("FEEAMT")_"*FEECNT)"
		else  set NEWLINE="set MAXDLY="_MAXDLY_",FEEAMT="_FEEAMT_",FEEAMT=$S(FEEAMT="""":""*"",1:FEEAMT*FEECNT)"
	}
		// Allow FEESCH to be null for FEECAT 2. Removes setting all feetype parameters
		// for FEECAT 2 and allows user to choose fee types.
	else  if FEESCH'="" do {
		do FEESCH(TMPDATE)
		if 'ER set NEWLINE=NEWLINE_" do S"_SCH(FEESCH)
	}

	quit:ER

	if $G(QRYID)'="" set NEWLINE="do "_QRYID_"(.dep) if  "_NEWLINE_" quit"
	set CODE($$LINE("typ"))=TAB_NEWLINE

	quit


FEESCH(TMPDATE)	// Fee schedule
	
	new feesch,PGMLNK,SCHTYP,TIER

	type RecordUTBLFEESCH feesch
	set feesch=Db.getRecord("UTBLFEESCH","FEESCH=:FEESCH,FEESCHDT=:TMPDATE")
	set SCHTYP=feesch.schtyp
	set TIER=feesch.tier
	set PGMLNK=feesch.pgmlnk

	// Fee category ~p1, type ~p2 (CHGOPT=1) - fee schedule tier cannot be ~P3
	if CHGOPT=1,'TIER do ERR(10) quit
	// Fee category ~p1, type ~p2 (SCHTYP=1) - fee schedule tier cannot be ~P3
	if SCHTYP=1,'TIER!(TIER=2) do ERR(11) quit
	if (FEECAT=2)!(FEECAT=4),TIER=2 do ERR(11) quit
	// Fee category ~p1, type ~p2 - cannot have a fee schedule - DLY/STP fee type
	if (FEETYP="DLY")!(FEETYP="STP"),TIER'<0 do ERR(21) quit
	if PGMLNK'="" do {
		new PGM
		set PGM=$P($P(PGMLNK,"^",2),"(",1)
		// Fee category ~p1, type ~p2 is linked to an invalid routine (~p3)
		if '$$VALID^%ZRTNS(PGM) do ERR(14)
		// Pass dep object if PGM is standard Service Fee Exemption Plans
		if PGM="YFEEEXP1" set PGMLNK=$P(PGMLNK,")",1)_",.dep)"
		}
	quit:ER

	if $D(SCH(FEESCH)) quit
	set SCHNO=SCHNO+1,SCH(FEESCH)=SCHNO

	if 'TIER set BALCMP=1

	set CODE($$LINE("sch"))="S"_SCH(FEESCH)_TAB_"// "_FEESCH_" - "_feesch.desc
	set CODE($$LINE("sch"))=TAB_"type public Boolean ONLINE"
	set CODE($$LINE("sch"))=TAB_"type public Number CHGOPT, FEEAMT, FEEBAL, FEECNT, TAMT"
	set CODE($$LINE("sch"))=TAB_"type public String CRCD, SCH()"
	if SCHTYP do {
		set CODE($$LINE("sch"))=TAB_"type Number CNT" 
		set CODE($$LINE("sch"))=TAB_"set FEEAMT=0"
	}

	/* Note that use of a program call can pass the RecordDEP object, dep,
	   e.g., ^ABC(.dep), if the program is designed to accept it as input.
	   The following variables are available for use by the custom program.
	   They should not be modified, nor should any other variables be used:
		CHGOPT,CID,FEECAT,FEETYP,PLTP
	*/
	if PGMLNK'="" set CODE($$LINE("sch"))=TAB_"do "_PGMLNK
	else  do SCH
	set CODE($$LINE("sch"))=TAB_"quit"
	quit


SCH	// Set up fee schedule

	new BASEFEE,COUNT,feetiers,I,SCHCNT,TIERFEE,TIERLVL

	set COUNT=0,SCHCNT=1
	type ResultSet feetiers=Db.select("TL,FA,BASEAMT","UTBLFEESCH1","FEESCH=:FEESCH AND FEESCHDT=:TMPDATE","TL"))
	if feetiers.isEmpty() quit

	// Need to work with current tier, but with knowledge of next tier level
	// 0 = current, 1 = next
	for I=0,1 set (TIERLVL(I),TIERFEE(I),BASEFEE(I))=""
	while feetiers.next() do {
		set TIERLVL(0)=TIERLVL(1)
		set TIERFEE(0)=TIERFEE(1)
		set BASEFEE(0)=BASEFEE(1)
		set TIERLVL(1)=feetiers.getCol(1)
		set TIERFEE(1)=feetiers.getCol(2)
		set BASEFEE(1)=feetiers.getCol(3)
		do SCHSET
	}

	// Handle last level
	set TIERLVL(0)=TIERLVL(1)
	set TIERFEE(0)=TIERFEE(1)
	set BASEFEE(0)=BASEFEE(1)
	set TIERLVL(1)=""		// Signal last tier to SCHSET
	do SCHSET

	quit


SCHSET	// Set schedule info

	new NEXTLVL,VAR
		
	quit:TIERLVL(0)=""  	// First pass need to get next level
	// TIER types - 0=balance, 1=item count, 2=percentage
	if CURFLAG,TIER'=1,TIERLVL(1) set NEXTLVL=$$CONVERT(TIERLVL(1))
	else  set NEXTLVL=+TIERLVL(1)

	set TIERFEE=TIERFEE(0)
	if TIER=2 set TIERFEE=TIERFEE(0)/100
	else  if CURFLAG set TIERFEE=$$CONVERT(TIERFEE(0))

	set BASEFEE=BASEFEE(0)
	if CURFLAG,BASEFEE set BASEFEE=$$CONVERT(BASEFEE(0))

	if CURFLAG,TIER'=1 set TIERLVL=$$CONVERT(TIERLVL(0))
	else  set TIERLVL=+TIERLVL(0)

	set VAR=$S(TIER=1:"FEECNT",TIER=2:"TAMT",1:"FEEBAL")
	if 'SCHTYP do SCH0		// Cumulative schedule
	if SCHTYP do SCH1		// Incremental schedule
	quit


SCH0	// Cumulative schedule

	new NEWLINE
	set NEWLINE=TAB

	if TIERLVL(1)'="" set NEWLINE=TAB_"if "_VAR_"<"_NEXTLVL_" "
	set NEWLINE=NEWLINE_"set FEEAMT="
	if VAR="TAMT" do {
		set NEWLINE=NEWLINE_"$$^SCARND("_TIERFEE_"*TAMT*$S(CHGOPT=1:FEECNT,1:1))"_"+"_BASEFEE
		set NEWLINE=NEWLINE_" set:'$D(ONLINE) SCH(1)=FEECNT" 
		set NEWLINE=NEWLINE_"_"_""""_"|"""_"_("_TIERFEE_"*TAMT)_"_""""_"|"""_"_"_BASEFEE
	}
	else  do {
		set NEWLINE=NEWLINE_$S(TIERFEE'="":"("_TIERFEE_"*FEECNT)+",1:"")_BASEFEE
		set NEWLINE=NEWLINE_" set:'$D(ONLINE) SCH(1)=FEECNT" 
		set NEWLINE=NEWLINE_"_"_""""_"|"""_"_"_TIERFEE_"_"_""""_"|"""_"_"_BASEFEE
	}
	if TIERLVL(1)'="" set NEWLINE=NEWLINE_" quit"

	set CODE($$LINE("sch"))=NEWLINE
	quit


SCH1	// Incremental schedule

	new NEWLINE
	set CODE($$LINE("sch"))=TAB_"if "_VAR_"<"_TIERLVL_" quit"
	set NEWLINE=TAB_"set CNT="
	if TIERLVL(1)'="" set NEWLINE=NEWLINE_"$S(FEECNT<"_NEXTLVL_":FEECNT-"_COUNT_",1:"_(NEXTLVL-TIERLVL)_")"
	else  set NEWLINE=NEWLINE_"FEECNT-"_COUNT
	
	set CODE($$LINE("sch"))=NEWLINE_",FEEAMT=("_TIERFEE_"*CNT)+"_BASEFEE_"+FEEAMT"
	set NEWLINE=TAB_"set:'$D(ONLINE) SCH("_SCHCNT_")=CNT"
	set CODE($$LINE("sch"))=NEWLINE_"_"_""""_"|"""_"_"_TIERFEE_"_"_""""_"|"""_"_"_BASEFEE
	set COUNT=TIERLVL(1)-1,SCHCNT=SCHCNT+1
	quit


FEETBL(FEETBL)	// Handle fee table lookup for fee amount 
	/* Approach -- create section for this table.  If table is CRDTYP or
	   UTBLSTPFEE, handle directly.  If other, then if any references
	   to ZDEP, instantiate new object, load keys from DEP or ZDEP,
	   then get fee amount
	*/

	new ACCKEYS,feetbl,GETCOLMN,I,KEYCNT,KEYSET,NEWLINE,NEWLIST
	new ORDER,SEARCH,WHERE,X

	set FEETBLNO=FEETBLNO+1
	set TBL(FEETBL)=FEETBLNO		// Save to use again, if needed

	type RecordUTBLFEETBL feetbl=Db.getRecord("UTBLFEETBL","FEETBL=:FEETBL")
	set GETCOLMN=feetbl.feed
	set SEARCH(1)=feetbl.search1
	set SEARCH(2)=feetbl.search2
	set SEARCH(3)=feetbl.search3
	set SEARCH(4)=feetbl.search4
	set SEARCH(5)=feetbl.search5
	set SEARCH(6)=feetbl.search6
	set SEARCH(7)=feetbl.search7
	set SEARCH(8)=feetbl.search8
	set SEARCH(9)=feetbl.search9

	// If FEETBL is CRDTYP or UTBLSTPFEE then need to already have key
	// loaded, just return fee amount
	if FEETBL="CRDTYP"!(FEETBL="UTBLSTPFEE") do {
		new KEY
		if FEETBL="CRDTYP" set KEY="CARDTYPE"
		else  set KEY="STPTYP"
		set CODE($$LINE("tbl"))="T"_+TBL(FEETBL)_"()"_TAB_"// "_FEETBL
		set CODE($$LINE("tbl"))=TAB_"type public String "_KEY
		set CODE($$LINE("tbl"))=TAB_"type Record"_FEETBL_" feeobj=Db.getRecord("""_FEETBL_""","""_KEY_"=:"_KEY_""")"
		set CODE($$LINE("tbl"))=TAB_"quit feeobj."_$$LOWER^%ZFUNC(GETCOLMN)
	}
	if  quit

	// If another table, need to pass dep object
	set CODE($$LINE("tbl"))="T"_+TBL(FEETBL)_"(RecordDEP dep)"_TAB_"// "_FEETBL
	set TBL(FEETBL)=TBL(FEETBL)_"|DEP"	// Flag to pass dep object

	do BLDKEYS(feetbl.file1,1)
	do BLDKEYS(feetbl.file2,2)
	do BLDKEYS(feetbl.file3,3)
	do BLDKEYS(feetbl.file4,4)
	do BLDKEYS(feetbl.file5,5)
	do BLDKEYS(feetbl.file6,6)
	do BLDKEYS(feetbl.file7,7)
	do BLDKEYS(feetbl.file8,8)
	do BLDKEYS(feetbl.file9,9)

	set CODE($$LINE("tbl"))=TAB_"new "_NEWLIST

	// Instantiate ZDEP if necessary
	if KEYSET["zdep." do {
		set CODE($$LINE("tbl"))=TAB_"type RecordZDEP zdep = Db.getRecord(""ZDEP"",""CID=:CID"")"
	}

	set CODE($$LINE("tbl"))=TAB_KEYSET

	// Build select to get fee amount
	// Get access keys to FEETBL and build up where clause
	type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:FEETBL", 1)
	if (dbtbl1.getMode() = 0) do ERR(22) quit
	set ACCKEYS=$$TOKEN^%ZS(dbtbl1.acckeys)
	set KEYCNT=1,(ORDER,WHERE)=""
	for I=1:1:$L(ACCKEYS,",") do {
		new KEY,OP
		set KEY=$P(ACCKEYS,",",I)
		quit:KEY?1.N				// Ignore numeric keys
		quit:$E(KEY)=$C(0)			// Ignore literal strings
		if SEARCH(KEYCNT)="N" do {		// Next
			set OP=" NOT < "
			set ORDER=ORDER_KEY_" ASC,"
		}
		else  if SEARCH(KEYCNT)="P" do {	// Previous
			set OP=" NOT > "
			set ORDER=ORDER_KEY_" DESC,"
		}
		else  set OP="="
		set WHERE=WHERE_KEY_OP_":KEY"_KEYCNT_" AND "
		set KEYCNT=KEYCNT+1
	}
	set WHERE=$E(WHERE,1,$L(WHERE)-5)		// Strip last " AND "
	set ORDER=$E(ORDER,1,$L(ORDER)-1)		// Strip comma
	set CODE($$LINE("tbl"))=TAB_"new feeamtrs"
	set NEWLINE=TAB_"type ResultSet feeamtrs=Db.select("""_GETCOLMN_""","""_FEETBL_""","""_WHERE
	if ORDER'="" set NEWLINE=NEWLINE_""","""_ORDER
	set NEWLINE=NEWLINE_""")"
	set CODE($$LINE("tbl"))=NEWLINE
	set CODE($$LINE("tbl"))=TAB_"if feeamtrs.isEmpty() quit 0"
	set CODE($$LINE("tbl"))=TAB_"if feeamtrs.next() quit feeamtrs.getCol(1)"
	set CODE($$LINE("tbl"))=TAB_"quit 0"

	quit


BLDKEYS(KEY,KEYNUM)	// Construct info related to keys
	/* Build list of key references (KEY1-n) to new in NEWLIST and list to
	   set (KEYSET) based on object references.  Since working with objects
	   dep and zdep, just lowercase the key list references to create
	   object references
	*/
	quit:KEY=""
	if KEYNUM=1 do {
		set NEWLIST="KEY1"
		set KEYSET="set KEY1="_$$LOWER^%ZFUNC(KEY)
	}
	else  do {
		set NEWLIST=NEWLIST_",KEY"_KEYNUM
		set KEYSET=KEYSET_",KEY"_KEYNUM_"="_$$LOWER^%ZFUNC(KEY)
	}
	quit


CONVERT(AMT)	// Put amount field to convert syntax 
	quit "$$CONV^CRCDUTL("_AMT_","_"CRCD"_","""_PLANCUR_""","_PLANEXC_")"


LINE(ref)	// Get next line number based on reference
	quit $O(CODE(TAGS(ref)),-1)+.0001


CMP	// Compile service fee program

	new CMPERR,PGM

	set PGM=$$^UFID(FEEPLAN,FEEDATE)
	set CODE(1)="public "_PGM_"(RecordDEP dep,FEECAT,FEETYP,FEECNT,NOTFSN,TAMT)"
	set CODE(1)=CODE(1)_TAB_"// "_$$DAT^%ZM(%CurrentDate,$G(%MSKD))_" "_$$TIM^%ZM_" - "_%UID
	set CODE(2)=TAB_"// "_DESC

	do BUILDRTN^UCGM(.CODE,PGM,.CMPERR)
	if $D(CMPERR) do {
		new N
		set N=""
		for  set N=$O(CMPERR(N)) quit:N=""  write CMPERR(N),!
		do ERR("")
	}
	quit



ERR(ECODE)	// Compile errors

	new EMSG

	// Set EMSG to allow to log into error log, then return in RM(2)

	// Fee category ~p1, type ~p2 is not a valid misc tran code
	if ECODE=1 set EMSG=$$^MSG(8386,FEECAT,FEETYP)
	// Fee category ~p1, type ~p2 has an invalid charge option (1)
	else  if ECODE=2 set EMSG=$$^MSG(8379,FEECAT,FEETYP)
	// Fee category ~p1, type ~p2 has an invalid fee schedule (~p3)
	else  if ECODE=3 set EMSG=$$^MSG(8380,FEECAT,FEETYP,FEESCH)
	// Fee category ~p1, type ~p2 has both a fixed fee amount and a fee schedule
	else  if ECODE=4 set EMSG=$$^MSG(8383,FEECAT,FEETYP)
	// Fee category ~p1, type ~p2 (CHGOPT'=1) - max daily amount does not apply
	else  if ECODE=5 set EMSG=$$^MSG(8375,FEECAT,FEETYP)
	// Fee category ~p1, type ~p2 is an invalid tran code group
	else  if ECODE=6 set EMSG=$$^MSG(8384,FEECAT,FEETYP)
	// Fee category ~p1, type ~p2 has an invalid tran code
	else  if ECODE=7 set EMSG=$$^MSG(8382,FEECAT,FEETYP)
	// Fee category ~p1, type ~p2 has an invalid query linkage (~p3)
	else  if ECODE=8 set EMSG=$$^MSG(8381,FEECAT,FEETYP,QRYNAME)
	// Fee category ~p1, type ~p2 (query ~p3) primary file not [DEP] or [LN]
	else  if ECODE=9 set EMSG=$$^MSG(8377,FEECAT,FEETYP,QRYNAME)
	// Fee category ~p1, type ~p2 (CHGOPT=1) - fee schedule tier cannot be ~P3
	else  if ECODE=10 set EMSG=$$^MSG(8376,FEECAT,FEETYP,TIER)  
	// Fee category ~p1, type ~p2 (SCHTYP=1) - fee schedule tier cannot be ~P3
	else  if ECODE=11 set EMSG=$$^MSG(8378,FEECAT,FEETYP,TIER)
	// Balance for fee computation not required
	else  if ECODE=12 set EMSG=$$^MSG(8373)
	// Balance for fee computation required
	else  if ECODE=13 set EMSG=$$^MSG(8374)        
	// Fee category ~p1, type ~p2 is linked to an invalid routine (~p3)
	else  if ECODE=14 set EMSG=$$^MSG(8385,FEECAT,FEETYP,PGMLNK)
	// Type ~p1, transaction code ~p2 does not consider direct transaction fees.
	else  if ECODE=15 set EMSG=$$^MSG(8675,FEETYP,ETC)
	// Type ~p1, transaction code ~p2 does not contain a transaction fee plan
	else  if ECODE=16 set EMSG=$$^MSG(213,FEETYP,ETC)
	// Fee schedule for fee computation is not required in fee category
	// ~p1, type ~p2 (CHGOPT=1)
	else  if ECODE=17 set EMSG=$$^MSG(215,FEECAT,FEETYP)
	// Minimum fee amount not required.
	else  if ECODE=18 set EMSG=$$^MSG(280)
	// Maximum fee amount not required.
	else  if ECODE=19 set EMSG=$$^MSG(282)
	// Type ~p1, close-out transaction code ~p2 fee charge at analysis is invalid
	else  if ECODE=20 set EMSG=$$^MSG(1258,FEETYP,ETC)
	// Fee category ~p1, type ~p2 - cannot have a fee schedule - DLY/STP fee type
	else  if ECODE=21 set EMSG=$$^MSG(4363,FEECAT,FEETYP)
	// Invalid table name - ~p1
	else  if ECODE=22 set EMSG=$$^MSG(1484, FEETBL)

	set ET="SRVCMP"
	do ^UTLERR
	set ER=1
	if $D(EMSG) set RM(1)=RM,RM(2)=EMSG

	quit


COMPILE1	// Compile just one plan and date via character prompting
		// Called by function SRVCMP

	new FEEDT,OLNTB,PLAN,%READ,%TAB,VFMQ

	set %TAB("PLAN")=".PLAN8/TBL=[FEEPLN]PLAN:DISTINCT"
	set %TAB("FEEDT")=".EFD1/TBL=[FEEPLN]FEEDT:QU ""[FEEPLN]PLAN=<<PLAN>>"""
	set %READ="@@%FN,,,PLAN/REQ,FEEDT/REQ"
	do ^UTLREAD
	if VFMQ'="Q" do {
		do ^SRVCMP(PLAN,FEEDT)
		// Service fee plan ~p1 compiled
		if 'ER set RM=$$^MSG(2480,PLAN),ER="W"
		}
	quit



ALL	// Mass re-compile all service fee plan

	new VFMQ

	// If interactive, display prompt to continue or not
	if $$INTRACT^%ZFUNC do {
		new CONT,%READ,%TAB
		set %TAB("CONT")=".CONT2"
		set %READ="@@%FN,,,CONT/REQ"
		do ^UTLREAD
		if VFMQ'="Q",'CONT set VFMQ="Q"
		}
	quit:$G(VFMQ)="Q"

	// Compile them
	type ResultSet feeplnrs=Db.select("PLAN,FEEDT","FEEPLN",,"PLAN,FEEDT")
	if feeplnrs.isEmpty() quit
	
	while feeplnrs.next() do {
		new ER,FEEPLAN,FEEDATE,RM
		set FEEPLAN=feeplnrs.getCol(1)
		set FEEDATE=feeplnrs.getCol(2)
		write $$^MSG(4653,"","")_FEEPLAN_" "_$$DAT^%ZM(FEEDATE,$G(%MSKD))_"...", !
		set ER=0
		do SRVCMP(FEEPLAN,FEEDATE)
		if ER do {
			new MSG
			if $G(RM(2))'="" set MSG=RM(2)
			else  set MSG=$G(RM)
			if MSG'="" write MSG, !
			}
	}

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60571^62551^Laura Hillanbrand^23343"	// Signature - LTD^TIME^USER^SIZE
