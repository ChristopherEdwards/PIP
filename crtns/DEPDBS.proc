DEPDBS
 	/*
	 PROCEDURE ID:	DEPDBS
	     Original:	
		 Date:	
	         Desc:	Deposit account post-processors
 
	---- Revision History ------------------------------------------------

	11/09/06 - KinI - CR22979
		   Removed PCTAX section as it should have been deleted along
		   with some obsoleted Patagon system area elements (Premature 
		   Withdrawal Tax processing).
		   Modified CWI and CWIP sections to remove PCTAX section call 
		   and PCTAXAMT variable references.
		   	
	11/29/06 - MbuiM - CR 21675
		   Changed reference of INTAVLNC to INTAVLNCR to comply with 
		   GTM version 5.0. In lower versions INTAVLNCR was set but 
		   trancated to INTAVLNCR (8 character limit). This is now not
		   an issue in GTM version 5.0. Everything is changed to use
		   INTAVLNCR and since there are no other variables that start 
		   with INTAVLNC,it's OK regardless of version.
		   
	09/18/06 - KinI - CR23161
		   Modified FEE10 section to correct syntax when composing
		   the fee plan runtime program call.
	
	05/25/06 - DESHPANDE S K - CR 20748
		   Removed references to public variables %TRNSEQ and SEQ from 
		   section CWIPEFD. Also removed call to setErrMSG("TTX",883)
		   as it it is no longer required in Profile04 archictecture. 
		   
	05/31/06 - SANTHUMS - CR 21314
		   Initialized PRIN to set dep.bal in the CLSINI section.
		   		    	
	05/24/06 - GIRIDHAL - CR21297
		   Removed all references to SPLTDY since it is being obsoleted.

	03/28/06 - RussellDS - CR20344
		   Fix CHKLEAD seciton to eliminate error where not quiting
		   with return value in some cases.
	
	03/23/06 - Alagarss - CR 20052
		   Modified the code to avoid undefined error %TRNSEQ and DIR.
		   
	02/13/06 - RussellDS - CR19527
		   Correct reference to variable INTAVLNC which had an R on the
		   end and causes problems in GT.M 5.0.

	10/07/05 - SmithCD - CR 16885
		   . Removed 4th and 5th parameters in call to EXEC^UANTIC
		   . Replaced deprecated features
		   . Resolved "PSL-W-Undefined Variable: BAL" warning in PV 
		     section
		   . Corrected parameters in calls to EXT^DEPIADJ
		   . Removed old revision history
		   
	*/

	quit


public CALC(CID,%EffectiveDate,MDT)

	/* Calc Rate Based on Term and Balance
	Called from DEP_TRM_1 pre/post proc library.

	Arguments:
		. CID		Account number	/TYP=N/REQ/MECH=VAL
		. %EffectiveDate Effective date	/TYP=D/REQ/MECH=VAL
		. MDT		Maturity date	/TYP=D/REQ/MECH=VAL

	Returns:
 		. IRN	Interest rate value	/TYP=N
	*/

	type RecordDEP dep=Db.getRecord("DEP","CID",1)
	if 'dep.getMode() quit

	if dep.sch="" set IRN="" quit

	set IRN=$$RSCH^URSCH(dep.sch,dep.org,%EffectiveDate,MDT,dep.rsintspr,dep.rsrndmtd)

	quit
	

	/* Transaction Code Pre/Post Processing

	NOTE: In version 5.0, IRA Auto-distribution routines IRADIS1 and
	IRADIS2 were changed to get the closeout amount from the product type 
	closeout tran code pre-processor.  Previous versions called internal 
	line tags in IRADIS1,2 corresponding to the closeout routine name, 
	which prevented custom closeout	routines.
	Also in V5.0, transaction code post-processors have been changed to 
	call a private RPC when on a client to return the default amount for 
	the transation. Information about the account is now held in and 
	referenced by the data item name and not %A or ^ACN.
	*/

public C(RecordDEP dep,RecordTTX ttx,RecordTRN trn,DWA,DSWA)
	/* Close account (BAL-WTH)		^DEPCL("00")

	Arguments:
 		. dep	Deposit account object	/TYP=RecordDEP/REQ
		. ttx	Transaction object	/TYP=RecordTTX/NOREQ
		. trn	Transaction code object	/TYP=RecordTRN/REQ
		. DWA	Distr w/h amount	/TYP=N/NOREQ/MECH=REFNAM
		. DSWA	Distr state w/h amount	/TYP=N/NOREQ/MECH=REFNAM

	Inputs:
		. DFT("AMT")	Default amount		/TYP=N
	*/

	// Skip if error correct or reversal
	if $E(trn.itc,6)!$E(trn.itc,12) quit

	new AIACR,BAL,BWF,BALCL,CRCD,CUMDEP,DBWA,DEFINADJ,DNINT,DPINT,DRINT
	new INTAVLNCR,IPL,IRN,NEGACR,NEGACRUN,RESINT,STAT,UNCACR

	set DWA=$G(DWA)
	set DSWA=$G(DSWA)

	do CLSINI(.dep,.trn)

	// For discount CDs, the closeout amount is always the ledger balance
	if dep.salesprc set DFT("AMT")=dep.bal quit

	if 'DEFINADJ set (DPINT,DNINT,DRINT,DBWA)=0
	else  do EXT^DEPIADJ(.dep,,.DPINT,.DNINT,.DRINT,.DBWA) quit:ER

	set BALCL=BAL+INTAVLNCR+DPINT-DNINT-DRINT-DBWA

	do CLOSE(.dep,.trn,BALCL,.DWA,.DSWA)

	quit 
	

public CWIP(RecordDEP dep,	// Deposit account object
	    RecordTTX ttx,	// Transaction object
	    RecordTRN trn,	// Transaction code object
	    %EffectiveDate,	// Effective date	
	    Number DWA,		// Distr w/h amount
	    Number DSWA) 	// Distr state w/h amount
	    
	// Close account (BAL+ACR-PEN-WTH) 	^DEPCL(11)
	// Input:	. DFT("AMT")	Default amount		/TYP=N

	// Skip if error correct or reversal
	if trn.itc.extract(6)!trn.itc.extract(12) quit

	type Number ADJ, ADJW, AIACR, BALCL, BAL, BWA, DBWA, BWF, CUMINT, DNINT
	type Number DPINT, DRINT, INT, INTAVLNCR, IPL, IRN, NEGACR, NEGACRUN
	type Number PEN, RESINT, STAT, UNCACR
	type String CRCD
	type Boolean CUMDEP, DEFINADJ

	set DWA=DWA.get()
	set DSWA=DSWA.get()

	do CLSINI(.dep,.trn)

	// In order to avoid making changes to original dep object, a copy of
	// the object will be used throughout this section.
	type RecordDEP cpdep=dep.copy()

	if 'ttx.exists() set ttx=Class.new("RecordTTX")

	/* CWIPEFD calls RECALC which will adjust .cpdep to reflect changes 
	caused by ADJINT and ADJACR.  These figures will be accounted for when
	info passed to UMAT. */
	if (%EffectiveDate&(%SystemDate-%EffectiveDate)) do CWIPEFD(.cpdep,.trn) quit:ER 

	/* Get the following data: 
	ADJ	Accrual adjustment (grace period)
	ADJW	Withholding tax accrual adjustment (grace period)
	BWA	Backup withholding
	INT	Interest amount
	PEN	Penalty amount */
	do ^UMAT(.cpdep,.ttx)
 	
	// ALL amounts must be rounded prior to calculation of BALCL as these
	// figures are rounded in TAMT singlely.
	set NEGACR=NEGACR.roundDec()
	set NEGADJ=NEGADJ.roundDec()
	set NEGACRUN=NEGACRUN.roundDec()
	set UNCACR=UNCACR.roundDec()
	set AIACR=AIACR.roundDec()
 	
	// No closeouts w/int for Low balance accounts with negative accrual
	do CHECKLB(dep.ircb,NEGACR,NEGACRUN,UNCACR) quit:ER 

	if 'DEFINADJ set (DPINT,DNINT,DRINT,DBWA)=0
	else  do DEFINT(.cpdep,.ttx,.DPINT,.DNINT,.DRINT,.DBWA) quit:ER 
	
	// Cumulative interest adjustment
	if 'dep.schproc set CUMINT=0
	else  do CUMDEP(.cpdep,INT,IPL) quit:ER 

	// INT includes the adjustment (ADJACR) from RECALC.
	// ADJ is the adjustment for grace period adjustment GOPT.
	set BALCL=+BAL+INT+INTAVLNCR+ADJ-PEN-BWA-NEGACR-NEGACRUN-RESINT
	set BALCL=BALCL+DPINT-DNINT-DRINT-DBWA-UNCACR+AIACR+CUMINT
	if %EffectiveDate,%SystemDate-%EffectiveDate set BALCL=BALCL-NEGADJ
	
	do CLOSE(.cpdep,.trn,BALCL,.DWA,.DSWA)
	
	quit 
	

public CWP(RecordDEP dep,RecordTTX ttx,RecordTRN trn,%EffectiveDate,DWA,DSWA)
	/* Close account (BAL-PEN-WTH) 	^DEPCL("01")

	Arguments:
		. dep		Deposit account object	/TYP=RecordDEP/REQ
		. ttx		Transaction object	/TYP=RecordTTX/NOREQ
		. trn		Transaction code object	/TYP=RecordTRN/REQ
		. %EffectiveDate Effective date		/TYP=D/REQ/MECH=VAL
		. DWA		Distr w/h amount	/TYP=N/NOREQ/MECH=REFNAM
		. DSWA		Distr state w/h amount	/TYP=N/NOREQ/MECH=REFNAM
	*/

	// Skip if error correct or reversal
	if $E(trn.itc,6)!$E(trn.itc,12) quit 
	
	new AIACR,ADJ,BAL,BWA,BWF,BALCL,CRCD,CUMDEP,DBWA,DEFINADJ,DNINT,DPINT
	new DRINT,INTAVLNCR,IPL,IRN,INT,NEGACR,NEGACRUN,PEN,RESINT
	new STAT,UNCACR

	set DWA=$G(DWA)
	set DSWA=$G(DSWA)
	if 'ttx.exists() set ttx=Class.new("RecordTTX")

	do CLSINI(.dep,.trn)

	// Returns: ADJ,BWA,INT,PEN
	do ^UMAT(.dep,.ttx)
	
	if 'DEFINADJ set (DPINT,DNINT,DRINT,DBWA)=0
	else  do DEFINT(.dep,.ttx,.DPINT,.DNINT,.DRINT,.DBWA) quit:ER 
	
	set BALCL=+BAL-PEN+ADJ+INTAVLNCR+DPINT-DNINT-DRINT-DBWA

	do CLOSE(.dep,.trn,BALCL,.DWA,.DSWA)

	quit 
	

public CWI(RecordDEP dep,	// Deposit account object	
	   RecordTTX ttx,	// Transaction object
	   RecordTRN trn,	// Transaction code object
	   Number DWA,		// Distr w/h amount	
	   Number DSWA)		// Distr state w/h amount
	   
	// Close account w/Interest w/o Penalty (BAL+ACR-WTH)	^DEPCL(10)

	// Skip if error correct or reversal
	if trn.itc.extract(6)!trn.itc.extract(12) quit 

	type Number ADJ, ADJW, AIACR, BALCL, BAL, BWA, CTL, BWF, CUMINT, DBWA
	type Number DNINT, DPINT, DRINT,INT, INTAVLNCR, IPL, IRN, NEGACR 
	type Number NEGACRUN, PEN, RESINT, STAT, UNCACR
	type String CRCD
	type Boolean CUMDEP, DEFINADJ
	
	set DWA=DWA.get()
	set DSWA=DSWA.get()
	if 'ttx.exists() set ttx=Class.new("RecordTTX")

	do CLSINI(.dep,.trn)

	set CTL=10

	// In order to avoid making changes to original dep object, a copy of 
	// the object will be used throughout this section.
	type RecordDEP cpdep=dep.copy()

	/* CWIPEFD calls RECALC which will adjust account level data to reflect
	   changes caused by ADJINT and ADJACR.  These figures will be 
	   accounted for when info passed to UMAT. */
	if (%EffectiveDate&(%SystemDate-%EffectiveDate)) do CWIPEFD(.cpdep,.trn) quit:ER 
	
	// Returns: ADJ,BWA,INT,PEN
	do ^UMAT(.cpdep,.ttx)
	
	// ALL amounts must be rounded prior to calculation of BALCL as these
	// figures are rouned in TAMT singlely. 
	set NEGACR=NEGACR.roundDec()
	set NEGADJ=NEGADJ.roundDec()
	set NEGACRUN=NEGACRUN.roundDec()
	set UNCACR=UNCACR.roundDec()
	set AIACR=AIACR.roundDec()
	
	// No closeouts w/int for Low balance accounts with negative accrual
	do CHECKLB(dep.ircb,NEGACR,NEGACRUN,UNCACR) quit:ER 
	
	if 'DEFINADJ set (DPINT,DNINT,DRINT,DBWA)=0
	else  do DEFINT(.cpdep,.ttx,.DPINT,.DNINT,.DRINT,.DBWA) quit:ER 
	
	// Cumulative interest adjustment
	if 'dep.schproc set CUMINT=0
	else  do CUMDEP(.cpdep,INT,IPL) quit:ER 
	
	// INT includes the adjustment (ADJACR) from RECALC.
	// ADJ is the adjustment for grace period adjustment GOPT.
	set BALCL=+dep.bal+INT+dep.intavlncr-BWA+ADJ-NEGACR-NEGACRUN-dep.resint
	set BALCL=BALCL+DPINT-DNINT-DRINT-DBWA-UNCACR+AIACR+CUMINT
	if %EffectiveDate,%SystemDate-%EffectiveDate set BALCL=BALCL-NEGADJ

	do CLOSE(.cpdep,.trn,BALCL,.DWA,.DSWA)
	
	quit 
	

CWIPEFD(RecordDEP dep,RecordTRN trn)
	/* Get amount for effective dated closeouts
	Arguments:
		. dep		Deposit account object	/TYP=RecordDEP/REQ
		. trn		Transaction code	/TYP=RecordTRN/REQ

	Input:
		. %TRNSEQ	transaction sequence, comes from TRNDRV	/TYP=N
	*/
	type public Number DIR
	
	if dep.ipld="" do { quit:ER 
		if dep.ipf=""!(dep.inp="") quit 
		set dep.ipld=$$NJD^UFRE(dep.inp,"-"_dep.ipf) quit:ER
		}

	// Closeout effective in prior int/div posting period
	if %EffectiveDate<(dep.ipld+CUVAR.IPD) do Runtime.setErrMSG("TTX",557) quit

	// Closeout effective prior to date last renewed
	if %EffectiveDate<dep.dlr do Runtime.setErrMSG("TTX",558) quit
	
	// Closeout effective prior to history cutoff date
	if %EffectiveDate'>dep.hisctf do Runtime.setErrMSG("TTX",559) quit
	
	/* Protect TR, then set TR with single transaction for RECALC - MRR
	The following line may be a temporary way to ensure that multiple
	transactions to the same account being closed are not on the same
	screen. */
	
	/* ttxtmp object will be passed to RECALC for processing, while 
	original transaction is saved */
	type RecordTTX ttxtmp=Class.new("RecordTTX")

	set ttxtmp.cid=dep.cid
	set ttxtmp.itc=trn.itc
	set ttxtmp.etc=trn.etc
	set ttxtmp.tamt=dep.bal*DIR
	set ttxtmp.efd=%EffectiveDate
	if %MCP set ttxtmp.crcd=dep.crcd

	// Process colseout
	do CWIP2(.dep,.ttxtmp,dep.bal,dep.posacr,NEGACR,NEGACRUN,dep.resint,UNCACR)

	// Segments in use flag
	if dep.segflg do { quit 
		set ADJACR=$G(ADJACR)
		set ADJAWT=$G(ADJAWT)
		set (ADJINT,PEN,NEGADJ)=""
		}

	set ADJINT=$G(ADJINT)
	set ADJACR=$G(ADJACR)
	set ADJAWT=$G(ADJAWT)
	set PEN=$G(PEN)
	set NEGADJ=$G(NEGADJ)

	quit 

	
CWIP2(RecordDEP dep,RecordTTX ttxtmp,OBAL,ACR,NEGACR,NEGACRUN,RESINT,UNCACR)
	
	new BAL,MINACR

	if dep.segflg do { quit 
		new RSPAR
		set RSPAR("CLOSE")=1
		set RSPAR("EXSKIP")=1
		do EXTERN^RECALSEG(.dep,.ttxtmp,.RSPAR)
		}
	
	// Future-dated closeout
	if %EffectiveDate>%SystemDate do { quit 
		new DLR,ETC,ORIGACR,ORIGAWT,ORIGNADJ,ORIGNUNA

		set ORIGACR=dep.posacr
		set ORIGAWT=dep.awt
		set ORIGNADJ=dep.negacr
		set ORIGNUNA=dep.negacrun
	
		// protect DLR
		set DLR=dep.dlr
		do EXEC^UANTIC(.dep,.ttxtmp,,%EffectiveDate,"00")
		// Date Last Renewed
		set dep.dlr=DLR
	
		// Positive Accrued Int/Div
		set ADJACR=dep.posacr-ORIGACR
		// Accrued Withholding Tax
		set ADJAWT=dep.awt-ORIGAWT
		// Negative Accrued
		set NEGADJ=dep.negacr-ORIGNADJ
		// Negative Accrued Interest Unauthorized
		set NEGADJ=NEGADJ+(dep.negacrun-ORIGNUNA)
		set PRIN=dep.bal
		}
	
	/* Set BAL to zero to "trick" RECALC into thinking that the
	transaction has been processed. */
	if OBAL>0 set BAL=0
	else  set BAL=OBAL
	
	/* Null out Minimum Balance to Accrue Int/Div. This is necessary as 
	RECALC will zero out the ACR if the balance drops below MINACR 
	(which in all likelihood it will). */
	set MINACR=""
	
	// Make dep.bal look as if balance already gone to zero for recalc
	set dep.bal=0
	
	do ENT^RECALC(.dep,.ttxtmp)
	
	/* Reset dep.bal for calculation of service fee. Query on [DEP]BAL
	results in an incorrect fee if dep.bal=0  */
	set dep.bal=OBAL

	quit 
	

CLSINI(RecordDEP dep,RecordTRN trn)
	/* Initialize variables. These variables should be used throughout 
	the program because their values may be changed by called processes.

	Arguments:
		. dep	Deposit account		/TYP=RecordDEP/REQ

	Inputs: AIACR,BAL,BWF,CRCD,CUMDEP,DEFINADJ,INTAVLNCR,IPL,IRN,
	  	NEGACR,NEGADJ,NEGACRUN,RESINT,STAT,UNCACR
	*/

	type public Number DIR,PRIN
	// Cannot close lead account used in account analysis
	quit:$$CHKLEAD(dep.cid,dep.anltyp)

	// Available interest accrual
	set AIACR=dep.aiacr
	// Ledger balance
	set (BAL,PRIN)=dep.bal
	// Backup Withholding
	set BWF=dep.bwf
	// Currency Code
	set CRCD=dep.crcd
	// Cumulative Interest
	set CUMDEP=dep.schproc
	// Defer Posting Int Adjustments
	set DEFINADJ=dep.definadj
	// Interest Paid Not Credited
	set INTAVLNCR=dep.intavlncr
	// Nominal Int/Div Rate
	set IRN=dep.irn
	// Int/Div Paid - Life
	set IPL=dep.ipl
	// Negative accrual	
	set NEGACR=dep.negacr
	// Negative interest adjustment
	set NEGADJ=$G(NEGADJ)
	// Negative accrued unauthorized
	set NEGACRUN=dep.negacrun
	// Residual Interest
	set RESINT=dep.resint
	// Account Status
	set STAT=dep.stat
	// Uncollected accrued
	set UNCACR=dep.uncacr
	
	
	// Determine whether we should be working with a debit balance closeout.
	if dep.trb-$E(trn.itc) set DIR=-1
	else  set DIR=1

	quit	


public CLOSE(RecordDEP dep,RecordTRN trn,BALCL,DWA,DSWA)
	/* 
	Arguments:
 		. dep	Deposit account object	/TYP=RecordDEP/REQ
		. trn	Transaction code 	/TYP=RecordTRN/REQ
 		. BALCL Closeout balance	/TYP=N/REQ/MECH=VAL
		. DSWA	Distr w/h amount	/TYP=N/REQ/MECH=REFNAM
		. DWA	Distr state w/h amount	/TYP=N/REQ/MECH=REFNAM

	Returns:
		. DFT("AMT")	Default amount	/TYP=N
	*/

	new DFTAMT,DIR,FEEAMT,FEEACT,STTAX

	set (FEEAMT,FEEACT)=0

	// Determine whether we should be working with a debit balance closeout.
	if dep.trb-$E(trn.itc) set DIR=-1
	else  set DIR=1

 	do FEES(.dep,.trn,.FEEAMT,.FEEACT,.DWA,.DSWA)

	if dep.ira do { quit:ER
		new ACN,CID,RPASEQ,STTAX,TAMT
		set TAMT=BALCL-FEEACT-FEEAMT

		set ACN=dep.acn
		// Retirement Plan Account Sequence Number
		set RPASEQ=dep.rpaseq
		set CID=dep.cid

		/* Calculate Federal and State Withholding (STTAX=0,1)
		Input: STTAX; Returns: DWA,DSWA */
		for STTAX=0:1:1 do CLOSE^IRAWH(.dep)
		}

	// Closeout default amount
	set DFTAMT=$$^SCARND(BALCL-DWA-DSWA-FEEACT-FEEAMT-dep.aecamt,0,dep.cid)
	
	// Closeout amount is negative
	if DFTAMT<0,DIR>0 do Runtime.setErrMSG("TTX",555) quit
	
	// Closeout amount is not negative
	if DFTAMT>0,DIR<0 do Runtime.setErrMSG("TTX",556) quit
	
	set DFT("AMT")=DFTAMT*DIR

	quit
	

public CHKLEAD(CID,ANLTYP)
	/* Check if account is a primary account used in account analysis
	
	Arguments:
		. CID		Account number		/TYP=N/REQ/MECH=VAL
		. ANLTYP	Analysis Account Type	/TYP=N/REQ/MECH=VAL

	Returns:
		. $$	Lead account flag		/TYP=L
				1 - Used in account analysis
				0 - Not used in account analysis
	*/
	set ER=0

	if ANLTYP=1 do {
		
		type ResultSet rs=Db.select("ANLCID","DEP","ANLCID=:CID AND STAT<>4")
		// Cannot close the lead account used in account analysis
		if 'rs.isEmpty() do Runtime.setErrMSG("DEP",4357) quit:ER
	}

	quit ER


public IP(RecordDEP dep)
	/* Interest Payment - default amount

	Arguments:
		. dep	Deposit account object	/TYP=RecordDEP/REQ

	Input:
		. ITC	Internal transaction code	/TYP=N

	Returns:
		. DFT("AMT")	Default amount		/TYP=N
	*/

	new DA

	if dep.negipo=2 do {
		// credit
		if ITC set DA=dep.posacr
		// debit
		else  set DA=dep.negacr
		}
	else  set DA=dep.acr
	
	set DFT("AMT")=$$^SCARND(DA,0,dep.cid)

	quit 
	

public STMGRP(RecordDEP dep) 
	/* Post processor for Statement Group field on new account set-up.
	Called from DEPINV0 screen

	Inputs:
		. ACN	Customer Number		/TYP=N/REQ
		. X	Statement Group		/TYP=T/REQ
		. I()
	*/
	if X set I(3)=""
	// Statement Flag
	if X="",'dep.smet quit

	// Not a statement account
	if 'dep.smet do Runtime.setErrMSG("DEP",2024) quit

	// If defined in product, DO NOT require a statement group

	type RecordPRODDFTD proddftd=Db.getRecord("PRODDFTD","TYPE",1)
	if proddftd.sfre quit

	// Statement group required
	if 'X do Runtime.setErrMSG("PRODDFTD",2537) quit

	type RecordCMBGRP cmbgrp=Db.getRecord("CMBGRP","ACN,X",1)
	
	// New statement grp
	if 'cmbgrp.getMode() quit

	// Restricted Statement Group
	if 'cmbgrp.rest quit

	// No accounts in restricted group
	type ResultSet rs=Db.select("CID","CMBSTM","ACN=:ACN AND STMGRP=:X")
	if rs.isEmpty() quit

	// Restricted statement group.  Only one account allowed.
	do Runtime.setErrMSG("PRODDFTD",2406)

	quit 
	

public NOTEFD(NOTMIN,NOTICE,NOTNBC,NOTDAT)
	/* Get date notice of withdrawl effective
	Arguments:
		. NOTMIN	Minimum Notice Period	/TYP=N/REQ/MECH=VAL
		. NOTICE	Notice Account Flag	/TYP=N/REQ/MECH=VAL
		. NOTNBC	Notice Days Non-Business Date Calendar
							/TYP=T/NOREQ/MECH=VAL
		. NOTDAT	Date Notice of Withdrawal Given
							/TYP=D/NOREQ/MECH=VAL
	Returns:
		. $$	Date notice of withdrawl effective	TYP=D
	*/

	if $G(NOTDAT)="" quit ""
	if $G(NOTNBC)'="" quit $$NBD^UNBD(NOTDAT+1,NOTMIN,0,NOTNBC)

	quit $S(NOTDAT:NOTDAT+NOTMIN,1:"")


public NOTEXP(NOTMAX,NOTNBC,NOTEFD)
	/* Get date notice of withdrawl expires
	Arguments:
		. NOTMAX	Maximum Number of Days Notice Effecti
							/TYP=N/REQ/MECH=VAL
		. NOTNBC	Notice Days Non-Business Date Calendar
							/TYP=T/NOREQ/MECH=VAL
		. NOTEFD	Date Notice of Withdrawal Effective
							/TYP=D/NOREQ/MECH=VAL
	Returns:
		. $$	Date notice of withdrawl expires	/TYP=D
	*/

	if $G(NOTEFD)="" quit ""
	if $G(NOTNBC)'="" quit $$NBD^UNBD(NOTEFD+1,NOTMAX,0,NOTNBC)

	quit $S(NOTEFD:NOTEFD+NOTMAX,1:"")


public FEES(RecordDEP dep,RecordTRN trn,FEEAMT,FEEACT,DWA,DSWA)
	/* Process service fees and direct transaction fees. Determine direct 
	transaction fee and closeout service fees.

	Arguments:
		. dep		Deposit account		/TYP=RecordDEP/REQ
		. trn		Transacton code obj	/TYP=RecordTRN/REQ
 		. FEEAMT	Direct transaction fee	/TYP=N/REQ/MECH=REFNAM
		. FEEACT	Closeout service fees	/TYP=N/REQ/MECH=REFNAM
		. DWA		Distribution w/h amount	/TYP=N/REQ/MECH=VAL
		. DSWA		Distr state w/h amount	/TYP=N/REQ/MECH=VAL
	*/
	new AIACR,BAL,BWF,CRCD,CRT,CUMDEP,DEFINADJ,INTAVLNCR,IPL,IRN
	new NEGACR,NEGADJ,NEGACRUN,RESINT,STAT,UNCACR

	do CLSINI(.dep,.trn)

	set FEEAMT=0
	set FEEACT=0

	// Substract service charges
	// direct transaction fee
	if $E(trn.pcf,10) set FEEAMT=$$FEE10(.dep,.trn,.FEEAMT) quit:$G(ER)
	// closeout service fees
	if dep.feepln'="",$E(trn.pcf,9) set FEEACT=$$FEE9(.dep,.FEEACT)

	quit 
	

FEE9(RecordDEP dep,FEEACT)
	/* This function is used to calculate closeout service fees

	Arguments:
		. dep		Deposit account		/TYP=RecordDEP/REQ
		. FEEACT	Closeout service fees	/TYP=N/REQ/MECH=REFNAM
	*/

	// New this variable bacause BCHFEEUTL may reset it.
	new FEEAMT

	// Get FEEACT
	do EXTERN^BCHFEEUT(.dep,"11",$S(%EffectiveDate:%EffectiveDate,1:%SystemDate)) quit:$G(ER)

	// Add Federal and State Withholding to FEEACT
	if FEEACT,dep.ira set FEEACT=FEEACT+$$RPACRT^IRAWH(.dep,CUVAR.RPAFEE,FEEACT)+$$RPACRTS^IRAWH(.dep,CUVAR.RPAFEE,FEEACT)
	
	// Calculate CPMF charges on Service Fees.
	if FEEACT set FEEACT=FEEACT+$$CTFCALC(.dep,FEEACT)

	quit
	

FEE10(RecordDEP	dep,RecordTRN trn,FEEAMT)
	/* The function is used to calculate direct transaction fee amount

	Arguments:
		. dep		Deposit account		/TYP=RecordDEP/REQ
		. trn		Transaction code record	/TYP=RecordTRN/REQ
		. FEEGRP	Tran Code Group		/TYP=T/REQ/MECH=VAL
		. FEEAMT	Direct transaction fee	/TYP=N/REQ/MECH=REFNAM
	
	Inputs:
		. BALCL		Closeout balance		/TYP=N
		. DWA		Distribution w/h amount		/TYP=N
		. DSWA		Distribution state w/h amount	/TYP=N
	*/
	
	type Number TAMT
	type String FEEGRP, MAXDLY, PGM

	// Fee not taken from closing account
	if dep.svcfeecid'="" quit FEEAMT

	// Fee plan not on transaction
	if trn.feepln="" quit FEEAMT

	// Feeplan does not contain direct transaction fees
	if trn.feegrp="" quit FEEAMT

	set MAXDLY=""
	set TAMT=BALCL-DWA-DSWA-dep.aecamt

	// Find correct posting program get program from ^FEEPGM
	set PGM=$$FEEPGM^UFID(trn.feepln,$S(%EffectiveDate:%EffectiveDate,1:%SystemDate))

	// Service fee plan ~p1 not compiled
	if PGM="" do Runtime.setErrMSG("FEEPLN",2481,trn.feepln) quit FEEAMT

	set FEEGRP=trn.feegrp
	set PGM="^"_PGM_"(.dep,3,FEEGRP,1,1,"_TAMT_")"
	do @PGM quit:ER FEEAMT

	// Fee amount not adjusted
	if (FEEAMT>TAMT),dep.feeopt set FEEAMT=$$FEEOPT^SRVTRN2(.dep,.trn,TAMT)
	
	// Add Federal and State withholding to fee amount
	if FEEAMT,dep.ira set FEEAMT=FEEAMT+$$RPACRT^IRAWH(.dep,CUVAR.RPAFEE,FEEAMT)+$$RPACRTS^IRAWH(.dep,CUVAR.RPAFEE,FEEAMT)	
	
	// Calculate CPMF charges on Service Fees.
	if FEEAMT set FEEAMT=FEEAMT+$$CTFCALC(.dep,FEEAMT)
	
	quit FEEAMT
	

public PV(ODT,FV,IACM,IRN,DAYS,CMP)
	/* Return present value (sales price)
	ARGUMENTS:
		. ODT          Opening date            /TYP=D/REQ/MECH=VAL
		. FV           Future Value            /TYP=$/REQ/MECH=VAL
		. IACM         Accrual Method          /TYP=N/REQ/MECH=VAL
		. IRN          Nominal Rate            /TYP=N/REQ/MECH=VAL
				Rate expressed at % e.g. 10% would be 10
		. DAYS         Days to calculate       /TYP=N/REQ/MECH=VAL
				Days in period (inclusive)
		. CMP          Daily Compounding       /TYP=L/NOREQ/MECH=VAL
	RETURNS:
		. $$     Present value
	*/

	new OLDBAL,HIGH,LOW,ACR,X,BAL

	set CMP=$G(CMP)
	set ACR=""
	set OLDBAL=""
	set HIGH=FV 
	set LOW=0
	set BAL=""

	for  do { if +BAL=FV!(BAL-OLDBAL=0) quit 
		set OLDBAL=BAL
		set ACR=""
		set X=(HIGH-LOW)/2
		set PV=HIGH-X
		set PV=$$^SCARND(PV,0,,,2)
		set BAL=PV
	
		if CMP for I=1:1:DAYS set ACR=$$IACM(IACM,DAYS,IRN) set BAL=BAL+ACR
		if 'CMP for I=1:1:DAYS set ACR=$$IACM(IACM,DAYS,IRN)+ACR
		if 'CMP set BAL=BAL+ACR
		set BAL=$$^SCARND(BAL,0,,,2)
		if BAL>FV set HIGH=PV
		if BAL<FV set LOW=PV
		}

	quit PV
	

IACM(IACM,DAYS,IRN)	// Interest accrual calculation method
	new ACR,DY
	
	set DY=$$DY^UIC(IACM,ODT+DAYS-1)
	if IACM="00" set ACR=BAL*IRN/100/365
	if IACM="01" set ACR=BAL*IRN/100*360/DY/DY
	if IACM="10" set ACR=BAL*IRN/100/360
	if IACM=11 set ACR=BAL*IRN/100/DY

	quit ACR
	

public CLOSAMT1(RecordDEP dep,RecordTTX ttx)
	/* Determine closeout amount upon which to calculate withholding

	Arguments:
		. dep	Deposit account object	/TYP=RecordDEP/REQ
		. ttx	Transaction object	/TYP=RecordTTX/REQ

	Returns:
		. $$	Closeout amount		/TYP=N
	*/

	new DFT,DWA,DSWA,ETC
	
	set (DWA,DSWA)=0
	set ETC=ttx.etc

	type RecordTRN trn=Db.getRecord("TRN","ETC")

	if 'CINT,'CPEN do C(.dep,.ttx,.trn,.DWA,.DSWA)
	if 'CINT,CPEN do CWP(.dep,.ttx,.trn,%EffectiveDate,.DWA,.DSWA)
	if CINT,'CPEN do CWI(.dep,.ttx,.trn,.DWA,.DSWA)
	if CINT,CPEN do CWIP(.dep,.ttx,.trn,%EffectiveDate,.DWA,.DSWA)

	// Add State and Federal w/h amounts to closeout amount 
	quit DFT("AMT")+DWA+DSWA
	
	
public CHECKLB(IRCB,NEGACR,NEGACRUN,UNCACR)
	/* Check for error condition for low balance accounts
	Arguments:
		. IRCB		Int Rate Calc Base	/TYP=N/REQ/MECH-VAL
		. NEGACR	Negative accrued	/TYP=N/REQ/MECH-VAL
		. NEGACRUN	Negative accrued unauth./TYP=N/REQ/MECH-VAL
		. UNCACR	Uncollected accrued	/TYP=N/REQ/MECH-VAL

	Closeouts w/int are not allowed for Low balance accounts if there is 
	negative accrual.
	Called from inside and DEPCL
	*/
	if IRCB'=5 quit

	new TNEGACR
	
	set TNEGACR=NEGACR+NEGACRUN+UNCACR
	// Cannot process with negative accrual ~p1
	if TNEGACR do Runtime.setErrMSG("DEP",471,TNEGACR)

	quit 
	

DEFINT(RecordDEP dep,RecordTTX ttx,DPINT,DNINT,DRINT,DBWA) 
	// Consider deferred interest

	new BRCD
	set BRCD=dep.boo
	do EXT^DEPIADJ(.dep,,.DPINT,.DNINT,.DRINT,.DBWA) quit:ER 

	quit 
	

public CUMDEP(RecordDEP dep,INT,IPL)
	/* Consider cumulative interest adjustment amount
	Called from DEPCL and internally
	
	Arguments:
		. dep	Deposit account		/TYP=RecordDEP/REQ
		. INT	Interest amount		/TYP=N/REQ/MECH=VAL
		. IPL	Int/Div paid - life	/TYP=N/REQ/MECH=VAL

	Input:
		. IRN	Interest rate		/TYP=N
	
	Returns:
		. CUMINT Cumulative interest adjustment amount	/TYP=N

	*/

	set CUMINT=$$CURRACR^UACRIND(.dep,%EffectiveDate,IRN) quit:ER 
	set CUMINT=$$^SCARND(CUMINT,0,dep.cid) quit:ER 
	
	// Total cumulative int minus current accrual and int paid life
	set CUMINT=CUMINT-(INT+IPL)

	quit 


public ADDRESS
	/* Pre-processor for Escrow reports
	
	Output:
		CO()	Array of company information
	*/
	new LINE

	set CO(4)=""
	set CO(5)=""
	set CO(6)=""

	#IF CUVAR.CSTATE'=""
	set LINE=CUVAR.CCITY_", "_CUVAR.CSTATE_"  "_CUVAR.CCNTRY_"  "_CUVAR.CZIP 
	#ELSE  
	set LINE=CUVAR.CCITY_"  "_CUVAR.CCNTRY_"  "_CUVAR.CZIP 
	#ENDIF

	// Institution Name
	set CO(1)=CUVAR.CNAME
	// Customer Address 1
	set CO(2)=CUVAR.CAD1
	if CO(2)="" set CO(2)=LINE set CO(3)=CUVAR.TELEPHONE quit 
	
	// Customer Address Line 2
	set CO(3)=CUVAR.CAD2
	if CO(3)="" set CO(3)=LINE set CO(4)=CUVAR.TELEPHONE quit 
	
	// Customer Address Line 3
	set CO(4)=CUVAR.CAD3
	if CO(4)="" set CO(4)=LINE set CO(5)=CUVAR.TELEPHONE quit 
	
	set CO(5)=LINE
	set CO(6)=CUVAR.TELEPHONE

	quit


CTFCALC(RecordDEP dep,FEEAMT)
	// Used if PCF10 or PCF9 flags are turned on.

	new CID,CTFAMT,TMPETC,TYPE

	// No CTF plans linked to the account
	set CID=dep.cid
	type ResultSet rs=Db.select("CTFPLN","CTFPLNCID","CID=:CID")
	if rs.isEmpty() quit 0

	set CTFAMT=0

	set TYPE=dep.type
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE",1)

	/* Inquire on CTF plan amounts for transactions. Use DR Service 
	Fee Tran Code or use DR General Purpose Tran Code */
	if prodctl.getMode() set CTFAMT=$$CTFINQ^CTFCALC(CID,$S(prodctl.drtrsc:prodctl.drtrsc,1:prodctl.drtrgp),FEEAMT)

	quit CTFAMT

vSIG()	quit "60603^63004^Irina Kin^25672"	// Signature - LTD^TIME^USER^SIZE
