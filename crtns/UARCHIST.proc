public UARCHIST(Number OPTION)	// 0 = report, 2 = purge
	/*
	ORIG: CHENARD - February 18,1994
	
	***********************************************************************
	NOTE:  CR16982 removed the archiving aspects of this procedure and
	       left only the purging features.  This has been done until
	       archiving is enable at a future point.
	***********************************************************************

	This utility will manage the process of purging PROFILE account
	history records.

	EXAMPLE:
		do ^UARCHIST(1) ; Archives account history
		do ^UARCHIST(2) ; Purges account history

	LIBRARY:
		. $$EXEC Serves as primary execution point for the
		 archive/purge utility. Based on selection
		 criteria, get an account and process it.

		. ARCHV Processes a single account based upon the minimum
		 history to retain, whether to archive or purge,
		 and the current global directory to use for
		 archiving.

	-------Revision History-----------------------------------------------
	
	03/18/06 - RussellDS - Cr16892
		   Remove archiving features, but leave purge capability.
		   
		   Remove old revision history.
		
	02/13/03 - GRAY - 51349
		   Commented out all code until history archiving issues
		   are resolved in Phase 2.  This procedure was
		   inadvertently released as a part of Phase 1.
	*/
	
	
	// Option 1, archive, not currently supported
	
	type public String ER, RM()
	
	type Date CUTOFF
	type Number CID, TYPE
	type String %READ, %TAB(), CLS, GRP, IO, PRGDIR, VFMQ, VQRY(,,), ZQRY

	set %TAB("CLS") = ".CLS3/XPP=D PPCLS^UARCHIST/TBL=[STBLCLS]:QU ""STBLCLS.CLS>A"""
	set %TAB("GRP") = ".A8/XPP=D PPGRP^UARCHIST/TBL=[STBLGRP]:NOVAL"
	set ZQRY = "[ACN]CLS=<<CLS>> AND [ACN]GRP=<<GRP>>"
	set %TAB("TYPE") = ".QI1/XPP=D PPTYP^UARCHIST/TBL=[ACN]TYPE:DISTINCT:NOVAL:QU ZQRY"
	set %TAB("CUTOFF") = ".CUTOFF/MAX="_(%SystemDate-1)

	set (GRP, TYPE) = ""
	set %READ = "@@%FN,,,CLS/REQ,GRP/REQ,TYPE/REQ,,CUTOFF"
	
	set IO = ""

	if (OPTION = 0) do {
		
		set %TAB("IO") = $$IO^SCATAB($I)
		set %READ = %READ_",,IO/REQ"
	}

	else  if (OPTION = 2) do {
		
		set %TAB("PRGDIR") = ".DIR3"
		set PRGDIR = CUVAR.SPLDIR
		set %READ = %READ_",,PRGDIR/REQ"
	}

	do ^UTLREAD quit:(VFMQ="Q")
	
	set ER = 0

	if (OPTION = 0), (IO '= $I) do OPEN^SCAIO quit:(ER > 0)

	set CID = ""

	set ER = $$EXEC(.RM(),.VQRY(,,), OPTION, CUTOFF, CID, PRGDIR.get(), IO)
	if (ER = 0) set ER = "W"
	
	quit


EXEC(String RM(),	// Return message		/MECH=REFNAM:W
     String VQRY(,,),	// List of selected types
     Number OPTION,	// 0 = Report, 2 = Purge
     Number CUTOFF,	// Cutoff date
     Number XCID,	// Starting account number
     String PRGDIR,	// Directory to purge to
     String IO)		// Output device for report

	/*
	Execute purge
	*/
	
	type public Number ER
	
	type Boolean SHUTDN
	type Number BYTCNT, ERRCNT, MINHIST, RECCNT, TOTBYT, TOTCID, TOTREC, VTYPE
	type String VCLS, VGRP

	catch vERROR {
		
		type public Number %ZTSEQ

		do ZE^UTLERR
		// Host error number ~p1. Contact system manager.
		set RM=$$^MSG(1191,%ZTSEQ.get())
		
		quit 1
	}

	if CUTOFF.isNull() set MINHIST = 0
	else  set MINHIST = %SystemDate - CUTOFF
	
	set SHUTDN = 0

	set (ER, ERRCNT, TOTBYT, TOTCID, TOTREC)=0

	if (OPTION = 0) do Db.fastDelete("SCA166", "PID=:%ProcessID")
	
	set (VCLS, VGRP, VTYPE) = ""
	for  set VCLS = VQRY(VCLS).order() quit:VCLS.isNull()  do { quit:SHUTDN
		for  set VGRP = VQRY(VCLS, VGRP).order() quit:VGRP.isNull()  do { quit:SHUTDN
			for  set VTYPE = VQRY(VCLS, VGRP, VTYPE).order() quit:VTYPE.isNull()  do { quit:SHUTDN
				
				set (BYTCNT, RECCNT) = 0
				
				do TYPE(OPTION, VTYPE, .BYTCNT, .RECCNT, PRGDIR, .ERRCNT, MINHIST, .SHUTDN)
				
				set TOTREC = TOTREC + RECCNT
				set TOTBYT = TOTBYT + BYTCNT
			}
		}
	}

	// Run the report
	if (OPTION = 0) do {
		
		type String PGM, RID
		
		set RID = "SCA166"
		do ^URID
		if PGM.isNull() do {
			
			type String ET = "INVLDRPT"
			
			do ^UTLERR
			set ER = 1
		}
		
		else  do {
	
			type String VRWOPT()
			
			set VRWOPT("NOOPEN") = 1
	
			set PGM = "V0^"_PGM
			
			do @PGM
		}
	}
	
	if ER quit 1

	// Process shutdown: ~p1 VTYPE ~p2, account ~p3
	if SHUTDN set RM(1) = $$^MSG(6820, VGRP, VTYPE, XCID)
	// Process complete
	else  set RM(1) = $$^MSG(2237)
	// Record count: ~p1
	set RM(2) = $$^MSG(6821, TOTREC)
	// Byte count: ~p1
	set RM(3) = $$^MSG(6818, TOTBYT)
	// Errors: ~p1
	set RM(4) = $$^MSG(6819,ERRCNT)
	
	if SHUTDN quit 2
	
	quit 0


TYPE(Number OPTION,	// 0 = Report, 2 = Purge
     String VTYPE,	// Product type
     Number BYTCNT,	// Byte count			/MECH=REFNAM:W
     Number RECCNT,	// Record count			/MECH=REFNAM:W
     String PRGDIR,	// Directory to purge to
     Number ERRCNT,	// Error count
     Number MINHIST,	// Days to keep
     Boolean SHUTDN)	// Shutdown flag
     
	/*
	Process accounts within product VTYPE
	*/
	
	type public Number ER
	type public String RM
	
	type IO io = Class.new("IO")
	type Boolean X
	type String COLLIST
	
	type RecordPRODCTL prodctl = Db.getRecord("PRODCTL", "TYPE=:VTYPE")

	set (BYTCNT, RECCNT) = 0
	
	if OPTION=2 do {
	
		set io.fileName = $$FILE^%TRNLNM("SAVHIST."_VTYPE, PRGDIR)
		set io.openParams = "NEWV/WRITE"
		set io.timeout = 5
	
		catch ioExc {
			// catch exception error
			if ioExc'["%PSL-E-IO" throw ioExc

			set ER = 1
			// Error opening ~p1. Process stopped for type ~p2
			set RM = $$^MSG(992, io.fileName, ioExc.type)
		}
		
		do io.open()
	
		// Write header info
		do io.write($$HEADER("HIST", .COLLIST()))
		do io.write($$HEADER("HISTDST", .COLLIST()))
		if (prodctl.cls = "L") do io.write($$HEADER("HISTLST", .COLLIST()))
		do io.write($$HEADER("HISTN", .COLLIST()))
		if (prodctl.cls = "L") do io.write($$HEADER("HISTSB", .COLLIST()))
	}
	
	type ResultSet rs = Db.select("CID", "ACN", "TYPE=:VTYPE", "CID ASC")
	while rs.next() do { quit:SHUTDN
		
		if (ERRCNT > 99) set SHUTDN = 1 quit
		
		// Keep going if error
		catch error {
			
			set ERRCNT = ERRCNT + 1
			
			do ZE^UTLERR
		}
	
		do ARCHV(.prodctl, rs.getCol("CID"), .MINHIST, OPTION, io, .RECCNT, .BYTCNT, .COLLIST())
	}

	if (OPTION = 2) do io.close()

	quit


ARCHV(RecordPRODCTL prodctl,
      Number XCID,
      Number MINHIST,
      Number OPTION,
      IO io,
      Number RECCNT,
      Number BYTCNT,
      String COLLIST())
      
	/*
	Move account history records to purge file.

	This subroutine will determine if history can be purged based on the
	minimum number of days history to keep. Other criteria include the 
	statement last date, the service charge last date and the last updated
	passbook sequence .

	In order for a History record to qualify for purging, must pass the
	following checks:

		1. Minimum history to keep, based on the value in the product
		   table or, if greater than the value in the product table,
		   the number of days specified by parameter 'irahist' (if 
		   retirement account) or 'MINHIST' (if non-retirement
		   active/open account) or 'clohist' (if non-retirement closed
		   account).

		2. Statement last date, for statement accounts.  If history record
		   pre-dates the last statement date, it qualifies for archiving/
		   purging.

		3. Service charge last date, for accounts that have a service fee
		   plan.  If history record pre-dates the last service charge date,
		   it qualifies for purging.

		4. Last passbook update sequence, for passbook accounts only.  If
		   history record pre-dates the last posted passbook sequence, it
		   qualifies for purging.

		5. Last history record in production.  If the record that is about
		   to be archived is the only remaining record left in the
		   production history file, it will not be purged.
	*/
	
	type Boolean QUIT
	type Date CUTOFF
	type Number lseq

	type RecordACN acn = Db.getRecord("ACN", "XCID")

	// If IRA account
	if (acn.cls = "D") do {
		
		type RecordDEP dep = {RecordDEP}acn
	
		if (dep.ira > 0) do {
			
			// Set cutoff date to TJD-IRAHIST if IRAHIST is defined, else ignore cutoff date
			#IF CUVAR.IRAHIST.isNull()
			set CUTOFF = 0
			#ELSE
			set CUTOFF = %SystemDate - CUVAR.IRAHIST
			#ENDIF
		}
	}

	if 'CUTOFF.exists() do {
		// Non-retirement account
		// Determine the cut-off date for the account; i.e. the latest
		// date that can qualify to be purged/archived.
		
		// Account closed
		if (acn.stat = 4) do {
			
			if prodctl.clohist.isNull() set CUTOFF = 0
			else  set CUTOFF = %SystemDate - prodctl.clohist
		}
		else  do {
			
			if (MINHIST > prodctl.minhist) set CUTOFF = %SystemDate - MINHIST
			else  set CUTOFF = %SystemDate - prodctl.minhist
		}
	}

	if acn.cls="D" do {
		
		type RecordDEP dep = {RecordDEP}acn
		
		if 'dep.feepln.isNull(), (dep.scld < CUTOFF) set CUTOFF = dep.scld

		if dep.pbi do {
			
			if (dep.pbkseq > 0) do {

				type RecordHIST hist = Db.getRecord("HIST", "CID=:XCID,TSEQ=:dep.pbkseq")
				if (hist.tjd < CUTOFF) set CUTOFF = hist.tjd
			}
		}
		else  do {
			
			type Number CID
			type String SFRE, XCF01
			
			set CID = XCID
			do STM^DEPDI
			set SFRE = XCF01.get().piece("|", 4)
			if '(SFRE.isNull() ! (SFRE="1DA")) do {
			
				type Date SLDT = XCF01.piece("|", 2)
				
				if (SLDT < CUTOFF) set CUTOFF = SLDT
			}
		}
	}

	
	set lseq = Db.currVal("HIST", "CID=:XCID")
	set QUIT = 0
	
	type ResultSet rs = Db.select("TSEQ,TJD", "HIST", "CID=:XCID", "TSEQ ASC")
	
	while rs.next() do { quit:QUIT
		
		type Number TSEQ
		
		if (rs.getCol("TJD") '< CUTOFF) set QUIT = 1 quit
		
		set TSEQ = rs.getCol("TSEQ")
		
		// Always save at least one history record
		if (TSEQ = lseq) set QUIT = 1 quit

		set RECCNT = RECCNT + 1

		// Anticipated report
		if (OPTION = 0) do {
			
			type RecordSCA166 sca166 = Class.new("RecordSCA166", "PID=:%ProcessID, CID=:XCID, TSEQ=:TSEQ")
			
			do sca166.save()
		}

		// Write record(s) to output file and delete them
		else  if (OPTION = 2) do {
			
			do PURGE(.acn, TSEQ, io, .COLLIST(), .BYTCNT)
			
			set acn.hisctf = CUTOFF
			do acn.save()
		}
	}
	
	quit


PURGE(RecordACN acn,	// Account record
      Number TSEQ,	// History record sequence
      IO io,		// Output file
      String COLLIST(),	// Column list, by table
      Number BYTCNT)	// Byte count
      
	/*
	Write history record and any related records.  The output format
	is the same as that used in LNPURGU.proc
	*/
	
	type Number CID = acn.cid

	do DATA(CID, COLLIST("HISTDST"), "HISTDST", "CID="_CID_" AND TSEQ="_TSEQ, io, .BYTCNT)
	do Db.fastDelete("HISTDST", "CID=:CID,TSEQ=:TSEQ")
	
	if (acn.cls = "L") do {
		
		do DATA(CID, COLLIST("HISTLST"), "HISTLST", "CID="_CID_" AND SLN="_TSEQ, io, .BYTCNT)
		do Db.fastDelete("HISTLST", "CID=:CID,SLN=:TSEQ")
	
		do DATA(CID, COLLIST("HISTSB"), "HISTSB", "CID="_CID_" AND SLN="_TSEQ, io, .BYTCNT)
		do Db.fastDelete("HISTSB", "CID=:CID,SLN=:TSEQ")
	}
	
	do DATA(CID, COLLIST("HIST"), "HIST", "CID="_CID_" AND TSEQ="_TSEQ, io, .BYTCNT)
	do Db.fastDelete("HIST", "CID=:CID,TSEQ=:TSEQ")
	
	do DATA(CID, COLLIST("HISTN"), "HISTN", "CID="_CID_" AND TSEQ="_TSEQ, io, .BYTCNT)
	do Db.fastDelete("HISTN", "CID=:CID,TSEQ=:TSEQ")
		
	quit
	
	
HEADER( String TABLE, 		// Table name
        String COLLIST())	// Column list
        
	/*
	Return file header info for this table
	*/
 	
	set COLLIST = $$COLLIST^DBSDD(TABLE, 1, 1, 1)
	set COLLIST(TABLE) = COLLIST

	quit (TABLE_9.char()_COLLIST.translate(",", 9.char()))
	
	
DATA(Number CID,	// Account number
     String COLLIST, 	// Column list for TABLE
     String TABLE, 	// Table name
     String WHERE,	// Where clause
     IO io,		// Output device
     Number BYTCNT)	// Byte count
     
	/*
	Write the record(s)
	*/

	type String DATA

	#ACCEPT Date=03/19/2006; PGM=RussellDS; CR=19862
	type ResultSet rs = Db.select(COLLIST, TABLE, WHERE)
	
	while rs.next() do {

		type Row rw = rs.getRow()

		set DATA = TABLE_9.char()_CID_rw.toString()
		
		set BYTCNT =  BYTCNT + DATA.length()

		do io.write(.DATA)
	}

	quit


PPCLS	// Post processor for Class

	type public String VQRY(), X
	
	if 'X.isNull() do {
	
		kill VQRY
		set VQRY(X) = ""
	}
	
	quit


PPGRP	// Post processor for GROUP

	type public String VQRY(,), X
	
	type String CLS
	
	set CLS = VQRY("").order()

	if (X = "ALL") do { quit

		type ResultSet rs = Db.select("DISTINCT GRP", "PRODCTL", "CLS=:CLS")
			
		while rs.next() set VQRY(CLS, rs.getCol("GRP")) = ""
	}
	
	else  if X.isLike("%,%") do {
		
		type Number I
		type String GRP
		
		for I = 1:1:X.length(",") do {
			
			set GRP = X.piece(",", I)
			if 'GRP.isNull() set VQRY(CLS, GRP) = ""
		}
	}
	
	else  do {
		
		type ResultSet rs = Db.select("DISTINCT GRP", "PRODCTL", "CLS=:CLS AND GRP=:X")
			
		if rs.next() set VQRY(CLS, X) = ""
	}

	quit


PPTYP	// Post processor for TYPE

	type public String VQRY(,,), X
	
	type String CLS
	
	set CLS = VQRY("").order()

	if (X = "ALL") do { quit
		
		type String GRP = ""
		
		for  set GRP = VQRY(CLS,GRP).order() quit:GRP.isNull()  do {

			type ResultSet rs = Db.select("DISTINCT TYPE", "PRODCTL", "CLS=:CLS AND GRP=:GRP")
			
			while rs.next() set VQRY(CLS, GRP, rs.getCol("TYPE")) = ""
		}
	}
	
	// Handle single value or list
	else  do {
		
		type Number I
		type String CLS, GRP
		
		for I = 1:1:X.length(",") do {
			
			type ResultSet rs = Db.select("CLS, GRP", "PRODCTL", "TYPE=:X")
			
			if rs.next() do {
				
				set CLS = rs.getCol("CLS")
				set GRP = rs.getCol("GRP")
				
				if VQRY(CLS, GRP).exists() set VQRY(CLS, GRP, X) = ""
			}
		}
	}
			
	quit

vSIG()	quit "60358^48876^Dan Russell^12713"	// Signature - LTD^TIME^USER^SIZE
