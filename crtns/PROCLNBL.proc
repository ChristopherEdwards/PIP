PROCLNBL		/*
	---------- Revision History ------------------------------------------
	
	07/31/06 - KELLYP - CR 22048
		   Modified FINDSEQ section to eliminate PRECEDENCE warning.
	   
	05/24/05 - RussellDS - CR16071
		   Converted M TP commands to PSL Runtime methods.
		   
		   Removed old revision history.
	*/

	quit
	
	// I18N=OFF

public VIEW(CID,tplarray,pmtarray,dtlarray,pmtdat,scope,filter)	// Public;Access
	
	/*
	   .CID		Account Number			/typ=N/REQ/MECH=VAL

	   .tplarray	Output 1 Array Name		/typ=T/REQ/MECH=REF
			(Payment Template)

	   .pmtarray	Output 2 Array Name		/typ=T/REQ/MECH=REF
			(Payment Record Control)

	   .dtlarray	Output 3 Array Name		/typ=T/REQ/MECH=REF
			(Payment Record Detail)

	   .pmtdat	Payment Date			/typ=D/NOREQ/MECH=VAL

			If passed, utility returns payment record
			associated with specified date

	   .scope	Records to Return		/typ=N/NOREQ/DEF=1

			0	Do not return payment detail.
				Purpose of call is to return payment
				template data in array tplarray.

			1	Return payment data for a single
				payment record.

				The payment record is either for
				'pmtdat' (if passed) or LN.OSEQ (if
				'pmtdat' is not passed).

				If no bill record exists for payment
				date 'pmtdat', then a payment record
				template is returned.

			2	Return payment data for multiple rows.

				If 'pmtdat' is passed, data for it and
				all that follow will be returned.  If
				there is no sequence associated with
				'pmtdat', then only those sequences
				due after 'pmtdat' are returned.

				Otherwise, data for LN.OSEQ and all
				that follow will be returned.

			3	Return data for all payment rows.

				'pmtdat', if passed, is ignored.

	   .filter	Element filter			/typ=T/NOREQ
							/MECH=VAL
			Passed in conjunction with
			with 'scope' option 0.  If
			only payment elements are
			required, value of 'filter'
			limits values returned to:

			1	Elements for which 'lump' amounts
				are acceptable.  (Single character
				and escrow elements only.  No fees.)
				Expected use is with lump amount
				maintenance functions.

			2	Escrow elements only.
	
	   Output:

	   tplarray (payment_element, subscript) = Template array

		Sub	Description

		1	Chronological seq in which element collected
		2	Indicator (0/1) of whether or not this is
		a	Base element for fees which follow
		3	If linked fee, element on which this linked
			fee is based
		4	Deposit (escrow) account number
		5	Current lump amount
		6	New payment amount (next pmt change date)
		7	Current payment amount
		8	Distribution

	   pmtarray (payment_due_date) = Payment control array

		Piece	LNBIL1 data 	Description

		1	casd  		Amount still due
		2	cbcd  		Cut-off date
		3	schseq  	Sequence number
		4	ctab  		Total amount billed
		5	cpid  		Prin + Int amount still due
		6	cpib  		Prin + Int original billed
		7	copb  		BALINT at cutoff
		8	coia  		Interest adjustment at cutoff
		9	cdib  		Deferred interest at cutoff
		10	cirn  		Interest rate at cutoff
		11	csubamt  	Subsidy amount
		12	csubdue  	Subsidy remaining

	   dtlarray (payment_due_date, element_sequence) = Detail array

		Piece	Description

		1	Element
		2	Amount originally due
		3	Amount currently due

		Note:	A base element will have an integer
			element_sequence.  Linked fees will have
			decimal offfsets.

	   Example:	dtlarray(due_date,1)=I|100|80
			dtlarray(due_date,1.01)=TAXINT|5|4
	*/

	new bilseq,ele,newseq
	
	kill tplarray,pmtarray,dtlarray
	
	if $G(scope)="" set scope=1
	
	// Build 'tplarray' template of payment elements
	set ER=$$PMTELEM(CID,.tplarray,$G(filter)) quit:ER 1
	
	// Find bill sequence associated with passed date 'pmtdat'
	set newseq=0 
	set pmtdat=$G(pmtdat)
	if pmtdat set ER=$$FINDSEQ(CID,pmtdat,.bilseq,.newseq) quit:ER 1
	else  set bilseq=Db.getOneRow("OSEQ","LN","CID") quit:ER 1
	
	// Single payment record
	if scope=1 do {

		// If a new bill sequence, return payment template
		if newseq set ele="" for  set ele=$O(tplarray(ele)) quit:ele=""  do {
			new seq
			set seq=$G(tplarray(ele,1))
			set dtlarray(pmtdat,seq,ele)=""
			}
		else  set ER=$$PMTREC(CID,bilseq,.dtlarray,bilseq) 
		quit:ER 1
		}
	
	// All starting with 'pmtdat' or, if not passed, LN.OSEQ
	if scope=2 set ER=$$PMTREC(CID,bilseq,.dtlarray,999999) quit:ER 1 
	
	// All payment records
	if scope=3 set ER=$$PMTREC(CID,.00000001,.dtlarray,999999) quit:ER 1
	
	quit 0
	
PMTELEM(CID,array,filter)	//Public;Return template of payment elements
	
	/*
	   . CID	Account number		/REQ

	   . array	Output array		/REQ

	   . filter	Element filter		/typ=T/NOREQ
						/MECH=VAL

			Limits values returned to:

			1	Elements for which 'lump' amounts
				are acceptable.  (Single character
				and escrow elements only.  No fees.)
				Expected use is with lump amount
				maintenance functions.

			2	Escrow elements only.
	*/
	
	new ER,I,PEnnDA,PEnnEA,PEnnLA,PEnnNA,PEnnPA,PEnnPF
	new base,baseseq,data,fee,pmtdist,element,feeplan,piece,quit
	new seq,temp,tmparray
	
	set (ER,quit)=0
	
	// Load all PEnnEA (Acronyms) and PEnnPF (Distributions) from LNBIL0
	
	new rs,list1
	set list1="PE01EA,PE01DA,PE01PA,PE01PF,PE01LA,PE01NA,PE02EA,PE02DA,PE02PA,PE02PF,PE02LA,PE02NA,PE03EA"
	set list1=list1_",PE03DA,PE03PA,PE03PF,PE03LA,PE03NA,PE04EA,PE04DA,PE04PA,PE04PF,PE04LA,PE04NA,PE05EA"
	set list1=list1_",PE05DA,PE05PA,PE05PF,PE05LA,PE05NA"
	set data=Db.getOneRow(list1,"LNBIL0","CID")
	do BIL0(0)
	
	if 'quit do {
		new rs,list2 
		set list2="PE06EA,PE06DA,PE06PA,PE06PF,PE06LA,PE06NA,PE07EA,PE07DA,PE07PA,PE07PF,PE07LA,PE07NA,PE08EA,PE08DA"
		set list2=list2_",PE08PA,PE08PF,PE08LA,PE08NA,PE09EA,PE09DA,PE09PA,PE09PF,PE09LA,PE09NA,PE10EA,PE10DA,PE10PA"
		set list=list2_",PE10PF,PE10LA,PE10NA"
		set data=Db.getOneRow(list2,"LNBIL0","CID")
		do BIL0(5)
		}
	
	if 'quit do {
		new rs,list3
		set list3="PE11EA,PE11DA,PE11PA,PE11PF,PE11LA,PE11NA,PE12EA,PE12DA,PE12PA,PE12PF,PE12LA,PE12NA,"
		set list3=list3_"PE13EA,PE13DA,PE13PA,PE13PF,PE13LA,PE13NA,PE14EA,PE14DA,PE14PA,PE14PF,PE14LA,PE14NA,"
		set list3=list3_"PE15EA,PE15DA,PE15PA,PE15PF,PE15LA,PE15NA,PE16EA,PE16DA,PE16PA,PE16PF,PE16LA,PE16NA"
		set data=Db.getOneRow(list3,"LNBIL0","CID")
		do BIL0(10)
		}
	
	if 'quit do {
		new rs,list4
		set list4="PE17EA,PE17DA,PE17PA,PE17PF,PE17LA,PE17NA,PE18EA,PE18DA,PE18PA,PE18PF,PE18LA,PE18NA,PE19EA,"
		set list4=list4_"PE19DA,PE19PA,PE19PF,PE19LA,PE19NA,PE20EA,PE20DA,PE20PA,PE20PF,PE20LA,PE20NA"
		set data=Db.getOneRow(list4,"LNBIL0","CID")
		do BIL0(15)
		}
	
	// Now consider all linked fees associated with the account.
	if $G(filter)'=1 do {
		new rs 
		type ResultSet rs=Db.select("FEETYP","LNFEE","CID=:CID")
		if rs.isEmpty() quit
		while rs.next() do { quit:ER 
			set fee=rs.getCol(1)
			set feeplan=$$FEEPLN^LNU(fee)
	
			// Continue only if this is a linked fee
			if '$P(feeplan,"|",13) quit
	
			// Find what element this fee is linked to
			set base=$P(feeplan,"|",12) quit:base=""
	
			// Find sequence of the base
			set baseseq=+$G(array(base,1)) quit:baseseq=0
	
			// Determine sequence of the fee
			set seq=$O(tmparray(baseseq+1),-1)+.01
	
			set array(fee,1)=seq
			set array(fee,3)=base
			set array(fee,8)=$G(array(base,8))
			set tmparray(seq)=fee
	
			// Update the base sequence to indicate that it is base
			if $G(baseseq) set array(base,2)=1
			}
		}
	quit 0
	
BIL0(offset)	// Private; Process LNBIL0 data

	new I
	set quit=0 for I=1:6:25 do { quit:quit
		new seq,temp
	
		// No more elements defined for this loan
		if $P(data,$C(9),I)="" set quit=1 quit
	
		// Which element are we dealing with?
		set seq=(I+5)/6+offset
		
		// Element acronym
		set PEnnEA=$P(data,$C(9),(I+0))
	
		// Apply filter indicating no fee elements
		if $G(filter)=1,$$FEEPLN^LNU(PEnnEA)'="" quit
	
		// Apply filter indicating no escrow elements
		if $G(filter)=2,$$ESC^LNU(PEnnEA) quit 
	
		// Deposit account
		set PEnnDA=$P(data,$C(9),(I+1))       

		// Payment amount (current)
		set PEnnPA=$P(data,$C(9),(I+2))       

		// Distribution
		set PEnnPF=$P(data,$C(9),(I+3))       

		// Lump payment amount
		set PEnnLA=$P(data,$C(9),(I+4))       

		// Payment amount (next)
		set PEnnNA=$P(data,$C(9),(I+5))       
	
		set array(PEnnEA,1)=seq
		if PEnnDA'="" set array(PEnnEA,4)=PEnnDA
		if PEnnLA'="" set array(PEnnEA,5)=PEnnLA
		if PEnnNA'="" set array(PEnnEA,6)=PEnnNA
		if PEnnPA'="" set array(PEnnEA,7)=PEnnPA
		set array(PEnnEA,8)=$S(PEnnPF:PEnnPF,1:1)
	
		// Maintain temporary array of elements by sequence
		set tmparray(seq)=PEnnEA
		}
	quit
	
FINDSEQ(CID,pmtdat,pmtseq,newseq)	//Public;Find bill seq for date 'pmtdat'
	
	new ER,bseq,cdpd,data,folseq,lbdd,quit,schseq
	
	/* 
	   pmtseq The LNBIL1 sequence number associated with date pmtdat
	   folseq The LNBIL1 sequence following 'bilseq'
	   newseq Indicator of whether (1) or not (0) returned sequence
	   'pmtseq' is for a record which does not currently exist.
	*/

	set (ER,newseq)=0
	set data=Db.getOneRow("BSEQ,LBDD","LN","CID") quit:ER 1
	set bseq=$P(data,$C(9),1)
	set lbdd=$P(data,$C(9),2)
	
	/* 
	   If the passed due date is greater than the due date of the last
	   payment record on file, return the value one greater than the
	   sequence number of the last payment record on file.
	*/
	if pmtdat>lbdd set pmtseq=bseq+1,newseq=1
	
	/* 
	   If the passed due date is equal to the due date of the last payment
	   record on file, return the sequence associated with that record.
	*/
	else  if pmtdat=lbdd set pmtseq=bseq
	
	/* 
	   Otherwise, scan the current payment file.  Return either the sequence
	   of an existing payment record if its due date agrees to the passed due
	   date, or a value half between the first sequences due both before
	   and after.
	*/
	else  do {
		set (folseq,pmtseq,quit)=""
		new rs
		type ResultSet rs=Db.select("SCHSEQ,CDPD","LNBIL1","CID=:CID","SCHSEQ DESC") quit:ER
		if rs.isEmpty() quit
		while rs.next() do { quit:ER  quit:quit //ASC 04/25/01
			set schseq=rs.getCol(1)
			set cdpd=rs.getCol(2)
			if cdpd=pmtdat set pmtseq=schseq,quit=1 quit
			if cdpd<pmtdat set pmtseq=(folseq+schseq)/2,(newseq,quit)=1 quit
			set folseq=schseq
			}
		if 'pmtseq set pmtseq=folseq/2,newseq=1
		}	
	quit ER
	
PMTREC(CID,MINSEQ,array,MAXSEQ)	// Public ; Bill record detail
	/*
	   .CID		Account number		/REQ
	
	   .MINSEQ	Lowest bill sequence	/REQ

	   .array	Output array		/REQ
	
	   .MAXSEQ 	Highest bill sequence	/NOREQ/DEF=MINSEQ
	*/

	new ER,SCHSEQ,amtbld,amtdue,casd,cdpd,cpib,cpid,ctab
	new data,idp,element,link,list,numctele,offset,seq,tmpele
	
	set idp=Db.getOneRow("IDP","LN","CID")
	set ER=0
	
	if $G(MAXSEQ)="" set MAXSEQ=MINSEQ
	
	/* 
	Variable 'numctele' indicates the number of control elements in the
	SqlOpen statement which precede the detail ("PE...") columns.
	*/
	set numctele=13
	
	set list="SCHSEQ,CASD,CBCD,CDPD,CTAB,CPID,CPIB,COPB,COIA,CDIB,CIRN,CSUBAMT,CSUBDUE,PE01AB,PE01AD,"
	set list=list_"PE02AB,PE02AD,PE03AB,PE03AD,PE04AB,PE04AD,PE05AB,PE05AD,PE06AB,PE06AD,PE07AB,PE07AD,PE08AB,"
	set list=list_"PE08AD,PE09AB,PE09AD,PE10AB,PE10AD,PE11AB,PE11AD,PE12AB,PE12AD,PE13AB,PE13AD,PE14AB,PE14AD,"
	set list=list_"PE15AB,PE15AD,PE16AB,PE16AD,PE17AB,PE17AD,PE18AB,PE18AD,PE19AB,PE19AD,PE20AB,PE20AD"
	
	type ResultSet rs=Db.select(list,"LNBIL1","CID=:CID AND SCHSEQ>=:MINSEQ AND SCHSEQ<=:MAXSEQ","SCHSEQ DESC")
	if rs.isEmpty() quit 0
	while rs.next()  do { quit:ER
		set data=rs.getRow()
		set cdpd=rs.getCol(4)
		set SCHSEQ=rs.getCol(1)		

		for I=2:1:13 set $P(pmtarray(cdpd),"|",(I-1))=$P(data,$C(9),I)
		set $P(pmtarray(cdpd),"|",3)=rs.getCol(1)
	
		set element=""
		for  set element=$O(tplarray(element)) quit:element=""  do {

			// Ignore linked fees (which are not in LNBIL1)
			set link=$G(tplarray(element,3))
			if link'="" quit

			set tmpele=element
	
			// Find sequence of this fee
			set seq=$G(tplarray(element,1))
	
			/* 
			If interest determined at payment, "I" and "P"
			elements are ignored.  They are replaced by "P+I".
			*/
			if idp,element="P" quit
			if idp,element="I" do {
				set amtbld=rs.getCol(7)
				set amtdue=rs.getCol(6)
				set tmpele="P+I"
				}
	
			else  do {
				/* 
				Find number of columns before the columns
				associated with this element.
				*/
				set offset=(seq-1)*2+numctele
	
				// Find amount billed and amount due
				set amtbld=$P(data,$C(9),(offset+1))
				set amtdue=$P(data,$C(9),(offset+2))
				}
	
			set dtlarray(cdpd,seq)=tmpele_"|"_amtbld_"|"_amtdue
			}
	
		/* 
		Load information from fee support file LNBIL5.  Only
		interested in values where LNBIL5.DUEAMT is equal to 1
		which indicates that the fee amount is included in the
		payment amount.
		*/
		type ResultSet rsfee=Db.select("FEETYP,BFAMT,BRFAMT","LNBIL5","CID=:CID AND SCHSEQ=:SCHSEQ AND DUEAMT=1")
		if rsfee.isEmpty() quit
		while rsfee.next()  do { quit:ER
			set element=rsfee.getCol(1)
			set amtbld=rsfee.getCol(2)
			set amtdue=rsfee.getCol(3)

			// Find sequence of this fee
			set seq=$G(tplarray(element,1))
			set dtlarray(cdpd,seq)=element_"|"_amtbld_"|"_amtdue
			}
		}
	quit ER
	
CHANGE(CID,chgarray,delete,inttrn)	// Change LNBIL0, LNBIL1, LNBIL5 table
	/*
	   Subroutine is used to either insert new, or modify an existing, row.
	   The amount change array 'chgarray' can contain existing payment
	   dates (which will process as updates) or new dates (processing
	   as inserts).

	   .CID		Account Number			/typ=N/REQ/MECH=VAL

	   .chgarray	Column Value Array		/typ=array/REQ/MECH=REF

			Array of column value
			changes in format:

			chgarray(pmtdat,element,column)=newval

				pmtdat	- Payment date, or "*" if
					change is not associated
					with a specific date (i.e.
					it is an LNBIL0 column)

				element	- Payment element, or "*"
					if direct set to specific
					column

				column	- Either:

					A. If element parameter is
					equal to "*", then
					column is equal to
					column name in
					table.column syntax where
					table is equal to either
					'LNBIL1' or 'LNBIL5'.

					B. If the 'element'
					parameter is not blank,
					and 'pmtdat' is a date,
					then 'column' is equal
					to the literal:

						DUEAMT:  Amount due

						If 'pmtdat' is equal to
						"*", then 'column' is
						equal to one of the
						following literals
						associated with LNBIL0:

						LA Lump Amount
						NA New Pmt Amt
						PA Current Pmt

				new_val	- New field value after change

	   . delete	List, with comma 		/TYP=T/NOREQ
			delimeter, of payment
			dates which should be
			deleted.

	   . inttrn	Interest Tran Flag		/typ=L/NOREQ/MECH=VAL
			Indicator of whether or not interest
			accrual transactions should be generated
			to support interest payment changes.
	*/
	
	// set error trap 
	catch vERROR {
		set %ZTHALT=0 do ZE^UTLERR
		quit
		}
	
	new BILSEQ,ER,FEE,buf,col,data,delseq,delta,ele,link,newseq,newval
	new oldval,piece,pmtdat,pos,quit,set,stmt,tplarray
	new where
	
	// LN columns
	new cc,crcd,glsc,grp,trb,type,TYPE
	
	set ER=0
	set delete=$G(delete)
	set inttrn=$G(inttrn)
	
	// Build array of LNBIL1 positions by payment element
	if $$PMTELEM(CID,.tplarray) quit $$TPERROR
	
	// Load LN columns
	if 'Db.isDefined("LN","CID") do Runtime.setErrMSG("LNBIL1",57) if ER quit $$TPERROR

	Type RecordLN ln=Db.getRecord("LN","CID=:CID")
	set cc=ln.cc
	set crcd=ln.crcd
	set glsc=ln.glsc
	set grp=ln.grp
	set trb=ln.trb
	set type=ln.type
	set TYPE=type
	
	/* 
	   Process each record to be deleted.  For each, build the change
	   array with all elements, setting each to zero.  This approach
	   is necessary to ensure that negative adjustment transactions
	   are generated for all fee changes.
	*/
	for piece=1:1 set pmtdat=$P(delete,",",piece) quit:pmtdat=""  do { quit:ER
		set delete(pmtdat)=""
		set element=""
		for  set element=$O(tplarray(element)) quit:element=""  do {
			set chgarray(pmtdat,element,"DUEAMT")=0
			}
		}
	
	if ER quit $$TPERROR
	
	// Process each record in the change array
	set (col,ele,pmtdat)=""
	for  set pmtdat=$O(chgarray(pmtdat)) quit:pmtdat=""  do { quit:ER
		new update1,set1,where1,val1,col1
		new update5,set0,set5,where5
	
		set (col1,set1,set0,val1)=""
	
		// Find bill sequence associated with 'pmtdat'
		if pmtdat'="*" set ER=$$FINDSEQ(CID,pmtdat,.BILSEQ,.newseq) quit:ER
	
		// Action if intent is to delete sequence
		if $D(delete(pmtdat)) do { quit:ER

			// If non-existent payment, return error
			if newseq do { quit
				new datedisp 
				set datedisp=$$DAT^%ZM(pmtdat,$G(%MSKD))
				do Runtime.setErrMSG("LNBIL1",3323,datedisp) quit:ER
				}

			// Otherwise, build array by sequence
			set delseq(BILSEQ)=""
			}
	
		for  set ele=$O(chgarray(pmtdat,ele)) quit:ele=""  do { quit:ER
			for  set col=$O(chgarray(pmtdat,ele,col)) quit:col=""  do { quit:ER
	
				set newval=chgarray(pmtdat,ele,col)
	
				// Convert element to upper case
				set ele=$$UPPER^%ZFUNC(ele)
	
				set quit=0
	
				// Direct sets to specified column
				if ele="*" do { quit
					if newseq do {
						if col1'="" do {
							set col1=col1_","
							set val1=val1_","
							}
						set col1=col1_$P(col,".",2)
						set val1=val1_newval
						}

					if 'newseq do {
						if set1'="" set set1=set1_","
						set set1=set1_$P(col,".",2)
						set set1=set1_"="_newval
						}
					}
	
				// Changes to payment element amount
				if ele'="*" do { quit:ER

					// Find element's position in LNBIL1
					set pos=$G(tplarray(ele,1))

					// Payment file (top level) LNBIL0
					if pmtdat="*" do { quit   ; DJH 06/26/00
						if ele="P+I" set pos=$G(tplarray("I",1))   ; DJH 06/26/00
						do LNBIL0 quit   ; DJH 06/26/00
						}

					if ele="P+I" do LNBIL1 quit
	
					/*
					   Payment file update aborted due to
					   invalid element ~p1
					*/
					if pos="" do Runtime.setErrMSG("LNBIL1",3324,ele) quit:ER
	
					// Payment file LNBIL1 updates
					if pos'["." do LNBIL1
	
					// Payment file (linked fee) LNBIL5
					if pos["." do LNBIL5
					}
	
				// No transactions associated with LNBIL0 change
				if pmtdat="*" quit
	
				// Calculate amount change
				if ele'="*" set delta=newval-oldval quit:'delta
	
				// Consider interest accrual transactions
				if ele="I",inttrn do INTTR(.ln,delta) quit:ER
	
				// Consider fee adjustment transactions
				if $$FEEPLN^LNU(ele)'="" do FEETR(.ln,ele,delta,type,crcd)
				if ER quit
				quit
				}
			}
	
		// Insert new LNBIL1 record
		if col1'="" do { quit:ER
			set insert1="Insert into LNBIL1 "
			set col1="CID,SCHSEQ,CDPD,"_col1
			set val1=CID_","_BILSEQ_","_pmtdat_","_val1
			
			// Add acronyms associated with each payment element
			set element=""
			for  set element=$O(tplarray(element)) quit:element=""  do {
				new seq

				// Ignore linked fees (which are not in LNBIL1)
				set link=$G(tplarray(element,3))
				if link'="" quit
	
				// Find sequence of this element
				set seq=$G(tplarray(element,1))
	
				// Convert sequence to two characters
				set seq=$E(100+seq,2,3)

				set column="PE"_seq_"EA"
				set col1=col1_","_column
				set val1=val1_",'"_element_"'"
				}
			set stmt=insert1_"("_col1_") values ("_val1_")"
			set ER=$$^SQL(stmt)
			}

		// Update LNBIL0 record
		if set0'="" do { quit:ER
			set stmt="Update LNBIL0 Set "_set0_" where CID=:CID"
			set ER=$$^SQL(stmt)
			quit
			}

		// Update existing LNBIL1 record
		if set1'="" do { quit:ER
			new param S param=""
			set update1="Update LNBIL1 Set "
			set where1=" where CID=:CID and SCHSEQ=:BILSEQ"
			set stmt=update1_set1_where1

			/*
			   If deleting this record, then make changes
			   invisible to the user.  The only probable
			   changes are the ones built by this
			   routine.  The fee amounts are set to zero
			   to trigger adjustment transactions.
			*/
			if $D(delete(pmtdat)) set param="/NOJOURNAL"
			
			set ER=$$^SQL(stmt,param)
			}

		}
	
	if 'ER do {

		// Process each delete instruction
		set delseq=""
		for  set delseq=$O(delseq(delseq)) quit:delseq=""  do { quit:ER
			new BILSEQ
			set BILSEQ=delseq
			do Db.delete("LNBIL1","CID=:CID AND SCHSEQ=:BILSEQ")
			}
		}
	if ER quit $$TPERROR
	quit 0

LNBIL0	// Private, LNBIL0 updates
	
	// Convert position to two characters
	set pos=$E(100+pos,2,3)
	set column="PE"_pos_col
	
	// Build 'set' clause
	if set0'="" set set0=set0_","
	set set0=set0_column_"='"_newval_"'"
	quit
	
LNBIL1	// Private, LNBIL1 payment element updates
	
	// Convert position to two characters
	set pos=$E(100+pos,2,3)
	
	if ele="P+I" set column="CPID"
	else  set column="PE"_pos_"AD"
	
	// Insert new sequence
	if newseq=1 do {
		
		// Build 'columns' and 'values' clause
		if col1'="" set col1=col1_","
		set col1=col1_column
	
		if val1'="" set val1=val1_","
		set val1=val1_"'"_newval_"'"
		set oldval=""
		}
	
	// Update existing sequence
	if newseq=0 do {

		// Build 'set' clause
		if set1'="" set set1=set1_","
		set set1=set1_column_"='"_newval_"'"
		set where=" where CID=:CID and SCHSEQ=:BILSEQ"
	
		// Find current value
		set ER=$$^SQL("Select "_column_" from LNBIL1"_where,,,.oldval)
		}
	quit
	
LNBIL5	// Private, LNBIL5 (linked fee) payment file updates
	
	new newbil5,schseq
	new ELE,NEWVAL
	
	set ELE=ele
	set NEWVAL=newval
	
	// Determine if this is a new fee record
	set (newbil5,oldval)=0
	
	/* 
	   If the LNBIL1 payment record did not exist, then the LNBIL5 is
	   automatically a new sequence.
	*/
	if newseq set newbil5=1
	
	// Otherwise it is new if the LNBIL5 record did not previously exist.
	else  do { quit:ER
		set data=""
	
		// Does this fee level exist?
		new rs
		type ResultSet rs=Db.select("SCHSEQ,BRFAMT","LNBIL5","CID=:CID AND SCHSEQ=:BILSEQ AND DUEAMT=1 AND FEETYP=:ELE")
		// Fee record does not exist
		if rs.isEmpty() set newbil5=1 quit
		set schseq=rs.next()	// Change the cursor position...
		set schseq=rs.getCol(1)
		set oldval=rs.getCol(2)
		}
	
	// New sequence
	if newbil5 do Db.insert("LNBIL5","CID,SCHSEQ,DUEAMT,FEETYP,BRFAMT",":CID,:BILSEQ,1,:ELE,:NEWVAL")
	
	// Existing sequence
	else  do Db.update("LNBIL5","BRFAMT=:NEWVAL","CID=:CID and SCHSEQ=:BILSEQ and DUEAMT=1 and FEETYP=:ELE")
	
	quit
	
INTTR(RecordLN ln,delta)	// Post interest transactions
	
	new abdadj,crtcrd,crtso,drtrcd,drtso,occ,tcmt
	
	set (crtso,drtso)=""
	set data=Db.getOneRow("DRADIN,CRADIN","PRODCTL","TYPE")
	
	// Find absolute value of adjustment amount
	set absadj=+$FN(delta,"T")
	
	// Interest Billed Adjustment
	set tcmt=$$^MSG(4248)
	
	Type RecordUTBLGLSC glsc=Db.getRecord("UTBLGLSC","GLSC=:ln.glsc")
	if delta>0 do {

		// Increase transaction
		set inc=1
	
		if trb set crtrcd="MCR"
		else  set crtrcd="MDR"
	
		// GLSC interest income account
		set cracnt=glsc.lgli
	
		// Interest accrual adjustment tran
		set drtrcd=$P(data,$C(9),1)
		set dracnt=CID
		}
	else  do {

		// Decrease transaction
		set inc=0
		set crtrcd=$P(data,$C(9),2)
		set cracnt=CID
		if trb set drtrcd="MDR"
		else  set drtrcd="MCR"
	
		// GLSC interest income account
		set dracnt=glsc.lgli
		}
	
	// Create debit transaction
	do TTX(dracnt,drtrcd,absadj,%SystemDate,%UserStation,drtso,tcmt,cc,crcd,inc)
	
	// Create offset credit transaction
	do TTX(cracnt,crtrcd,absadj,%SystemDate,%UserStation,crtso,tcmt,cc,crcd,inc)
	
	quit
	
FEETR(RecordLN ln,fee,delta,TYPE,CRCD)	// Post fee transactions
	
	new absadj,cracnt,crtcmt,crtrcd,crtso,dracnt,drtcmt,drtrcd,drtso
	new efd,increase,occ,tcmt,tcmt1,tcmt2
	
	// Effective date equal to pmt due date unless later than system date
	set efd=$S(pmtdat'>%SystemDate:pmtdat,1:%SystemDate)
	
	// Absolute value of adjustment amount
	set absadj=+$FN(delta,"T")
	
	// Payment Due ~p1
	set tcmt1=$$^MSG(5628,$$DAT^%ZM(pmtdat,$G(%MSKD)))
	set tcmt2=CID_", "_fee
	
	/*
	   If positive, fee assessed is being increased.
	       Debit:  Loan assessment transaction increases amount due.
	       Credit: Income is deferred:  	Increase deferral adj. code.
		       Income is not deferred:  Miscellaneous transaction to
				   		increase fee income.
	*/
	Type RecordLNFEEP lnfeep=Db.getRecord("LNFEEP","FEETYP=:fee",1)
	if delta>0 do { quit:ER
		set increase=1					// Increase
	
		if '$$DEFER^LNFEEU(.lnfeep,fee,pmtdat) do {		// Not deferred
			set crtrcd=Db.getOneRow("FEEICRTC","CUVAR")
			if crtrcd="" set crtrcd="MCR"		// Stndrd Credit
			set cracnt=$$GLACN^LNFEEU(.ln,.lnfeep,fee,pmtdat)	// G/L fee income
			set crtcmt=tcmt2			// Comment
			set crtso=""
			}
		else  do {					// Defer income
			set cracnt=CID				// Credit loan

			//Credit
			set crtso="LNFEEIN"_"#"_fee_":"_absadj_":"_BILSEQ

			// Comment
			set crtcmt=tcmt1
			set crtrcd=Db.getOneRow("CRTRDI","PRODCTL","TYPE")
			}
	
		set drtrcd=$$GETTRCD(1,fee,type,crcd) quit:ER
		set dracnt=CID					// Loan account
		set drtso="LNFEEIN"_"#"_fee_":"_absadj_":"_BILSEQ // Offset TSO
		set drtcmt=tcmt1				// Comment
		}
	
	/* 
	   If negative, fee assessed is being decreased.
		Debit:	Income is deferred:	Decrease deferral adj. code.
			Income is not deferred:	Miscellaneous transaction to
						decrease fee income.
		Credit:	Loan assessment reduction decreases amount due.
	*/
	if delta<0 do { quit:ER 
	
		set increase=0					// Decrease
		if '$$DEFER^LNFEEU(.lnfeep,fee,pmtdat) do {		// Not deferred
			set drtrcd=Db.getOneRow("FEEIDRTC","CUVAR")
			if drtrcd="" set drtrcd="MDR"		// Stndrd Debit
			set dracnt=$$GLACN^LNFEEU(.ln,.lnfeep,fee,pmtdat)	// G/L fee income
			set drtcmt=tcmt2 			// Comment
			set drtso=""				// Debit TSO
			}
		else  do {					// Defer income
			set dracnt=CID				// Debit loan

			//Debit
			set drtso="LNFEEIN"_"#"_fee_":"_absadj_":"_BILSEQ
			set drtcmt=tcmt1			// Comment
			set drtrcd=Db.getOneRow("DRTRDFDA","PRODCTL","TYPE")
			}
	
		set crtrcd=$$GETTRCD(0,fee,type,crcd) quit:ER
		set cracnt=CID					// Loan account
		set crtso="LNFEEIN"_"#"_fee_":"_absadj_":"_BILSEQ // Offset TSO
		set crtcmt=tcmt1				// Comment
		}
	
	// Debit transaction
	do TTX(dracnt,drtrcd,absadj,efd,%UserStation,drtso,drtcmt,cc,crcd,increase)
	
	// Credit transaction
	do TTX(cracnt,crtrcd,absadj,efd,%UserStation,crtso,crtcmt,cc,crcd,increase)
	
	quit
	
GETTRCD(inc,FEE,TYPE,CRCD)	// Find appropriate fee transaction code
	/* 
	   inc Fee adjustment direction (1=Increase, 0=Decrease)
	   FEE Fee Type
	   TYPE Product
	   CRCD Currency code
	
	   $$ Return value:  Transaction Code.
	*/

	new trcd
	set trcd=""
	
	// Fee increase transaction
	if inc=1 do { quit:ER ER
		if grp="COM" set trcd=Db.getOneRow("COMFIAT","LNFEEP","FEE")
		else  if grp="MTG" set trcd=Db.getOneRow("MTGFIAT","LNFEEP","FEE")
		else  if grp="LN" set trcd=Db.getOneRow("LNFIAT","LNFEEP","FEE")
		else  if grp="RC" set trcd=Db.getOneRow("RCFIAT","LNFEEP","FEE")
		else  if grp="CBL" set trcd=Db.getOneRow("CBLFIAT","LNFEEP","FEE")
		else  if grp="DM" set trcd=Db.getOneRow("DMFIAT","LNFEEP","FEE")
	
		if trcd="" set trcd=Db.getOneRow("DRTRMI","PRODCTL","TYPE")
	
		// Fee increase tran code missing from product ~p1
		if trcd="" do Runtime.setErrMSG("LNBIL1",1067,TYPE) quit:ER
		}
	
	// Fee decrease transaction
	else  do { quit:ER ER
		if grp="COM" set trcd=Db.getOneRow("COMFCT","LNFEEP","FEE")
		else  if grp="MTG" set trcd=Db.getOneRow("MTGFCT","LNFEEP","FEE")
		else  if grp="LN" set trcd=Db.getOneRow("LNFCT","LNFEEP","FEE")
		else  if grp="RC" set trcd=Db.getOneRow("RCFCT","LNFEEP","FEE")
		else  if grp="CBL" set trcd=Db.getOneRow("CBLFCT","LNFEEP","FEE")
		else  if grp="DM" set trcd=Db.getOneRow("DMFCT","LNFEEP","FEE")
	
		if trcd="" set trcd=Db.getOneRow("CRTRMFR","PRODCTL","TYPE")
	
		// Fee decrease tran code missing from product ~p1
		if trcd="" do Runtime.setErrMSG("LNBIL1",1066,TYPE) quit:ER
		}
	quit trcd
	
TTX(CID,TRCD,TAMT,EFD,%UserStation,TSO,TCMT,OCC,CRCD,INC) // Transaction array
	/* 
	   CID Customer number
	   TRCD Transaction code
	   TAMT Transaction amount
	   EFD Effective date
	   TLO Location
	   TSO Source
	   TCMT Comment
	   OCC Cost center
	   CRCD Currency Code
	   INC Increase (1) or Decrease (0) transaction
	*/

	new TRC,ITC
	
	/* 
	   Note:  Can't pass tran code in variable ETC as we don't want to
		  lose ETC array created by TTXEXT.
	*/
	n x
	set ETC=TRCD
	type RecordTTX ttx=Class.new("RecordTTX")
 
	set ttx.cid=CID
	set ttx.itc=INC
	set ttx.etc=ETC
	set ttx.tamt=TAMT
	set ttx.efd=EFD
	set ttx.tlo=%UserStation
	set ttx.tso=TSO
	set ttx.tcmt=TCMT
	set ttx.crcd=CRCD
	set ttx.cc=OCC
	do TRNSINGL^TRNDRV(.ttx,,%SystemDate,0,5)
	quit 
	
JRNL(mode,CID,SEQ,table,column,oldval,newval,fee,comment,RecordLNBIL1 lnbil1) //Public;History

	/*
	   [HIST]TCMT message.  Called by LNBIL0,1,5 journal definitions.

	   . mode	Processing mode		/TYP=T/REQ/MECH=VAL

			Value			Description

			insert			Create new row

			update			Modify existing row

			delete			Delete existing row

	   . CID	Account number

	   . SEQ	Sequence number

	   . table	LNBIL0, LNBIL1 or LNBIL5

	   . column	Column modified

	   . oldval	Old Value

	   . newval	New Value

	   . fee	Element modified, if
			table is LNBIL5.  Otherwise
			blank.

	   . comment	Start of comment text.
			Supplied if source is LNBIL0 only.
	*/
	
	new element,elemcol,keys,pmtdat,stmt
	
	set comment=$G(comment)
	if comment'="" set comment=comment_" "
	
	set element=""
	
	// Descending fee level data should appear as updates in history
	if table="LNBIL5",mode="insert" set mode="update"

	// ~p1 payment added
	if mode="insert" set comment=$$^MSG(1909,$$DAT^%ZM(lnbil1.cdpd,$G(%MSKD)))     //Payment dated ~p1 added

	// ~p1 payment deleted
	if mode="delete" set comment=$$^MSG(1910,$$DAT^%ZM(lnbil1.cdpd,$G(%MSKD)))     //Payment dated ~p1 deleted
	
	if mode="update" do {

		// Change control field
		if table="LNBIL1",$E(column,1,2)'="PE" do { quit
			set keys=CID_","_SEQ
			set comment=$$TCMTFM^ACNFUNCS(keys,table,column,oldval,newval)
			}
	
		// ~p1 Payment,
		if table="LNBIL1" set pmtdat=lnbil1.cdpd
		if table="LNBIL5" do {
			set pmtdat=Db.getOneRow("CDPD","LNBIL1","CID,SEQ")
			}

		if table'="LNBIL0" set comment=$$^MSG(4250,$$DAT^%ZM(pmtdat,$G(%MSKD)))       //~p1 Payment
	
		/* 
		   Note: if table is LNBIL0, the comment is initialized in
		   the journal definition.
		   Find payment element modified
		*/
		if $G(fee)'="" set element=fee
		else  do {
			set elemcol=$E(column,3,4)
			set elemcol="PE"_elemcol_"EA"
			set stmt=elemcol_" from LNBIL0 where CID=:CID"
			do SELECT^SQL(stmt,,,.element)
			}
		set oldval=+$$^SCARND(oldval,,CID)
		set newval=+$$^SCARND(newval,,CID)
	
		// ~p1 '~p2' - ~p3 to ~p4
		set comment=$$^MSG(4251,comment,element,oldval,newval)	
		}
	quit comment


JRNL5(mode,CID,SEQ,table,column,oldval,newval,fee,comment) //Public;History

	/*
	   [HIST]TCMT message.  Called by LNBIL0,1,5 journal definitions.

	   . mode	Processing mode		/TYP=T/REQ/MECH=VAL

			Value			Description

			insert			Create new row

			update			Modify existing row

			delete			Delete existing row

	   . CID	Account number

	   . SEQ	Sequence number

	   . table	LNBIL0, LNBIL1 or LNBIL5

	   . column	Column modified

	   . oldval	Old Value

	   . newval	New Value

	   . fee	Element modified, if
			table is LNBIL5.  Otherwise
			blank.

	   . comment	Start of comment text.
			Supplied if source is LNBIL0 only.
	*/


	new lnbil1
	type RecordLNBIL1 lnbil1
	if table="LNBIL5" set lnbil1=Db.getRecord("LNBIL1","CID,SEQ")
	if table="LNBIL0" do {
		set lnbil1=Class.new("RecordLNBIL1")
		set lnbil1.cid=CID
		set lnbil1.schseq=SEQ
		}
	set comment=$$JRNL(mode,CID,SEQ,table,$G(column),oldval,newval,$G(fee),$G(comment),.lnbil1)
	quit comment



TPERROR()	// Tag is called when error occurs within TP fence
	
	if $TLEVEL do Runtime.rollback()
	quit 1
	

vSIG()	quit "60477^65448^Pat Kelly^30138"	// Signature - LTD^TIME^USER^SIZE
