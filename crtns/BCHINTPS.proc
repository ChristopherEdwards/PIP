BCHINTPS //Batch BCHINTPOST - Batch Interest Posting (all types)
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 02/01/2007 08:53 - shetyes
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHINTPOST Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit quit
 do JOBMGR^BCHUTL(%FN,"BCHINTPOST",.vINPUT)
 do ^JOBMGR(.vINPUT)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(CID) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHINTPOST","*","",CID.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,CID)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHINTPOST","*","",CID.get(),"",et)
 }
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,CID) //
 type Number vMONID,vMONCNT
	type public Cache %CACHE()

	type Number AREF, INTAMT, KEEPACR, LAFTFR, MININT
	type Number CURDEC, NEGMININ, NTFRCID, TFRCID, POSTING
	type String CCODE
	type Boolean TRB
	type Date NBD
	type RecordDEP deplaf, deptfrneg, deptfrpos
	type RecordLN ln
	type RecordUTBLGLSC glsc
	type RecordPRODCTL prodctl
	
	type RecordDEP dep = Db.getRecord("DEP", "CID=:CID")

	if dep.mdt = %SystemDate quit	// Posting will be handled by rollover

	if dep.stat = 4 quit		// Account closed

	// Neg Int Posting Option cannot be 2 if Neg Accrual Option is 0
	if 'dep.negacrpo, dep.negipo = 2 do Runtime.setErrMSG("DEP", 249) quit

	do CIDINIT(.dep, .glsc, .prodctl, .deptfrpos, .deptfrneg, .deplaf, .ln)

	type ResultSet rs = Db.select("POSTING", "DAYENDINP", "TJD=:%SystemDate AND CID=:CID")
	if rs.isEmpty() quit

	while rs.next() do {
		type Boolean ER = 0
		set POSTING = rs.getCol("POSTING")	// Posting Type
		
		/*
		Post deferred interest for all current and past dates 
		(according to POSTING indicator) first... applicable with 
		positive/negative only (excluding segmented accounts)
		*/
		if dep.definadj, POSTING < 2 do {
			type ResultSet rs = Db.select("INP", "DEFINP", "CID=:CID AND INP NOT>:%SystemDate")
			while rs.next() do {
				do EXEC(.dep, .deptfrpos, .deplaf, .deptfrneg, .ln, .glsc, .prodctl, POSTING, 0, rs.getCol("INP"))
				if ER do EXC set ER = 0
				}
			}

		do EXEC(.dep, .deptfrpos, .deplaf, .deptfrneg, .ln, .glsc, .prodctl, POSTING, 0)
		if ER do EXC

		if 'dep.segflg do BUMPINP(.dep, 0)
		}

	do BUMPCHK(.dep)

	quit


EXEC(RecordDEP dep,		// Account to post interest		/REF:RW
     RecordDEP deptfrpos,	// Account to transfer positive int	/REF:RW
     RecordDEP deplaf,		// Lease administration account		/REF:RW
     RecordDEP deptfrneg,	// Account to transfer negative int	/REF:RW
     RecordLN ln,		// Loan account number (escrow)		/REF:RW
     RecordUTBLGLSC glsc,	// General ledger set code		/REF:R
     RecordPRODCTL prodctl,	// Product type				/REF:R
     Number POSTING,		// Interest Posting type			
     Boolean CTL,		// Control indicator
     Date DEFINP)		// Deferred interest posting date	/NOREQ

	/*
	 Execute interest posting to a single account

	 Additional notes on ARGUMENTS:

		. POSTING
			  0  Positive Interest
			  
			  1  Negative interest
		 	  2  Segment interest
			  3  Segment available interest

		. CTL
			  0 - Not an external call
			  1 - External call
	
	*/

	type public Boolean ER
	type public Number AREF, BRCD, CID, CURDEC, INTAMT, LAFTFR
	type public Number MININT, NEGMININ, NTFRCID, TFRCID

	type Boolean INTPDRCR, SEPNET
	type Number POSINT, POSTOPT
	type String TAMT, TCMT

  	// Check for dep.iaf = 2 and IOPT = 1,2,3  (does not apply to AIIOPT)
   	if POSTING < 3 do { quit:ER
		if 'dep.iopt quit
		if dep.iaf '= 2 quit
	
		/*
		Invalid field values Available Int/Div Option and Int/Div 
		Disbursement Option
		*/
		do Runtime.setErrMSG("DEP", 8619) quit
	   	}
	
       	// Check for interest next posting date in sync for actual posting only
	if POSTING = 0, dep.inp '= %SystemDate quit
	if POSTING = 1, dep.neginp '= %SystemDate quit

	set DEFINP = DEFINP.get()
	
	set (TCMT, TAMT) = ""

	// Set POSTOPT to determine type of posting for this account
	if dep.negipo '= 2 set POSTOPT = 0	// Both
	else  if POSTING = 0 set POSTOPT = 1	// Positive only
	else  set POSTOPT = 2			// Negative only
	
	/*
	   SEPNET flag indicates a special case scenario: accruing separately, 
	   posting net - treat as though POSACR and NEGACR as separate or 
	   interpret as net accrual when appropriate.
	*/
	if 'POSTOPT, dep.negacrpo = 1 set SEPNET = 1
	else  set SEPNET = 0
	
	/*
	 TRB 0 - a debit reduces balance
	     1 - a credit reduces balance
	*/

	#IF 'CUVAR.NOSEGMENTS
		// Segmented accounts process separately
		if POSTING > 1 do { quit
			if dep.segacr do ACCTLEV(.dep, .deptfrpos, .prodctl, .glsc) quit
			do SEGLEV(.dep, .deptfrpos, .prodctl, .glsc)
			}
	#ENDIF
	
	// Start interest posting fence
	do Runtime.start("BA", , "REGINT")

	// Post "regular" (positive / negative) interest to account
	do REGINT(.dep, .ln, .glsc, .prodctl, POSTING, CTL)

	// Roll back changes for interest posting Profile application 
	// errors
	if ER do Runtime.rollback("REGINT") quit
	
	// Commit interest posting to database
	do Runtime.commit()

	// Transfer interest 
	if (dep.iopt ! (dep.lsp)), TAMT do {
		// Start interest transfer fence
		do Runtime.start("BA", , "TRANSFER")
		
		// Post interest transfer transactions
		do TRANSFER(.dep, .deptfrpos, .deptfrneg, deplaf, .prodctl, TAMT.toNumber())
		
		// Roll back changes for interest transfer Profile application
		// errors
		if ER do Runtime.rollback("TRANSFER") quit
		
		// Commit interest transfer to database
		do Runtime.commit()
		}
	
	quit
	
	
REGINT(RecordDEP dep,		// Account to post interest		/REF:RW
       RecordLN ln,		// Loan account number (escrow)		/REF:RW
       RecordUTBLGLSC glsc,	// General ledger set code		/REF:R
       RecordPRODCTL prodctl,	// Product type				/REF:R
       Number POSTING,		// Interest Posting type			
       Boolean CTL)		// Control indicator

	type public Boolean ER, INTPDRCR, SEPNET
	type public Number AREF, AWCD, BRCD, CID, CURDEC, INTAMT, LAFTFR
	type public Number MININT, NEGMININ, NTFRCID, POSINT, POSTOPT, TFRCID
	type public String TAMT
	type public Date DEFINP
	
	type Number NEGACR, NEGACRUN, NEGADJ, NEGADJUN, NEGINT
	type Number POSACR, POSADJ, RESINT, UNCACR, UNCADJ
	type RecordDEFINP definp
	
	// Deferred interest posting date defined
	if 'DEFINP.isNull() do {
		set definp = Db.getRecord("DEFINP", "CID=:CID,INP=:DEFINP")
		
		set POSACR = +definp.dcur	// Current pos accrual
		set NEGACR = +definp.dcurneg	// Current neg accrual auth
		set NEGACRUN = +dep.negacrun	// Current neg accrual unauth
		set AWCD = +definp.awcd		// Current deferred accrued w/h
		set UNCACR = ""			// Current unauthorized accrual
		}
	else  do {
		// Add in Accrual for today before posting if set to include 
		// same-day (does not apply for segmented accounts)
		#IF CUVAR.IPD 
			do GETIPDA^UIC(.dep) 
			do dep.save("NOTRIGBEF/NOVALREQ/NOVALDD/NOTRIGAFT/NOVALRI/NOINDEX/NOFKCHK/JOURNAL") quit:ER
		#ENDIF
		
		// Set unrounded accrual variables
		set POSACR = +dep.posacr	// Positive Accrued Int/Div
		set NEGACR = +dep.negacr	// Negative Accrued Interest Auth
		set NEGACRUN = +dep.negacrun	// Negative Accrued Interest Unauth
		set UNCACR = +dep.uncacr	// Round uncollected accrual
		}

	// Prevent posting of negative amounts when posting separately
	if dep.negacrpo = 1 do {

		/*
		Posting option does not allow negative amount 
		to post for positive accrual
		*/
		if POSACR < 0 do Runtime.setErrMSG("DEP", 7499)

		// Posting option does not allow negative amount to post for 
		// negative accrual
		if NEGACR < 0 ! (NEGACRUN < 0) ! (UNCACR < 0) do Runtime.setErrMSG("DEP", 7500)
		}
    
	if INTAMT, POSTOPT '= 2 , 'prodctl.maxadj.isNull() do { quit:ER
		// Check absolute value against maximum adjustment
		if (POSACR + dep.ipnd - INTAMT).fnumber("-") '> prodctl.maxadj quit

		// Accrual adjustment exceeds maximum allowed
		do Runtime.setErrSTBLER("DEP", "MAXADJ")
		}
		
	set (POSADJ, NEGADJ, NEGADJUN, UNCADJ, RESINT) = 0	
	
	do INT(.dep, .POSINT, .NEGINT)			// Determine interest amounts
	
	// Posting positive only	
	if POSTOPT = 1 set (NEGACR, NEGACRUN, UNCACR, NEGINT) = 0
	// Posting negative only
	else  if POSTOPT = 2 do {
		set (POSACR, POSINT, INTAMT) = 0
		
		// Take into account minimum negative interest to charge
		if dep.negminop = 1, NEGINT < NEGMININ set NEGINT = 0
		if dep.negminop = 2, NEGINT, NEGMININ > NEGINT set NEGINT = NEGMININ
		}
	
	if dep.negbalop do RESINT(.dep) quit:ER
	
	// Any account changes to post?
	if POSINT ! (POSACR) ! (NEGINT) ! (NEGACR) ! (NEGACRUN) ! (UNCACR) do { quit:ER
		if POSTOPT = 0 do NET(.dep, .ln, .glsc, .prodctl) quit:ER
		if POSTOPT = 1 do POS(.dep, .ln, .glsc, .prodctl) quit:ER
		if POSTOPT = 2 do NEG(.dep,.ln, .glsc, .prodctl) quit:ER
		}

	// Move current deferred to paid		
	if 'DEFINP.isNull() do DEFINADJ^DEPIADJ(.definp, POSACR, NEGACR, RESINT, AWCD)
	// Calculate cumulative interest and post difference
	else  if dep.cumdep, POSTOPT < 2 do CUMDEP(.dep, .glsc, .prodctl) quit:ER

	quit


BUMPCHK(RecordDEP dep)	// Deposit account to post interest	/REF:RW
	
	// Bump check dates

	type String ET, FRE
	type Boolean ER = 0

	if dep.intchknd '= %SystemDate quit

	set FRE = dep.intchkfre
	if FRE.isNull() set FRE = dep.ipf
	if FRE.isNull() quit

	set dep.intchkld = %SystemDate
	
	set dep.intchknd = %SystemDate.nextFreqDate(FRE)
	
	if ER do { quit

		// Invalid interest check - next date
		if dep.intchknd.isNull() set ET = $$^MSG(6750)

		// Invalid interest check production frequency
		else  set ET = $$^MSG(6751)
		do EXC
		}
	
	do dep.bypassSave()
	
	quit


BUMPINP(RecordDEP dep,	// Deposit account to post interest		/REF:RW
	Boolean CTL)	// Control indicator

	// Bump interest posting date
	
	type public Number CID, POSTING

	type Boolean ER = 0

	// Bump positive interest posting next date
	if POSTING = 0 do { quit
		set dep.ipld = %SystemDate
		if dep.ipf.isNull() quit

		set dep.inp = %SystemDate.nextFreqDate(dep.ipf)
		
		// Invalid frequency
		if dep.inp < 0 ! (ER) do Runtime.setErrSTBLER("DEP", "INVLDFRE1") do EXC quit
		
		do dep.bypassSave()

		// Update DAYENDINP only if not external call
		if 'CTL do {
			type RecordDAYENDINP nextinp = Db.getRecord("DAYENDINP", "TJD=:dep.inp,CID=:CID,POSTING=:POSTING", 1)
			do nextinp.bypassSave()

			// Record positive scheduled posting date for today
			type RecordACNDSD acndsd = Db.getRecord("ACNDSD", "CID=:CID,FRECOL='IPF',SCHDT=:%SystemDate", 1)
			do acndsd.bypassSave()
			}
		}

	set dep.negipld = %SystemDate
	if dep.negipf.isNull() quit

	set dep.neginp = %SystemDate.nextFreqDate(dep.negipf)

	// Invalid frequency
	if dep.neginp < 0 ! (ER) do Runtime.setErrSTBLER("DEP", "INVLDFRE1") do EXC quit

	do dep.bypassSave()
	
	// Update DAYENDINP only if not external call
	if 'CTL do {
		type RecordDAYENDINP nextinp = Db.getRecord("DAYENDINP", "TJD=:dep.neginp,CID=:CID,POSTING=:POSTING", 1)
		do nextinp.bypassSave()

		// Record negative scheduled posting date for today
		type RecordACNDSD acndsd = Db.getRecord("ACNDSD", "CID=:CID,FRECOL='NEGIPF',SCHDT=:%SystemDate", 1)
		do acndsd.bypassSave()
		}

	quit


POS(RecordDEP dep,		// Deposit account to post int	/REF:RW
    RecordLN ln,		// Loan account number (escrow)	/REF:RW
    RecordUTBLGLSC glsc,	// General ledger set code	/REF:R
    RecordPRODCTL prodctl)	// Product type			/REF:R

	// Post positive accrual
	
	type public Number KEEPACR, POSACR, POSADJ, POSINT
	type public Boolean ER
	
	// Calculate accrual interest adjustment (if any)
	do ADJ(POSINT, .POSACR, .POSADJ, .KEEPACR, .dep) quit:ER
	
	do POST(.dep, .ln, .glsc, .prodctl) quit:ER
	
	quit
	
	
NEG(RecordDEP dep,		// Deposit account to post int	/REF:RW
    RecordLN ln,		// Loan account number (escrow)	/REF:RW
    RecordUTBLGLSC glsc,	// General ledger set code	/REF:R
    RecordPRODCTL prodctl)	// Product type			/REF:R
    
	// Post negative accrual
	
	type public Number NEGACR, NEGACRUN, NEGADJ, NEGADJUN, NEGINT, RESINT
	type public Number UNCACR, UNCADJ
	type public Boolean ER
	
	type Number INT
	
	// Calculate negative accrual adjustment (if any)
	set INT = NEGINT + RESINT
	
	do ADJ(INT, .NEGACR, .NEGADJ, , .dep) quit:ER
	do ADJ(INT, .NEGACRUN, .NEGADJUN, , .dep) quit:ER
	do ADJ(INT, .UNCACR, .UNCADJ, , .dep) quit:ER
	
	do POST(.dep, .ln, .glsc, .prodctl) quit:ER
	
	quit
	
	
NET(RecordDEP dep,		// Deposit account to post int	/REF:RW
    RecordLN ln,		// Loan account number (escrow)	/REF:RW
    RecordUTBLGLSC glsc,	// General ledger set code	/REF:R
    RecordPRODCTL prodctl)	// Product type			/REF:R    

	// Net positive and negative interest
	
	type public Number KEEPACR, NEGACR, NEGACRUN, NEGADJ, NEGADJUN, NEGINT
	type public Number POSACR, POSADJ, POSINT, RESINT, UNCACR, UNCADJ
	type public Boolean ER
	
	// Subtract residual interest from positive interest if accruing net
	if 'dep.negacrpo do ADJ(POSINT - RESINT, .POSACR, .POSADJ, .KEEPACR, .dep) quit:ER

	// Add residual interest to negative interest if accruing separately
	if dep.negacrpo do { quit:ER
		type Number INT = NEGINT + RESINT
		
		do ADJ(POSINT, .POSACR, .POSADJ, .KEEPACR, .dep) quit:ER
		do ADJ(INT, .NEGACR, .NEGADJ, , .dep) quit:ER
		do ADJ(INT, .NEGACRUN, .NEGADJUN, , .dep) quit:ER
		do ADJ(INT, .UNCACR, .UNCADJ, , .dep) quit:ER
		}
	
	do POST(.dep, .ln, .glsc, .prodctl) quit:ER
	
	quit
	
	
POST(RecordDEP dep,		// Deposit account to post interest	/REF:RW
     RecordLN ln,		// Loan account number (escrow)		/REF:RW
     RecordUTBLGLSC glsc,	// General ledger set code		/REF:R
     RecordPRODCTL prodctl)	// Product type				/REF:R

	// Post interest to account according to POSTOPT
	
	type RecordTTX ttxpri
	
	type public Number AREF, AWCD, CID, CURDEC, KEEPACR, NEGACR, NEGACRUN
	type public Number NEGADJ, NEGADJUN, NEGINT, POSACR, POSADJ, POSINT
	type public Number POSTOPT, RESINT, UNCACR, UNCADJ
	type public String TAMT
	type public Boolean CTL, ER, SEPNET, TRB
	type public Date DEFINP
	
	// DIANC - amount to decrease interest available not credited
	type Number DIANC, TOTNEG
	type String ETC, TCMT = "", TSO

	set DIANC = 0
	
	// If accruing separately and posting net, reset POSINT to be net int
	if SEPNET set POSINT = POSINT - NEGINT, NEGINT = 0

	// Clear Anticipated Earnings and Compounded Int/Div buckets.
	if POSTOPT '= 2 do {
		set dep.cmp = ""		// Compounded Int/Div
		set dep.aecamt = ""		// Anticipated Amount
		}

	// Make any necessary accrual adjustment transactions and offsets
	set TSO = ""
 	if POSADJ do { quit:ER
		do ACRADJ(0, POSADJ, "", "", 2, .dep, .ln, .glsc, .prodctl)
		if 'KEEPACR do EXPENSE(.glsc, .dep, POSADJ)
		}

	set TOTNEG = NEGADJ + NEGADJUN + UNCADJ	

	if UNCADJ, POSTOPT = 2 do { quit:ER
		do ACRADJ(3, "", "", UNCADJ, 2, .dep, .ln, .glsc, .prodctl)
		if NEGADJ ! (NEGADJUN) do ACRADJ(2, NEGADJ, NEGADJUN, "", 1, .dep, .ln, .glsc, .prodctl)
		do INCOME(.glsc, .dep, TOTNEG)
		}
	else  if NEGADJ ! (NEGADJUN) ! (UNCADJ) do { quit:ER
		do ACRADJ(1, NEGADJ, NEGADJUN, UNCADJ, 2, .dep, .ln, .glsc, .prodctl)
		do INCOME(.glsc, .dep, TOTNEG)
		}

	// No interest to post
	if 'POSINT, 'NEGINT, 'RESINT quit
	
	if UNCACR, POSTOPT = 2 do { quit:ER
		type Number TAMT
		type String TCMT
		
		set TCMT = "UNCACR:"_UNCACR

		do TRN(CID, , , .dep, .ln, UNCACR, 0, "80") quit:ER
		
		set NEGINT = NEGINT - UNCACR
		}
	
	// Net positive and negative interest
	if 'POSTOPT do {
		set TAMT = POSINT - NEGINT
		set:TAMT < 0 TAMT = -TAMT
		}
	// Positive interest
	else  if POSTOPT = 1 set TAMT = POSINT
	// Negative interest
	else  set TAMT = NEGINT
	
	if NEGACR set TCMT = "NEGACR:"_NEGACR
	if NEGACRUN do {
		if 'TCMT.isNull() set TCMT = TCMT_"/"
		set TCMT = TCMT_"NEGACRUN:"_NEGACRUN
		}

	if UNCACR, POSTOPT '= 2 do {
		if 'TCMT.isNull() set TCMT = TCMT_"/" 
		set TCMT = TCMT_"UNCACR:"_UNCACR
		}
	
	if POSTOPT = 2 set TSO = "NEGINT#"
	else  set TSO = "INT#"
	
	// If posting deferred interest, and a deferred withholding is already 
	// calculated, use it
	if 'AWCD.get().isNull() set TAMT.piece("#", 5) = AWCD	
	/* 
	If both Backup Withholding (DEP.BWF) option and Accrued Withholding Tax
	Processing (DEP.AWTP) option are selected, set piece 5 of TAMT to
	Accrued Withholding tax (DEP.AWT) and clear bucket. If DEP.AWTP option 
	is not selected, let transaction code procedure call into ^DEPBW to 
	calculate backup withholding amount when posting the transaction.
	*/
	else  if dep.bwf, dep.awtp, POSINT > 0 set TAMT.piece("#", 5) = dep.awt, dep.awt = 0
	
	if (+TAMT '= 0) do { quit:ER
		type String TCCTL
		
		// CR Interest Paid TC
		if POSTOPT = 1 set TCCTL = "01"
		// DR Neg. Interest Paid TC
		else  if POSTOPT = 2 set TCCTL = "30"
		// DR Pos. Interest Paid TC
		else  if (POSINT - NEGINT) < 0 set TCCTL = "00"
		// CR Interest Paid TC
		else  set TCCTL = "01"

		do TRN(CID, , , .dep, .ln, TAMT, 0, TCCTL) quit:ER
		}

	if RESINT do { quit:ER
		// DR ADJ Residual Interest
		set ETC = prodctl.dradres
		do TRN(CID, ETC, , .dep, .ln, RESINT, 0) quit:ER
		}	

	set TCMT = ""
	
	// Deferred interest offset does not touch accrual
	if 'DEFINP.isNull(), CTL do { quit
		type public Number TNEGINT, TPOSINT, TRESINT

		if POSTOPT = 2 do {
			set TNEGINT = TNEGINT + TAMT
			do INCOME(.glsc, .dep, TAMT)
			}
		else  do {
			set TPOSINT = TPOSINT + TAMT
			do EXPENSE(.glsc, .dep, TAMT)
			}

		set TRESINT = TRESINT + RESINT
		}
	/* 
	If accruing net, POSACR is the equivalent of POSINT-RESINT at this 
	point. If accruing separately, NEGACR+NEGACRUN+UNCACR is the equivalent 
	of NEGINT+RESINT at this point. 
	*/

	do GENTDA(.dep, .ln, .glsc, .prodctl, TSO) quit:ER
	
	/*
	Don't accumulate offsets when called externally, or Delayed Interest 
	Posting Sweep processing is enabled, or escrow (offset handled by 
	escrow posting transaction pieced out to accrual position of TAMT)
	*/
	if CTL ! (dep.swpdelip) ! (dep.grp = "ESC") quit
	
	/*
	Accumulate general ledger offsets
	
	STAT processes 1 type of accrual at a time while GENTDA 
	processes all types of accrual at once
	*/
	if POSACR do STAT(TRB, POSACR, 1, .glsc, .dep)
	if NEGACR do STAT('TRB, NEGACR, 1, .glsc, .dep)
	if NEGACRUN do STAT('TRB, NEGACRUN, 0, .glsc, .dep)
	if UNCACR do STAT('TRB, UNCACR, 3, .glsc, .dep)

	quit
	

STAT(Boolean CR,		// Debit / Credit
     Number INT,		// Interest amount
     Number GLPST,		// General ledger posting type
     RecordUTBLGLSC glsc,	// General ledger set code record	/REF:R
     RecordDEP dep)		// Deposit account to post interest	/REF:R
     
	/* 
	Totals by crcd / type / cost center
	
	Additional notes on ARGUMENTS:

	GLPST
		0 - Unauthorized negative accrual
		1 - Regular (positive or negative) accrual
		2 - Available interest accrual
		3 - Uncollected interest accrual
	*/

	type public Boolean TRB
	
	type String PTYPE
	type Number GLCR, GLDR
	
	if GLPST = 1 set PTYPE="reg", GLCR = glsc.dglni
	else  if 'GLPST set PTYPE="una", GLCR = glsc.dglunani
	else  if GLPST = 2 set PTYPE="avl", GLCR = glsc.dglai
	else  set PTYPE = "unc", GLCR = glsc.dglunc

	set GLDR = glsc.dgl2
	if TRB set GLDR = GLCR, GLCR = glsc.dgl2
	
	do BDOFFSET(GLCR, GLDR, 6752, PTYPE, CR, INT, .dep)

	quit
	
	
ADJ(Number INT,		// Interest amount
    Number ACR,		// Accrual amount			/REF:RW
    Number ADJ,		// Adjustment amount			/REF:W
    Number KEEPACR,	// Amount if accrual to remain on acct	/REF:W/NOREQ
    RecordDEP dep)	// Deposit account to post interest	/REF:R
    
	// Calculate accrual adjustment 
	
	type public Number CURDEC, INTAMT

	type Number INTRND, RNDACR
	
	set INTRND = +INT.roundDec(CURDEC)
	set RNDACR = +ACR.roundDec(CURDEC)
	
	// Adjust all accrued
	if 'INTRND, RNDACR set ADJ = -ACR, ACR = 0 quit

	if INTAMT do { quit
		// Accrual is less than anticipated
		if INTRND > RNDACR set ADJ = ACR - INT set KEEPACR = ADJ
		// Accrual is more than anticipated
		if INTRND < RNDACR set KEEPACR = ACR-INT set ACR = INT
		}
	
	// Use absolute value to determine if no adjustment
	if +{String}INTRND.translate("-", "") '< +{String}RNDACR.translate("-", "") set ADJ = 0 quit

	// Partial adj
	set ADJ = ACR - INT
	set ACR = INT

	quit


TRN(Number CID,			// Account number		/REF:R
    String ETC, 		// External transaction code	/NOREQ
    RecordTTX ttxmcp(),		// Multi-currency transactions	/REF:RW/NOREQ
    RecordDEP trndep,		// Transaction account		/REF:RW
    RecordLN ln,		// Loan account			/REF:RW
    String TAMT,		// Transaction amount
    Number ADJTYPE,		// Adjustment type
    String TCCTL)		// Transaction code control	/NOREQ
    
	/*
	 Create and post transaction set entry
	 
	 Additional notes on ARGUMENTS:

		. ADJTYPE
				0 - Not an accrual adjustment
				1 - Accrual offset to interest posting
				2 - Earnings adjustment

		. TCCTL
		Position 1:
                   0 - Post (positive) interest/dividend
                   1 - Adjust (positive) interest/dividend accrual
                   2 - Adjust (positive) interest/dividend paid
                   3 - Post negative interest
                   4 - Adjust negative (authorized) interest accrual
                   5 - Adjust negative (authorized /unauthorized) interest char$
                   6 - Adjust negative unauthorized interest accrual
                   7 - Adjust negative uncollected interest accrual
                   8 - Adjust negative uncollected interest charged
                Position 2:
                   0 - Debit
                   1 - Credit
                   
	 INPUTS:
		. CCODE		Customer code			/REQ

		. TSO		Transaction source		/REQ

		. TCMT		Teller comment			/REQ

		. INTTFR	Interest transfer option	/NOREQ
				0 - Not a disbursement
				1 - Pay by check
				2 - Transfer to internal positive account
				3 - Transfer to internal negative account
				4 - Transfer to external account
				5 - Transfer to lease administration account
	*/

	type public Cache %CACHE()
	type public RecordTTX ttxpri
	type public Date DEFINP, NBD
	type public Number AREF, BRCD, CURDEC, ECID, INTTFR
	type public Number POSTING, SEG
	type public Boolean CTL, ER, EXCH, INTPDRCR
	type public String CCODE, FCRCD, TCMT, TSO
	
	type String ITC
	
	if 'TAMT quit

	// If transaction control specified, use it to determine ETC...
	// otherwise, ETC is required	
	if 'TCCTL.get().isNull() do { quit:ER
		// Escrow interest posting transaction - reset CID, ETC to go 
		// through loan
		if trndep.grp = "ESC" do {
			// Save escrow account number and reset
			set ECID = CID
			set CID = AREF
			set ETC = $$LETC^ESCFUNCS(ln.type, TCCTL.extract(1), TCCTL.extract(2)) quit:ER
			}
		else  set ETC = $$DETC^ESCFUNCS(trndep.type, TCCTL.extract(1), TCCTL.extract(2)) quit:ER
		}
	
	// Type ~p1: Interest posting tran code not defined
	if ETC.isNull() do Runtime.setErrMSG("PRODCTL", 8463, trndep.type) quit
	
	// Invalid transaction code ~p1
	if 'Db.isDefined("TRN", "ETC=:ETC")) do Runtime.setErrMSG("DEP", 1498, ETC) quit
			
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")

	// Force Update Last Customer Contact Date off (PCFLD2)
	if trn.cls = "D" set trn.pcfd2 = 0

	set ITC = trn.itc
	
	type RecordTTX ttx = Class.new("RecordTTX")
		
	// Do not update HIST / DTX for accrual reduction (offset) transaction
	// when in batch mode (will be accumulated instead)
	if ADJTYPE = 1, 'CTL do ttx.setStoredValue("noJournal", 1)
	
	// Any type of accrual adjustment or interest posting (exclude interest 
	// transfer)
	if 'INTTFR.get() do {
		type Number TAMT5
		
		set TSO = $$FIELDIN^UTSO(TSO, "EXACTACR", TAMT)
		
		set TAMT.piece("#", 1) = +{Number}TAMT.roundDec(CURDEC)
		set TAMT5 = TAMT.piece("#", 5)
		if TAMT5 do {
			set TAMT.piece("#", 5) = TAMT5.roundDec(CURDEC)
			set TAMT.piece("#", 2) = TAMT.piece("#", 1) - TAMT5
			}
		
		// Notate deferred interest transactions
		if 'DEFINP.isNull() do {
			do TSODEF^DEPIADJ(POSTING, DEFINP)

			// Deferred int posting adj: ~p1
			if 'TCMT.isNull() set TCMT = TCMT_"~"
			set TCMT = TCMT_$$^MSG(3855, DEFINP.toString())
			}
		}
	else  if 'DEFINP.isNull() do {
		// NOADJ indicates we will not recurse into RECALC during 
		// processing of the interest disbursement transaction
		set TSO = $$FIELDIN^UTSO(TSO, "NOADJ", 1)
		// Interest/Dividend Transfer Adjustment
		set TSO = $$FIELDIN^UTSO(TSO, "INTTRFADJ")
		}
	
	if 'INTTFR.get(), 'ADJTYPE do {
		// Not an interest transfer and not an accrual adj transaction
		// - Mark as an interest posting transaction
		
		// Available interest posting transaction
		if POSTING = 3 set ttx.itc = $$ITC^TTXEXT(ITC, 4, 2)
		// Interest posting transaction
		else  set ttx.itc = $$ITC^TTXEXT(ITC, 4, 1)
		
		// Mark intrest posting debit / credit indicator for use in 
		// transfer sections
		set INTPDRCR = +ITC.extract(1)

		// Insert segment number into TSO if posting on segment level
		if POSTING > 1, 'trndep.segacr set TSO = $$FIELDIN^UTSO(TSO, "SEG", SEG)
		}
	else  set ttx.itc = ITC
	
	set ttx.cid = CID
	set ttx.etc = ETC
	set ttx.tamt = TAMT
	set ttx.tso = TSO
	set ttx.tcmt = TCMT
	set ttx.crcd = trndep.crcd
	set ttx.efd = %EffectiveDate.get()
	set ttx.tlo = %UserStation
	set ttx.custcd = CCODE
		
	#IF CUVAR.%MCP
		set EXCH = EXCH.get()

		// Save first part of transfer (exclude interest posting 
		// transactions)
		if EXCH = 1 set ttxmcp(EXCH) = ttx.copy() quit
			
		// Currency codes differ, and this is the interest transfer
		// offset transaction
		if EXCH = 2 do { quit
			/*  
			If we're transfer to a different currency, then the
			transfer amount must be converted so that the transfer
			recipient's account balance is updated correctly when 
			posting
			*/
			type Number EXCAMT, MAXRATE, MINRATE, MULTIPLY, RATE
			type Number VARIANCE
			type Boolean TRESREF, TRNTYP
			
			set TRNTYP = $select(ITC.extract():0, 1:1)	

			do EXC^CRCDUTL(FCRCD, trndep.crcd, TAMT, 1, TRNTYP, "00", CCODE, %EffectiveDate.get(), 1)
			set TAMT = EXCAMT
			
			set ttx.bseamt = TAMT
			set ttx.rate = RATE
			set ttx.bcrcd = FCRCD

			set ttxmcp(EXCH) = ttx.copy()
			
			// Build currrency exchange transactions into ttxmcp()
			do CURXFR^TTXBLD(.ttxmcp(), 1)
			
			// Post all transactions involved in the multi-currency
			// set, including exchange transactions, individually
			type Number TTXSEQ = 0
			while TTXSEQ = ttxmcp(TTXSEQ).order() do { quit:ER
				// Deposit transaction, pass trndep
				if ttxmcp(TTXSEQ).cls = "D" do TRNSINGL^TRNDRV(.ttxmcp(TTXSEQ), .trndep, %SystemDate, BRCD, 4) quit
				// Assume exchange transaction, do not pass 
				// trndep
				else  do TRNSINGL^TRNDRV(.ttxmcp(TTXSEQ), , %SystemDate, BRCD, 4)
				}
			}
	#ENDIF
	
	if 'trndep.swpdelip do { quit
		// Post interest transaction to deposit account
		if trndep.grp '= "ESC" do { quit
			
			type Number ETRNMODE
                       
                        // External deferred interest calls s/be processed as
                        // secondary transactions
                        if CTL, 'DEFINP.isNull() set ETRNMODE = 5
                        // Otherwise process as system-generated
                        else  set ETRNMODE = 4
			
			do TRNSINGL^TRNDRV(.ttx, .trndep, %SystemDate, BRCD, ETRNMODE)
			
			// Extract withholding amount from transaction (may 
			// have been updated during posting)
			type public Number TBWA
			if 'DEFINP.isNull(), CTL set TBWA = TBWA + ttx.tamt.piece("#", 5)
			
			// Save HISTLST record tying it to primary loan 
			// transaction (ttxpri)
			if trn.cls = "M", ttxpri.exists() do HIS4^LNPTS1(.ttx)
			}
			
		// Post system-generated escrow transaction through loan (the 
		// Loan transaction will generate the escrow transaction)
		do TRNSINGL^TRNDRV(.ttx, .ln, %SystemDate, BRCD, 4)
		
		// Save primary loan transaction for possible escrow G/L 
		// posting through POST^LNTRB if waiving interest for escrow
		set ttxpri = ttx
		}
			
	/* 
	For delayed interest posting, all of the transactions generated are
	stored and will be posted later. These transactions will update
	the deposit accrual buckets. Therefore, nothing updated in the dep
	object can be saved.
	*/

	type Number TSEQ
	
	type ResultSet rs = Db.select("TSEQ", "DAYENDINVINT", "PSTDT=:NBD AND CID=:CID", "TSEQ DESC")
	if rs.next() set TSEQ = rs.getCol("TSEQ") + 1
	else  set TSEQ = 1

	// Store top level if not already there
	if 'Db.isDefined("DAYENDINVTOP", "PSTDT=:NBD,CID=:CID") do {
		type RecordDAYENDINVTOP invtop = Class.new("RecordDAYENDINVTOP", "PSTDT=:NBD,CID=:CID")
		do invtop.bypassSave()
		}

	// Store detail data			
	type RecordDAYENDINVINT invint = Class.new("RecordDAYENDINVINT", "PSTDT=:NBD,CID=:CID,TSEQ=:TSEQ")

	set invint.tcid = ttx.cid
	set invint.itc = ttx.itc
	set invint.etc = ttx.etc
	set invint.tamt = ttx.tamt
	set invint.tlo = ttx.tlo
	set invint.tso = ttx.tso
	set invint.tcmt = ttx.tcmt
	set invint.crcd = ttx.crcd

	do invint.bypassSave()

	quit

	
ADJCR(Number ACRTYPE,		// Accrual adjustment type
      Number ADJ,		// Accrual adjustment amount
      Number ADJUN,		// Unauthorized accrual adjustment amt
      Number ADJUNCL,		// Uncollected accrual adjustment amt
      Number ADJTYPE,		// Adjustment type
      RecordDEP dep,		// Deposit account to post interest	/REF:R
      RecordLN ln,		// Loan account number (escrow)		/REF:R
      RecordUTBLGLSC glsc,	// General ledger set code		/REF:R
      RecordPRODCTL prodctl)	// Product type				/REF:R

	/*
	Accrual adjustment (credit)
	
	Additional notes on ARGUMENTS:
	
		ACRTYPE	0 - Positive accrual bucket adjusted
		 	1 - Negative accrual (authorized) bucket adjusted
		 	2 - Available int accrual bucket adjusted
		 	3 - Uncollected accrual bucket adjusted
	*/
	
	type public Boolean ER
	type public Number AREF, CID, CURDEC
	
	type String ETC, TAMT, TCCTL
	
	set (ETC, TCCTL) = ""

	set ADJ = ADJ.fnumber("-")
	set ADJUN = ADJUN.fnumber("-")
	set ADJUNCL = ADJUNCL.fnumber("-")
	
	// CR Adj. Accrued Interest TC
	if 'ACRTYPE set TCCTL = "11", TAMT = ADJ
	else  if ACRTYPE = 1 do {
		// CR Adj. Neg Accrued Int TC
		if ADJ set TCCTL = "41", TAMT = ADJ
		// CR Adj. Neg Accrued Unauth TC
		if ADJUN set TCCTL = "61", TAMT = ADJUN
		// CR Uncoll Int Accrued TC
		if ADJUNCL set TCCTL = "71", TAMT = ADJUNCL
		}
	// CR Accrued Int on Avail Int
	else  if ACRTYPE = 2 set ETC = prodctl.craai, TAMT = ADJ
	// CR Uncoll Int Accrued TC
	else  if ACRTYPE = 3 set ETC = prodctl.craiuc, TAMT = ADJUNCL

	do TRN(CID, ETC, , .dep, .ln, TAMT, ADJTYPE, TCCTL) quit:ER

	quit
	
	
ADJDR(Number ACRTYPE,		// Accrual adjustment type
      Number ADJ,		// Accrual adjustment amt
      Number ADJUN,		// Unauthorized accrual adjustment amt
      Number ADJUNCL,		// Uncollected accrual adjustment amt
      Number ADJTYPE,		// Adjustment type
      RecordDEP dep,		// Deposit account to post interest	/REF:R
      RecordLN ln,		// Loan account number (escrow)		/REF:R
      RecordUTBLGLSC glsc,	// General ledger set code		/REF:R
      RecordPRODCTL prodctl)	// Product type				/REF:R

	/*
	Accrual adjustment (debit)

	Additional notes on ARGUMENTS:

		ACRTYPE	0 - Positive accrual bucket adjusted
			1 - Negative accrual (authorized) bucket adjusted
			2 - Available int accrual bucket adjusted
			3 - Uncollected accrual bucket adjusted
	*/

	type public Boolean ER
	type public Number AREF, CID

	type String ETC, TAMT, TCCTL

	set (ETC, TCCTL) = ""

	set ADJ = ADJ.fnumber("-")
	set ADJUN = ADJUN.fnumber("-")
	set ADJUNCL = ADJUNCL.fnumber("-")

	// DR Adj. Accrued Interest TC
	if 'ACRTYPE set TCCTL = "10", TAMT = ADJ
	else  if ACRTYPE = 1 do {
		// DR Adj. Neg Accrued Int TC
		if ADJ set TCCTL = "40", TAMT = ADJ
		// DR Adj. Neg Accrued Unauth TC
		if ADJUN set TCCTL = "60", TAMT = ADJUN
		// DR Uncoll Int Accrued TC
		if ADJUNCL set TCCTL = "70", TAMT = ADJUNCL
		}
	// DR Accrued Int on Avail Int
	else  if ACRTYPE = 2 set ETC = prodctl.draai, TAMT = ADJ
	// DR Uncoll Int Accrued TC
	else  if ACRTYPE = 3 set ETC = prodctl.draiud, TAMT = ADJUNCL

	do TRN(CID, ETC, , .dep, .ln, TAMT, ADJTYPE, TCCTL) quit:ER

	quit
	
	
EXPENSE(RecordUTBLGLSC glsc,	// General ledger set code		/REF:R
	RecordDEP dep,		// Deposit account to post interest	/REF:R
	Number POSADJ)		// Positive accrual adjustment amount

	// Offsetting interest expense entry

	type public Number CURDEC
	type public Boolean CTL, TRB
		
	type Boolean CR
	
	// Positive interest adjustment
	set POSADJ = +POSADJ.roundDec(CURDEC)

	if POSADJ < 0 set CR = 'TRB, POSADJ = -POSADJ
	else  set CR = TRB

	// Invalid bank number. No G/L number found.
	if glsc.dgli.isNull() do Runtime.setErrMSG("DEP", 1270) quit

	// External calls and escrow G/L transactions must be posted through 
	// transaction driver instead of accumulated
	if CTL ! (dep.grp = "ESC") do { quit
		type String ETC
		
		if CR set ETC = "MCR"
		else  set ETC = "MDR"

		// Hide deposit / loan objects for G/L transaction
		type RecordDEP dep = Class.new("RecordDEP")
		type RecordLN ln = Class.new("RecordLN")
		do TRN(glsc.dgli, ETC, , .dep, .ln, POSADJ, 0)
		}

	// Batch calls should be accumulated
	do BDOFFSET(glsc.dgli, glsc.dgli, 6753, "exp", CR, POSADJ, .dep)

	quit
	
	
INCOME(RecordUTBLGLSC glsc,	// General ledger set code		/REF:R
       RecordDEP dep,		// Deposit account to post interest	/REF:R
       Number NEGADJ)		// Negative accrual adjustment amount

	// Offsetting interest income entry

	type public Number CURDEC
	type public Boolean CTL, TRB
	
	type Boolean CR
	
	// Negative interest adjustmen
	set NEGADJ = +NEGADJ.roundDec(CURDEC)

	if NEGADJ > 0 set CR = 'TRB
	else  set CR = TRB, NEGADJ = -NEGADJ

	// Invalid bank number. No G/L number found.
	if glsc.dglii.isNull() do Runtime.setErrMSG("DEP", 1270) quit

	// External calls and escrow G/L transactions must be posted through 
	// transaction driver instead of accumulated
	if CTL ! (dep.grp = "ESC") do { quit
		type String ETC
		
		if CR set ETC = "MCR"
		else  set ETC = "MDR"

		// Hide deposit / loan objects for G/L transaction
		type RecordDEP DEP = Class.new("RecordDEP")		
		type RecordLN ln = Class.new("RecordLN")
		do TRN(glsc.dglii, ETC, , .dep, .ln, NEGADJ, 0)
		}
	
	// Batch processing should be accumulated
	do BDOFFSET(glsc.dglii, glsc.dglii, 6753, "inc", CR, NEGADJ, .dep)

	quit


INT(RecordDEP dep,	// Deposit account to post interest	/REF:R
    Number POSINT,	// Positive interest amount to post	/REF:W
    Number NEGINT)	// Negative interest amount to post	/REF:W

	// Determine positive and negative interest amounts to post
	
	/*
	If the negative interest posting option is 0 (post if net accrual is 
	positive), treat POSACR as the net accrual
	*/
	
	type public Number INTAMT, MININT, NEGACR, NEGACRUN
	type public Number POSACR, UNCACR

	type Number TNEGACR	// Total negative accrual
	
	set TNEGACR = NEGACR + NEGACRUN + UNCACR
	
	// If there is an anticipated amount, post it
	if INTAMT set POSINT = INTAMT - dep.ipnd, NEGINT = TNEGACR quit

	
	// If min bal to credit int is not met, waive positive interest
	if dep.bal < MININT set POSINT = 0, NEGINT = TNEGACR quit
	 
	/*
	If accruing net and posting only positive net accrual, and 
	net accrual (POSACR) is negative, waive net interest (POSINT)
	*/
	if 'dep.negacrpo, 'dep.negipo, POSACR < 0 set (POSINT, NEGINT) = 0 quit
	
	/*
	If accruing separately and posting only positive net accrual, 
	and net accrual is negative, waive all interest
	*/
	if dep.negacrpo = 1, 'dep.negipo, TNEGACR > POSACR set (POSINT, NEGINT) = 0 quit
	
	// Posting all interest
	set POSINT = POSACR, NEGINT = TNEGACR

	quit
	
	
ACRADJ(Number ACRTYPE,		// Accrual adjustment type
       Number ADJ,		// Accrual adjustment amount	/NOREQ
       Number ADJUN,		// Unauthorized accrual adj amt	/NOREQ
       Number ADJUNCL,		// Uncollected accrual adj amt	/NOREQ
       Number ADJTYPE,		// Adjustment type
       RecordDEP dep,		// Deposit account to post int	/REF:RW
       RecordLN ln,		// Loan account number (escrow)	/REF:RW/NOREQ
       RecordUTBLGLSC glsc,	// General ledger set code	/REF:R
       RecordPRODCTL prodctl)	// Product type			/REF:R
	
	/*
	Create / post accrual adjustment

	Additional notes on ARGUMENTS:
	
		ACRTYPE 0 - Positive accrual bucket adjusted
			1 - Negative accrual (authorized) bucket adjusted
			2 - Available int accrual bucket adjusted
			3 - Uncollected accrual bucket adjusted

		ADJTYPE 0 - Not an accrual adjustment
			1 - Accrual offset to interest posting
			2 - Earnings adjustment
	*/
	
	type public Number KEEPACR

	type String TAMT, TCMT
		
	if ADJTYPE = 2 set TCMT = $$^MSG(6748)	// Earnings adjustment
	else  set TCMT = ""
	
	if 'ACRTYPE do { quit
		/*
		Only create credit adjustment transaction if there
		is no anticipated earnings amount to be kept. 
		*/

		if ADJ > 0, 'KEEPACR do ADJCR(0, ADJ, "", "", ADJTYPE, .dep, .ln, .glsc, .prodctl)  quit
		do ADJDR(0, ADJ, "", "", ADJTYPE, .dep, .ln, .glsc, .prodctl)
		}

	if ACRTYPE = 1 do { quit
		if (ADJ + ADJUN + ADJUNCL) > 0 do ADJDR(1, ADJ, ADJUN, ADJUNCL, ADJTYPE, .dep, .ln, .glsc, .prodctl) quit
		do ADJCR(1, ADJ, ADJUN, ADJUNCL, ADJTYPE, .dep, .ln, .glsc, .prodctl)
		}

	if ACRTYPE = 3 do {  quit
		if ADJUNCL > 0 do ADJDR(3, "", "", ADJUNCL, ADJTYPE, .dep, .ln, .glsc, .prodctl) quit
		do ADJCR(3, "", "", ADJUNCL, ADJTYPE, .dep, .ln, .glsc, .prodctl)
		}

	if ADJ > 0 do ADJCR(2, ADJ, "", "", ADJTYPE, .dep, .ln, .glsc, .prodctl) quit
	do ADJDR(2, ADJ, "", "", ADJTYPE, .dep, .ln, .glsc, .prodctl)

	quit


GENTDA(RecordDEP dep,		// Deposit account to post int	/REF:RW
       RecordLN ln,		// Loan account number (escrow)	/REF:RW/NOREQ
       RecordUTBLGLSC glsc,	// General ledger set code	/REF:R
       RecordPRODCTL prodctl,	// Product type			/REF:R
       String TSO)		// Transaction source
       
	/* Generate transactions to decrease accrual
	   For TAMT breakdown, look at ^STBL("GLDESCD"
	*/
	
	type public Boolean SEPNET
	type public Number AIACR, NEGACR, NEGACRUN, POSACR, POSTING
	type public Number POSTOPT, UNCACR
	
	/*
	Accruing separately, posting net - must back up and treat as though 
	POSACR and NEGACR are still separate.
	*/
	if SEPNET do { quit
		if POSACR do ACRADJ(1, -POSACR, "", "", 1, .dep, .ln, .glsc, .prodctl)
		if (NEGACR + NEGACRUN + UNCACR) > 0 do ACRADJ(1, NEGACR, NEGACRUN, UNCACR, 0, .dep, .ln, .glsc, .prodctl)
		}
	
	// Posting negative
	if POSTOPT = 2 do ACRADJ(1, -NEGACR, -NEGACRUN, -UNCACR, 1, .dep, .ln, .glsc, .prodctl) quit
	
	// Posting interest on available interest
	if POSTING = 3 do ACRADJ(2, -AIACR, "", "", 1, .dep, .ln, .glsc, .prodctl) quit

	// Posting positive or net
	do ACRADJ(0, -POSACR, "", "", 1, .dep, .ln, .glsc, .prodctl)

	quit
	
	
TRANSFER(RecordDEP dep,		// Deposit account to transfer from	/REF:RW
    	 RecordDEP deptfrpos,	// Account to transfer positive int	/REF:RW
   	 RecordDEP deptfrneg,	// Account to transfer negative int	/REF:RW
    	 RecordDEP deplaf,	// Account to transfer lease fee	/REF:RW
    	 RecordPRODCTL prodctl,	// Product type				/REF:R
    	 Number TAMT)		// Amount to transfer

	/* 
	 Transfer interest?

	 Internal VARIABLES:
		. INTTFR	Transfer option
				0 - Do not disburse funds
				1 - Pay by check
				2 - Transfer to internal positive account
				3 - Transfer to internal negative account
				4 - Transfer to external account
				5 - Transfer to lease administration account
	*/
	
	type public Number CURDEC, INTAMT, LAFTFR, NTFRCID, POSINT
	type public Number POSTING, TFRCID
	type public Boolean CTL, INTPDRCR
	type public Date DEFINP
	
	type Number FEEAMT, INTTFR = 0
	type Boolean ER = 0
	type RecordTTX ttxmcp()
	
	set TAMT = TAMT.roundDec(CURDEC)
	
	/*
	 Transfer deferred interest only if in batch mode and interest 
	 adjustments are allowed to be transferred
	*/
	if 'DEFINP.isNull(), CTL, dep.iopt '> 4 quit

	// Calculate administration fee if Lease Security Processing is enabled
	if dep.lsp = 1, 'LAFTFR.isNull() do { if 'TAMT quit
		set FEEAMT = $$LSP(.dep, TAMT)

		if FEEAMT.isNull() quit
		
		// Do not calculate amount for negative postings
		if (POSTING = 1) ! (POSINT < 0) quit

		// Transfer Lease Admin Fee from tenant to landlord account
		do TFRLAF(.dep, .deplaf, LAFTFR, FEEAMT, prodctl)
		
	        /*
		Set transactions amount to interest posted amount less lease 
		fee amount in case of subsequent interest transfer
		*/
		set TAMT = TAMT - FEEAMT
		}
		
	if 'dep.iopt quit

	// Interest posting was a credit
	if INTPDRCR do { quit:ER
		// Pay by check
		if dep.iopt = 1 ! (dep.iopt = 3) ! (INTAMT) set INTTFR = 1

		if INTAMT.isNull() do {
			// Transfer positive interest
			if (dep.iopt = 2 ! (dep.iopt = 5) ! (dep.iopt = 7)), TFRCID set INTTFR = 2
			// Transfer to external account
			if dep.iopt = 4, dep.intdisetc set INTTFR = 4
			}

		// Save file sort names and account data
		if INTTFR do TFRPINT(.dep, .deptfrpos, .ttxmcp(), TFRCID, .prodctl, INTTFR)
		}

	// Interest posting was a debit
	if 'INTPDRCR do {
		// Transfer negative
		if dep.iopt = 6, NTFRCID set INTTFR = 3
		// Transfer negative
		if dep.iopt = 7, NTFRCID!(TFRCID) set INTTFR = 3

		if INTTFR do {
			if NTFRCID do TFRPINT(.dep, .deptfrneg, .ttxmcp(), NTFRCID, .prodctl, INTTFR) quit

			do TFRPINT(.dep, .deptfrpos, .ttxmcp(), TFRCID, .prodctl, INTTFR)
			}
		}

	quit

	
RESINT(RecordDEP dep)		// Deposit account to post interest	/REF:R

	// Calculate residual interest
	
	type public Number CID, NEGINT, POSINT, RESINT
	type public Boolean ER
	
	type Number BALRINT, INT
	type String BALAVLCALCFO
	
	// If accruing net, note that NEGINT will be 0 at this point
	set INT = POSINT - NEGINT
	if INT '< 0 quit

	// Determine balance for residual interest calculation purposes
	if dep.negbalop < 3 set BALRINT = dep.bal
	else  do {  quit:ER
		// Option 3: Post negative interest up to available balance;
		// then track residual interest
 
 		type Number ODLIM
 		type Boolean AUTOD
 		type Date ODEXP, ODSTART
 		type String HOLD(), PHOLD()
 		
 		// Authorized Overdraft Flag
 		set AUTOD=0
		set BALAVLCALCFO = $$BALAVLFO^DEPCDI(dep.cid)
		if BALAVLCALCFO.extract(2)=1 set AUTOD=1

		set ODLIM = dep.odlim
		set ODSTART = dep.odstart
		set ODEXP = dep.odexp

		set BALRINT = $$EFDAVBAL^RECALC(CID, dep.bal, %SystemDate)
		}

	if (BALRINT + INT) '< 0 quit
	
	// Part of neg int is residual
	if BALRINT > 0 set RESINT = -(BALRINT + INT)
	// All neg int is residual
	else  set RESINT = -INT
		
	if NEGINT set NEGINT = NEGINT - RESINT
	else  set POSINT = POSINT + RESINT
	
	if dep.negbalop = 1 set RESINT = 0		// Waive residual interest

	quit
	

public RESFILE(Number RESAMT,		// Residual interest amount
	       Number CID,		// Deposit account number
	       Date %SystemDate)	// System date

	// Update Residual Interest table
	
	type RecordRESINT resint = Db.getRecord("RESINT", "POSTDT=:%SystemDate,CID=:CID", 1)
	set resint.resintp = resint.resintp + RESAMT
	do resint.save()
	
	quit
	
	
BDOFFSET(Number CRGL,		// Credit general ledger number
	 Number DRGL,		// Debit general ledger number
	 String TCMT,		// Transaction comment
	 String LITERAL,	// Posting source literal
	 Boolean DRCR,		// Debit / credit indicator
	 Number OFFAMT,		// Offset amount
	 RecordDEP dep)		// Deposit account to post interest	/REF:RW
	 
	 // Build offset
	 
	type public Boolean CTL
	type public Number CURDEC

	/*
	Don't accumulate offsets when called externally, or Delayed Interest 
	Posting Sweep processing is enabled, or escrow (offset handled by 
	escrow posting transaction pieced out to accrual position of TAMT)
	*/
	if CTL ! (dep.swpdelip) ! (dep.grp = "ESC") quit


	// Ensure amount is rounded
	set OFFAMT = OFFAMT.roundDec(CURDEC)
	if 'OFFAMT quit

	if 'Db.isDefined("TMPBCHOFF", "TJD=:%SystemDate,BCHID='INTPOST',JOB=:%ProcessID,LITERAL,CRCD=:dep.crcd,TYPE=:dep.type,GLSC=:dep.glsc,CC=:dep.cc") do {
		// TYPE ~p1 CC ~p2
		set TCMT = $$^MSG(6752, dep.type, dep.cc)
		do BDOFFSET^BCHSOURC("INTPOST", LITERAL, dep.crcd, dep.type, dep.glsc, dep.cc, DRGL, CRGL, "MDR", "MCR", TCMT)	
		}
	
	/* 
	  Offset Record already exists, so update it with the amount from this
	  transaction
	*/
	
	do UPOFFSET^BCHSOURC("INTPOST", LITERAL, dep.crcd, dep.type, dep.glsc, dep.cc, DRCR, OFFAMT)

	quit
	
	
EXC	// Log exceptions
	
	type public Number CID, INTTFR, LAFTFR, NTFRCID, SEG, TFRCID
	type public String %FN, ET, RM, TCMT
	
	type String ERRMSG
	type Number CIDEXC
		
	//If teller comment contains the original account number,
	//must be a tranfer to / from transfer account
	if TCMT.get().isLike("%"_CID_"%") do {
		set INTTFR = INTTFR.get()
		if INTTFR = 2 set CIDEXC = TFRCID
		else  if INTTFR = 3 set CIDEXC = NTFRCID
		else  if INTTFR = 5 set CIDEXC = LAFTFR
		}
	else  set CIDEXC = CID

	if 'SEG.get().isNull() set ERRMSG = "SEGMENT "_SEG_":"
	else  set ERRMSG = ""
	set ERRMSG = ERRMSG_$select('ET.get().isNull():ET, 1:RM.get())
	
 	do LOG^UTLEXC($T(+0), "*", , CIDEXC, "", ERRMSG)

	quit

	
LSP(RecordDEP dep,	// Deposit account			/REF:R
    Number TAMT)	// Transaction amount

	// Calculate lease security processing fee amount

	type public Number CID, CURDEC

    	type Number DIP, LAFEE, LAFEE1, LAFEE2, NODY

	if TAMT.isNull() quit ""

	// % of Opening Balance
	if dep.lafm = 1 do {
		// Number of days in period
                set DIP = %SystemDate - dep.ipld
                if 'DIP set DIP = 1
                
                // Number of days in year
                set NODY = $$NODY^SCADAT(%SystemDate, 1))
                
		set LAFEE = (DIP / NODY) * (dep.org * (dep.oborirp / 100))
		}
	// % of Int/Div Rate
	else  if dep.lafm = 2 set LAFEE = ((dep.oborirp / 100) / (dep.irn / 100)) * TAMT
	// % of Int/Div Earned
	else  if dep.lafm = 3 set LAFEE = (dep.iep / 100) * TAMT
	// Greater of % of Opening Balance or % of Int/Div Earned
	else  if dep.lafm = 4 do { 
		// Number of days in period
                set DIP = %SystemDate - dep.ipld
                if 'DIP set DIP = 1

		// Number of days in year
		set NODY = $$NODY^SCADAT(%SystemDate, 1))
                
                set LAFEE1 = (DIP / NODY) * (dep.org * (dep.oborirp / 100))
		set LAFEE2 = (dep.iep / 100) * TAMT
		
		if LAFEE1 > LAFEE2 set LAFEE = LAFEE1
		else  set LAFEE = LAFEE2
		}
	// Greater of % of Int/Div Rate or % of Int/Div Earned
	else  if dep.lafm = 5 do { 
		set LAFEE1 = ((dep.oborirp / 100) / (dep.irn / 100))*TAMT
		set LAFEE2 = (dep.iep / 100) * TAMT
		
		if LAFEE1 > LAFEE2 set LAFEE = LAFEE1		
		else  set LAFEE = LAFEE2
		}

	set LAFEE = LAFEE.roundDec(CURDEC)

	quit LAFEE
	   

TFRPINT(RecordDEP dep,		// Deposit account to transfer from	/REF:RW
	RecordDEP deptfr,	// Account to transfer interest		/REF:RW
	RecordTTX ttxmcp(),	// Multi-currency transaction set	/REF:W
	Number TFRCID,		// Transfer account number
	RecordPRODCTL prodctl,	// Product type				/REF:R
	Number INTTFR)		// Interest transfer option

	/*
	 Transfer interest on principal (positive or negative amounts)
 
	 Additional notes on ARGUMENTS:
		. INTTFR
				0 - Do not disburse funds
				1 - Pay by check
				2 - Transfer to internal positive account
				3 - Transfer to internal negative account
				4 - Transfer to external account
				5 - Transfer to lease administration account
 
	*/
	
	type public Number TAMT
	type public Number CID
	type public Boolean ER
	
	type Boolean CHECK

	if dep.iopt = 6 do {
		// Transferring negative interest
		set TAMT = TAMT - dep.ipnd
		if -TAMT < dep.bal, dep.bal < 0 set TAMT = dep.bal
		}
	else  if dep.iopt '= 7 do {
		// Transferring positive interest or paying by check
		set TAMT = TAMT + dep.ipnd
		if TAMT > dep.bal, dep.bal > 0 set TAMT = dep.bal
		}

	if INTTFR = 4 do EFTREC(dep.intdisetc, dep.intdisets, "", "", dep.acn, dep.crcd) quit
	
	if INTTFR = 1 do XPDO(.dep, .CHECK) if 'CHECK quit

	// Transfer from interest account
	do IPACTFR(.dep, deptfr, .ttxmcp(), .prodctl) if ER do EXC quit

	set TAMT = +TAMT
	if INTTFR = 1 do XPDO2(.dep, .prodctl) quit
 
	// Transfer to transfer account
	do XTFR(.dep, .deptfr, .ttxmcp(), CID, TFRCID)

	quit


TFRLAF(RecordDEP dep, 		// Deposit account to transer from	/REF:RW
       RecordDEP deplaf,	// Lease administration account
       Number LAFTFR,		// Lease Administration account number
       Number FEEAMT,		// Lease fee amount
       RecordPRODCTL prodctl)	// Product type				/REF:R

	type String ITC, TCMT, TSO
	type Boolean ER, INTTFR = 5
	type RecordTTX ttxmcp()

	set TSO = ""
	
	do DRLAF(.dep, .deplaf, .ttxmcp(), LAFTFR, .prodctl, FEEAMT) if ER do EXC quit
	do CRLAF(.dep, .deplaf, .ttxmcp(), LAFTFR, FEEAMT) quit:ER

	quit


DRLAF(RecordDEP dep,		// Deposit account to transfer from	/REF:RW
      RecordDEP deplaf,		// Lease administration account		/REF:RW
      RecordTTX ttxmcp(),	// Multi-currency transaction set	/REF:W
      Number LAFTFR,		// Lease Administration account number
      RecordPRODCTL prodctl,	// Product type				/REF:R
      Number TAMT)		// Transaction amount

	// Debit transaction for tenant account
	
	type public Boolean ER
	type public Number CID
	
	type String CCODE, ETC, FCRCD, TCMT
	
	set FCRCD = deplaf.crcd
	set TCMT = "TFRLAF-"_LAFTFR
	set CCODE = dep.ccode

	/*
	Normally, a debit reduces the balance for a deposit account, 
	so the a debit will transaction will be used here
	*/

	if 'dep.trb do {
		// Lease Admin. Fee - Debit
        	set ETC = prodctl.drlaf
		// DR General Purpose TC
        	if ETC.isNull() set ETC = prodctl.drtrgp
		}
	else  do {
		// Lease Admin. Fee - Credit
        	set ETC = prodctl.crlaf
		// CR General Purpose TC
		if ETC.isNull() set ETC = prodctl.crtrgp
		}

	// Post debit for fee to tenant account
	type RecordLN ln = Class.new("RecordLN")
	do TRN(CID, ETC, .ttxmcp(), .dep, .ln, TAMT, 0) quit:ER

	// Update Admin.Expense - Year to Date field
	set dep.aeytd = dep.aeytd + TAMT
        
	quit


CRLAF(RecordDEP dep,		// Deposit account			/REF:RW
      RecordDEP deplaf,		// Lease administration account		/REF:RW
      RecordTTX ttxmcp(),	// Multi-currency transaction set	/REF:W
      Number LAFTFR,		// Lease Administration account number
      Number TAMT)		// Transaction amount
      
	//Credit transaction for landlord account

	type public Boolean ER
	type public Cache %CACHE()
	
	type Number CID
	type String CCODE, ETC, FCRCD, TCMT
	type Boolean EXCH
	
	// Indicate a currency exchange is to take place (TO)
	#IF CUVAR.%MCP if dep.crcd '= deplaf.crcd set EXCH = 2
	
	set CID = LAFTFR

	set FCRCD = dep.crcd
	set TCMT = "TFRLAF-"_dep.cid
	set CCODE = deplaf.ccode
        
       	type RecordPRODCTL tprodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:deplaf.type")

	/*
	Normally, a debit reduces the balance for a deposit account, 
	so the a credit will transaction will be used here
	*/
	if 'deplaf.trb do {
		// Lease Admin. Fee - Credit
        	set ETC = tprodctl.crlaf
		// CR General Purpose TC
        	if ETC.isNull() set ETC = tprodctl.crtrgp
		}
	else  do {
		// Lease Admin. Fee - Debit
        	set ETC = tprodctl.drlaf
		// DR General Purpose TC
		if ETC.isNull() set ETC = tprodctl.drtrgp
		}
		
	// Post credit for fee to landlord account
	type RecordLN ln = Class.new("RecordLN")
	do TRN(CID, ETC, .ttxmcp(), .deplaf, .ln, TAMT, 0) quit:ER

	quit


public XPDO(RecordDEP dep,	// Deposit account to post interest	/REF:RW
	    Boolean CHECK)	// Check flag				/REF:W

	// Paid by check (similar coding is in routine DEPAEC)
	
	type public String TAMT
	
	if dep.swpdelip quit

	if ((TAMT + dep.intchkbkt) < dep.intchkmin) ! (dep.intchknd& (%SystemDate '= dep.intchknd)) do {
		set dep.intchkbkt = dep.intchkbkt + TAMT
		set CHECK=0
		}
	else  set CHECK = 1

	if CHECK set TAMT.piece("#", 1) = TAMT + dep.intchkbkt, dep.intchkbkt = 0

	quit
	

public XPDO2(RecordDEP dep,		// Deposit account to post int	/REF:R
	     RecordPRODCTL prodctl)	// Product type			/REF:R

	// Generate interest check
	
	type public Boolean CTL, ER
	type public Number BRCD, CID, INTAMT, TAMT
	type public String IPITC
		
	type Number CKSEQ

	if dep.swpdelip quit
	
	type ResultSet rs = Db.select("CKSEQ", "XPDO", "TJD=:%SystemDate AND CKTYP=:prodctl.ckint", "CKSEQ DESC")
	if rs.next() set CKSEQ = rs.getCol("CKSEQ") + 1
	else  set CKSEQ = 1

	type RecordXPDO xpdo = Class.new("RecordXPDO", "TJD=:%SystemDate,CKTYP=:prodctl.ckint,CKSEQ=:CKSEQ")

	// Check Type TC
	set xpdo.brcd = BRCD
	set xpdo.uid = %UserID
	set xpdo.cid = CID
	set xpdo.tamt = TAMT
	
	if dep.ira set xpdo.tso = $$RPATSO("IRAD", dep.ira, CUVAR.IRAIPO) quit:ER

	// If INTAMT is 0 or null, Print Flag should be 0 (print); any other
	// value it should be 1 (do not print)
	set xpdo.pntflg = ''INTAMT

	do xpdo.bypassSave()
	
	// Check offset transaction
	do BDOFFSET(CUVAR.IPCID, CUVAR.IPCID, 6752, "CHECK", IPITC, TAMT, .dep)

	quit

	
XTFR(RecordDEP dep,		// Deposit account to transfer from	/REF:R
     RecordDEP deptfr,		// Account to transfer interest		/REF:RW
     RecordTTX ttxmcp(),	// Multi-currency transaction set	/REF:W
     Number SCID,		// Transfer from (source) account number
     Number TFRCID)		// Transfer to account number

	// Interest transfer in
	
	type public Cache %CACHE()
	type public Boolean ER, INTPDRCR
	type public String TAMT
	
	type Boolean CRCOMP, EXCH, ITC
	type Number CID
	type String CCODE, ETC, FCRCD, TCMT, TSO
		
	// Indicate a currency exchange is to take place (TO)
	#IF CUVAR.%MCP if dep.crcd '= deptfr.crcd set EXCH = 2

	set TCMT = "TFR-"_SCID
	set CID = TFRCID
	set FCRCD = dep.crcd
	set CCODE = deptfr.ccode

	type RecordPRODCTL tprodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:deptfr.type")

	if deptfr.ira set TSO = $$RPATSO("IRAC", deptfr.ira, CUVAR.IRAINT) quit:ER
	else  set TSO = ""

	#IF CUVAR.IPD
		// Need to add INTTRF flag for IPD (Include Posting Day) 
		// accounts and add the transfer amount to DEP.IPDTRF
		set deptfr.ipdtrf = deptfr.ipdtrf + TAMT
		set TSO = $$FIELDIN^UTSO("", "INTTRF")
	#ENDIF
	
	// Credit comparison
	if 'INTPDRCR set CRCOMP = 'deptfr.trb
	else  set CRCOMP = +deptfr.trb

	/* 
	   Have we crossed an asset liability boundary?  Could be negative
	   amount transferred to a Nostro.
	*/
	if $$TRB^UTRB(SCID) = CRCOMP do {
		// CR Dividend Transfer tran code (transfer positive)
		if dep.swpf = 2 set ETC = tprodctl.crtrdv
		// CR Interest Transfer tran code (transfer positive)
		if dep.swpf '= 2 ! (ETC.isNull()) set ETC = tprodctl.crtrit
		set ITC = 1
		}
	// Credit reduces balance
	else  do {
		// DR Dividend Transfer tran code (transfer negative)
		if dep.swpf = 2 set ETC = tprodctl.drtrdv
		// DR Interest Transfer tran code (transfer negative)
		if dep.swpf '= 2 ! (ETC.isNull()) set ETC = tprodctl.drtrit
		set ITC = 0
		}

	type RecordLN ln = Class.new("RecordLN")
	do TRN(CID, ETC, .ttxmcp(), .deptfr, .ln, TAMT, 0) quit:ER
        
	quit
	
	
IPACTFR(RecordDEP dep,		// Deposit account to transfer from	/REF:RW
	RecordDEP deptfr,	// Deposit account to transfer to	/REF:R
	RecordTTX ttxmcp(),	// Multi-currency transaction set	/REF:W
	RecordPRODCTL prodctl)	// Product type				/REF:R

	// Check / Interest posted account transfer out
	
	type public Number CID, INTTFR, TFRCID, TRB
	type public String TAMT
	type public Boolean ER, INTPDRCR

	type String ETC, TCMT, TSO

	// Interest paid not disbursed
	set dep.ipnd = 0
	
	if dep.ira set TSO = $$RPATSO("IRAD", dep.ira, CUVAR.IRAIPO) quit:ER
	else  set TSO = ""
	 
	#IF CUVAR.IPD
		// Need to add INTTRF flag for IPD (Include Posting Day) 
		// accounts and subtract the transfer amount from DEP.IPDTRF
		set dep.ipdtrf = dep.ipdtrf - TAMT
		set TSO = $$FIELDIN^UTSO("", "INTTRF")
	#ENDIF
	
	// Reverse transaction codes for debit transfers
	// Prevent debit to a check
	if INTTFR = 1, $select(INTPDRCR:TRB, 1:'TRB) quit

	if INTTFR = 1 do {
		// Pay by Check
		set TCMT = "PDO"
		// DR General Purpose Tran Code
		set ETC = prodctl.drtrgp
		}
	else  do {
		
		// Interest posting was a credit
		if INTPDRCR = 1 do {
			// DR Interest Transfer tran code (transfer pos int)
			if dep.swpf = 2 set ETC = prodctl.drtrdv
			// DR Dividend Transfer tran code (transfer pos int)
			if dep.swpf '= 2 ! (ETC.isNull()) set ETC = prodctl.drtrit

			// Positive net interest
			set TCMT = "POSINT-TFR-"_TFRCID
			}
		else  do {
			// CR Interest Transfer tran code (transfer negative)
			if dep.swpf = 2 set ETC = prodctl.crtrdv
			// CR Dividend Transfer tran code (transfer negative)
			if dep.swpf '= 2 ! (ETC.isNull()) set ETC = prodctl.crtrit

			// Negative net interest
			set TCMT = "NEGINT-TFR-"_TFRCID
			}
		}

	type RecordLN ln = Class.new("RecordLN")
	do TRN(CID, ETC, .ttxmcp(), .dep, .ln, TAMT, 0) quit:ER

	quit


ACCTLEV(RecordDEP dep,		// Deposit account to post interest	/REF:RW
	RecordDEP deptfr,	// Account to transfer interst		/REF:RW
	RecordPRODCTL prodctl,	// Product type				/REF:R
	RecordUTBLGLSC glsc)	// General ledger set code		/REF:R
	
	// Segmented account - Post at account level (only one pass needed)
	
	type public Boolean ER
	type public Number POSTING
	
	type Number AIACR, BAL, POSACR

	type RecordDEPSEG depseg = Class.new("RecordDEPSEG")

	if POSTING = 2 do {
		// Check for int next post date in sync for actual posting only
		if dep.inp '= %SystemDate quit

		set BAL = dep.bal
		set POSACR = +dep.posacr

		do SPRINT(.dep, .deptfr, .depseg, .prodctl, .glsc) if ER quit
		}
	else  do {
		// Check for int next post date in sync for actual posting only
		if dep.aiinp '= %SystemDate quit

		set BAL = dep.tsab
		set AIACR = +dep.aiacr

		do SAINT(.dep, .deptfr, .depseg, .prodctl, .glsc) if ER quit
		}

	if ER do EXC

	do BUMPSINP(.dep ,.depseg)

	quit


SEGLEV(RecordDEP dep,		// Deposit account to post interest	/REF:RW
       RecordDEP deptfr,	// Account to transfer interest		/REF:RW
       RecordPRODCTL prodctl,	// Product type				/REF:R
       RecordUTBLGLSC glsc)	// General ledger set code		/REF:R
       
	// Segmented account - Post at segment level
	
	type public String EVENT
	type public Number CID, CTL, POSTING

	type Number SEG

	if CTL, 'EVENT.get().isNull() do { quit
		type String UANTSEGS
		type Number UPOS
		
		// Posting segments list
		set UANTSEGS = EVENT.piece("|", 5)
		set UPOS = 0
		
		type RecordDEPSEG depseg = Class.new("RecordDEPSEG")

		for  set UPOS = UPOS + 1, SEG = UANTSEGS.piece(",", UPOS) quit:SEG.isNull()  do {
			type Boolean ER = 0

			type RecordDEPSEG depseg = Db.getRecord("DEPSEG", "CID=:CID,SEGMENT=:SEG")

			do SEGMENT(.dep, .deptfr, .depseg, .prodctl, .glsc)
			if ER do EXC

			do BUMPSINP(.dep, .depseg)
			}
		}

	// Process all segments scheduled for interest (on prin) posting today
	if POSTING = 2 do { quit
		type ResultSet rs = Db.select("SEG", "DAYENDSEGIP", "TJD=:%SystemDate AND CID=:CID AND POSTING=2")

		while rs.next() do {
			/*
			Bump segment next posting dates for all segments 
			even if an error occurs and the segment is not 
			posted to.
			*/

			type Boolean ER = 0
			
			set SEG = rs.getCol("SEG")	// Segment number

			type RecordDEPSEG depseg = Db.getRecord("DEPSEG", "CID=:CID,SEGMENT=:SEG")

			do SEGMENT(.dep, .deptfr, .depseg, .prodctl, .glsc)
			if ER do EXC

			do BUMPSINP(.dep, .depseg)
			}
		}

	// Process all segments scheduled for int (on avail int) posting today
	type ResultSet rs = Db.select("SEG", "DAYENDSEGIP", "TJD=:%SystemDate AND CID=:CID AND POSTING=3")

	while rs.next() do {
		/*
		Bump segment avail int next posting dates for all segments 
		even if an error occurs and the segment is not 
		posted to.
		*/
		
		type Boolean ER = 0

		set SEG = rs.getCol("SEG")		// Segment number
 
		type RecordDEPSEG depseg = Db.getRecord("DEPSEG", "CID=:CID,SEGMENT=:SEG")
 
		do SEGMENT(.dep, .deptfr, .depseg, .prodctl, .glsc)
		if ER do EXC

		do BUMPSINP(.dep, .depseg)
		}

	quit


SEGMENT(RecordDEP dep,		// Deposit account to post interest	/REF:RW
	RecordDEP deptfr,	// Account to transfer interest		/REF:RW
	RecordDEPSEG depseg,	// Deposit account segment		/REF:RW
	RecordPRODCTL prodctl,	// Product type				/REF:R
	RecordUTBLGLSC glsc)	// General ledger set code		/REF:R
	
	type public Boolean ER
	type public Number POSTING

	type Number AIACR, BAL, POSACR

	 // Posting will be handled by rollover
	if depseg.segmdt = %SystemDate quit

	if POSTING = 2 do { quit:ER
		// Check for int next post date in sync for actual posting only
		if depseg.inp '= %SystemDate quit
		
		set BAL = depseg.bal
		set POSACR = +depseg.posacr

		do SPRINT(.dep, .deptfr, .depseg, .prodctl, .glsc) quit:ER
		}
	else  do { quit:ER
		// Check for int next post date in sync for actual posting only
		if depseg.aiinp '= %SystemDate quit
		
		set BAL = depseg.aibal
		set AIACR = +depseg.aiacr
	
		do SAINT(.dep, .deptfr, .depseg, .prodctl, .glsc) quit:ER
		}

	quit


SPRINT(RecordDEP dep,		// Deposit account to post interest	/REF:RW
       RecordDEP deptfr,	// Deposit transfer account		/REF:RW
       RecordDEPSEG depseg,	// Deposit account segment		/REF:RW
       RecordPRODCTL prodctl,	// Product type				/REF:R
       RecordUTBLGLSC glsc)	// General ledger set code		/REF:R
       
	// Segmented account - interest on principal
	
	type public Boolean ER

	type Number POSINT, TAMT
	
	// Start segmented account interest on principal posting fence
	do Runtime.start("BA", , "SPRIPOST")

	// Post segmented account interest on principal to account
	do SPRIPOST(.dep, .depseg, .prodctl, .glsc)

	// Roll back changes for segmented account interest on principal 
	// posting Profile application errors
	if ER do Runtime.rollback("SPRIPOST") quit

	// Commit segmented account interest on principal to database
	do Runtime.commit()

	// Transfer for positive amounts only
	if POSINT > 0 do {
		// Start segmented account interest transfer fence
		do Runtime.start("BA", , "SEGXFR")

		// Post segmented account interest transfer transactions
		do SEGXFR(.dep, .deptfr, .depseg, dep.iopt, dep.itrf, .prodctl)
		
		// Roll back changes for segmented account interest transfer
		// Profile application errors
		if ER do Runtime.rollback("SEGXFR") quit
		
		// Commit segmented account interest transfer to database
		do Runtime.commit()
		}

	quit
	
	
SPRIPOST(RecordDEP dep,		// Deposit account to post interest	/REF:RW
         RecordDEPSEG depseg,	// Deposit account segment		/REF:RW
         RecordPRODCTL prodctl,	// Product type				/REF:R
         RecordUTBLGLSC glsc)	// General ledger set code		/REF:R

	// Post segmented account interest on principal

	type public Number BAL, CID, CURDEC, KEEPACR, MININT, POSACR, POSINT
	type public String TAMT
	type public Boolean ER, TRB

	type Number POSADJ
	type String ETC, TCMT, TSO

	set POSADJ = 0

	set POSINT = +POSACR	// Positive interest

	// If min bal to credit int is not met, waive positive interest
	if BAL < MININT set POSINT = 0
	/*
	If accruing net and posting only positive net accrual, and 
	net accrual (POSACR) is negative, waive net interest (POSINT)
	*/
	else  if 'dep.negacrpo, 'dep.negipo, POSACR < 0 set POSINT = 0
	
	if 'POSINT do ADJ(POSINT, .POSACR, .POSADJ, .KEEPACR, .dep)
	
	// Equivalent to POST section

	// Make any necessary accrual adjustment transactions and offsets
 	if POSADJ do { quit:ER
		do ACRADJ(0, POSADJ, "", "", 2, .dep, , .glsc, .prodctl)
		do EXPENSE(.glsc, .dep, POSADJ)
		}
	else  set TSO = ""

	if 'POSINT, 'POSADJ quit
	
	set TCMT = ""
	set TAMT = POSINT
	set TSO = $$FIELDIN^UTSO(TSO, "EXACTACR", POSACR)

	// DR / CR interest paid
	if POSINT < 0 set ETC = prodctl.drtrin
	else  set ETC = prodctl.crtrin

	type RecordLN ln = Class.new("RecordLN")
	do TRN(CID, ETC, , .dep, .ln, TAMT, 0) quit:ER

	set TCMT = ""

	// Generate accrual adjustments
	do GENTDA(.dep, , .glsc, .prodctl, TSO) quit:ER
	
	// Accumulate general ledger offset
	if POSACR do STAT(TRB, POSINT, 1, .glsc, .dep)

	quit


SAINT(RecordDEP dep,		// Deposit account to post interest	/REF:RW
      RecordDEP deptfr,		// Account to transfer interest		/REF:RW
      RecordDEPSEG depseg,	// Deposit account segment		/REF:RW
      RecordPRODCTL prodctl,	// Product type				/REF:R
      RecordUTBLGLSC glsc)	// General ledger set code		/REF:R

	// Segmented account - interest on available interest

	type public Boolean ER
	
	type Number AIINT, TAMT

	// Start segmented account interest on available interest posting fence
	do Runtime.start("BA", , "SAIPOST")

	// Post segmented account interest on available interest to account
	do SAIPOST(.dep, .prodctl, .glsc)

	// Roll back changes for segmented account interest on available 
	// interest posting Profile application errors
	if ER do Runtime.rollback("SAIPOST") quit

	// Commit segmented account interest on available interest to database
	do Runtime.commit()

	// Transfer for positive amounts only	
	if AIINT > 0 do {
		// Start segmented account interest on available interest 
		// transfer fence
		do Runtime.start("BA", , "SEGXFR")

		// Post segmented account interest on available interest 
		// transfer transactions
		do SEGXFR(.dep, .deptfr, .depseg, dep.aiiopt, dep.aiinttrf, .prodctl)
		
		// Roll back changes for segmented account interest on 
		// available interest transfer Profile application errors
		if ER do Runtime.rollback("SEGXFR") quit
		
		// Commit segmented account interest on available interest 
		// transfer to database
		do Runtime.commit()
		}
	
	quit
	
	
SAIPOST(RecordDEP dep,		// Deposit account to post interest	/REF:RW
        RecordPRODCTL prodctl,	// Product type				/REF:R
        RecordUTBLGLSC glsc)	// General ledger set code		/REF:R
        
       	// Segmented account - interest on available interest posting

	type public Number AIACR, AIINT, BAL, CID, CURDEC, MININT
	type public String TAMT
	type public Boolean ER, TRB

	type Number AIADJ
	type String ETC, TCMT, TSO
	
	set AIADJ = 0

	// Interest on available interest
	set AIINT = +AIACR

	if 'AIINT do ADJ(AIINT, .AIACR, .AIADJ, , .dep)

	if 'AIACR, 'AIADJ quit
	
	// Equivalent to POST section
	
	// Make any necessary accrual adjustment transactions and offsets
	set TSO = ""
 	if AIADJ do { quit:ER
		do ACRADJ(2, AIADJ, "", "", 2, .dep, , .glsc, .prodctl)
		do EXPENSE(.glsc, .dep, AIADJ)
		}

	if 'AIINT, 'AIADJ quit
	
	set TCMT = ""
	set TAMT = AIINT
	set TSO = $$FIELDIN^UTSO(TSO, "EXACTACR", AIACR)
	
	// DR / CR int posted on avail int
	if AIINT < 0 set ETC = prodctl.drpai
	else  set ETC = prodctl.drpai

	type RecordLN ln = Class.new("RecordLN")
	do TRN(CID, ETC, , .dep, .ln, TAMT, 0) quit:ER
	
	set TCMT = ""

	// Generate accrual adjustments
	do GENTDA(.dep, , .glsc, .prodctl, TSO) quit:ER
	
	// Accumulate general ledger offset
	if AIACR do STAT(TRB, AIINT, 2, .glsc, .dep)

	quit


BUMPSINP(RecordDEP dep,		// Deposit account to post interest	/REF:RW
	 RecordDEPSEG depseg)	// Deposit account segment		/REF:RW

	// Bump segment interest posting date
	
	type public String ET
	type public Number CID, POSTING, SEG
	type public Boolean CTL

	type Boolean ER = 0
	type String FRE
	type Date NJD

	// Bump interest posting next date
	if POSTING = 2 do { quit

		// Interest at account level
 		if dep.segacr do { quit
			set dep.ipld = %SystemDate
			if dep.ipf.isNull() quit

			set dep.inp = %SystemDate.nextFreqDate(dep.ipf)
			
			// Invalid frequency
			if dep.inp < 0 ! (ER) do Runtime.setErrSTBLER("DEP", "INVLDFRE1") do EXC quit
			
			do dep.bypassSave()

			if CTL quit

			type RecordDAYENDSEGIP nextinp = Db.getRecord("DAYENDSEGIP", "TJD=:dep.inp,CID=:CID,POSTING=:POSTING,SEG=-1", 1)
			do nextinp.bypassSave()
 			}

		// Interest at segment level

		set depseg.ipld = %SystemDate
		if depseg.ipf.isNull() quit

		set depseg.inp = %SystemDate.nextFreqDate(depseg.ipf)
		
		// Invalid frequency
		if depseg.inp < 0 ! (ER) do Runtime.setErrSTBLER("DEPSEG", "INVLDFRE1") do EXC quit
		
		do depseg.bypassSave()

		if CTL quit

		type RecordDAYENDSEGIP nextinp = Db.getRecord("DAYENDSEGIP", "TJD=:depseg.inp,CID=:CID,POSTING=:POSTING,SEG=:SEG", 1)
		do nextinp.bypassSave()
		}

	// Bump available interest posting next date
	if POSTING = 3 do {

		// Available interest at account level
		if dep.segacr do { quit
			set dep.aiipld = %SystemDate
			if dep.aiipf.isNull() quit

			set dep.aiinp = %SystemDate.nextFreqDate(dep.aiipf)
			
			// Invalid frequency
			if dep.aiinp < 0 ! (ER) do Runtime.setErrSTBLER("DEP", "INVLDFRE1") do EXC quit
			
			do depseg.bypassSave()
			
			if CTL quit

			type RecordDAYENDSEGIP nextinp = Db.getRecord("DAYENDSEGIP", "TJD=:dep.aiinp,CID=:CID,POSTING=:POSTING,SEG=-1", 1)
			do nextinp.bypassSave()
			}

		// Available interest at segment level

		set depseg.aiipld = %SystemDate
		if depseg.aiipf.isNull() quit

		set depseg.aiinp = %SystemDate.nextFreqDate(depseg.aiipf)
		
		// Invalid frequency
		if depseg.aiinp < 0 ! (ER) do Runtime.setErrSTBLER("DEPSEG", "INVLDFRE1") do EXC quit
		
		do depseg.bypassSave()

		if CTL quit

		type RecordDAYENDSEGIP nextinp = Db.getRecord("DAYENDSEGIP", "TJD=:depseg.aiinp,CID=:CID,POSTING=:POSTING,SEG=:SEG", 1)
		do nextinp.bypassSave()
		}
	
	quit
	
	
SEGXFR(RecordDEP dep,		// Deposit account to transfer from	/REF:RW
       RecordDEP deptfr,	// Account to transfer interest		/REF:RW
       RecordDEPSEG depseg,	// Deposit account segment		/REF:RW
       Number IOPT,		// Transaction set			/REF:W
       Number TFRCID,		// Transaction set			/REF:W
       RecordPRODCTL prodctl)	// Product type				/REF:R
       
	// Transfer interest for segmented account?
	
	type Boolean ER = 0
	type Number INTTFR
	type RecordTTX ttxmcp()
	
	if IOPT = 1 ! (IOPT = 3) set INTTFR = 1
	else  if IOPT = 2, TFRCID set INTTFR = 2
	else  if IOPT = 4 set INTTFR = 4
	else  set INTTFR = 0

	if INTTFR do TFRSINT(.dep, .deptfr, .depseg, .ttxmcp(), TFRCID, .prodctl)

	quit


TFRSINT(RecordDEP dep,		// Deposit account to transfer int from	/REF:RW
	RecordDEP deptfr,	// Account to transfer interest	to	/REF:RW
	RecordDEPSEG depseg,	// Deposit account segment		/REF:RW
	RecordTTX ttxmcp(),	// Multi-currency transaction set	/REF:W
	Number TFRCID,		// Transfer account number
	RecordPRODCTL prodctl)	// Product type				/REF:R

	/*
	 Transfer interest (positive amounts only) for segmented accounts
 
	 INPUTS:
		. INTTFR	Interest transfer option
				1 - Pay by check
				2 - Transfer to internal account
				4 - Transfer to external account
 
		. POSTING	Posting type
				0  Positive Interest
				1  Negative interest
		 		2  Segment interest
				3  Segment available interest
 
	*/
	
	type public Boolean CTL, ER, TRB
	type public Number CID, INTTFR, POSTING, SEG, TSCRCID
	type public String ETC, TAMT, TCMT

	// Interest transfer not supported for esrow
	type RecordLN ln = Class.new("RecordLN")	

	type String TSO

	#IF CUVAR.IPD
		// Need to add INTTRF flag for IPD (Include Posting Day) 
		// accounts and subtrct the transfer amount from DEP.IPDTRF
		set deptfr.ipdtrf = deptfr.ipdtrf - TAMT
		// Interest/Dividend Transfer
		set TSO = $$FIELDIN^UTSO("", "INTTRF", "")
	#ELSE
		set TSO = ""
	#ENDIF

	if 'dep.segacr do {
		if POSTING = 2 do {
			// Use principal amount
			set:TAMT.isLike("%#%") TAMT = TAMT.piece("#", 2) 
			set TSO = $$TSOSEG(TSO, "SEGP", SEG, +TAMT)
			}
		else  do {
			// Use available interest amount
			set:TAMT.isLike("%#%") TAMT = TAMT.piece("#", 8)
			set TAMT.piece("#", 8) = TAMT 
			set TSO = $$TSOSEG(TSO, "SEGI", SEG, +TAMT)
			}
		}

	if INTTFR = 4 do { quit
		if CTL do { quit
			/*
			External call - simulate INTTFR=4 (Transfer to external 
			account) as INTTFR=2 (Transfer to internal pos account) 
			using transaction suspense credit account. This
			is necessary because EFTBUILD does not handle calls 
			from back-dated / future-dated processing.
			*/

			set TCMT = "TFR-"_TSCRCID
			
			// CR Interest Transfer TC
			set ETC = prodctl.drtrit

			// DR suspense account
			do TRN(CID, ETC, .ttxmcp(), .dep, .ln, TAMT, 0) quit:ER

			set TAMT = +TAMT
			// Takes place of tfr to external account
			set TCMT = ""
			set ETC = "TSCR"
			set TSO = "GLO#"_CID

			// CR suspense account
			type Number CID = TSCRCID
			do TRN(CID, ETC, .ttxmcp(), .dep, .ln, TAMT, 0) quit:ER
			}

		// DR Interest Transfer TC
		set ETC = prodctl.drtrit

		if POSTING = 2 do EFTREC(dep.intdisetc, dep.intdisets, ETC, TSO, dep.acn, dep.crcd)
		if POSTING = 3 do EFTREC(dep.aiextacn, dep.aiextseq, ETC, TSO, dep.acn, dep.crcd)
		}
	
	// Prevent debit to a check
	if INTTFR = 1, TRB quit

	if INTTFR = 2 do {
		// DR Interest Transfer TC
		set ETC = prodctl.drtrit
		set TCMT = "TFR-"_TFRCID
		}
	else  do {
		// DR Interest Paid TC
		set ETC = prodctl.drtrip
		set TCMT = "PDO"
		}

	// Debit source account
	do TRN(CID, ETC, .ttxmcp(), .dep, .ln, TAMT, 0) quit:ER

	set TAMT = +TAMT

	// Generate interest check
	if INTTFR = 1 do XPDO2(.dep, .prodctl) quit

	// Transfer to target account
	if INTTFR = 2 do XTFR(.dep, .deptfr, .ttxmcp(), CID, TFRCID)

	quit


TSOSEG(String TSO,	// Transaction source
       Number TYPE,	// TSO type
       Number SEG,	// Segment number
       Number AMT)	// Amount

	/* 
	 Set segment TSO type into TSO field

	 RETURNS:
		. TSO		Transaction source
	*/
 
	type String TSOSEG

	set TSOSEG = $$FIELD^UTSO(TSO, TYPE)
	if 'TSOSEG.isNull() set TSOSEG = TSOSEG_"^"_SEG_":"_AMT
	else  set TSOSEG = SEG_":"_AMT
	set TSO = $$FIELDIN^UTSO(TSO, TYPE, TSOSEG)

	quit TSO


EFTREC(Number ACN,	// External customer account
       Number SEQ,	// External sequence number
       String TC,	// Transaction code
       String TSO,	// Transaction source
       Number CIF,	// CIF account number
       String CRCD)	// Currency code

	/*
	Build Electronic Funds Transfer record

	 INPUTS:
		. CID		Account number		/REQ
		
		. TAMT		Transaction amount	/REQ

	*/
	
	type public Number CID
	type public String TAMT

	type String CONSTANT, EXTCITY, EXTINST, EXTNAME, TCMT
	type Number RCID

	set SEQ = +SEQ
	type RecordCIFEXT cifext = Db.getRecord("CIFEXT", "ACN=:ACN,SEQ=:SEQ")

	set EXTINST = cifext.extinst		// External Institution
	set EXTNAME = cifext.benname		// Beneficiary Name
	set EXTCITY = cifext.bencity		// Beneficiary City
	set RCID = cifext.extacct		// Recipient Account
	set CONSTANT = cifext.constant		// External account type
	set TSO = ""
	set TSO = $$FIELDIN^UTSO(TSO, "EXTNAME", EXTNAME)
	set TSO = $$FIELDIN^UTSO(TSO, "EXTCITY", EXTCITY)
	set TCMT = "TFR-"_ACN

	// Note EFTBUILD will file it's own exception if error occurs
	do ^EFTBUILD(CID, , RCID, EXTINST, +TAMT, CRCD, %SystemDate, , "PO", 1, TSO, TC, , CONSTANT)

	quit


CIDINIT(RecordDEP dep,		// Account to post interest		/REF:R
	RecordUTBLGLSC glsc,	// General ledger set code		/REF:W
	RecordPRODCTL prodctl,	// Product type				/REF:W
	RecordDEP deptfrpos,	// Account to transfer positive int	/REF:W
	RecordDEP deptfrneg,	// Account to transfer negative int	/REF:W
	RecordDEP deplaf,	// Lease security transfer account	/REF:W
	RecordLN ln)		// Loan account				/REF:W
	
	// Initialize variables / objects specific to account

	type public Cache %CACHE()
	type public Number AREF, INTAMT, KEEPACR, LAFTFR
	type public Number CURDEC, MININT, NEGMININ, NTFRCID, TFRCID
	type public String CCODE
	type public Boolean TRB
	type public Date NBD

	set CCODE = dep.ccode
	set TRB = +dep.trb		// Transaction to Reduce Balance

	set LAFTFR = +dep.laftfr	// Lease security transfer account
	set TFRCID = +dep.itrf		// Interest Transfer Account
	
	/*
	Use Avail Interest Trasfer Account if regular transfer account is 
	not defined (they are mutually exclusive)
	*/
	if dep.segflg, TFRCID.isNull() set TFRCID = dep.aiinttrf
	set NTFRCID = +dep.negitrf	// Negative Int Transfer Account

 	set INTAMT = dep.aecint		// Interest Amount
	
	// Minimum balance to credit interest
	set MININT = dep.minint
	if MININT.isNull() set MININT = -1E15
	
	// Minimum negative interest to charge
	set NEGMININ = dep.negminint
	if NEGMININ.isNull() set NEGMININ = -1E15
	
	// Set up currency decimal precision
	set CURDEC = $$curdec^CRCDUTL(dep.crcd)
	
	// Escrow account initialization
	set AREF = +dep.aref			// Loan Account Number

	// Delayed interest posting
	set NBD = $$CHKNBDC(.dep)
	set KEEPACR = 0

	set glsc = %CACHE("GLSC").getRecord("UTBLGLSC", "GLSC=:dep.glsc")       	
	set prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:dep.type")
	
	set deptfrpos = Db.getRecord("DEP", "CID=:TFRCID", 1)	
	set deptfrneg = Db.getRecord("DEP", "CID=:NTFRCID", 1)
	set deplaf = Db.getRecord("DEP", "CID=:LAFTFR", 1)
	
	#ACCEPT DATE=02/08/06;PGM=SmithCD
	if 'ln.getPointer() set ln = Db.getRecord("LN", "CID=:AREF", 1)
	
	quit


CHKNBDC(RecordDEP dep)	// Deposit account number		/REF:R

	/* 
	Check the date for next valid business date

	This subsection returns the next business date according to two
	non-business date calendars: dep.nbdc and CUVAR.brknbdc.
	*/
 
	type String CAL1, CAL2
	type Date STD, DATE1, DATE2, FND

	set STD = %SystemDate + 1
	set FND = 0
	set CAL1 = dep.nbdc
	set CAL2 = CUVAR.BRKNBDC

	for  quit:FND  do {
		set DATE1 = $$NBD^UNBD(STD, 0, 0, CAL1)
		set DATE2 = $$NBD^UNBD(STD, 0, 0, CAL2)
		if DATE1 = DATE2 set FND = DATE1 quit
		if DATE1 > DATE2 set STD = DATE1
		else  set STD = DATE2
		}

	quit FND


CUMDEP(RecordDEP dep,		// Account to post interest		/REF:RW
       RecordUTBLGLSC glsc,	// General ledger set code		/REF:R
       RecordPRODCTL prodctl)	// Product type				/REF:R

	// Calculate cumulative interest and post difference
	
	type public Number CID, CURDEC
	type public Boolean ER

	type Number CUMINT, DIFF
	type String TCMT

	set CUMINT = $$CALC^UACRIND(dep.schdepf, dep.icf, dep.irn, dep.schdepa, dep.odt, dep.schdepn)
	set CUMINT = CUMINT.roundDec(CURDEC) quit:ER
 
	set DIFF = CUMINT - dep.ipl
 
	if DIFF do { quit:ER
		do POSINT(DIFF, .dep, .prodctl) quit:ER
		do EXPENSE(.glsc, .dep, DIFF) quit:ER
		}

	quit


POSINT(Number ADJ,		// Interest amount
       RecordDEP dep,		// Account to post interest		/REF:RW
       RecordPRODCTL prodctl)	// Product type				/REF:R

	// Interest adjustment for cumulative accounts

	type public Boolean ER
	type public Number CID
	
	// Interest cumulative interest not supported for esrow
	type RecordLN ln = Class.new("RecordLN")
	
	type Number TAMT
	type String ETC, TCMT, TSO
	
	// DR Pos. Interest Paid TC
	if ADJ < 0 set ETC = prodctl.drtrin, TAMT = -ADJ
	// CR Interest Paid TC
	else  set ETC = prodctl.crtrin, TAMT = ADJ

 	// Cumulative interest posting adj
	set TCMT = $$^MSG(4681)

	set TSO = "NOADJ#1"

	do TRN(CID, ETC, , .dep, .ln, TAMT, 0) quit:ER
 
	quit
	
	
RPATSO(String TSOTYPE,		// "IRAD" or "IRAC"
       Number RPA,		// Retirement Plan Account type
       String DFT)		// Default from customer variables
       
	// Determine proper teller source for retirement account trasnfer

	// Retirement Savings Plan Definition
	type RecordUTBLRSPDEF rspdef = Db.getRecord("UTBLRSPDEF", "KEY=:RPA", 1)
	if 'rspdef.getMode() quit DFT
	
	// Reason codes concatenated with IRA distribution/contribution symbol
	// Default RSP Interest Transfer In Code
	if TSOTYPE = "IRAC", 'rspdef.iraipi.isNull() quit TSOTYPE_"#"_rspdef.iraipi
	// Default RSP Interest Paid Out Code
	else  if TSOTYPE = "IRAD", 'rspdef.iraipo.isNull() quit TSOTYPE_"#"_rspdef.iraipo

	quit DFT

 
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
 type String vRECORD,CID
 for  set vRECORD=vINPUT.piece("|",1),vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD.isNull()  do {
 set CID=vRECORD.piece($C(9),1)
 do vPROC(CID)
 }
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
 type public Number vMONID,vMONCNT
 type public String vBUFOVFL
 type String vRECORD,vrow,CID
 type Number vcur,vlen
 set vINPUT=vBUFOVFL.get()
 set vBUFOVFL="",vlen=0
 type public ResultSet vRESULT
 for  do { quit:'vcur
 set vcur=vRESULT.next() if 'vcur quit
 set vrow=vRESULT.getRow()_"|",vlen=vlen+vrow.length()
 if vlen>32767 set vBUFOVFL=vrow,vcur=0 quit
 set vINPUT=vINPUT_vrow if vlen+13>32767 set vcur=0 quit
 }
 set vINPUT=vINPUT.extract(1,vINPUT.length()-1)
 set vMONCNT=vMONCNT+1
 if vMONCNT#1000=0 do UPDATE^JOBMON(vMONID,vMONCNT,$TR(vrow,$C(9),$C(44)))
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	type public Boolean ER = 0
	type public String %FN, RM
	
	/*
	 Only proceed if institution variables indicate EOD interest posting 
	 and the calling function is EOD, or institution variables indicates 
	 BOD and the calling function is BOD
	*/
	// Int/Div did not post.  Verify value of [CUVAR]INTPOS
	#IF CUVAR.INTPOS=1 if %FN '= "QUE055" set %BatchExit = 1, RM = $$^MSG(1250) quit
	#IF CUVAR.INTPOS=2 if %FN '= "QUE054" set %BatchExit = 1, RM = $$^MSG(1250) quit

 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("DISTINCT CID","DAYENDINP","DAYENDINP.TJD=:%SystemDate")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	type public Number BRCD, TSCRCID, TSDRCID

	// Init variables needed for processing
	do INIT
	
	do SOURCE^BCHSOURC("INT", "INT", .%UserID, .BRCD, .%UserClass, .TSDRCID, .TSCRCID)

	quit


INIT	// Init variables needed for processing (all int post types)

	/* 
	This section is called from all batch interest posting types 
	(positive, negative, segment and available) from thread init
	*/
	
	type public Cache %CACHE()
	type public String IPITC
	
	type String IPETC

	// Dividend check G/L offset tran code
	#IF CUVAR.IPETC
		set IPETC = CUVAR.IPETC
	#ELSE
		set IPETC = "MCR"
	#ENDIF
	
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:IPETC")
	
	// IPETC debit/credit indicator
	set IPITC = trn.itc.extract(1)

	quit


public	EXTERN(Number CID,	// Account number to post int	/REF:RW
       	       Number POSTING,	// Interest Posting type	/NOREQ
       	       RecordDEP dep,	// Deposit accounts		/NOREQ/REF:RW
       	       RecordLN ln)	// Loan account			/NOREQ/REF:RW

	/*
	Process a single account

	Called by UANTIC (for account projections) and DEPDBS / DEPCL (for 
	closeouts of deferred interest accounts)
	*/
	
	type public Boolean ER
	type public Cache %CACHE()
	
	type Number AREF, INTAMT, KEEPACR, LAFTFR, MININT
	type Number CURDEC, NEGMININ, NTFRCID, TFRCID
	type String CCODE
	type Boolean TRB
	type Date NBD
	type RecordDEP deplaf, deptfrneg, deptfrpos
	type RecordUTBLGLSC glsc
	type RecordPRODCTL prodctl
	
	// A null posting indicator signifies all current and prior deferred 
	// interest posting adjustments should be posted
	set POSTING = POSTING.get()
	
	do INIT

	if 'dep.exists() set dep = Db.getRecord("DEP", "CID=:CID")
	
	if dep.mdt = %SystemDate quit		// Handled by rollover process
	   
	if dep.stat = 4 quit			// Account closed

	do CIDINIT(.dep, .glsc, .prodctl, .deptfrpos, .deptfrneg, .deplaf, .ln)

	/*
	Post deferred interest for all current and past dates 
	(according to POSTING indicator) first... applicable with 
	positive/negative only (excluding segmented accounts)
	*/
	if dep.definadj, POSTING < 2 do {
		type public Number TBWA, TNEGINT, TPOSINT, TRESINT
		
		type Number POSTDEF

		set (TBWA, TNEGINT, TPOSINT, TRESINT) = 0

		type ResultSet rs = Db.select("INP", "DEFINP", "CID=:CID AND INP NOT>:%SystemDate")

		while rs.next() do {
			// Post only deferred interest for POSTING type
			if 'POSTING.isNull() do { quit
				do EXEC(.dep, .deptfrpos, .deplaf, .deptfrneg, .ln, .glsc, .prodctl, POSTING, 1, rs.getCol("INP"))
				if ER do EXC set ER = 0
				}

			// POSTING is null - post pos / neg deferred interest
			for POSTDEF = 0, 1 do {
				do EXEC(.dep, .deptfrpos, .deplaf, .deptfrneg, .ln, .glsc, .prodctl, POSTDEF, 1, rs.getCol("INP"))
				if ER do EXC set ER = 0
				}
			}
		}

	do EXEC(.dep, .deptfrpos, .deplaf, .deptfrneg, .ln, .glsc, .prodctl, POSTING, 1) quit:ER

	if 'dep.segflg do BUMPINP(.dep, 1)

	do BUMPCHK(.dep)

	quit


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
 type public Number vMONID,vMONCNT
 type public String %FN
 set vMONID=$$INIT^JOBMON($G(%FN)_"#"_"BCHINTPOST"),vMONCNT=0
	type public Boolean ER
	type public Number schjob, BRCD, TSCRCID, TSDRCID

	do SOURCE^BCHSOURC("INT","INT", .%UserID, .BRCD, .%UserClass, .TSDRCID, .TSCRCID)
	if ER set %BatchExit = 1 quit

	set schjob = %ProcessID

	
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
 type public Number vMONID,vMONCNT
 type public String %FN
 do CLOSE^JOBMON(vMONID,vMONCNT)
	type public Number BRCD

	do OFFSET^TTXBLD(%SystemDate, BRCD, %UserID, "INTPOST")

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
