TGLMON	
	/*
	Procedure Definition: TGLMON

	ORIG: MATTSON - 03/20/2002
	DESC: Transaction Summary Monitor
 
	---- Revision History -------------------------------------------------

	08/22/07 - NATRAJAH - CR 28578
		   Modified dtx section to pass dtx.tseq instead of dtx.seq to 
		   EVENTTQ^EVENTMON call, since third argument of 
		   EVENTTQ^EVENTMON should refer History sequence number.
		   
	08/06/07 - KinI - CR 28043
		   . Modified dtx section by adding an error catch block and
		   the error logging capability. 
		   . Modified DTX section to 1) set the new DTX.ACCUMER flag 
		   to Y if the error is generated in dtx section during DTX 
		   record movement to DTJ or DMJ; 2) to delete DTX record after 
		   successful movement to DTJ or DMJ; 3) to reset DTXPID.PTR to
		   zero in in case of error so any subsequent run will pick up 
		   all outstanding DTX.SEQ. 
		   . Modified EXT section to display the new error message when 
		   the error is generated by @TGLACCUM. 
		   . Modified RESET section to remove select from DTX to avoid 
		   unique constraint violation Oracle error on DTXHWM save when 
		   rerunning TGLACCUM for the date when all DTX records have 
		   been deleted. It would quit from RESET not deleting DTXHWM
		   and during TGLACCUM rerun, it would attempt to save DTXHWM 
		   record for the same date. Also removed DTJ and DMJ deleting 
		   as DTX is now deleted and there would be no way to restore 
		   DTJ/DMJ. This matches the lower versions logic.
		   
	02/01/07 - KumarSS - CR 25104
		   Removed Invalid Unicode Characters.

	06/16/06 - DESHPANDE S K - CR 20748
		   Used .Copy() method instead of manual field copy in dtx() 
		   function. Replaced dtx.tefd with dtx.efd and dtx.ptype with 
		   dtx.type.
		   	
	05/15/06 - RussellDS - CR21296
		   Changed to use cache array instead of %CACHE, which is
		   reserved for PSL record objects.
		   
		   Corrected PSL warning issues.
	
	04/19/06 - RussellDS - CR20209
		   Remove code related to obsoleted Mutual Funds/Securities,
		   including obsoleted columns from DMJ, DTJ, and DTX.

	04/24/06 - KELLYP - CR 20900
		   Modified DMJ section to pass TIM variable to RGLSUM.  This
		   prevents an undefined error on the tim variable within 
		   RGLSUM that was preventing accumulations from running properly.

	04/11/06 - KELLYP - CR 20232
		   Modified entire procedure to remove references to CUVAR.GLCC 
		   which has been obsoleted.  The system will always operate as 
		   if CUVAR.GLCC="Y" (cost center reporting enabled).

	03/10/06 - KELLYP - CR 19758
		   . Modified TTL section to put ttl object column sets on 
		   different lines.  The sets being on the same lines caused 
		   problems and the columns were never updated.  
		   
		   . Modified the SUM section to set dtxhwm.restart=0 instead 
		   of "" and to reset dtxhwm=NEWHWM since NEWHWM is reset 
		   halfway through SUM and is used in the DTJ and DMJ sections.  
		   This corrects problems with invalid/corrupt dtxhwm records 
		   causing double-postings to TTL.
		   
		   . Modified entire procedure to use distinct object names
		   within each label (same names were used repeatedly in
		   some labels).
	
	05/22/05 - Erik Scheetz - 15677
		   Modified top section to register the monitor process in 
		   the PROCESSID table.  
		   
		   Modified MSG section to issue a CTRL interrupt when 
		   adding a control message to the TGLMON table.
	
		   Modified STOP section to issue a STOP interrupt when 
		   stopping the TGL monitor.
		   
        	   Modified CTL section to use interrupt mechanism when
        	   checking to stop rather than polling the TGLMON table.
        	   When monitor process is interrupted %INTRPT will be set 
        	   with the neccessary action to be taken.
        	   
        	   Replaced tstart commands with Runtime.start methods with the
        	   "CS" qualifier.
	
	03/25/05 - Hillanbrand 
	           Modified DTJ and DMJ subsection to select DATETIME<=:NEWHWM
	           since there is a chance that the NEWWHM is the same in these
	           sections from when NEWWHM is set in the SUM section.

	02/03/05 - Kini - CR13991
		   . Modified INIT section to eliminate unneeded components 
		     from %CACHE and obtain correct GLDI component from 
		     STBLGLDESCD and STBLGLDESCL tables since these were 
		     restructured to comply with DBI standards.
		   . Modified dtx section to reference new dtx.summ sub-fields
		     and removed CC from copying dtx record to dmj as they have
		     the same CC column now.
		   . Modified SUM section: eliminated quit after RESET section
		     call to continue processing.
		   . Removed SPD resetting from INIT section. Otherwise, if the 
		     date of accumulation was requested in the past, it 
		     wouldn't be available for the processing. Modified the top
		     section to pass %SystemDate to SUM section instead of 
		     undefined in this case SPD.
		   . Modified dtj and DMJ sections to pass CLS,CID,DATETIME,GRP
		     and SPD to SUMDTJ^RGLSUM and CID and "M" class to 
		     SUMDMJ^RGLSUM.	
		   . Modified DTX section to set PTR to zero in case there is 
		     no data in DTXPID table.
		   . Modified EXT section to display 'Process complete' message.
		   . Added NEWHWM resetting in SUM section before DTJ and DMJ 
		     tags call since these sections expect the newest datetime 
		     stamp to be used in where clause when selecting data from 
		     DTJ and DMJ tables.
		   . Modified dtx section to correct columns setting that are
		     different between DTX and DTJ/DMJ files.
		   . Modified CTLMSG and the top section to pass %SystemDate as
		     an argument for CTLMSG section.
		     
	02/01/05 - SmithCD - CR13661
		   . Replaced CID reference with dtj.cid to fix undefined 
		     error in ACCTTOEVENTS Db.select statement and call to 
		     EVENTTQ^EVENTMON in section dtx
		   . Fixed infinite loop situation in SUM section that 
		     occurred when called from BCHRGLXFR (when SUM called 
		     from MAIN for TGL monitor it should be under a for loop, 
		     but when called from the EOD section for dayend G/L 
		     transfer it should not be within the for loop)
		   . Fixed potential undefined error on trc by replacing 
		     with TRC in scan section
		   . Labeled several tags as public that are called 
		     externally
		   . Cleaned up compiler warnings and modified to conform to 
		     current standards
		   . Removed old revision history
  
	12/29/03 - CARROLLJ - CR7901
	           Corrected precedence errors.

	 */

	type public String TGLMON
	type Date SPD
	type Boolean ACCUMER=false

	// Locking is used to ensure only one TGLMON process is running
	lock +TGLMON:5 else  quit

	type RecordTGLMONPA tglmonpa=Db.getRecord("TGLMONPA","PA='PA'",1)

	set tglmonpa.pid=$$DECHEX^%ZHEX(%ProcessID)
	do tglmonpa.bypassSave()
	
	// Register M process
	do REGISTER^IPCMGR("MONITOR","TGLMON")

	do INIT
	
	catch vERROR {
		lock -TGLMON

		type String ET,RM
		set ET=vERROR.type
 
		if ET["%GTM-" do ZE^UTLERR quit
		set ET=ET_"-"_vERROR.thrownAt
		set RM=vERROR.description
		do ^UTLERR
		}

	/* The following loop will terminate only in the event a STOP message
	is received by the monitor in subroutine CTLMSG in which case the
	monitor will HALT. Note that the call to CTLMSG May result in a 
	change to the value of SPD (system processing date) if the date of the 
	system has been advanced.
	*/
	
	/* Note that the monitor hangs 5 seconds between accumulations.
	This prevents the process from "spinning" if there is no
	activity to be accumulated and provides a clean boundary
	between the old and the new high water marks.
	*/

	for  do SUM(%SystemDate,.ACCUMER),CTLMSG(%SystemDate) hang 5
	
	quit


SUM(Date SPD,		// System Processing Date
    Boolean ACCUMER)	// DTJ/DMJ Accumulation Error	/REF:RW

	// Summarize DTX
	
	type public Boolean ER
	type public String TGL()
	
	type Number NEWHWM,OLDHWM
	type Boolean RESTART

	type RecordDTXHWM dtxhwm=Db.getRecord("DTXHWM","SPD=:SPD",1)

	set OLDHWM=dtxhwm.hwm
	if OLDHWM="" set OLDHWM=0
	set NEWHWM=$$TIM($H)
	
	/* Compare the old (OLDHWM) and new (NEWHWM) high water mark
	timestamps.  If NEWHWM<OLDHWM, the system clock	time was
	reset; set the RESTART flag to force a re-accumulation.
	Otherwise, if the monitor was abnormally terminated during
	the process of accumulating either DTJ or DMJ (the RESTART
	flag will be set), re-accumulate all of the activity for
	the day.
	*/		

	if NEWHWM<OLDHWM set RESTART=1
	else  set RESTART=dtxhwm.restart

	if RESTART do {
		do RESET(SPD)
		
		/*
		 If we restart we want to reaccumulate all of the day's
		 activities so OLDHWM is reset to 0 to ensure that all
		 all DTJ/DMJ records from today are processed.  Also,
		 the RESET section deletes the DTXHWM table for SPD, so
		 we need to reset the mode to "create".
		*/ 
		set OLDHWM=0
		do dtxhwm.setMode(0)
		}

	set dtxhwm.restart=1
	set dtxhwm.hwm=NEWHWM
	do dtxhwm.save()
	
	do dtxhwm.setMode(1)

	// Lock required by RGLSUM
	lock +TGL(SPD)

	do DTX(SPD,.ACCUMER)
	
	// Reset NEWHWM since select from DTJ/DMJ files will be based on
	// NEWHWM and DATETIME comparison.

	set NEWHWM=$$TIM($H)
	
	if OLDHWM="" set OLDHWM=0   // for Oracle select specifics
	
	do DTJ(SPD,OLDHWM,NEWHWM)
	do DMJ(SPD,OLDHWM,NEWHWM)

	lock -TGL(SPD)

	set dtxhwm.hwm=NEWHWM
		
	do dtxhwm.save()

	quit


DTX(Date SPD,		// System Processing Date
    Boolean ACCUMER)	// DTJ/DMJ Accumulation Error	/REF:RW

	/*
	Copy table DTX to tables DTJ and DMJ
	
	This subroutine is primarily responsible for copying DTX records
	into either DTJ or DMJ.
	*/
	
	type Number DTXCNT,PID,PTR,QUIT,SEQ,TIM

	type ResultSet rs1 = Db.select("DISTINCT PID","DTX","SPD=:SPD")

	while rs1.next() do {
		set PID = rs1.getCol("PID")

		type RecordDTXPID dtxpid = Db.getRecord("DTXPID","SPD=:SPD,PID=:PID",1)

		// Last sequence copied to DTX/DMJ
		set PTR=dtxpid.ptr
		
		/* In a case there is no info in DTXPID table, set PTR to 0 to 
		   get a return from DTX table. If PTR is null, no DTX records  
		   will be returned. 
		*/
		if PTR.isNull() set PTR = 0
		
		type ResultSet rs2 = Db.select("SEQ","DTX","SPD=:SPD AND PID=:PID AND SEQ>:PTR")

		if rs2.isEmpty() quit

		/*
		Hang one second between each PID (process ID) to ensure
		the access keys are unique in DTJ/DMJ.  To improve the
		system performance, updates are committed in blocks of
		100 records.
		*/

		hang 1

		set QUIT=0
		for  do { quit:QUIT
			set TIM=$$TIM
			
			do Runtime.start("CS")

			for DTXCNT=1:1:100 do { quit:QUIT

				if rs2.next() do {
					set SEQ = rs2.getCol("SEQ")
					
					type RecordDTX dtx=Db.getRecord("DTX","SPD=:SPD,PID=:PID,SEQ=:SEQ")					
					
					do dtx(.dtx,TIM,.ACCUMER)

					// If error occurs during DTJ/DMJ movement, set error indicator in DTX
					// to avoid repeated error logging if TGLACCUM is rerun.
					if dtx.isChanged("ACCUMER") do dtx.bypassSave()
					
					// Only when DTJ/DMJ movement completes fine, delete DTX
					if 'dtx.accumer do Db.delete("DTX", "SPD=:SPD AND PID=:PID AND SEQ=:SEQ")
					}

				else  set QUIT=1
				}

			if ACCUMER=false set dtxpid.ptr=SEQ
			else  set dtxpid.ptr=0
			
			do dtxpid.bypassSave()

			do Runtime.commit()
			}
		}

	do dmjec(SPD)
	
	quit


dtx(RecordDTX dtx,		// Teller Transaction Record
    Number TIM,			// Date/Time Stamp
    Boolean ACCUMER)		// DTJ/DMJ Accumulation Error Indicator	/REF:RW

	// Copy DTX record to DTJ or DMJ

	type public String RM
	
	do Runtime.start("CS",,"TGLACCUM")
	
	/*
	If an error is generated in this section (for example, by DTJ/DMJ 
	filers), it will be logged in DAYENDEXC or SCAER but only when it 
	occurs the first time TGLACCUM is executed for a given date and 
	dtx.accumer flag is still false.
	This is done to avoid repetitive error logging if TGLACCUM is rerun 
	multiple times for a given date or when the monitor is running and 
	recycling over erroneous record. 
	
	If an error occurs, it sets ACCUMER ("procedure-level" error 
	indicator) to true in order to return the message about the error to 
	a user. Also it sets dtx.accumer to true to mark DTX record as the one 
	that can't be deleted until the error is corrected and to indicate 
	that the same error doesn't need to be logged again.
	*/
	catch error {
		set ACCUMER=true
			
		if 'dtx.accumer do {
			type String ET
			
			do Runtime.rollback()
		
			if error.type.isLike("%%PSL-%") do {
				type String SOURCE = "  ("_error.type_" - "_error.context_", "_error.thrownAt_")"
				set RM = error.description_SOURCE
				}
			else  do ZE^UTLERR

			// Accumulate G/L Summary Totals
			do LOG^UTLEXC(%RoutineName, %SystemDate.toString(), $$^MSG(4651), dtx.cid, "", $select('ET.get().isNull():ET,1:RM.get()))
			
			set ER=0
				
			// dtx.isChanged() check in DTX section relies on setAuditFlag()
			do dtx.setAuditFlag(1)
			set dtx.accumer=true
			}
		}
			
	if dtx.jnlid="DTJ" do {

		type RecordDTJ dtj=Class.new("RecordDTJ")
		set dtj=dtx.copy()
		
		set dtj.tjd=dtx.spd
		set dtj.datetime=TIM
		set dtj.cid=dtx.cid
		// Set transaction sequence that corresponds to the HIST.TSEQ
		set dtj.tseq=dtx.tseq
		// Adjust SUMM column since dtx.summ and dtj.summ structure differ
		set dtj.summ=dtx.cc_"#"_dtx.type_"#"_dtx.glsc
	
		do dtj.save()

		// If the account subscribes to any transaction
		// events, log into transaction event queue.
	
		type ResultSet rs=Db.select("EVENTSEQ","ACCTTOEVENTS","CID=:dtj.cid")

		if rs.isEmpty() quit
		
		do EVENTTQ^EVENTMON("A",dtj.cid,dtx.tseq)
		}

	if dtx.jnlid="DMJ" do {

		type RecordDMJ dmj=Class.new("RecordDMJ")
		set dmj=dtx.copy()
		
		// Unable to use "copy" method here, since SUMM column doesn't 
		// exist in DMJ record.
		set dmj.tjd=dtx.spd
		set dmj.datetime=TIM
		set dmj.cid=dtx.cid
		// Set system-assigned sequential number
		set dmj.tseq=dtx.seq
		
		do dmj.save()

		do dmjxr(.dmj)
		}

	do Runtime.commit()

	quit


dmjxr(RecordDMJ dmj)		// Daily Tran Journal Object

	/* Create DMJ cross-reference files
	
	This subroutine creates an entry in either of the following cross
	reference files:
	
		DMJEC - miscellaneous error correct transactions
		DMJXR - miscellaneous non error correct transactions

	These x-ref files are used to match error correct transactions
	(in DMJEC) to the transaction being error corrected (in DMJXR)
	so the error correct indicator of ITC can be turned on for the
	original transaction in DMJ.
	*/

	if dmj.itc6 do {
		type RecordDMJEC dmjec=Class.new("RecordDMJEC")
 
		set dmjec.spd=dmj.tjd
		set dmjec.brcd=dmj.brcd
		set dmjec.uid=dmj.uid
		set dmjec.cid=dmj.cid
		set dmjec.datetime=dmj.datetime
		set dmjec.tseq=dmj.tseq

		do dmjec.save()
		}

	else  do {
		type RecordDMJXR dmjxr=Class.new("RecordDMJXR")
 
		set dmjxr.spd=dmj.tjd
		set dmjxr.brcd=dmj.brcd
		set dmjxr.uid=dmj.uid
		set dmjxr.cid=dmj.cid
		set dmjxr.datetime=dmj.datetime
		set dmjxr.tseq=dmj.tseq

		do dmjxr.save()
		}

	quit 


dmjec(Date SPD)		// System Processing Date

	// Update DMJ.ITC if record was error corrected

	type Number BRCD,CID,SEQ,TIM,UID

	type ResultSet rs=Db.select("BRCD,UID,CID,DATETIME,TSEQ","DMJEC","SPD=:SPD")

	while rs.next() do {
		set BRCD=rs.getCol("BRCD")
		set UID=rs.getCol("UID")
		set CID=rs.getCol("CID")
		set TIM=rs.getCol("DATETIME")
		set SEQ=rs.getCol("TSEQ")

		do scan(SPD,BRCD,UID,CID,TIM,SEQ)
		}

	quit 

	
scan(Date SPD,			// System Processing Date
     Number BRCD,		// Branch Code
     Number UID,		// User ID	
     Number CID,		// Account Number
     Number TIM1,		// Date/Time Stamp
     Number SEQ1)		// Sequence
     
	// Scan DMJ

	type Number SEQ2,TIM2,TRC

	type RecordDMJ dmj1=Db.getRecord("DMJ","TJD=:SPD,DATETIME=:TIM1,CID=:CID,TSEQ=:SEQ1")

	type ResultSet rs=Db.select("DATETIME,TSEQ","DMJXR","SPD=:SPD AND BRCD=:BRCD AND UID=:UID AND CID=:CID","DATETIME DESC")

	while rs.next() do {
		set TIM2=rs.getCol("DATETIME")
		set SEQ2=rs.getCol("TSEQ")

		type RecordDMJ dmj2=Db.getRecord("DMJ","TJD=:SPD,DATETIME=:TIM2,CID=:CID,TSEQ=:SEQ2")

		if dmj1.cc'=dmj2.cc quit 
		if dmj1.etc'=dmj2.etc quit 
		if dmj1.efd'=dmj2.efd quit 
		if dmj1.tamt+dmj2.tamt quit 
		if dmj1.crcd'=dmj2.crcd quit
		if +dmj1.itc7'=(+dmj2.itc7) quit 

		set TRC=$$FIELD^UTSO(dmj1.tso,"EC")
		if TRC,dmj2.trc'=TRC quit 

		set dmj2.itc=$$ITC^TTXEXT(dmj2.itc,6)
		do dmj2.bypassSave()

		do Db.fastDelete("DMJEC","SPD=:SPD,BRCD=:BRCD,UID=:UID,CID=:CID,DATETIME=:TIM1,TSEQ=:SEQ1")
		do Db.fastDelete("DMJXR","SPD=:SPD,BRCD=:BRCD,UID=:UID,CID=:CID,DATETIME=:TIM2,TSEQ=:SEQ2")
		}

	quit 


DTJ(Date SPD,			// System Processing Date
    Number OLDHWM,		// Old High Water Mark		
    Number NEWHWM)		// New High Water Mark		

	/* This subroutine accumulates information contained in the daily
	transaction journal file (DTJ) into a G/L summary file (TGL).
	*/

	type Number CID,SEQ,TIM
	type String PRODCTL

	type ResultSet rs = Db.select("DATETIME,CID,TSEQ","DTJ","TJD=:SPD AND DATETIME>:OLDHWM AND DATETIME<=:NEWHWM")

	while rs.next() do {

		catch vERROR {
			type String ET,RM
			set ET=vERROR.type
 
			if ET["%GTM-" do ZE^UTLERR quit
			set ET=ET_"-"_vERROR.thrownAt
			set RM=vERROR.description
			do ^UTLERR
			}

		set TIM = rs.getCol("DATETIME")
		set CID = rs.getCol("CID")
		set SEQ = rs.getCol("TSEQ")

		type RecordDTJ dtj = Db.getRecord("DTJ","TJD=:SPD,DATETIME=:TIM,CID=:CID,TSEQ=:SEQ")

		if dtj.itc.isNull() quit
		if dtj.etc.isNull() quit

		do Runtime.start("CS")
		
		do dtj(.dtj,.PRODCTL,SPD)
		
		do Runtime.commit()
		}

	quit 


dtj(RecordDTJ dtj,		// Daily Tran Journal Object	
    String PRODCTL(),		// Product Info			
    Date SPD)			// System Processing Date
    
	// Process Daily Transaction Journal record

	type Number CID,DATETIME,NOSTRO,TSEQ,TYPE
	type String CLS,GRP

	set CID=dtj.cid
	set TSEQ=dtj.tseq
	set TYPE=dtj.type
	set DATETIME=dtj.datetime

	if 'PRODCTL(TYPE).exists() do PRODCTL(TYPE,.PRODCTL)
	set NOSTRO=PRODCTL(TYPE).piece("|",3)
	
	set CLS=PRODCTL(TYPE).piece("|",1)
	set GRP=PRODCTL(TYPE).piece("|",2)

	do SUMDTJ^RGLSUM(.dtj,CLS,CID,DATETIME,GRP,SPD)
	
	do TTL(.dtj,.PRODCTL)
	
	do ERA(.dtj,.PRODCTL)
	
	quit 


DMJ(Date SPD,			// System Processing Date
    Number OLDHWM,		// Old High Water Mark		
    Number NEWHWM)		// New High Water Mark		
	
	/* This subroutine accumulates information contained in the daily
	miscellaneous journal file (DMJ) into a G/L summary file (TGL).
	*/

	type public Number CID,SEQ,TIM

	type ResultSet rs = Db.select("DATETIME,CID,TSEQ","DMJ","TJD=:SPD AND DATETIME>:OLDHWM AND DATETIME<=:NEWHWM")

	while rs.next() do {

		catch vERROR {
			type String ET,RM
			set ET=vERROR.type
 
			if ET["%GTM-" do ZE^UTLERR quit
			set ET=ET_"-"_vERROR.thrownAt
			set RM=vERROR.description
			do ^UTLERR
			}

		set TIM = rs.getCol("DATETIME")
		set CID = rs.getCol("CID")
		set SEQ = rs.getCol("TSEQ")

		type RecordDMJ dmj = Db.getRecord("DMJ","TJD=:SPD,DATETIME=:TIM,CID=:CID,TSEQ=:SEQ")

		do Runtime.start("CS")
		
		do SUMDMJ^RGLSUM(.dmj,"M",CID,TIM,,SPD)
		
		do Runtime.commit()
		}

	quit


TTL(RecordDTJ dtj,		// Daily Tran Journal Object	
    String PRODCTL())		// Product Info			

	// Update system totals
	
	type public Date SPD

	type Number CC,TYPE
	type String CLS,CRCD,GLSC,GRP

	set CRCD=dtj.crcd
	set GLSC=dtj.glsc
	set TYPE=dtj.type
	set CC=dtj.cc

	if CRCD.isNull() set CRCD=%SystemCurrency
	set CLS=PRODCTL(TYPE).piece("|",1)
	set GRP=PRODCTL(TYPE).piece("|",2)

	type RecordTTL ttl=Db.getRecord("TTL","TJD=:SPD,CRCD=:CRCD,CLS=:CLS,GRP=:GRP,TYPE=:TYPE,GLSC=:GLSC,CC=:CC",1)

	if dtj.itc1 do {
		set ttl.crcnt=ttl.crcnt+1
		set ttl.cramt=ttl.cramt+dtj.prin
		}
	else  do {
		set ttl.drcnt=ttl.drcnt+1
		set ttl.dramt=ttl.dramt+dtj.prin
		}

	do ttl.save()

	quit 


ERA(RecordDTJ dtj,		// Daily Tran Journal Object	
    String PRODCTL())		// Product Info			
    
	// Excessive report amount
	
	type public Number CID

	type Number AMT,ERA,TYPE

	set AMT=dtj.tamt
	set TYPE=dtj.type

	if dtj.itc1 set ERA=PRODCTL(TYPE).piece("|",4)
	else  set ERA=PRODCTL(TYPE).piece("|",5)
	if 'ERA quit

	if AMT<0 set AMT=-AMT
	if AMT<ERA quit

	/* Exclude problem sub-accounts from DAYENDERA; excessive transaction
	amounts will be associated with 'parent' account.
	*/
	if PRODCTL(TYPE).piece("|",1)="L",$$PRBLN(CID) quit

	type RecordDAYENDERA dayend=Class.new("RecordDAYENDERA")

	set dayend.tjd=dtj.tjd
	set dayend.cid=dtj.cid
	set dayend.tseq=dtj.tseq
	set dayend.datetime=dtj.datetime
	
	do dayend.save()

	quit


public TIM(String TIM)		// Time ($HOROLOG format)

	// Converts a $HOROLOG formatted date/time into a numeric date and 
	// time stamp.	

	if TIM.get().isNull() set TIM=$h
	
	quit (TIM*1E5)+TIM.piece(",",2)


private CTLMSG(Date SPD)	// System Processing Date
	
	// Check control messages

	type Public String %INTRPT()
	type Number MSGSEQ
	type String CTLMSG

	if %INTRPT.data() > 1 do INTRPT^IPCMGR
	if %INTRPT.get() = "STOP" do {
		do Db.fastDelete("TGLMONPA","PA='PA'")
		do CLOSE^IPCMGR()
		halt
		}
	if %INTRPT.get() = "CTRL" do {
		type ResultSet rs=Db.select("MSGSEQ,CTLMSG","TGLMONMSG")
		
		while rs.next() do {
				set MSGSEQ=rs.getCol("MSGSEQ")
				set CTLMSG=rs.getCol("CTLMSG")
				do Db.fastDelete("TGLMONMSG","MSGSEQ=:MSGSEQ")
	
				if CTLMSG="STOP" do {
					do Db.fastDelete("TGLMONPA","PA='PA'")
					do CLOSE^IPCMGR()
					halt
					}
	
				#ACCEPT DATE=12/29/03;PGM=John Carroll;CR=7901
				xecute CTLMSG
				}
		}
		
	set %INTRPT = ""		
	/* If the system date has changed, issue a control message to re-init
	PROFILE system variables.  This will be executed the next time the
	control messages will be read, allowing one more pass to summarize
	information that may not have been accumumated before the date was
	bumped.
	*/

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
	
	if cuvar.tjd'=SPD do MSG("D INIT")

	quit


MSG(String CTLMSG,	// Control Message
    String RM)		// Error Message
    
	// Issue control message

	do Runtime.start("CS")

	type RecordTGLMONMSG tglmon = Class.new("RecordTGLMONMSG")

	set tglmon.msgseq = Db.nextVal("TGLMONMSG")
	set tglmon.ctlmsg = CTLMSG
	do tglmon.bypassSave()

	// ~p1 message issued to Transaction Summary Monitor
	set RM = $$^MSG(8365,CTLMSG)

	do Runtime.commit()

	// Send Interrupt to TGLMON Monitor
	type String sel()
	
	set sel("PRCTYP") = "MONITOR"
	set sel("SUBTYP") = "TGLMON"
	do ISSUE^IPCMGR("CTRL",,.sel)
	
	quit


INIT	
	/*
	Initialization
	
	RETURNS:
	     . %*	System driver variables
	     . cache	Process specific cached data
	     . GLTS	G/L transaction suspense acct
	     . GLEFD	G/L effective dated batch flag
	*/
	
	type public String cache
	type public Date SPD
	type public Boolean GLEFD
	type public Number GLTS

	type String STRING
	
	do SYSVAR^SCADRV0()

	type RecordCUVAR cuvar = Db.getRecord("CUVAR")

	set GLTS=cuvar.glts
	set GLEFD=cuvar.glefdbch

	type ResultSet rsd=Db.select("KEY,DESC,SDESC,GLDI","STBLGLDESCD")

	while rsd.next() do {
		set STRING.piece("|",1)=rsd.getCol("DESC")
		set STRING.piece("|",2)=rsd.getCol("SDESC")
		set STRING.piece("|",3)=rsd.getCol("GLDI")
			
		set cache("TGLMON", "GLDESC", "D", rsd.getCol("KEY")) = STRING
		}

	type ResultSet rsl=Db.select("KEY,DESC,SDESC,GLDI","STBLGLDESCL")

	while rsl.next() do {
		set STRING.piece("|",1)=rsl.getCol("DESC")
		set STRING.piece("|",2)=rsl.getCol("SDESC")
		set STRING.piece("|",3)=rsl.getCol("GLDI")
			
		set cache("TGLMON", "GLDESC", "L", rsl.getCol("KEY")) = STRING
		}

	type ResultSet rs=Db.select("CC,GLCO","UTBLCCNTR")
	while rs.next() set cache("TGLMON", "CO", rs.getCol("CC")) = rs.getCol("GLCO")

	type ResultSet rs2=Db.select("CO1,CO2,ICC","UTBLICC")
	while rs2.next() set cache("TGLMON", "ICC", rs2.getCol("CO1"), rs2.getCol("CO2")) = rs2.getCol("ICC")

	quit


PRODCTL(String TYPE,		// Product Type
	String PRODCTL())	// Product Array

	// Cache product information

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")

	set PRODCTL(TYPE).piece("|",1)=prodctl.cls 
	set PRODCTL(TYPE).piece("|",2)=prodctl.grp
	set PRODCTL(TYPE).piece("|",3)=prodctl.nostro
	set PRODCTL(TYPE).piece("|",4)=prodctl.eracr
	set PRODCTL(TYPE).piece("|",5)=prodctl.eradr

	quit 


RESET(Date SPD)		// System Processing Date

	// Re-initialize summary data

	type ResultSet rs1=Db.select("TJD","DTJ","TJD=:SPD")

	type ResultSet rs2=Db.select("TJD","DMJ","TJD=:SPD")

	// If the DTJ and DMJ result sets are empty (i.e., possibly purged), 
	// do not re-accumulate summary information.

	if rs1.isEmpty(),rs2.isEmpty() quit

	// The following tables are re-initialized (dropped) in the event a
	// re-accumulation is necessary.

	do Db.fastDelete("DMJXR","SPD=:SPD")
	do Db.fastDelete("DMJEC","SPD=:SPD")
	do Db.fastDelete("DTXHWM","SPD=:SPD")
	do Db.fastDelete("DTXPID","SPD=:SPD")

	do Db.fastDelete("DAYENDERA","TJD=:SPD")
	do Db.fastDelete("SYSBAL1","TDATE=:SPD")
	do Db.fastDelete("SYSBAL2","TDATE=:SPD")
	do Db.fastDelete("TGL","TJD=:SPD,SRC=1")
	do Db.fastDelete("TGL","TJD=:SPD,SRC=2")
	do Db.fastDelete("TGL","TJD=:SPD,SRC=9")

	// Re-initialize DR/CR information in TTL
	do TTLINI(SPD,1)

	quit


public	TTLINI(Date SPD,	// System Processing Date
	       Number OPT)	// TTL Initialization Option

	/* This subroutine initializes data in TTL.  It is called by
	RESET^TGLMON to re-initialize the debit/credit count and
	amount fields (opt=1).  It is also called by the accrual
	process (program ^RCHK) to initialize all fields in TTL
	EXCEPT the debit/credit count and amount fields.

	Additional notes on ARGUMENTS:
	     . OPT	0 = Initialize all fields except DR/CR cnt/amt
			1 = Initialize only DR/CR cnt/amt
	*/

	type Number CC,CRAMT,CRCNT,DRAMT,DRCNT
	type String CLS,CRCD,GLSC,GRP,TYPE

	type ResultSet rs=Db.select("CRCD,CLS,GRP,TYPE,GLSC,CC","TTL","TJD=:SPD")

	while rs.next() do {
		set CRCD=rs.getCol("CRCD")
		set CLS=rs.getCol("CLS")
		set GRP=rs.getCol("GRP")
		set TYPE=rs.getCol("TYPE")
		set GLSC=rs.getCol("GLSC")
		set CC=rs.getCol("CC")

		type RecordTTL ttl=Db.getRecord("TTL","TJD=:SPD,CRCD=:CRCD,CLS=:CLS,GRP=:GRP,TYPE=:TYPE,GLSC=:GLSC,CC=:CC")

		// Initialize columns CRCNT, CRAMT, DRCNT and DRAMT
		if OPT do {  quit
			set ttl.crcnt=""
			set ttl.cramt=""
			set ttl.drcnt=""
			set ttl.dramt=""
			do ttl.save()
			}

		// Initialize all columns except CRCNT, CRAMT, DRCNT and DRAMT
		else  do {
			set CRCNT=ttl.crcnt
			set CRAMT=ttl.cramt
			set DRCNT=ttl.drcnt
			set DRAMT=ttl.dramt

			do Db.delete("TTL","TJD=:SPD AND CRCD=:CRCD AND CLS=:CLS AND GRP=:GRP AND TYPE=:TYPE AND GLSC=:GLSC AND CC=:CC")

			type RecordTTL ttln=Class.new("RecordTTL")

			set ttln.tjd=SPD
			set ttln.crcd=CRCD
			set ttln.cls=CLS
			set ttln.grp=GRP
			set ttln.type=TYPE
			set ttln.glsc=GLSC
			set ttln.cc=CC

			set ttln.crcnt=CRCNT
			set ttln.cramt=CRAMT
			set ttln.drcnt=DRCNT
			set ttln.dramt=DRAMT
			do ttln.save()
			}
		}

	quit


public	START	// Start monitor

	type public String ER
	
	type String VFMQ

	// Monitor is already running
	if '$$pid.isNull() do Runtime.setErrMSG("TGLMONPA",8364) quit:ER

	do PRMT(1) quit:VFMQ="Q"
	do JOB

	quit


public	STOP	// Issue a stop message to PROFILE/IBS server(s)

	type public String ER,RM
	
	type String VFMQ

	// Monitor is not running
	if $$pid.isNull() do Runtime.setErrMSG("TGLMONPA",8366) quit:ER

	do PRMT(0) quit:VFMQ="Q" 
	
	// Interrupt TGLMON Monitor to stop 
	type String sel()
	
	set sel("PRCTYP") = "MONITOR"
	set sel("SUBTYP") = "TGLMON"
	do ISSUE^IPCMGR("STOP",,.sel)
		
	// ~p1 message issued to Transaction Summary Monitor
	set RM=$$^MSG(8365,"STOP")
	set ER = "W"
	
	
	quit


public	JOB	// External entry point to spawn monitor

	type public String ER,RM

	type String PRCNAM,X

	// Monitor is already running
	if '$$pid.isNull() do Runtime.setErrMSG("TGLMONPA",8364) quit:ER

	type RecordCUVAR cuvar
	set cuvar=Db.getRecord("CUVAR")

	set PRCNAM="TGLMON_"_cuvar.ptmdirid
	set X=$$^%ZJOB("^TGLMON","PRO="_PRCNAM,1)

	if X set RM(RM("").order(-1)+1)=$$^MSG(6800,PRCNAM)	//~p1 submitted
	else  set RM(RM("").order(-1)+1)=$$^MSG(6799,PRCNAM)	//~p1 not submitted
	set ER="W"

	quit 


pid()	// Return process ID

	type String PID

	if 'Db.isDefined("TGLMONPA","PA='PA'") quit ""

	type RecordTGLMONPA tglmonpa=Db.getRecord("TGLMONPA","PA='PA'")

	set PID=tglmonpa.pid if PID.isNull() quit ""
	if '$$VALID^%ZPID(PID,1) quit ""
	quit PID


PRMT(Number OPT)	// Option

	/*
	Prompts for startup/shutdown
	
	Additional notes on ARGUMENTS:
	     . OPT	0 = Stop
			1 = Start
	*/
	
	type public String VFMQ
	
	// If not interactive (e.g. run from script), assume CONTINUE="Y"
	if '$$INTRACT^%ZFUNC set VFMQ="F" quit

	type Boolean CONT
	type Number %PAGE,%PG
	type String %READ,%TAB(),OLNTB

	set %PG=1
	set %PAGE=1
	set %TAB("CONT")=".CONT2"

	set %READ="@@%FN,,,CONT/REQ"
	do ^UTLREAD if VFMQ="Q" quit 
	if 'CONT set VFMQ="Q"
	quit


public	EXT	// External accumulation (forces a re-accumulation)

	// Called by function TGLACCUM
	
	type public String RM,TGL()
	type public Boolean ER
	
	type Date XJD
	type Number %PG
	type String %READ,%TAB(),OLNTB,VFMQ
	type Boolean ACCUMER=false

	set %PG=1

	set %TAB("XJD")=".XJD1/MAX="_%SystemDate
	set %READ="@@%FN,,,XJD/REQ"
	do ^UTLREAD if VFMQ="Q" quit 

	lock +TGL(XJD):2
	// File locked by another user
	else  do Runtime.setErrMSG("TGL",1081) quit:ER

	do RESET(XJD)
	do EOD(XJD,.ACCUMER)
	do ^TTXGLA(XJD)

	lock -TGL(XJD)

	// Process completes with error(s). See Standard Exception Report.
	if ACCUMER=true do Runtime.setErrMSG("TGL",6242) quit:ER

	// Process complete
	do Runtime.setErrMSG("TGL",2237) quit:ER
	
	quit


public	EOD(Date SPD,		// System Processing Date
	    Boolean ACCUMER)	// DTJ/DMJ Accumulation Error Indicator	/REF:RW

	// End-of-day entry point
	// Called by EXT^TGLMON and BCHRGLXFR

	type Boolean GLEFD
	type Number GLTS
	type String ETC(),GL

	do INIT
	do SUM(SPD,.ACCUMER)
	do MTD^RGLSUM(SPD)
	
	quit


PRBLN(Number CID)	// Problem Account Status (ln.pcidstat)

	type RecordLN ln=Db.getRecord("LN","CID=:CID")

	quit ln.pcidstat

	
 #OPTION ResultClass ON
Public String vSIG()	quit "60864^24928^Hari Natrajan^28731"	// Signature - LTD^TIME^USER^SIZE
