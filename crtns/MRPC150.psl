MRPC150(String RETURN, Number VERSN,Date TPDATE, String UID, Number BRCD, String CRCD, String SEQ, String INPUT, Number CTL)
 /*
	Procedure ID: MRPC150
	ORIG: appleyam - 02/01/2007
	DESC: Denomination Tracking Functions RPC
 
         ARGUMENTS:
                . RETURN        Return value            /TYP=T/REQ/MECH=REFNAM:W
                . VERSN         Version number          /TYP=N/REQ/MECH=VAL
                . TPDATE        System Balancing Date   /TYP=D/REQ/MECH=VAL
                . UID           User ID                 /TYP=T/REQ/MECH=VAL
                . BRCD          Branch Code             /TYP=N/REQ/MECH=VAL
                . CRCD          Currency Code           /TYP=T/REQ/MECH=VAL
		. SEQ		Sequence		/TYP=N/NOREQ/MECH=VAL
		. INPUT		Input String to update file DENACTU
							/TYP=T/NOREQ/MECH=VAL
		. CTL		Report control Flag	/TYP=T/REQ/MECH=VAL
 					0 = Denomination Entry Cash Count Comparison
 					1 = Branch/Teller Cash Report
 					2 = Cash Transaction by Denomination report
 					3 = Update file DENACTU
 
         RETURNS:
                . $$     Error Message                  /TYP=T
                  Null= No Error
 
                . RETURN                                /TYP=T

                  RETURN
                        Columns in each record are tab-delimited ($C(9))
                        Records are delimted by CRLF ($C(13,10))
 		CTL = 0
                  - BRCD        Branch Code
                  - UID		User ID
                  - CRCD    	Currency Code
                  - DENOMDESC	Denomination Description
                  - DENOMCNT    Denomination Count
                  - DENOMVAL    Denomination Value
                  - CASHVAL	Cash Count Value
                  - DIFF	Denomination Value - Cash Count Value

		CTL = 1
                  - BRCD        Branch Code
                  - UID		User ID
                  - CRCD    	Currency Code
                  - DENOMDESC	Denomination Description
                  - MIN		Minimum Count - User or Userclass limit
                  - MAX		Maximum Count - User of Userclass limit
                  - CIRC	Circulating Count
                  - MUTIL    	Mutilated Count
                  - TOTAL	Total Count
                  - OVERSHORT	Difference of Total vs. Min or Max

		CTL = 2
                  - BRCD        Branch Code
                  - UID		User ID
                  - CRCD    	Currency Code
		  - TSEQ	Transaction Sequence
		  - ETC		Transaction Code
		  - TAMT	Transaction Amount
		  - DESCR	Denomination Description
		  - CNT		Circulating Count
		  - MUTIL	Mutilated Count
		  - MULT	Denomination multiplier		  
         EXAMPLE:
 
                set UID=1
                set BRCD=0
                set CRCD="USD"
                set TPDATE=^CUVAR(2)
		set CTL="0"
                set X=$$^MRPC150(.R,1,TPDATE,UID,BRCD,CRCD,CTL)
 
	---- Comments --------------------------------------------------------
 
	---- Revision History ------------------------------------------------

	07/06/07 - APPLEYARDM - CR 28056
	   Modified section PROC for Denomination Entry Cash Count Comparison reporting
	   (CTL = 0) to correctly calculate and report summary values for mutilated, 
	   strapped, and rolled coin denominations

	02/02/07 - APPLEYARDM - CR 25302
	   Created MRPC


 */

	type public Boolean ER
	type Boolean ERV
	type public String ET,RM
 	type String ERRMSG
 
	set (ER,ERV)=0
	set (ERRMSG,RM)=""
	set RETURN=""
 
	do PROC(VERSN.get(),TPDATE.get(),UID.get(),BRCD.get(),CRCD.get(),SEQ.get(),INPUT.get(),CTL.get())
 
	if ERV set ER=1,RM=ERRMSG
 
	if ER quit $$ERRMSG^PBSUTL(RM)
 
	// Build return value
	set RETURN=$$V2LV^MSG(.RETURN)
 
	quit ""

public PROC(Number VERSN, Date TPDATE, String UID, Number BRCD, String CRCD, String TSEQ, String INPUT, Number CTL)

 /*         ARGUMENTS:
                . RETURN        Return value            /TYP=T/REQ/MECH=REFNAM:W
                . VERSN         Version number          /TYP=N/REQ/MECH=VAL
                . TPDATE        System Blancing Date    /TYP=D/REQ/MECH=VAL
                . UID           User ID                 /TYP=T/REQ/MECH=VAL
                . BRCD          Branch Code             /TYP=T/REQ/MECH=VAL
                . CRCD          Currency Code           /TYP=T/REQ/MECH=VAL
		. TSEQ		Sequence		/TYP=T/NOREQ/MECH=VAL
		. INPUT		Input String to update file DENACTU
							/TYP=T/NOREQ/MECH=VAL
		. CTL		Report control Flag	/TYP=T/REQ/MECH=VAL
 					0 = Denomination Entry Cash Count Comparison
 					1 = Branch/Teller Cash Report
 					2 = Cash Transaction by Denomination report
 					3 = Update file DENACTU
        RETURNS 
                . RETURN        Return value            /TYP=T/REQ/MECH=REFNAM:W
 
 */
 	type public Boolean ER,ERV
	type public String ERRMSG,ET,RETURN,RM
	type String FROM
 
 	type Boolean FLG,MLTCUR,MLTUSR
	type Number BRMAX,BRMIN,BRSUM,BRTOTAL,CIRC,CRCDTOTAL,CSEQ,MAX,MIN,MULT,MUTIL,MUTILDIFF
	type Number OVERMAX,OVERMIN,OVERSHORT,OVERSUM,OVERTOTAL,TOTAL
	type String BRLIM,CASH,CRLF,DENACTU,DENOM,DESCR,LASTCRCD,LASTUSER,OVERLIM,UCLIM,URLIM,REC,UCLS,%
	type String CASH(,,),DENOM(,),DENACTU(,,,),UCLIM(,),URLIM(,)

	set (REC,RETURN)=""
	set %=$C(9)
	set CRLF=$C(10,13)

	// Version number of client message is not compatible with server
	if VERSN'=1 do Runtime.setErrMSG("MSG","2951") quit:ER
 
	// 1308 - Invalid date ~p1
	if $$^SCAJD(TPDATE)=-1 do Runtime.setErrMSG("MSG","1308",TPDATE) quit:ER
 
	// Denomination entry Cash Count Comparison
	if CTL=0 do {

		do FILLDEN(CRCD.get(),.DENOM)
		
		do FILLCASH(UID.get(),CRCD.get(),BRCD.get(),TPDATE.get(),.CASH)
		
		do FILLDENAC(UID.get(),BRCD.get(),.DENACTU)

		type Number TOTDENOM,TOTCASH,TOTDIFF
		type Number CASHVAL,DENOMCNT,DENOMVAL,DIFF,DMUTCNT,DMUTVAL,MULT,ROLLED,ROLLEDDIFF,STRAP,STRAPDIFF
		type Number DROLLVAL,DSTRPVAL,STRPROLL
		type String DESCR,LINK
		set (BRCD,UID,CRCD,CSEQ)=""
		for  set BRCD=DENACTU(BRCD).order() quit:BRCD=""  do {
			for  set UID=DENACTU(BRCD,UID).order() quit:UID=""  do {
				for  set CRCD=DENACTU(BRCD,UID,CRCD).order() quit:CRCD=""  do {
					set TOTDENOM=0
					set TOTCASH=0
					set TOTDIFF=0
					set DMUTVAL=0
					set DROLLVAL=0
					set DSTRPVAL=0
					for  set CSEQ=DENACTU(BRCD,UID,CRCD,CSEQ).order() quit:CSEQ=""  do {
						set STRPROLL=0
						set DESCR=DENOM(CRCD,CSEQ).piece("|",1)
						set MULT=DENOM(CRCD,CSEQ).piece("|",2)
						set LINK=DENOM(CRCD,CSEQ).piece("|",3)
						if LINK.get()="" set CASHVAL=0
						else  set CASHVAL=CASH(UID,CRCD,LINK)*MULT

						set DENOMCNT=DENACTU(BRCD,UID,CRCD,CSEQ).piece("|",1)
						set DENOMVAL=DENOMCNT*MULT
						set DMUTCNT=DENACTU(BRCD,UID,CRCD,CSEQ).piece("|",2)
						set DMUTVAL=DMUTVAL+(DMUTCNT*MULT)
						// Strapped
						if DENOM(CRCD,CSEQ).piece("|",4)=1 do {
							set DSTRPVAL=DSTRPVAL+(DENOMCNT*MULT)
							set STRPROLL=1
						}
						// Rolled
						if DENOM(CRCD,CSEQ).piece("|",5)=1 do {
							set DROLLVAL=DROLLVAL+(DENOMCNT*MULT)
							set STRPROLL=1
						}
						set TOTDENOM=TOTDENOM+DENOMVAL+(DMUTCNT*MULT)
						set TOTCASH=TOTCASH+CASHVAL
						set DIFF=DENOMVAL-CASHVAL
						// ONLY CALCULATE TOTDIFF IF NOT STRAPPED OR ROLLED 
						if STRPROLL=0 do {
							set TOTDIFF=TOTDIFF+DIFF
							set REC=REC_CRLF_UID_%_CRCD_%_DESCR_%_DENOMCNT_%_DENOMVAL_%_CASHVAL_%_DIFF
						}
						else  set REC=REC_CRLF_UID_%_CRCD_%_DESCR_%_DENOMCNT_%_DENOMVAL_%_%_DIFF
					}
					// Add rows for Mutilated, Strapped and Rolled
					set MUTIL=CASH(UID,CRCD,"MUTIL")
					set MUTILDIFF=DMUTVAL-MUTIL
					set ROLLED=CASH(UID,CRCD,"ROLLED")
					set ROLLEDDIFF=DROLLVAL-ROLLED
					set STRAP=CASH(UID,CRCD,"STRAP")
					set STRAPDIFF=DSTRPVAL-STRAP
					set TOTCASH=TOTCASH+MUTIL+ROLLED+STRAP
					set TOTDIFF=TOTDIFF+MUTILDIFF+ROLLEDDIFF+STRAPDIFF
					set REC=REC_CRLF_UID_%_CRCD_%_"Mutilated"_%_%_DMUTVAL_%_MUTIL_%_MUTILDIFF
					set REC=REC_CRLF_UID_%_CRCD_%_"Rolled"_%_%_DROLLVAL_%_ROLLED_%_ROLLEDDIFF
					set REC=REC_CRLF_UID_%_CRCD_%_"Strap"_%_%_DSTRPVAL_%_STRAP_%_STRAPDIFF
					set REC=REC_CRLF_UID_%_CRCD_%_"TOTAL"_%_%_TOTDENOM_%_TOTCASH_%_TOTDIFF
				}
			}
		}
		// Strip off leading CRLF
		set RETURN=REC.extract(2,REC.length())
	}

	if CTL=1 do {
		if CRCD.get()="*" set MLTCUR=1
		else  set MLTCUR=0
		if UID.get()="*" set MLTUSR=1
		else  set MLTUSR=0

		// Fill DENOM array
		do FILLDEN(CRCD.get(),.DENOM)
		// Fill DENACTU array
		do FLBRDEN(BRCD.get(),UID.get(),.DENACTU)
		// Fill URLIM and UCLIM arays
		do FLURLIM(UID.get(),.DENOM,.URLIM)
		do FLUCLIM(.DENOM,.UCLIM)
	
		//assemble and return the results
		set (BRCD,CRCD,UID,CSEQ)=""
		for  set BRCD=DENACTU(BRCD).order() quit:BRCD=""  do {
			set BRTOTAL=0
			do BROVER(BRCD,.BRLIM)
			if BRLIM(BRCD).data() do {
				set BRMIN=BRLIM(BRCD).piece("|",1)
				set BRMAX=BRLIM(BRCD).piece("|",2)
			}
			else  set (BRMIN,BRMAX)="" 
			// User Summary Level
			for  set UID=DENACTU(BRCD,UID).order() quit:UID=""  do {
				set OVERTOTAL=0
				do UROVER(UID,.OVERLIM)
				if OVERLIM(UID).data() do {
					set OVERMIN=OVERLIM(UID).piece("|",1)
					set OVERMAX=OVERLIM(UID).piece("|",2)
				}
				else  set (OVERMIN,OVERMAX)=""
				// Currency Summary Level
				for  set CRCD=DENACTU(BRCD,UID,CRCD).order() quit:CRCD=""  do {
					set CRCDTOTAL=0
					//User Totals for Single Currency
					for  set CSEQ=DENACTU(BRCD,UID,CRCD,CSEQ).order() quit:CSEQ=""  do {
						quit:DENACTU(BRCD,UID,CRCD,CSEQ).get()=""
						set (MIN,MAX)=""
						set DESCR=DENOM(CRCD,CSEQ).piece("|",1)
						set MULT=DENOM(CRCD,CSEQ).piece("|",2)
						if URLIM(CRCD,UID,CSEQ).get()'="" do {
							set MIN=URLIM(CRCD,UID,CSEQ).piece("|",1))
							set MAX=URLIM(CRCD,UID,CSEQ).piece("|",2))
							if MIN="" set MIN=0
						}
						else  do {
							type ResultSet rsUclass
							set rsUclass=Db.select("%UCLS","SCAU","UID=:UID")
							while rsUclass.next() do {
								set UCLS=rsUclass.getCol("%UCLS")
							}
							if UCLIM(CRCD,UCLS,CSEQ).get()'="" do {
								set MIN=UCLIM(CRCD,UCLS,CSEQ).piece("|",1)
								set MAX=UCLIM(CRCD,UCLS,CSEQ).piece("|",2)
								if MIN="" set MIN=0
							}
						}
						set CIRC=DENACTU(BRCD,UID,CRCD,CSEQ).piece("|",1)
						set MUTIL=DENACTU(BRCD,UID,CRCD,CSEQ).piece("|",2)
						set CRCDTOTAL=CRCDTOTAL + ((CIRC+MUTIL)*MULT)
						set TOTAL=CIRC+MUTIL
						set OVERSHORT=""
						if MIN'="",MAX'="" do {
							if (CIRC+MUTIL)<MIN set OVERSHORT=CIRC+MUTIL-MIN
							if (CIRC+MUTIL)>MAX set OVERSHORT=CIRC+MUTIL-MAX
						}
						set REC=REC_CRLF_BRCD_%_UID_%_CRCD_%_DESCR_%_MIN_%_MAX_%_CIRC_%_MUTIL_%_TOTAL_%_OVERSHORT
					}
					//Display User Total for Single Currency
					//Flag this line for report
					set REC=REC_CRLF_BRCD_%_UID_%_CRCD_%_"CRCDTOTAL"_%_%_%_%_%_CRCDTOTAL_%
					// Overall Total, corrected for non-system base currencies
					set OVERTOTAL=OVERTOTAL+$$CKCRCD(CRCDTOTAL,CRCD)
					set LASTCRCD=CRCD
				}
				// Display User Overall Data
				set OVERSUM=""
				if OVERMIN'="",OVERMAX'="" do {
					if OVERTOTAL<OVERMIN set OVERSUM=OVERTOTAL-OVERMIN
					if OVERTOTAL>OVERMAX set OVERSUM=OVERTOTAL-OVERMAX
				}
				//Flag this line for report
				set REC=REC_CRLF_BRCD_%_UID_%_LASTCRCD_%_"USEROVERALL"_%_OVERMIN_%_OVERMAX_%_%_%_OVERTOTAL_%_OVERSUM
				set BRTOTAL=BRTOTAL+OVERTOTAL
				set LASTUSER=UID
			}
			// Display Branch level Overall Totals
			set BRSUM=""
			if BRMIN'="",BRMAX'="" do {
				if BRTOTAL<BRMIN set BRSUM=BRTOTAL-BRMIN
				if BRTOTAL>BRMAX set BRSUM=BRTOTAL-BRMAX
			}
			//Flag this line for report
			set REC=REC_CRLF_BRCD_%_LASTUSER_%_LASTCRCD_%_"BRANCHOVERALL"_%_BRMIN_%_BRMAX_%_%_%_BRTOTAL_%_BRSUM
		}
		set RETURN=REC.extract(2,REC.length())
	}
	
	if CTL=2 do {
		// Get UTBLDENOM information
		do FILLDEN(CRCD.get(),.DENOM)
		type ResultSet rsDentran
		type String REC,WHERE
		type Date TPD
		
		set TPD=TPDATE
		set REC=""
		set WHERE="TJD=:TPD AND BRCD=:BRCD"
		if UID.get()'="*",UID.get()'="" set WHERE=WHERE_" AND UID=:UID"
		if TSEQ.get()'="*",TSEQ.get()'="" set WHERE=WHERE_" AND TSEQ=:TSEQ"
		if CRCD.get()'="*",CRCD.get()'="" set WHERE=WHERE_" AND CRCD=:CRCD"
		
		#ACCEPT DATE=02/13/2007;PGM=MAPPLEYARD;CR=25302
		set rsDentran=Db.select("UID,TSEQ,CRCD,CSEQ,CNT,MUTILATED","DENTRAN",WHERE,"UID,TSEQ,CSEQ")
		while rsDentran.next() do {
			type String CRCD,CSEQ,TSEQ,UID
			set UID=rsDentran.getCol("UID")
			set TSEQ=rsDentran.getCol("TSEQ")
			set CSEQ=rsDentran.getCol("CSEQ")
			set CRCD=rsDentran.getCol("CRCD")

			set REC=REC_CRLF_BRCD_%_UID_%_CRCD_%_TSEQ

			type RecordTTX temp=Db.getRecord("TTX","TJD=:TPD,BRCD,UID,TSEQ")
			set REC=REC_%_temp.etc_%_temp.tamt_%_DENOM(CRCD,CSEQ).piece("|",1)			
			set REC=REC_%_rsDentran.getCol("CNT")_%_rsDentran.getCol("MUTILATED")_%_DENOM(CRCD,CSEQ).piece("|",2)			
		}
		set RETURN=REC.extract(2,REC.length())
	}
	
	if CTL=3 do UPDENACT(BRCD.get(),UID.get(),INPUT.get())
	
	quit

private FILLDEN(String CRCD,DENOM)
	if CRCD.get()'="*" do {
		do GETDENOM(CRCD,.DENOM)
	}	
 	else  do {
 		type ResultSet rs
 		set rs=Db.select("DISTINCT CRCD","UTBLDENOM")
 		while rs.next() do {
 			set CRCD=rs.getCol("CRCD")
 			do GETDENOM(CRCD,.DENOM)
 		}
 	}
 	quit
 	
private FILLCASH(String UID, String CRCD, Number BRCD, Date TPDATE, String CASH(,,))
	type public String DENOM(,)
	if UID.get()'="*" do {
		set CRCD=""
		for  set CRCD=DENOM(CRCD).order() quit:CRCD=""  do {
			do GETCASH(UID,CRCD,BRCD,TPDATE,.CASH)
		}
	}
	else  do {
		type ResultSet rsUser
		set rsUser=Db.select("DISTINCT UID","DENACTU","BRCD=:BRCD")
		while rsUser.next() do {
			set UID=rsUser.getCol("UID")
			set CRCD=""
			for  set CRCD=DENOM(CRCD).order() quit:CRCD=""  do {
				do GETCASH(UID,CRCD,BRCD,TPDATE,.CASH)
			}
		}
	}
	quit
	
private FILLDENAC(String UID, Number BRCD, String DENACTU(,,,))
	type public String DENOM(,)
	type String CRCD
	if UID.get()'="*" do {
		set CRCD=""
		for  set CRCD=DENOM(CRCD).order() quit:CRCD=""  do {
			do GETDENAC(UID,BRCD,CRCD,.DENACTU)
		}
	}
	else  do {
		type ResultSet rsUser
		set rsUser=Db.select("DISTINCT UID","DENACTU","BRCD=:BRCD")
		while rsUser.next() do {
			set UID=rsUser.getCol("UID")
			set CRCD=""
			for  set CRCD=DENOM(CRCD).order() quit:CRCD=""  do {
				do GETDENAC(UID,BRCD,CRCD,.DENACTU)
			}
		}
	}
	quit

private FLBRDEN(String BRCD, String UID, String DENACTU(,,,))
	if BRCD.get()'="*" do {
		do FILLDENAC(UID,BRCD,.DENACTU)
	}
	else  do {
		type ResultSet rsBrcd
		set rsBrcd=Db.select("DISTINCT BRCD","DENACTU")
		while rsBrcd.next() do {
			set BRCD=rsBrcd.getCol("BRCD")
			do FILLDENAC(UID,BRCD,.DENACTU)
		}
	}
	quit

private FLURLIM(String UID, String DENOM(,), String URLIM(,))
	type String CRCD
	set CRCD=""
	for  set CRCD=DENOM(CRCD).order() quit:CRCD=""  do {
		if UID.get()'="*" do {
			do GETURLIM(CRCD,UID.get(),.URLIM)
		}
		else  do {
			type ResultSet rsUser
			set rsUser=Db.select("DISTINCT UID","UTBLDENLIMUR")
			while rsUser.next() do {
				set UID=rsUser.getCol("UID")
				do GETURLIM(CRCD,UID.get(),.URLIM)
			}
		}
	}
	quit
	
private FLUCLIM(String DENOM(,), String UCLIM(,))
	type String CRCD
	set CRCD=""
	for  set CRCD=$order(DENOM(CRCD)) quit:CRCD=""  do {
		type String UCLS
		type ResultSet rsClass
		set rsClass=Db.select("DISTINCT UCLS","UTBLDENLIMUC","CRCD=:CRCD")
		while rsClass.next() do {
			set UCLS=rsClass.getCol("UCLS")
			do GETUCLIM(UCLS,CRCD,.UCLIM)
		}
	}
	quit		
		
private GETDENOM(String CRCD,DENOM)
 	type ResultSet rsUtbldenom
 	set rsUtbldenom=Db.select("CSEQ,DESC,MULT,TPCSHLNK,STRAP,ROLL","UTBLDENOM","CRCD=:CRCD","ORDER BY CSEQ")
 	while rsUtbldenom.next() do {
 		type String CSEQ
 		set CSEQ=rsUtbldenom.getCol("CSEQ")
 		set DENOM(CRCD,CSEQ)=rsUtbldenom.getCol("DESC")_"|"_rsUtbldenom.getCol("MULT")_"|"_rsUtbldenom.getCol("TPCSHLNK")_"|"_rsUtbldenom.getCol("STRAP")_"|"_rsUtbldenom.getCol("ROLL")
 	}
 	quit
 	
private GETCASH(String UID, String CRCD, Number BRCD, Date TPDATE, String CASH(,,))
	type RecordTPCASH tpcash
	//Get record if it exists, otherwise create new,
	set tpcash=Db.getRecord("TPCASH","BRCD=:BRCD,UID=:UID,TPD=:TPDATE,CRCD=:CRCD",1)
	set CASH(UID,CRCD,"HUND")=tpcash.hund
	set CASH(UID,CRCD,"FIFTY")=tpcash.fifty
	set CASH(UID,CRCD,"TWENTY")=tpcash.twenty
	set CASH(UID,CRCD,"TEN")=tpcash.ten
	set CASH(UID,CRCD,"FIVE")=tpcash.five
	set CASH(UID,CRCD,"TWO")=tpcash.two
	set CASH(UID,CRCD,"ONE")=tpcash.one
	set CASH(UID,CRCD,"SILVER")=tpcash.silver
	set CASH(UID,CRCD,"HALVES")=tpcash.halves
	set CASH(UID,CRCD,"QUARTER")=tpcash.quarter
	set CASH(UID,CRCD,"DIMES")=tpcash.dimes
	set CASH(UID,CRCD,"NICKLE")=tpcash.nickle
	set CASH(UID,CRCD,"PENNY")=tpcash.penny
	set CASH(UID,CRCD,"TWOPNC")=tpcash.twopnc
	set CASH(UID,CRCD,"TSILVER")=tpcash.tsilver
	set CASH(UID,CRCD,"TWTYCN")=tpcash.twtycn
	set CASH(UID,CRCD,"FTHOU")=tpcash.fthou
	set CASH(UID,CRCD,"FHUND")=tpcash.fhund
	set CASH(UID,CRCD,"OTHOU")=tpcash.othou
	set CASH(UID,CRCD,"FIFTYCN")=tpcash.fiftycn
	set CASH(UID,CRCD,"TWENTYCOIN")=tpcash.twentycoin
	set CASH(UID,CRCD,"FIVECOIN")=tpcash.fivecoin
	set CASH(UID,CRCD,"TENCOIN")=tpcash.tencoin
	set CASH(UID,CRCD,"HUNDTHOU")=tpcash.hundthou
	set CASH(UID,CRCD,"FIFTYTHOU")=tpcash.fiftythou
	set CASH(UID,CRCD,"TWENTYTHOU")=tpcash.twentythou
	set CASH(UID,CRCD,"TENTHOU")=tpcash.tenthou
	set CASH(UID,CRCD,"TWOTHOU")=tpcash.twothou
	set CASH(UID,CRCD,"FIVEHUNCOIN")=tpcash.fivehuncoin
	set CASH(UID,CRCD,"TWOHUNDCOIN")=tpcash.twohundcoin
	set CASH(UID,CRCD,"ONEHUNDCOIN")=tpcash.onehundcoin
	set CASH(UID,CRCD,"TWOHUND")=tpcash.twohund
	set CASH(UID,CRCD,"TWOHUNDFIF")=tpcash.twohundfif
	set CASH(UID,CRCD,"TWOFIFCOIN")=tpcash.twofifcoin
	set CASH(UID,CRCD,"TWENTYFIVE")=tpcash.twentyfive
	set CASH(UID,CRCD,"TWNTYFIVCOIN")=tpcash.twntyfivcoin
	set CASH(UID,CRCD,"OTHOUCOIN")=tpcash.othoucoin
	set CASH(UID,CRCD,"FHUNDTHOU")=tpcash.fhundthou
	set CASH(UID,CRCD,"OMILL")=tpcash.omill
	set CASH(UID,CRCD,"OMILLCOIN")=tpcash.omillcoin
	set CASH(UID,CRCD,"MUTIL")=tpcash.mutil
	set CASH(UID,CRCD,"STRAP")=tpcash.strap
	set CASH(UID,CRCD,"ROLLED")=tpcash.rolled

	quit
	
private GETDENAC(String UID, Number BRCD, String CRCD, DENACTU)
	type ResultSet rsDenac
	set rsDenac=Db.select("CSEQ,CNT,MUTILATED","DENACTU","UID=:UID AND BRCD=:BRCD AND CRCD=:CRCD","ORDER BY CSEQ")
	while rsDenac.next() do {
		type String CSEQ
		set CSEQ=rsDenac.getCol("CSEQ")
		set DENACTU(BRCD,UID,CRCD,CSEQ)=rsDenac.getCol("CNT")_"|"_rsDenac.getCol("MUTILATED")
	}
	quit
	
private GETURLIM(String CRCD, String UID, URLIM)
	type ResultSet rsUrlim
	set rsUrlim=Db.select("CSEQ,MINCNT,MAXCNT","UTBLDENLIMUR","CRCD=:CRCD AND UID=:UID","ORDER BY CSEQ")
	while rsUrlim.next() do {
		type String CSEQ
		set CSEQ=rsUrlim.getCol("CSEQ")
		set URLIM(CRCD,UID,CSEQ)=rsUrlim.getCol("MINCNT")_"|"_rsUrlim.getCol("MAXCNT")
	}
	quit
	
private GETUCLIM(String UCLS, String CRCD, UCLIM)
	type ResultSet rsUclim
	set rsUclim=Db.select("CSEQ,MINCNT,MAXCNT","UTBLDENLIMUC","CRCD=:CRCD AND UCLS=:UCLS","ORDER BY CSEQ")
	while rsUclim.next() do {
		type String CSEQ,MAXCNT,MINCNT
		set CSEQ=rsUclim.getCol("CSEQ")
		set MAXCNT=rsUclim.getCol("MAXCNT")
		set MINCNT=rsUclim.getCol("MINCNT")
		if MINCNT'="",MAXCNT'="" set UCLIM(CRCD,UCLS,CSEQ)=MINCNT_"|"_MAXCNT
	}
	quit
	
private UROVER(String UID,OVERLIM)
	type ResultSet rsOver
	set rsOver=Db.select("OACMIN,OACMAX","SCAU","UID=:UID")
	while rsOver.next() do {
		set OVERLIM(UID)=rsOver.getCol("OACMIN")_"|"_rsOver.getCol("OACMAX")
	}
	quit
	
private BROVER(Number BRCD,BRLIM)
	type ResultSet rsBranch
	set rsBranch=Db.select("OACMIN,OACMAX","UTBLBRCD","BRCD=:BRCD")
	while rsBranch.next() do {
		set BRLIM(BRCD)=rsBranch.getCol("OACMIN")_"|"_rsBranch.getCol("OACMAX")
	}
	quit	
	
private CKCRCD( Number TOTAL, String CRCD)
	/*
	   Return system base currency value
	*/
	type Number VALUE
	type String CONAM
	if CRCD=%SystemCurrency set VALUE=TOTAL
	else  do {
		type ResultSet rsRate
		set CONAM=%CompanyName
		set rsRate=Db.select("MIDRATE","CRCD","CO=:CONAM AND CRCD=:CRCD")
		while rsRate.next() do {
			set VALUE=$$^SCARND(TOTAL*rsRate.getCol("MIDRATE"),,,%SystemCurrency)
		}
	}
	quit VALUE
	
private UPDENACT( Number BRCD, String UID, String INPUT)

	type String DATA
	type Boolean QUIT
	type Number seqcnt
	
	set QUIT=0
	
	// Move INPUT into local array
	do STR2ARR^UTLMRPC(INPUT,.DATA)
	
	/*
	The input string is a series of repeating strings. Each new set of records is 
	marked by a sequential integer appended to the table name, i.e., 
	DENACTU1, DENACTU2, etc. Each sequence of records must be saved individually.
	The bypassSave method is used. It is the responsibility of the calling routine
	to ensure the validity of the data, similar to batch processing.
	*/	
	
	for seqcnt=1:1 do { quit:QUIT
		type String UID, TMPDATA

 		set UID=$G(DATA("DENACTU"_seqcnt_".UID"))
		if UID="" set QUIT=1 quit 

		type RecordDENACTU denactu
		set denactu=Class.new("RecordDENACTU")

		do MOVEARR^UTLMRPC("DENACTU"_seqcnt,"DENACTU",.DATA,.TMPDATA)		
		do denactu.overlay("TMPDATA")
		do denactu.bypassSave()		
	}
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60817^44485^Mike Appleyard^20113"	// Signature - LTD^TIME^USER^SIZE
