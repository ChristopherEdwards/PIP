LNPATH	// - PAYMENT APPLICATION PATH MAINTENANCE
	/*
	       ORIG:  Kathie Pardoe (7070) - 10/07/87

	---- Revision History ------------------------------------------------
	
	05/23/06 - KUMARB - CR 21400
		   Modified VSET section to sort LNPDS2 records numerically by
		   UPLIMIT by using an intermediate array.  This prevents the
		   LNPDS2 records from being sorted in ASCII order by UPLIMIT
		   in Oracle environments.

	03/27/06 - KELLYP - CR 20387
		   Modified FILE section to set the mode of the fLNPATH object
		   if the LNPATH record is going to be deleted.  This prevents
		   a problem where the LNPATH1 records get creted but the 
		   LNPATH record is not recreated after it's deleted.  Also
		   modified VPG and VPG02 sections to check VFMQ to prevent 
		   undefined errors from occurring when the user F11's out of
		   query or screen pages.  Also modified VSET section to order
		   the final LNPATH1 result set by STAB.  This prevents an 
		   issue where the LNPAS21 screen was displaying the LNPATH1
		   records out of order even though they were correct in the db.
		   
	06/16/05 - KELLYP - CR 16312
		   Modified VDELCK section to reference PRODDFTL instead of
		   XCLSLN (which has been obsoleted).  Also removed pre-2003
		   revision history.
	  
	01/06/04 - RussellDS - CR7514
	  	   Eliminated use of table LNPAS (obsoleted) and replaced with
	  	   LNPA.
	  	   
	  	   Eliminate use of table LNPAS1 (obsoleted) and replaced with
	  	   local array ULX() and screen arrays UL1()-UL13().

	---------------------------------------------------------------------------

	*/
	
	quit

CREATE 	//
	do INIT(0)

	quit


UPD 	//
	do INIT(1)

	quit


INQ 	//
	do INIT(2)

	quit


DEL 	//
	do INIT(3)

	quit


INIT(%ProcessMode)	//
	new I,OLNTB,OPDST,ULI,ULX,VFMQ

	set %PG=0 
	set %PAGE=$S(%ProcessMode>1:1,1:2)
	set OPDST=""
	set ULI=0
	set I=0

	type RecordLNPAS2 fLNPAS
	type RecordLNPATH fLNPATH

	do VPG(.fLNPAS,.fLNPATH)

	quit


VPG(RecordLNPAS2 fLNPAS,RecordLNPATH fLNPATH)	// Page control

	new FINISH
	set FINISH=0

	for  do { quit:FINISH
		if %PG=1&((%ProcessMode=2)!(%ProcessMode=4)) do {
			do VSET(.fLNPAS,.fLNPATH,.ULX) 
			do VPG02(.fLNPAS,.fLNPATH)
			}

		if %PG=0 do VPG00(.fLNPAS,.fLNPATH)
		
		if "Q"[VFMQ set FINISH=1 quit

		if %PG=2 do {
			do VSET(.fLNPAS,.fLNPATH,.ULX) 
			do VPG02(.fLNPAS,.fLNPATH,.ULX) 
			}
		if ER=1 set FINISH=1 quit
 
                if "DFQ"[VFMQ do VER(.fLNPAS,.fLNPATH,.ULX) set FINISH=1 quit
                set %PG=%PG+1

		if %PG>0 do VPG01(.fLNPAS,.fLNPATH)

		if ER=1 set FINISH=1 quit

		if "DFQ"[VFMQ do VER(.fLNPAS,.fLNPATH,.ULX) set FINISH=1 quit
		set %PG=%PG+1
		}

	quit


VPG00(RecordLNPAS2 fLNPAS,RecordLNPATH fLNPATH)	//
	set %TAB("TABLE")=".UTBL1/TBL=[LNPAS2]"

	if %ProcessMode=0 set %TAB("PATH")=".PATH1/XPP=D PATHPP^LNPATH"
	else  set %TAB("PATH")=".PATH1/TBL=[LNPATH]PATH:QU ""[LNPATH]TABLE=<<TABLE>>"""
	
	if %ProcessMode=2 set %TAB("IO")=$$IO^SCATAB($I)

	set %READ="@@%FN,,,TABLE/REQ,PATH/REQ"

	if %ProcessMode=2 set %READ=%READ_",IO/REQ"

	do ^UTLREAD 

	if VFMQ="Q" set ER=1 quit

	if %ProcessMode=2,IO'=$I do OPEN^SCAIO quit:ER

	// Load data
	set fLNPAS=Db.getRecord("LNPAS2","TABLE=:TABLE")
	set fLNPATH=Db.getRecord("LNPATH","TABLE=:TABLE,PATH=:PATH",1)
	if fLNPATH.getMode()=0 set PDST=fLNPAS.pdst
	else  set PDST=fLNPATH.pdst

	if %ProcessMode=2!(%ProcessMode=4) do VSET(.fLNPAS,.fLNPATH,.ULX) quit
	if %ProcessMode=3 do VDELCK

	quit


PATHPP	// Path Post Processor

	if 'Db.isDefined("LNPATH","TABLE=:TABLE,PATH=:X") quit

	set ET="LNONFIL"
	do ERR

	quit


VPG01(RecordLNPAS2 fLNPAS,RecordLNPATH fLNPATH)	// Screen

	do DRV^USID(%ProcessMode,"LNPATH",.fLNPATH,.fLNPAS)

	quit


VPG02(RecordLNPAS2 fLNPAS,RecordLNPATH fLNPATH,String ULX())	// Screen

	type String UL1(),UL2(),UL3(),UL4(),UL5(),UL6(),UL7(),UL8(),UL9(),UL10(),UL11(),UL12(),UL13()

	if '$D(ULX) do FILLARY(.ULX)
	
	// Move ULX info into ULn for use as screen repeating variables
	for I=1:1:20 do {
		set UL1(I)=$P(ULX(I),"|",1)
		set UL2(I)=$P(ULX(I),"|",2)
		set UL3(I)=$P(ULX(I),"|",3)
		set UL4(I)=$P(ULX(I),"|",4)
		set UL5(I)=$P(ULX(I),"|",5)
		set UL6(I)=$P(ULX(I),"|",6)
		set UL7(I)=$P(ULX(I),"|",7)
		set UL8(I)=$P(ULX(I),"|",8)
		set UL9(I)=$P(ULX(I),"|",9)
		set UL10(I)=$P(ULX(I),"|",10)
		set UL11(I)=$P(ULX(I),"|",11)
		set UL12(I)=$P(ULX(I),"|",12)
		set UL13(I)=$P(ULX(I),"|",13)
		}
	
	do DRV^USID(%ProcessMode,"LNPAS21",.fLNPATH,.fLNPAS)
	
	if "Q"[VFMQ quit
	
	// Move ULn info back into ULX
	for I=1:1:20 do {
		set $P(ULX(I),"|",1)=UL1(I)
		set $P(ULX(I),"|",2)=UL2(I)
		set $P(ULX(I),"|",3)=UL3(I)
		set $P(ULX(I),"|",4)=UL4(I)
		set $P(ULX(I),"|",5)=UL5(I)
		set $P(ULX(I),"|",6)=UL6(I)
		set $P(ULX(I),"|",7)=UL7(I)
		set $P(ULX(I),"|",8)=UL8(I)
		set $P(ULX(I),"|",9)=UL9(I)
		set $P(ULX(I),"|",10)=UL10(I)
		set $P(ULX(I),"|",11)=UL11(I)
		set $P(ULX(I),"|",12)=UL12(I)
		set $P(ULX(I),"|",13)=UL13(I)
		}

	quit


FILLARY(String ULX())	// To allocate ULX()
	new I

	for I=1:1:20 set ULX(I)=""

	quit


ERR	//

	set ER=1 
	do ^UTLERR
	set VFMQ="Q"

	quit


VER(RecordLNPAS2 fLNPAS,RecordLNPATH fLNPATH,String ULX()) 	//

	if %ProcessMode=2!(%ProcessMode=4)!(VFMQ="Q") do END quit
	do FILE(.fLNPAS,.fLNPATH,.ULX)
	do END

	quit


FILE(RecordLNPAS2 fLNPAS,RecordLNPATH fLNPATH,String ULX)	// File data

	new STAB
	
	if %ProcessMode=3 do { quit
		type RecordLNPDS lnpds=Db.getRecord("LNPDS","TABLE=:PDST")
		do lnpds.setAuditFlag(1)

		set lnpds.ct=lnpds.ct-1
		do lnpds.bypassSave()

		do Db.delete("LNPATH","TABLE=:TABLE AND PATH=:PATH")
		do Db.delete("LNPATH1","TABLE=:TABLE AND PATH=:PATH")
		}

	// update PDS counter if needed
	do VCHK(.fLNPATH)

	if $D(ULX) do {
                do Db.delete("LNPATH","TABLE=:TABLE AND PATH=:PATH")
		do Db.delete("LNPATH1","TABLE=:TABLE AND PATH=:PATH")
		do fLNPATH.setMode(0)
		}
	
	do fLNPATH.bypassSave()

	if '$D(ULX) quit

	for J=2:1:ULI do {
		set UL=$P(UN(J-1)," ",1)
		set XX=""
		for I=1:1:%REPEAT do { quit:'$D(ULX(I))
			if J=2 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",2)_"-"
			if J=3 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",3)_"-"
			if J=4 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",4)_"-"
			if J=5 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",5)_"-"
			if J=6 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",6)_"-"
			if J=7 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",7)_"-"
			if J=8 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",8)_"-"
			if J=9 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",9)_"-"
			if J=10 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",10)_"-"
			if J=11 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",11)_"-"
			if J=12 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",12)_"-"
			if J=13 set XX=XX_$P(ULX(I),"|",1)_"-"_$P(ULX(I),"|",13)_"-"
			
			if I=%REPEAT do {
				type RecordLNPATH1 lnpath1=Db.getRecord("LNPATH1","TABLE=:TABLE,PATH=:PATH,STAB=:UL",1)
				do lnpath1.setAuditFlag(1)
				set lnpath1.pastr=$E(XX,1,$L(XX)-1)
				do lnpath1.bypassSave()
				}
			}
		}
	quit


END	//
	if ER!(%ProcessMode=2)!(%ProcessMode=4) quit
	set PATH=$G(PATH)

	if VFMQ="Q" do {

		// Path ~p1 not created
		if %ProcessMode=0 set RM=$$^MSG(2145,PATH) quit

		// Path ~p1 not modified
		if %ProcessMode=1 set RM=$$^MSG(2147,PATH) quit

		// Path ~p1 not deleted
		set RM=$$^MSG(2146,PATH)
		}
	else  do {

		// Path ~p1 created
		if %ProcessMode=0 set RM=$$^MSG(2142,PATH) quit

		// Path ~p1 modified
		if %ProcessMode=1 set RM=$$^MSG(2144,PATH) quit

		// Path ~p1 deleted
		set RM=$$^MSG(2143,PATH)
		}

	set ER="W"

	quit


VSET(RecordLNPAS2 fLNPAS,RecordLNPATH fLNPATH,String ULX())	// set up path info.

	if $D(OPDST),OPDST=fLNPATH.pdst,$D(ULX) quit
	
	if '$D(ULX) do FILLARY(.ULX)

	set DISTRIB=fLNPAS.distrib
	set (OPDST,PDST)=fLNPATH.pdst

	new COLNAM,DES,I
	set COLNAM=""

	if PDST'="" do {
		type String TMPARR(),UPLIMIT
		
		type ResultSet rs=Db.select("UPLIMIT,DES","LNPDS2","TABLE=:PDST")
		while rs.next() do {
		        set UPLIMIT=rs.getCol("UPLIMIT")
		        set TMPARR(UPLIMIT)=rs.getCol("DES")
		        }
		        
		set I=0,UPLIMIT=""
		for  set UPLIMIT=TMPARR(UPLIMIT).order() quit:UPLIMIT.isNull()  do {
			set UL=UPLIMIT
			if UL=0 quit
			set I=I+1
			set UN(I)=$E(UL_"    ",1,4)
			set DES=TMPARR(UPLIMIT)
			set UL(I)=$E(DES_"    ",1,4)
			set DASH(I)="----"
			}
		}
	set I=I+1
	set ULI=I
	if I<13 for J=I:1:12 do {
		set UL(J)=$J("",4)
		set DASH(J)=$J("",4)
		set UN(J)=$J("",4)
		}

	set REC=""
	for I=1:1:12 set REC=REC_$J("",4)_"|"

	// Set up table info if create
	if '%ProcessMode do VSET1(.ULX) quit

	// If new table, no LNPATH1 info
	type ResultSet rs1=Db.select("STAB","LNPATH1","TABLE=:TABLE AND PATH=:PATH")
	if rs1.isEmpty() do VSET1(.ULX) quit

	// If changed pdst
	if fLNPATH.pdst'=PDST do VSET1(.ULX) quit

	// For update with same due status table as used before
	for DI=1:1 set DIS=$P(DISTRIB,"-",DI)  do { quit:DIS=""
		if '$D(ULX(DI)) set ULX(DI)=""

		set $P(ULX(DI),"|",1)=DIS
		set $P(ULX(DI),"|",2)=REC
		}

	set (%REPEAT,DI)=DI-1

	set JJ=0
	type ResultSet rs=Db.select("STAB,PASTR","LNPATH1","TABLE=:TABLE AND PATH=:PATH","STAB ASC")
	while rs.next() do {
		set JJ=JJ+1
		set UL=rs.getCol("STAB")
		if UL=0 set JJ=JJ-1 quit

		set XUL=rs.getCol("PASTR")
			
		for II=1:1:DI do {
			if JJ=1 set $P(ULX(II),"|",2)=$P(XUL,"-",II*2)
			if JJ=2 set $P(ULX(II),"|",3)=$P(XUL,"-",II*2)
			if JJ=3 set $P(ULX(II),"|",4)=$P(XUL,"-",II*2)
			if JJ=4 set $P(ULX(II),"|",5)=$P(XUL,"-",II*2)
			if JJ=5 set $P(ULX(II),"|",6)=$P(XUL,"-",II*2)
			if JJ=6 set $P(ULX(II),"|",7)=$P(XUL,"-",II*2)
			if JJ=7 set $P(ULX(II),"|",8)=$P(XUL,"-",II*2)
			if JJ=8 set $P(ULX(II),"|",9)=$P(XUL,"-",II*2)
			if JJ=9 set $P(ULX(II),"|",10)=$P(XUL,"-",II*2)
			if JJ=11 set $P(ULX(II),"|",12)=$P(XUL,"-",II*2)
			if JJ=12 set $P(ULX(II),"|",13)=$P(XUL,"-",II*2)
			}			
		}
	quit


VSET1(String ULX())	// new path info if: new table, or old table & new due status table

	if '$D(ULX) do FILLARY(.ULX)
	
	for DI=1:1 do { quit:DIS=""

		set DIS=$P(DISTRIB,"-",DI)
		if DIS="" quit
		
		set $P(ULX(DI),"|",1)=DIS
		set $P(ULX(DI),"|",2)=REC

		for J=1:1:ULI-1 do {

			if J=1 set $P(ULX(DI),"|",2)="v"
			if J=2 set $P(ULX(DI),"|",3)="v"
			if J=3 set $P(ULX(DI),"|",4)="v"
			if J=4 set $P(ULX(DI),"|",5)="v"
			if J=5 set $P(ULX(DI),"|",6)="v"
			if J=6 set $P(ULX(DI),"|",7)="v"
			if J=7 set $P(ULX(DI),"|",8)="v"
			if J=8 set $P(ULX(DI),"|",9)="v"
			if J=9 set $P(ULX(DI),"|",10)="v"
			if J=11 set $P(ULX(DI),"|",12)="v"
			if J=12 set $P(ULX(DI),"|",13)="v"

			}
		}

	set %REPEAT=DI-1

	quit


VDELCK	// don't delete if this table, path is used
	
	type public Boolean ER
	type public String PATH,TABLE,VFMQ
	
	type ResultSet rs=Db.select("TYPE","PRODDFTL","PAP=:PATH AND PAS=:TABLE")

	// May not modify or delete.  Table is currently being used.
	if 'rs.isEmpty() do Runtime.setErrSTBLER("PRODDFTL","INVLDOPT") set VFMQ="Q" quit:ER
	
	quit


VCHK(RecordLNPATH fLNPATH)	//  check table counter

	if '%ProcessMode do VUPDAT quit

	set OPDST=fLNPATH.pdst
	if OPDST=PDST quit
	
	type RecordLNPDS lnpds=Db.getRecord("LNPDS","TABLE=:OPDST",1)

	set CT=lnpds.ct
	set CT=CT-1
	set lnpds.ct=CT

	do lnpds.bypassSave()

	do VUPDAT

	quit


VUPDAT	//

	type RecordLNPDS lnpds=Db.getRecord("LNPDS","TABLE=:PDST")
	set CT=lnpds.ct
	set CT=CT+1
	set lnpds.ct=CT
	quit

	
 #OPTION ResultClass ON
Public String vSIG()	quit "60409^19810^Balasubramonian Sankar^10734"	// Signature - LTD^TIME^USER^SIZE
