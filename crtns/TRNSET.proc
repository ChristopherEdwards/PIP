TRNSET	//Transaction Set Maintainance
	/*
	   ORIG: Claude Jeruchim - 10/22/98
	   DESC: Transaction Set Maintainance

	KEYWORDS: Transaction Sets
	----------------------------------------------------------------------------
	Revision History
	
	02/22/06 - SPR - 19155
	
		   Modified the sections UPD2, NEXT, BIGTNS, START, FILE2 to 
		   maintain and update,delete a transaction field for the 
		   transaction set.	
	   
	11/24/05 - SPR - 18268
	
		   Transaction Support Data/Transaction Sets -General DBI3
		   system area cleanup.Deprecated functions removed. 
	   
	----------------------------------------------------------------------------
	*/
	
	quit
	
NEW	//

	type Number SEQ
	type String NEWSEQ,%NOPRMT,%READ,%TAB(),TRNSET

	// New sequence of a transaction set or entirely new transaction set

	set %TAB("TRNSET")=".TRNSET/XPP=D TRNPP1^TRNSET/TBL=[UTBLTRNSET]TRNSET:NOVAL:DISTINCT"
	set %TAB("SEQ")=".SEQN/XPP=D SEQPP1^TRNSET"
	
	// Mark the sequence as new so we can bump the total number of pages.
	set NEWSEQ="YES"
	set %READ="@@%FN,,,TRNSET,SEQ/REQ" 
	set %NOPRMT="N"

	do UPD2

	quit


UPD	//

	type Number SEQ
	type String NEWSEQ,%NOPRMT,%READ,%TAB(),TRNSET

	set NEWSEQ="NO"
	set %READ="@@%FN,,,TRNSET" 
	set %NOPRMT="N"

	// Modify existing transaction set
	set %TAB("TRNSET")=".TRNSET/XPP=D TRNPP2^TRNSET/TBL=[UTBLTRNSET]TRNSET:DISTINCT"
	
	do UPD2

	quit


UPD2	//

	type Public Number SEQ
	type Public String NEWSEQ,TRNSET

	type Number DONE,pagenum,%PG
	type String BIGSEQ(),BIGTNS(,)

	set %ProcessMode=0

	do ^UTLREAD
	
	if TRNSET.get()="" do END quit
	set %PG=0 
	set pagenum=1
	set DONE=0
	
	// Create the Big TNS array, which holds the entire transaction set.
	
	do BIGTNS
	
	if NEWSEQ="NO" do {
		set SEQ=""
		
		// Get the first sequence of the set.
		type ResultSet rs=Db.select("SEQ","UTBLTRNSET","TRNSET=:TRNSET")
		if rs.next() set SEQ=rs.getCol("SEQ")	
		}	
	do NEXT

	quit


NEXT	//

	type Public Number DONE,ER,pagenum,SEQ
	type Public String BIGSEQ(),TRNSET,VFMQ,X

	type Number minipage
	type String DIREC

	// User has opted to go the next or previous page
	do START(TRNSET,SEQ)
	if VFMQ="Q" do END quit
	while ((X="N")!((X="F")&(VFMQ))) do { quit:(DONE)!(ER)

		if (X="N")!(VFMQ) do {
			if (VFMQ=pagenum) do { quit

		                /*
		                User has opted to go to the next page	
		                the minipage variable stands for pages within
		                one sequence, where there are more fields than
		                can be held on one screen.  The BIGSEQ array
		                holds the number of minipages for each sequence
		                that needs multiple pages.
		                */

		                set DIREC="F"
		                set minipage=minipage.get()
	 	
				// Increase sequence if were on the last minipage.
				set pagenum=pagenum+1
	 
		                // NEXT
    		                
		                if BIGSEQ(SEQ).get()=minipage set SEQ=SEQ+1 set minipage=""
		               	if minipage.get()>0 set minipage=minipage+1
		
				}

			if (VFMQ<pagenum) do { quit
	
				// User has opted to go to the previous page
 	                         set DIREC="B"
	       	                 set pagenum=pagenum-1
	       	                 if minipage.get()>0 set minipage=minipage-1
 
	                        // Decrease sequence if on the first minipage, or if not on a minipage.
 
        	                // PREVIOUS
        	                if (minipage.get()=0)!(minipage.get()="") set SEQ=SEQ-1 set minipage=""

				}

			}

		if (VFMQ="F") do { quit:DONE
	
			do FILE
			set DONE=0
			if ER quit
			do END
			}

		if ER quit
		if DONE.get()=0,X="F" set X="N",ER=0
		if VFMQ="Q" set DONE=1 do END quit

		do START(TRNSET,SEQ)
		}
	
	if ER quit
	if (X="F")&(VFMQ="F") do { quit:DONE
		do FILE
		set DONE=0
		if ER quit
		do END
		}
	
	quit  	


START(TRNSET,SEQ)	//

	type Public Number ER,minipage,%MODS,%PAGE,pagenum,%PG,%REPEAT,TOTPAGES
	type Public String BIGSEQ(),BIGTNS(,),DIREC,TNS(),X
	
	type Number CNT,CNTB,LIM,MAX,N,PRI
	type String DESC,TRNFIELD,TYPE
	
	
	// Set up screen
	for N=1:1:9 set TNS(N).piece("|",13)=1
	set %ProcessMode=1 
	set MAX=9 
	set LIM=MAX
	
	/*
	Loop through the BIGTNS array to create the array TNS, which
	represents one sequence.
	*/

	set TRNFIELD=""
	set CNT=0 
	set CNTB=0
	if BIGSEQ(SEQ).exists() do {
		if minipage.get()="" do {
	
			// if not going backwards, use first minipage
			if DIREC.get()'="B" set minipage=1
			if DIREC.get()="B" set minipage=BIGSEQ(SEQ)
			}
		}

	/*
	 If we are on a minipage, calculate limit of entries for the page.
	 Also increase CNT so that we can create TNS entries 1, 2, 3 from
	 BIGTNS entries 10,11,12, for example.
	*/

	if minipage.get() do {
		set LIM=MAX*minipage
		set CNT=MAX*(minipage-1)
		}
	
	// Set up TNS array now.
	for  set TRNFIELD=BIGTNS(SEQ,CNT).order() quit:(TRNFIELD="")!(CNT=LIM)  do {
		set CNT=CNT+1 
		set CNTB=CNTB+1
		set TNS(CNTB)=BIGTNS(SEQ,CNT)
		}
	
	// Data entry
	type RecordUTBLTRNSET fUTBLTRN

	if CNT<MAX set CNT=MAX
	set %REPEAT=MAX

	// Starting array offset
	set %MODS=1		     

	// Call the screen program
	set %PG=pagenum
	set %PAGE=TOTPAGES
		
	set fUTBLTRN=Class.new("RecordUTBLTRNSET")
        set fUTBLTRN.trnset=TRNSET
        set fUTBLTRN.seq=SEQ

	do DRV^USID(%ProcessMode,"TRNSET",.fUTBLTRN)

	// File the data from the screen to the BIGTNS array
	do SCRFILE(SEQ)
	
	quit


BIGTNS	//
	
	/*
	Set up BIGTNS array
	This section sets up the BIGTNS array, which holds the entire
	Transaction Set.
	*/
	
	type Public Number TOTPAGES
	type Public String BIGSEQ(),BIGTNS(,),NEWSEQ
	
	type Number CNT,count,extrapgs,MAX,SEQ
	type String TRNFIELD
	
	set SEQ=""	
	set MAX=9 
	set TOTPAGES=10
	set TRNFIELD=""
	set CNT=0
	set count=0
	
	type DbSet rs=Db.selectDbSet("UTBLTRNSET","TRNSET=:TRNSET")

	while rs.next() do {
        	type RecordUTBLTRNSET trnset=rs.getRecord("UTBLTRNSET")

        	if SEQ'=trnset.seq do {
        		set count=1
			set CNT=0
        		set BIGSEQ(SEQ)=BIGSEQ(SEQ).get()+1
        		}

		set SEQ=trnset.seq
		set TRNFIELD=trnset.trnfield
		set CNT=CNT+1

		set BIGTNS(SEQ,CNT)=TRNFIELD_"|"_trnset.reftran_"|"_trnset.fixedval_"|"_trnset.tablecol_"|"_trnset.dte_"|"_trnset.tso_"|"_trnset.function_"|"_trnset.repeat_"|||"_trnset.diszero_"||"_trnset.prot
		if count>MAX do {

			/*
			If the number of transaction fields exceeds the maximum number
			we can have on the screen, we need to calculate the number of
			extra pages required, and set up entries in BIGSEQ array to
			keep track of which sequences get the extra screens.
			*/
			set extrapgs=(count/MAX).roundDec(0,"+")
			set BIGSEQ(SEQ)=BIGSEQ(SEQ).get()+extrapgs
			set count=1
			}
		set count=count+1	
		}
		
	quit


SCRFILE(SEQ)	// SCREEN FILER - file one sequence from TNS to BIGTNS

	type Public Number ER,MAX,minipage
	type Public String BIGTNS(,),TNS()

	type Number CNT,mini
	
	/*
	 The mini variable is used to correctly file information back
	 to BIGTNS for sequences that need more than one screen.
	*/
	
	set CNT="" 
	set mini=0
	if minipage.get()>1 do {
		set mini=(minipage-1)*MAX
		}
	
	// fILE TNS data back to BIGTNS array
	for  set CNT=TNS(CNT).order() quit:((CNT="")!(ER.get()=1))  do {
		set BIGTNS(SEQ,(mini+CNT))=TNS(CNT)
		}
		
	kill TNS
	
	quit
	

FILE	// Main filing section.  For each sequence, call FILE2.

	type Public Number ER
	type Public String BIGTNS(,),TNS()

	type Number CNT,SEQ

	// Create TNS array
	set SEQ=""

	// Loop through BIGTNS array
	for  set SEQ=BIGTNS(SEQ).order() quit:((SEQ="")!(ER.get()=1))  do {
		set CNT=""
		kill TNS
		for  set CNT=BIGTNS(SEQ,CNT).order() quit:((CNT="")!(ER.get()=1))  do {
			set TNS(CNT)=BIGTNS(SEQ,CNT)
			}

		// File each sequence (TNS array) to the global.
		do FILE2 
	
		if ER quit
		}
	quit
	

FILE2	// File data

	type Public Number ER,SEQ
	type Public String TNS(),TRNSET

	type Boolean delseq,gotcid,gotetc,gottamt
	type Number CNT,LEN
	type String REC,TRNFIELD,ZREC

	set CNT=""
	
	// Loop through the TNS array, performing edit checks for each transaction field.
	
	// These variables specify if the sequence contains CID,TAMT, and ETC.
	set gotcid=0 
	set gottamt=0 
	set gotetc=0
	type RecordUTBLTRNSET fUTBLTRN	
	// This variable specifies if the sequence should be deleted.
	set delseq=1
	for  set CNT=TNS(CNT).order() quit:((CNT="")!(ER.get()=1))  do {
		set REC=TNS(CNT)
		if REC.piece("|",9)=1 quit
		set TRNFIELD=REC.piece("|",1)
		if TRNFIELD="" quit
		set delseq=0
		if TRNFIELD="CID" set gotcid=1
		if TRNFIELD="TAMT" set gottamt=1
		if TRNFIELD="ETC" set gotetc=1
		set LEN=TRNFIELD.length()

		set ZREC=REC.extract((LEN+2),REC.length())
		set fUTBLTRN=Db.getRecord("UTBLTRNSET","TRNSET=:TRNSET,SEQ=:SEQ,TRNFIELD=:TRNFIELD",1)
		set fUTBLTRN.reftran=ZREC.piece("|",1)
		set fUTBLTRN.fixedval=ZREC.piece("|",2)
		set fUTBLTRN.tablecol=ZREC.piece("|",3)
		set fUTBLTRN.dte=ZREC.piece("|",4)
		set fUTBLTRN.tso=ZREC.piece("|",5)
		set fUTBLTRN.function=ZREC.piece("|",6)
		set fUTBLTRN.repeat=ZREC.piece("|",7)
		set fUTBLTRN.diszero=ZREC.piece("|",8)
		set fUTBLTRN.prot=ZREC.piece("|",12)

		do ^PROCTRNS(.fUTBLTRN)

		if ER quit
		}
	if ER quit

	// Transaction Set Sequence must contain CID,ETC, and TAMT
	if ((gotcid=0)!(gottamt=0)!(gotetc=0))&(delseq=0) do Runtime.setErrMSG("UTBLTRNSET",3616) quit
	if ER quit

	// If no errors were encountered, file each record.
	// do Db.delete("UTBLTRNSET","TRNSET=:TRNSET AND SEQ=:SEQ")
	for  set CNT=TNS(CNT).order() quit:CNT=""  do {
		
		type String ZREC
		
		set REC=TNS(CNT)
		set TRNFIELD=REC.piece("|",1)
		if TRNFIELD="" quit
		
		type RecordUTBLTRNSET utbltrnset=Db.getRecord("UTBLTRNSET","TRNSET=:TRNSET,SEQ=:SEQ,TRNFIELD=:TRNFIELD",1)
		if utbltrnset.getMode()=1 set %ProcessMode=1
		else  set %ProcessMode=0
				
		if REC.piece("|",9)=1 set %ProcessMode=3
				
		set LEN=TRNFIELD.length()
                set ZREC=REC.extract((LEN+2),REC.length())
                set fUTBLTRN=Db.getRecord("UTBLTRNSET","TRNSET=:TRNSET,SEQ=:SEQ,TRNFIELD=:TRNFIELD",1)
                set fUTBLTRN.reftran=ZREC.piece("|",1)
                set fUTBLTRN.fixedval=ZREC.piece("|",2)
                set fUTBLTRN.tablecol=ZREC.piece("|",3)
                set fUTBLTRN.dte=ZREC.piece("|",4)
                set fUTBLTRN.tso=ZREC.piece("|",5)
                set fUTBLTRN.function=ZREC.piece("|",6)
                set fUTBLTRN.repeat=ZREC.piece("|",7)
                set fUTBLTRN.diszero=ZREC.piece("|",8)
                set fUTBLTRN.prot=ZREC.piece("|",12)
		
		if %ProcessMode=3 do Db.delete("UTBLTRNSET","TRNSET=:TRNSET AND SEQ=:SEQ AND TRNFIELD=:TRNFIELD")			
		if %ProcessMode=0!(%ProcessMode=1) do fUTBLTRN.save()
		
		if ER quit
		}
	if delseq=1 do Db.delete("UTBLTRNSET","TRNSET=:TRNSET AND SEQ=:SEQ")
	quit


SEQPP1	// Sequence post processor

	type Public Number X
	
	// Sequence must be greater than 1
	if X=1 do Runtime.setErrMSG("TRNSETPTR",3609) quit

	// ~p1 already exists
	type ResultSet rs=Db.select("SEQ","UTBLTRNSET","TRNSET=:TRNSET AND SEQ=:X")
	if rs.next() do Runtime.setErrMSG("UTBLTRNSET",3019,"Sequence")
	
	quit


TRNPP1	// Transaction set creation post processor

	type Public Number X
	
	if X="" quit
	
	type RecordTRNSETPTR trnsetptr=Db.getRecord("TRNSETPTR","PTRNAME=:X",1)
	
	// ~p1 already defined as a transaction set pointer.
	if trnsetptr.getMode() do Runtime.setErrMSG("TRNSETPTR",4338,X)

	quit


TRNPP2	// Transaction set maintenance post processor

	type Public Number X
	
	if X="" quit
	
	type RecordTRNSETPTR trnsetptr=Db.getRecord("TRNSETPTR","PTRNAME=:X",1)
	
	// "~p1 is a transaction set pointer.  Please run function @TRNSETPTR02 to maintain this record"
	if trnsetptr.getMode() do Runtime.setErrMSG("TRNSETPTR",4339,X)
		
	quit


END	// End processing

	type Public Number DONE,ER
	type Public String VFMQ

	set DONE=1

	// Transaction Set fields not modified
	if VFMQ="Q" do Runtime.setErrMSG("UTBLTRNSET",3618)
	
	// Transaction set fields modified
	else  do Runtime.setErrMSG("UTBLTRNSET",3617)
	set ER="W"
	
	quit


NETAMT()	//
	/*
	   This is a dummy linetag.  Transaction sets can use $$NETAMT^TRNSET
	   as a net transaction function.  However, MRPC076 does the
	   computation.  Since this is a net amount, we cannot determine
	   the value until all sequences are evaulated, and this is done
	   at the end of MRPC076.
	*/

	quit ""

vSIG()	quit "60319^31525^Renga SP^11761"	// Signature - LTD^TIME^USER^SIZE
