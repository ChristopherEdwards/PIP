V00S464(%ProcessMode,)   // -  - SID= <SKLBFM> Data Item Batch File Maintenance Input
 ;;Copyright(c)2006 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/24/2006 12:04 - kini
  /*
ORIG: CHENARDP - 03/03/2003
DESC: PSL Screen Compiler Template

---- Comments --------------------------------------------------------
	This procedure is used as the base template for the PSL screen compiler.
	It is referenced by the PSL screen compiler - procedure DBS2PSL4
	
	
---- Revision History ------------------------------------------------
	02/23/06 - Pete Chenard - CR19551
		   Fixed routine label.
		   
	05/19/05 - Pete Chenard - CR 14146
		   Modified to type variables.
		   
	12/1/03 - Spier -cr7178
	   	     Modifications to correct dead code warnings and
	   	     other issues that occurred during mass compile of screens.

	09/24/03 - Pete Chenard - 45497
		       Created screen template for compiler.
----------------------------------------------------------------------

 */

 #WARN SCOPE OFF
	type Public String %MODS,%PAGE,%PG,%REPEAT,ER,RM
	type String KEYS(),KVAR,VFSN(),VO,VODFT,VPGM,vPSL,VSID,VSNAME

	// %O (0-Create  1-Modify  2-Inquiry  3-Delete  4-Print  5-Blank screen)

	set:'$D(%ProcessMode) %ProcessMode=5
 set KVAR="kill %TAB,VFSN,VO,VPTBL,vtab,GRP,QTYPE,DI,DDAT,NDV",VSID="SKLBFM",VPGM=$T(+0),VSNAME="Data Item Batch File Maintenance Input"
 set vPSL=1
 //
	// ==================== Display blank screen         (%O=5)

 if %ProcessMode=5 set %MODS=1,%REPEAT=14 do VPR(),VDA1(),V5^DBSPNT quit

 set ER=0 do VSCRPRE() if ER quit  // Screen Pre-Processor
 
 if '%ProcessMode do VNEW(),VPR(),VDA1()
 if %ProcessMode do VLOD() quit:$G(ER)  do VPR(),VDA1()

	// ====================  Display Form
	do ^DBSPNT()
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	if %ProcessMode=2!(%ProcessMode=3) do ^DBSCRT8A X:'$D(%PAGE) KVAR quit  // Inquiry/Delete
	// ====================  Set up data entry control table


 if %ProcessMode<2 do VTAB()
	quit


VNEW() // Initialize arrays if %O=0
 
 do VLOD()
 do VDEF()
 do VLOD()
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
	
VDEF()
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
VNEWDQ() // Original VNEW section
 
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
VLOD() // User defined access section
 //
 if '$D(%REPEAT) set %REPEAT=14
 if '$D(%MODS) set %MODS=1
 type public String DDAT(),DI(),NDV()
 type Number I
 for I=1:1:%REPEAT set DI(I)=DI(I).get(),DDAT(I)=DDAT(I).get(),NDV(I)=NDV(I).get()
 #ACCEPT date=11/05/03;pgm=Screen compiler
 quit
VLODDQ() //Original VLOD section
 
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


	type Public String %MODS,%REPEAT
	quit
	

VPR() // Display screen prompts
 set VO="7||13|"
 set VO(0)="|0"
 set VO(1)=$C(6,19,6,0,0,0,0,0,0,0)_"01TRemove"
 set VO(2)=$C(7,5,9,0,0,0,0,0,0,0)_"01TData Item"
 set VO(3)=$C(7,21,4,0,0,0,0,0,0,0)_"01TData"
 set VO(4)=$C(7,30,14,0,0,0,0,0,0,0)_"01TNew Data Value"
 set VO(5)=$C(8,5,9,0,0,0,0,0,0,0)_"01T---------"
 set VO(6)=$C(8,21,4,0,0,0,0,0,0,0)_"01T----"
 set VO(7)=$C(8,30,14,0,0,0,0,0,0,0)_"01T--------------"
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VDA1()  // Display screen data
 new V
 s DDAT=$G(DDAT)
 s DESC=$G(DESC)
 s DI=$G(DI)
 s GRP=$G(GRP)
 s NDV=$G(NDV)
 s QTYPE=$G(QTYPE)
 //
 set VO="12|8|13|"
 set VO(8)=$C(1,12,50,2,0,0,0,0,0,0)_"01T"_$G(DESC)
 set VO(9)=$C(4,5,0,1,0,0,0,0,0,0)_"01T"_" "_"["_CFID_"]GRP:"
 set VO(10)=$C(4,28,10,2,0,0,0,0,0,0)_"00T"_$G(GRP)
 set VO(11)=$C(5,4,0,1,0,0,0,0,0,0)_"01T"_" "_"["_CFID_"]TYPE:"
 set VO(12)=$C(5,28,10,2,0,0,0,0,0,0)_"00T"_$G(QTYPE)
  
 set:'$D(%MODS) %MODS=1 set VX=$P(VO,"|",2)+4,DY=9 for I=%MODS:1:%REPEAT+%MODS-1 do VRDA()
 set $piece(VO,"|",1)=VX quit  // EOD pointer
 
VRDA()  // Display data %REPEAT times
 //instantiate new object if necessary
 if %ProcessMode=5 new v2,v1,v3
 if  set (v2,v1,v3)=""
 else  new v2,v1,v3
 else  set (v2,DDAT(I))=$G(DDAT(I)),(v1,DI(I))=$G(DI(I)),(v3,NDV(I))=$G(NDV(I))
 
 set VO(VX+1)=$C(DY,5,12,2,0,0,0,0,0,0)_"00T"_v1
 set VO(VX+2)=$C(DY,23,1,2,0,0,0,0,0,0)_"00L"_$S(v2:"Y",1:"N")
 set VO(VX+3)=$C(DY,30,48,2,0,0,0,0,0,0)_"00T"_v3
 set DY=DY+1,VX=VX+3
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
	
	
VTAB()
 
 kill VSCRPP,REQ,%TAB,%MOD,%MODOFF,%MODGRP,%REPREQ,vtab set %MODGRP=1
 set %MODOFF=3,%MOD=3,%MAX=(%MOD*%REPEAT)+%MODOFF,VPT=1,VPB=8+%REPEAT,BLKSIZ=(61*%REPEAT)+70,PGM=$T(+0),DLIB="SYSDEV",DFID=""
 set OLNTB=VPB*1000
 
 for I=7:1:%MAX set %TAB(I)=""
	
	
 set %TAB(1)=$C(0,11,50)_"20T|*DESC|[*]@2"
 set %TAB(2)=$C(3,27,10)_"01T|*GRP|[*]@GRP|[STBLGRP]GRP:QU ""[STBLGRP]CLS=<<CLS>>"":DISTINCT||do VP1^V00S464()"
 set %TAB(3)=$C(4,27,10)_"01T|*QTYPE|[*]@77|||do VP2^V00S464()"
 set %TAB(4)=$C(8,4,12)_"00T|*DI(1)|[*]@101|||do VP3^V00S464()|do VP4^V00S464()"
 set %TAB(5)=$C(8,22,1)_"00L|*DDAT(1)|[*]@10|||do VP5^V00S464()|do VP6^V00S464()"
 set %TAB(6)=$C(8,29,48)_"00T|*NDV(1)|[*]@102|||do VP7^V00S464()|do VP8^V00S464()"
 do VTBL()
	do ^DBSCRT8 	// data entry
	quit


VREQ   // Create REQ() array
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


VTBL() //Create %TAB(array)
 	// 1 2 3  4 5   6   7-9 10-11
 	// DY,DX,SZ PT REQ TYPE DEL POS |NODE|ITEM NAME|TBL|FMT|PP|PRE|MIN|MAX|DEC

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit


  //user-defined post procs
 //
VP1() //
 type public String I(),V,X

 // Field entry req'd, let DQ handle
 quit:X.isNull()

 // Group is look-up sensitive and cannot be changed
 if CK.exists(),V'="ALL",X'="V" do Runtime.setErrMSG("DBTBL1D",1170) quit

 if X="ALL" set I(3)="" do CHK quit

 // If invalid entry, let DQ handle
 type RecordSTBLGRP stblgrp=Db.getRecord("STBLGRP","CLS='D',GRP=:X",1) 

 if 'stblgrp.getMode() quit

 quit


 // If error, set RM to indicate table entry requires GRP
 // Verify that no data items have been entered that req GRP to resolve
CHK ;

 // No group requirement defined
 if 'CK.exists() quit

 // Single group must be defined to resolve look-up
 do Runtime.setErrMSG("DBTBL1D",2511) quit

 quit
VP2() //
 type public String Q(),SAVE,SQTYPE,X
 
 if (X="ALL")!(X="") kill Q(2) quit

 // I18N=OFF
 set SAVE=X,X="["_CFID_"]TYPE "_X,SQTYPE=X

 // I18N=ON
 do ^DBSQRY

 set X=SAVE

 quit
VP3() //
 type public Boolean ER
 type public String CK(),GRP,OFID,X
 type public RecordDBTBL1D dbtbl1d
 type Number I
 type String KEYS,VAL,Z

 // If no input or REMOVE
 
 if X.isNull() do DELETE^DBSMACRO("@102","1","0")
 
 if  kill CK(z1) quit

 // Display error message if data item is restricted from maintenance
 type RecordUTBLBATCHFM utblbatchfm=Db.getRecord("UTBLBATCHFM","FID=:OFID,DI=:X",1)
 if utblbatchfm.getMode()  do Runtime.setErrMSG("UTBLBATCHFM",1082) quit

 // If already on screen, disallow
 // Unless, of course, you've returned to the orignal data input

 set VAL="" for I=1:1 set VAL=DI(VAL).order() quit:VAL.isNull()  if DI(VAL)=X,VAL'=z1 set ER=1,RM=$$^MSG(3018,X) quit

 // If not defined data item, allow DQ to handle error processing

 set dbtbl1d=Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=:OFID,DI=:X",1)
 if 'dbtbl1d.getMode() quit

 // File maintenance restricted on computed data item
 if dbtbl1d.nod="" do Runtime.setErrMSG("DBTBL1D",1084) quit

 // File maintenance restricted on access keys
 if dbtbl1d.nod["*" do Runtime.setErrMSG("DBTBL1D",1083) quit

 // Reset check flag
 kill CK(z1)
 
 set KEYS=dbtbl1d.tbl.piece("(",2)

 for I=1:1 set Z=KEYS.piece(",",I) quit:Z.isNull()  if Z'="GRP",Z.extract()'="""",Z'=+Z set ER=1 quit 
 //  File maintenance restricted.  Table look-up cannot be resolved

 if ER do Runtime.setErrMSG("DBTBL1D",1085) quit

 // If look-up required for group, disallow query group="ALL"
 if KEYS.length(),GRP="ALL" for I=1:1 set Z=KEYS.piece(",",I) quit:Z.isNull()  if Z="GRP" set CK(z1)=1 quit

 quit
VP4() //
 type public String I()

 set I(3)="[DBTBL1D]DI,DES:QU  ""[DBTBL1D]%LIBS="""""_LIB_""""""""

 set I(3)=I(3)_","_"""[DBTBL1D]FID="""""_OFID_""""""""

 quit
VP5() //
 type public RecordDBTBL1D dbtbl1d
 type public Number NI
 type public String CK(),DI(),GRP,RM,X

 if 'dbtbl1d.getMode() quit

 // If data item requires GRP to resolve look-up set flag to exception.
 if X set NI=NI+1,RM=$$^MSG(791,DI(z1))
 if  do DELETE^DBSMACRO("@102","1","0")
 if  quit

 // Single group must be defined to resolve look-up table
 if GRP="ALL",CK(z1).exists() do Runtime.setErrMSG("DBTBL1D",2511) quit

 quit
VP6() //
 type public String DDAT

 set DDAT="N"

 quit
VP7() //
 type public String CK(),DI(),GRP,X

 // Single group must be defined to resolve look-up table 
 if GRP="ALL",CK(z1).exists() do Runtime.setErrMSG("DBTBL1D",2511) quit

 // Delimiters (e.g., vertical bar) and characters (e.g., quotat
 if X["|"!(X["""") do Runtime.setErrMSG("DBTBL1D",517) quit

 // Remove data or enter new data value for all data items
 if X="",DI(z1).length(),'DDAT(z1) do Runtime.setErrMSG("DBTBL1D",2364) quit

 if DI.get()="INDEX" do ^UINDX

 quit
VP8() //
 type public String DDAT()
 type public String DI()
 type Number E67
 type String E8,I()

 if 'DDAT(z1) set DDAT(z1)=""
 set DI=$G(DI(z1)) Q:DI.isNull()

 // Remove data selected.  New data value not allowed.
 if DDAT(z1) do Runtime.setErrMSG("DBTBL1D",2365) quit

 // Set variable DIVAL equal to files def for selected data item.
 type RecordDBTBL1D dbtbl1d=Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=:OFID,DI=:DI",1)
 if 'dbtbl1d.getMode() quit

 // Re-define variables for DBSCRT8, using entries from files definitions
 // (above), the variables replace the values extracted from %TAB.

 set I(3)=dbtbl1d.tbl ;  Look-up table
 set I(7)=dbtbl1d.min ; Minimum value 
 set I(8)=dbtbl1d.max ; Maximum value
 set I(9)=dbtbl1d.dec ; Decimal Precision
 set E8=dbtbl1d.typ   ;    Type (T,D,$,N...
 set E67=dbtbl1d.len  ;   Length

 quit
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit								// User defined post processor's


VRV(V,L) quit V_$J("",L-$L(V))
VREPRNT
 do VPR()
 do VDA1()
 do ^DBSPNT()
 quit

VW()
 do VDA1()
 do ^DBSPNT(10)
 quit

VDAPNT()
 do VDA1()
 do ^DBSPNT(0,2)
 quit

VDA
 do VDA1()
 quit

	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
 
vSET(sn,di,X)
 #ACCEPT Date=11/5/03;PGM=Screen Compiler
 quit
	
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
vREAD(fid,di)
 quit ""
	#ACCEPT DATE=11/05/03; PGM=Screen Compiler
	quit
 //
VSCRPRE()  // Screen Pre-Processor
 new %TAB,vtab // Disable .MACRO. references to %TAB()
 //
 type public String GRP,QTYPE
 set GRP="ALL",QTYPE="ALL"
 #ACCEPT date=11/05/03;PGM=Screen Compiler
 quit
