RETP	// Return Payed Items
	/*
	    ORIG:  Mindy Gill   02/19/93
	    DESC:  This routine will credit an account for inclearing debit
	           items originally payed (i.e., posted to account) that the
	           user has subsequently decided to return using function
	           RET001.  This routine is called by function RET004.

	           This routine will scan the Return Item Exception file [RET]
	           for accounts that were originally paid ([RET]ORET=0) that
	           were selected for return ([RET]RET=1).  The process will
	           create a TTX batch to post credit transactions to the
	           account for the items returned.  If [RET]CHG is "Y" the
	           process will use the account's Service Fee Plan to
	           determine the service charge amount.  If applicable a TTX
	           entry will be created for the service charge debit to the
	           account.
	           See detail specifications for CDW0984  Return Item
	           Processing for more details.

	---- Revision History ------------------------------------------------
	
	02/15/07 - RussellDS - CR25382
		   Eliminated use of obsoleted routine DBSQRYA.
	
	03/14/05 - SmithCD - CR 13782
		   . Modified call to %EXT^TTXPOS in EXEC section to pass 
		     %ProcessID, BOO, and BOFFRTLR instead of cuvar object, 
		     and moved the call within the TOTB array loop (replaces 
		     code that updated ^T global usage in the p01 version that 
		     was never converted)
		   . Added /HLP attribute in %TAB for fields that didn't have 
		     one specified
		   . Removed unnecessary Db.getRecord on trn table usage in 
		     FEECR section (second call in that section)
		   . Added additional parameters to BATCH and FEECR sections 
		     to avoid multiple declarations on variables
		   . Changed declaration of several variables throughout to 
		     to be public to prevent undefined errors
		   . Corrected parameters passed to BLDTR^TTXOFST
		   . Replaced $$Q2SQL^SQLCONV call with $$WHERE^SQLCONV to 
		     prevent undefined error (Q() is not in the format 
		     expected by the Q2SQL function)
		   . Cleaned up compiler warnings
	
	12/29/03 - CARROLLJ - CR7658
		   Corrected precedence error in BATCH section.

	06/05/03 - GRAY - 51351
		   Converted to PSL.  Removed OFFSET section.

	*/

	type public Number ER

	type Date PJD
	type String BCC, BOFFRTLR, CRTRCD, GLACN, VFMQ

	catch vERROR {
		do ZT
	}

	do INIT if ER set VFMQ = "Q"

	if VFMQ = "Q" do END quit

	do EXEC

	quit


INIT	// Initialize variables and get user input
	
	type public Date PJD
	type public Number ER
	type public String BCC, BOFFRTLR, CRTRCD, GLACN, VFMQ

	type Number %PAGE, %PG
	type String %READ, %TAB, OLNTB

	set (%PAGE,%PG) = 0

	// will default Branch Code prompt to "ALL"
	set BCC = "ALL"
	set %TAB("PJD") = ".RETPD/HLP=[RET]TJD/TBL=[RET]TJD:DISTINCT/XPP=do PPPJD^RETP"
	set %TAB("BCC") = ".A5/HLP=[RET]OBRCD/TBL=[UTBLBRCD]/XPP=do EXT^DBSQRY"
	set %TAB("EFD") = ".EFD1/HLP=[EXC]EFD/XPP=do PPEFD^RETP"
	set %TAB("CRTRCD") = ".TRN1/HLP=[TRN]ETC/TBL=[TRN]/XPP=do PPCRTRCD^RETP"

	set %READ = "@@%FN,,,PJD/REQ,BCC/REQ,EFD/REQ,CRTRCD/NOREQ"

	do ^UTLREAD if VFMQ = "Q" quit

	// Get the back office source teller for return items
	do SOURCE^BCHSOURC("BOFF", "RET", .BOFFRTLR)
	if ER do LOGERR quit
	
	type RecordSCAU scau = Db.getRecord("SCAU", "UID=:BOFFRTLR")

	set GLACN = scau.tsdr_"|TSDR||||Return"

	quit


EXEC	// Collate Return File to process returns
	/*

	   . INPUT:
	       BCC   Branch code specified by the user, returns  /REQ/TYP=N
	             processed will be limited to the accounts
	             owned by this branch.

	*/

	type public Date PJD
	type public String BCC, BOFFRTLR, DQQRY(), GLACN
	type public Number ER

	type Number BOO, BRCD, CID, TSEQ
	type String %UserID, WHERE, QWHERE, TOTB(,,)
	
	set WHERE = "TJD=:PJD"

	if (BCC '= "ALL") do { quit:ER
		set DQQRY(1) = "[RET]OBRCD "_BCC
		set WHERE = WHERE_" AND "_$$WHERE^SQLCONV(.DQQRY(), "RET") quit:ER
		}

	#ACCEPT DATE=9/5/03; PGM=Shaun Gray; CR=unknown; Group=Dynamic
	type DbSet ds = Db.selectDbSet("RET", WHERE, "OBRCD")
	
	while ds.next() do {
		type RecordRET ret = ds.getRecord("RET")
		
		set BOO = ret.obrcd
		set ER = 0
		set BRCD = ret.brcd
		set CID = ret.cid
		set %UserID = ret.uid
		set TSEQ = ret.tseq
		
		do PROCRET(.ret,CID)
		}

	/* 
	Collate TOB array (keyed by - crcd,BOO,occ) and create TOT entries
	(keyed by - crcd,BOFFRTLR,"*",occ), which is used by OFFSET^UMSC to
	create one offset entry per BOO.  
	*/

	if TOTB.data() do {
		type Number BOO, OCC
		type String CRCD

		set (CRCD, BOO, OCC) = ""
		for  set CRCD = TOTB(CRCD).order() quit:CRCD.isNull()  do {
			for  set BOO = TOTB(CRCD, BOO).order() quit:BOO.isNull()  do {
				for  set OCC = TOTB(CRCD, BOO, OCC).order() quit:OCC.isNull()  do {
					type String TOT(,,,,)
					
					do %EXT^TTXPOS(%ProcessID, BOO, BOFFRTLR, PJD)

					set TOT(CRCD, BOFFRTLR, "*", OCC) = GLACN
					set TOT(CRCD, BOFFRTLR, "*", OCC, 0) = TOTB(CRCD, BOO, OCC)
					do OFFSET^UMSC(%SystemDate, BOO, BOFFRTLR, "TOT", 0)
					}
				}
			}
		}

	quit


PROCRET(RecordRET ret, Number CID)

	type public Number TAMT = ""

	// Process return for the item from Return File.

	// already processed
	if ret.retind = "*" quit

	type Number BAL, ER = 0
	type String ET, RM

	/*
	Original Return Flag
	Process the current item for RETURN (credit) if item was originaly
	paid ([RET]ORET=0) and is set up to be returned ([RET]RET=1).
	*/

	quit:'ret.ret ! (ret.oret)

	type RecordDEP dep = Db.getRecord("DEP", "CID=:CID", 1)

	// Record not on file
	if 'dep.getMode() do Runtime.setErrSTBLER("DEP", "RECNOF") do LOGERR quit

	// Create the ^TTX entries
	do BATCH(.dep, .ret, %UserID)

	// Log the error
	if ER set BAL = dep.bal do LOGERR quit

	/*
	Mark the item with an "*" indicating that it has been processed by
	Return Payed Items process.
	*/	
	set ret.retind = "*"
	do ret.save()

	// Update the return counters.
	do RET^DEPNSF(.dep, TAMT)
	
	do dep.bypassSave()

	quit


BATCH(RecordDEP dep, RecordRET ret, String %UserID)

	/*
	Create TTX batch for posting the credit transaction to the account.
	
	If charge option [RET]CHG for the current item is "Y" and Service Fee
	Plan for the account is set up for charging return (RET) fee, create
	a TTX entry to post service charge debit transaction.
	The ^TTX batch will be created using the back office source teller for
	return items (BOFFRTLR).
	*/

	type public Cache %CACHE()
	type public Date PJD 
	type public Number BOFFRTLR, BOO, BRCD, ER, TAMT, TSEQ
	type public String CRTRCD, RM, TOTB(,,)

	type Boolean CHG, PBK
	type Number AMT, BAMT, CHKTYP, MULTIPLY, OCC, RATE, SEQ, TYPE
	type String CCODE, CRCD, CRCDBASE, ETC, ITC, TCMT, TSO
	type RecordTTX ttx()

	set SEQ = Db.currVal("TTX", "TJD=:%SystemDate,BRCD=:BOO,UID=:BOFFRTLR")
	set SEQ = (((SEQ \ 1000) + 1) * 1000) + 1

	set TYPE = dep.type

	set CRCD = dep.crcd
	if CRCD.isNull() set CRCD = %SystemCurrency

	// user specified credit transaction code
	set ETC = CRTRCD.get()

	/* 
	If transaction code was not provided by the user use the general
	purpose credit transaction code for product type
	*/		
	if ETC.isNull() do {
		type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:TYPE")
		set ETC = prodctl.crtrgp
		}

	// External transaction code not defined
	if ETC.isNull() do Runtime.setErrMSG("PRODCTL", 6655) quit

	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")

	// Invalid transaction code ~p1	
	if trn.etc.isNull() do Runtime.setErrMSG("TRN", 1498, ETC) quit

	// Internal Transaction Code
	set ITC = trn.itc

	// Credit for return item
	set TCMT = $$^MSG(1358)

	type RecordEXC exc = Db.getRecord("EXC", "TJD=:PJD,BRCD=:BRCD,UID=:%UserID,TSEQ=:TSEQ", 1)
	if 'exc.getMode() quit

	// Set other variables expected by BLDTR^TTXOFST to set in transaction

	set (TAMT,AMT) = exc.tamt
	set TSO = exc.tso
	set BAMT = exc.bseamt
	set CCODE = exc.custcd
	set CHKTYP = exc.chktyp
	set CRCDBASE = CRCD 
	set MULTIPLY = exc.mult 
	set RATE = exc.rate 
	set PBK = 1

 	set OCC = dep.cc

	if OCC.isNull() do {
		type RecordUTBLBRCD utblbrcd = %CACHE("BRCD").getRecord("UTBLBRCD", "BRCD=:BOO")
		set OCC = utblbrcd.ccdef
		}
	
	set %UserID = BOFFRTLR
	
	set ttx(SEQ) = Class.new("RecordTTX", "TJD=:%SystemDate,BRCD=:BOO,UID=:%UserID,TSEQ=:SEQ")

	do BLDTR^TTXOFST(.ttx(), SEQ)

	do ttx(SEQ).save()

	// Set up to create the offsetting credit transaction to a GL account
	set TOTB(CRCD, BOO, OCC) = TOTB(CRCD, BOO, OCC).get() + TAMT

	// Charge Option
	set CHG = ret.chg

	// Charge return item fee if applicable
	if CHG do RETFEE(.dep)

	quit


RETFEE(RecordDEP dep)	// Return Item Fee

	/*
	Execute the service fee plan on account to determine the FEEAMT
	associated with RETurn item fees.  Create transactions if applicable to:

	     . Debit customer account
	        -  Transaction code:
	           [DTYPE]DRTRRC - Dr B/Off TC (O/D Fees (Fee Plan)
	           If [DTYPE]DRTRRC is not specified
	            then [DTYPE]DRTRGP -  Dr B/Off TC (General Purpose)

	     . Credit miscellaneous fee account
	        -  Transaction code:
	           [DTYPE]ODTC1  O/D Fee Offset Tran Code
	           If [DTYPE]ODTC1 is not set then use "MCR"


	*/

	type public Number CHGOPT, CID, FEEAMT
	type public Date %EffectiveDate

	type String CRCD, FEEPLN, FEETYP, PGM

	kill FEEAMT 

	// Currency Code
	set CRCD = dep.crcd
	if CRCD.isNull() set CRCD = %SystemCurrency

	// Service Fee Plan
	set FEEPLN = dep.feepln
	quit:FEEPLN.isNull()
	
	set FEETYP = "RET"

	// Find service fee program
        set PGM = $$FEEPGM^UFID(dep.feepln, %EffectiveDate)
 
        // Service fee program not compiled
        if PGM.isNull() do Runtime.setErrMSG("DEP", 2481, dep.feepln) quit
        set PGM="^"_PGM_"(.dep,2,"_FEETYP_",1,0)"

	do @PGM 
	set FEEAMT = FEEAMT.get() 
	if 'FEEAMT quit

	if CHGOPT - 1 set FEEAMT = 0 quit

	do FEEDR(.dep)

	do FEECR(.dep, CID)

	quit


FEEDR(RecordDEP dep)	// Debit customer account

	type public Boolean PBK
	type public Cache %CACHE()
	type public Date %EffectiveDate
	type public Number BOO,CHKTYP,CID,ER,FEEAMT,MULTIPLY,RATE,SEQ,TYPE
	type public String BOFFRTLR,CCODE,CRCD,CRCDBASE,FEETYP,RM
	
	type String %UserID, ETC,ITC,TCMT,TSO
	type Number AMT,BAMT,TAMT

	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:TYPE")

	set ETC = prodctl.drtrrc
	if ETC.isNull() set ETC = prodctl.drtrgp

	// Invalid transaction code ~p1
	if ETC.isNull() do Runtime.setErrMSG("TRN", 1498, ETC) quit

	set (TAMT, AMT, BAMT) = FEEAMT
	set TSO = ""
	set TCMT = "FEE-"_FEETYP

	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")

	// Invalid transaction code ~p1
	if 'trn.etc.isNull() do Runtime.setErrMSG("TRN", 1498,ETC) quit

	// Internal Transaction Code
	set ITC = trn.itc

	kill CHKTYP

	set SEQ = SEQ + 1
	
	set %UserID = BOFFRTLR
	
	type RecordTTX ttx()
	set ttx(SEQ) = Class.new("RecordTTX", "TJD=:%SystemDate,BRCD=:BOO,UID=:%UserID,TSEQ=:SEQ")
	
	/* 
	The transaction built in BLDTR^TTXOFST requires the following
	variables be defined: 	
		ETC,ITC,SEQ,AMT,TCMT,TSO,EFD,CRCD,BAMT,CCODE
		CHKTYP,CRCDBASE,MULTIPLY,RATE,PBK
	*/

	do BLDTR^TTXOFST(.ttx(), SEQ)

	do ttx(SEQ).save()

	quit


FEECR(RecordDEP dep, Number CID)	// Credit miscellaneous fee account

	type public Boolean PBK
	type public Cache %CACHE()
	type public Date %EffectiveDate
	type public Number AMT, BAMT, BOO, CHKTYP, ER, FEEAMT, MULTIPLY, RATE
	type public Number SEQ, TAMT, TSCRCID, TYPE
	type public String BOFFRTLR, CCODE, CRCD, CRCDBASE, GLSC, RM, %UserID
	
	type String ETC, ITC, TCMT, TSO

	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:TYPE")

	set ETC = prodctl.odtc1
	if ETC.isNull() set ETC = "MCR"

	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:ETC")

	// Internal Transaction Code
	set ITC = trn.itc

	set TSO = "TFR#"_CID		// Customer's account number

	// Default Account Number
	set CID = +trn.acn 

	if 'CID, 'GLSC.get().isNull() do {  
		type RecordUTBLGLSC utblglsc = Db.getRecord("UTBLGLSC", "GLSC=:GLSC", 1)
		set CID  =utblglsc.dglf
		}

	if 'CID set ETC = "TSCR" set CID = TSCRCID

	set SEQ = SEQ + 1

	type RecordTTX ttx()
	set ttx(SEQ) = Class.new("RecordTTX", "TJD=:%SystemDate,BRCD=:BOO,UID=:%UserID,TSEQ=:SEQ")

	/* 
	The transaction built in BLDTR^TTXOFST requires the following
	variables be defined: 	
		ETC,ITC,SEQ,AMT,TCMT,TSO,EFD,CRCD,BAMT,CCODE
		CHKTYP,CRCDBASE,MULTIPLY,RATE,PBK
	*/

	do BLDTR^TTXOFST(.ttx(), SEQ)

	do ttx(SEQ).save()

	quit


END	// Return Paid Items process complete
	
	type public String ER, RM, VFMQ

	quit:VFMQ="Q"

	// Return paid items process complete
	set RM = $$^MSG(1943)
	set ER = "W"

	quit


private	PPPJD

	// Post-Processor for Return Item Processing date prompt, default
	// effective date (EFD)

	type Public Date X

	quit:X.isNull()

	do DEFAULT^DBSMACRO("@EFD", X, 0)

	quit


private	PPEFD	// Post-Processor for Effective date prompt.

	/*
	The effective date must fall between Return Item Processing Date (PJD)
 	and system date
	*/

	type public Date PJD, X
	type public String RM

	quit:X.isNull()

	// Effective date must fall within the range: ~p1-~p2
	if (X < PJD) ! (X > %SystemDate) do Runtime.setErrMSG("EXC", 1232, PJD.toString()_"~"_%SystemDate.toString()) quit

	quit


PPCRTRCD	// Post Processor for Credit Transaction Code prompt
	/*
	Make sure that the debit/credit indicator in the trancode table for
	the trancode selected is set to credit.
	*/

	type public Number ER
	type public Cache %CACHE()
	type public String RM, X

	quit:X.isNull()
	
	type RecordTRN trn = %CACHE("TRN").getRecord("TRN", "ETC=:X")

	// Transaction code for ~p1 must be a credit
	if 'trn.dc do Runtime.setErrMSG("TRN", 2695, X) quit

	quit


ZT	// Mumps error
	
	type public Number %ZTSEQ
	type public String ET
	
	type Number %ZTHALT

	// Log MUMPS error
	set %ZTHALT = 0 do ZE^UTLERR

	// Error log sequence number ~p1
	if %ZTSEQ.exists() set %ZTSEQ = $$^MSG(3389,%ZTSEQ)

	// Error in account, not processed
	set ET = $$^MSG(3511)

	do LOGERR

	quit


LOGERR	// Log error in exception file

	type public Number BAL, CID, %ZTSEQ
	type public String ET, RM

	do LOG^UTLEXC(%RoutineName, "*", RM.get(), CID.get(), %ZTSEQ.get(), ET.get(), +BAL.get())

	kill ET, %ZTSEQ

	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60712^46298^Dan Russell^13693"	// Signature - LTD^TIME^USER^SIZE
