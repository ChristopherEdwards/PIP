public SCAUCID(Number MODE)	// Host-based ACN/CIF block manager

	/*
	   ORIG:	CHISARICKD - 09/06/94
	   DESC:	Host-based ACN/CIF block manager

	   Permits the manual updating of available account and customer
	   information file numbers for individual branches by the host.
	   Can also be used as a query tool to check free numbers remaining
	   on a branch computer.
	 
	   KEYWORDS:	
	  	   	CIF,FRONT ENDS
	 
	   EXAMPLES:
	  		D ^SCAUCID(1)
	  		D ^SCAUCID(2)
	 
	------------ Revision History ---------------------------------------
	
	10/17/06 - KELLYP - CR 22092
		   Modified UPHOST and ADDBLOCK sections to correct logic
		   and conform to current PSL standards.  These sections
		   were not saving the UTBLNXTCID and UTBLNCID records
		   they were modifying/creating.
	
	05/22/06 - MBUIM - CR 21308
		   Modified variable names for UTBLNXTCID, UTBLNCID and 
		   UTBLNCIDT records to unxtcid, uncid and uncidt resp. to
		   be less than 8 characters long. This was a problem because
		   GT.M truncated after 8 characters and there was a second 
		   variable that also started with utblnxtc.
		   
	03/01/06 - chhabris - CR 19780
		   Removed the Temp tables ZINVACN,ZINVCID (Created by 
		   Db.createSchema) and used TMPRPT1 instead of the TEMP
		   tables.
		   
	11/10/04 - MBUIM - CR 13086
		   Converted to PSL
	
	04/07/98 - Terrie Dougherty - 26685
	  	   Removed calls to SKL-LOAD and replaced with SQL calls.
	  	   Removed old change history.
	 
	03/11/97 - mjr - ARQ#  23471
	  	   Fix offline problems
	---------------------------------------------------------------------

	*/
	type public String OLNTB,TMPTBL
	type public Number HIADD,HIRANGE,LOADD,LORANGE,TMPBRCD
	type String %TAB(),%READ,ALLOCSIZ,LOCTBL(),TBLNAM(),TMPKILLF,VFMQ
	
	kill OLNTB
	
	// Create ACN Numbers 
	set LOCTBL(1)=$$^MSG(7506) 
	
	// Create CIF Numbers
	set LOCTBL(2)=$$^MSG(7507)
	
	// These are INDICES-DO NOT TRANSLATE!
	set TBLNAM(1)="ACN" 
	set TBLNAM(2)="CIF"	
	
	/*
	 PROMPTS:
	 .ALSIZ    = Allocation Size;       .BRCD1 = Branch Code
	 .HIRNG    = High Range; 	    .LORNG = Low Range
	 .OPT1     = Option;	            .BRFRE = Unused numbers at branch
	 .AUTHCODE = Enter authentication code
	*/

	// Prompts common to both screens 
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
	
	// Get default block size to allocate
	set ALLOCSIZ=cuvar.cidblk     
	set %TAB("OPTION")=".OPT1/REQ/TBL=LOCTBL(/XPP=D OPTPP^SCAUCID"
	set %TAB("BRCD")=".BRCD1/REQ/TBL=[UTBLBRCD]/XPP=D BRFREPP^SCAUCID"
	set %TAB("HIRANGE")=".HIRNG/PRO"
	set %TAB("LORANGE")=".LORNG/PRO"
	set %TAB("BRFRE")=".BRFRE/PRO"
	set %TAB("KILLF")=".FREEUSED/XPP=D KILLPP^SCAUCID"
	set %TAB("ALLOCSIZ")=".ALSIZ/REQ/XPP=D ALPP^SCAUCID"
	set %TAB("STARTNUM")=".STARTNUM/REQ"
	set %TAB("ENDNUM")=".ENDNUM/REQ"
	set %TAB("AUTHCODE")=".AUTHCODE/XPP=D AUTHPP^SCAUCID/REQ"

	// Prompts used for HOST allocation screen
	if MODE=1 set %READ="@@%FN/REV/CEN,,OPTION,BRCD,ALLOCSIZ,KILLF,,BRFRE,LORANGE,HIRANGE"
	
	// Prompts used for BRANCH allocation screen	
	if MODE=2 set %READ="@@%FN/REV/CEN,,OPTION,BRCD,STARTNUM,ENDNUM,AUTHCODE,KILLF,,BRFRE"	
	// Special UTLREAD code for mode 3
	if MODE=3 do { quit
		// Prompts used for manual block generation screen
		set %TAB("ALLOCSIZ")=".ALSIZ/REQ/XPP=D UPDMALOC^SCAUCID"
		set %TAB("CHECKSUM")=".CHECKSUM/PRO"
		set %READ="@@%FN/REV/CEN,,OPTION,ALLOCSIZ,,LORANGE,HIRANGE,,CHECKSUM"
		do ^UTLREAD
		if VFMQ="F" do UPHOST(TMPTBL,(HIRANGE+1))
		}	
	// UTLREAD for modes 1 and 2
	do ^UTLREAD
	if VFMQ="F" do {
		do UPHOST(TMPTBL,(HIADD+1))
		do ADDBLOCK(LOADD_"|"_HIADD,TMPBRCD,TMPTBL,TMPKILLF)
		}
	quit

UPDMALOC	// Post-processor to update the manual allocation fields

	type public Number HIRANGE,LORANGE,OPTION
	type public Boolean ER
        type Number ZCHKSUM,ZRANGE
	
	// Call original ALLOCSIZ post-processor
	do ALPP 
	quit:ER ""
	set ZRANGE=LORANGE_"|"_HIRANGE
	
	// Update the authorization code field
	set ZCHKSUM=$$AUTHRNG^UFETCH(ZRANGE,OPTION)
	do DISPLAY^DBSMACRO("@CHECKSUM",ZCHKSUM)
	
	quit
	
AUTHPP	// Post-processor to verify that correct authorization code was entered

	type public Number ENDNUM,HIRANGE,LORANGE,OPTION,STARTNUM,X
	type public String RM
	type public Boolean ER
	type Number CHECKSUM,USERCODE
	
	// X is raw input from AUTHCODE
	set USERCODE=X
	set CHECKSUM=$$AUTHRNG^UFETCH(STARTNUM_"|"_ENDNUM,OPTION)
	
	// Invalid number range or authorization code
	if (X'=CHECKSUM)!(X=0) set ER=1 set RM=$$^MSG(7716)
	
	// Restore X for UTLREAD to process
	set X=USERCODE
	set LORANGE=STARTNUM 
	set HIRANGE=ENDNUM
	
	quit

ALPP	// Post-processor to update Hi and Lo ranges after ALLOCSIZ is entered

	type public String RM,TMPTBL
	type public Number HIRANGE,LORANGE,X
	type public Boolean ER
	type String FULLRNG
	
	/*
	 Low Range is the pointer to the Branch's Local table of free numbers
	 X is the raw input from ALLOCSIZ.  X+Low Range = High Range
	*/
	
	// Block size must be at least 1
	if X<1 set ER=1 set RM=$$^MSG(7532) quit
	
	if TMPTBL="ACN" set FULLRNG=$$ACNBLOCK^UFETCH()
	else  set FULLRNG=$$CIFBLOCK^UFETCH()
	
	set LORANGE=FULLRNG.piece("|",1) 
	set HIRANGE=LORANGE+X-1
	
	// Update the screen to reflect the current values
	do DISPLAY^DBSMACRO("@LORANGE",LORANGE)
	do DISPLAY^DBSMACRO("@HIRANGE",HIRANGE)
	
	quit

BRFREPP	// Post-processor to inform user of number of unused numbers remaining

	type public String RM,TMPTBL
	type public Number BRFRE,X
	type public Boolean ER
	
	set BRFRE=0
		
	// X is the raw output from Branch Number. 
	// Invalid branch code
	if 'Db.isDefined("UTBLNXTCID","TYPE=:TMPTBL,BRCD=:X") set ER=1 set RM=$$^MSG(1273) quit
	
	type RecordUTBLNXTCID utblnxtcid=Db.getRecord("UTBLNXTCID","TYPE=:TMPTBL,BRCD=:X")
	
	set BRFRE=utblnxtcid.cnt
	
	do DISPLAY^DBSMACRO("@BRFRE",BRFRE)
	
	quit

OPTPP	// Post-processor to verify that the table selected is available

	type public Boolean ER
        type public String RM,TBLNAM(),TMPTBL,X
        type String UTBLNCIDT()
	
	// X is raw output from Option.  
	// Invalid entry ~p1	
	if 'TBLNAM(X).exists() set ER=1 set RM=$$^MSG(5791) quit
	
	set TMPTBL=TBLNAM(X)
	type RecordUTBLNCIDT utblncidt=Db.getRecord("UTBLNCIDT","TYPE=:TMPTBL")
	
	Lock +UTBLNCIDT(TMPTBL):5
	
	// Required table not available
	else  set ER=1 set RM=$$^MSG(7508)
	
	quit

KILLPP	// Kill post-processor.  Extracts information needed to add blocks
	
	type public Number BRCD,HIADD,HIRANGE,LOADD,LORANGE,TMPBRCD,X 
	type public String TMPKILLF
	
	set HIADD=HIRANGE 
	set LOADD=LORANGE 
	set TMPBRCD=BRCD
	
	// X is the raw output from KILLF
	set TMPKILLF=$select(X=1:1,1:0)
	
	quit

public ADDBLOCK( String RANGE,	// Range of numbers "LOWNUM|HIGHNUM" to be added to the branch.	/TYP=N/REQ/MECH=VAL	
	  Number BRCD,	// Branch code of branch to have numbers added t0.		/TYPE=N/REQ/MECH=VAL		
	  String TABLE,	// Which table to add to.  Currently "ACN" or "CIF"		/TYPE=T/REQ/MECH=VAL
	  Boolean KILLF)// ill Flag; Set to 1 removes used numbers from branch database	/TYPE=N/REQ/MECH=VAL
	  
	/*
	   Adds a range of new numbers to branch
	   Takes the listed parameters, and optionally kills off all previous
	   numbers from the database.  Updates BRANCH "remaining" count, and
	   initalizes newly created accounts.  DOES NOT update HOST pointers.
	 
	   Example:
	  			  ADDBLOCK("100|150",0,"ACN",1)
	*/
	
	type Number ADDCOUNT,INDEX,LAST
	
	type RecordUTBLNXTCID unxtcid = Db.getRecord("UTBLNXTCID","TYPE=:TABLE,BRCD=:BRCD",1)
	
	/* 
	 Kill all "free" accounts between start of list and system pointer to
	 next free number
	*/
	if KILLF=1 do {
	
		set LAST = unxtcid.ncid

		type DbSet ds = Db.selectDbSet("UTBLNCID","TYPE=:TABLE AND BRCD=:BRCD AND CID<:LAST","CID ASC")
		while ds.next() do {
			type RecordUTBLNCID uncid = ds.getRecord("UTBLNCID")
			if uncid.used = 1 do Db.delete("UTBLNCID","TYPE=:TABLE AND BRCD=:BRCD AND CID=:uncid.cid")
			}

		/* 
		 In case of unused numbers behind the "next number" 
		 pointer, move "next number" pointer to start of the
		 list of free accounts.
		*/
		type ResultSet rsINDEX = Db.select("CID","UTBLNCID","TYPE=:TABLE AND BRCD=:BRCD","CID ASC")
		if rsINDEX.next() do {
			set unxtcid.ncid = rsINDEX.getCol("CID")
			do unxtcid.bypassSave()
			}
		}
		
	set INDEX=RANGE.piece("|",1) 
	set LAST=RANGE.piece("|",2)
	set ADDCOUNT=(LAST-INDEX)+1

	set unxtcid.cnt = unxtcid.cnt + ADDCOUNT
	
	do unxtcid.bypassSave()

	for INDEX=INDEX:1:LAST do {
		type RecordUTBLNCID utblncid = Db.getRecord("UTBLNCID","TYPE=:TABLE,BRCD=:BRCD,CID=:INDEX",1)
		set utblncid.used = 0
		do utblncid.bypassSave()
		}

	quit

public BPTRINIT
	/*
	   Branch pointer initalization - DO NOT RUN THIS!
	   
	   Algorithm 1 - Loop thru all acount numbers, get the product type and
	   currency code (use default CRCD if null), look up check digit method,
	   from that extract position of check digit.  Assume digit appended to
	   last position of account number if check digit position is null.

	*/
	type public Number ACN,CID,PID
	type String CRCD,METHOD,TYPE
	type Number ACNMAX,BOO,BRCD,CIFMAX,INDEX,NOCDNUM,POS,ZCONVCNT 
	
	// Set all branch pointers to zero
	set ACNMAX=0 
	set ZCONVCNT=0 
	
	type RecordUTBLNCIDT utblncidt
	type RecordUTBLNXTCID utblnxtcid
		
	type ResultSet rs=Db.select("BRCD","UTBLBRCD")
	while rs.next() do {
		set INDEX=rs.getCol("BRCD")
		set utblncidt=Db.getRecord("UTBLNCIDT","TYPE='ACN'")
		set utblncidt.nnum=0
		set utblnxtcid=Db.getRecord("UTBLNXTCID","TYPE='ACN',BRCD=:INDEX")
		set utblnxtcid.ncid=0
		set utblnxtcid.cnt=0
		}
	// Compute starting pointers for all branches (Algorithm 1)
	
	// Converting ACN Table
	write $$^MSG(7772)_":"
	
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
	// Create entry in TMPRPT1 table to hold invalid account numbers
	type RecordTMPRPT1 tmprpt1
	type ResultSet rs1=Db.select("CID,TYPE,CRCD,BOO","ACN")
	while rs1.next() do {
		set INDEX=rs1.getCol("CID")	
		set TYPE=rs1.getCol("TYPE")
		set CRCD=rs1.getCol("CRCD")
		set BOO=rs1.getCol("BOO")
		
		set PID=0
		if 'Db.isDefined("TMPRPT1","PID=:PID,KEY1=:INDEX")
		set tmprpt1=Class.new("RecordTMPRPT1")

		else  set tmprpt1=Db.getRecord("TMPRPT1","PID=:PID,KEY1=:INDEX",1)
		
		// Null BOO field
		if BOO="" set tmprpt1.data=$$^MSG(7775) quit
		if CRCD.get()="" set CRCD=cuvar.%crcd
		
		type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
		// Invalid account number
		if prodctl.cdm'=""&($L(INDEX)<2) set tmprpt1.data="|"_$$^MSG(7774) quit
		if prodctl.cdm'="" do {
			set METHOD=prodctl.cdm
			type RecordUTBLCDM utblcdm=Db.getRecord("UTBLCDM","KEY=:METHOD")
			if utblcdm.getMode() set POS=utblcdm.pos
			if POS="" set POS=1
			set NOCDNUM=$$STRIPCD(INDEX,POS)
			}
		else  set NOCDNUM=INDEX
		set ZCONVCNT=ZCONVCNT+1 if ZCONVCNT#100=0 write "."
		
		if 'Db.isDefined("UTBLBRCD","BOO") do {
			set utblnxtcid.ncid=0
			set utblnxtcid.cnt=0			
			}
		if utblnxtcid.ncid<NOCDNUM set utblnxtcid.ncid=NOCDNUM
		if ACNMAX<NOCDNUM set ACNMAX=NOCDNUM
		}
	set utblncidt.nnum=ACNMAX
	write !
	
	// Invalid account numbers found: Logged in TMPRPT1
	if Db.isDefined("TMPRPT1","PID=:PID,KEY1=:INDEX") write $$^MSG(7776) ,!
	write !

	// CIF Code
	// Set all branch pointers to zero 
	set CIFMAX=0 
	set ZCONVCNT=0 
		
	type ResultSet rs2=Db.select("BRCD","UTBLBRCD")
	while rs2.next() do {
		set INDEX=rs2.getCol("BRCD")
		set utblncidt=Db.getRecord("UTBLNCIDT","TYPE='CIF'")
		set utblncidt.nnum=0
		set utblnxtcid=Db.getRecord("UTBLNXTCID","TYPE='CIF',BRCD=:INDEX")
		set utblnxtcid.ncid=0
		set utblnxtcid.cnt=0
		}
	
	// Compute starting pointers for all branches (Algorithm 1)
	
	// Converting CIF Table
	write $$^MSG(7778)_":"
	
	// Create entry in TMPRPT1 to hold invalid customer numbers
	
	type RecordTMPRPT1 tmprpt11	
	
	type ResultSet rs3=Db.select("ACN,TYPE,CRCD,BOO","CIF")
	while rs3.next() do {
		set INDEX=rs3.getCol("ACN")		
		set TYPE=rs3.getCol("TYPE")
		set CRCD=rs3.getCol("CRCD")
		set BOO=rs3.getCol("BOO")
		
		if 'Db.isDefined("TMPRPT1","PID=:PID,KEY1=:CID")
		
		set tmprpt11=Class.new("RecordTMPRPT1")

		else  set tmprpt11=Db.getRecord("TMPRPT1","PID=:PID,KEY1=:INDEX")
		
		// Null BOO field
		if BOO="" set tmprpt11.data=$$^MSG(7775) quit
		
		if CRCD.get()="" set CRCD=cuvar.%crcd
		
		type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
				
		// Invalid account number
		if prodctl.cdm'=""&($L(INDEX)<2) set tmprpt11.data="|"_$$^MSG(7774) quit
		if prodctl.cdm'="" do {
			set METHOD=prodctl.cdm
			type RecordUTBLCDM utblcdm=Db.getRecord("UTBLCDM","KEY=:METHOD")
			if utblcdm.getMode() set POS=utblcdm.pos
			if POS="" set POS=1
			set NOCDNUM=$$STRIPCD(INDEX,POS)
			}
		else  set NOCDNUM=INDEX
		set ZCONVCNT=ZCONVCNT+1 if ZCONVCNT#100=0 write "."
		if 'Db.isDefined("UTBLBRCD","BOO") do {
			set utblnxtcid.ncid=0
			set utblnxtcid.cnt=0
			}
		if utblnxtcid.ncid<NOCDNUM set utblnxtcid.ncid=NOCDNUM
		if CIFMAX<NOCDNUM set CIFMAX=NOCDNUM
		}
	set utblncidt.nnum=CIFMAX
	write !
	
	// Invalid account numbers found: Logged in TMPRPT
	if Db.isDefined("TMPRPT1","PID=:PID,KEY1=:INDEX") write $$^MSG(7777) ,!
	write !
	
	quit

STRIPCD( Number CDNUM,	// Account Number
	 Number CDPOS)	// Account Position
	 
	// Returns an account number minus the check digit (if any)

	type Number L
	
	set L=CDNUM.length()
	
	// Eliminate leading zeros which might be present
	set CDNUM=+CDNUM
	
	// Check digit is leftmost digit if its position exceeds account number length
	if CDPOS>L set CDPOS=L
	set CDNUM=CDNUM.extract(1,L-CDPOS)_CDNUM.extract(L-CDPOS+2,CDPOS-1)
	
	quit CDNUM

UPHOST( String TABLE,	// Table Type
	Number MAXPTR)	// Host Pointer
	
	// Update's host pointers to next available number
	type RecordUTBLNCIDT uncidt=Db.getRecord("UTBLNCIDT","TYPE=:TABLE",1)

	set uncidt.nnum=MAXPTR
	
	do uncidt.bypassSave()

	quit
	

vSIG()	quit "60555^57442^Pat Kelly^13161"	// Signature - LTD^TIME^USER^SIZE
