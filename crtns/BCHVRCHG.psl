BCHVRCHG //Batch BCHLNVRCHG - Adjust Variable Interest Rate Loans
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/30/2007 15:08 - joynerd
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHLNVRCHG Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 set vBCHSTS=$$STATUS^BCHUTL("BCHLNVRCHG")
 if vBCHSTS=1 set ER=1,RM=$$^MSG(3410) quit
 if vBCHSTS=2 set ER=1,RM=$$^MSG(3414) quit
 if vBCHSTS=0 set %BatchRestart=1
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit do EXIT^BCHUTL("BCHLNVRCHG") quit
 do JOBMGR^BCHUTL(%FN,"BCHLNVRCHG",.vINPUT)
 do ^JOBMGR(.vINPUT)
 do EXIT^BCHUTL("BCHLNVRCHG")
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(CID) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHLNVRCHG","*","",CID.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 if %BatchRestart,$$CHKLOG^BCHUTL(%SystemDate,%FN,"BCHLNVRCHG",CID.get()) do { quit
 do LOG^BCHUTL(%SystemDate,%FN,"BCHLNVRCHG",CID.get(),"Record already processed")
 }
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,CID)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHLNVRCHG","*","",CID.get(),"",et)
 }
 do UPDLOG^BCHUTL(%SystemDate,%FN,"BCHLNVRCHG",CID.get(),vCONTEXT)
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,CID) //
	do PROCESS
	
	quit

	
public	PROCESS

	// Single account entry to process (also called by LNBOD for 
	// re-amortization)
	
	type public Number CID
	type public Boolean ER
	type public String ET
	
	type Date ICHND, PCHND
	
	type RecordLN ln = Db.getRecord("LN", "CID=:CID")
	
	if %SystemDate < ln.odd ! (('ln.mdt.isNull()) & (%SystemDate > ln.mdt)) quit
	
	set ICHND = ln.ichnd
	
	// Interest review offset is null
	if ln.intoff.isNull() set ET = $$^MSG(8437) do LOGERR quit

	set PCHND = ln.pchnd

	do INTCHG(.ln)
	if ER do LOGERR quit

	quit


INTCHG(RecordLN ln)	// Common point to both normal processing and modeling

	type public String ET
	type public Number CID
	type public Date ICHND, PCHND
	type public Boolean ER
	
	type Number BAL, CALBAL, DONE = 0, INT, IRN, PINC, PMTPI, PR, PE0AD
	type Number PRADJ, SCHNUM, SCHSEQ, SVIRN
	type Date ICND, JD, LBDD, NDD, NJD, SCHLD, SCHND
	type Boolean getout
	
	// No Index In Account Record
	if ln.index.isNull() set ET = $$^MSG(4019) quit
	
	// Acount closed
	if ln.stat = 4 do END(.ln, 2) quit
	
	// Inactive
	if ln.stat = 1 do END(.ln, 1) quit
	
	set BAL = ln.bal
	if ln.aruf set BAL = BAL - ln.udbal
	
	set IRN = +ln.irn
	set PMTPI = ln.pmtpi
	set SCHND = +ln.schnd
	set SCHNUM = ln.schnum
	set SCHLD = +ln.schld
	set SCHSEQ = ln.schseq
	
	set LBDD = +ln.lbdd
	if 'LBDD set LBDD = SCHLD

	// Calculate balance to be used for recalculation 
	
	set PRADJ = 0
	set CALBAL = BAL

	// Revolving account left open with no balance
	if 'BAL do NXIR(.ln) quit
	
	if ln.prcb = 1 do NXIR(.ln) quit
	
	set ICND = ln.ichnd
	set SVIRN = IRN

	if PCHND do {
		type RecordLNPTCHG lnptchg = Db.getRecord("LNPTCHG", "PCHND=:PCHND,CID=:CID", 1)
		set PINC = lnptchg.npmt			// New Payment
		}
	else  set PINC = 0	

	// If loan determines interest at payment determine amount remaining.
	if ln.idp do BL(.ln) quit
	
	// ln.idp = 0 loans
	do {
		if LBDD '= SCHND set PE0AD = 0 quit
		
		type String SUB

		type DbSet rs = Db.selectDbSet("LNBIL1", "CID=:CID AND CASD>0 AND SCHSEQ>:SCHSEQ")

		if rs.next() do {
			type RecordLNBIL1 bil1 = rs.getRecord("LNBIL1")
			set SUB = $$SUB^BILFUNCS("P", .bil1)
			set PE0AD = SUB.piece("#",4)
			}
		}

	// If CUPR is negative don't include it in the calculation
	set PRADJ = ln.cupr + ln.unpr + PE0AD
	if ln.cupr < 0 set PRADJ = PRADJ - ln.cupr
	
	set CALBAL = BAL - PRADJ
	set JD = LBDD
	if LBDD '< SCHND set SCHNUM = SCHNUM + 1

	if 'ln.icm, (LBDD '< ICHND ! (LBDD '< PCHND)) do DIA(.ln) quit

	set getout = 0
	for  do { Q:ER ! (getout)
		set NJD = JD.nextFreqDate(ln.dist1fre) quit:ER
		
		set NDD = NJD

		/*
		 If the loan is interest in advance, and we have reached 
		 (but not considered) the due date associated with the 
		 payment change, stop because the next payment will be the 
		 new one.
		*/

		if ln.icm,(NDD > ICHND ! (NDD > PCHND)) do DIA(.ln) set getout = 1 quit

		set INT = $$^UIC(CALBAL, JD, NJD, ln.iacm, IRN, 1, ln.dist1af, ln.dist1fre, ln.icpf, SCHND, SCHLD)
		if INT '= (INT \ 1) set INT = $$^SCARND(INT, 0, CID.get(), "", "", "+")
	
		set PR = PMTPI - INT
		if PR < 0 set PR = 0
		
		if PR '< CALBAL set CALBAL = PR
		set CALBAL = CALBAL - PR
		set SCHNUM = SCHNUM + 1

		/*
		 If the loan is not interest in advance, and we have 
		 considered the due date associated with the payment 
		 change, stop because the next payment (the one after
		 the change date) will be the new one.
		*/

		if 'ln.icm, (NDD '< ICHND ! (NDD '< PCHND)) do DIA(.ln) set getout = 1 quit
	
		do UD(.ln)

		set JD = NDD
		}

	quit


public EXTERN(RecordLN ln, String CTL)

	// Calculate new rate for one account.  Defines SING=1 to 
	// indicate that only one account is to be processed.
	
	type public String ET
	type public Boolean ER
	
	type Number SING
	type Date EJD, ICHND, PCHND
	
	set CTL = CTL.get()
	set SING = 1
	
	set EJD = %SystemDate
	set ICHND = ln.ichnd
	
	// Interest review offset is null
	if ln.intoff.isNull() set ET = $$^MSG(8437) do LOGERR quit
	
	set PCHND = ln.pchnd
	
	do INTCHG(.ln)
	if ER do LOGERR quit
	
	quit
	
	
public	MOD

	/*
	  Model one loan.  The modeling call returns the local data item LNVR
	  which contains the rate change data.  Nothing is filed to disk.
	  Defines SING=2 to indicate that only one account is to be processed
	  without filing.
	*/
	
	type public Number CID

	type String CTL
	type Number SING
	type Date EJD
	
	set CTL = 0
	set SING = 2
		
	set EJD = %SystemDate
	
	type RecordLN ln2 = Class.new("RecordLN")

	set ln2.cid = CID
	
	do INTCHG(.ln2)

	quit
	

UD(RecordLN ln)

	type public Date ICND, IRN, IRNC, NDD, NJD, PCHND
	type public Number CID, PINC, PMTPI
	type public Boolean ER

	// Update IRN for new rates and P+I for new payment amounts
	
	if PINC, ln.icm, NDD > PCHND set PMTPI = PINC
	if PINC, 'ln.icm, NDD '< PCHND set PMTPI = PINC
	
	if IRNC.get(), NDD '< PCHND set IRN = IRNC
	
	if PCHND = NDD do { quit:ER
		set NJD = PCHND.nextFreqDate(ln.pcfre)  quit:ER

		set PCHND = NJD
		
		type RecordLNPTCHG lnptchg = Db.getRecord("LNPTCHG", "PCHND=:PCHND,CID=:CID", 1)
		set PINC = lnptchg.npmt			// New Payment
		}	

	if PCHND < ICND, ICND = NDD do {
		set NJD = ICND.nextFreqDate(ln.intfre) quit:ER

		set ICND = NJD

		type RecordLNVRCHG lnvrchg = Db.getRecord("LNVRCHG", "ICHND=:ICND,CID=:CID", 1)
		
		set IRNC = lnvrchg.nrate
		set IRN = lnvrchg.irn
		}

	quit
	
	
BL(RecordLN ln)	// Determine principal amount remaining in bill file

	type public Number BAL, CALBAL, CID, IRN, PINC, PMTPI, PR, PRADJ, SCHNUM
	type public Date ICHND, JD, LBDD, NDD, NJD, PCHND, SCHLD, SCHND
	type public Boolean ER
	
	type Number INT

	type DbSet dbset = Db.selectDbSet("LNBIL1", "CID=:CID", "SCHSEQ DESC")
	
	set PR = 1
	while dbset.next() do { quit:'PR
		
		type RecordLNBIL1 lnbil1 = dbset.getRecord("LNBIL1")

		/*
		  If the bill is in the future, we don't want to include 
		  it's principal.
		*/
		if lnbil1.cdpd > ICHND ! (lnbil1.cdpd > PCHND) quit

		// Once we hit zero due, go on.
		set PR = lnbil1.cpid
		if 'PR quit
		
		set PRADJ = PRADJ + PR
		}

	
	// Calculate interest using current accrual balance
	
	set JD = SCHND
	
	set INT = $$^UIC(ln.balint, %SystemDate, JD, ln.iacm, IRN, 0, ln.dist1af, ln.dist1fre, ln.icpf, SCHND, SCHLD)
	if INT '= (INT \ 1) set INT = $$^SCARND(INT, 0, CID.get(), "", "", "+")
	
	set CALBAL = BAL - PRADJ + ln.acr + INT
	 
	if LBDD '< SCHND set CALBAL = CALBAL - PMTPI, SCHNUM = SCHNUM + 1
	
	for  set NJD = JD.nextFreqDate(ln.dist1fre) quit:ER ! (NJD > ICHND)  do {
		
		set NDD = NJD
	
		// Paid in advance
		if ln.dist1nd > NJD set JD = NJD quit

		set INT = $$^UIC(CALBAL, JD, NJD, ln.iacm, IRN, 0, ln.dist1af, ln.dist1fre, ln.icpf, SCHND, SCHLD)
		if INT '= (INT \ 1) set INT = $$^SCARND(INT, 0, CID.get(), "", "", "+")
		set CALBAL = CALBAL + INT - PMTPI
		set SCHNUM = SCHNUM + 1
	
		do UD(.ln)

		set JD = NDD
		}

	if 'PCHND.isNull(), ICHND '< PCHND, PINC set PMTPI = PINC

	do DIA(.ln) quit:ER

	quit
	

DIA(RecordLN ln)

	// Multiply DIA in current bill by # of bills to next change date
	
	type public Number CALBAL, CID, IRN, SVIRN
	type public Date ICHND
	type public Boolean ER

	type Number N = 0
	type Date JD, NJD
	
	set IRN = SVIRN
	set JD = %SystemDate
	for  set NJD = JD.nextFreqDate(ln.dist1fre), N = N + 1 quit:ER ! (NJD '< ICHND)  set JD = NJD

	type RecordLNBIL1 lnbil1 = Db.getRecord("LNBIL1", "CID=:CID,SCHSEQ=:ln.bseq", 1)
	if lnbil1.getMode() = 1 set CALBAL = CALBAL + (lnbil1.cdib * N)

	do NXIR(.ln) 

	quit

	
NXIR(RecordLN ln)	// Obtain new interest rate 

	type public Date EJD, ICHND
	type public Number CALBAL, IRN, PMTPI
	type public Boolean ER
	type public String ET, RM

	type String CALTRM, PAR()
	type Number RATE, RRATE, SRATE, URATE

	set PAR("IXLOAD") = 0
	set PAR("NOTSER") = 0
	set PAR("ROUND") = 1
	set PAR("LIMIT") = 1
	set PAR("MATFLG") = 1
	
	do CTL^UINDX(.ln, EJD, CALBAL, .PAR())
	if ER set ET = RM.get() quit
	
	set CALTRM = ""
	if RATE = IRN do RESET(.ln) quit
	
	// Calculate remaining term
	if ln.piacm set CALTRM = $$NPI^UFINC(PMTPI, RATE, CALBAL, 0, ICHND, ln.iacm, ln.dist1fre, "", ln.dist1af)
	else  set CALTRM = $$NP^UFINC(CALBAL, RATE, PMTPI, 0, ln.dist1af)

	set CALTRM = $$^SCARND(CALTRM, 0, "", "", 0)
	if 'CALTRM set CALTRM = "****"

	do RESET(.ln) 
	
	quit
	

RESET(RecordLN ln)	// Set new IRN into the interest change table

	type public Number CALBAL, CALPT, CID, DONE = 1, RATE, SCHNUM
	type public Date ICHND, PCHND
	
	type Number NP
	
	if ICHND = PCHND do {
		type RecordLNPTCHG lnptchg = Db.getRecord("LNPTCHG", "PCHND=:PCHND,CID=:CID", 1)
		set CALPT = lnptchg.upmt		// Unadjusted Payment
		}
	else  set CALPT = ""

	if 'CALPT.isNull() do FILE(.ln) quit
	
	// Compute the P+I which is necessary to amortize the loan over its
	// remaining life
	set NP = ln.onp - SCHNUM
	if NP '> 0 do FILE(.ln) quit
	
	if ln.piacm set CALPT = $$PMT^UFINC(CALBAL, RATE, NP, ln.dist1af)
	if 'ln.piacm set CALPT = $$PI^UFINC(CALBAL, RATE, NP, 0,ICHND, ln.iacm, ln.dist1fre, "", ln.dist1af)

	set CALPT = $$^SCARND(CALPT, 0, CID.get())

	do FILE(.ln)

	quit

	
FILE(RecordLN ln)

	type public Boolean ER
	type public Number BAL, CALBAL, CALPT, CID, DONE, IRN
	type public Number PMTPI, RATE, SCHNUM, SING, SRATE, URATE
	type public String CALTRM, LNVR
	type public Date ICHND

	if SING = 2 set LNVR = (+CALBAL)_"|"_CALTRM_"|"_(+RATE)_"|"_(+URATE)_"|"_ln.index_"|"_(+IRN)_"|"_(+BAL)_"|"_SCHNUM_"|"_(+PMTPI)_"|"_SRATE quit

	/*
	Set entry into the 1-st level of DAYENDLNNOT table to signal the 
	system to produce the Payment Adjustment Notice or/and Projected 
	Activity Report along with the LNVRCHG update
	*/
	
	type Boolean PIL

	type String PIIND

	set PIIND = $$PCMVAL^LNCDI(ln.pcm)	// PCM value
	set PIL = PIIND.extract(1)		// P+I loan indicator

	// Not an Average Interest loan
	if (ln.pcm '= 5), (ln.pcm '= "5N"), (PIL = 0) do { quit:ER
		// Interest Rate Adjustment Notice
		type RecordDAYENDLNNOT lnnot = Db.getRecord("DAYENDLNNOT", "DT=:%SystemDate,CID=:CID,ID=:1", 1)

		set lnnot.oldrate = +IRN
		set lnnot.newrate = +RATE
		
		do lnnot.bypassSave()

		// Generate Acct Projected Act Report Flag (Account Projected 
		// Activity Report)
		if ln.genprjrep = 1 do {
			type RecordDAYENDLNNOT lnnot = Db.getRecord("DAYENDLNNOT", "DT=:%SystemDate,CID=:CID,ID=4", 1)
			
			do lnnot.bypassSave()			
			}
		}

	type RecordLNVRCHG lnvrchg = Db.getRecord("LNVRCHG", "ICHND=:ICHND,CID=:CID", 1)

	set lnvrchg.calbal = +CALBAL		// Calculated Balance
	set lnvrchg.caltrm = CALTRM		// Calculated Term
	set lnvrchg.nrate = +RATE		// New Interest Rate
	set lnvrchg.rate = +URATE	 	// Unadjusted New Rate
	set lnvrchg.index = ln.index	  	// Interest Index
	set lnvrchg.irn = +IRN			// Current Interest Rate
	set lnvrchg.bal = +BAL		        // Ledger Balance
	set lnvrchg.schnum = SCHNUM		// Scheduled # of Payments
	set lnvrchg.pmtpi = +PMTPI		// Current Payment
	set lnvrchg.linv = SRATE		// Current Interest Index Value

	if CALPT set lnvrchg.upmt = +CALPT	// Payment to Amortize
						// (Int Chng '=Pmt Chng)
	do lnvrchg.bypassSave()

	do END(.ln, DONE)

	do ln.bypassSave()

	quit


END(RecordLN ln, Number DONE)	// Update intoffdt and force index to be built

	type public Date EJD, ICHND

	type Date DATE

	if 'DONE quit

	set ln.intoffdt = EJD

	if DONE '= 1 quit

	set DATE = $$NXDT(EJD, ICHND, ln.intfre, ln.intoff, ln.intoffcl)
	if 'DATE quit

	set ln.intoffdt = DATE

	quit
	
	
EXIT	// Exit batch

	type public Boolean ER
	type public Number SING

	set:'SING.get() ER=0

	quit
	
	
public NXDT(Date DT, Date NJD, String FRE, Number OFF, String CAL, Boolean CTL)

	/*
	 Determine next offset date (Identical code exists
			in LNPTCHG
			DT = Limit date, such as TJD
			NJD = Next change date
			FRE = Change frequency
			OFF = Change offset
			CAL = Offset Calendar
			C = Control: 0 = Offset date is greater than TJD
				1 = Offset date is the last date (upto
					and including TJD
	*/
	
	type public Boolean ER
	type public Number COFF(,,,,,)
	
	type Date ICHND, INTOFFDT, JD
	
	set CTL = +CTL.get()
	set ICHND = NJD
	if CAL.get().isNull() set CAL = "NOCALENDAR"

	if COFF(DT,ICHND,FRE,OFF,CAL,CTL).data() quit COFF(DT,ICHND,FRE,OFF,CAL,CTL)

	set ER = 0
	set INTOFFDT = $$INTOFFDT^LNCDI(NJD, OFF, $select(CAL = "NOCALENDAR":"", 1:CAL))
	if INTOFFDT > DT set COFF(DT, ICHND, FRE, OFF, CAL, CTL) = INTOFFDT quit INTOFFDT

	set JD = NJD
	for  set NJD = JD.nextFreqDate(FRE) quit:ER  do { quit:ER ! (INTOFFDT > DT)

		set INTOFFDT = $$INTOFFDT^LNCDI(NJD, OFF, $select(CAL = "NOCALENDAR":"", 1:CAL))

		if 'CTL do {
			if INTOFFDT > DT set COFF(DT,ICHND,FRE,OFF,CAL,CTL)=INTOFFDT quit
			set JD = NJD
			}
		else  do {
			if INTOFFDT > DT do { quit
				set INTOFFDT = JD - OFF
				set COFF(DT,ICHND,FRE,OFF,CAL,CTL)=INTOFFDT
				}
			set JD = NJD
			}
		}
	if ER quit 0

	quit INTOFFDT


LOGERR	// Log error in exception file

	type public Boolean ER
	type public String ET, RM
	type public Number %ZTSEQ, BAL, CID, SING
	
	type String DESC
	
	if SING.get() set RM = ET.get() quit
	
	set DESC = "Variable Rate Loan Offset Processing|1"
	
	do LOG^UTLEXC($T(+0), "*", DESC, CID.get(), %ZTSEQ.get(), ET.get(), +BAL.get())

	kill ET, %ZTSEQ

	quit
	

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
 type String vRECORD,CID
 for  set vRECORD=vINPUT.piece("|",1),vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD.isNull()  do {
 set CID=vRECORD.piece($C(9),1)
 do vPROC(CID)
 }
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
 type public String vBUFOVFL
 type String vRECORD,vrow,CID
 type Number vcur,vlen
 set vINPUT=vBUFOVFL.get()
 set vBUFOVFL="",vlen=0
 type public ResultSet vRESULT
 for  do { quit:'vcur
 set vcur=vRESULT.next() if 'vcur quit
 set vrow=vRESULT.getRow()_"|",vlen=vlen+vrow.length()
 if vlen>32767 set vBUFOVFL=vrow,vcur=0 quit
 set vINPUT=vINPUT_vrow if vlen+13>32767 set vcur=0 quit
 }
 set vINPUT=vINPUT.extract(1,vINPUT.length()-1)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("CID","LN","LN.INTOFFDT=:%SystemDate AND LN.INTFRE IS NOT NULL")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	/*
	   Dayend processing entry for standard offset rate change processing.
	   Called dayend function via QUEed function.  Defines SING=0 to indicate
	   that all accounts are to be processed.
	*/
	
	type public Boolean SING = 0
	type public String CTL = ""
	type public Date EJD = %SystemDate

	quit

	
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
