public DEPPEN(RecordDEP dep,     //Deposit Account       /REF:RW
	     RecordTTX ttx, 	 //Transaction 		 /REF:RW
	     Number PRIN)	 //Principal 

	/*
	   ORIG:  Allan R. Mattson (6915) - 03/19/86

  	---- Revision History ------------------------------------------------

	  07/14/06 - SANTHUMS - CR 20522
	  	     Where Clause of HIST table has been modified in LP 
	  	     section not to ignore interest posting transactions 
	  	     from history.  
	  	     
	  06/20/06 - DHANALAKSHMI R - CR 21816
	  	     Modified the section C1 to updated the call to ACR^RECALC
	  	     by adding BJD as a third argument.

	  06/05/06 - SANTHUMS - CR 21314
	  	     Added PRIN as a new (required) parameter to the top DEPPEN
	  	     ENT,INIT sections. 
	  	     Removed initialization to PRIN in INIT section 
	  	     since it is passed.
	  	     Declared the top (DEPPEN) section as public.
	  	     Corrected typos in some of the revision histories.
	  	      		
	  05/17/06 - SANTHUMS - CR 21311
	  	     Corrected undefined errors in NHIST,LP,LDLT90,INIT 
		     Section.
	  	     	  
	  04/20/06 - SANTHUMS - CR 20840
	  	     Where Clause of HIST table has been modified in LP and 
	  	     NHIST section to select non-interest posting transactions 
	  	     from history for the purpose of calculating the principal 
	  	     amount to penalize.
	  	     
	  03/30/06 - SANTHUMS - CR 20424 
	  	     Since %EffectiveDate scope was getting lost in CALC 
	  	     section, changes made in the C1 section to scope
	  	     %EffectiveDate locally. 
	  	     	
	  03/28/06 - SANTHUMS - CR 20195
                     Since Penalty calculation was not happening correctly
                     Corrected HIST fetch logic in HIST section to select 
                     proper records from HIST table.
                     Corrected UNDEFINED error on the variable U. Modified LP 
                     section to set the value to the variable U.
                     When TSO is NULL in database with the Condition 
                     TSO NOT LIKE '%INT%' HIST table is not fetching the records 
                     in oracle. So corrected HIST logic in LP section.
                    
          03/22/06 - Hillanbrand - CR 20109
                     Corrected logic for NJD^UFRE in section PO11 to
                     correct an infinite loop which occurs when 
                     dep.popt=11.
          
          03/16/06 - DHANALAKSHMI R - CR 20127
 	  	     Modified the section LP to remove the usage of VSQL and
 	  	     to set hist.efd to EJD if hist.efd is defined to avoid 
 	  	     the Undefined errors.

 	  02/24/05 - MugilvannanCS - CR19550
 	  	     Changes made in the INIT section to set PRIN to ttx.prin 
 	  	     instead dep.bal to calculate penalty on the transaction
 	  	     posting amount. Modified section C1 where the "for loop"
 	  	     should check the condition first and then execute the body
 	  	     of the loop. Also modified in the Section IPF where the
 	  	     X() array need to be built in the X(JD) as index instead X(NJD).
 	  	   
          09/13/05 - S.Krishnan- CR16884
	             Removed ORDER BY clause from the section LP and NHIST.
	             Also modified the deprecated feature Db.prevKey to 
	             ResultSet(Db.Select) in the section PO4.

          07/28/05 - SkariahV- CR16679
	             Removed #WARN and #OPTIMIZE directives.
	
 	
	  12/05/03 - CARROLLJ - CR7239
		     Corrected parameter mismatch errors with procedure.

	  10/27/03 - CARROLLJ - 51630
		     Modified PO4 section to define STOP variable before
		     entering while loop.


	  05/28/03 - CARROLLJ - 51349
		     Modified PO2 section to pass the dep object to UACRIND.

	  04/17/03 - GRAY - 51549
		     Corrected undefined error on the variable IPDPRC in
		     section C1.  Also, corrected undefined errors in INIT
		     section (PRIN) and PO4 section (STD).

 	  01/09/03 - Erik Scheetz - 51349
 	  		 Modified code to clean up calls to external programs.  Made sure
 	  		 the correct parameters were being passed.  Also cleaned up code
 	  		 by making use of new PSL methods/properties.  Added the #WARN and 
 	  		 #OPTIMIZE compiler switches.

	  11/27/02 - Svetlana Antonov - 51245 (Roll forward for ARQ 46454)
		     Modified to change variable SWA to SWDA in order to avoid
		     double naming during the withholding process.

	  09/23/02 - Erik Scheetz - 43583
		     PSL conversion cleanup.
 
	  05/20/02 - Erik Scheetz - 43583
		     Convert to PSL, moved from routine to DQ Procedure 
		     Definition.
		     Remove pre-2001 revision history
	
	*/
			
	do ENT(.dep,.ttx,PRIN)
	quit

ENT(RecordDEP dep,
    RecordTTX ttx,
    Number PRIN) 
	
	/* If no penalty option, PEN=0.  Penalty Calculation Method
 	ARGUMENTS:
	
	. dep	Deposit Account Record		/TYP=RecordDEP/REQ
	
	. ttx	Transaction Account Record	/TYP=RecordTTX/REQ
	
	. PRIN  Principal amount                /TYP=N/REQ
	*/

	type Public Number PEN
	
	if 'dep.popt set PEN=0 quit

	type Number NEGACR,NEGACRUN,POSACR,TOTALINT
	type String CUMDEP,DT,INTPW,K,PREVINT,PREVINTPW,PWPP,U,Z
	
	do INIT(.dep,.ttx,PRIN)
	quit

public INIT(RecordDEP dep,
            RecordTTX ttx,
            Number PRIN) 

	/*  INPUT 
		. CID  - Account number		/TYP=N/REQ
		. PRIN - Principal amount	/TYP=N/REQ
		. EC   - Error Correct Flag	/TYP=L/NOREQ
	*/

	type Public Boolean EC
	type Public Date IPLD
	type Public Number %TRNPRT,ACR,AWT,CID,DIY,DYS,IRN,NEGACR,NEGACRUN,NOTICE,PEN
	type Public Number PCA,PENINT,POSACR,PRATE,X
	
	type Date BJD,SAVEFD
	type Number INT
	type String ITC,SRC,TCMT
	
	// Pay Int/Div on Partial Withdrawal
	if dep.pipw set PENINT=0 
	
	// Exclude Total Available Interest
	set PCA=PRIN-$$TOTINTAV^DEPCDI(CID)
	if EC.get()'=1,PCA<0 set PCA=0 
	if 'PCA set PEN=0 quit 
	set IRN=dep.irn

	// Int/Div Paid - Last Date
	set IPLD=dep.ipld 
	if 'IPLD set IPLD=$select(dep.dlr>dep.odt:dep.dlr,1:dep.odt)
	
	// Recalc may have already adjusted these figures. 
	set POSACR=dep.posacr
	set NEGACR=dep.negacr
	set NEGACRUN=dep.negacrun

	// Negative Accrued Interest Unauthorized                  
	set ACR=POSACR-NEGACR-NEGACRUN
	
	// Look for penalty rate first, then default from account
	if 'PRATE.data() set PRATE=""
	if PRATE="" set PRATE=$$FIELD^UTSO(ttx.tso,"PRATE")
	if PRATE="" set PRATE=dep.prate

	/*
	Pull PRATE out from transaction for error correct.  %TRNPRT is 
	the PRATE from the set of transactions.
	*/

	if EC.get() set PRATE=%TRNPRT.get()
	
	// Penalty is valid throughout deposit's life if no expiration date's set
	
	set SAVEFD=%EffectiveDate.get()
	type Date %EffectiveDate=SAVEFD
	if %EffectiveDate="" set %EffectiveDate=%SystemDate 

	set DIY=$$DY^UIC(dep.iacm,%EffectiveDate)

	set AWT=dep.awt
	set NOTICE=0

	if dep.notice do ^DEPNOT(.dep)

	if NOTICE=0!(dep.popt=9) do {
		set BJD=$select(dep.popt=9:%EffectiveDate-dep.notmin,dep.dlr>dep.odt:dep.dlr,1:dep.odt)

		set X=dep.popt
		set X="PO"_X_"(.dep,.ttx)"
		do @X
		}
	
	kill DIY,DYS
	if PEN.get() set PEN=$$^SCARND(PEN,0,CID)
	quit 	

PO1(RecordDEP dep,RecordTTX ttx)
	/*
	   Option 1: All Respective Earnings

	   This section is also called from PIPW^DEPPW to determine the interest
	   accrued on the withdrawal amount for a partial withdrawal; this is
	   necessary when this interest is paid out to the customer.
	*/

	type Public Date BJD,IPLD
	type Public Number ADJINT,CID,INT,PCA,POSACR,PEN,POSTBAL,PRIN
	type Number SAVPCA

	/*
	   If this is a closeout transaction, then the penalty amount will
	   always equal the accrued interest, no need to pass through history.
	*/

	if PRIN=dep.bal set PEN=$$^SCARND(POSACR,0,CID)
	
	/* 
	   If interest is paid, and interest available is used, PCA must be
	   set to PRIN so that the interest is calculated on the full
	   withdrawal amount, including interest available, rather than the
	   difference.
	*/
	// Penalty Calculation Method
	if dep.popt'=1 set PCA=PRIN            
	
	/*
	   If interest is paid, and then is reversed, PCA must be positive
	   to calculate interest accrued on it.
	*/

	set SAVPCA=PCA 
	if PCA<0 set PCA=-PCA
	
	if PRIN'=dep.bal do {
		if IPLD>BJD set BJD=IPLD

		do HIST(.dep)
		do CALC(.dep,.ttx)

		set PEN=INT
		}
	
	set POSTBAL=dep.bal-(PCA+PEN)
	set ADJINT=0
	set PCA=SAVPCA

	quit 	


PO2(RecordDEP dep,RecordTTX ttx)
	/*
	   Option 2: Days Held at Penalty Rate

	   Calculate the penalty amount using the penalty rate defined on the
	   account for the days the account was held
	
	*/
	
	type Public Number ADJINT,CID,NUMDAYS,PCA,PEN,POSTBAL,PRATE

	if dep.cumdep set PEN=$$CURRPEN^UACRIND(.dep,CID,%EffectiveDate,PRATE)
	else  do {
		if dep.dlr set NUMDAYS=%EffectiveDate-dep.dlr
		else  set NUMDAYS=%EffectiveDate-dep.odt
		set PEN=PCA*PRATE*NUMDAYS/36000
		}
	
	set POSTBAL=dep.bal-(PCA+PEN)
	set ADJINT=0

	quit 
	

PO3(RecordDEP dep,RecordTTX ttx)

	//	Option 3: Specified Number of Days; No More Than Earnings

	
	type Public Number ADJINT,BJD,INT,PCA,PEN,POSTBAL
	type Date X

	set X=%EffectiveDate-dep.pdys 
	if BJD<X set BJD=X

	do HIST(.dep)
	do CALC(.dep,.ttx)

	set PEN=INT
	set POSTBAL=dep.bal-(PCA+PEN)
	set ADJINT=0

	quit 	


PO4(RecordDEP dep,RecordTTX ttx)

	/*
	   Option 4: Term Remaining at Marginal Replacement Cost Rate

	   Calculate the penalty amount using the difference between the penalty
	   replacement cost rate and the account rate for the days remaining on
	   the term.
	*/

	type Public Number ER,NUMDAYS,RATE(),REMDAYS
	type Date RATEDATE=%EffectiveDate+1
	type Number BAL,DAYS,D1,IRN,MBAL,PRR,RATESCH,STD,STOP
	type String TRM

	//Penalty rate schedule not defined
	if dep.prs="" do Runtime.setErrMSG("DEP",8722) quit:ER
	
	set TRM=dep.trm		// ^UMDT needs TRM defined

	// Determine number of days remaining in the term of the account
	do ^UMDT
	
	if dep.dlr set NUMDAYS=%EffectiveDate-dep.dlr
	else  set NUMDAYS=%EffectiveDate-dep.odt
	
	/*
	STD - The number of days in the standard term specified,
          where:
        
          D = 1 day
          M = 30.4166666666667 days
          Y = 365 days
	*/

	set REMDAYS=STD-NUMDAYS
	
	set (D1,MBAL,PRR,STOP)=0

	// Penalty Rate Schedule
	set RATESCH=dep.prs	
	
	type ResultSet rs = Db.select("EFD","RATE1","SCH=:RATESCH AND EFD<:RATEDATE","EFD DESC")
	if rs.next() set RATEDATE=rs.getCol("EFD")
	else  quit
	
	
	type DbSet ds=Db.selectDbSet("RATE1","SCH=:RATESCH AND EFD=:RATEDATE")
	if ds.isEmpty(),D1 do PO4B(RATE(D1),dep.irn,dep.bal) quit

	while ds.next() do { quit:STOP=1
		type RecordRATE1 rate1=ds.getRecord("RATE1")

		set RATE(rate1.term)=rate1.ratexbal
		if REMDAYS>rate1.term set D1=rate1.term quit

		if (REMDAYS=rate1.term)!(REMDAYS<rate1.term) do { quit
			if D1=0 quit
			do PO4B(RATE(D1),dep.irn,dep.bal)
			set STOP=1
			}

		if REMDAYS<rate1.term,'D1 do {
			do PO4B(RATE(rate1.term),dep.irn,dep.bal)
			set STOP=1
			}
		}

	quit
	
PO4B(PRR,IRN,BAL)

	type Public Number ADJINT,PCA,PEN,POSTBAL,REMDAYS

	if PRR<IRN set PEN=0
	else  set PEN=PCA*(PRR-IRN)*REMDAYS/36000
	set POSTBAL=BAL-(PCA+PEN)
	set ADJINT=0
	quit 	
	
PO5(RecordDEP dep,RecordTTX ttx)	// Calculate the penalty amount using the greater of option 2 and 3
	
	type Public Number ADJINT,P1,P2,PCA,PEN,POSTBAL
	
	do PO2(.dep,.ttx) set P1=PEN
	do PO4(.dep,.ttx) set P2=PEN
	if P1>P2 set PEN=P1
	if P2>P1 set PEN=P2
	if P1=P2 set PEN=P1
	set POSTBAL=dep.bal-(PCA+PEN) set ADJINT=0
	quit 	
	
PO6(RecordDEP dep,RecordTTX ttx)	 
	/*
		Calculate the penalty amount for the days on deposit using a penalty
		rate from a rate schedule. The rate determined from this schedule will
		be based on the number of days the withdrawal amount was held.
	  	
	*/
	
	type Public Number CID,ER,NUMDAYS,PCA,PEN,POSTBAL,PRR
	type Public String RM
	type Date FDT
	
	
	set FDT=$select(dep.dlr:dep.dlr,1:dep.odt)
	set NUMDAYS=%EffectiveDate-FDT

	if dep.pxd,(FDT+NUMDAYS)>dep.pxd set PEN=0

	else  do {
		//Penalty rate schedule not defined
		if dep.prs="" set ER=1 set RM=$$^MSG(8722) quit
	   	
		// Calculate Penalty Rate
		set PRR=$$RSCH^URSCH(dep.prs,PCA,FDT,%EffectiveDate)
		set PEN=$$^SCARND($$^UIC(PCA,FDT,%EffectiveDate-1,dep.iacm,PRR),0,CID)	
		}

	set POSTBAL=dep.bal-(PCA+PEN)
	quit 	
	
PO7(RecordDEP dep,RecordTTX ttx)	// Specified number of days, pay at passbook rate	

	type Public Number ADJINT,CID,DIY,INT,IRN,N,OINT,PCA,PEN,POSTBAL
	type Public String X()
	
	do HIST(.dep) 
	do CALC(.dep,.ttx) 
	set OINT=INT
	set N=""
	for  set N=X(N).order() quit:N=""  set X(N).piece("|",2)=""

	/*
	Cuvar data item passbook interest rate for penalties (not static info therefor get
	the information by creating an object.
	*/

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
	set IRN=cuvar.pbkirn
	
	do CALC(.dep,.ttx) 
	set PEN=OINT-INT
	set PEN=PEN+$$^SCARND(PCA*dep.irn/100*dep.pdys/DIY,0,CID)
	
	if PEN>OINT set PEN=OINT
	
	set POSTBAL=dep.bal-(PCA+PEN) 
	set ADJINT=0
	
	kill OINT
	quit 	
	
PO8(RecordDEP dep,RecordTTX ttx)	// Specified number of days, invade principal if necessary

	type Public Number ADJINT,CID,IRN,PCA,PEN,POSTBAL
	
	// AF always 360
	set PEN=$$^SCARND(PCA*IRN*dep.pdys/36000,0,CID)    
	set POSTBAL=dep.bal-(PCA+PEN)
	set ADJINT=0
	quit 
	
	
	
PO9(RecordDEP dep,RecordTTX ttx)	// Notice Account Penalties
	/*
	    This method uses a FIFO (first in first out) method, meaning the
	    money on deposit the longest (oldest) will be used for penalty
	    calculations first.
	
	    Example :  An account has a balance of $500 that has not changed
	               for 4 months.  The minimum notice period is 90 days.
	               Then there is a deposit of $300 (BAL=$800). 2 days later,
	               there is a withdrawal of $600. On this withdrawal the
	               penalty will be calculated on the original $500 for loss
	               of accrued since the last interest post, then a penalty
	               on $100 of the $300 deposit, for loss of accrued for
	               2 days.
	
	               This penalty will be greater than a LIFO (last in first
	               out) calculation.  A LIFO calculation would use the $300
	               deposit (2 days penalty) + a penalty on $300 of the
	               original $500 for loss of accrued since the last interest
	               post.
	
	
	    The penalty calculation is as follows:
	
	     1) The oldest money available is always used for penalties.
	
	     2) For the amount of withdrawal which has been on deposit for the
	        minimum number of notice days or more, loss of accrued interest
	        since the last earnings date. (Priority 1)
	
	     3) For the amount of withdrawal which has been on deposit for less
	        than the minimum number of notice days, loss of earnings since
	        the date of deposit. (Priority 2)
	
	
	        Variables Used :
	
	        PCA      = Withdrawal amount (TAMT-INTAVL).
	
	
	        BALLT90  = (balance less than 90)
	                   Total of deposits made during current notice days
	                   period (%EffectiveDate-NOTMIN through %EffectiveDate). If BALLT90 is
	                   greater than the balance, BALLT90 is set equal to
	                   the balance.  This in effect handles any previous
	                   withdrawals made.
	
	        BALGT90  = (balance greater than 90)
	                   Balance minus BALLT90.
	
	        Note : This means the Balance equals BALLT90 plus BALGT90.
	
	        AMTGT90  = (amount greater than 90)
	                   Portion of the withdrawal amount which will be taken
	                   from BALGT90. (Priority 1). If the withdrawal amount
	                   (PCA) is less than or equal to BALGT90, then AMTGT90
	                   is equal to the withdrawal amount. Else, AMTGT90 is
	                   equal to BALGT90.
	
	        AMTLT90  = (amount less than 90)
	                   Portion of the withdrawal amount which will be taken
	                   from BALLT90. (Priority 2).
	
	        Note : This means PCA equals AMTGT90 plus AMTLT90.
	
	
	   ----------------------------------------------------------------------
	
	    Programming Approach :
	
	    1) Collate through history back as far as IPLD or %EffectiveDate-NOTMIN,
	       whichever is earlier. Take non-interest deposits and set up
	       X-array, adding to BALLT90 if the date is less than %EffectiveDate-NOTMIN.
	
	    2) Set remaining variables: BALGT90, AMTLT90, AMTGT90.
	
	    3) If AMTLT90, call sub-routine LDLT90.
	       Taking AMTLT90, collate through X array, reducing AMTLT90 by
	       the amount in X(N) until AMTLT90=0. Then, the rest of the
	       X array is killed. Since RECALC will need a start and end X
	       array element, X(%EffectiveDate) and X(BJD) will be reset to null.

	       Example :
		
	         Going into LDLT90 :
	
	                 AMTLT90=175 , with X(BJD)=""
	                                    X(54500)=100
	                                    X(54510)=50
	                                    X(54520)=230
	                                    X(54530)=100
	         X(%EffectiveDate)=""
	         Coming out of LDLT90 :
	
	                 AMTLT90=0   , with X(BJD)=""
	                                    X(54500)=100
	                                    X(54510)=50
	                                    X(54520)=25
	                                    X(%EffectiveDate)=""
	
	     4) If AMTGT90, set X(IPLD)=AMTGT90+X(IPLD). Any amount on
	        deposit for the minimum number of notice days or more
	        (AMTGT90), will be penalized all accrued since the last
	        interest posting date (IPLD).
	
	     5) Collate through X array, dispatching to ACR^RECALC to
	        calculate adjustment (penalty).
	
	   ----------------------------------------------------------------------
	
	   BJD (beginning date) is %EffectiveDate-NOTMIN at this point. Set BJD to IPLD
	   if IPLD is earlier.
	*/

	type Public Date BJD,IPLD
	type Public Number ADJINT,AMTGT90,AMTLT90,BALGT90,BALLT90,INT
	type Public Number NOTICE,PCA,PEN,POSTBAL,REQPER
	type Public String X,Y

	set BJD=$select(BJD<IPLD:BJD,1:IPLD)
	do NHIST(.dep)
	
	if BALLT90>dep.bal do {
		do BALLT90(.dep)
		set BALLT90=dep.bal
		}
	set BALGT90=dep.bal-BALLT90
	set AMTGT90=$select(PCA'>BALGT90:PCA,1:BALGT90)
	set AMTLT90=PCA-AMTGT90
	
	if 'AMTLT90 kill X
	if AMTLT90 do LDLT90
	if AMTGT90,'NOTICE set X(IPLD)=$G(X(IPLD))+AMTGT90
	set X(BJD)=X(BJD).get() set X(%EffectiveDate)=X(%EffectiveDate).get()
	
	if dep.ipf'="" do IPF(.dep)
	if dep.icf'="" do ICF(.dep)
	if dep.intfre'="" do INTFRE(.dep)
	
	set BJD=X("").order()
	
	do CALC(.dep,.ttx)
	
	set PEN=INT
	set POSTBAL=dep.bal-(PCA+PEN)
	set ADJINT=0
	
	kill NOTICE,REQPER,X,Y
	quit	

BALLT90(RecordDEP dep)
	/*
	   Since BALLT90 is greater than the account balance, there
	   has been a previous withdrawal in this period.  Since this
	   previous withdrawal has already been penalized with FIFO
	   method, the amount of the withdrawal will be removed from
	   the earliest entries in the X array.
	
	   BALPRE is the amount previously withdrawn.
	  ----------------------------------------------------------------------	
	*/
	
	type Public Number AMTLT90,BALLT90,BALPRE,N,NOTICE,REQPER
	type Public String X(),Y
	
	set N=""
	set BALPRE=BALLT90-dep.bal

	for  set N=X(N).order() quit:N=""!('BALPRE)  do { 
		if 'BALPRE quit 	
		/*
		Reduce the amount of this X entry by BALPRE if BALPRE<X(N),
		or kill X(N) if X(N)<BALPRE
		*/

		if BALPRE'<X(N) do { quit
			set BALPRE=BALPRE-X(N)
			kill X(N)
			}
		set X(N).piece("|",1)=+X(N)-BALPRE
		set BALPRE=0
		}
		
	quit

LDLT90	//
	/*
	    The amount needed is AMTLT90. Passing through the X array,
	    the amounts in the X array will be left until AMTLT90=0. The
	    rest of the unwanted X elements will be killed.	
	*/
	
	type Public Number AMTLT90,NOTICE,REQPER
	type Public String N,X(),Y
	
	set N=""

	for  set N=X(N).order() quit:N=""  do { 
		if 'AMTLT90 kill X(N) quit 
	
		/*
		If this whole X value is needed, reduce AMTLT90 by X(N)
		and get the next one.
		*/
	
		if AMTLT90'<X(N) set AMTLT90=AMTLT90-X(N) quit	
		// If the whole X value isn't needed, decrease so set X(N)=AMTLT90	
		set X(N).piece("|",1)=AMTLT90
		set AMTLT90=0
		}
	
	quit 
	
PO10(RecordDEP dep,RecordTTX ttx)	

	/*
	Make an accrual adjustment for the amount of accrued interest 
	on the amount withdrawn if the withdrawal occurs within the penalty term.
	*/
	
	type Public Number ACR,CID,ER,IRN,NUMDAYS,PCA,PEN,POSTBAL
	type Public String RM,YY
	type Date FDT
		
	//Penalty expiration term not defined
	if 'dep.pxd do Runtime.setErrMSG("DEP",8723) quit:ER
	
	if (dep.pxd<%EffectiveDate)!(dep.pxd=%EffectiveDate) do { quit
		set PEN=0
		set POSTBAL=dep.bal-PCA
		}

	set FDT=$select(dep.dlr:dep.dlr,1:dep.odt)
	set NUMDAYS=%EffectiveDate-FDT
	set YY=$$DY^UIC(dep.iacm,%EffectiveDate)
	set PEN=$$^SCARND(PCA*IRN*NUMDAYS/100/YY,0,CID)

	if PEN>ACR set PEN=ACR	
	set POSTBAL=dep.bal-PCA

	quit
	
PO11(RecordDEP dep,RecordTTX ttx)
	/*
	This method will determine how much the accrual would be at the
	penalty rate, then set the penalty equal to the difference between
	the current accrual and the recalculated accrual.
	
	That is, this method will determine how much to reduce the accrual
	"to" using the penalty rate.
	*/
	
	type Public Date BJD,EJD,JD,NJD
	type Public Number CID,ER,INTAF,IPLD,IRN,PCA,PEN,PRATE,RATE
	type Public String FRE,ICPF,RM

	// new accrual variables
	new FDT,NEWAC1,NEWAC2 
	
	// start date	
	set FDT=$select(dep.dlr:dep.dlr,1:dep.odt)      
	
	// Has int been paid
	if IPLD if IPLD>FDT do {               
		if IPLD<%EffectiveDate set FDT=IPLD quit
		set JD=IPLD

		for  set JD=$$NJD^UFRE(JD,dep.ipf,,1) quit:(ER!(JD<%EffectiveDate))
		// int freq prior to FDT
		quit:JD<FDT 
		// set FDT to int pd                         
		set FDT=JD                           
		}
	
	if (PRATE=""),(dep.pindex'="") do {
		type String PAR()

		set PAR("INDEX")=dep.pindex
		set PAR("NOTSER")=1

		do CTL^UINDX(.dep,%EffectiveDate,dep.bal,.PAR)
		set PRATE=RATE
		}
	
	quit:ER
	
	//Penalty rate exceeds int/div rate 
	if (PRATE>IRN)!(PRATE<0) do Runtime.setErrMSG("DEP",212) quit:ER
	
	set BJD=FDT
	set EJD=%EffectiveDate-1
	set INTAF=dep.intaf
	do DIP(.dep)

	// Int/Div - Annual Factor
	if 'INTAF set INTAF=1

	// Int/Div Calc Period Frequency       
	set ICPF=dep.icpf                      
	
	/*
	Call ^UIC to determine how much interest accrued on the withdrawal
	amount at IRN, then how much accrued on it at PRATE.  This is done
	for a date range starting at the latest of ODT/DLR/IPLD upto %EffectiveDate-1.
	*/
	
	if %EffectiveDate'>FDT set PEN=0 quit        
	set NEWAC1=$$^UIC(PCA,FDT,%EffectiveDate-1,dep.iacm,IRN,"00",INTAF,dep.ipf,ICPF,dep.inp)
	set NEWAC2=$$^UIC(PCA,FDT,%EffectiveDate-1,dep.iacm,PRATE,"00",INTAF,dep.ipf,ICPF,dep.inp)
	
	set PEN=NEWAC1-NEWAC2
	set PEN=$$^SCARND(PEN,0,CID)
	kill NEWAC1,NEWAC2

	quit 	
	
PO12(RecordDEP dep,RecordTTX ttx)
	/*
	This method will determine how much to reduce the accrual
	by using the penalty rate.
	*/
	
	type Public Number CID,DIY,ER,IPLD,NUMDAYS,PCA,PEN,PRATE,RATE
	
	// has int been paid
	if IPLD do {

		// latter of DLR, IPLD
		if dep.dlr,(dep.dlr>IPLD) set NUMDAYS=%EffectiveDate-dep.dlr
		else  set NUMDAYS=%EffectiveDate-IPLD
		}
	else  do {
		// days elapsed
		if dep.dlr set NUMDAYS=%EffectiveDate-dep.dlr         
		else  set NUMDAYS=%EffectiveDate-dep.odt
		}
	
	if (PRATE=""),(dep.pindex'="") do { quit:ER
		type String PAR()

		set PAR("INDEX")=dep.pindex
		set PAR("NOTSER")=1

		do CTL^UINDX(.dep,%EffectiveDate,dep.bal,.PAR)

		set PRATE=RATE
		}
	
	// penalty amt w/PRATE
	set PEN=PCA*PRATE/DIY/100*NUMDAYS      
	set PEN=$$^SCARND(PEN,0,CID)

	quit


PO14(RecordDEP dep,RecordTTX ttx)
	/*
	This method will determine the penalty by taking the total interest
	earned for the term plus the interest accrued. That amount will be
	be reduced by the penalty rate on interest. The penalty rate on
	interest will be determined by the bank. This method will also
	forfeit all interest earned if the balance is greater than a
	penalty threshold. The penalty threshold will also be set by the bank.
	*/
	
	type Public Date IPLD
	type Public Number ACR,ADJINT,CID,INT,INTPW,PCA,PEN,PENPW,POSACR,POSTBAL
	type Public Number PRIN,TOTALINT
	
	// calculate int on full w/d
	if PRIN=dep.bal do {
		do HIST(.dep)
		set INT=$$^SCARND(POSACR,0,CID)
		if dep.dlr,(dep.dlr'<IPLD) do CALC(.dep,.ttx) 
		set PENPW=dep.penpw
		if dep.pthresh'<dep.bal!(dep.pthresh="") set PEN=(TOTALINT+INT)*((dep.pint/100)-PENPW)
		else  set PEN=(TOTALINT+INT)-PENPW
		}
	// calculate int on partial w/d	
	if PRIN'=dep.bal do {
		do HIST(.dep) 
		do CALC(.dep,.ttx)
		if %EffectiveDate<IPLD set ACR=0
		set PEN=(INTPW+ACR)*(dep.pint/100)
		set PENPW=PEN+dep.penpw               
		set PENPW=$$^SCARND(PENPW)
		set dep.penpw=PENPW
		}
	
	set POSTBAL=dep.bal-(PCA+PEN)
	set ADJINT=0
	quit 
	
PO15(RecordDEP dep,RecordTTX ttx)	// Specified number of days using IACM, invade principal if necessary
	
	type Public Number ADJINT,CID,DIY,IRN,PCA,PEN,POSTBAL
	
	//The original formula w/IACM
	set PEN=$$^SCARND(PCA*IRN*dep.pdys/(DIY*100),0,CID)
	set POSTBAL=dep.bal-(PCA+PEN)
	set ADJINT=0
	quit 
	
CALC(RecordDEP dep,RecordTTX ttx) // Calculate sum of interest on X(EJD) array

	type Public Date BJD,LJD,SVEFD
	type Public Number ACR,AWT,BASE,CID,CMP,INT,INTAF,NEGACR,NEGACRUN,POSACR
	
	if dep.iacm.curVal.extract()=0 do {
		set INTAF=dep.intaf
		do DIP(.dep)

		 // Int/Div - Annual Factor
		if 'INTAF set INTAF=1
		}
	
	set SVEFD=%EffectiveDate
	set (BASE,INT,CMP,POSACR,NEGACR,NEGACRUN,ACR,AWT)=0
	set LJD=BJD-1

	do C1(.dep,.ttx)

	set ACR=POSACR-NEGACR-NEGACRUN
	set INT=$$^SCARND(INT+ACR,0,CID)
	quit 
	
C1(RecordDEP dep,RecordTTX ttx)

	type Public Date BJD,LJD,SVEFD
	type Public Number ACR,AWT,BASE,CID,CMP,DIP,INT,IRN,NEGACR,NEGACRPO
	type Public Number NEGACRUN,MINACR,POSACR
	type Public String X()
	type Date %EffectiveDate

	set %EffectiveDate=""
	for  set %EffectiveDate=$O(X(%EffectiveDate)) quit:(%EffectiveDate="")!(%EffectiveDate>SVEFD))  do { 
	  	//  Needed to define all variables for ACR section
		do INIT^RECALC(.dep) // Needed to define all variables for ACR section
		set MINACR=0	     // Ensures that penalty is calculated on correct balance		
		set NEGACRPO=0
	
		if CUVAR.IPD do {                    
			// If IPD is set then set last date+1 if it is a posting date.
			if X(LJD).get().piece("|",3),LJD'=dep.odt set LJD=LJD+1
	
			// Include %EffectiveDate if it is a posting date.
			if X(%EffectiveDate).piece("|",3),%EffectiveDate'=%SystemDate new Y set Y=%EffectiveDate new %EffectiveDate set %EffectiveDate=Y+1
	
			if LJD=%EffectiveDate set ACR=0
			else  do ACR^RECALC(.dep,.ttx,BJD)
			}
		else  do ACR^RECALC(.dep,.ttx,BJD) 

		set ACR=POSACR-NEGACR-NEGACRUN
	
		set BASE=BASE+X(%EffectiveDate)        // Deposit amounts
		if X(%EffectiveDate).piece("|",2) set IRN=X(%EffectiveDate).piece("|",2)
		if X(%EffectiveDate).piece("|",3) do {
			set INT=INT+$$^SCARND(ACR,0,CID)
			set (POSACR,NEGACR,NEGACRUN,ACR,CMP,AWT)=0
			}
		if X(%EffectiveDate).piece("|",4) set CMP=ACR
		if X(%EffectiveDate).piece("|",8) set DIP=X(%EffectiveDate).piece("|",8)
		set LJD=%EffectiveDate
		}
	quit	
	
DIP(RecordDEP dep) // Days in period
	
	type Public Date EJD,JD,NJD,Z
	type Public Number DIP,ER

	if dep.ipf'=""  do { quit:ER
		set JD=EJD 
		set NJD=$$NJD^UFRE(JD,dep.ipf) quit:ER  
		set DIP=$select(NJD>JD:NJD-JD,1:0) 
		}
	else  do {	 
		set Z=dep.dlr if 'Z set Z=dep.odt
		  // Account Maturity Date
		set DIP=dep.mdt-Z if DIP'>0 set DIP=0 
		}
	quit
	
HIST(RecordDEP dep)	//
	/*
	      BJD = Beginning date. This will be the earliest of IPLD and
	            %EffectiveDate-NOTMIN (Effective date minus the notice offset).
	            The earliest date needs to be used so the X array will
	            contain sufficient deposits for adjustments.
	      EJD = Effective date
	      PCA = Penalty calculation amount
	      PWA = Primary w/d amt (current w/d)
	     SWDA = Secondary w/d amt (previous w/d's)
	   X(EJD) = Event array (accrual recalculation)
	            Deposit amts | int rate | int post flg | int cmp flg
		
	*/
	
	type Public Date DT	
	type Public Number INTPW,K,N,PCA,PWA,PWPP,SWDA,TOTALINT,Z
	type Public String X
	
	kill X
	set X(%EffectiveDate)=""
	set N=""
	// Set for penalty method 14.
	set (DT,INTPW,K,TOTALINT,Z,PWPP)=0 
	set PWA=PCA
	set SWDA=0

	// This section was previously handed by UHFETCH.
	
	new OUTOFF,U
	set OUTOFF=""
	do LP(.dep)
	quit

LP(RecordDEP dep)
	
	/* Select interest posting transactions from history for 
 	   the purpose of calculating the principal amount to penalize
  	*/
 	   
	type Public Date BJD,DT,EJD
	type Public Number AMT,CID,ER,ITC,OUTOFF,PREVINT,PREVINTPW,PRIN,PWA,SWDA,TYPE
	type Public String X()
	type String U
	
	type DbSet rs=Db.selectDbSet("HIST","CID=:CID AND REVTRN=0","TSEQ DESC")
	if rs.isEmpty() set EJD=BJD
	while rs.next() do { quit:ER!(OUTOFF=1)
		
		type RecordHIST hist=rs.getRecord("HIST")	

 	 	 // These 2 var will store the first interest earned in a term.
		if dep.popt=14 do {
			set PREVINT=0                         
			set PREVINTPW=0                      

			type RecordPRODCTL  prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
			set U=prodctl.crtrin
			if prodctl.crtrin=hist.etc do {
				if DT>dep.dlr,(hist.efd'>dep.dlr) do {
					quit:'X(EJD).data()
					set PREVINT=X(EJD)
					set PREVINTPW=X(EJD)/hist.endbal*PRIN
					}
				}
			}
	
		set ITC=hist.itc
		set AMT=hist.tamt 

		if 'hist.efd set EJD=hist.tjd
		else  set EJD=hist.efd

		// Prior to beginning date
		if EJD<BJD set EJD=BJD
		
		/*
		For an account with interest not set to update principal
		a "#######" is used instead of "#".
		*/
		if dep.popt=14 if AMT["#######" set AMT=+$P(AMT,"#######",2) quit:'AMT
	
		if AMT["#" set AMT=+$P(AMT,"#",2) if 'AMT quit
		// Potential IRN file maintenance
		if 'AMT!(ITC="") do FM(hist.tcmt) quit       

		if '$$DC^UTRB($E(ITC),dep.trb) set SWDA=SWDA+AMT quit
	
		/*
		Handle deposits, reduce SWDA first before working on PWA
		Ignore interest except to reduce SWDA
		*/
	
		// this will add up all previous interest.
		if dep.popt=14 do PM14(.dep,.hist) quit         
		if SWDA.get() do {
			set SWDA=SWDA-AMT  
			if SWDA'<0 quit
			set AMT=-SWDA
			set SWDA=0
			}
		if ITC.extract(4) quit
	
		set X(EJD).piece("|",1)=+$G(X(EJD))+AMT
		set PWA=PWA-AMT
		if PWA<0 do {
			set X(EJD).piece("|",1)=+$G(X(EJD))+PWA
			set PWA=0
			}
		if PWA quit
		else  set OUTOFF=1 
		quit
		}

	do LPEND(.dep)

	quit

PM14(RecordDEP dep,RecordHIST hist)	// Penalty Method 14

	type Public Date DT,EJD,IPLD
	type Public Number AMT,INTPW,K,PREVINT,PREVINTPW,PRIN,PWA,PWPP,TOTALINT,Z
	type Public String U,X()

	if PWPP=1 set K=K/(IPLD-hist.efd)*(%EffectiveDate-hist.efd)
	set PWPP=0
	
	// will store the total int for term
	set TOTALINT=Z                         
	// will store the int for the term on partial w/d
	set INTPW=K                            
	
	set X(EJD).piece("|",1)=+$G(X(EJD))+AMT
	set PWA=PWA-AMT 
	
	if PRIN'=dep.bal do {
		// computes int for term on P/W
		set K=X(EJD)/hist.endbal*PRIN
		if %EffectiveDate<hist.endbal set PWPP=1
		set K=K+INTPW
		}
	
	// computes int for term for full w/d
	if PRIN=dep.bal set Z=X(EJD)+TOTALINT

	
	if DT'=0 do {
		if dep.dlr'="",(hist.endbal'>dep.dlr) do {	
		// this loop makes sure that int isn't calculated on interest from previous term.
			set Z=TOTALINT				
			set K=INTPW	
			}
		}
	// this checks X(EJD) array to make sure that int. is only on Int Paid Trn code.	
	if U'=hist.etc do {			
		set Z=TOTALINT		
		set K=INTPW		
		}
	/*
	The following loop calculates the correct interest for the term
	if the account is a rollover. 
	*/
	if dep.popt=14,(dep.dlr'="") do {
		if DT>dep.dlr,(hist.endbal'>dep.dlr) do {
			set TOTALINT=(TOTALINT-PREVINT)+(PREVINT/(DT-hist.endbal)*(DT-dep.dlr))
			set INTPW=(INTPW-PREVINTPW)+(PREVINTPW/(DT-hist.endbal)*(DT-dep.dlr))
			set Z=TOTALINT
			set K=INTPW
			}
		}

	//This will contain the date of int posting to compare to DLR	
	if U=hist.etc set DT=hist.endbal
	
	if PWA<0 set X(EJD).piece("|",1)=+X(EJD).get()+PWA,PWA=0

	if PWA quit
	do LPEND(.dep)
	quit
	
	
LPEND(RecordDEP dep)	// 
	/*
	All done, either past BJD or have enough to cover PWA
	Any amount left over is considered from beginning date
	*/

	type Public Date EJD
	type Public Number PWA,SWDA
	type Public String X()

	kill SWDA
	if PWA set X(EJD).piece("|",1)=+$G(X(EJD))+PWA
	if dep.ipf'="" do IPF(.dep)
	if dep.icf'="" do ICF(.dep)
	if dep.intfre'="" do INTFRE(.dep)
	quit 
	
IPF(RecordDEP dep)	// Load INP dates

	type Public Date BJD,DLR,JD,NJD
	type Public Number ER
	type Public String FRE,X()

	set FRE="-"_dep.ipf
	set DLR=dep.dlr
	set NJD=dep.inp
	for  set JD=NJD set NJD=$$NJD^UFRE(JD,FRE) quit:NJD<BJD!(ER) 
	set BJD=NJD
	set FRE=FRE.extract(2,99)
	if BJD<DLR do { quit:ER
		set X(DLR).piece("|",3)=$select(dep.popt=9:"",1:1)
		set X(DLR).piece("|",8)=NJD-JD
		set JD=NJD
		set NJD=$$NJD^UFRE(JD,FRE)
		} 
	for  set JD=NJD set NJD=$$NJD^UFRE(JD,FRE) quit:ER!(JD>%EffectiveDate)  do {
		if JD<%EffectiveDate do {
			set X(JD).piece("|",3)=$select(dep.popt=9:"",1:1)
			set X(JD).piece("|",8)=NJD-JD
			}
		}

	quit 

ICF(RecordDEP dep)	// Load INC dates

	type Public Date BJD,JD,NJD
	type Public Number ER
	type Public String FRE,X()

	quit:dep.icf.curVal.extract(1,3)="1DA" 
	set FRE=dep.icf
	set NJD=BJD-1
	for  do { quit:ER!'NJD!(NJD<0)!(NJD>%EffectiveDate)
		set JD=NJD
		set NJD=$$NJD^UFRE(JD,FRE)  
		set X(NJD).piece("|",4)=1
		}
	quit 
	
INTFRE(RecordDEP dep)	// Load ICHND dates

	type Public Date BJD
	type Public Number ER,RATE
	type Public String A(),X()

	new JD
	set BJD=$select(dep.popt=9:%EffectiveDate-dep.notmin,dep.dlr>dep.odt:dep.dlr,1:dep.odt) 
	set JD=dep.ichnd
	for  set JD=$$NJD^UFRE(JD,dep.intfre,"",1) quit:JD<BJD!(ER)  do {
		set PAR("INDEX")=dep.index
		set PAR("IXLOAD")=0
		set PAR("NOTSER")=0
		set PAR("IPMODE")=0
		set PAR("ROUND")=1
		set PAR("LIMIT")=0
		do CTL^UINDX(.dep,JD,0,.PAR) quit:ER 
		set X(JD).piece("|",2)=RATE
		}
	quit

FM(TCMT)	// Load interest rate changes

	type Public Date BJD,DI,EJD
	type Public Number IRN,NV,OV
	type Public String FID,X()

	if EJD=BJD quit
	set FID=TCMT.piece("[",2)
	set FID=FID.piece("]",1)
	
	if '(FID="DEP"!(FID="LN")) quit 
	
	set DI=TCMT.piece("]",2)
	set DI=DI.piece(":",1)
	
	if DI'="IRN" quit 
	
	set OV=TCMT.piece(":",2)
	set NV=TCMT.piece(":",3)
	set X(EJD).piece("|",2)=NV
	set IRN=OV
	quit 
	
NHIST(RecordDEP dep)	// Find out total amount deposited within last notice days
	
	type Public Date BJD
	type Public Number BALLT90,ER,N,X()
	
	kill X set X(BJD)="" set N=""
	
	// Total deposits within last notice days
	set BALLT90=0                          
	
	/*
	
	X(EJD) = Event array (accrual recalculation)
	Deposit amts | int rate | int post flg | int cmp flg
	
	Back through history, using deposits only.
	This section was previously handled by UHFETCH.
	
	Select non-interest posting transactions from history for 
 	the purpose of calculating the principal amount to penalize
  	
	*/

	new ITC,AMT,EJD,SRC,TCMT
	
	type DbSet ds=Db.selectDbSet("HIST","CID=:CID AND REVTRN=0 AND (TSO NOT LIKE '%INT%' OR TSO IS NULL)","TSEQ DESC")
	if ds.isEmpty() set EJD=BJD quit
	
	while ds.next() do { quit:ER
		type RecordHIST hist=ds.getRecord("HIST")
	
		set ITC=hist.itc
		set AMT=hist.tamt 
		// Prior to beginning date
		set EJD=hist.efd
		set:'EJD EJD=hist.tjd if EJD<BJD set EJD=BJD
		// No principle	
		if AMT["#" set AMT=+$P(AMT,"#",2) if 'AMT quit 
		// Potential IRN file maintenence   
		if 'AMT!(ITC="") do FM(hist.tcmt) quit
		// Look at deposits only 
		if '$$DC^UTRB($E(ITC),dep.trb) quit
		
		// Ignore interest   
		if ITC.extract(4) quit         
	
		/*
		Increment BALLT90 (total deposits in current period) only if
		EJD is in the current period.
		*/
	
		//if EJD'<%EffectiveDate-dep.notmin set BALLT90=BALLT90+AMT
		if EJD'<(%EffectiveDate-dep.notmin) set BALLT90=BALLT90+AMT
		set X(EJD)=+X(EJD).get()+AMT
		}
	quit
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60617^21180^Sunitha Santhumayor^34517"	// Signature - LTD^TIME^USER^SIZE
