public	TTXFDT(RecordTTX ttx, RecordTRN trn, String OM())

 	/*

	Future Dated Transaction Processing

 	 PROCEDURE ID:	TTXFDT
 	     Original:	TTXFDT.M
		 Date:	5/13/2002 - 4:04:05 PM
 	         Desc:	Future Dated Transaction Processing
 
 	---- Comments --------------------------------------------------------
 
 	ARGUMENTS:
		. ttx	  Future-dated transaction		/TYP=obj/REQ
 		. trn	  Transaction Code			/TYP=obj/REQ
 		. OM()	  Output Message Array			/TYP=REFARR/REQ
 
	KEYWORDS: Transaction processing, treasury
	
	LIBRARY:
	   . future - Stores future-dated transactions
	   . NOS2   - Updates ^ITNOSTR with nostro transactions
	   . NOSTRO - Returns nostro account flag
	   	      Entry point to append transactions to end of file (CRT mode)
	
	INPUTS:
           . System        	TJD, %UID
           . BRCD          	Branch code                     /TYP=T
           . %Effective Date	Effective date of transaction   /TYP=D
           . ITS           	ITS Flag                        /TYP=L
           . SPV           	Supervisory override array      /TYP=ARRAY

	EXAMPLE:
	   do ^TTXFDT(.ttx(), .trn)
	
	 ---- Revision History ------------------------------------------------
	 
	 06/23/06 - DESHPANDE S K - CR 20748
		    Replaced public variable %TRNSEQ with call to 
		    ttx.getStoredValue("TranSeq"). Replaced public variable 
		    TRNMODE with call to ttx.getStoredValue("TranMode")
	 
	 06/14/06 - PUTTASWH - CR 21734
	 	    Modified TTXFDT section to round the TTXFDT.RATE column
	 	    to 5 decimal places.
	 
	 05/25/06 - GIRIDHAL - CR 21297
	 	    Modified section HIST to remove references to Split Day 
	 	    Processing as it is obsolete. 
	 	
	 02/10/06 - KELLYP - CR 19298
	 	    Removed call to CRT^TRNUTL.  Cash transactions cannot be
	 	    future-dated so Currency Transaction Threshold processing
	 	    is not applicable for future-dated transactions.
	
	 11/03/05 - KELLYP - CR 18064
	 	    Modified to remove local scoping of the OM array and added
	 	    it as a parameter to this procedure.  This prevents a 
	 	    problem from occurring where the output message wasn't
	 	    being returned to the client for future-dated transactions.
	
 	 08/11/05 - Mugilvannan - CR 16732
		    Modified the HIST section to append the comment it builds
		    to the end of the original TCMT. Prior to this change, the
		    original TCMT would be found between the "future amt" and
		    "trancode" comments that the HIST section was building.  
	  
	 03/31/05 - SmithCD - CR 13782
	 	    Replaced Db.nextKey() with Db.select() and other cleanup, 
	 	    and made the procedure public. Corrected some potential 
	 	    defects. Removed call to EXCHOFF^TTXEXT, which is no 
	 	    longer necessary (called rom TRNDRV). Removed old 
	 	    revision history.

	 03/01/05 - Kini - 13991
		    Modified sumpos section to pass the System Date as the 
		    argument to position^RGLSUM procedure.
		    
	 12/07/04 - JERUCHIMC - 13228
	            Comply with DBI standards.  Correct setting of endseq.
	
	 01/28/04 - CARROLLJ - CR7473
		    Removed the new of BRCD variable and corrected
		    undefined error in ttxfdt object.

	*/

	type public Cache %CUVAR
	type public Number %MCP, BRCD, CID 
	type public Boolean CTRFLG, ER
	type public String mxtrlm(), SPV(), OVR()
	type public Date TPD
	
	type String CTR(), ETC, SPVREC, UID
	type Number MTRC, PTRC, TRC
	type Date FTDTJD

	// Prevent the filing of future dated transactions after MXUCLSTR error
	// in online mode
	
	// Transaction exceeds maximum userclass limit
	if ttx.getStoredValue("TranMode") = 1, mxtrlm.data() do Runtime.setErrMSG("TTXFDT", 4167) quit

	// Track last posted sequence for returned payment orders
    
	set FTDTJD = %EffectiveDate
	set UID = %UserID
	 
	type RecordTTXFDTUID ttxfdtuid = Db.getRecord("TTXFDTUID", "TJD=:FTDTJD,BRCD=:BRCD,UID=:UID", 1)
	
	if ttx.getStoredValue("TranSeq") = 1 set ttxfdtuid.endseq = ttxfdtuid.endseq + 1
	set PTRC = (ttxfdtuid.endseq * 1000) + ttx.getStoredValue("TranSeq")

	do ttxfdtuid.save()

	// Create new ttxfdt object with attributes of ttx

	type RecordTTXFDT ttxfdt = ttx.copy()
	
	set ttxfdt.tjd = FTDTJD
	set ttxfdt.brcd = BRCD
	set ttxfdt.uid = UID
	set ttxfdt.tseq = PTRC
	
	set ttxfdt.cdt = %CurrentDate
	set ttxfdt.tim = %CurrentTime
	set ttxfdt.brcde = BRCD
	
	if ttxfdt.crcd.isNull() set ttxfdt.crcd = %SystemCurrency

	if 'ttxfdt.rate.isNull() set ttxfdt.rate=ttxfdt.rate.roundDec(5)

	// Insert posting date TSO tag TPDSYNC#, this is for host synch

	if TPD.get() set ttxfdt.tso = $$FIELDIN^UTSO(ttxfdt.tso, "TPDSYNC", TPD)
	
	set ETC = trn.etc
	
	// Invalid transaction code
	if 'Db.isDefined("TRN", "ETC") do Runtime.setErrMSG("TRN", 3592)

	if trn.cls '= "M", $$NOSTRO(CID) do {

		set MTRC = $$NOSTRNUM^ITUTIL(CID, %EffectiveDate, 1)

		if MTRC > 0 do {
			set ttxfdt.tso = $$FIELDIN^UTSO(ttxfdt.tso, "NOSTSEQ", MTRC)

			type RecordITNOSTRO itnostro = Class.new("RecordITNOSTRO", "CID=:ttxfdt.cid,DTJD=:ttxfdt.tjd")

			set itnostro.tseq = MTRC

			do TTXF2NOS^NOSTRCDI(.ttxfdt, .itnostro)

			do itnostro.save()
     			}
		}
	
	if trn.cls = "M" do { quit:ER

		quit:ttxfdt.crcd = %SystemCurrency

		// Determine if this transaction is hitting a position account
		quit:'$$position(CID, ttxfdt.crcd)
	
		do sumpos(.ttxfdt)
	
		// Store TSO("SPM") into ttx.tso prior to writing to ^TTXFDT

		do FIELDIN^UTSO(ttxfdt.tso, "SPM", 1)
		}
	else  if trn.cls = "D" do { quit:ER
		/* 
		Value date to next accrual calculation date for low balance 
		based on collected balance. Value Date to Next Accrual Calc 
		Date.
		*/

		type RecordDEP dep = Db.getRecord("DEP", "CID")

		// Int/Div Rate Calculation Base				
		if trn.pcfd21, dep.ircb = 6 do { quit:ER
			type String TRNDT
			
			set ttxfdt.vdt = $$VALNACP^DEPLBB(.dep, %EffectiveDate) quit:ER 
			set TRNDT = $S(%EffectiveDate:%EffectiveDate, 1:%SystemDate)

			if ttxfdt.vdt > (TRNDT + CUVAR.VDTFWD) set OVR(CID, "OVR", "VDTFWD") = ""
	
			}
		} 

	if SPV(ttx.getStoredValue("TranSeq")).data(), 'ttxfdt.itc.isNull() set ttxfdt.itc = $$ITC^TTXEXT(ttxfdt.itc, 2)

	set TRC = ttxfdt.tseq
	set OM(ttx.getStoredValue("TranSeq")) = $$OM^TRNUTL(.ttx)
	
	// misc transaction
	if trn.cls = "M" do ttxfdt.save() quit
	  
	do HIST(.ttxfdt, TRC)
	
	do ttxfdt.save()
	
	if 'SPV(ttx.getStoredValue("TranSeq")).data() quit

	type RecordTTX ttxary()
	set ttxary(ttx.getStoredValue("TranSeq")) = ttx.copy()
	
	// Store in LV format
	set SPVREC = $$SPV^TTXRPC(.trn, .ttxary(), ttx.getStoredValue("TranSeq"), CID)
	
	type RecordTTXFDT0 ttxfdt0 = Class.new("RecordTTXFDT0", "TJD=:%EffectiveDate,BRCD=:BRCD,UID=:UID")

	set ttxfdt0.spvrec = SPVREC
	set ttxfdt0.tseq = PTRC
	
	do ttxfdt0.save()
	
   	kill SPV(ttx.getStoredValue("TranSeq"))

	quit 


HIST(RecordTTXFDT ttxfdt, Number PTRC)
	// File into account "future history"

	type public String %EMUCRCD
	type public Date %EffectiveDate
	
	type Number BRCD
	type String CO, COMMENT, CRCD, OCMT, TSO
	
	set CRCD = ttxfdt.crcd
	set TSO = ttxfdt.tso
	set BRCD = ttxfdt.brcd
	
	// Build comment - append to existing comment
	
	set OCMT = ttxfdt.tcmt
	set COMMENT = ""

	if CRCD' = %EMUCRCD do {
		set CO = CUVAR.CO
		type RecordCRCD crcd = Db.getRecord("CRCD", "CO=:CO,CRCD=:CRCD")
		if crcd.emu = 1 set COMMENT = CRCD_" "_COMMENT 
		}

	// Future Amount:~p1 ~p2
	set COMMENT = $$^MSG(6852, ttxfdt.tamt, COMMENT)

	// Tran:
	set COMMENT = COMMENT_"~ "_$$^MSG(7843)_" "_ttxfdt.etc
	
	// Append comment created above to original comment
        S COMMENT=OCMT_"~ "_COMMENT
	
	set ttxfdt.tcmt = COMMENT
	
	if TSO.isNull(), TSO.data() > 1 do IN^UTSO(.TSO, ttxfdt.tso)
	
	do HISTBLD^ACNFUNCS(COMMENT, BRCD, TSO)

	quit 
	

public	NOS2(RecordTTX ttx)

	/*
	   KEYWORDS: Treasury
	
	   ARGUMENTS:
	   	. ttx  Transaction Object /TYP=RecordTTX/REQ
	
	   INPUTS:
	   	. %SystemDate
	
	   EXAMPLE:
	   	if CLS'="M" set RVAL=$$NOS2^TTXFDT(.ttx)
	*/
   	
	type Number TSEQ = 0

	if ttx.etc = "M" quit -1
	set %EffectiveDate = ttx.efd
	if '%EffectiveDate set %EffectiveDate = %SystemDate

	type ResultSet rs = Db.select("TSEQ", "ITNOSTRO", "CID=:CID AND DTJD=:%EffectiveDate AND TSEQ>:TSEQ", "TSEQ ASC")
	
	if rs.next() set TSEQ = rs.getCol("TSEQ")
	else  set TSEQ = ""

 	if $$NOSTRO(ttx.cid) do {
       		type RecordITNOSTRO itnostro = Class.new("RecordITNOSTRO", "DTJD=:%EffectiveDate,TSEQ=:TSEQ")
       		
       		set itnostro.brcd = ttx.brcd
	
		do TTX2NOS^NOSTRCDI(.ttx, .itnostro)
		do itnostro.save()
		}

 	quit TSEQ
	

public NOSTRO(Number CID)

	/*

	Determines whether account is a Nostro Account

	   This function interrogates the account type for the account number
	   passed to determine if it's a Nostro account or not.
	
	   KEYWORDS: Treasury, deposits
	
	   ARGUMENTS:
	   	. CID  Account number  /TYP=T/REQ/LEN=12
				
	   RETURNS:
	   	. $$[PRODCTL]NOSTRO - Nostro account flag
	
	   EXAMPLE:
	   	set NOSTRO=$$NOSTRO^TTXFDT(CID)

	*/

	type RecordACN acn = Db.getRecord("ACN", "CID=:CID")

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:acn.type")

	quit prodctl.nostro
	

public	position(Number CID, String CRCD)

	/*

	Determine if this transaction is hitting a position account

	ARGUMENTS:
		. CID	Account number	/TYP=T/REQ/LEN=12	 
		. CRCD	Currency Code	/TYP=T/REQ/LEN=3

	EXAMPLE:
		W $$position^TTXFDT(CID,CRCD)
	*/

	type public String CO
	
	if CO.get().isNull() set CO = CUVAR.CO
	
	type RecordCRCD crcd = Db.getRecord("CRCD", "CO=:CO,CRCD=:CRCD")

	if (CID '= crcd.otcgl) & (CID '= crcd.spotgl) & (CID '= crcd.fxposgl) quit 0
	
	quit 1
	
	
public	sumpos(RecordTTXFDT ttxfdt)

	/*
	   Accumulate position amounts via position^RGLSUM
	   
	   ARGUMENTS:
		. ttxfdt  TTXFDT Record		/TYP=RecordTTXFDT/REQ
 
	    RETURNS:
		. tso 	  Entry for "SPM"	/TYP=tso entry
	*/
		
	type public Number TIM
	
	set TIM = $$TIM^TGLMON()

	do position^RGLSUM(ttxfdt.uid, TIM, ttxfdt.crcd, ttxfdt.cid, %EffectiveDate, ttxfdt.tamt, ttxfdt.itc, "", ttxfdt.tso, %SystemDate)

	quit 
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60457^33253^Shriram Deshpande^9498"	// Signature - LTD^TIME^USER^SIZE
