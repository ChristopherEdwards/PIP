public ZUCTXDD()	/*
	ORIG: Frans S.C. Witte
	DESC: test code for Code generation of methods of Column (indirection),
		Db, and Record for different table types and column types

	---- Comments ----------------------------------------------------------
	This unit contains tests to validate the code generated for
	- column indirection
	- Db.getRecord()
	- Record.copy()
	- Record.overlay()

	In addition it can be called from the top to write out code for PSLTable
	and PSLColumn methods and properties. The tables and cloumns that are
	included here span the entire spectrum with respect to different record
	types and data types.

	The public subroutines ucxCln() and ucxTbl() can be used to write out
	the code for PSLColumn and PSLTable methods and properties for an
	arbitrary column or table.

	---- Revision History --------------------------------------------------
	02/05/07 - Frans S.C. Witte - CR 22843
		Expanded addTable() to generate Db.isDefined() test cases.
	
	01/19/07 - Frans S.C. Witte - CR 22843
		* Added code that generates ZUCTXDDx for ACN, CIF, CIFSIG,
		  CUVAR, DBTBL2, EFTPAY, LN, NOTES, STBLPCM, STFHOST, and
		  TRNAUT.
		* Added methods that generate the test code for DB related
		  methods: create(), addGet(), addMain(), addSet(), addTable(),
		  and ca().

	07/05/06 - Frans S.C. Witte - CR 22843
		Split in one procedure per first letter of table name.

	05/31/06 - Frans S.C. Witte
		Added test code to verify Record.copy() (to same) with and
		without (implied) optimize.

	04/07/06 - Frans S.C. Witte
		Renamed ZUCTXDD, and integrated in ZUCT test set.

	05/22/05 - Frans S.C. Witte
		Initial test set for CR15028 / CR16039.
	*/
	write !,"======== generating DQ procedures with test code ========",!
	do create( "ZUCTXDDA", "ACN",     "BAL,BOO,DTCO,EFTREQ,SFRE,TYPE", "parent table (only)")
	do create( "ZUCTXDDB", "CIF",     "NAM,XNAME,TAXID,LNM,DOB,AGENT,AS,AUD1CF,TYPE,CLS", "recordType = 10")
	do create( "ZUCTXDDC", "CIFSIG",  "DATE,TIME,SIG", "recordType = 10 + blob field")
	do create( "ZUCTXDDD", "CUVAR",   "TJD,CORPID,%CRCD,%LIBS,%VN,ORIGCRCD", "no primary key")
	do create( "ZUCTXDDE", "DBTBL2",  "DESC,LNK9,YORIGIN","MDB negative subscripts")
	do create( "ZUCTXDDF", "EFTPAY",  "REFNO,RECV1,RECV2,ORIGSEQ,CRCD,EFD", "recordType = 11")
	do create( "ZUCTXDDL", "LN",      "ANPTO,BOO,CLS,DISTPF,DUIN,LRIAS,OSGNCRDC,STP,STP3,STP5", "child table, complex computed, master-subfield")
	do create( "ZUCTXDDN", "NOTES",   "RBDATE,NOTES,ACN", "recordType=1 + memo field")
	do create( "ZUCTXDDR", "STBLPCM", "PCMP", "recordType=1 + QID1 IS NOT NULL")
	do create( "ZUCTXDDS", "STFHOST", "CDT,PRIMARY,TRNET", "recordType=1 + QID1 IS NOT NULL")
	do create( "ZUCTXDDT", "TRNAUT",  "BNR,NOBOOK", "subfield with extract()")
	
	// "run" the generated routines.
	write !,"======== test table ACN ========",!		do ^ZUCTXDDA()
	write !,"======== test table CIF ========",!		do ^ZUCTXDDC()
	write !,"======== test table CIFSIG ========",!		do ^ZUCTXDDD()
	write !,"======== test table CUVAR ========",!		do ^ZUCTXDDE()
	write !,"======== test table DBTBL2 ========",!		do ^ZUCTXDDF()
	write !,"======== test table LN ========",!		do ^ZUCTXDDL()
	write !,"======== test table NOTES ========",!		do ^ZUCTXDDN()
	write !,"======== test table STBLPCM ========",!	do ^ZUCTXDDR()
	write !,"======== test table STFHOST ========",!	do ^ZUCTXDDS()
	write !,"======== test table TRNAUT ========",!		do ^ZUCTXDDT()

	quit

	// ---------------------------------------------------------------------
public ucxCln(	String    TBL,
		String    CLN,
		PSLTable  td(),
		PSLColumn cd())
	/* ---------------------------------------------------------------------
	This subroutine can be called for an arbitrary TBL.CLN.
	It will print all applicable PSLColumn properties, and the values of
	all applicable compbinations of PSLColumn methods.

	NOTES:
	. The subroutine will print the un-edited form of return values. In
		particular, if expressions contain TABs, these TABs will not be
		removed or converted.
	*/

	// get Column Descriptor
	type String prop = TBL _ "." _ CLN
	type String rec = TBL.lowerCase()
	if 'td(TBL).exists() set td(TBL) = PSL.getPSLTable(TBL,0)
	set cd(prop) = PSL.getPSLColumn( TBL, CLN)

	write !,"================ Test PSLColumn implementation for " _ prop_ " ================",!

	// List its properties:
	write ".table", ?20, cd(prop).table,!
	write ".column", ?20, cd(prop).column,!
	write ".node", ?20, cd(prop).node,!
	write "delim and pos info", ?20, cd(prop).delimiter, ?25, cd(prop).position
	if 'cd(prop).subfieldPosition.isNull() do {
		write "/", cd(prop).subfieldTag, "~", cd(prop).subfieldMajor
		write "~", cd(prop).subfieldMinor, "~", cd(prop).subfieldPosition
	}
	write !
	write "type information", ?20, cd(prop).dataType _ cd(prop).precision
	write ":"_ cd(prop).length_ ", n2z=", cd(prop).isNullToZero,!
	write ".computation", ?20, "<"_ cd(prop).computation_ ">",!
	write "stored as", ?20, cd(prop).internalTable_ "."_ cd(prop).internalColumn,!!

	// List the application of its methods:
	write "current node",?20, "<"_ cd(prop).getCurrentNode()_ ">",!
	write "current lvn",?20, cd(prop).getCurrentLvn(rec),!
	write "column retrieval",?20, cd(prop).getCurrentExpr(rec,0),!

	if cd(prop).computation.isNull() do {
		if cd(prop).masterfieldType'=2 write "column assignment",?20,cd(prop).getCurrentExpr(rec,1),!
		write "audit node",?20, "<"_ cd(prop).getOldNode(rec)_ ">",!
		write "oldVal stored in",?20, cd(prop).getOldLvn(rec),!
		write "oldVal retrieval",?20, cd(prop).getOldExpr(rec,0),!
		write "full upd, audit off", ?20, "<"_ cd(prop).getUpdateCode(rec,"newval",0)_ ">",!
		write "full upd, audit PSL", ?20, "<"_ cd(prop).getUpdateCode(rec,"newval",1)_ ">",!
		write "full upd, audit SQL", ?20, "<"_ cd(prop).getUpdateCode(rec,"newval",2)_ ">",!
		write "fast upd, audit off", ?20, "<"_ cd(prop).getUpdateCode(rec,"newval",3)_ ">",!
		write "fast upd, audit PSL", ?20, "<"_ cd(prop).getUpdateCode(rec,"newval",4)_ ">",!
		write "fast upd, audit SQL", ?20, "<"_ cd(prop).getUpdateCode(rec,"newval",5)_ ">",!
	}

	type String node = cd(prop).getCurrentNode(1)
	write !
	if node.toNumber()<0 {
		write "load",?20,"key column - no separate load code",!
		write "save",?20,"key column - no bypassSave code",!
	}
	else  if 'cd(prop).computation.isNull() {	// computed
		write "load",?20,"computed column - no separate load code",!
		write "save",?20,"computed column - no bypassSave code",!
		}
	else  {
		type String keypatch()
		type Number n
		set keypatch(-2)="vok000"
		set keypatch($SELECT(node="":"0*",1:node))="vod999"
		for n=1:1:td(TBL).primaryKeys.length() set keypatch(n_"*") = "vok"_n

		if "BM"[cd(prop).dataType do {
			set node="*"_cd(prop).column
			set keypatch(-151)="vod151"
		}

		if cd(prop).masterfieldType<2 do {	// cannot load RDB masterfields
			write "load, new",?20, "<"_ td(TBL).getLoadCode(rec,node,0,0)_ ">",!
			write "load, old",?20, "<"_ td(TBL).getLoadCode(rec,node,1,0)_ ">",!
			write "load, unknown",?20, "<"_ td(TBL).getLoadCode(rec,node,-1,0)_ ">",!
			write "load, new, inc",?20, "<"_ td(TBL).getLoadCode(rec,node,0,1)_ ">",!
			write "load, old, inc",?20, "<"_ td(TBL).getLoadCode(rec,node,1,1)_ ">",!
			write "load, unknown, inc",?20, "<"_ td(TBL).getLoadCode(rec,node,-1,1)_ ">",!

			write "voXN, new",?20, "<"_ td(TBL).getLoadCode("-",node,0,0,.keypatch())_ ">",!
			write "voXN, old",?20, "<"_ td(TBL).getLoadCode("-",node,1,0,.keypatch())_ ">",!
			write "voXN, unknown",?20, "<"_ td(TBL).getLoadCode("-",node,-1,0,.keypatch())_ ">",!
			write "voXN, new, inc",?20, "<"_ td(TBL).getLoadCode("-",node,0,1,.keypatch())_ ">",!
			write "voXN, old, inc",?20, "<"_ td(TBL).getLoadCode("-",node,1,1,.keypatch())_ ">",!
			write "voXN, unknown, inc",?20, "<"_ td(TBL).getLoadCode("-",node,-1,1,.keypatch())_ ">",!
		}

		// Save code (if applicable)
		type PSLColumn xrf()
		do addRdbPos^UCXDD( .xrf(), cd(prop))

		write !
		write "save, new",?20, "<"_ $$getSavCode^UCXDD(td(TBL),rec,node,0,,xrf())_ ">",!
		write "save, old",?20, "<"_ $$getSavCode^UCXDD(td(TBL),rec,node,1,,xrf())_ ">",!
		write "save, unknown",?20, "<"_ $$getSavCode^UCXDD(td(TBL),rec,node,-1,,xrf())_ ">",!
	}


	quit

	// ---------------------------------------------------------------------
public ucxTbl(	String    TBL,
		PSLTable  td(),
		PSLColumn cd())
	/* ---------------------------------------------------------------------
	*/

	// get Table Descriptor (and column descriptors)
	type String rec = TBL.lowerCase()

	if 'td(TBL).exists() set td(TBL) = PSL.getPSLTable(TBL,0)
	type PSLTable des = td(TBL)
	set des = des.assertLevel( 1, .cd())

	write !,"================ Test PSLTable implementation for " _ TBL_ " ================",!
	type String m()
	type String pm()
	type Number n
	type String nd

	for n=1:1:td(TBL).primaryKeys.length() set pm(n_"*") = "v"_n
	set pm(-1)=$$lvpm^UCXDD(rec,-1)

	//write "single node?",?20,des.isOneNode(),!
	write "update key",  ?20, "<", des.getUpdateKey( rec), ">",!
	write "instantiate NEW",?20, "<", des.getNewCode( rec, 0), ">",!

	write !,"================ DB.getRecord for vobj()",!
	write $$cdNewObj^UCCLASS( rec, """Record"_ des.table_ """"),!
	do getRecCode^UCXDD(des, rec, .pm(), .m())

	for n=1:1:m("").order(-1) write m(n),!

	/* getRecord code for voXN could potentially access every node, because
	   the table may be a parent table, or could contain a VIEW restriction.
	   So create hardcoded dbAcc("*",,) entries for all nodes, and for the
	   -2 special purpose node. */
	write !,"================ DB.getRecord for voXN",!
	kill m,pm(-1)
	set rec=876.54321
	type String dbAcc(,,)
	if des.recordType#2 = 1 set dbAcc("*",rec,"0*") = "vod"
	type String nql = des.nodeQuotedList
	for n=1:1 quit:nql.isNull()  do {
		set nd = nql.piece( ",", 1, 1, """")
		set nql = nql.extract( nd.length() + 2, nql.length())
		set nd = nd.stripQuotes()
		set dbAcc("*",rec,nd) = "vod"_ nd
	}
	set dbAcc("*",rec,-2) = "vodMode"
	do getRecCode^UCXDD(des, rec, .pm(), .m())

	for n=1:1:m("").order(-1) write m(n),!
	
	quit

	// #####################################################################
	// Test procedure generation code
	// #####################################################################

	// ---------------------------------------------------------------------
ca( public String src(), local String cod) // Append cod to src()
	/* ---------------------------------------------------------------------
	Support function that adds a line of code to src()
	*/
	if cod.extract() = " " {
		type Number s
		for s=1:1 quit:cod.extract( s)'=" "
		set cod = "".justify( (s - 1) * 4)_ cod.extract(s, cod.length())
	}

	set src( src("").order(-1) + 1) = cod
	quit

	// ---------------------------------------------------------------------
addMain( public String src(), String tbl, String cmt)
	/* ---------------------------------------------------------------------
	Add the main procedure to the source array
	*/
	do ca(src(), " /*")
	do ca(src(), " ORIG: Frans S.C. Witte")
	do ca(src(), " DESC: test code for "_ cmt)
	do ca(src(), "")
	do ca(src(), " ---- Revision History --------------------------------------------------")
	do ca(src(), " "_ %CurrentDate.toString("YEAR-MM-DD")_ " - Frans S.C. Witte - CR 22843")
	do ca(src(), "  generated by "_ %RoutineName)
	do ca(src(), " */")
	do ca(src(), " do "_ tbl_ "()")
	do ca(src(), "")
	do ca(src(), " write !,""======== code generated for ""_ %RoutineName_ "" ========"",!")
	do ca(src(), " #ACCEPT CR=22843; DATE=2006-08-29; PGM=Frans S.C. Witte;GROUP=XECUTE")
	do ca(src(), " xecute ""zprint""")
	do ca(src(), " quit")

	quit

	// ---------------------------------------------------------------------
addGet( public String src(), String inst, List cols)
	/* ---------------------------------------------------------------------
	Add column retrieval code for supplied list of columns.
	This method uses the standard values() array as assignment targets
	*/
	type Number k
	type String colNam

	// code: set valuesCOLNAM) = inst.colnam
	for k = 1:1:cols.count() {
		set colNam = cols.elementAt( k)
		do ca(src(), " set values("""_ colNam_ """) = "_ inst_ "."_ colNam.lowerCase())
	}
	quit

	// ---------------------------------------------------------------------
addSet( public String src(), String inst, List cols)
	/* ---------------------------------------------------------------------
	Add column assignment code for supplied list of columns.
	This method uses the standard values() array as assignment sources.
	The generated code will contain values(COLNAM).get() to prevent
	runtime undefined value exceptions.
	*/
	type Number k
	type String colNam

	// code: set inst.colnam = values(COLNAM).get()
	for k = 1:1:cols.count() {
		set colNam = cols.elementAt( k)
		do ca(src(), " set "_ inst_ "."_ colNam.lowerCase()_ " = values("""_ colNam_ """).get()")
	}
	quit

	// ---------------------------------------------------------------------
addTable( public String src(),
		local String tbl,
		local List cols,
		local String cmt)
	/* ---------------------------------------------------------------------
	Create the test methods for the specified tables and columns
	*/
	type PSLTable td = PSL.getPSLTable( tbl, 0)

	type List allCols = cols, setCols = ""
	if 'td.primaryKeys.isNull() set allCols = td.primaryKeys_ ","_ cols

	type PSLColumn cd
	type String accKeys = "", colNam, fpKeys = "", key
	type Number k
	for k = 1:1:td.primaryKeys.count() {
		set key = td.primaryKeys.elementAt( k)
		set cd = PSL.getPSLColumn( tbl, key)
		set accKeys = accKeys_","_key_"=:K"_k
		set fpKeys = fpKeys_ cd.getClass()_ " K"_ k_ ","
	}
	set accKeys = ""","""_ accKeys.extract(2, accKeys.length())_ """"


	// create the list of assignable columns
	// colNam and cd will contain the name and descriptor of the last column
	// of the supplied list. This can be used in generated code if only a 
	// single sample column is needed.
	for k = 1:1:cols.count() {
		set colNam = cols.elementAt( k)
		set cd = PSL.getPSLColumn( tbl, colNam)
		quit:'cd.computation.isNull()

		set setCols = setCols.add( colNam)
	}

	do ca(src(), "")
	do ca(src(), " // #####################################################################")
	do ca(src(), " // database testcode for: "_ cmt)
	do ca(src(), " // table=" _ tbl)
	do ca(src(), " // columns="_ cols)
	do ca(src(), " // #####################################################################")
	do ca(src(), "")

	// calls to ucxTbl^ZUCTXDD() and ucxCln^ZUCTXDD to demonstrate PSLTable
	// and PSLColumn
	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public "_ tbl_ "( public PSLTable td(), public PSLColumn cd())	//")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " */")
	do ca(src(), " type Number o")
	do ca(src(), " type String c")
	do ca(src(), " type String t  = "_ tbl.addQuotes())
	do ca(src(), " type List   cl = " _ allCols.addQuotes())
	do ca(src(), "")
	do ca(src(), " do ucxTbl^ZUCTXDD(t, .td())")
	do ca(src(), " for o=1:1:cl.count() set c = cl.elementAt( o) do ucxCln^ZUCTXDD(t,c,.td(),.cd())")
	do ca(src(), " quit")
	do ca(src(), "")

	// methods d*: Db.isDefined
	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public d0" _ tbl_ "("_ fpKeys_ " String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test code for Db.isDefined("_ tbl_ "), with:")
	do ca(src(), " - complete primary key, and implied rowCount = 1 (most common occurrence).")
	do ca(src(), " - first primary key column, and explicit rowCount = 1")
	do ca(src(), " - first primary key column, and explicit rowCount = 3")
	do ca(src(), " - condition on "_ tbl_ "."_ colNam_ " and explicit rowCount = 5")
	do ca(src(), " */")
	do ca(src(), " set values(0) = Db.isDefined("""_ tbl_ accKeys_ ")")
	
	if td.primaryKeys.count() > 1 {
		do ca(src(), " set values(1) = Db.isDefined("""_ tbl_ ""","""_ td.primaryKeys.elementAt(1)_ "=:K1"", 1)")
		do ca(src(), " set values(2) = Db.isDefined("""_ tbl_ ""","""_ td.primaryKeys.elementAt(1)_ "=:K1"", 2)")
	}
	
	do ca(src(), " set values(5) = Db.isDefined("""_ tbl_ """, """_ colNam_ $SELECT("FTU"[cd.dataType:">'ABC'",cd.dataType="L":"=1","CDN$":">123",1:" IS NOT NULL")_ """,5)")

	do ca(src(), " quit")

	// methods i*: column indirection, and Record.overlay
	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public i0" _ tbl_ "("_ fpKeys_ " List colList, String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test retrieval code for Record"_ tbl_ ", with colum indirection")
	do ca(src(), " retrieval, and Record" _ tbl_ ".copy() to same with optimizable")
	do ca(src(), " target.")
	do ca(src(), " */")
	do ca(src(), " type Record"_ tbl_ " rec=Db.getRecord("""_ tbl_ accKeys_ ")")
	do ca(src(), " type Number cnm	// column name")
	do ca(src(), " type Number cnr	// column name iterator")
	do ca(src(), " for cnr = 1:1:colList.count() {")
	do ca(src(), "  set cnm = colList.elementAt(cnr)")
	do ca(src(), "  set values(cnm) = rec.@cnm")
	do ca(src(), " }")
	do ca(src(), " type Record" _tbl_ " cpy = rec.copy()")
	do ca(src(), " type Primitive p = cpy."_ cols.elementAt(1).lowerCase())
	do ca(src(), " quit")
	do ca(src(), "")

	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public i1"_ tbl_ "( Record"_ tbl_" rec, List colList, String values(), Record"_ tbl_ " cpy)")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test assignment code for Record"_ tbl_ ", with column indirection")
	do ca(src(), " assignment, and Record" _ tbl_ ".copy() to same with optimizable")
	do ca(src(), " target. The audit flag is off (implied).")
	do ca(src(), " */")
	do ca(src(), " type Number cnm	// column name")
	do ca(src(), " type Number cnr	// column name iterator")
	do ca(src(), " for cnr = 1:1:colList.count() {")
	do ca(src(), "  set cnm = colList.elementAt(cnr)")
	do ca(src(), "  set rec.@cnm = values(cnm)")
	do ca(src(), " }")
	do ca(src(), " set cpy = rec.copy()")
	do ca(src(), " type Primitive p = cpy."_ cols.elementAt(1).lowerCase())
	do ca(src(), " quit")
	do ca(src(), "")

	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public i2"_ tbl_ "( Record"_ tbl_ " rec, List colList, String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test assignment code for Record" _ tbl_ ", with column indirection")
	do ca(src(), " assignment, and audit flag on.")
	do ca(src(), " */")
	do ca(src(), " do rec.setAuditFlag(1)")
	do ca(src(), " type Number cnm	// column name")
	do ca(src(), " type Number cnr	// column name iterator")
	do ca(src(), " for cnr = 1:1:colList.count() {")
	do ca(src(), "  set cnm = colList.elementAt(cnr)")
	do ca(src(), "  set rec.@cnm = values(cnm)")
	do ca(src(), " }")
	do ca(src(), " quit")
	do ca(src(), "")

	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public i3"_ tbl_ "( Record"_ tbl_ " rec, String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test assignment code for Record"_ tbl_ ", with column indirection assignment.")
	do ca(src(), " Uses Record.overlay(values()), to force datatype conversion code")
	do ca(src(), " */")
	do ca(src(), " do rec.overlay(.values())")
	do ca(src(), " quit")
	do ca(src(), "")

	// methods n*: Class.new("Record")
	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public n0"_ tbl_ "("_ fpKeys_ " String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test Class.new(""Record"_ tbl_ """) with object optimization OFF.")
	do ca(src(), " See s0"_ tbl_ " for Class.new(""Record"_ tbl_ """) with object optimization ON.")
	do ca(src(), " Calls u0"_ tbl_ "() to force OPTIMIZE OBJECTS OFF.")
	do ca(src(), " */")
	do ca(src(), " type Record"_ tbl_ " rec=Class.new(""Record"_tbl_ accKeys_ ")")
	do ca(src(), " do s4"_ tbl_ "( rec, values())")
	do ca(src(), " quit")
	do ca(src(), "")

	// methods o*: Column.oldval
	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public o0"_ tbl_ "( Record"_ tbl_ " rec, String values(), String before(), String after())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test code for Record"_ tbl_ ".column.oldVal, with AUDIT ON.")
	do ca(src(), " */")
	do ca(src(), " do rec.setAuditFlag(1)")
	
	for k = 1:1:setCols.count() {
		type String colQut = setCols.elementAt( k)
		type String colLow = colQut.lowerCase()
		set colQut = "("""_ colQut_ """)"
		do ca(src(), " set before"_ colQut_ " = rec."_ colLow_ ".oldVal, rec."_ colLow_" = values"_ colQut)
		do ca(src(), " set after"_ colQut_ "  = rec."_ colLow_ ".oldVal")
		do ca(src(), "")
	}
	do ca(src(), " quit")
	do ca(src(), "")

	// methods r*: column retrieval, and incremental load
	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public r0"_ tbl_ "( Record"_ tbl_ " rec, String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test retrieval code for Record"_ tbl_ ", when object optimization OFF,")
	do ca(src(), " and Record"_ tbl_ ".copy() when target is optimizable.")
	do ca(src(), " */")
	do addGet( src(), "rec", cols)	// code: set value(COLNAME) = rec.colname
	do ca(src(), " type Record"_ tbl_ " cpy = rec.copy()")
	do addGet( src(), "cpy", cols)	// code: set value(COLNAME) = cpy.colname
	do ca(src(), " quit")
	do ca(src(), "")

	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public r1"_ tbl_ "("_ fpKeys_ " String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test retrieval code for Record"_ tbl_ ", when object optimization ON")
	do ca(src(), " */")
	do ca(src(), " type Record"_ tbl_ " rec = Db.getRecord("""_ tbl_ accKeys_ ")")
	do addGet( src(), "rec", cols)
	do ca(src(), " quit")
	do ca(src(), "")

	// methods s*: Record.bypassSave() and record.save()
	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public s0"_ tbl_ "("_ fpKeys_ " String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test bypassSave code for Record"_ tbl_ ", when object optimization ON,")
	do ca(src(), " and recordMode = 0")
	do ca(src(), " */")
	do ca(src(), " type Record"_ tbl_ " rec = Class.new( ""Record"_tbl_ accKeys_ ")")
	do addSet( src(), "rec",  setCols)
	do ca(src(), " do rec.bypassSave()")
	do ca(src(), " quit")
	do ca(src(), "")

	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public s1"_ tbl_ "("_ fpKeys_ " String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test bypassSave code for Record"_ tbl_ ", when object optimization ON,")
	do ca(src(), " and recordMode = 1")
	do ca(src(), " */")
	do ca(src(), " type Record"_ tbl_ " rec = Db.getRecord("""_ tbl_ accKeys_ ")")
	do addSet( src(), "rec", setCols)
	do ca(src(), " do rec.bypassSave()")
	do ca(src(), " quit")
	do ca(src(), "")

	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public s2"_ tbl_ "("_ fpKeys_ " String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test bypassSave code for Record"_ tbl_ ", when object optimization ON,")
	do ca(src(), " and recordMode = -1")
	do ca(src(), " */")
	do ca(src(), " type Record"_ tbl_ " rec = Db.getRecord("""_ tbl_ accKeys_ ", 1)")
	do addSet( src(), "rec", setCols)
	do ca(src(), " do rec.bypassSave()")
	do ca(src(), " quit")
	do ca(src(), "")

	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public s3"_ tbl_ "( Record"_tbl_ " rec, String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test bypassSave code for Record"_ tbl_ ", when object optimization OFF,")
	do ca(src(), " and change audit is OFF")
	do ca(src(), " */")
	do addSet( src(), "rec", setCols)
	do ca(src(), " do rec.bypassSave()")
	do ca(src(), " quit")
	do ca(src(), "")

	do ca(src(), " // ---------------------------------------------------------------------")
	do ca(src(), "public s4"_ tbl_ "( Record"_tbl_ " rec, String values())")
	do ca(src(), " /* ---------------------------------------------------------------------")
	do ca(src(), " Test save code for Record"_ tbl_ ", when object optimization OFF,")
	do ca(src(), " and change audit is ON")
	do ca(src(), " */")
	do ca(src(), " do rec.setAuditFlag(1)")
	do addSet( src(), "rec", setCols)
	do ca(src(), " do rec.save()")
	do ca(src(), " quit")

	quit	// end of addTable(,,)

public create( local String dqp,	// DQ Procedurename
		local String tbl,	// DQ Tablename
		local List cols,	// Column names
		local String cmt)	// comment for test code type
	/* ---------------------------------------------------------------------
	*/
	type literal String BYPASSALL = $$bypassQual^UCRECORD_"/NOLOG"
	type String code()

	do ca( code(), "public "_ dqp_ "()")
	do addMain( code(), tbl, cmt)
	do addTable( code(), tbl, cols, cmt)

	type RecordDBTBL25 dq25 = Db.getRecord( "DBTBL25", "%LIBS='SYSDEV', PROCID=:dqp", 1)
	if dq25.getMode() = 1 do Db.delete( "DBTBL25D", "%LIBS='SYSDEV' AND PROCID=:dqp")

	type String des = "PSL Test Set - "_tbl_ ": "_ cmt
	if des.length() > dq25.des.len set des = des.extract(1, dq25.des.len - 4)_ " ..."

	set dq25.pgm   = dqp
	set dq25.des   = des
	set dq25.mplus = true
	set dq25.ltd   = %CurrentDate
	set dq25.time  = %CurrentTime
	set dq25.user  = %UserName
	do dq25.save( BYPASSALL)
	
	type RecordDBTBL25D dq25d = Class.new( "RecordDBTBL25D", "%LIBS='SYSDEV',PROCID=:dqp")
	type Number ln
	for ln = 1:1:code("").order( -1) {
		set dq25d.seq  = ln
		set dq25d.code = code(ln)
		do dq25d.save( BYPASSALL)
		do dq25d.setMode(0)
	}
	do COMPILE^DBSPROC( dqp)

	quit		
 #OPTION ResultClass ON
Public String vSIG()	quit "60667^22127^Frans S.C. Witte^26052"	// Signature - LTD^TIME^USER^SIZE
