DIFFUTL	  /*
	ORIG: alagarss - 08/11/2005
	DESC: Utilities used to determine errors in updates to 
	      replicated Profile Database.  This routine was designed 
	      exclusively for use on a UNIX operating system. It reads
	      output generated by the diff command which is formatted
	      in a manner exclusive to the unix environment.
	Functions:
	      COMP	 - Compare difference output from Unix machine
	      DBCOMPAR - Export data based on SQL statements stored in a script file
	      BLDSQL	 - Build SQL script for selecting difference records again
	      BLDREP- Create temporary global and run report showing differences 

---- Comments --------------------------------------------------------

---- Revision History ------------------------------------------------
	08/11/2005 - ALAGARSS - CR16677
	                Converted to PSL.
	                Also removed the revision history prior to 2004.
	
----------------------------------------------------------------------
 */
	quit
	//
DBCOMPAR /*Private; Export data based on SQL statements stored
	   in a script file    This function opens the text file,
	   process each SQL statement in order and then output 
	   selected rows to SCAU$SPOOL:EXTRACT_seq.DAT
	   (seq is the sequential record number within the text file) files.
	   ARGUMENTS:
	   . file        Script file name        /TYP=T/REQ/MECH=VAL
	   EXAMPLE:
	   content of the input text file
	   ------------------------------
	   SELECT CID,BAL,LNM FROM DEP
	   SELECT ACN,DOB,TAXID FROM CIF
	   D DBCOMPAR^DIFFUTL
	   output file SCAU$SPOOL:DBCOMPARE_2.DAT
	   -------------------------------------
	   ACN<tab>DOB<tab>TAXID
	   11<tab>01/23/55<tab>111-11-1234
	   15<tab>05/22/77<tab>123-45-9999
	  */
 //---------------------------------------------------------------------- 
	type Public String extract,IOPAR,IO,IOTYP,sqlexpr,outfile
	type Public String file,IOSEC,SEC,RM
	type Public Number er,ER,flseq,x
	
	set file=$$TRNLNM^%ZFUNC("scriptfile")
	set SEC=$$TRNLNM^%ZFUNC("secondary")
	if file.isNull() quit
	set x=$$FILE^%ZOPEN(file,"READ",5,4096)
	// Invalid file name
	if 'x set ER=1,RM=$$^MSG(1337,file) quit
	set flseq=0
	set SEC=$S(SEC.get()="":"",1:"SEC")
	for  set sqlexpr=$$^%ZREAD(file,.er)  do { quit:er 
		// remove tabs
		set sqlexpr=sqlexpr.translate($C(9),"") 
		// remove leading spaces        
		set sqlexpr=$$LTRIM^%ZS(sqlexpr)
		// Blank line          
		if sqlexpr="" quit   
		// Comment line                     
		if sqlexpr.extract(1,2)="//" quit         
		set flseq=flseq+1
		set outfile=$$SCAU^%TRNLNM("SPOOL")
		set outfile=$$FILE^%TRNLNM("DBCOMPARE"_SEC_"_"_flseq_".DAT",outfile)
		use 0
		// Export data with
		do EXPORT^SQLOADER(sqlexpr,outfile,1)	  
	}
	set IO=outfile
	set IOPAR="append"
	set IOTYP="RMS"
	do OPEN^SCAIO
	// used to verify last record of
	use IO write !,"checklast"                       
	// last file was copied up to primary					
	close IO
	close file				    
	// header option on
	quit
		
COMP    /* Private;Compare difference output from Unix machine
	   This utility is part of the M database replication software.
	   It is designed to compare the output of the unix diff command.
	   The source files from that diff are generated through individual
	   SQL commands executed simultanuously on the primary and 
	   secondary system.
	 */
	type Public String DIFFILE,DIFLINE,DATA,extract,EOT,HEADER,IOSTAT,SRCFILE
	type Public String KEY2
	type Public Number A,C,D
	
	set SRCFILE=$$TRNLNM^%ZFUNC("SOURCE")
	set DIFFILE=$$TRNLNM^%ZFUNC("DIFFFILE")
	do SRCINFO(SRCFILE)
	set IOSTAT=$$FILE^%ZOPEN(DIFFILE,"READ:VARIABLE",2,5600)
	if 'IOSTAT quit
	do Db.fastDelete("TMPRPT1","PID=:%ProcessID,KEY1=:SRCFILE")
	set (A,C,D)=0
	for  set DIFLINE=$$^%ZREAD(DIFFILE,.EOT) quit:EOT  do COMPARE
	close DIFFILE
	
		if HEADER.length()<450 do { quit
			type RecordTMPRPT1 tmprpt1=Db.getRecord("TMPRPT1","PID=:%ProcessID,KEY1=:SRCFILE",1)
			set tmprpt1.data=HEADER
			do tmprpt1.save()
		}
		
		type RecordTMPRPT1 tmprpt2=Db.getRecord("TMPRPT1","PID=:%ProcessID,KEY1=:SRCFILE",1)
		set tmprpt2.data=""
		do tmprpt2.save()
		type Number i,n
		set n=1
		set KEY2="DIFFHDR"
		for i=1:1:(HEADER.length()\450)+1 do {
			type RecordTMPRPT3 tmprpt3=Db.getRecord("TMPRPT3","PID=:%ProcessID,KEY1=:SRCFILE,KEY2=:KEY2,KEY3=:i",1)
			set tmprpt3.data=HEADER.extract(n,n+449)
			do tmprpt3.save()
			set n=n+450
		}
	
	quit

COMPARE	 //Private; Build global containing the keys of changed records
	type Public String DIFLINE,extract,KEYS,KEYLOC,SRCFILE,VAL
	type Number II
	
	set KEYS=""
	if (DIFLINE.extract(1)=">")!(DIFLINE.extract(1)="<") do {
			for II=1:1:KEYLOC.length(",") do {
				set VAL=DIFLINE.piece($C(9),KEYLOC.piece(",",II))
				if KEYLOC.piece(",",II)=1 set VAL=VAL.extract(3,100)
				set KEYS=KEYS_","_VAL
		}
		set KEYS=KEYS.extract(2,1000)
		type RecordTMPRPT2 tmprpt4=Db.getRecord("TMPRPT2","PID=:%ProcessID,KEY1=:SRCFILE,KEY2=:KEYS",1)
		set tmprpt4.data=""
		do tmprpt4.save()
	}
	quit	
	
	
BLDSQL	/*Private;Create script file to recheck differences
	Based on the output from the COMP line tag, create a new SQL
	script file to  execute on both systems.  This second attempt
	to check particular accounts is designed to prevent reporting
	errors due to timing issues.
	*/
	
	type Public String HEADER,IO,KEYLOC,KEYVAL,KEY2,KEYS,SRCFILE,SELECT,TABLE,X
	type Public Number CNT,I
	type Number i
	
	set KEY2="DIFFHDR"
	set (SRCFILE,KEYVAL)=""
	/*verify that we have differences from the first go-round. If nothing
	  then do not build a new script file. The script dbcompare.sh will
	  check for the existance of the new script file and exit if it does
	  not exist.
	*/
	
	type ResultSet rs = Db.select("KEY1","TMPRPT1","PID=:%ProcessID")
	while rs.next() do { quit:SRCFILE=""
		set SRCFILE=rs.getCol("KEY1")	
		if Db.isDefined("TMPRPT1","PID=:%ProcessID,KEY1=:SRCFILE") quit
	}
	if SRCFILE="" quit
	set IO=$$SCAU^%TRNLNM("SPOOL")
	set IO=$$FILE^%TRNLNM("script.dat",IO)
	set X=$$FILE^%ZOPEN(IO,"WRITE/NEWV",,4096)
	use IO
	set (SRCFILE,KEYVAL)=""
	//Generate 5 record requests to a line to increase the speed of
	//the second sql execution.
	
	type ResultSet temp=Db.select("KEY1","TMPRPT1","PID=:%ProcessID")
	
	while temp.next() do { quit:SRCFILE=""
		set SRCFILE=temp.getCol("KEY1")
		if Db.isDefined("TMPRPT2","PID=:%ProcessID,KEY1=:SRCFILE,KEY2=:KEY2") do {
			set HEADER=""
			set i=""
			type ResultSet temp1=Db.select("KEY3","TMPRPT3","PID=:%ProcessID AND KEY1=:SRCFILE AND KEY2=:KEY2")
			while temp1.next() do { quit:i=""
				set i=temp1.getCol("KEY3")
				set HEADER=HEADER_temp1.getCol("KEY3")
				do Db.fastDelete("TMPRPT2","PID=:%ProcessID,KEY1=:SRCFILE,KEY2=KEY2")
			}
		}
		else  do {
			type ResultSet temp=Db.select("DATA","TMPRPT1","PID=:%ProcessID AND KEY1=:SRCFILE")
			if temp.next() set HEADER=temp.getCol("DATA")
		}
	
		set TABLE=HEADER.piece($C(9),1)
		set KEYLOC=HEADER.piece($C(9),2)
		set SELECT=(HEADER.piece($C(9),3,1000)).translate($C(9),",")
		set CNT=0
		type ResultSet temp2=Db.select("KEY2","TMPRPT2","PID=:%ProcessID AND KEY1=:SRCFILE")
		while temp2.next() do { quit:KEYVAL=""
			set KEYVAL=temp2.getCol("KEY2")
			if CNT=0 write "SELECT ",SELECT," FROM ",TABLE,"WHERE ("
			if CNT>0 write " OR ("
			for I=1:1:KEYLOC.length("'") do {
				if I>1 write " AND "
				write SELECT.piece(",",KEYLOC.piece(",",I)),"=",KEYVAL.piece(",",I)
			}
			write ")"
			set CNT=CNT+1
			if CNT=5 set CNT=0 write !
		}
		if CNT'=0 write !
	}
	close IO
	do Db.fastDelete("TMPRPT0")
	quit
	

SRCINFO(SRCFILE) //Private; open and read header of source created by SQLOADER
	
	type Public String IOSTAT,EOT,HEADER,TABLE,KEYLOC
	
	set IOSTAT=$$FILE^%ZOPEN(SRCFILE,"READ:VARIABLE",2,5600)
	if 'IOSTAT quit
	//The first line of the source file will contain the
	//table,numeric key pointer and then a list of the fields selected.
	set HEADER=$$^%ZREAD(SRCFILE,.EOT)
	set HEADER=HEADER.translate("|",$C(9))
	set TABLE=HEADER.piece($C(9),1)
	set KEYLOC=HEADER.piece($C(9),2)
	close SRCFILE
	quit
	
BLDREP	// Private ; Build global for reporting
	/* For each new source file, build a entry containing the
	   differences related to that source file.*/
	   
	type Public Number IOSTAT,EOT,i,LENHEAD,I,A,C,D,II,VAL
	type Public String HEADER,SRCFILE,DIFFILE,KEYS,DIFLINE,DATA,KEYLOC,TABLE,TMP
	
	set SRCFILE=$$TRNLNM^%ZFUNC("SRCFILE")
	set DIFFILE=$$TRNLNM^%ZFUNC("DIFFFILE")
	do Db.fastDelete("TMPRPT1","PID=:%ProcessID,KEY1=:SRCFILE")
	do SRCINFO(SRCFILE)
	set HEADER=HEADER.piece($C(9),3,HEADER.length($C(9)))
	set LENHEAD=HEADER.length($C(9))
	set KEYS=""
	for I=1:1 quit:KEYLOC.piece(",",I)=""  set KEYS=KEYS_","_HEADER.piece($C(9),KEYLOC.piece(",",I))
	type RecordTMPRPT1 tmprpt5=Db.getRecord("TMPRPT1","PID=:%ProcessID,KEY1=:SRCFILE",1)
	set tmprpt5.data=TABLE_"|"_KEYS.piece(",",2,20)
	do tmprpt5.save()
	set i=1
	for I=1:1 do { quit:HEADER.extract(i,i+449)=""
		  type String KEY2
		  set KEY2="DIFFHDR"
		  type RecordTMPRPT3 tmprpt6=Db.getRecord("TMPRPT3","PID=:%ProcessID,KEY1=:SRCFILE,KEY2=:KEY2,KEY3=:i",1)
		  set tmprpt6.data=HEADER.extract(i,i+449)
		  do tmprpt6.save()
	          set i=i+450
		  
	}
	set IOSTAT=$$FILE^%ZOPEN(DIFFILE,"READ:VARIABLE",2,5600)
	if 'IOSTAT quit
	set (A,C,D)=0
	for  set DIFLINE=$$^%ZREAD(DIFFILE,.EOT) do {  quit:EOT
		set KEYS="",DATA=""
		if DIFLINE.extract(1)?1N for  set KEYS=TMP(KEYS).order() quit:KEYS=""  do SETRPT 
		if (DIFLINE.extract(1)=">") ! (DIFLINE.extract(1)="<") do { quit
			for II=1:1:KEYLOC.length(",") do {
				set VAL=DIFLINE.piece($C(9),KEYLOC.piece(",",II))=1 set VAL=VAL.extract(3,100)
				set KEYS=KEYS_","_VAL
			}
			set KEYS=KEYS.extract(2,1000)
			set DATA=TMP(KEYS).get()
			if DIFLINE.extract(1)=">" set DATA.piece("|",1)=1,DATA.piece("|",2)=DIFLINE.piece("> ",2)
			if DIFLINE.extract(1)="<" set DATA.piece("|",3)=1,DATA.piece("|",4)=DIFLINE.piece("< ",2)
			set TMP(KEYS)=DATA
		}
	}
	set KEYS=""
	for  set KEYS=TMP(KEYS).order() quit:KEYS=""  do SETRPT 
	close DIFFILE
	quit
	
SETRPT	// 
	type Public Number I,LENHEAD
	type Public String HEADER,KEYS,PRIMARY,SECOND,SRCFILE,TMP

	if TMP(KEYS).piece("|",1)+TMP(KEYS).piece("|",3)<2 do { quit
		if TMP(KEYS).piece("|",1) do {
			 type String KEY3
			 set KEY3="PRIVALID"
			 type RecordTMPRPT3 tmprpt7=Db.getRecord("TMPRPT3","PID=:%ProcessID,KEY1=:SRCFILE,KEY2=:KEYS,KEY3=:KEY3",1)
			 set tmprpt7.data=""
			 do tmprpt7.save()
			 kill TMP(KEYS) quit
			 
			 
		}
		if TMP(KEYS).piece("|",3) do {
			 type String KEY3
			 set KEY3="SECVALID"
			 type RecordTMPRPT3 tmprpt8=Db.getRecord("TMPRPT3","PID=:%ProcessID,KEY1=:SRCFILE,KEY2=:KEYS,KEY3=:KEY3",1)
			 set tmprpt8.data=""
			 do tmprpt8.save()
			 kill TMP(KEYS) quit
			
		}
		}
	set PRIMARY=TMP(KEYS).piece("|",2)
	set SECOND=TMP(KEYS).piece("|",4)
	for I=1:1:LENHEAD do {
		if PRIMARY.piece($C(9),I)'=SECOND.piece($C(9),I) do {
			type String KEY3
			set KEY3=HEADER.piece($CHAR(9),I)
			type RecordTMPRPT4 tmprpt9=Db.getRecord("TMPRPT4","PID=:%ProcessID,KEY1=:SRCFILE,KEY2=:KEYS,KEY3=:KEY3,KEY4=:I",1)
			set tmprpt9.data=PRIMARY.piece($C(9),I)_"|"_SECOND.piece($C(9),I)
			do tmprpt9.save()
	}
	}
		
	kill TMP(KEYS)
	quit

REPORT	/* Private;; Generate the report based on data created in BLDREP label
	   Convert the global genertaed by BLDREP into the traditional TMP($J
	   global. The TMPCOMP global was required because $J is not generated
	   at the job level on a Unix machine, a new value is generated for each
	   new invocation of the M environment.	
	 */
	 
	type Public String %BLK,IO,I,%LIBS,RID
	type String KEY1,KEY2,KEY3
	
	set (KEY1,KEY2,KEY3)=""
	
	type ResultSet rs=Db.select("KEY1","TMPRPT1","PID=:%ProcessID")
	
	while rs.next() do { quit:KEY1=""
		set KEY1=rs.getCol("KEY1")
		type ResultSet rs1=Db.select("DATA","TMPRPT1","PID=:%ProcessID AND KEY1=:KEY1")
		type RecordTMPRPT1 tmprpt10=Db.getRecord("TMPRPT1","PID=:%ProcessID,KEY1=:KEY1",1)
		if rs1.next() do {
			set tmprpt10.data=rs1.getCol("DATA")
			do tmprpt10.save()
		}
		type ResultSet rs2=Db.select("KEY2","TMPRPT2","PID=:%ProcessID AND KEY1=:KEY1")
		set KEY2=rs2.getCol("KEY2")
		while rs2.next() do {  quit:KEY2=""
			if KEY2="DIFFHDR" do { 
				for I=1:1 do { 
					if 'Db.isDefined("TMPRPT3","PID=:%ProcessID,KEY1=:KEY1,KEY2=:KEY2,KEY3=:I") quit
					type RecordTMPRPT3 tmprpt11=Db.getRecord("TMPRPT3","PID=:%ProcessID,KEY1=:KEY1,KEY2=:KEY2,KEY3=:I")
					type RecordTMPRPT2 tmp1=Db.getRecord("TMPRPT2","PID=:%ProcessID,KEY1=:KEY1,KEY2=:KEY2",1)
					set tmp1.data=tmprpt11.data
					do tmp1.save()
				}
			}
		
		type ResultSet rs3=Db.select("KEY3","TMPRPT3","PID=:%ProcessID AND KEY1=:KEY1 AND KEY2=:KEY2")
		while rs3.next() do {
			set KEY3=rs3.getCol("KEY3")
			type ResultSet rs4=Db.select("DATA","TMPRPT3","PID=:%ProcessID AND KEY1=:KEY1 AND KEY2=:KEY2 AND KEY3=:KEY3")
			type RecordTMPRPT3 tmp2=Db.getRecord("TMPRPT3","PID=:%ProcessID,KEY1=:KEY1,KEY2=:KEY2,KEY3=:KEY3",1)
			if rs4.next() do {
			set tmp2.data=rs4.getCol("DATA")
			do tmp2.save()
			}
		}
		}
	}
	
	
	set %LIBS="SYSDEV"
	set RID="DATADIFFRPT"
	do GET^URID
	set IO=$$SCAU^%TRNLNM("SPOOL")
	set IO=$$FILE^%TRNLNM("DATADIFF.RPT",IO)
	set %BLK="/,"_IO
	do ^@PGM
	quit
	
QA	//
	type Public String sqlexpr,outfile
	
	set sqlexpr="SELECT * FROM ACN"
	set outfile=$$SCAU^%TRNLNM("SPOOL")
	set outfile=$$FILE^%TRNLNM("DBCOMPAREtest.DAT",outfile)
	use 0
	do EXPORT^SQLOADER(sqlexpr,outfile,1)
	quit
	

vSIG()	quit "60178^31010^Sanjay Chhrabria^12937"	// Signature - LTD^TIME^USER^SIZE
