EFTFIL0 // EFTPAY DATA-QWIK filer, part (2)
 // Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 05/09/2007 16:35 - joynerd

	quit		// Not called from top


VAD //
	type public Number ER = 0
	type public String vx(),RM
	do vad1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAI //
	type public Number ER = 0
	type public String vx(),RM
	do vai1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VAU //
	type public Number ER = 0
	type public String vx(),RM
	do vau2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() quit
	if vx("AMTTYP").exists() do vau3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CRCD").exists()!vx("SETCRCD").exists()!vx("INTEXT").exists()!vx("SENDNOS").exists()!vx("SENDCORR").exists()!vx("PROCDT").exists()!vx("EFD").exists() do vau6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("EXPDT").exists() do vau4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PARTAMT").exists()!vx("REPOST").exists() do vau5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STATUS").exists() do vau1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBD //
	type public Number ER = 0
	type public String vx(),RM
	do vbd1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBI //
	type public Number ER = 0
	type public String vx(),RM
	do vbi1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	quit

VBU //
	type public Number ER = 0
	type public String vx(),RM
	type public RecordEFTPAY eftpay
	do vbu4 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("").order().isNull() do AUDIT^UCUTILN(eftpay,.vx(),11,"|") quit
	if vx("AMOUNT").exists()!vx("ANTTOTAL").exists()!vx("CRCD").exists()!vx("FEECONV").exists()!vx("CCODE").exists()!vx("FEETYPE").exists()!vx("ANTRATE").exists()!vx("RCVRCHG").exists()!vx("RCVRCHGC").exists()!vx("FEEPAYOR").exists() do vbu12 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CID").exists()!vx("RECACCT").exists()!vx("RECINST").exists()!vx("TTYPE").exists() do vbu6 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("CRCTACCT").exists()!vx("CRCTGL").exists() do vbu7 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("EFTSRCDD").exists() do vbu2 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("HLDAUTO").exists() do vbu8 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MSG1").exists()!vx("MSG2").exists()!vx("MSG3").exists()!vx("MSG4").exists() do vbu5 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("MSGFP1").exists()!vx("MSGFP2").exists()!vx("MSGFP3").exists()!vx("MSGFP4").exists()!vx("MSGFP5").exists()!vx("MSGFP6").exists() do vbu9 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("PTYSTAT").exists() do vbu13 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("REJECT").exists() do vbu10 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SENDNOS").exists()!vx("INTEXT").exists()!vx("SENDCORR").exists()!vx("PROCDT").exists()!vx("EFD").exists() do vbu1 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("SETCRCD").exists() do vbu11 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	if vx("STATUS").exists() do vbu3 if ER throw Class.new("Error","%PSL-E-DBFILER,"_RM.get().replace(",","~"))
	do AUDIT^UCUTILN(eftpay,.vx(),11,"|")
	quit


vad1 // Trigger AFTER_DELETE - After Delete trigger

	type public RecordEFTPAY eftpay
	/*
	 ---- Revision History ------------------------------------------------

	 06/26/02 - SIGDAE - 50872
		Added code to remove EFTREF records in eftpay.refno is not null.
	 ----------------------------------------------------------------------
	*/

	new REFNO
	if eftpay.refno'="" do {
		set REFNO=eftpay.refno
		do Db.delete("EFTREF","REFNO=:REFNO")
	}
	quit

vai1 // Trigger AFTER_INSERT - EFTPAY Filer After Insert Trigger

	type public RecordEFTPAY eftpay
	/*
	   ---- Revision History ------------------------------------------------

	   08/10/04 - KELLYP - CR 11405
	   	      Added check on STBLEFT for NDPO's when testing ttype
	   	      because ttype is not set for foreign payments.

	   10/17/02 - RICKARDSC - 49098
		      Added check for EFD<PROCDT for foreign payments
		      Added calls to DATCHK for PROCDT and EFD for foreign
		      payments

	   10/16/02 - SIGDAE - 51270
		      Added checks for Amount Type.

	   04/22/02 - SIGDAE - 50427
		      Modified updates to dep/ln.payeft to use bypassSave
		      method.  Also move this code under the IBS section.

	   12/12/01 - SIGDAE - 48558
		      Modified trigger to only check the account level for
	 	      EFTDEB and EFTREQ.  Added check for EFTDD.
	
	   10/24/01 - RICKARDSC - 45998
		      Modified trigger to always validate SENDNOS and SENDCORR
		      by a call to NOSCHECK^PROCEFT for outgoing and incoming
		      foreign payments, and added SETCRCD check.

	   10/18/01 - SIGDAE - 47857
		      Added code to check domestic payment ONUS recipient 
		      account to see if it is valid and not closed.

	   06/13/01 - SIGDAE - 45301
		      Fix undefined error for variable xtype.

	   06/11/01 - SIGDAE - 45301
		      Consolidated $$SqlSelect macros to minimize the number of
		      global accesses and reduce the amount of compiled code
		      that gets generated; eliminated unnecessary macros.

		      Modified calls to MSG1 and MSG2^SWFTEDIT to pass a second
		      argument (SWFTCHAR) to avoid the need to build the string
		      of acceptable characters for each field.  Moved this edit
		      checking after other, less labor intensive edit checking
		      has been performed.

		      Removed older revision history.

	   10/24/00 - JERUCHIMC - 42266
	              Remove integrity check.

	   10/05/00 - MaltepesA 42199
		      Added check if efttype="" then set it to
		      STBLEFTTYPE.EFTTYPE

  	   09/07/00 - MaltepesA - 41255
          	      Modified to look at the new table STBLEFTTYPE to get a
             	      payment type instead of getting it directly from EFTPAY table.	
	  
	   08/07/00 - SCHWARTZC - 41394
	              Removed code updating eftpay.lnm.  This code has been 
		      moved to the BEFORE_INSERT and BEFORE_UPDATE triggers.
	*/

	if (%ProcessMode=2) quit
	
	new CLS,CRCD,EMUMEM,STBLEFT,XCID,XACN

	type RecordDEP dep
	type RecordLN ln

	// Invalid CIF ~p1
	set XACN=eftpay.acn
	if XACN'="",'Db.isDefined("CIF","XACN") do Runtime.setErrMSG("EFTPAY",7575) quit:ER
	set XCID=eftpay.cid

	set STBLEFT=eftpay.efttype
	set STBLEFT=Db.getOneRow("STBLEFT","CTBLEFTTYPE","STBLEFT")

	// Date cannot be less than date of creation
	if eftpay.efd<eftpay.datecre do Runtime.setErrMSG("EFTPAY",8368) quit:ER

	// IBS account
	if (STBLEFT'["NDPO"),(eftpay.ttype<2) do { quit:ER
		new CLS,EFTDD,EFTDEB,EFTREQ,PAYEFT,STAT

		// ~p1 is not a valid account number
		if '+XCID do Runtime.setErrMSG("EFTPAY",7683,"XCID") quit:ER
		if 'Db.isDefined("ACN","XCID") do Runtime.setErrMSG("EFTPAY",7683,"XCID") quit:ER

		if Db.isDefined("DEP","XCID") do {
			set dep=Db.getRecord("DEP","XCID")
			set CLS="D"
			set EFTDD=dep.eftdd
			set EFTDEB=dep.eftdeb
			set EFTREQ=dep.eftreq
			set PAYEFT=dep.payeft
			set STAT=dep.stat
		}
		else  do {
			set ln=Db.getRecord("LN","XCID")
			set CLS="L"
			set EFTDD=ln.eftdd
			set EFTDEB=ln.eftdeb
			set EFTREQ=ln.eftreq
			set PAYEFT=ln.payeft
			set STAT=ln.stat
		}

		// Account ~p1 is closed
		if STAT=4 do Runtime.setErrMSG("EFTPAY",6050,XCID) quit:ER

		// Collection orders not permitted for account ~p1
		if STBLEFT["CO",EFTREQ'=1 do Runtime.setErrMSG("EFTPAY",3810,XCID) quit:ER

		// Payment orders not permitted for account ~p1
		if STBLEFT["PO",EFTDEB'=1 do Runtime.setErrMSG("EFTPAY",3805,XCID) quit:ER

		// Direct debits not permitted for account ~p1
		if STBLEFT="DD",EFTDD'=1 do Runtime.setErrMSG("EFTPAY",5085,XCID) quit:ER

		// Set the PAYEFT flag on account upon creation of standing order
		if CLS="D",PAYEFT'=1 do {
			set dep.payeft=1
			do dep.bypassSave()
		}
		if CLS="L",PAYEFT'=1 do {
			set ln.payeft=1
			do ln.bypassSave()
		}
	}

	// Domestic payment ONUS recipient account
	if STBLEFT'["NDPO",'(eftpay.ttype#2) do { quit:ER
		new ONUS,RECACCT,RECINST,STAT
		set RECINST=eftpay.recinst
		set ONUS=Db.getOneRow("ONUS","UTBLEFTINST","RECINST")
		if 'ONUS quit

		set RECACCT=eftpay.recacct
		// ~p1 is not a valid account number
		if '+RECACCT do Runtime.setErrMSG("EFTPAY",7683,RECACCT) quit:ER
		if 'Db.isDefined("ACN","RECACCT") do Runtime.setErrMSG("EFTPAY",7683,RECACCT) quit:ER
		set STAT=Db.getOneRow("STAT","ACN","RECACCT")

		// Account ~p1 is closed
		if STAT=4 do Runtime.setErrMSG("EFTPAY",6050,RECACCT) quit:ER
	}

	// Check for valid Amount Types based on Account Type and EFT Type
	do AMTTYP^PROCEFT(eftpay.amttyp,eftpay.cid,STBLEFT,eftpay.ttype) quit:ER

	// Minimum 2 lines required for intermediary
	if eftpay.inter2="",eftpay.inter1'="" do Runtime.setErrMSG("EFTPAY",2101) quit:ER

	// SETCRCD cannot equal 1 if non-IN currency
	set CRCD=eftpay.crcd
	set EMUMEM=Db.getOneRow("EMU","CRCD","%CompanyName,CRCD")
	if EMUMEM'=1,eftpay.setcrcd=1 do Runtime.setErrMSG("EFTPAY",3604) quit:ER

	// Incoming foreign payments
	if STBLEFT="NDPOIN" do { quit:ER
		// Debit account cannot be same as beneficiary's account
		if XCID'="",eftpay.sendnos=eftpay.cid do Runtime.setErrMSG("EFTPAY",7754) quit:ER

		// Validate SENDNOS and SENDCORR
		do NOSCHECK^PROCEFT(.eftpay) quit:ER

		// Settlement date cannot be less than payment date
		if eftpay.efd<eftpay.procdt do Runtime.setErrMSG("EFTPAY",7542) quit:ER

		// Verify PROCDT and EFD
		do DATCHK^PROCEFT(1,eftpay.procdt,eftpay.sendcorr) quit:ER
		do DATCHK^PROCEFT(0,eftpay.efd,eftpay.sendcorr) quit:ER
	}
	
	// Outgoing foreign payments
	if STBLEFT="NDPO" do { quit:ER
		// Credit account cannot be same as payment account
		if eftpay.sendnos'="",eftpay.sendnos=eftpay.acn do Runtime.setErrMSG("EFTPAY",7657) quit:ER

		// Validate SENDNOS and SENDCORR
		do NOSCHECK^PROCEFT(.eftpay) quit:ER

		do BENINST^PROCEFT(eftpay.beninst,.eftpay) quit:ER

		// Settlement date cannot be less than payment date
		if eftpay.efd<eftpay.procdt do Runtime.setErrMSG("EFTPAY",7542) quit:ER

		// Verify PROCDT and EFD
		do DATCHK^PROCEFT(0,eftpay.procdt,eftpay.sendcorr) quit:ER
		do DATCHK^PROCEFT(1,eftpay.efd,eftpay.sendcorr) quit:ER

		// Ensure fields conform to SWIFT standards
		do DICHECK^PROCEFT(.eftpay)
	}
	
	// Standing foreign payments
	if STBLEFT="NDPOST" do BENINST^PROCEFT(eftpay.beninst,.eftpay) quit:ER
	
	// Validate message format /text/ or //text
	if eftpay.msgfp1'="" do MSG1^SWFTEDIT(eftpay.msgfp1,.SWFTCHAR) quit:ER
	if eftpay.msgfp2'="" do MSG2^SWFTEDIT(eftpay.msgfp2,.SWFTCHAR) quit:ER
	if eftpay.msgfp3'="" do MSG2^SWFTEDIT(eftpay.msgfp3,.SWFTCHAR) quit:ER
	if eftpay.msgfp4'="" do MSG2^SWFTEDIT(eftpay.msgfp4,.SWFTCHAR) quit:ER
	if eftpay.msgfp5'="" do MSG2^SWFTEDIT(eftpay.msgfp5,.SWFTCHAR) quit:ER
	if eftpay.msgfp6'="" do MSG2^SWFTEDIT(eftpay.msgfp6,.SWFTCHAR) quit:ER
	quit

vau1 // Trigger AFTER_STATUS - After Status Update to "D"elete Trigger

	type public RecordEFTPAY eftpay
	/*---- Revision History ------------------------------------------------

	 04/22/02 - SIGDAE - 50427
		    Modified updates to dep/ln.payeft to use bypassSave
		    method.

	 07/24/01 - YURKOVICG - 45987
		    Moved code which updates PAYEFT flag above check of HLDAUTO.
		    Cleaned up structure of code at end of trigger.
	
	 06/11/01 - SIGDAE - 45301
		    Miscellaneous clean-up.

	 08/04/00 - SCHWARTZC - 41394
	            Removed code setting EFTPAY.LNM if it was null.  This code
		    has been moved to the BEFORE_UPDATE trigger.

	----------------------------------------------------------------------
	*/

	if eftpay.status="AP",eftpay.uidmod=%UserID do Runtime.setErrMSG("EFTPAY",7682) quit:ER
	if eftpay.status="V",eftpay.uidadd=%UserID do Runtime.setErrMSG("EFTPAY",7687) quit:ER

	// Remaining code not for G/Ls
	if eftpay.ttype'<2 quit

	// Update PAYEFT flag on account
	if eftpay.status="D" do {
		new CLS,XCID
		set XCID=eftpay.cid

		type ResultSet rs
		set rs=Db.select("SEQ","EFTPAY","CID=:XCID AND STATUS='A'")
		if 'rs.isEmpty() quit

		if Db.isDefined("DEP","XCID") do { quit
			type RecordDEP dep
			set dep=Db.getRecord("DEP","XCID")
			set dep.payeft=0
			do dep.bypassSave()
		}
		if Db.isDefined("LN","XCID") do {
			type RecordLN ln
			set ln=Db.getRecord("LN","XCID")
			set ln.payeft=0
			do ln.bypassSave()
		}
	}

	/*
	   Remove hold on outgoing clean payment if the status is 
	   changed to "D"elete and HLDAUTO flag is on.
	*/
	if eftpay.status="D",eftpay.hldauto=1 do { quit:ER
		new X
		set X=$$RMHLDS^EFTFUNCS(eftpay.cid,eftpay.seq)
		if 'X do Runtime.setErrMSG("EFTPAY",8343) quit
		}
	
	// SENDNOS required when outgoing has been approved
	if eftpay.efttype="NDPO",eftpay.status="AP",eftpay.sendnos="" do Runtime.setErrMSG("EFTPAY",7668) quit:ER

	quit

vau2 // Trigger AFTER_UPDATE - After Update all fields

	type public RecordEFTPAY eftpay
	/* 
	---- Revision History ------------------------------------------------
	04/22/02 - SIGDAE - 50427
		   Added check for EFTPAY.EFTTYPE="NDPO" before calling
		   DICHECK.

	06/11/01 - SIGDAE - 45301
		   Removed unused code.

		   Deleted older revision history.
	----------------------------------------------------------------------
	*/

	if eftpay.efttype="NDPO" do DICHECK^PROCEFT(.eftpay)

	quit

vau3 // Trigger AFT_UPD_AMTTYP - After Update of Amount Type

	type public RecordEFTPAY eftpay
	/*
	 ---------- Revision History ------------------------------------------

	 10/16/02 - SIGDAE - 51270
		Added checks for Amount Type.

	 ----------------------------------------------------------------------
	*/

	new EFTTYPE

	set EFTTYPE=eftpay.efttype

	type RecordCTBLEFTTYPE ctbleft=Db.getRecord("CTBLEFTTYPE","EFTTYPE")

	// Check for valid Amount Types based on Account Type and EFT Type
	do AMTTYP^PROCEFT(eftpay.amttyp,eftpay.cid,ctbleft.stbleft,eftpay.ttype) quit:ER
	quit

vau4 // Trigger AFT_UPD_EXPDT - After Update Expiration Date

	type public RecordEFTPAY eftpay
	/*
	  ---- Revision History ------------------------------------------------

	  03/04/02 - SIGDAE - 49001:01
		Added code to check Expiration Date.
	  ----------------------------------------------------------------------
	*/

	if eftpay.expdt="" quit

	new BD,CAL,CRCD,UFRE

	set CRCD=eftpay.crcd
	set CAL=Db.getOneRow("CALENDAR","CRCD","%CompanyName,CRCD")
	set UFRE=eftpay.frequency
	set BD=Db.getOneRow("BD","USRFRE","UFRE")

	// Expiration date must be business day.
	if (BD'=""&(BD'["A")),'$$BD^UNBD(eftpay.expdt,CAL) do Runtime.setErrMSG("EFTPAY",6062) quit:ER
	else  if UFRE'["A",'$$BD^UNBD(eftpay.expdt,CAL) do Runtime.setErrMSG("EFTPAY",6062) quit:ER

	// Effective date greater than Expiration date.
	if eftpay.efd>eftpay.expdt do Runtime.setErrMSG("EFTPAY",6063) quit:ER
	quit

vau5 // Trigger AFT_UPD_PARTAMT - After Update Partial Amount

	type public RecordEFTPAY eftpay
	/*
	 ---- Revision History ------------------------------------------------

	 12/20/03 - CARROLLJ - CR7658
		Added #ACCEPT prior to xecute command.

	 08/07/01 - SIGDAE - 46611
		Added arguments to PP^PROCRICO call.

		Removed older revision history.
	*/

	new PGM,PPSEQ

	if eftpay.partamt="" do {
		set PPSEQ=eftpay.seq
		set PGM=$$GET^UBCHID("BCHEFT") if PGM="" quit
		set XECUTE="D public^"_PGM_"(CID,PPSEQ,,,1)"
		#ACCEPT DATE=12/30/03;PGM=John Carroll
		xecute XECUTE
		}

	if eftpay.partamt="" quit
	new PPSEQ
	set PPSEQ=$$PP^PROCRICO(CID,SEQ,eftpay.partamt)
	if ER quit
	if PPSEQ="" quit

	// Protect SEQ
	new SEQ

	// Process the partial payment record via call to public linetag in batch
	set PGM=$$GET^UBCHID("BCHEFT") if PGM="" quit
	set XECUTE="D public^"_PGM_"(CID,PPSEQ)"
	#ACCEPT DATE=12/30/03;PGM=John Carroll
	xecute XECUTE
	quit

vau6 // Trigger AFT_UPD_SENDNOS - After Update Sender's Nostro/Vostro

	type public RecordEFTPAY eftpay
	/*
	 ---- Revision History ------------------------------------------------
	 10/17/02 - RICKARDSC - 49098
		Added check for EFD<PROCDT for foreign payments
		Added calls to DATCHK for PROCDT and EFD for foreign
		payments
	*/

	new CRCD,EMUMEM

	// SETCRCD cannot equal 1 if non-IN currency
	set CRCD=eftpay.crcd
	set EMUMEM=Db.getOneRow("EMU","CRCD","%CompanyName,CRCD")
	if EMUMEM'=1,eftpay.setcrcd=1 do Runtime.setErrMSG("EFTPAY",3604) quit:ER

	// Non-foreign payment
	if eftpay.efttype'["NDPO" do { quit:ER
		// Verify PROCDT and EFD
		do SDTIP^PROCEFT(eftpay.procdt,.eftpay) quit:ER
		do VDTIP^PROCEFT(eftpay.efd,.eftpay) quit:ER
	}

	// Incoming foreign payments
	if eftpay.efttype="NDPOIN" do { quit:ER
		// Validate SENDNOS and SENDCORR for foreign payments
		do NOSCHECK^PROCEFT(.eftpay) quit:ER

		// Settlement date cannot be less than payment date
		if eftpay.efd<eftpay.procdt do Runtime.setErrMSG("EFTPAY",7542) quit:ER

		// Verify PROCDT and EFD
		do DATCHK^PROCEFT(1,eftpay.procdt,eftpay.sendcorr) quit:ER
		do DATCHK^PROCEFT(0,eftpay.efd,eftpay.sendcorr) quit:ER
	}

	// Outgoing foreign payments
	if eftpay.efttype="NDPO" do { quit:ER
		// Validate SENDNOS and SENDCORR for foreign payments
		do NOSCHECK^PROCEFT(.eftpay) quit:ER

		// Settlement date cannot be less than payment date
		if eftpay.efd<eftpay.procdt do Runtime.setErrMSG("EFTPAY",7542) quit:ER

		// Verify PROCDT and EFD
		do DATCHK^PROCEFT(0,eftpay.procdt,eftpay.sendcorr) quit:ER
		do DATCHK^PROCEFT(1,eftpay.efd,eftpay.sendcorr) quit:ER
	}
	quit

vbd1 // Trigger BEFORE_DELETE - Before Delete Trigger

	type public RecordEFTPAY eftpay
	if eftpay.status'="D" set ER=1,RM=$$^MSG(433,eftpay.status)
	quit

vbi1 // Trigger BEFORE_INSERT - Before insert of eftpay record

	type public RecordEFTPAY eftpay
	/*
	   ---- Revision History ------------------------------------------------
	   
	   05/11/04 - RussellDS - CR9592
	  	Added code to calculate and set value of EFTPAY.CRCDCID.

	   10/17/02 - RICKARDSC - 49098
		Added call to DATIP for foreign payments
		Removed calls to SDTIP2 and VDTIP2 for incoming foreign
		payments

	   10/16/02 - SIGDAE - 51270
		Moved check on Amount Type equal 18 to After Insert Trigger.

		Deleted older revision history.

	   03/04/02 - SIGDAE - 49001:01
		o Modified '["NDPO" section to move the auto hold logic
		  into this section.  The "}" was in the wrong location.
		o Modified '["NDPO" section to use the currency code
		  calendar when checking Expiration Date.

	   02/08/02 - RICKARDSC - 48359
		Modified to call CALCANT^PROCEFT for all incoming and outgoing
		foreign payments.

	   12/06/01 - SIGDAE - 48608
		o Modified calls to place holds to use new PSL version 
		  of PLHLDS^EFTFUNCS.
		o Set eftpay.hldauto=0 for G/L account orders.
		o Change DEBCHECK^BCHEFT call to use DEBCHECK^EFTFUNCS

	   10/24/01 - RICKARDSC - 45998
		Removed validation of SENDNOS and SENDCORR for outgoing and
		incoming foreign payments. The validation has been moved to
		the AFTER_INSERT trigger.
		Modified SETCRCD default logic to use CUVAR.SCDFT.

	   10/18/01 - SIGDAE - 47857
		Moved check for same account transaction to non-foreign
		payment section since RECINST will not be defined during
		creation for foreign orders.

	   10/15/01 - SIGDAE - 47552
		o Added code to set TRIES equal to UTBLEFTINST.RETRY for
		  Direct Debits.
		o Removed setting of AMOUNT for Amount types greater than 1.

	*/
	
	new CRCD,EFTTYPE,EMUMEM,PROCDT,SCDFT,STBLEFT,VALDT,XCID

	if eftpay.efttype="" quit

	set CRCD=eftpay.crcd
	set XCID=eftpay.cid
 	set EFTTYPE=eftpay.efttype

	type RecordCTBLEFTTYPE ctbleft=Db.getRecord("CTBLEFTTYPE","EFTTYPE")

	set STBLEFT=ctbleft.stbleft

	// Verify proper use of memo and header G/Ls in the EFTPAY record
	do GLCHECK^PROCEFT(STBLEFT,eftpay.ttype,eftpay.cid,eftpay.recinst,eftpay.recacct)
	if ER quit
	
	// Calculate and set value of CRCDCID
	set eftpay.crcdcid=$$CRCDCID^EFTFUNCS(eftpay.cid,eftpay.ttype,eftpay.crcd)

	/*
	 Default settlement currency flag
	 Settlement currency must equal 0 for a non-In currency.
	*/
	set EMUMEM=Db.getOneRow("EMU","CRCD","%CompanyName,CRCD")
	if EMUMEM=1 do {
		set SCDFT=Db.getOneRow("SCDFT","CUVAR")
		if eftpay.setcrcd="" set eftpay.setcrcd=+SCDFT
		}
	else  set eftpay.setcrcd=0

	// Cannot be a negative amount
	if eftpay.amount<0 do Runtime.setErrMSG("EFTPAY",415) quit:ER

	// Verify the decimal precision of the payment currency.
	new CURDEC,DECPRS
	set CURDEC=Db.getOneRow("CURDEC","CRCD","%CompanyName,CRCD") quit:ER
	set DECPRS=.1**CURDEC
	if eftpay.amount#DECPRS>0 do Runtime.setErrMSG("EFTPAY",775) quit:ER
		
	//  Populate PTYSTAT if PTYSTAT is null
	if eftpay.ptystat="" set eftpay.ptystat=999
	// Only standing payment orders may have a priority status
	if (STBLEFT'="SPO"),(eftpay.ptystat'=999) do Runtime.setErrMSG("EFTPAY",4187,"RM") quit:ER
	
	// Holds for Profile accounts only
	if eftpay.ttype>1 set eftpay.hldauto=0

	// Non Foreign EFTPAY entries
	if STBLEFT'["NDPO" do { quit:ER
		new DATA,EFTINST,ONUS,RECINST

		set RECINST=eftpay.recinst
		set EFTINST=Db.getOneRow("ONUS,RETRY","UTBLEFTINST","RECINST")
		set ONUS=$P(EFTINST,$C(9),1)

		if eftpay.status="" set eftpay.status="A"
		if eftpay.met="" set eftpay.met=ctbleft.paymetdft
		if eftpay.met="" set eftpay.met="CC"
		if eftpay.amttyp="" set eftpay.amttyp=1
		if eftpay.hldauto="" set eftpay.hldauto=ctbleft.hldauto
		if STBLEFT="DD",eftpay.tries="" set eftpay.tries=$P(EFTINST,$C(9),2)
		if eftpay.tries="" set eftpay.tries=ctbleft.tries
		if eftpay.ttype<2 do { quit:ER
			set DATA=Db.getOneRow("BOO,CC,LNM","ACN","XCID")
			if eftpay.brcd="" set eftpay.brcd=$P(DATA,$C(9),1)
			if eftpay.cc="" set eftpay.cc=$P(DATA,$C(9),2)
			if eftpay.lnm="" set eftpay.lnm=$P(DATA,$C(9),3)
			}
		if eftpay.crcd="" set eftpay.crcd=%SystemCurrency

		// Set the source of the direct debit to 1 (Manually Input)
		if STBLEFT="DD" set eftpay.eftsrcdd=1

		// Debit Account cannot be the Beneficiary's Account
		if eftpay.cid=eftpay.recacct,ONUS,((eftpay.ttype=0)!(eftpay.ttype=3)) do Runtime.setErrMSG("EFTPAY",7754) quit:ER

		do ACNIP^PROCEFT(eftpay.acn,.eftpay) quit:ER
		do CRCD^PROCEFT(eftpay.crcd,.eftpay) quit:ER

		/*
		 If using financial option 1, effective date must match offset days
		 If STBLEFT is XCO then do not worry about the offset days because
		 XCOs get created on the same date.

		 Invalid offset in (efttype) for Effective Date:
		*/
		new erstr
		set erstr=EFTTYPE_"~"_$$^MSG(5951,eftpay.efd)
 		if ctbleft.fintras=1,eftpay.efd'=(%SystemDate+ctbleft.ftod) do Runtime.setErrMSG("EFTPAY",5407,erstr) quit:ER
	
		// Frequency required for standing orders
		if eftpay.frequency="",(STBLEFT="SPO"!(STBLEFT="SCO")) do Runtime.setErrMSG("EFTPAY",2105) quit:ER
		if eftpay.frequency'="",eftpay.efd="" set eftpay.efd=$$NJD^UFRE(%SystemDate,eftpay.frequency) if ER do Runtime.setErrMSG("EFTPAY",3333,"RM") quit:ER
		do EFD^PROCEFT(eftpay.efd,.eftpay) quit:ER

		// verify debit authorization - DDs only checked when processed
		if (STBLEFT="CO"!(STBLEFT="SCO")),$$DEBCHECK^EFTFUNCS(.eftpay,ONUS) do Runtime.setErrMSG("EFTPAY",3333,"RM") quit:ER

		/*
		 Payment orders and standing payment orders for Segmented
		 accounts must supply segment information in UNIQTSO.
		*/
		if STBLEFT["PO",'(eftpay.uniqtso["SEGI#")&'(eftpay.uniqtso["SEGP#") do { quit:ER
			new CLS,SEGFLG
			set CLS=Db.getOneRow("CLS","ACN","XCID")
			if CLS'="D" quit
			set SEGFLG=Db.getOneRow("SEGFLG","DEP","XCID")
			if SEGFLG=1 do Runtime.setErrMSG("EFTPAY",3350,"RM") quit:ER
			}

		if eftpay.expdt'="" do { quit:ER			//MCA 6-6-00
			new CAL,UFRE,bd
			set CAL=Db.getOneRow("CALENDAR","CRCD","%CompanyName,CRCD")
			set UFRE=eftpay.frequency
			set bd=Db.getOneRow("BD","USRFRE","UFRE")
			if (bd'=""&(bd'["A")),'$$BD^UNBD(eftpay.expdt,CAL) do Runtime.setErrMSG("EFTPAY",6062) quit:ER //MCA 6-6-00
			else  if UFRE'["A",'$$BD^UNBD(eftpay.expdt,CAL) do Runtime.setErrMSG("EFTPAY",6062) quit:ER	//MCA 6-6-00
			if eftpay.efd>eftpay.expdt do Runtime.setErrMSG("EFTPAY",6063) quit:ER
			}

		if eftpay.ttype<2,eftpay.hldauto do { quit:ER
			new HSEQ
			S HSEQ=$$PLHLDS^EFTFUNCS(.eftpay)
			if HSEQ=0 do Runtime.setErrMSG("EFTPAY",630) quit
			set eftpay.hldseq=HSEQ
			}
																}

	// Outgoing Foreign Payment Orders
	if STBLEFT="NDPO" do { quit:ER

		if eftpay.refno="" do REFNO^PROCEFT(2,.eftpay) quit:ER
		// assign ORD fields if they have not been entered into the record
		do ACNIP^PROCEFT(eftpay.acn,.eftpay)
	
		// Place calculated values in the record
		do CALCANT^PROCEFT(.eftpay) quit:ER
	
		// Validate currency and default payment currency related fields
		do CRCDIP^PROCEFT(eftpay.crcd,.eftpay) quit:ER

		// Default to an external payment
		if eftpay.intext="" set eftpay.intext=1

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// Default PROCDT and EFD
		set PROCDT=eftpay.procdt
		set VALDT=eftpay.efd
		do DATIP^PROCEFT(eftpay.crcd,eftpay.efttype,eftpay.sendcorr,.PROCDT,.VALDT) quit:ER
		if eftpay.procdt="" set eftpay.procdt=PROCDT
		if eftpay.efd="" set eftpay.efd=VALDT

		// places hold on outgoing clean payment for inserts if nondoc PO and 'ogl.
		if eftpay.ttype<2 do { quit:ER
			new HSEQ

			// now insert the hold into PHLD
			set HSEQ=$$PLHLDS^EFTFUNCS(.eftpay)
			if HSEQ=0 do Runtime.setErrMSG("EFTPAY",630) quit 
			set eftpay.hldseq=HSEQ

			// Hold is always placed. Set HLDAUTO=1 so hold removals work.
			set eftpay.hldauto=1
			}
		}
	
	// Incoming Foreign Payment Orders
	if STBLEFT="NDPOIN" do { quit:ER
	
		if eftpay.refno="" do REFNO^PROCEFT(3,.eftpay) quit:ER

		// Decimal precision error
		if eftpay.amount#($$MOD^SCARND("",eftpay.crcd)) do Runtime.setErrMSG("EFTPAY",775) quit:ER
		do CALCANT^PROCEFT(.eftpay) quit:ER
		do BENIP^PROCEFT(eftpay.acn,.eftpay)

		// Validate currency and default payment currency related fields
		do CRCDIP^PROCEFT(eftpay.crcd,.eftpay) quit:ER

		// Default to an external payment
		if eftpay.intext="" set eftpay.intext=1

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// Default PROCDT and EFD
		set PROCDT=eftpay.procdt
		set VALDT=eftpay.efd
		do DATIP^PROCEFT(eftpay.crcd,eftpay.efttype,eftpay.sendcorr,.PROCDT,.VALDT) quit:ER
		if eftpay.procdt="" set eftpay.procdt=PROCDT
		if eftpay.efd="" set eftpay.efd=VALDT

		if eftpay.constant="" do { quit:ER
			new ccycid,XCID
			set XCID=eftpay.cid
			if eftpay.ttype>1 set ccycid=eftpay.crcd
			else  set ccycid=Db.getOneRow("CRCD","ACN","XCID")

			//currency can not equal system currency
			if ccycid=%SystemCurrency new MSG set MSG="CRCD" do Runtime.setErrMSG("EFTPAY",7531,"MSG") quit:ER
			}
		}
	
	// Standing payment foreign orders
	if STBLEFT="NDPOST" do { quit:ER

		new NJD
		set NJD=$$NJD^UFRE(%SystemDate,eftpay.frequency) if ER do Runtime.setErrMSG("EFTPAY",3333,"RM") quit:ER
		if eftpay.frequency'="" do { quit:ER
			if eftpay.frequency<0 do Runtime.setErrMSG("EFTPAY",1354) quit:ER
			set eftpay.efd=eftpay.procdt
			if eftpay.procdt'="" quit 
			set eftpay.procdt=NJD
			set eftpay.efd=NJD
			}
	
		if eftpay.expdt'="" do { quit:ER

			// Expiration date precedes system date.
			if eftpay.expdt<%SystemDate do Runtime.setErrMSG("EFTPAY",1843) quit:ER
	
			// Expiration date precedes next process date.
			if eftpay.expdt<eftpay.procdt do Runtime.setErrMSG("EFTPAY",1846) quit:ER
			}

		//Enter either payment amount or account amount.
		if eftpay.amount'="",eftpay.antamt'="" do Runtime.setErrMSG("EFTPAY",1883) quit:ER
		if eftpay.amount="",eftpay.antamt="" do Runtime.setErrMSG("EFTPAY",1883) quit:ER
	
		//Payment amount must have a positive value.
		if eftpay.amount<0 do Runtime.setErrMSG("EFTPAY",1888) quit:ER
		if eftpay.antamt<0 do Runtime.setErrMSG("EFTPAY",1888) quit:ER
		}

	new TOTLEN
	set TOTLEN=$L(eftpay.msg1)+$L(eftpay.msg2)+$L(eftpay.msg3)+$L(eftpay.msg4)
	set TOTLEN=TOTLEN+$L(eftpay.recinst)+$L(eftpay.recacct)+$L(eftpay.efttype)
	set TOTLEN=TOTLEN+$L(eftpay.seq)+$L(eftpay.benad1)+$L(eftpay.cid)+$L(eftpay.lnm)
	set TOTLEN=TOTLEN+$L(eftpay.constant)+$L(eftpay.variable)+$L(eftpay.specific)
	set TOTLEN=TOTLEN+$L(eftpay.met)+$L(eftpay.source)+$L(eftpay.thold)
	set TOTLEN=TOTLEN+4
	if TOTLEN>200 do Runtime.setErrMSG("EFTPAY",2338,"RM") quit:ER
	
	quit

vbu1 // Trigger BEFORE_SENDNOS - Before Update of SENDNOS

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/*
	 ---- Revision History ------------------------------------------------

	 10/17/02 - RICKARDSC - 49098
		Added call to DATIP for foreign payments

	 10/29/01 - RICKARDSC - 45998
		Modified to use NOSIP^PROCEFT to default SENDNOS and SENDCORR

	 10/15/01 - SIGDAE - 47552
		Change 3rd argument for call to NOSSPP^DEALSINT to be 
		SENDNOS instead of X.

	 06/11/01 - SIGDAE - 45301
		Miscellaneous clean-up.

		Deleted pre-2000 revision history.
	*/

	new erstr,EFTTYPE,PROCDT,VALDT

	type RecordCTBLEFTTYPE etype

	set EFTTYPE=eftpay.efttype
	set etype=Db.getRecord("CTBLEFTTYPE","EFTTYPE")

	// Invalid offset in (efttype) for Effective Date:
	set erstr=EFTTYPE_"~"_$$^MSG(5951,eftpay.efd)
	if etype.fintras=1,eftpay.efd'=(%SystemDate+etype.ftod) do Runtime.setErrMSG("EFTPAY",5407,erstr)

	// Outgoing and Incoming Foreign Payment Orders
	if (eftpay.efttype="NDPO")!(eftpay.efttype="NDPOIN") do {

		// Default to an external payment
		if eftpay.intext="" set eftpay.intext=1

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// Default PROCDT and EFD
		set PROCDT=eftpay.procdt
		set VALDT=eftpay.efd
		do DATIP^PROCEFT(eftpay.crcd,eftpay.efttype,eftpay.sendcorr,.PROCDT,.VALDT) quit:ER
		if eftpay.procdt="" set eftpay.procdt=PROCDT
		if eftpay.efd="" set eftpay.efd=VALDT
	}
	quit

vbu2 // Trigger BEFORE_SOURCEDD - Update before SOURCEDD

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/*
	 ---Revision History----------------------------------------------------------

	 06/11/01 - SIGDAE - 45301
		    Replaced reference to eftpay.efttype with STBLEFTTYPE value.

		    Removed pre-2000 revision history
	*/

	new STBLEFT
	set STBLEFT=eftpay.efttype
	set STBLEFT=Db.getOneRow("STBLEFT","CTBLEFTTYPE","STBLEFT")
	/*
	   Set the source of the direct debit to 1 (Manually Input). If the payment
	   is a direct debit.
	*/
	if STBLEFT="DD" set eftpay.eftsrcdd=1
	quit

vbu3 // Trigger BEFORE_STATUS - Before Update of Status

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/*
	 ---Revision History----------------------------------------------------------

	 12/06/01 - SIGDAE - 48608
		Added code to call DATES^EFTFUNCS to define next possible
		effective date and corresponding process date when 
		resubmitting a suppressed order.

	 06/11/01 - SIGDAE - 45301
		Miscellaneous clean-up.  Removed insert of DAYENDEFT record.
		Since this is an index, updating PROCDT will handle the
		creation of the new entry.

		Deleted pre-2000 revision history.
	*/

	// Resubmit of Suppressed order - set new EFD and PROCDT if necessary
	if eftpay.status="A",eftpay.status.oldVal="SUP",eftpay.procdt<%SystemDate do {
		new ONUS,PROCDT,RECINST,STBLEFT
		set RECINST=eftpay.recinst
		set ONUS=Db.getOneRow("ONUS","UTBLEFTINST","RECINST")
		set STBLEFT=eftpay.efttype
		set STBLEFT=Db.getOneRow("STBLEFT","CTBLEFTTYPE","STBLEFT")
		set eftpay.efd=$$DATES^EFTFUNCS(%SystemDate,"1DA",ONUS,0,STBLEFT,eftpay.crcd,.PROCDT)
		set eftpay.procdt=PROCDT
	}
	quit

vbu4 // Trigger BEFORE_UPDATE - EFTPAY Before Update Trigger

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/*
	   ---- Revision History -----------------------------------------------
	  
	  01/10/03 - KINI - 51316
		     Removed quit in the middle of the code since it prevented 
		     successful filer compilation and subsequent code 
		     execution.          	   
	
	  06/11/01 - SIGDAE - 45301
		     Miscellaneous clean-up.
		     Deleted pre-2000 revision history.

	  08/07/00 - SCHWARTZC - 41394
	             Modified to set eftpay.lnm when it is null. eftpay.lnm
		     is required for maker checker processing.

	  02/09/00 - SCHWARTZC - 35615
		     Modify change made on 01/11/00 to include reversals.

	  01/11/00 - KELLYP - 35902
		     Modified to allow modifications to the EFTPAY record
		     for status "C", "R", and "D" in the event that it is
		     being modified because of a cancellation or return.
	*/

	new oldstat
	set oldstat=eftpay.status.oldVal
	if '$G(EXPORT)&'$G(CANCEL)&'$G(RETURN)&'$G(REVERSE)&((oldstat="C")!(oldstat="R")!(oldstat="D")) do Runtime.setErrMSG("EFTPAY",7669,oldstat) quit

	/*
	   CDS 8/23/99
	   Verify that the amount entered conforms to the decimal precision of the
	   payment currency.
	*/
	new curdec,DECPRS,CO,EMUMEM,CRCD
	set CO=%CompanyName
	set CRCD=eftpay.crcd
	set curdec=Db.getOneRow("CURDEC","CRCD","CO,CRCD") quit:ER
	set DECPRS=.1**curdec
	if eftpay.amount#DECPRS>0 do Runtime.setErrMSG("EFTPAY",775) quit:ER

	if (eftpay.ttype<2),(eftpay.lnm="") do {
		new LNM,XCID
		set XCID=eftpay.cid
		set LNM=Db.getOneRow("LNM","ACN","XCID")
		set eftpay.lnm=LNM
		}
	quit

vbu5 // Trigger BEFORE_UPDATE_MSG - Before Update MSG

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)

	new TOTLEN
	set TOTLEN=$L(eftpay.msg1)+$L(eftpay.msg2)+$L(eftpay.msg3)+$L(eftpay.msg4)
	set TOTLEN=TOTLEN+$L(eftpay.recinst)+$L(eftpay.recacct)+$L(eftpay.efttype)
	set TOTLEN=TOTLEN+$L(eftpay.seq)+$L(eftpay.benad1)+$L(eftpay.cid)+$L(eftpay.lnm)
	set TOTLEN=TOTLEN+$L(eftpay.constant)+$L(eftpay.variable)+$L(eftpay.specific)
	set TOTLEN=TOTLEN+$L(eftpay.met)+$L(eftpay.source)+$L(eftpay.thold)
	set TOTLEN=TOTLEN+4
	if TOTLEN>200 do Runtime.setErrMSG("EFTPAY",2338,"RM") quit:ER
	quit

vbu6 // Trigger BEFORE_UPD_ACCOUNT - Before Updating Account Number

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)

	/* 
	   ---Revision History-------------------------------------------------------------------------

	   12/12/01 - SIGDAE - 48558
		Replaced EFTMEMO check code with call to GLCHECK^PROCEFT.

	   10/18/01 - SIGDAE - 47857
		Added code to check domestic payment ONUS recipient
		account to see if it is valid and not closed.

	   06/11/01 - SIGDAE - 45301
		Miscellaneous clean-up.

		Deleted pre-2000 revision history.
	   
	   12/14/00 - JERUCHIMC - 43158
		Expand Memo G/L account edit check to include header G/Ls.
	
	   12/10/00 - JERUCHIMC - 43150 (roll forward 41875)
		Add edit check for Memo G/L account
	*/

	new STBLEFT

	new STBLEFT
	set STBLEFT=eftpay.efttype
	set STBLEFT=Db.getOneRow("STBLEFT","CTBLEFTTYPE","STBLEFT")

	do GLCHECK^PROCEFT(eftpay.efttype,eftpay.ttype,eftpay.cid,eftpay.recinst,eftpay.recacct)
								quit:ER

								// Domestic payment ONUS recipient account
								if STBLEFT'["NDPO",'(eftpay.ttype#2) do { quit:ER
		new ONUS,RECACCT,RECINST,STAT
		set RECINST=eftpay.recinst
		set ONUS=Db.getOneRow("ONUS","UTBLEFTINST","RECINST")
		if 'ONUS quit
	
		set RECACCT=eftpay.recacct
		// ~p1 is not a valid account number
		if '+RECACCT do Runtime.setErrMSG("EFTPAY",7683,RECACCT) quit:ER
		if 'Db.isDefined("ACN","RECACCT") do Runtime.setErrMSG("EFTPAY",7683,RECACCT) quit:ER
		set STAT=Db.getOneRow("STAT","ACN","RECACCT")
	
		// Account ~p1 is closed
		if STAT=4 do Runtime.setErrMSG("EFTPAY",6050,RECACCT) quit:ER
								}

	/*
	   The following checks that for a payment order or standing payment order, the
	   originating account is not segmented, unless segment information is supplied
	   in UNIQTSO.
	*/
	I STBLEFT["PO",'(eftpay.uniqtso["SEGI#")&'(eftpay.uniqtso["SEGP#") do {
		new CLS,SEGFLG,XCID
		set XCID=eftpay.cid
		set CLS=Db.getOneRow("CLS","ACN","XCID")
		if CLS'="D" quit
		set SEGFLG=Db.getOneRow("SEGFLG","DEP","XCID")
		; Cannot manually create payment orders for segmented accounts
		if SEGFLG=1 do Runtime.setErrMSG("EFTPAY",3350,"RM") quit:ER
		}
	quit

vbu7 // Trigger BEFORE_UPD_CRCTACCT - Before Update Correct Account

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/* ---Revision History-------------------------------------------------------------------------
	
	01/06/04 - CARROLLJ - CR7658
		Added #ACCEPT prior to xecute command.

	08/07/01 - SIGDAE - 46611
		Modified the call to PROCRICO^PROCRICO to use new function
		NEWACCT^PROCRICO().

		Removed older revision history,
	*/

	new CRCTACCT,CRCTGL,NEWCID,NEWCIDSQ,NEWSEQ,newcid
	set CRCTACCT=eftpay.crctacct
	set CRCTGL=eftpay.crctgl
	if CRCTACCT'="" set newcid=Db.getOneRow("CID","ACN","CRCTACCT")
	if CRCTGL'="" set newcid=Db.getOneRow("ACN","GLAD","CRCTGL")
	
	//~p1 Not a valid account number
	if (CRCTACCT'=""),(newcid="") set ER=1,RM=$$^MSG(3058,CRCTACCT) quit

	//Invalid G/L account ~p1
	if (CRCTGL'=""),(newcid="") set ER=1,RM=$$^MSG(1364,CRCTGL) quit

	if eftpay.repost'=1 quit

	// Call to PSL procedure to handle changing the account number
	set NEWCIDSQ=$$NEWACCT^PROCRICO(CID,SEQ,CRCTACCT,CRCTGL)
	if ER quit
	if NEWCIDSQ="" quit
	set NEWCID=$P(NEWCIDSQ,"|",1)
	set NEWSEQ=$P(NEWCIDSQ,"|",2)

	set eftpay.status="D"

	// Protect SEQ
	new SEQ

	// Process the partial payment record via call to public linetag in batch
	set PGM=$$GET^UBCHID("BCHEFT") if PGM="" quit
	set XECUTE="D public^"_PGM_"(NEWCID,NEWSEQ)"
	#ACCEPT DATE=12/30/03;PGM=John Carroll
	xecute XECUTE
	quit

vbu8 // Trigger BEFORE_UPD_HLDAUTO - Maintain Holds on HLDAUTO

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/*
		---Revision History-----------------------------------------------------

		05/22/02 - SIGDAE - 49389
		Removed setting of HLDSEQ="" after call to RMHLDS^EFTFUNCS.

		12/06/01 - SIGDAE - 48608
		Modified calls to place holds to use new PSL version of
		PLHLDS^EFTFUNCS.

		07/17/01 - SIGDAE - 45449
		Added argument FREQUENCY to PLHLDS2^EFTFUNCS call.
	
		06/11/01 - SIGDAE - 45301
		Changed call for domestic order holds to use new function
		PLHLDS2^EFTFUNCS.

		01/05/01 - Carol Scott - 43034
  		This trigger will either remove a hold if the HLDAUTO flag 
		is turned off, or add a hold if the hold auto flag is set.
	*/

	if eftpay.ttype>1 quit

	//Add hold
	if eftpay.hldauto=1 do { quit:ER   
	new HSEQ
	S HSEQ=$$PLHLDS^EFTFUNCS(.eftpay)
	if HSEQ=0 do Runtime.setErrMSG("EFTPAY",630) quit:ER
	set eftpay.hldseq=HSEQ
	}

	// Remove hold
	if eftpay.hldauto=0 do { quit:ER
	new HLDREM
	set HLDREM=$$RMHLDS^EFTFUNCS(eftpay.cid,eftpay.seq)
	if 'HLDREM do Runtime.setErrMSG("EFTPAY",7675) quit:ER
	}
	quit

vbu9 // Trigger BEFORE_UPD_MSGFP - Validate foreign payment message format

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	;-----------Revision History------------------------------------------
	;
	; 12/20/99 - KARPIAKP - 36155 (orig 35442)
 	;            Added code to pass parameters to MSGCHK function to indicate
 	;            the name of the column. It is required by MSGCHK to generate
 	;            the error message if the value does not pass the validation,
 	;            otherwise an undefined error is being generated by ^PROCEFT.
 	;            Changed last line where If statement was testing MSGFP5 while
 	;            the editcheck was performed for MSGFP6.

	// Validate message format /text/ or //text
	
	new X
	if eftpay.msgfp1'="" set X=eftpay.msgfp1 do MSGCHK1^PROCEFT
	if eftpay.msgfp2'="" set X=eftpay.msgfp2 do MSGCHK^PROCEFT(0,"MSGFP2") set eftpay.msgfp2=X quit:ER
	if eftpay.msgfp3'="" set X=eftpay.msgfp3 do MSGCHK^PROCEFT(0,"MSGFP3") set eftpay.msgfp3=X quit:ER
	if eftpay.msgfp4'="" set X=eftpay.msgfp4 do MSGCHK^PROCEFT(0,"MSGFP4") set eftpay.msgfp4=X quit:ER
	if eftpay.msgfp5'="" set X=eftpay.msgfp5 do MSGCHK^PROCEFT(0,"MSGFP5") set eftpay.msgfp5=X quit:ER
	if eftpay.msgfp6'="" set X=eftpay.msgfp6 do MSGCHK^PROCEFT(0,"MSGFP6") set eftpay.msgfp6=X quit:ER
	quit

vbu10 // Trigger BEFORE_UPD_REJECT - Before Update Reject

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)

	/* ---Revision History-------------------------------------------------------------------------
	
	   10/18/99 - DUJ - 33890
			Converted M code to PSL.

	   5/17/99 - JERUCHIMC - 32492
			Set status to rejected if we are rejecting the order.
	*/

	if eftpay.reject'=1 quit
	set eftpay.status="R"
	quit

vbu11 // Trigger BEFORE_UPD_SETCRCD - Before Update of SETCRCD

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/* ---Revision History-------------------------------------------------------------------------
	
	   10/26/01 - RICKARDSC - 45998
			Modified SETCRCD default logic to use CUVAR.SCDFT, and
			added calls to NOSIP^PROCEFT for foreign payments.

	   10/18/99 - DUJ - 33890
			Converted M code to PSL.

	   02/25/99 - JERUCHIMC - 32010
			Set settlement currency to 0 for a non-In currency.
	
	   07/29/98 - JERUCHIMC - 28545
			Set UX array for EFTPAY.EURAMT
	
	   06/19/98 - JERUCHIMC - 28545
			Set the EURRATE and EURAMT data items and default payment information 
			into MSGFP1 (which represents SWIFT field 32) whenever settlement currency =1.
			Do not allow null value of SETCRCD.
	*/

	new CRCD,EMUMEM,EURAMT,SCDFT

	/*
	 Default settlement currency flag
	 Settlement currency must equal 0 for a non-In currency.
	*/
	set CRCD=eftpay.crcd
	set EMUMEM=Db.getOneRow("EMU","CRCD","%CompanyName,CRCD")
	if EMUMEM=1 do {
		set SCDFT=Db.getOneRow("SCDFT","CUVAR")
		if eftpay.setcrcd="" set eftpay.setcrcd=+SCDFT
		}
	else  set eftpay.setcrcd=0

	// Outgoing foreign payment
	if eftpay.efttype="NDPO" do { quit:ER

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// If SETCRCD=1, default EURRATE, EURAMT, and MSGFP1
		if eftpay.setcrcd'=1 quit

		set eftpay.msgfp1="/OCMT/"_eftpay.crcd_eftpay.amount_",/"
		set eftpay.eurrate=$$FNCRATE^EFTUTL(eftpay.crcd)
		set EURAMT=eftpay.amount/eftpay.eurrate
		set eftpay.euramt=$$^SCARND(EURAMT,,,,2)
		}

	// Incoming foreign payment
	if eftpay.efttype="NDPOIN" do { quit:ER

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""
		}
	quit

vbu12 // Trigger BEF_UPD_AMT_CRCD - Before Update of AMOUNT,CRCD,FEECONV,CCO

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
	/* 
	 ---Revision History-------------------------------------------------------------------------

	 10/17/02 - RICKARDSC - 49098
		Added call to DATIP for foreign payments

	 05/22/02 - SIGDAE - 49389
		Removed setting of HLDSEQ="" after call to RMHLDS^EFTFUNCS.

	 02/08/02 - RICKARDSC - 48359
		Added feetype, antrate, rcvrchg, rcvrchgc and feepayor to
		the UPDATE column list for the trigger.

	 12/06/01 - SIGDAE - 48608
		Modified call to place holds to use new PSL 
		version of PLHLDS^EFTFUNCS.  Also replaced
		call to HLDAMT^EFTFUNCS with a Db.getOneRow call.

	 10/26/01 - RICKARDSC - 45998
		Added calls to CRCDIP^PROCEFT & NOSIP^PROCEFT for
		incoming and outgoing foreign payments.

	 07/24/01 - YURKOVICG - 45987
	 	Modified code that handles NDPO type payment
		orders.  Since code was added to BEFORE_INSERT
		trigger to set HLDAUTO=1 for all NDPO's, no 
		need to check EFTTYPE if HLDAUTO=1.
		Cleaned up structure of code at end of trigger.

	 07/17/01 - SIGDAE - 45449
		Added argument FREQUENCY to PLHLDS2^EFTFUNCS call.

	 06/11/01 - SIGDAE - 45301
		Changed call for domestic order holds to use new 
		function PLHLDS2^EFTFUNCS.

		Removed pre-2000 revision history
	
	 02/10/00 - SCHWARTZC - 35615
		Fix for PSL conversion.
	*/

	new PROCDT,VALDT,XAMT

	// Cannot be a negative amount
	if eftpay.amount<0 do Runtime.setErrMSG("EFTPAY",415) quit:ER
	
	// Decimal precision error
	set XAMT=eftpay.amount
	if eftpay.efttype="NDPOIN" do { quit:ER
		if XAMT#($$MOD^SCARND("",eftpay.crcd)) do Runtime.setErrMSG("EFTPAY",775) quit:ER
		do CALCANT^PROCEFT(.eftpay) quit:ER

		// Validate and default payment currency related fields
		do CRCDIP^PROCEFT(eftpay.crcd,.eftpay) quit:ER

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// Default PROCDT and EFD
		set PROCDT=eftpay.procdt
		set VALDT=eftpay.efd
		do DATIP^PROCEFT(eftpay.crcd,eftpay.efttype,eftpay.sendcorr,.PROCDT,.VALDT) quit:ER
		if eftpay.procdt="" set eftpay.procdt=PROCDT
		if eftpay.efd="" set eftpay.efd=VALDT
		}
	
	if eftpay.efttype="NDPO" do { quit:ER
		do CALCANT^PROCEFT(.eftpay) quit:ER

		// Validate and default payment currency related fields
																do CRCDIP^PROCEFT(eftpay.crcd,.eftpay) quit:ER

		// Default SENDNOS and SENDCORR
		do NOSIP^PROCEFT(.eftpay) quit:ER

		// Sender's correspondent is not needed if equal to receiver's corre.
		if eftpay.sendcorr=eftpay.recvcorr set eftpay.sendcorr=""

		// Default PROCDT and EFD
		set PROCDT=eftpay.procdt
		set VALDT=eftpay.efd
		do DATIP^PROCEFT(eftpay.crcd,eftpay.efttype,eftpay.sendcorr,.PROCDT,.VALDT) quit:ER
		if eftpay.procdt="" set eftpay.procdt=PROCDT
		if eftpay.efd="" set eftpay.efd=VALDT
		}

	// The code below is for hold functionality only
	if eftpay.hldauto'=1!(eftpay.ttype>1) quit
	
	/*
	   Places hold on outgoing clean payment if amount changed only 
	   on payment orders where status '= delete, and 'ogl.
	*/
	if eftpay.status'="D",(((eftpay.amount.oldVal'=eftpay.amount))!((eftpay.anttotal.oldVal'=eftpay.anttotal))) do {
		new HSEQ,X

		set HSEQ=eftpay.hldseq

		// if verify or approval and amount is same on hold, just quit.
		if HSEQ'="",(eftpay.anttotal=Db.getOneRow("AMT","PHLD","CID,HSEQ")),((eftpay.status="V")!(eftpay.status="AP")) quit
	
		// Otherwise try to delete old holds.
		set X=$$RMHLDS^EFTFUNCS(eftpay.cid,eftpay.seq)
		if 'X do Runtime.setErrMSG("EFTPAY",8343) quit
	
		// Now place new holds.
		set HSEQ=$$PLHLDS^EFTFUNCS(.eftpay)
		if HSEQ=0 do Runtime.setErrMSG("EFTPAY",630) quit
		set eftpay.hldseq=HSEQ
	}
	quit

vbu13 // Trigger BU_PTYSTAT - Populate PTYSTAT if changed to null

	type public RecordEFTPAY eftpay
	do eftpay.setAuditFlag(1)
								//  Populate PTYSTAT if PTYSTAT is null
	if eftpay.ptystat="" set eftpay.ptystat=999
	
								//        Display message if trying to prioritize anything but an SPO
								//        "Only Standing Payments Order may have a priority status".
	if (eftpay.efttype'="SPO"),(eftpay.ptystat'=999) do Runtime.setErrMSG("EFTPAY",4187,"RM") quit:ER
	quit
