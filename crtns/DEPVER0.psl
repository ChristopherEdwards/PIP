DEPVER0		// - Deposit Account Integrity Check
	/*
	       ORIG:  Allan R. Mattson (6915) - 08/12/86
	       DESC:  Accessed by functions: DEPVER001 - DEPVER005
	
	
	---- Revision History ------------------------------------------------
	
	10/26/05 - RussellDS - CR17834
 		   Replaced calls to EXT^DBSFILER with direct calls to the
 		   filers.
	
	11/02/04 - RussellDS - CR13011
		   Eliminated use of two dynamic Db.selectDbSet()s -- can
 		   only have one per procedure.  Collapsed to use a single,
 		   common Db.select().
 		   
 		   Added some whitespace and made QUIT a Boolean.
 		   
 		   Added getMode() test in RAN to deal with existing PSL
 		   problem where nextKey() for DEP looks only at ACN,
 		   resulting in chance of getting LN records.
 		   
 		   Added test to make sure ROLLOVR record exists before calling
 		   integrity for it.

	09/08/04 - KELLYP - CR 11982
		   Replaced references to RELACN with RELCIF.  RELACN is an index
		   and should not be directly referenced.  The RELACN table was 
		   also obsoleted from the M database.

	01/06/04 - spier 7501
		   Removed reference to DEP102 which was never built
		   
	12/05/03 - CARROLLJ - CR7239
		   Added #ACCEPT prior to setting %SystemDate int section REDO.	

	03/12/03 - Dan Russell - 51351
		   Removed call to obsolete executive ^DEPEXEC, replaced with
		   VERIFY section in this procedure.
	
	08/06/02 - Dan Russell - 49794
		   Removed R1 section that was previously called by DEVER.
		   Modified use of ^QRYGRP and  ^QRYTYPE.  Generally rewrote to
		   improve code.

	11/27/01 - ARCILLAZ - 43583
		   Converted to PSL. Removed old revision history.

	----------------------------------------------------------------------
	*/

	quit		// Not called from top

XCLS(String TYPELIST)	/* Class/group/type    (Called by function CIFVER1)

	ARGUMENTS:
		. TYPELIST	List of types	/NOREQ/MECH=REFARR:R
				to check.

	If called externally (%EXT=1), and no TYPELIST, do all types.
	If not called externally, prompt for types.
	*/

	type Public Number ER,%EXT
	
	type Date DATE
	type String GRP,VFMQ,WHERE

	if '%EXT.data() do QRY(.TYPELIST) quit:ER!(VFMQ="Q")

	set DATE=%SystemDate
	
	// Delete old entries
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='DEP'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='ROLLOVR'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='DEPODP'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='DEP101'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='RELCIF'")
	do Db.delete("XBAD","TDATE=:DATE AND TABLE='TRTYPE'")

	// Build select list for types in TYPELIST
	set WHERE=""
	if TYPELIST.data() do {
		type String IN,N
		set IN="(",N=""
		for  set N=$O(TYPELIST(N)) quit:N=""  set IN=IN_N_","
		set WHERE="TYPE IN "_IN.extract(1,IN.length()-1)_")"
	}
	
	do PROCLIST("CID", "DEP", WHERE)

	quit


REDO	// Called to re-do integ for specific date
	/*
	   Function call to allow deposit integrity on only accounts where
	   prevsious bad entries were found
	*/

	type Public Number ER
	
	type Boolean QUIT
	type Date REDODT
	type String %NOPRMT,%PG,%READ(),%TAB(),TYPELIST(),VFMQ

	if $G(%SystemDate)="" do {
		type ResultSet rs=Db.select("TJD","CUVAR")
		if rs.isEmpty() quit
		#ACCEPT DATE=12/05/03;PGM=John Carroll
		if rs.next() set %SystemDate=rs.getCol(1)
		}
	
	set %TAB("REDODT")=".REDODT/TBL=^XBAD("
	set REDODT=%SystemDate
	set %READ="@@%FN,,,REDODT/REQ"
	set %PG=0
	set %NOPRMT="C"

	do ^UTLREAD quit:VFMQ="Q" 

	kill %PG
	
	do QRY(.TYPELIST) quit:ER!(VFMQ="Q")

	type ResultSet xbadrs=Db.select("DISTINCT AKEYS","XBAD","TDATE=:REDODT AND TABLE='DEP'")

	set QUIT=0
	while xbadrs.next() do { quit:QUIT
		type RecordDEP dep=Db.getRecord("DEP","CID=:xbadrs.getCol(1)")
		if $D(TYPELIST),'$D(TYPELIST(dep.type)) quit
		if REDODT=%SystemDate do DELOLD(dep.cid)
		do EXEC(.dep)
	}

	quit
	

DTJNA(String TYPELIST)	/* New accounts    (Called by function DEPVER003)

	ARGUMENTS:
		. TYPELIST	List of types	/NOREQ/MECH=REFARR:R
				to check.

	If called externally (%EXT=1), and no TYPELIST, do all types.
	If not called externally, prompt for types.
	*/

	type Public Number %EXT
	
	type Date XJD
	type String VFMQ,WHERE
	
	set XJD=%SystemDate
	if '$D(%EXT) do GETDATE(.XJD,1) quit:VFMQ="Q"!'$G(XJD)

	// Build select list for types in TYPELIST
	set WHERE="TJD=:XJD AND CLS='D'"
	if $D(TYPELIST) do {
		type String IN,N
		set IN="(",N=""
		for  set N=$O(TYPELIST(N)) quit:N=""  set IN=IN_N_","
		set WHERE=WHERE_" AND TYP IN "_$E(IN,1,$L(IN)-1)_")"
	}
	
	do PROCLIST("CID", "DTJNA", WHERE)

	quit
	
	
DTJFM(String TYPELIST)	/* File maintenance    (Called by function DEPVER002)

	ARGUMENTS:
		. TYPELIST	List of types	/NOREQ/MECH=REFARR:R
				to check.

	If called externally (%EXT=1), and no TYPELIST, do all types.
	If not called externally, prompt for types.
	*/

	type Public Number %EXT
	type Date XJD
	type Number QUIT
	type String VFMQ,WHERE
	
	set XJD=%SystemDate
	if '$D(%EXT) do GETDATE(.XJD,1) quit:VFMQ="Q"!'$G(XJD)

	// Build select list for types in TYPELIST
	set WHERE=""
	if $D(TYPELIST) do {
		type String IN,N
		set IN="(",N=""
		for  set N=$O(TYPELIST(N)) quit:N=""  set IN=IN_N_","
		set WHERE="TJD=:XJD AND CLS='D' AND TYP IN "_$E(IN,1,$L(IN)-1)_")"
	}
	
	do PROCLIST("DISTINCT CID", "DTJFM", WHERE)

	quit
	
	
GETDATE(Date XJD,Number ASKTYPE)	//Private - Get date and TYPELIST

	type Public String TYPELIST,VFMQ

	type Number OLNTB,%PAGE,%PG
	type String %NOPRMT,%READ(),%TAB()

	set %TAB("XJD")=".XJD1"
	set %READ="XJD/REQ"
	set %NOPRMT="F",%PG=1

	do ^UTLREAD quit:VFMQ="Q"

	// Ask for types
	if $G(ASKTYPE) do ^QRYTYPE("D","",.TYPELIST)

	quit
	

RAN	// Random accounts    (Called by function DEPVER004)

	type Boolean QUIT
	type Number CID,MAX,TOT,X,Y

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

	set MAX=cuvar.depver
	if 'MAX set MAX=10

	set CID=""

	set X=Db.nextKey("DEP","CID") if X="" quit
	set Y=Db.prevKey("DEP","CID")

	/* If the range of accounts are greater than 2**31 reset the
	   first account number so the difference is less than 2**31
	   - this is the limit for $R.
	*/
        if (Y-X)>((2**31)-1) for  set X=Db.nextKey("DEP","X") quit:((Y-X)<(2**31))
	if X=Y do { quit
		type RecordDEP dep=Db.getRecord("DEP","CID=:X",1)
		if dep.getMode() do EXEC(.dep)
	}

	set (QUIT,TOT)=0

	for  do { quit:QUIT
		set CID=X+$R(Y-X)-1
		set CID=Db.nextKey("DEP","CID")
		type RecordDEP dep=Db.getRecord("DEP","CID=:CID",1)
		if dep.getMode() do EXEC(.dep)
		set TOT=TOT+1
		if TOT>MAX set QUIT=1
	}

	quit
	

CID	// Single account

	type Public String ER

	type Date DATE
	type Number CID,%NOPRMT,OLNTB
	type String %READ(),%TAB(),VFMQ

	set %TAB("CID")=".CID1/XPP=S ZCLS=""D"",%EXT=1 D ^UACN"
	set %READ="@@%FN,,,CID/REQ",%NOPRMT="F"

	do ^UTLREAD quit:VFMQ="Q"

	// Delete old entries
	do DELOLD(CID)

	type RecordDEP dep=Db.getRecord("DEP","CID=:CID")
	do EXEC(.dep) quit:ER

	do DSPERR^DBSEXECU(CID)
	
	quit
	

DELOLD(Number CID)	// Delete old XBAD entries for today
	
	// Delete old entries
	do Db.delete("XBAD","AKEYS=:CID AND TDATE=:%SystemDate AND TABLE='DEP'")
	do Db.delete("XBAD","AKEYS=:CID AND TDATE=:%SystemDate AND TABLE='ROLLOVR'")
	
	// files where AKEYS contain more then just the primary key
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:%SystemDate AND TABLE='DEP'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:%SystemDate AND TABLE='DEPSEG'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:%SystemDate AND TABLE='DEP101'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:%SystemDate AND TABLE='RELCIF'")
	do Db.delete("XBAD","PKEY=:CID AND TDATE=:%SystemDate AND TABLE='TRTYPE'")

	quit
	

QRY(String TYPELIST)	//Private - Query

	type Public String ER,GRPLIST,VFMQ

	type String GRP,N
	
	do ^QRYGRP("D",.GRPLIST) quit:ER!(VFMQ="Q")

	set (GRP,N)=""
	for  set N=$O(GRPLIST(N)) quit:N=""  set GRP=GRP_N_","
	set GRP=$E(GRP,1,$L(GRP)-1)

	do ^QRYTYPE("D",GRP,.TYPELIST)

	quit
	
	
EXEC(RecordDEP dep) // Execute the integrity
	/*
	   OUTPUT:
	   . RM		Return message
	*/

	type Number CID
	type String MFRE,SVFRE,verrors,vfkey

	set CID=dep.cid

	if dep.stat=4 do {			// Closed account
		
		type Number SAVEMODE
		
		set SAVEMODE = dep.getMode()
		
		do dep.setMode(2)
		do ^DEPFILE(.dep, "/NOVALDD/NOINDEX/NOVALREQ")

		do dep.setMode(SAVEMODE)
		}     

	// Validate relationships
	else  do VERIFY(CID)

	if $D(verrors) do XBAD^DBSEXECU(.verrors)

	quit
	
	
VERIFY(Number CID)	/* Public - run integity check on one DEP record

	ARGUMENTS:
		. CID		DEP Number	/REQ/NONULL/MECH=VAL
		
	RETURNS:
		. ER		Error flag	/TYP=L

		. RM		Error message	/TYP=T
		
		. verrors()	Error array	/TYP=T
	*/
	
	type Public Number ER=0
	type Public String RM,verrors()
	
	type RecordDEP dep = Db.getRecord("DEP", "CID=:CID")
	
	do dep.setMode(2)
	do ^DEPFILE(.dep)		// Validate a single DEP record
	
	if Db.isDefined("ROLLOVR","CID=:CID") do {	// Validate ROLLOVR table
		
		type RecordROLLOVR rollovr = Db.getRecord("ROLLOVR", "CID=:CID")
		
		do rollovr.setMode(2)
		do ^ROLLFIL(.rollovr)
	}

	// Validate RELCIF table
	do { quit:ER
		type ResultSet rs=Db.select("ACN","RELCIF","CID=:CID")
		
		while rs.next() do { quit:ER
			type Number ACN

			set ACN=rs.getCol("ACN")
			
			type RecordRELCIF relcif = Db.getRecord("RELCIF", "ACN=:ACN,CID=:CID")
			
			do relcif.setMode(2)
			do ^RCIFFILE(.relcif)
			}
		}

	// Validate DEPODP table
	do { quit:ER
		type ResultSet rs=Db.select("ODACN","DEPODP","CID=:CID")
		
		while rs.next() do { quit:ER
			type Number ODACN

			set ODACN=rs.getCol("ODACN")
			
			type RecordDEPODP depodp = Db.getRecord("DEPODP", "CID=:CID,ODACN=:ODACN")
			
			do depodp.setMode(2)
			do ^DEPODPFL(.depodp)
			}
		}		

	// Validate DEP101 table
	do { quit:ER
		type ResultSet rs=Db.select("ICID","DEP101","CID=:CID")
		
		while rs.next() do { quit:ER
			type Number ICID

			set ICID=rs.getCol("ICID")
			
			type RecordDEP101 dep101 = Db.getRecord("DEP101", "CID=:CID,ICID=:ICID")
			
			do dep101.setMode(2)
			do ^DEP101F(.dep101)
			}
		}


	// Validate DEPEXPLN table
	do { quit:ER
		type ResultSet rs=Db.select("EXMPLN","DEPEXPLN","CID=:CID")
		
		while rs.next() do { quit:ER
			type String EXMPLN

			set EXMPLN=rs.getCol("EXMPLN")
			
			type RecordDEPEXPLN depexpln = Db.getRecord("DEPEXPLN", "CID=:CID,EXMPLN=:EXMPLN")
			
			do depexpln.setMode(2)
			do ^DEPEXPFL(.depexpln)
			}
		}

	// Validate DEPDONOR table
	do { quit:ER
		type ResultSet rs=Db.select("DONACT","DEPDONOR","CID=:CID")
		
		while rs.next() do { quit:ER
			type Number DONACT

			set DONACT=rs.getCol("DONACT")
			
			type RecordDEPDONOR depdonor = Db.getRecord("DEPDONOR", "CID=:CID,DONACT=:DONACT")
			
			do depdonor.setMode(2)
			do ^DONORFL(.depdonor)
			}
		}

	// Validate TRTYPE table
	do { quit:ER
		type ResultSet rs=Db.select("TYP","TRTYPE","CID=:CID")
		
		while rs.next() do { quit:ER
			type String TYP

			set TYP=rs.getCol("TYP")
			
			type RecordTRTYPE trtype = Db.getRecord("TRTYPE", "CID=:CID,TYP=:TYP")
			
			do trtype.setMode(2)
			do ^TRTYPEFL(.trtype)
			}
		}

	// Validate DEPSEG table
	do { quit:ER
		type ResultSet rs=Db.select("SEGMENT","DEPSEG","CID=:CID")
		
		while rs.next() do { quit:ER
			type Number SEGMENT

			set SEGMENT=rs.getCol("SEGMENT")
			
			type RecordDEPSEG depseg = Db.getRecord("DEPSEG", "CID=:CID,SEGMENT=:SEGMENT")
			
			do depseg.setMode(2)
			do ^DEPSEGFL(.depseg)
			}
		}

	do CMBSTMVF^MSCFUNCS(CID)		// Validate combined statements
	
	quit
	
	
PROCLIST(String CIDCOL,		// Column that is DEP.CID in TABLE
	 String TABLE,		// Table for dynamic select
	 String WHERE)		// Where clause fo dynamic select
	 
	 /*
	 Process deposit records based on TABLE and WHERE clause.
	 
	 It is necessary to do this in one place, versus in each of the calling
	 sections since PSL currently limits a procedure to a single dynamic
	 select or selectDbSet().
	 */
	 
	type Boolean QUIT = 0
	
	#ACCEPT DATE=11/02/04; PGM=Dan Russell
	type ResultSet rs = Db.select(CIDCOL, TABLE, WHERE)

	while rs.next() do { quit:QUIT
		
		type RecordDEP dep = Db.getRecord("DEP", "CID=:rs.getCol(1)",1)
		
		if dep.getMode() do EXEC(.dep)
	}
		
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60205^55238^Dan Russell^11453"	// Signature - LTD^TIME^USER^SIZE
