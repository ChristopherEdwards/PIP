public MRPC114(String RETURN,Number VERSN,Number CID,String COLS,String WHERE,Number NUMROWS,String MORE,Number FM,Number OPT)

  /*
	ORIG: YURKOVICG - 04/03/2001
	DESC: History/STFHOST Transaction Journals RPC
	KEYWORDS: RPC, HISTORY, STF

	This RPC is a public RPC that will return transaction journal records
	for an account, using the input parameters to define what data should 
	be returned and what filters should be used when gathering the data. 
	The MRPC will return both regular transaction journal records, from 
	the HIST (Transaction History) table, and store-and-forward records, 
	from the STFHOST (Host Store and Forward File) table, if they exist.

	Prior to querying the HIST table, the MRPC will check to see if the 
	system is operating in store-and-forward mode.  If it is, it will 
	check the STFHOST table to see if entries for the account being 
	queried against exist.  If entries exist, they will be returned by 
	the MRPC using the input parameters to filter records.  If a column 
	specified in the COLS parameter does not exist in the STFHOST table, 
	it will be returned as a null value in the return record.  This allows 
	the client calling the MRPC to query the same columns and use the same
	filters for both STFHOST and HIST records.

	After any STFHOST records have been retrieved, the MRPC will use the 
	same input parameters to retrieve records from the HIST table if the 
	number of rows already gathered has not exceeded the maximum defined 
	in the NUMROWS input parameter.  The same columns will be retrieved 
	and the same filters will be used by applying the WHERE clause.  

	If any customization is needed, copy MRPC114 to ZMRPC114.  Add custom 
	code to ZMRPC114 and then compile it.  Then recompile MRPC114.  
	ZMRPC114 will be called directly from MRPC114 if it exists.  There 
	is no need to modify the entries in the M Remote Procedures Call 
	Table (SCATBL5).


	ARGUMENTS:

		. RETURN   Return Value                 /TYP=T/REQ/MECH=REFNAM

		. VERSN    Version Number               /TYP=N/REQ/MECH=VAL
			   current versions
			      1 - Standard STFHOST/HIST return mechanisms using 
			   	  dynamic selects for all data returned.
			   	    
			      2 - Upgraded HIST return mechanisms using dynamic 
			      	  select for record key retrieval followed by 
			      	  getRecord calls for better Oracle performance.
			   	  Usage restricted to the PFW Account History report.

		. CID      Account Number               /TYP=N/REQ/MECH=VAL

		. COLS     Columns from HIST/STFHOST    /TYP=T/REQ/MECH=VAL

		. WHERE    Valid SQL WHERE clause	/TYP=T/NOREQ/MECH=VAL
			   used to filter records

		. NUMROWS  Maximum number of total	/TYP=N/NOREQ/MECH=VAL
			   rows to be returned

		. MORE     More Token			/TYP=T/NOREQ/MECH=VAL

		. FM       File Maintenance Indicator   /TYP=N/NOREQ/DFT=0
			     0=Exclude File Maintenance
			     1=Include File Maintenance
			     2=Include File Maintenance Only

		. OPT	   Service Option Value		/TYP=N/NOREQ/MECH=VAL
			     1=	Interactive Voice Response (IVR)
			     2=	Automated Teller Machine (ATM)

	---- Revision History ------------------------------------------------

	04/11/07 - KinI - CR 26508
		   Modified GETHIST2 section to include VAT related TAMT 
		   breakdown in return string.

	02/23/07 - KELLYP - CR 25518
		   Introduced MRPC version 2 for improving the performance of 
		   the PFW Account History report against Oracle host databases.  
		   The dynamic selects previously used were very inefficient 
		   with the large number of oomputed call backs necessary for 
		   HIST columns.  Also modified to conform to current PSL 
		   standards.

   	07/10/06 - RussellDS - CR 22121
		   Modified length checking against 31000 to consider bytes,
		   not characters to be Unicode compliant.
		   
		   Removed old revision history.
   ----------------------------------------------------------------------

 */
 
 	type public Boolean ER
 	type public String RM
 
	type String RET

	// Check for Custom Routine and call it if it exists.
	#if $$VALID^%ZRTNS("ZMRPC114")
	do START^ZMRPC114
	#else
	do START
	#endif

	if ER.get() quit $$ERRMSG^PBSUTL(RM)
	
	set RETURN = $$V2LV^MSG(RET)

	quit ""

START

	type public Boolean ER,%STFHOST
	type public Number CID,FM,NUMROWS,VERSN
	type public String COLS,MORE,RET,RM,WHERE

	type Boolean QUIT
	type Number ROWCNT,SAVSEQ,XCID,XSEQ
	type String ETC,FILE,par,sqlcnt,sqldta,sqlsta

	set (ER,QUIT,ROWCNT)=0
	set (FILE,RM,RET,SAVSEQ,XSEQ,par,sqlsta)=""

	// Version number of client message is not compatible with server
	if '((VERSN.get()=1)!(VERSN.get()=2)) set ER=1,RM=$$^MSG(2951) quit

	set XCID=CID.get()

	type RecordACN acn = Db.getRecord("ACN","CID=:XCID",1)
	
	// Invalid account number
	if 'acn.getMode() set ER=1,RM=$$^MSG(7774) quit

	// Columns Cannot be NULL
	if COLS.get().isNull() set ER=1,RM=$$^MSG(8557) quit

	// Initialize WHERE clause and add Account Number to it
	set WHERE=WHERE.get()
	if WHERE'["CID=" do {
		if 'WHERE.isNull() set WHERE=WHERE_" AND CID=:XCID" quit
		set WHERE="CID=:XCID"
		}

	// Initialize variables to defaults if not defined.
	if NUMROWS.get().isNull() set NUMROWS=40
	set FM=+FM.get()
	if FM'=1 set WHERE=WHERE_" AND FM="_$select(FM=2:1,1:0)

	set MORE=MORE.get() 
	// If MORE token is present, retrieve place marker.
	if 'MORE.isNull() do GETMORE quit:ER

	// STF records only currently supported under version 1
	if (VERSN'=2),(FILE'="HIST"),%STFHOST.get() do GETSTF set XSEQ="" quit:ER
	if 'QUIT do {  quit:ER
		if VERSN=1 do GETHIST quit
		if VERSN=2 do GETHIST2(.acn) quit
		}
	set RET=ROWCNT_$char(9)_MORE_$char(13,10)_RET

	quit


GETSTF  // Retrieve Store-and-Forward Records 

	type public Boolean ER,QUIT
	type public Number NUMROWS,ROWCNT,SAVSEQ,XSEQ
	type public String COLS,MORE,RET,WHERE,par,sqlcnt,sqldta,sqlsta
	
	type String SQLSTMT,STFCOLS,STFWHR

	// STFSEQ must be retrieved, since it is needed for more token.
	set STFCOLS="STFSEQ,"_$$VERCOLS(COLS,"STFHOST")
	set STFWHR=WHERE

	if XSEQ'="" set STFWHR=STFWHR_" AND STFSEQ<:XSEQ"
	if STFWHR'["ORDER BY" set STFWHR=STFWHR_" ORDER BY STFSEQ DESC"

	// Open cursor and fetch one record at a time.
	set SQLSTMT="MRPC114 as SELECT "_STFCOLS_" FROM STFHOST WHERE "_STFWHR
	do OPEN^SQL(SQLSTMT,,.sqlsta,.sqldta)
	if (ER)!(sqlsta>99) do CLOSE^SQL("MRPC114") quit
	
	for  do FETCH^SQL("MRPC114",.par,.sqlsta,.sqldta,.sqlcnt) quit:sqlcnt=0  do {  quit:(ER)!(QUIT)
		set SAVSEQ=sqldta.piece($char(9),1)
 		set RET=RET_"0"_$C(9)_sqldta.extract(sqldta.find($char(9)),sqldta.length())_$char(13,10)
		set ROWCNT=ROWCNT+1
		if (RET.toByteString().length()<31000),(ROWCNT<NUMROWS) quit
		set MORE=$$SETMORE("STFHOST",SAVSEQ)
		set QUIT=1
		}
	
	do CLOSE^SQL("MRPC114")
	
	quit


GETHIST // Retrieve History Records

	type public Boolean ER,QUIT
	type public Number CID,NUMROWS,OPT,ROWCNT,SAVSEQ,XSEQ
	type public String COLS,ETC,MORE,RET,WHERE,par,sqlcnt,sqldta,sqlsta

	type Number TSEQFLG
	type String SQLSTMT
	
	set SAVSEQ=""

	// TSEQ must be retrieved, since it is needed for more token.
	if COLS'["TSEQ" set COLS="TSEQ,"_COLS,TSEQFLG=-1
	else  set TSEQFLG=COLS.piece("TSEQ,",1).length(",")

	if XSEQ'="" set WHERE=WHERE_" AND TSEQ<:XSEQ"
	if WHERE'["ORDER BY" set WHERE=WHERE_" ORDER BY TSEQ DESC"

	// Open cursor and fetch one record at a time.
	set SQLSTMT="MRPC114 as SELECT "_COLS_" FROM HIST WHERE "_WHERE
	do OPEN^SQL(SQLSTMT,,.sqlsta,.sqldta)
	if (ER)!(sqlsta>99) do CLOSE^SQL("MRPC114") quit
	
	for  do FETCH^SQL("MRPC114",.par,.sqlsta,.sqldta,.sqlcnt) quit:sqlcnt=0  do {  quit:(ER)!(QUIT)
		if TSEQFLG<0 set SAVSEQ=sqldta.piece($char(9),1),sqldta=sqldta.extract(sqldta.find($C(9)),sqldta.length())

		// filter the transaction history records
		// check made against UTBLSRTC. 
		// Transaction code must be in the user table under
		// the service option, unless the service option
		// does not exist at all in the table, in which
		// case no filtering will occur.

		if TSEQFLG>0 set SAVSEQ=sqldta.piece($char(9),TSEQFLG)
		if 'OPT.get() set RET=RET_"1"_$char(9)_sqldta_$char(13,10)
		else  do {
			type ResultSet histrs = Db.select("ETC","HIST","CID=:CID AND TSEQ=:SAVSEQ")
			if histrs.next() set ETC = histrs.getCol("ETC")
			type ResultSet rs=Db.select("SROPT,TRNCD","UTBLSRTC","SROPT=:OPT AND TRNCD=:ETC")
			if 'rs.isEmpty() set RET=RET_"1"_$char(9)_sqldta_$char(13,10)
			type ResultSet rs2=Db.select("SROPT","UTBLSRTC","SROPT=:OPT")
			if rs2.isEmpty() set RET=RET_"1"_$char(9)_sqldta_$char(13,10)
			}

		set ROWCNT=ROWCNT+1
		if (RET.toByteString().length()<31000),(ROWCNT<NUMROWS) quit
		set MORE=$$SETMORE("HIST",SAVSEQ)
		set QUIT=1
		}
	
	do CLOSE^SQL("MRPC114")
	
	quit


GETHIST2(RecordACN acn) // Retrieve History Records for PFW Account History Report

	/*
	 Sample PFW Select Statement for Account History Report:
	 
	 SELECT ACN.CID,HIST.TJD,HIST.EFDCMP,HIST.ETC,HIST.UID,HIST.PRIN,HIST.INT,HIST.TAMT,
	 HIST.CRCD,HIST.TSO,HIST.SPR,HIST.TCMT,ACN.CLS,HIST.ITC1,HIST.BRCD,ACN.LNM,HIST.TSEQ,
	 HIST.TOT,ACN.CRCD,HIST.ENDBAL,HIST.FM,HIST.DI,HIST.OLDV,HIST.NEWV,HIST.TSB,HIST.TRC,
	 HIST.ITC10,HIST.ITC11,HIST.ITC8,HIST.DIDSC,HIST.KEY1NAME,HIST.KEY1VAL,HIST.KEY2NAME,
	 HIST.KEY2VAL,HIST.KEY3NAME,HIST.KEY3VAL,HIST.KEY4NAME,HIST.KEY4VAL,HIST.NEGP,HIST.NEGPB,
	 HIST.NITUF,HIST.NEGPU,HIST.WHLD,HIST.SWHLD,HIST.MISC,HIST.REC,HIST.UNC,HIST.COA,HIST.PENALTY,
	 HIST.ESCSUS,HIST.EENDBAL,HIST.ETAMT,HIST.EFDTCMT2,HIST.CHGVAL,HIST.TTAMT2,HIST.VATLCHG,
	 ACN.ACN,ACN.EURCNVD,ACN.EUREVDT,ACN.EURSTAT,ACN.STFPENDING FROM ACN 
	 LEFT OUTER JOIN (HIST) ON (ACN.CID=HIST.CID) WHERE HIST.CID=:A ORDER BY HIST.TSEQ DESC
	*/

	type public Boolean ER,QUIT
	type public Number CID,NUMROWS,OPT,ROWCNT,SAVSEQ,XSEQ
	type public String COLS,ETC,MORE,RET,WHERE,par,sqlcnt,sqldta,sqlsta

	type Date TMPDT,TMPDT2
	type Number HSEQ,TSEQFLG
	type String SQLSTMT
	
	set SAVSEQ=""

	if XSEQ'="" set WHERE=WHERE_" AND TSEQ<:XSEQ"

	#ACCEPT DATE=02/20/07;PGM=KELLYP;CR=25361
	type ResultSet rs = Db.select("TSEQ","HIST",WHERE,"TSEQ DESC")
	while rs.next() do {  quit:(ER)!(QUIT)
		set HSEQ = rs.getCol("TSEQ")
		
		set SAVSEQ = HSEQ
		
		type RecordHIST hist = Db.getRecord("HIST","CID=:CID,TSEQ=:HSEQ")

		set TMPDT = hist.tjd
		set TMPDT = TMPDT.toString()
		set TMPDT2 = hist.efdcmp
		set TMPDT2 = TMPDT2.toString()

		set RET=RET_CID_$char(9)_TMPDT_$char(9)_TMPDT2_$char(9)_hist.etc_$char(9)
		set RET=RET_hist.uid_$char(9)_hist.prin_$char(9)_hist.int_$char(9)_hist.tamt_$char(9)
		set RET=RET_hist.crcd_$char(9)_hist.tso_$char(9)_hist.spr_$char(9)_hist.tcmt_$char(9)
		set RET=RET_acn.cls_$char(9)_hist.itc1_$char(9)_hist.brcd_$char(9)_acn.lnm_$char(9)
		set RET=RET_HSEQ_$char(9)_hist.tot_$char(9)_acn.crcd_$char(9)_hist.endbal_$char(9)
		set RET=RET_hist.fm_$char(9)_hist.di_$char(9)_hist.oldv_$char(9)_hist.newv_$char(9)
		set RET=RET_hist.tsb_$char(9)_hist.trc_$char(9)_hist.itc10_$char(9)_hist.itc11_$char(9)
		set RET=RET_hist.itc8_$char(9)_hist.didsc_$char(9)_hist.key1name_$char(9)_hist.key1val_$char(9)
		set RET=RET_hist.key2name_$char(9)_hist.key2val_$char(9)_hist.key3name_$char(9)_hist.key3val_$char(9)
		set RET=RET_hist.key4name_$char(9)_hist.key4val_$char(9)_hist.negp_$char(9)_hist.negpb_$char(9)
		set RET=RET_hist.nituf_$char(9)_hist.negpu_$char(9)_hist.whld_$char(9)_hist.swhld_$char(9)
		set RET=RET_hist.misc_$char(9)_hist.rec_$char(9)_hist.unc_$char(9)_hist.coa_$char(9)
		set RET=RET_hist.penalty_$char(9)_hist.escsus_$char(9)_hist.eendbal_$char(9)_hist.etamt_$char(9)
		set RET=RET_hist.efdtcmt2_$char(9)_hist.chgval_$char(9)_hist.ttamt2_$char(9)_hist.vatlchg_$char(9)
		set RET=RET_acn.acn_$char(9)_acn.eurcnvd_$char(9)_acn.eurevdt_$char(9)_acn.eurstat_$char(9)
		set RET=RET_acn.stfpending_$char(13,10)

		set ROWCNT=ROWCNT+1

		if (RET.toByteString().length()<31000),(ROWCNT<NUMROWS) quit

		set MORE=$$SETMORE("HIST",SAVSEQ)

		set QUIT=1
		}
	
	
	
	quit
	

VERCOLS(String C,String F)

	/* 
	   This function will verify the columns listed in variable C
	   are valid data items in the file definition F, replacing the 
	   invalid column names with a null character.

	   Example: set COLS=$$VERCOLS("TJD,TOT,TCMT","STFHOST")
	*/

	type public Boolean ER

	type Number i
	type String di,fsn
	
	do fsn^SQLDD(.fsn,F) if ER quit
	for i=1:1:C.length(",") if '$$VER^SQLDD(F,C.piece(",",i),.fsn) set C.piece(",",i)="''"

	quit C


GETMORE // Use More token to continue gathering data

	type public Number XSEQ
	type public String FILE,MORE
	
	type RecordMORETKN moretkn = Db.getRecord("MORETKN","MORE=:MORE",1)
	
	do Db.fastDelete("MORETKN","MORE=:MORE")

	set FILE = moretkn.fld1			// Get File ID (STFHOST/HIST)
	set XSEQ = moretkn.fld2			// Get Sequence Number
	set MORE = ""				// Reset MORE Token

	quit


SETMORE(String FLD1,String FLD2) // Get More token and save data

	type String MORE

	set MORE=$$MORETKN^UTLMRPC(%ProcessID)	// Get New Token
 
	// Create MORETKN record in database
	type RecordMORETKN moretkn = Class.new("RecordMORETKN","MORE=:MORE")

	set moretkn.fld1=FLD1			// Store File ID (STFHOST/HIST)
	set moretkn.fld2=FLD2			// Store Sequence Number

	do moretkn.bypassSave()

	quit MORE
 #OPTION ResultClass ON
Public String vSIG()	quit "60731^64353^Irina Kin^12597"	// Signature - LTD^TIME^USER^SIZE
