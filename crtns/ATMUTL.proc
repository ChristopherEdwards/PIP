ATMUTL		/*
	 Procedure ID: ATMUTL
	 DESC: ATM Utility Functions
	 ORIG: Ed Sigda - 08/30/2001

	 DESC:  ATM Utilities for use with the ANSI X9.2 and ISO 8583
		Online ATM interfaces.

	 The logic to support Split Day processing contained in this routine
	 is valid for versions V6.3 and above.

	 LIBRARY:
	 . POST		Post financial transactions
	 . ATMPRE	Pre-authorization
	 . FINPRE	Delete PHLD and ATMHLD entries.
	 . CHKRSP	Check for insufficient funds entries in SPV array
	 . REV		Reverse financial transactions
	 . TTX		Create a transaction record
	 . STFCHK	Determine if a transaction has already been posted
	 . FINDH	Find history entry matching SPR and TLO
	 . JD		Return date in julian format  (input = MMDD)
	 . GETTRN	Determine PROFILE transaction codes
	 . TLRPDT	Determine and validate TPD (teller posting date)
	 . NXTSEQ	Unique message sequence
	 . ADDPHLD	Insert entry into PHLD
	 . CKTRN	Update the CK transaction in the transaction set
	 . EXCHANGE	Create exchange transactions
	 . CNVAMT	Convert transaction amount

	 ---- Revision History ------------------------------------------------
	 
	 01/09/07 - MBUIM
	 	When a posting error occurs, the error (and supervisory 
	 	override information) does not get returned from section 
	 	POST^ATMUTL, resulting in a successful response to the calling
	 	application.  The following variables are now typed public. 
	 	ER, RJ, SPV, and RSPCD.
	 	
	 05/18/05 - GIRIDHAL - CR 21297
	 	Modified section TLRPDT to remove references to Split Day 
	 	Processing as it is obsolete. Modified section FINDH to remove
	 	all references to SPLTDY and associated logic 
	 	
	 02/10/06 - KUMARB - CR 19502
	 	Modified all the Runtime.setErrMSG calls to pass the 
	 	correct parameters.

	 12/15/05 - PRAKASHJ - CR17423
	 	Removed PSL deprecited features and warnings.
	 	
	 10/27/05 - KELLYP - CR 16880
	 	Modified call to TRNSET^TRNDRV to correct parameters being 
	 	passed (RJ was being passed in PTRC's place).  Also removed
	 	"ORDER BY" from order by clause in multiple SQL selects to 
	 	prevent compilation errors and removed pre-2003 revision 
	 	history.

	 11/04/03 - CARROLLj - 51630
		Modified call to TRNSET^TRNDRV to pass correct parameters.

	 06/27/03 - ZWITKOWITSM - 51349
		Made changes to eliminate Tset processing.  Removed references
		to TTXP2 and general clean-up.

	 ----------------------------------------------------------------------
	*/
	quit



public POST(RecordTTX ttx(),Number CID,Date TPD,String BRCD,String TSPV,String STF)
	/*
	 Post financial transactions

	 Messages coming in as ADVICES have already been processed by the
	 ATM switch and must be processed as store and forward transactions
	 on PROFILE. This means that store and forward transactions MUST be
	 successfully processed on PROFILE since the transaction has already
	 been approved by the ATM switch. The supervisory override array,
	 TSPV, is set up so the PROFILE ATM teller has authorization over
	 all generated transactions. Also, bit 10 of ITC for each transaction
	 is turned on indicating that the transaction is off-line.

	 ARGUMENTS:
		TPD	- Teller posting date
		BRCD	- Branch code
		TSPV	- Teller supervisory array
		STF	- ATM switch store and forward flag

	 Called by: ANSIX92, ISO8583, and MRPC029
	*/

	type public Boolean ER
	type public String %STFHOST,RJ(),RSPCD,SPV()
	
	type String %IPMODE,CRT,LPSEQ,OVR(,,),par,UID,x
	type Number seq
	

	// If STF, modify transactions to off-line transactions
	if STF do {
		set seq=0
		while ttx(seq+1).exists() set seq=seq+1 if '(ttx(seq).itc).isNull() set ttx(seq).itc=$$ITC^TTXEXT(ttx(seq).itc,10)
		}

	if %STFHOST do PROCSTF(.ttx(),CID,TPD,BRCD,.TSPV,STF) quit

	// Define transaction trace number for error-correct transactions
	set UID=%UserID

	if %EffectiveDate'>%SystemDate do {
		type RecordTTXUID ttxuid=Db.getRecord("TTXUID","TPD,BRCD,UID",1)
		set LPSEQ=ttxuid.lpseq
		}
	else  do {
		type RecordTTXFDTUID ttxfdt=Db.getRecord("TTXFDTUID","TPD,BRCD,UID",1)
		set LPSEQ=ttxfdt.endseq
		}

	set LPSEQ=(LPSEQ+1)*1000

	// This code does not support secondary transactions
	set seq=1
	while ttx(seq).exists() do {
		set ttx(seq).trc=LPSEQ+seq	// Transaction trace 
		set seq=seq+1
		}

	set %IPMODE="NOINT"
	set CRT=0				// Mirror batch handling of overrides

	// 1 - online, 3 - STF
	do TRNSET^TRNDRV(.ttx(),TPD,BRCD,$S(STF:3,1:1),,.RJ,.SPV,.OVR)

	if RJ.data() set ER=1

	if 'ER do SETPRF^TTXLOK			// Needs TPD,BRCD

	// Deny the transaction if error
	set RSPCD=$$CHKRSP(CID,STF,.SPV,"",0)

	quit 


public ATMPRE(RecordTTX ttx(),Number CID,String CRCD,Number TCMT,Number SPR,String AUTCODE,String TSO,Date TPD,String BRCD,String STF,String PAUTH,Number PAMT)
	/*
	Pre-authorization

	 A permanent hold (PHC=92) is placed on the account with an 
	 expiration date of today+PHDAYS.
	
	 ARGUMENTS:
		CID	- PROFILE account number
		CRCD	- Transaction currency code
		TCMT	- Transaction comment
		SPR	- Spray value
		AUTCODE	- Authorization code
		TSO	- Transaction source of funds
		TPD	- Teller posting date
		BRCD	- Branch code
		STF	- ATM switch store and forward flag
		PAUTH	- Partial authorizations allowed
		PAMT	- Partial authorization amount
	 INPUTS:
		PHC	- Permanent hold code
		PHDAYS	- Permanent hold days
		CUTOFF	- Hold cutoff time
	*/
	type public Boolean ER
	type public Number PHC,PHDAYS,RSPCD
	type public Date BCAL,CUTOFF
	type public String RM
	type String OVR(,,),par,RC,RJ(),SAVPTR,SPV(),ts,x
	type Number TAMT

	set TAMT=ttx(1).tamt
	set PAMT=""

	// Transaction amount was converted
	if '(ttx(1).bseamt).isNull(),ttx(1).bseamt'=TAMT set TSO=$$FIELDIN^UTSO(TSO,"TCUR",ttx(1).bseamt_ttx(1).bcrcd)

	// If STF, just add hold to the account
	if STF do { quit
		do ADDPHLD(CID,TAMT,TCMT,SPR,AUTCODE,TSO,BCAL,PHC,PHDAYS,CUTOFF)
		if ER set RSPCD=3764
		}

	// Process only the first transaction in the transaction set
	do Runtime.start("CS","","SAVPTR")
	do TRNSINGL^TRNDRV(.ttx(1),,TPD,BRCD,1,.RJ,.SPV,.OVR)
	do Runtime.rollback("SAVPTR")

	if RJ.data() set ER=1

	set RSPCD=$$CHKRSP(CID,STF,.SPV,.PAMT,PAUTH)

	// Partial preauthorization
	if RSPCD=10 do {
		kill RJ,SPV
		set ER=0
		set RM=""
		set ttx(1).tamt=PAMT
		
		do Runtime.start("CS","","SAVPTR")
		do TRNSINGL^TRNDRV(.ttx(1),,TPD,BRCD,1,.RJ,.SPV,.OVR)
		do Runtime.rollback("SAVPTR")

		if RJ.data() set ER=1
		
		set RC=$$CHKRSP(CID,STF,.SPV,,PAUTH)
		if RC=10 set RSPCD=3764 quit	// Denied 2nd time, reject
		if RC'="00" set RSPCD=RC quit
		set TAMT=PAMT
		}
 
	quit:ER

	// Add hold to the account
	if 'ER do ADDPHLD(CID,TAMT,TCMT,SPR,AUTCODE,TSO,BCAL,PHC,PHDAYS,CUTOFF)
	// Error Posting Transactions.
	if ER set RSPCD=3764

	quit


public PREDEL(Number CID,Number SPR,String PHC,String STF,Number TRTYP)

	/*
	Completions to previously placed pre-authorization holds.
	Delete PHLD and ATMHLD entries.

	ARGUMENTS:
		CID	- PROFILE account number
		SPR	- Spray Number
		PHC	- Permanent hold code
		STF	- ATM switch store and forward flag
		TRTYP	- Transaction type
	*/

	type Date EXPDT
	type Number SEQ
	type String XTLO

	// Posted to suspense
	if STF,TRTYP["SUSP" quit

	type ResultSet rs
 
	// Delete PHLD and ATMHLD records
	set SEQ=""
	set XTLO=%UserStation
	set rs=Db.select("SEQ,EXPDT","PHLD","CID=:CID AND PHC=:PHC AND SPR=:SPR AND TLO=:XTLO","SEQ DESC")
	if 'rs.isEmpty(),rs.next() set SEQ=rs.getCol("SEQ"),EXPDT=rs.getCol("EXPDT")

	// No hold exists
	if SEQ.isNull() quit

	// Remove the hold
	do Db.delete("PHLD","CID=:CID AND SEQ=:SEQ")
	do Db.delete("ATMHLD","EXPDT=:EXPDT AND CID=:CID AND SEQ=:SEQ")
 
	quit


public CHKRSP(Number CID,String STF,String SPV,Number PAMT,Number PAUTH)
	/*
	 Check for insufficient funds entries in SPV array
	 ARGUMENTS:
		CID	- PROFILE account number
		STF	- ATM switch store and forward flag
		SPV	- Supervisory override array
		PAMT	- Partial amount
		PAUTH	- Partial authorizations allowed
	 RETURNS:
		Response code
		. 00	- Transaction Approved - With Balances
		. 10	- Partial Preautorization
		. 1244	- Insufficient Funds
		. 3764	- Error Posting Transactions.
	*/
	type public Boolean ER
	type public String RM
	type Number AMT
	type String RC,X

	set PAMT=""

	// Approved
	if 'ER!STF set ER=0 quit "00"

	// Error Posting Transaction.
	if RM.get().isNull() set RM=$$^MSG(3764)
 
	set RC=3764

	if '(SPV("").order()).isNull() quit RC

	// Collate through SPV array, set PAMT to smallest positive amount
	set X=""
	for  set X=SPV(1,CID,"OVR",X).order() quit:X.isNull()  do { quit:X="RSKAVL"
		if SPV(1,CID,"OVR",X).piece("|",1)'="*" quit
		if "-AVLBAL-BAL-BALAVL-BALCOL-ODUNAMT-RSKAVL-"[("-"_X_"-") do {
			set RC=1244
			if 'PAUTH set X="RSKAVL" quit
			set AMT=SPV(1,CID,"OVR",X).piece("|",2)
			if AMT<0 quit
			if PAMT.isNull()!(AMT<PAMT) set PAMT=AMT
			}
		}

	if PAUTH,PAMT>0 set RC=10

	quit RC


public REV(RecordTTX ttx(),Number PCID,Number AMT2,Number SPR,String AUTCODE,Number TRTYP,String ATMM,String BRCD,Number PSTDYS,String PARTIAL)
	/*
	 Reverse POS and financial transactions

	 Reverse the original transaction. If the original amount was
	 incorrect, then process the transaction with the correct amount
	 after the original is reversed.
	 ARGUMENTS:
		PCID    - PROFILE account number
		AMT2	- Correction amount
		SPR     - Spray value
		AUTCODE	- Authorization code
		TRTYP	- Transaction type
		ATMM	- Unique message sequence
		BRCD	- Branch code
		PSTDYS	- Number of days to search back in account history
		PARTIAL	- Partial reversal transaction
	 INPUTS:
		PHC	- Permanent hold code
		PHDAYS	- Permanent hold days
		CUTOFF	- Hold cutoff time
		DELDUP	- Delete duplicates flag
	*/
	type public Boolean ER
	type public Number PHC,PHDAYS,PRE,RSPCD,STF
	type public Date BCAL,CUTOFF
	type public String CRCD,DELDUP,RM,TCMT,TSO
	type Boolean FLG
	type Number CID,EXCAMT,MAXRATE,MAXSEQ,MINRATE,MINSEQ,MULTIPLY
	type Number RATE,RECTYP,seq,SEQ,STFSEQ,TAMT,TRSEQ,TSEQ,VARIANCE
	type Date EFD,HTJD,TPD
	type String CLS,ETC,hist,ITC,TMPTSO,TRC,TRESREF,TRN,UID,XTLO
	type RecordACN acn

	// Check ATMDUP table for duplicate message to reverse
	set XTLO=%UserStation
	set SEQ=Db.currVal("ATMDUP","XTLO,SPR")
	if DELDUP,('SEQ.isNull()) do Db.delete("ATMDUP","TLO=:XTLO AND SPR=:SPR AND SEQ=:SEQ") quit

	// Remove hold if original transaction was a pre-authorization
	if PRE do { quit
		do PREDEL(PCID,SPR,PHC,STF,TRTYP)
		if ER quit
 
		if 'PARTIAL quit

		// Convert amount to the account's currency (buy margins, non-cash, midrate)
		set acn=Db.getRecord("ACN","PCID")
		if acn.crcd'=CRCD do {
			do EXC^CRCDUTL(CRCD,acn.crcd,AMT2,1,1,"00",acn.ccode,"",1)
			if ER quit
			set TSO=$$FIELDIN^UTSO(TSO,"TCUR",AMT2_CRCD)
			set AMT2=EXCAMT.roundDec(acn.crcd)
			set CRCD=acn.crcd
			}

		// Add new hold for new amount
		set TSO=$$FIELDIN^UTSO(TSO.get(),"ATMM",ATMM)
		do ADDPHLD(PCID,AMT2,TCMT,SPR,AUTCODE,TSO,BCAL,PHC,PHDAYS,CUTOFF)
		}

	type RecordTTX ttxtmp=Class.new("RecordTTX")

	// Find original transaction, use TSEQ to get original TR's
	do FINDH(.ttxtmp,PCID,SPR,PSTDYS,.TSEQ,.STFSEQ,.TRSEQ,.RECTYP)

	// Unable to locate transaction in account history
	if RECTYP.isNull() set RSPCD=2793 do Runtime.setErrMSG("TTX",2793) quit

	// ASSERT: TRAN contains either a HIST or TR record 

	// Set HTJD, used to decide whether to EC or REV
	if RECTYP="HIST" set HTJD=ttxtmp.tjd
	else  set HTJD=%SystemDate

	// Check if transaction has already been reversed or error corrected
	set ITC=ttxtmp.itc
	// Transaction already error-corrected
	if ITC.extract(6)!ITC.extract(12) set RSPCD=2676 do Runtime.setErrMSG("TTX",2676) quit

	set UID=%UserID
	set TAMT=ttxtmp.tamt
	set TSO=ttxtmp.tso
	set TMPTSO("ATMM")=ATMM				// Reset message sequence
	if 'AUTCODE.isNull() set TMPTSO("AUTCODE")=AUTCODE	// Reset trace number
	do IN^UTSO(.TMPTSO,.TSO)
	set EFD=""

	// Transaction found in history
	if RECTYP="HIST" do {
		set TPD=ttxtmp.tjd+ITC.extract(8)
		set TRC=ttxtmp.trc

		if TRTYP'="CREDIT" set seq=1
		else  set seq=2

		set ttx(seq)=Db.getRecord("TTX","TPD,BRCD,UID,TRC",1)
		if ttx(seq).getMode()=0 kill ttx(seq) set ER=1 quit
		set CID=ttx(seq).cid
		set TRN(CID,TRC)=TSEQ_"|"_TRC

		if seq=1 set seq=2,TRC=TRC+1
		else  set seq=1,TRC=TRC-1

		// Get second transaction
		set TSEQ=""

		set ttx(seq)=Db.getRecord("TTX","TPD,BRCD,UID,TRC",1)
		if ttx(seq).getMode()=0 kill ttx(seq) set ER=1 quit
		set CID=ttx(seq).cid

		// Re-define TSEQ for the second transaction in the set
		set ETC=ttx(seq).etc
		type RecordTRN trn=Db.getRecord("TRN","ETC")
		set CLS=trn.cls
		if HTJD'=%SystemDate,CLS'="M" do FINDH(.ttxtmp,CID,SPR,,.TSEQ)
		set TRN(CID,TRC)=TSEQ.get()_"|"_TRC
		}

	// Transaction was found in TTXFDT
	if RECTYP="TTXFDT" do {
		// Get first transaction
		set seq=(TRSEQ.toString()).extract((TRSEQ.toString()).length())
		set ttx(seq)=ttxtmp.copy()
		set CID=ttx(seq).cid
		set TRN(CID,TRSEQ)=""

		// Get second transaction
		set EFD=ttx(seq).efd
		if seq=1 set seq=2
		else  set seq=1

		// Find offset transaction, ignoring secondary transactions.
		set MINSEQ=(TRSEQ\1000)*1000
		set MAXSEQ=MINSEQ+1000

		type DbSet ds=Db.selectDbSet("TTXFDT","TJD=:EFD AND BRCD=:BRCD AND UID=:UID AND TSEQ BETWEEN :MINSEQ AND :MAXSEQ AND TSEQ<>:TRSEQ AND TRC IS NOT NULL")
		if ds.isEmpty()!('ds.next()) set ER=1 quit

		type RecordTTXFDT ttxfdt=ds.getRecord()
		set TRSEQ=ttxfdt.tseq
		set ttx(seq)=ttxfdt.copy()
		set CID=ttx(seq).cid
		set TRN(CID,TRSEQ)=""
		}

	// Transaction was found in store and forward
	if RECTYP="STFHOST"  do {

		set seq=TRSEQ
		set ttx(seq)=ttxtmp.copy()

		set TRSEQ=$S(TRSEQ=1:2,1:1)

		type RecordSTFHOST stfhost=Db.getRecord("STFHOST","STFSEQ,TRSEQ",1)
		if stfhost.getMode()=0 set ER=1 quit

		set ttxtmp.cid=stfhost.cid
		set ttxtmp.itc=stfhost.itc
		set ttxtmp.etc=stfhost.etc
		set ttxtmp.tamt=stfhost.tamt
		set ttxtmp.efd=stfhost.stfefd
		set ttxtmp.tlo=stfhost.tlo
		set ttxtmp.tso=stfhost.tso
		set ttxtmp.tcmt=stfhost.tcmt
		set ttxtmp.spr=stfhost.spr

		set seq=TRSEQ
		set ttx(seq)=ttxtmp.copy()
		}
	if ER set RSPCD="05" quit
	
	// Build partial reversal transactions
	if PARTIAL for seq=1,2 do TTX(.ttx(),ttx(seq).cid,ttx(seq).etc,AMT2,EFD,TSO,TCMT,SPR,CRCD)

	// Modify original transactions with reversal information
	for seq=1,2 do {
		if 'ttx(seq).exists() quit

		set ITC=ttx(seq).itc		// Internal transaction code
		if ITC.extract(6)!(ITC.extract(12)) set ER=1 quit
		set FLG=$S(HTJD=%SystemDate:6,1:12)
		set ITC=$$ITC^TTXEXT(ITC,FLG,1)	// Error-correct or reversal flag

		// Update TSO
		set CID=ttx(seq).cid

		// Add reversal fields to TSO
		if RECTYP="HIST",TRN(CID).exists() do {
			set TRC=TRN(CID,"").order()
			if HTJD=%SystemDate set TMPTSO("EC")=TRN(CID,TRC).piece("|",2)
			else  set TMPTSO("REV")=+TRN(CID,TRC)
			set ttx(seq).tcmt="ATM Reversal of "_+TRN(CID,TRC)
			}
		if RECTYP="TTXFDT" do {
			set TMPTSO("FDTSEQ")=TRN(CID,"").order()
			set TMPTSO("EC")=TRN(CID,"").order()
			}
		if RECTYP="STFHOST" set TMPTSO("EC")="STF"_STFSEQ_"-"_seq
		do IN^UTSO(.TMPTSO,.TSO)

		set ttx(seq).itc=ITC
		set ttx(seq).tamt=$$TAMT^TRNUTL(ttx(seq).tamt)	// Reverse transaction amount
		set ttx(seq).tso=TSO
		set ttx(seq).spr=SPR
		}

	quit


public TTX(RecordTTX ttx(),Number CID,String ETC,Number AMT,Date EFD,String TSO,String TCMT,Number SPR,String CRCD)
	/*
	 Create a transaction record

	 ARGUMENTS:
		CID	- Account number
		ETC	- PROFILE transaction code
		AMT	- Transaction amount
		EFD	- Effective date
		TSO	- Transaction source of funds
		TCMT	- Transaction comment
		SPR	- Spray value
		CRCD	- Transaction currency code
	*/

	type public Boolean ER
	type public String %MCP,RM
	type Number BSEAMT,EXCAMT,MAXRATE,MINRATE,MULTIPLY,RATE,seq,TRESREF,TRNTYP,VARIANCE
	type String BSECRCD,CCODE
	type RecordACN acn
	type RecordTRN trn

	// Retrieve transaction code information
	set trn=Db.getRecord("TRN","ETC",1)

	// Invalid transaction code
	if trn.getMode()=0 do Runtime.setErrMSG("TRN",1498,ETC) quit

	// Default currency exchange transaction values
	set (CCODE,MULTIPLY,RATE)=""
	set BSEAMT=AMT
	set BSECRCD=CRCD

	// Profile account transactions must be in the account currency
	if trn.cls'="M" do {
		// Retrieve account information
		set acn=Db.getRecord("ACN","CID",1)

		// Invalid account
		if acn.getMode()=0 do Runtime.setErrMSG("ACN",1259,CID) quit

		// Conversion not needed
		if acn.crcd=CRCD quit

		// Convert amount to account currency (margins, non-cash, mid-rate)
		set CCODE=acn.ccode
		set TRNTYP=$S($E(trn.itc):0,1:1)
		do EXC^CRCDUTL(CRCD,acn.crcd,AMT,1,TRNTYP,"00",CCODE,EFD,1)
		if ER quit
		set AMT=EXCAMT.roundDec(acn.crcd)
		set CRCD=acn.crcd

		// Add TCUR to TSO
		set TSO=$$FIELDIN^UTSO(TSO,"TCUR",BSEAMT_BSECRCD)
		}
	if ER quit

	set seq=1
	while ttx(seq).exists() set seq=seq+1

	set ttx(seq)=Class.new("RecordTTX")
	set ttx(seq).cid=CID
	set ttx(seq).itc=trn.itc
	set ttx(seq).etc=ETC
	set ttx(seq).tamt=AMT
	set ttx(seq).efd=EFD
	set ttx(seq).tlo=%UserStation
	set ttx(seq).tso=TSO
	set ttx(seq).tcmt=TCMT
	set ttx(seq).spr=SPR
	set ttx(seq).crcd=CRCD

	if %MCP do {
		set ttx(seq).crcd=CRCD
		set ttx(seq).bseamt=BSEAMT
		set ttx(seq).bcrcd=BSECRCD
		set ttx(seq).rate=RATE
		set ttx(seq).mult=MULTIPLY
		set ttx(seq).custcd=CCODE
		}
	quit


public STFCHK(Number CID,Number SPR,String TRACE,Boolean PRE,Boolean REV,Boolean FINPRE,String ATMM,Number PSTDYS)
	/*
	 Determine if a transaction has already been posted

	 ARGUMENTS:
		CID	- PROFILE account number
		SPR	- Spray value
		TRACE	- Trace value
		PRE	- Preauthorization flag
		REV	- Reversal flag
		FINPRE	- POS preauthorized debit flag
		ATMM	- Unique message sequence
		PSTDYS	- Number of days to search back in account history
	*/
	type Boolean RFLG
	type Number TCMT,TSEQ
	type String ITC,RECTYP,TRAN,XTLO

	type RecordATMDUP dup
	type RecordTTX ttxtmp=Class.new("RecordTTX")

	set TRAN=$$FINDH(.ttxtmp,CID,SPR,PSTDYS,.TSEQ,,,.RECTYP)
	if TRAN="" quit 0

	set ITC=TRAN.piece("|",2)
	set TCMT=TRAN.piece("|",8)

	/*
	 The next section code has a hard coded phrase referenced - 
	 TCMT["deleted".  Need to determine a way to avoid this since 
	 this phrase can be translated.

	 STBL("MSG",5665)=Permanent hold Sequence Number ~p1 deleted
	*/
	if RECTYP'="PHLD" set RFLG=$S(ITC.extract(6)=1:1,ITC.extract(12)=1:1,1:0)
	else  set RFLG=$S(TCMT["deleted":1,1:0)
	
	// Not a duplicate
	if FINPRE,RECTYP="PHLD" quit 0
	if REV,'RFLG quit 0
	if 'REV,RFLG quit 0

	// Transaction is a duplicate - store duplicate hit in ATMDUP
	set dup=Class.new("RecordATMDUP")
	set dup.tlo=%UserStation
	set dup.spr=SPR
	set XTLO=%UserStation
	set dup.seq=Db.nextVal("ATMDUP","XTLO,SPR")
	set dup.cid=CID
	set dup.trace=TRACE
	set dup.tseq=TSEQ
	set dup.atmseq=ATMM
	set dup.sdt=%SystemDate
	do dup.bypassSave()

	// Log a dayend exception error
	do LOG^UTLEXC("ISO8583","*","",CID,ATMM,$$^MSG(4976))

	quit 1


PROCSTF(RecordTTX ttx(),Number CID,Date TPD,String BRCD,String TSPV,String STF)
	/*
	 Process transactions in PROFILE's store and forward

	 ARGUMENTS:
		CID	- Profile account number
		TPD	- Teller posting date
		BRCD	- Branch code
		TSPV	- Teller supervisory array
		STF	- ATM switch store and forward flag
	*/
	type public Boolean ER
	type public String %IPMODE,%STFHOST
	type Number seq
	type String context,CRT,SPV,TR,vzrec,vzstfflg

	set ER=0
	set context="",vzstfflg=STF		// STF processing variables
	set vzrec=$$FMTTSSP^STFUTL(.ttx(),,BRCD,TPD)

	set %IPMODE="NOINT"			// Not interactive
	set CRT=$S(STF:2,1:1)			// 1 - online, 2 - SAF
	new X set X=CRT		// Bug in ^STFUTL
	do STFHNDL^STFUTL(.ttx(),%STFHOST,1)
	
	quit


FINDH(RecordTTX ttxtmp,Number CID,Number SPR,Number PSTDYS,Number TSEQ,Number STFSEQ,Number TRSEQ,String RECTYP)
	/*
	 Find history entry matching SPR and TLO

	 ARGUMENTS:
		CID	- PROFILE account number
		SPR	- Spray value
		PSTDYS	- Number of days to search into an account's history
	 OUTPUTS:
		HIST, TTXFDT or STFHOST record
		TSEQ	- History transaction sequence number
		STFSEQ	- Host STF sequence number
		TRSEQ	- TTXFDT or STF TR sequence
		RECTYPE - Record Type
	*/
	type public Boolean ER
	type public Number BRCD
	type public String %STFHOST
	type Date DATE
	type String TSO,TRAN,XTLO
	type ResultSet rs1
	type RecordHIST hist

	set (RECTYP,STFSEQ,TRAN,TRSEQ,TSEQ)=""
	set XTLO=%UserStation
	if +CID=0 quit ""
	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	if 'acn.getMode() quit ""

	// Check in STFHOST for stored transaction
	if %STFHOST do {
		set rs1=Db.select("STFSEQ,TRSEQ,CID,ITC,ETC,TAMT,STFEFD,TLO,TSO,TCMT,SPR","STFHOST","CID=:CID AND TLO=:XTLO AND SPR=:SPR","STFSEQ DESC")
		if rs1.isEmpty()!('rs1.next()) quit

		set STFSEQ=rs1.getCol("STFSEQ")
		set TRSEQ=rs1.getCol("TRSEQ")
		set ttxtmp.cid=rs1.getCol("CID")
		set ttxtmp.itc=rs1.getCol("ITC")
		set ttxtmp.etc=rs1.getCol("ETC")
		set ttxtmp.tamt=rs1.getCol("TAMT")
		set ttxtmp.efd=rs1.getCol("STFEFD")
		set ttxtmp.tlo=rs1.getCol("TLO")
		set ttxtmp.tso=rs1.getCol("TSO")
		set ttxtmp.tcmt=rs1.getCol("TCMT")
		set ttxtmp.spr=rs1.getCol("SPR")

		set RECTYP="STFHOST"
		}
	if RECTYP="STFHOST" quit

	// Check in HIST
	set DATE=%SystemDate-PSTDYS

	type DbSet ds=Db.selectDbSet("HIST","CID=:CID AND TJD NOT <:DATE AND TLO=:XTLO AND SPR=:SPR","TSEQ DESC")

	if 'ds.isEmpty(),ds.next() do {
		set hist=ds.getRecord()
		set ttxtmp=hist.copy()
		if '(hist.etc).isNull() set RECTYP="HIST" quit
		set TSO=hist.tso
		set RECTYP="PHLD"
		}

	quit


public JD(Date DATE)
	/*
	 Return date in julian format  (input = MMDD)

	 ARGUMENT:
		DATE	- Message date (MMDD)
	 OUTPUT:
		Julian date

	 JD determines the correct year when the system date (%SystemDate) is
	 December (12) and a posting date of January (1) is sent.  In
	 addition, JD determines the correct year when the system is
	 January (1) and the posting date is still back in December (12)

	 Ex:	System		Posting		Date
		Date		Value		Calculated
		------		-------		----------
		12/31/1999	'0101'		01/01/2000
		01/01/2000	'1231'		12/31/1999
	*/

	type Number MON,MSGMON,YEAR

	set DATE=(DATE.toString()).extract(1,4)
	if DATE="" quit ""

	set MON=$$MON^SCADAT(%SystemDate)
	set YEAR=$$YEAR^SCADAT(%SystemDate)
	set MSGMON=+(DATE.toString()).extract(1,2)
	if (MON=12),(MSGMON=1) set YEAR=YEAR+1
	if (MON=1),(MSGMON=12) set YEAR=YEAR-1

	quit $$^SCAJD(DATE_YEAR,"MMDDYEAR")


public GETTRN(String INTRFACE,String CODE,String STF)
	/*
	 Determine PROFILE transaction codes

	 Determine PROFILE transaction codes using the processing code from the
	 message and the external interface table. If no entry in the external
	 interface table for CODE is found and the message is an STF message,
	 then the "SUSP" record is used if defined. The "SUSP" entry should
	 have two miscellaneous transaction codes so that an error occurs when
	 the transaction is posted since the account group does not match,
	 although, it is possible that an account could have the same number
	 as a GL account.

	 ARGUMENTS:
		INTRFACE	- Online ATM interface
		CODE		- Process code
		STF		- ATM network store and forward flag
	 RETURNS:
		TRCD		- PROFILE transaction codes
	*/
	type public Boolean ER
	type public Number RSPCD
	type public String RM
	type String TRCD

	set TRCD=""
	type RecordUTBLEXTTRN1 uexttrn1=Db.getRecord("UTBLEXTTRN1","INTRFACE,CODE",1)

	if '(uexttrn1.trtype).isNull() set TRCD.piece($C(9),1)=uexttrn1.trtype
	if '(uexttrn1.dretc).isNull() set TRCD.piece($C(9),2)=uexttrn1.dretc
	if '(uexttrn1.cretc).isNull() set TRCD.piece($C(9),3)=uexttrn1.cretc

	if 'TRCD.isNull() quit TRCD

	// Invalid process ID
	if 'STF set RSPCD=1427 do Runtime.setErrMSG("UTBLEXTTRN1",1427) quit ""

	set CODE="SUSP"

	type RecordUTBLEXTTRN1 uexttrn2=Db.getRecord("UTBLEXTTRN1","INTRFACE,CODE",1)

	if '(uexttrn2.trtype).isNull() set TRCD.piece($C(9),1)=uexttrn2.trtype
	if '(uexttrn2.dretc).isNull() set TRCD.piece($C(9),2)=uexttrn2.dretc
	if '(uexttrn2.cretc).isNull() set TRCD.piece($C(9),3)=uexttrn2.cretc

	// Invalid process ID
	if TRCD.isNull() set RSPCD=1427 do Runtime.setErrMSG("UTBLEXTTRN1",1427) quit ""

	quit TRCD


public TLRPDT(Number BCAL,String BRCD,Date EFD)
	/*
	 Determine and validate TPD (teller posting date)

	 If an error occurs, try to roll the date forward to the next 
	 business date if the error is one of the following:
	  1123 - Forward balancing date already assigned
	  1275 - Invalid business date
	  2208 - Posting file closed for
	  2573 - System has already balanced on
	  2618 - Teller posting file is closed for

	 ARGUMENTS:
		BCAL	- Business day calendar
		BRCD	- Branch code
		EFD  	- Effective Date      /REF:W
	   OUTPUTS:
		$$	- Teller Processing Date
	*/

	type public Boolean ER
	type public String %MSGID,%UID,RM
	type String ID,TPD,X

	type RecordSIGNON signon=Db.getRecord("SIGNON","%UID",1)

	set TPD=signon.tpd

	set ER=0
	set RM=""
	if TPD="" set TPD=$$NBD^UNBD(%SystemDate,1,0,BCAL)
	set X=TPD do TPD^SIGNON		// X,%UID,TJD,BRCD,TPD are needed
	if ER do {
		set ID=%MSGID.get().piece("|",1)
		if ",1123,1275,2208,2573,2618,"'[(","_ID_",") quit

		set ER=0
		set RM=""
		set TPD=$$NBD^UNBD(TPD+1,1,0,BCAL)
		set X=TPD do TPD^SIGNON
		}
	set EFD = ""
	quit TPD


public NXTSEQ()
	/*
	 Unique message sequence

	 OUTPUT:
		Unique message sequence
	*/

	type String JOB,TIME,VAL

	set JOB=%ProcessID

	type RecordNXTSEQ nxt=Db.getRecord("NXTSEQ","JOB",1)

	set VAL=nxt.unq+1
	set nxt.id=JOB
	set nxt.unq=VAL
	do nxt.bypassSave()

	set TIME=%CurrentTime
	quit %CurrentDate_("00000".extract(1,5-TIME.length()))_TIME_("000000".extract(1,6-JOB.length()))_JOB_("00000".extract(1,5-VAL.length()))_VAL


public ADDPHLD(Number CID,Number AMT,Number TCMT,Number SPR,String AUTCODE,String TSO,Number BCAL,String PHC,Number PHDAYS,String CUTOFF)

	/*
	 Insert entry into PHLD.
	 
	 The expiration date is set to one day after
	 the next BCAL business date. Today's date is considered the next
	 business date.
	 ARGUMENTS:
		CID	- PROFILE account number
		AMT	- Hold amount
		TCMT	- Teller comment
		SPR	- Spray value
		AUTCODE	- Authorization code
		TSO	- Transaction source of funds
		BCAL	- Business day calendar
		PHC	- Permanent hold code
		PHDAYS	- Permanent hold days
		CUTOFF	- Hold Cutoff Time
	 RETURNS:
		RSPCD	- Response code
	*/

	type public String %STFHOST
	type Date DATE

	set DATE=%SystemDate
	if 'CUTOFF.isNull(),(%CurrentTime'<CUTOFF)!(%SystemDate<%CurrentDate) set DATE=DATE+1

	type RecordPHLD phld

	set phld=Class.new("RecordPHLD")
	set phld.cid=CID
	set phld.seq=Db.nextVal("PHLD","CID")
	set phld.stdt=%SystemDate
	set phld.expdt=$$NBD^UNBD(DATE,PHDAYS,0,BCAL)+1
	set phld.amt=AMT
	set phld.phc=PHC
	set phld.tcmt=TCMT
	set phld.spr=SPR
	set phld.tlo=%UserStation
	set phld.autcode=AUTCODE
	set phld.stfhost=$S(%STFHOST:1,1:0)
	set phld.tso=TSO
	do phld.save("/NOVALDD")

	quit


public CKTRN(RecordTTX ttx(),String TSO,Number RT)
	/*
	 Update the CK transaction in the transaction set.
	 ARGUMENTS:
		TSO	- Transaction source of funds
		RT	- Routing and transit number
	*/

	type String CHKTYP,CKTSO,UTSO

	if RT.isNull() quit

	set CHKTYP=3
	do OUT^UTSO(.UTSO,TSO)			// Parse TSO field
	set UTSO("CHKTYP")=CHKTYP		// Hold based on RT number
	set UTSO("RT")=RT			// Routing and transit number
	do IN^UTSO(.UTSO,.CKTSO)		// Add check hold information

	// Add check information to the CK transaction
	set ttx(1).tso=CKTSO
	set ttx(1).chktyp=CHKTYP
	
	quit

vSIG()	quit "60639^54164^Marie Mbui^26195"	// Signature - LTD^TIME^USER^SIZE
