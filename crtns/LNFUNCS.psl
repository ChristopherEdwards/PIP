LNFUNCS

	/*
	Loan Filer Functions

	   ORIG: RUSSELL - 03/14/96
	   DESC: Loan Filer Functions
	
	   KEYWORDS: Loans
	
	   LIBRARY:
	   . BALINT   - Calculate value of BALINT
	   . BLOFF    - Billing offset
	   . CBMET1   - Coupon book info - method=1
	   . CBMET2   - Coupon book info - method=2
	   . CBMET3   - Coupon book info - method=3
	   . COLCID   - Return CID to use for collateral history
	   . CRLMT    - Return logical for existence of DTJNA record
	   . CRTRGP   - General purpose credit tran code
	   . CHK2FRE  - Check secondary frequencies
	   . CHK2ND   - Check secondary frequency dates
	   . COLLVR   - Collateral loan to value ratio
	   . DATECNT  - Count number of days in LNPS1
	   . DFRCSTR  - Deferred fees receivable string for DAYENDXFR journal
	   . EPPOFF   - Early payoff- percentage of term
	   . ESCCID   - Get escrow CID 
	   . ESCCIDUL - Unlock account
	   . EXPINF   - Loan expense information
	   . FBP      - Fixed bullet product indicator
	   . FRCSTR   - Fees receivable string for DAYENDXFR journal
	   . LIMITS   - Lending limits
	   . LNAMOJRN - History insert journal message for LNAMOAO
	   . LNBIL1   - Change order of LNBIL1 record elements
	   . LNPS1    - Return data for LNPS1 changes
	   . MAXFND   - Maximum funding limit
	   . NALPB    - Neg amort - Max % increase over original balance
	   . NDFREC   - Net Deferred fees receivable for DAYENDXFR journal
	   . ODSRC    - Overdraft source info
	   . PPINFO   - Payment path, string and other node 49 info
	   . PATINFO  - PAT info from product
	   . PMTDIST  - PMTDIST change - update LNBIL0 and LNBIL1
	   . PMTELEM  - Payment elements from LNBIL0
	   . PMTF     - Elements required for payment frequency checks
	   . PTMF     - Return LTYPE.PTMF flag
	   . RATEFC   - Rate floor and ceiling from product
	   . TRTRM    - Teaser rate term
	   . SETSTAT  - Set loan and attached escrow account status

	---- Revision History ------------------------------------------------
	
	11/14/06 - KELLYP - CR 24104
		   Modified LNAMOJRN section to return proper message for 
		   HIST.TCMT when journaling LNCYC* record creation.
	
	10/31/06 - SANTHUMS - CR 23708
		   Modified FRCSTR section to replace the column DEFTOT 
		   with FEEREM in the select statement of LNFEE table. 
		
	06/30/06 - SWARNALP - CR 21448
		   Deleted the section TTINSRT since this section is nowhere 
		   used and the source screen LNNEW6 which calls this section 
		   has already been found obsoleted for CR 19137 and the other 
		   source LN executive is not in use and the logic to set 
		   LN.RND with ESC1 can be found in AFTER_INSERT trigger of 
		   TRTYPE table.
		    
	05/12/06 - SmithCD - CR 19732
		   . Added code to loop through secondary escrow transactions 
		     generated by the primary, each calling new section 
		     CHKSTAT (code formerly in SETSTAT section)
		   . Replaced recursive call to SETSTAT in SETSTAT section for 
		     non-reversal escrow transaction with call to UPDSTAT 
		     instead, passing the same parameters, so dep.stat can 
		     get updated on the escrow account
		   . Removed code that caused acn.stat and acn.dtc to get into 
		     the history of the account to bring in-line with prior 
		     versions
		   . Replace %CACHE() with cache(,,) in BALINT section since 
		     it is used as a String class instead of a Cache class
		   	
	01/31/06 - SmithCD - CR 19343 (16890)
		   Modified trn.pcfl5 check in SETSTAT section to reference 
		   trn.pcf.extract(5) instead b/c the transaction passed 
		   may be to either a loan or a deposit (escrow) account. 
		   Fixed informational in SETSTAT section by using compiler 
		   directives from CUVAR.PUBLISH.

	10/05/05 - KELLYP - CR 17399
		   Retrofitted SETSTAT, IGNORE, and UPDSTAT sections from 
		   Profile01.  These sections are used to calculate and set
		   a loan (and attached escrow) account's status during a 
		   payoff/closeout transaction.  Also removed pre-2003
		   revision history.
	
	05/23/05 - arpavc - 15570
		   Modified COLCID section to retrieve CID
		   from the main COL table instead of getting
		   the next key from LNCOLC, which is an index and 
		   may not be updated in oracle environments.
		   
	04/11/05 - KinI - 14385
		   Modified NDFREC section to fix undefined PTS.

	*/

	// Do not enter from top
	quit


public BALINT(RecordLN ln)		// Loan account			/REF:R

	/*
	Returns value of balance for int calculation
	
	   Calculated value based on input in data array.

	   RETURNS:
	   . $$ Calculated value for BALINT 	/TYP=N
	
	   EXAMPLE:
	   S BALINT=$$BALINT^LNFUNCS(.ln)
	
	*/

	type public String cache(,,)
	type public Boolean ER

	type Number BALINT
	type String PRIO
	
	if 'cache("LNFUNCS", "ICPA", ln.icpa).exists() do { if ER quit ""
		type RecordUTBLICPA utblicpa = Db.getRecord("UTBLICPA","KEY=:ln.icpa")
		set cache("LNFUNCS", "ICPA", ln.icpa) = utblicpa.prio
		}

	set PRIO = cache("LNFUNCS", "ICPA", ln.icpa)
	
	set BALINT=ln.bal
	
	if ln.iam.extract(1)=1 set BALINT=BALINT-ln.iun+ln.ipl-ln.extamt       
	if ln.aruf set BALINT=ln.bal-ln.udbal
	
	if PRIO.extract(1) set BALINT=BALINT+ln.unin
	if PRIO.extract(2) set BALINT=BALINT-ln.unpr
	if PRIO.extract(3) set BALINT=BALINT+ln.unes
	if PRIO.extract(4) set BALINT=BALINT-ln.teb
	if PRIO.extract(5) set BALINT=BALINT+$$MCND^LNCO3(1,.ln,ln.cid)
	if PRIO.extract(6) set BALINT=BALINT+ln.lchg
	if PRIO.extract(7),ln.cuin>0 set BALINT=BALINT+ln.cuin
	if PRIO.extract(8),ln.cupr>0 set BALINT=BALINT-ln.cupr
	if PRIO.extract(9),ln.cues>0 set BALINT=BALINT+ln.cues
	if PRIO.extract(10) set BALINT=BALINT-ln.dic+ln.narl
	if PRIO.extract(11),ln.cupr<0 set BALINT=BALINT-ln.cupr

	set BALINT=BALINT+ln.extamt 
	    
	if PRIO.extract(12),ln.crlmt<BALINT set BALINT=ln.crlmt
	
	if PRIO.extract(13) do {
		set BALINT=BALINT-ln.ifda 
		if BALINT<0 set BALINT=0
		}  
			     
	if BALINT<0,ln.iam.extract(1)=1,'ln.tdr set BALINT=0     
	
	quit BALINT


public BLOFF(Number TYPE)	// Loan product type			/NOREQ

	// Returns billing offset

	if TYPE.get().isNull() quit ""
	
	type RecordPRODDFTL proddftl=Db.getRecord("PRODDFTL","TYPE=:TYPE")

	quit proddftl.bloff

	
public CHK2FRE(Number CID,		// Account number
	       String MFRE,		// Master frequency
	       String FRE)		// Frequency to check

	/*
	Check secondary frequencies

	   Secondary frequencies must be a subset of master frequency
	
	   RETURNS:
	   . $$  Success flag  			/TYP=L
	     0 = problem
	     1 = OK
	
	*/

	type String MFREDTS()
	type Date END,NJD,START
	type Boolean OK=1

	// Start from first of year and load all master frequency dates
	set NJD=$$^SCAJD("1/1","MM/YY") 
	set START=NJD 
	set END=NJD+365

	for  set NJD=NJD.nextFreqDate(MFRE) quit:NJD>END!(ER)  set MFREDTS(NJD)=""
	if ER quit 0
	
	set NJD=START

	for  set NJD=NJD.nextFreqDate(FRE) quit:NJD>END!(ER)  if 'MFREDTS(NJD).exists() set OK=0 quit 
	if ER quit 0

	quit OK

	
public CHK2ND(CID,MFRE,NEXTDT1,FRE,FRENO,NEXTDT,BLOFF,SYSDATE)

	/*
	Check secondary frequency dates
	
	   ARGUMENTS:
	   . CID  Account number  		/TYP=N/REQ
	
	   . MFRE  Value of DIST1FRE 		/TYP=F/REQ
	
	   . NEXTDT1 DIST1ND   			/TYP=D/REQ
	
	   . FRE  Frequency to check 		/TYP=F/REQ
	
	   . FRENO  Frequency number 		/TYP=N/REQ
	
	   . NEXTDT Next date for fre 		/TYP=D/REQ
	
	   . BLOFF  LN.BLOFF  			/TYP=N/REQ
	
	   . SYSDATE SystemDate  		/TYP=D/REQ
	
	   RETURNS:
	   . $$  success flag  			/TYP=N
	     ""   = OK
	     0 = date bad, but no recommended date
	     date = date bad, this is recommended
	
	*/

	new ER,MDATES,NJD,OK

	set OK=""
	// Verify secondary "*" frequencies
	if FRE="*" do {
		if BLOFF="1P" set NJD=$$NJD^UFRE(SYSDATE-1,"*"_FRENO) quit:ER 
		else  set NJD=$$NJD^UFRE(SYSDATE+BLOFF-1,"*"_FRENO) quit:ER 
		if NJD'=NEXTDT!$G(ER) set OK=NJD
		}
	else  if NEXTDT,NEXTDT-BLOFF<SYSDATE set OK=0
	
	// Check to make sure secondary date corresponds with master date
	if NEXTDT'=NEXTDT1 do {
		set NJD=NEXTDT1
		for  set NJD=$$NJD^UFRE(NJD,MFRE) quit:NJD'<NEXTDT!($G(ER)) 
		if NJD'=NEXTDT set OK=0
		}

	quit OK


public CBMET1(ONP,CNTCR)	// Returns coupon info for method=1

	/*
	   CBMET = 1 => produce based on orignal number of payments
	
	   Returns number of payments for coupon method 1 for setup of coupon
	   book ordering file, LNCPN, for new loan record or as a result of
	   changes to the loan record.
	
	   ARGUMENTS:
	   . ONP  Original number of pmts 	/TYP=N
	
	   . CNTCR  Payments satisfied 		/TYP=N
	
	   RETURNS:
	   . $$  Number of payments 		/TYP=N
	
	   EXAMPLE:
	   D NCP=$$CBMET1^LNFUNCS(.CBPND,36,0)
	
	*/

	quit ONP-CNTCR

	
public CBMET2(CBPND,CBOFF,APCND,ANFRE,PCHND,PCFRE,ICM,DIST1ND,DIST1FRE)

	/*
	Returns coupon info for method=2

	   CBMET = 2 => produce based on payment/analysis change frequency
	
	   Returns number of payments and next date for coupon method 2 for
	   setup of coupon book ordering file, LNCPN, for new loan record or as
	   a result of changes to the loan record.
	
	   ARGUMENTS:
	   . CBPND  Next date  			/TYP=D/MECH=REFNAM:W
	     Returned for use with new loans
	
	   . CBOFF  Offset days  		/TYP=N
	
	   . APCND  Analysis pmt chg nxt dt 	/TYP=D
	
	   . ANFRE  Analysis frequency 		/TYP=F
	
	   . PCHND  Payment change nxt dt 	/TYP=D
	
	   . PCFRE  Payment change freq 	/TYP=F
	
	   . ICM  Interest collect meth 	/TYP=N
	
	   . DIST1ND Distribution 1 nxt dt 	/TYP=D
	
	   . DIST1FRE Distribution 1 freq 	/TYP=F
	
	   RETURNS:
	   . $$  Number of payments 		/TYP=N
	
	   EXAMPLE:
	   D NCP=$$CBMET2^LNFUNCS(.CBPND,7,56401,"1MAE",,,0,56350,"1MAE")
	
	   NOTE:  One of APCND/ANFRE OR PCHND/PCFRE are required to be non-nulls.
	
	   Use NXTDT array to set calculate possible next coupon book production
	   dates based on either analysis payment change or payment change.  Then
	   figure number of coupons needed between now and then.
	
	*/

	new FRE,JD,NJD,NUMCPNS,NXTDT,NXTPRDDT
	
	if $G(PCHND) do { quit:ER 
		// ICM = in advance
		if ICM set NJD=PCHND
		else  do { quit:$G(ER) 
			set JD=PCHND 
			set FRE=DIST1FRE 
			set NJD=$$NJD^UFRE(JD,FRE)
			set NXTDT(NJD)=PCFRE 
			// ICM = in arrears
			}
		}
	if $G(APCND) set NXTDT(APCND)=ANFRE
	
	// Make sure that the earliest date is past the first distribution
	for  set JD=$O(NXTDT("")) quit:JD>DIST1ND  do { quit:ER
		set FRE=NXTDT(JD)
		kill NXTDT(JD)
		set NJD=$$NJD^UFRE(JD,FRE) quit:$G(ER)
		set NXTDT(NJD)=FRE
		}
	
	/* Start from first distribution and count payments up until earliest
	   event calculated in NXTDT (next production date)
	*/
	set JD=DIST1ND 
	set FRE=DIST1FRE 
	set NXTPRDDT=$O(NXTDT(""))
	for NUMCPNS=0:1 quit:JD'<NXTPRDDT  set NJD=$$NJD^UFRE(JD,FRE) quit:$G(ER)  set JD=NJD
	
	set CBPND=NXTPRDDT-CBOFF
	
	quit NUMCPNS


public CBMET3(CBPND,CBOFF,CBFRE,DIST1ND,DIST1FRE)	// Returns coupon info for method=3

	/*
	   CBMET = 3 => produce based on coupon production frequency
	
	   Returns number of payments and next date for coupon method 3 for
	   setup of coupon book ordering file, LNCPN, for new loan record or as
	   a result of changes to the loan record.
	
	   ARGUMENTS:
	   . CBPND  Next date  			/TYP=D/MECH=REFNAM:W
	     Returned for use with new loans
	
	   . CBOFF  Offset days  		/TYP=N
	
	   . CBFRE  Production frequency 	/TYP=F
	
	   . DIST1ND Distribution 1 nxt dt 	/TYP=D
	
	   . DIST1FRE Distribution 1 freq 	/TYP=F
	
	   RETURNS:
	   . $$  Number of payments 		/TYP=N
	
	   EXAMPLE:
	   D NCP=$$CBMET3^LNFUNCS(.CBPND,7,"12MA1",56350,"1MAE")
	
	
	*/

	new NJD,NUMCPNS,NXTPRDDT

	set NJD=$$NJD^UFRE(DIST1ND,CBFRE) quit:$G(ER) ""
	set NXTPRDDT=NJD
	
	/* Count number of payments from first distribution date up to next
	   production date
	*/

	for NUMCPNS=0:1 quit:DIST1ND'<NXTPRDDT  set NJD=$$NJD^UFRE(DIST1ND,DIST1FRE) quit:$G(ER)  set DIST1ND=NJD
	
	set CBPND=NXTPRDDT-CBOFF

	quit NUMCPNS


public COLCID(COLL,COLCID)	// Used by COL HIST_UPDATE journal

	/*
	   Return CID for use by collateral journal to file history to
	   account.  If colcid is passed in, return it; otherwise, return
	   the first account linked to this collateral record.  This is
	   necessary since a collateral record may be modified without
	   reference to an account.  'colcid' will be set in LNCOLSTS and
	   may be passed by a non-native client as a USING value.
	
	*/

	if $G(COLCID) quit COLCID

	type Number CID
	type ResultSet rs
	
	set rs=Db.select("CID","LNCOL","COLL=:COLL","CID ASC")
	if 'rs.next() quit ""
	set CID=rs.getCol("CID")
	
	quit CID


public COLLVR(LNCRCD,CRLMT,AMTREQ,COLCRCD,COLVAL,PRICE)	// Returns loan to value ratio
	
	new LVR

	// Sync currency values
	if COLCRCD'=LNCRCD do {
		do CAMT^CRCDUTL(COLCRCD,LNCRCD,.COLVAL)
		do CAMT^CRCDUTL(COLCRCD,LNCRCD,.PRICE)
		}
	if (PRICE>COLVAL)!'PRICE set PRICE=COLVAL
	if 'COLVAL set LVR=0
	else  do {
		new X
		
		set X=$S(CRLMT:CRLMT,AMTREQ:AMTREQ,1:0)
		set LVR=$$^SCARND((X/COLVAL)*100,0,,,0)
		}
	// Max value
	if $L(LVR)>4 set LVR=9999

	quit LVR


public CRTRGP(TYPE)	// Returns general credit tran code

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/
	
	if $G(TYPE)="" quit ""

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
	
	quit prodctl.crtrgp


public DATECNT(CID)	// Returns number of dates in LNPS1

	/*
	   ARGUMENTS:
	   . CID Account number   	/TYP=N/REQ
	
	   RETURNS:
	   . $$ Number of dates   	/TYP=N
	
	*/
		
	type ResultSet rs=Db.select("COUNT(PDD)","LNPS1","CID=:CID")

	if 'rs.isEmpty() if rs.next() quit rs.getCol(1)
	
	quit

	
public DFRCSTR(CID)	// returns deferred fees receivable string

	/*
	   Returns string of information related to current deferred fees
	   receivable for use in the LN file journal for DAYENDXFR for changes
	   to cost center or GL set code
	
	   ARGUMENTS:
	   . CID Account number    			/TYP=N/REQ
	
	   RETURNS:
	   . $$ Deferred fees receivable string  	/TYP=T
	       TotalAmt@FeePlan#FeeRecAmt[~FeePlan#FeeRecAmt ...]
	
	   EXAMPLE:
	   S X=$$DFRCSTR^LNFUNCS(CID)
	
	*/

	new DEFTOT,FEETYP,STRING,TOTAL

	set (FEETYP,STRING)="" 
	set TOTAL=0
	type ResultSet rs=Db.select("FEETYP","LNFEE","CID=:CID")

	if 'rs.isEmpty() while rs.next() do {
		set FEETYP=rs.getCol(1)
		type ResultSet rs1=Db.select("DEFTOT","LNFEE","CID=:CID AND FEETYP=:FEETYP")

		if rs1.isEmpty() quit

		while rs1.next() do {
			set DEFTOT=rs1.getCol(1)
			set TOTAL=TOTAL+DEFTOT
			set STRING=STRING_FEETYP_"#"_DEFTOT_"~"
			}
		}

	if STRING'="" set STRING=TOTAL_"@"_STRING
	
	quit STRING

	
public EPPOFF(TYPE)	// Returns early payoff - percentage of term

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/

	if $G(TYPE)="" quit ""
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")

	quit prodctl.eppoff

	
public ESCCID(TYPE,CRCD)	// Returns escrow account number

	/* Note - CLS, GRP, TYPE, and CRCD are generally needed by account
	   assignment routine

	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ

	*/

	new CID

	set CID=""
	set CLS="D"
	set GRP="ESC"
	
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

	set UCID=cuvar.ucid
	do @UCID
	for CID=CID:1 do {
		lock +ACN(CID):2 else  quit
		if Db.isDefined("ACN","CID") lock -ACN(CID)
		} 

	quit CID


public ESCCIDUL(ESCCID)	// Unlock the escrow account

	lock -ACN(ESCCID)
	
	quit 

	
public EXPINF(TYPE)	// Returns expense information

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/
	
	if $G(TYPE)="" quit ""
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
	
	quit prodctl.lexv_"|"_prodctl.lexf


public FBP(TYPE)	// Returns fixed bullet indictor

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/

	if $G(TYPE)="" quit ""
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")

	quit prodctl.fbp

	
public FRCSTR(CID)	// Returns fees receivable string

	/*
	   Returns string of information related to current fees receivable for
	   use in the LN file journal for DAYENDXFR for changes to cost center
	   or GL set code
	
	   ARGUMENTS:
	   . CID Account number  			/TYP=N/REQ
	
	   RETURNS:
	   . $$ Fees receivable string 			/TYP=T
	       TotalAmt@FeePlan#FeeRecAmt[~FeePlan#FeeRecAmt ...]
	
	   EXAMPLE:
	   S X=$$FRCSTR^LNFUNCS(CID)
	
	*/

	new FEEREM,FEETYP,STRING,TOTAL,X

	set (FEETYP,STRING)="" 
	set TOTAL=0

	type ResultSet rs=Db.select("FEETYP","LNFEE","CID=:CID")

	if 'rs.isEmpty() while rs.next() do {
		set FEETYP=rs.getCol(1)
		type ResultSet rs1=Db.select("FEEREM","LNFEE","CID=:CID AND FEETYP=:FEETYP")
		while rs1.next() do {
			set FEEREM=rs1.getCol(1)
			set TOTAL=TOTAL+FEEREM
			set STRING=STRING_FEETYP_"#"_FEEREM_"~"
			}
		}
	if STRING'="" set STRING=TOTAL_"@"_STRING

	quit STRING

	
public LNAMOJRN(String TYPE,String PLAN)	// TCMT for LNAMOAO journal message

	/*
	   ARGUMENTS:
	   . TYPE  AOAMO.TYPE   /REQ
	   . PLAN  AOAMO.PLAN	/REQ
	   	
	*/

	// Def Fees Added, Plan ~p1
	if TYPE="PTS" quit $$^MSG(4165,PLAN)  
	
	// ~p1 fees added plan ~p2
	quit $$^MSG(781,TYPE,PLAN)
	

public LIMITS(TYPE)	// Returns lending limit info

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/

	if $G(TYPE)="" quit ""
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
	
	quit prodctl.limigrp_"|"_prodctl.limpgrp

		
public LNBIL1(CID,ORDER)	// Modify LNBIL1 record elements

	/*
	   Modifies order and adds new elements
	   Called from LNBIL0 trigger
	*/

	new SCHSEQ

	type RecordLNBIL1 lnbil1
	set SCHSEQ=0
	for  set SCHSEQ=Db.nextKey("LNBIL1","CID,SCHSEQ") quit:SCHSEQ=""  do { quit:ER 
		set lnbil1=Db.getRecord("LNBIL1","CID,SCHSEQ")
		do PMTDIST1(.lnbil1,ORDER) quit:ER 
		do lnbil1.save()
		}

	quit 


public MAXFND(TYPE)	// Returns maximum funding limit

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/

	if $G(TYPE)="" quit ""
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")

	quit prodctl.maxfnd

	
NAGL(TYPE)	// Returns nonaccrual G/L linkage

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/

	if $G(TYPE)="" quit ""
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
	
	quit prodctl.nagl


public NALPB(TYPE)	// Returns Neg amort Max % increase over orig bal

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/

	if $G(TYPE)="" quit ""
	type RecordPRODDFTL proddftl=Db.getRecord("PRODDFTL","TYPE")
	
	quit proddftl.nalpb


public NDFREC(CID)	// Returns net fee amount for DAYENDXFR journal

	/*
	   Returns amount representing net deferred fee receivable (original
	   amount less calculated to date) for use in the LN file journal for
	   DAYENDXFR for changes to cost center
	
	   ARGUMENTS:
	   	. CID Account number   			/TYP=N/REQ
	
	   RETURNS:
	   	. $$ Net deferred fee amount  		/TYP=N
	
	   EXAMPLE:
	   	S X=$$NDFREC^LNFUNCS(CID)
	
	*/
	
	type String PTS="PTS"

	type RecordLNCYCPTS lncycpts=Db.getRecord("LNCYCPTS","CID=:CID,TYP=:PTS",1)
	
	quit lncycpts.amt-lncycpts.caltd
	
	
public ODSRC(TYPE)	// Returns fixed bullet indictor

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/

	if $G(TYPE)="" quit ""
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")

	quit prodctl.odsitr_"|"_prodctl.odsmtr

	
public PPINFO(TYPE)	// Returns various node 49 elements

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/

	if $G(TYPE)="" quit ""
	type RecordPRODDFTL proddftl=Db.getRecord("PRODDFTL","TYPE")

	quit proddftl.pap_"|"_proddftl.trb_"|"_proddftl.pas_"|"_proddftl.pdag_"|"_proddftl.pcm


public PATINFO(TYPE)	// Returns product PAT info

	/*
	   ARGUMENTS:
	   . TYPE  LN.TYPE   			/TYP=N/REQ
	   	
	*/

	if $G(TYPE)="" quit ""
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
    
	quit prodctl.patsrc_"|"_prodctl.patglo

	
public PMTDIST(CID,PMTDIST,PMTDISTF)

	/*
	Update LNBIL0 and LNBIL1 on LN.PMTDIST change
	
	   Establish new element order based on PMTDIST, then break each
	   BIL record apart and reconstruct in new order, adding any new
	   elements.  If a new fee is added, delete any LNBIL5 record of that
	   fee that may have existed due to the fee being on the account but
	   not in the payment string.
	
	   NOTE:  PMTDIST and PMTDISTF are new values
	
	*/

	new FEETYP,NEWELEMS
	
	// Modify LNBIL0 first
	type RecordLNBIL0 lnbil0

	set lnbil0=Db.getRecord("LNBIL0","CID",1)
	do PMTDIST0(.lnbil0,PMTDIST,.NEWELEMS,PMTDISTF) 
	quit:ER 
	do lnbil0.save()
	
	// Then individual bill records
	do LNBIL1(CID,PMTDIST)
	
	// If any new fees, delete LNBIL5 records
	set FEETYP=""
	for  set FEETYP=$O(NEWELEMS(FEETYP)) quit:FEETYP=""  do {
		quit:$$ESC^LNU(FEETYP) 
		quit:'Db.isDefined("LNFEEP","FEETYP")
		do Db.delete("LNBIL5","CID=:CID AND FEETYP=:FEETYP")
		}

	quit 


PMTDIST1(RecordLNBIL1 lnbil1,ORDER,NEWELEMS)	// Modify individual records

	/*
	   Reorder or insert new elements
	   Called by LNBIL1 
	*/

	new DATA,DISTNO,LNBIL1,OLD,P,X
	
	set LNBIL1=$TR($$BIL1ELE^BILFUNCS(.lnbil1),$C(9),"|")
  
	for P=2:1 set X=$P(LNBIL1,"|",P) quit:X=""  set OLD($P(X,"#",1))=X

	set LNBIL1=$P(LNBIL1,"|",1)
	for P=1:1 set X=$P(ORDER,"-",P) quit:X=""  do {
		if '$D(OLD(X)) set DATA=X set NEWELEMS(X)=""
		else  set DATA=OLD(X) kill OLD(X)
		do SETELMT^BILFUNCS(.lnbil1,P,DATA)
		}
	// Bill record elements may not be deleted
	if $D(OLD) do Runtime.setErrMSG("LNBIL1",782) quit:ER 
	
	quit 

	       
PMTDIST0(RecordLNBIL0 lnbil0,ORDER,NEWELEMS,PMTDISTF)

	/*
	Modify individual records

	   Reorder or insert new elements
	   Called by PMTDIST 
	*/

	new DATA,DISTNO,LNBIL0,OLD,P,X
 
	set LNBIL0=$TR($$ELEMENT^BILFUNCS(.lnbil0),$C(9),"|")
  
	for P=2:1 set X=$P(LNBIL0,"|",P) quit:X=""  set OLD($P(X,"#",1))=X
	set LNBIL0=$P(LNBIL0,"|",1)
	for P=1:1 set X=$P(ORDER,"-",P) quit:X=""  do {
		if '$D(OLD(X)) set DATA=X set NEWELEMS(X)=""
		else  set DATA=OLD(X) kill OLD(X)
		if $G(PMTDISTF) set DISTNO=$P(PMTDISTF,"-",P) set $P(DATA,"#",4)=DISTNO
		do SETBIL0^BILFUNCS(.lnbil0,P,DATA)
		}

	// Bill record elements may not be deleted
	if $D(OLD) do Runtime.setErrMSG("LNBIL0",782) quit:ER
		
	quit	


public PMTELEM(CID,PMTELEM)	// Return payment elements from LNBIL0

	/*
	   ARGUMENTS:
	   . CID  LN.CID  			/TYP=N/REQ
	
	   . PMTELEM Pmt elem array 		/TYP=larray/MECH=REFARR:W
	     Returns all defined payment
	     elements in form -
	       PMTELEM(pe_number)=pe_acronym#dep_account
	
	*/

	new I,LNBIL0,PE

	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID",1)
	if lnbil0.getMode()=0 quit

	set LNBIL0=$TR($$ELEMENT^BILFUNCS(.lnbil0),$C(9),"|")
 
	for I=1:1:20 set PE=$P(LNBIL0,"|",I) if PE'="" set PMTELEM(I)=$P(PE,"#",1,2)
	
	quit 

	
public PMTF(Number TYPE)		// Loan product type		/NOREQ

	// Returns info used for pmt frequency checking

	if TYPE.get().isNull() quit ""
	
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")

	quit prodctl.ppif_"|"_prodctl.fpf

	
public PTMF(Number TYPE)		// Loan product type		/NOREQ

	// Returns LTYPE.PTMF

	if TYPE.get().isNull() quit ""
	
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
	
	quit prodctl.ptmf


public RATEFC(Number TYPE,		// Loan product type
	      Number FLOOR,		// Interest rate floor		/REF:W
	      Number CEILING)		// Interest rate ceiling	/REF:W

	// Returns rate floor and ceiling
 
	if TYPE.get().isNull() set (FLOOR,CEILING)="" quit

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")
       
       	set FLOOR=prodctl.intf
	set CEILING=prodctl.intc
		
	quit 

	
TRTRM(Number TYPE)		// Loan product type			/NOREQ

	// Returns teaser rate term

	if TYPE.get().isNull() quit ""
	
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE")

	quit prodctl.trtrm


CRLMT(Date TJD,String CLS,String GRP,String TYPE,Number CID)

	// Called from ln journal CRLMT_U

	quit Db.isDefined("DTJNA","TJD,CLS,GRP,TYPE,CID")
	

public SETSTAT(RecordACN acn,		// Account			/REF:RW
	       RecordTTX ttx,		// Transaction			/REF:R
	       Boolean REV)		// Reversal indicator

	/*
	This section handles the setting of ACN.STAT for both loans
	and escrow accounts attached to loans when processing a loan
	payoff transaction or an escrow closeout transaction
	*/

	type public Boolean ER
	type public RecordDEP dep,dep()
		
	type Number TRNHSEQ = ttx.getStoredValue("HistSeq")
	
	if 'TRNHSEQ quit
		
	// Determine status of any spawned escrow transactions first
	type ResultSet rs = Db.select("ACT,RSEQ", "HISTLST,DEP", "HISTLST.CID=:ttx.cid AND SLN=:TRNHSEQ AND HISTLST.ACT=DEP.CID AND DEP.GRP='ESC'")
	while rs.next() do { quit:ER
		type Number ACT, RSEQ

		set ACT = rs.getCol("ACT")
		set RSEQ = rs.getCol("RSEQ")
		type RecordHIST hist = Db.getRecord("HIST", "CID=:ACT,TSEQ=:RSEQ")
		type RecordTTX ttxesc = hist.copy("TIM=TIME,BRCDE=BRCD,UIDT=UID,LNERC=XHS16,CC=BEN")
			
		// Ensure we're using the correct dep object
		if 'dep.exists() ! (dep.exists() & (ACT '= dep.cid)) do {
			if dep(ACT).exists() set dep = dep(ACT)
			else  set dep = Db.getRecord("DEP", "CID=:ACT")
			}

		// Secondary escrow transaction		
		do CHKSTAT(.dep, .ttxesc, REV) quit:ER
		}

	// Primary transaction
	do CHKSTAT(.acn, .ttx, REV) quit:ER
	
	quit
	

CHKSTAT(RecordACN acn,		// Deposit / loan account		/REF:RW
        RecordTTX ttx,		// Deposit / loan transaction		/REF:R
        Boolean REV)		// Reversal indicator
        
        // Check this transaction to determine if the account status should 
        // change

	type public Cache %CACHE()
	type public RecordLN ln
	
	type Number CID

	// Quit if no transaction code defined
	if ttx.etc.isNull() quit
	
	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ttx.etc")
	
	// Quit if this is not a payoff / closeout transaction
	if 'trn.pcf.extract(5) quit
	
	set CID=ttx.cid

	// Escrow closeout transaction
	if trn.grp="ESC" do {

		type RecordDEP dep={RecordDEP}acn

		if REV do {
			// Reversal of escrow closeout status to "Active"
			do UPDSTAT(.dep,0,"")
			
			// Secondary escrow transactions have already been 
			// filed by TRNDRV, so must save now (not so for ln)
			do dep.bypassSave()

			// Status not "Account Closed"
			if ln.stat'=4 quit
			
			// Reverse loan status to "Zero Balance Loan with 
			// Escrow Balance" as part of escrow closeout reversal
			if $$IGNORE(dep.aref,dep.cid,dep.iwcp,acn.stat) do UPDSTAT(.ln,1,"")
			}
		else  do {
			// Escrow closeout status to "Account Closed"
			do UPDSTAT(.dep,4,%SystemDate)
			
			// Secondary escrow transactions have already been 
			// filed by TRNDRV, so must save now (not so for ln)
			do dep.bypassSave()
			
			// Status not "Zero Balance Loan with Escrow Balance"
			if ln.stat'=1 quit
		
			if '$$IGNORE(dep.aref,dep.cid,dep.iwcp,acn.stat) do {
				// Close loan as part of escrow closeout
				do UPDSTAT(.ln,4,%SystemDate)
				do AROD^LNPTS1
				}
			}
		}
		
	// Loan payoff transaction
	if trn.cls="L" do {
		if REV do {
			// Reverse loan status to "Active"
			do UPDSTAT(.acn,0,"")
			do RAROD^LNPTS1
			}
		else  do {
			if '$$IGNORE(acn.cid,"","","") do {
				// Loan status to "Account Closed"
				do UPDSTAT(.acn,4,%SystemDate)
				do AROD^LNPTS1
				}
			// Status to "Zero Balance Loan with Escrow Balance"
			else  do UPDSTAT(.acn,1,"")
			}
		}

	quit
	
	
UPDSTAT(RecordACN acn,			// Account			/REF:W
	Number STATUS,			// Account status
	Date DTC)			// Date account closed

	// Updates the status of an account when processing a payoff/closeout
	
	#IF CUVAR.PUBLISH
		type String PUBLISH(,,)
		set PUBLISH("ACN",acn.cid,"STAT")=acn.stat_"|"_STATUS
		do TRANDRV^UCSDRV(.PUBLISH)
	#ENDIF
	
	set acn.stat=STATUS
	set acn.dtc=DTC

	quit
	

IGNORE(Number LCID,		// Loan account number
       Number ESCCID,		// Escrow account number
       Boolean IWCP,		// Ignore when calc loan payoff indicator
       Number DEPSTAT)		// Deposit account status

	// Determine whether LN should be closed based on DEP.ICWP and DEP.STAT
	
	type Boolean IGNORE=0

	// Get all escrow accounts linked to this loan
	type DbSet ds=Db.selectDbSet("DEP","AREF=:LCID")
	while ds.next() do {  quit:IGNORE
		type RecordDEP dep=ds.getRecord("DEP")

		if ESCCID=dep.cid do { quit
			/*
			 Status already updated locally for this ESC account
			 so we don't want to fetch DEP.STAT from the DB as 
			 it will be incorrect
			*/
			if IWCP,DEPSTAT=4 set IGNORE=1
			if IWCP,DEPSTAT'=4 set IGNORE=0
			}

		if dep.iwcp,dep.stat=4 set IGNORE=1
		if dep.iwcp,dep.stat'=4 set IGNORE=0
		}

	quit IGNORE
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60583^53971^Pat Kelly^26943"	// Signature - LTD^TIME^USER^SIZE
