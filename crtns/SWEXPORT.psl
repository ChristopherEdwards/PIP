SWEXPORT	 /*
 
  ORIG: KELLYP - 12/10/1999
  DESC: SWIFT Message Export Procedure
  
  ---- Comments --------------------------------------------------------
  This procedure manages the extraction of multiple SWIFT messages to a 
   plain-text file.  Any SWIFT messages extracted from the SWIFTQ("RTT"
   global will be treated as if they had been sent via PROFILE's ST400
   interface, and will therefore be moved to the SWIFTQ("CMP" global
   if the message export was successful.
  ---- Revision History ------------------------------------------------

	08/02/06 - KELLYP - CR 22048
		Modified SCRN section to eliminate DYNAMIC warning.

	01/11/06 - ratht - CR 18292
		Modified section fmtMSG, to define variables msgbdy,fs1,fs5
		and added the check for 'msgbdy.exists(). Removed the 
		deprecated warning in the INIT section.
		   
	09/26/05 - KUMARB - CR 17050
		Modified section SCRN, of DRV^USID call to pass
		%ProcessMode and SID. 
	
	12/08/03 -SPIER 7403
		PSL compiler ewarning message cleanup
		
	01/14/03 - Spier - 51423
		Fixed errors reported by new compiler

  ----------------------------------------------------------------------

 */
 quit		// Dummy quit for the compiler

public PROC	// Main processing portion of this procedure

 new cs2,dup,expfile,fname,fs1,fs2,fs3,fs4,fs5,fs6,fs7,msgtot,openOK,QUEUE
 new REFNO,SID,spldir,STseqO,STsess,swiftmsg,TJD,TRANDT,TYP,%O

 // Initialize variables & SWIFT message delimiters
 do INIT
 for  do SCRN quit:$G(VFMQ)="Q"!('((TRANDT="")&(TYP="")&(REFNO'="")))

 quit


SCRN 
 // Load the SWEXPORT screen to get criteria for messages to export
 type String WHERE

 set SID="SWEXPORT",%ProcessMode=1
 do DRV^USID(%ProcessMode,SID)
 if VFMQ="Q" quit
 if (TRANDT="")&(TYP="")&(REFNO'="") set ER="W",RM=$$^MSG(3002) quit
 if (TRANDT="")&(TYP'="")&(REFNO="") set ER="W",RM=$$^MSG(4184) quit 

 // Dynamic rs based upon what the user entered
 set WHERE=""
 if (TRANDT'=""),(TYP=""),(REFNO="") do {
 	// This section builds a result set from the SWIFTQ("RTT" global based on date
 	set WHERE="QUE=:QUEUE AND DT=:TRANDT"
 	set fname=$$DAT^%ZM(TRANDT,"MMDDYY")_".TXT"
	}
 else  if (TRANDT'=""),(TYP'=""),(REFNO="") do {
 	// This section builds a result set from the SWIFTQ("RTT" global based on date
 	// and on SWIFT message type
 	set WHERE="QUE=:QUEUE AND DT=:TRANDT AND TYPE=:TYP"
 	set fname=$$DAT^%ZM(TRANDT,"MMDDYY")_"_MT"_TYP_".TXT"
	} 
 else  if (TRANDT=""),(TYP'=""),(REFNO'="") do {
 	// This section builds a result set from the SWIFTQ("RTT" global based on SWIFT
 	// message type and transaction reference number
	set WHERE="QUE=:QUEUE AND TYPE=:TYP AND TRREFNO=:REFNO"
 	set fname="MT"_TYP_"_"_REFNO_".TXT"
	}
	
 if WHERE="" set ER="W",RM=$$^MSG(4176) quit
 // Show error and quit if no messages match user-entered criteria
 #ACCEPT DATE=08/02/06;PGM=KELLYP;CR=18140
 type ResultSet rs=Db.select("QUE,DT,SEQ,TRREFNO,TYPE","SWIFTQ1",WHERE)
 if rs.isEmpty() set ER="W",RM=$$^MSG(4176) quit

 // Compose filename with path and create the file
 set expfile=$$FILE^%TRNLNM(fname,spldir)  // Create path & filename string
 set openOK=$$FILE^%ZOPEN(expfile,"WRITE/NEWV",10,10000)
 if $P(openOK,"|",1)=0 set ER="W",RM=$P(openOK,"|",2) quit 

 while rs.next() do {
    new DAT,EXPORT,SEQ,stat,toqueue,TRREFNO,MSG
        
    set DAT=rs.getCol(2)
    set SEQ=rs.getCol(3)
    set TRREFNO=rs.getCol(4)
    set MSG=rs.getCol(5)
	
    set swiftmsg=$$fmtMSG(TRREFNO,MSG)

    // If message generation was ok, move the queue entry from RTT to PRD    
    if swiftmsg'="" set toqueue="CMP"

    // Otherwise, move it from RTT to REP
    else  set toqueue="REP"	

    // Variables implicitly required by REQUE^SWIFTUTL
    set stat("RTT")=0              // Ready to transmit
    set stat("REP")=2              // Repair
    set stat("CMP")=3              // Completed

    set EXPORT=1		   // Var needed to skip a check in EFT filer
    set status=$$REQUE^SWIFTUTL(QUEUE,toqueue,"OUT",DAT,SEQ,TRREFNO,MSG) 

    // Don't include this message if queue movement was bad or if no fmt'd msg
    if (status)!(swiftmsg="") quit 
    
    do FILE^%ZUSE(expfile)	
    write swiftmsg_$C(13,10)
    use 0

    set msgtot=msgtot+1		// Increment message counter
 }

 close expfile			// Close file
 use 0				// Reset device to display

 // Return message indicating filename and total number of messages exported
 set ER="W",RM=$$^MSG(4175,msgtot,fname)

 quit


 //----------------------------------------------------------------------------
fmtMSG(TRREFNO,TYPE) 
 //----------------------------------------------------------------------------
 // This section turns a ^SWIFT message into a string and returns the message
 //  body portion of the formatted message.
 
 type public String msgbdy,fs1,fs5
 new swmsg

 if 'msgbdy.exists() set msgbdy=""
 if (TRREFNO="")!(TYPE="") quit ""

 set swmsg=$$MSGOUT^SWIFTFMT(TRREFNO,TYPE,dup) 

 if (swmsg="")!(msgbdy="") quit ""
 else  quit fs1_msgbdy_fs5

 quit ""	// Dummy quit for the compiler


INIT	// This section initializes various parameters used by this procedure

 set (REFNO,TRANDT,TYP)=""	// Initialize SWIFT vars
 set msgtot=0			// Initialize message counter

 type RecordCUVAR cuvar=Db.getRecord("CUVAR")
 set TJD=cuvar.tjd
 set spldir=cuvar.spldir
 
 set QUEUE="RTT"		// The SWIFTQ we'll be looking for new msg's in

 // Initialize delimters used in the exported message
 set fs1="{{*"			// Start of Message
 set fs2="{-"			// Start of Text Block
 set fs3="||" 			// Text Block Field Delimiter
 set cs2="|*|" 			// Text Block Sub-Field Delimiter
 set fs4="-}"			// End of Text Block
 set fs5="*}}"			// End of Message

 // The following fields are not used in the msg but are required by SWIFTFMT
 set dup=0
 set fs6=""
 set fs7=""
 set STsess=""
 set STseqO=""

 quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60479^60361^Pat Kelly^5576"	// Signature - LTD^TIME^USER^SIZE
