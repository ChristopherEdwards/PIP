BCHCOLEX //Batch BCHCOLEXTR - NCO - Daily Collections Extracts
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/30/2007 15:07 - joynerd
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHCOLEXTR Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 set vBCHSTS=$$STATUS^BCHUTL("BCHCOLEXTR")
 if vBCHSTS=1 set ER=1,RM=$$^MSG(3410) quit
 if vBCHSTS=2 set ER=1,RM=$$^MSG(3414) quit
 if vBCHSTS=0 set %BatchRestart=1
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit do EXIT^BCHUTL("BCHCOLEXTR") quit
 do JOBMGR^BCHUTL(%FN,"BCHCOLEXTR",.vINPUT)
 do ^JOBMGR(.vINPUT)
 do EXIT^BCHUTL("BCHCOLEXTR")
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(CID) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHCOLEXTR","*","",CID.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 if %BatchRestart,$$CHKLOG^BCHUTL(%SystemDate,%FN,"BCHCOLEXTR",CID.get()) do { quit
 do LOG^BCHUTL(%SystemDate,%FN,"BCHCOLEXTR",CID.get(),"Record already processed")
 }
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,CID)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHCOLEXTR","*","",CID.get(),"",et)
 }
 do UPDLOG^BCHUTL(%SystemDate,%FN,"BCHCOLEXTR",CID.get(),vCONTEXT)
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,CID) //
	/* Walton 08/2000

	   On a daily basis, an extract record of delinquent loan accounts
	   and negative balance deposit accounts is produced and sent to
           NCO.  Selection of accounts is based on a combination of
	   product types, collection status, and number of days delinquent
           (loans) and number of days with a negative balance (deposits).
      	   For each account selected predefined data from the account
	   is included in the extract record (see NCO Collection Extract
	   specification).

	   The record is written to a temporary table in the EXEC section,
	   then taken from this table and written to the extract within
	   the SCHEXIT section.  This section will also populate the
	   COLEXTR table to be used by the batch defintion BCHCOLXTRDTJ.
	   
	   When an account is no longer delinquent we must still summit
           the account one last time in the extract.  This is done for
	   reconciliation purposes.

	   NOTE - This batch is to be placed in the beginning of day 
	          immediately following the accrual process (QUE039).  It
		  will collate through ACN using the COLEXTRDYS index.

	   
	   Timeline of events -

		Feb 1.  EOD  account 123 becomes delinquent
		Feb 2.  BOD  BCHCOLEXTR files entry into COLEXTR
                             using Feb. 1 for account 123, is
			     included in Collections Extract
		        BOD  BCHCOLXTRDTJ looks in COLEXTR for
                             Jan. 31 (no information)
			EOD  account 456 becomes delinquent
		Feb 3.  BOD  BCHCOLEXTR files entry into COLEXTR
			     using Feb. 2 for account 456, is
			     included in Collections Extract
		        BOD  BCHCOLXTRDTJ looks in COLEXTR for
			     Feb. 1 (finds account 123), then selects
			     all records in DTJ for Feb. 2 and includes
			     them in Collections Transaction Extract
	*/

	new dflg,BAL,BAL1,BPH,BPHEXT,CLS,CRLMT,DAYSDELQ,DELDT,DFLG,DOLDEL
        new DOB,DIST1LD,DTC,DTLC,DUIN,EMAIL,GTDUE,HPH,IRN,ISDEL,LCHG,LPDT
	new LADT,MAD1,MAD2,MCITY,MF,MSTATE,MZIP,NSFCY,NSFPY,ODT,OWN,REC
	new REC1,REC2,RETCY,RETPY,RFLG,TAXID,TITLE1,TITLE2,TLD,TYPE,WRKDTE
	new XCLS,XNAME,XOPT

	if Db.isDefined("COLEXTR","XTJD2,CID") do {

		type RecordCOLEXTR colextr=Db.getRecord("COLEXTR","CTJD=:XTJD2,CID=:CID",1)
		set dflg=colextr.dflg
		}
				
	else  set dflg=""

	type RecordACN acn=Db.getRecord("ACN","CID")
	set XCLS=acn.cls
	if XCLS="D" do DEP(.acn)
	else  do LN(.acn)

	quit

DEP(RecordDEP dep)	// Deposit Information

	set ISDEL=$$DTEST(.dep)
	
	// not in COLEXTR, not delinquent
	if dflg.isNull(),'ISDEL quit	   
	
	// not in COLEXTR, is delinquent  
	if dflg.isNull(),ISDEL set DFLG=1  
	
	// no longer delinquent skip
	if dflg=0,'ISDEL quit 	     
	
	// back to delinquent
	if dflg=0,ISDEL set DFLG=1   
	
	// no longer delinquent but include
	if dflg,'ISDEL set DFLG=0    
	
	// still delinquent
	if dflg,ISDEL set DFLG=1     
    
	set TITLE1=$$BLK(dep.title1,40)
	set TITLE2=$$BLK(dep.title2,40)
	set BAL=$$ZERO(dep.bal,15)
	set DELDT=$$BLK($$DAT(dep.deldt),10)
	set BAL1=$$ZERO((dep.bal*-1),15)
	set WRKDTE=$$BLK($$DAT(dep.wrkdte),10)
	set CLS=$$BLK(XCLS,1)
	set TYPE=$$ZERO(dep.type,4)
	set ODT=$$BLK($$DAT(dep.odt),10) 
	set DTC=$$BLK($$DAT(dep.dtc),10)
	set IRN=$$ZERO(dep.irn,8)
	set TLD=$$BLK($$DAT(dep.tld),10)
	set DTLC=$$BLK($$DAT(dep.dtlc),10)

	set NSFPY=dep.nsfo1+dep.nsfo2+dep.nsfo3+dep.nsfo4+dep.nsfo5+dep.nsfo6
	set NSFPY=NSFPY+dep.nsfo7+dep.nsfo8+dep.nsfo9+dep.nsfo10+dep.nsfo11
	set NSFPY=NSFPY+dep.nsfo12
	set NSFPY=$$ZERO(NSFPY,3)

	set NSFCY=dep.nsfo13+dep.nsfo14+dep.nsfo15+dep.nsfo16+dep.nsfo17+dep.nsfo18
        set NSFCY=NSFCY+dep.nsfo19+dep.nsfo20+dep.nsfo21+dep.nsfo22+dep.nsfo23
        set NSFCY=NSFCY+dep.nsfo24
	set NSFCY=$$ZERO(NSFCY,3)

	set RETPY=dep.reti1+dep.reti2+dep.reti3+dep.reti4+dep.reti5+dep.reti6
        set RETPY=RETPY+dep.reti7+dep.reti8+dep.reti9+dep.reti10+dep.reti11
        set RETPY=RETPY+dep.reti12
	set RETPY=$$ZERO(RETPY,3)

	set RETCY=dep.reti13+dep.reti14+dep.reti15+dep.reti16+dep.reti17+dep.reti18
        set RETCY=RETCY+dep.reti19+dep.reti20+dep.reti21+dep.reti22+dep.reti23
        set RETCY=RETCY+dep.reti24
	set RETCY=$$ZERO(RETCY,3)        

	do CIF(dep.acn)
	do RFLG(dep.acn)	

	set CID=$$ZERO(CID,12)

	set REC=CID_TAXID_TITLE1_TITLE2_MAD1_MAD2_MCITY_MSTATE_MZIP_EMAIL
	set REC=REC_HPH_BPH_BPHEXT_BAL_DELDT_BAL_BAL1_WRKDTE
	set REC=REC_CLS_TYPE_ODT_DTC_OWN_MF_RFLG_DOB_XNAME_IRN
	set REC=REC_TLD_DTLC_NSFPY_NSFCY_RETPY_RETCY
	set REC=$$BLK(111_REC,598)

	do FILE(REC,DFLG,TYPE)
	quit


LN(RecordLN ln)	// Loan Information

	set ISDEL=$$LTEST(.ln)
	
	// not in COLEXTR, not delinquent
        if dflg.isNull(),'ISDEL quit        
        
        // not in COLEXTR, is delinquent
        if dflg.isNull(),ISDEL set DFLG=1   
        
        // no longer delinquent skip
        if dflg=0,'ISDEL quit         
        
        // back to delinquent
        if dflg=0,ISDEL set DFLG=1    
        
        // no longer delinquent but include
        if dflg,'ISDEL set DFLG=0     
        
        // still delinquent
        if dflg,ISDEL set DFLG=1      

	set TITLE1=$$BLK(ln.title1,40)
	set TITLE2=$$BLK(ln.title2,40)
	set BAL=$$ZERO(ln.bal,15)
	set CRLMT=$$ZERO(ln.crlmt,15)
	set DAYSDELQ=$$ZERO(ln.daysdelq,12)
	
	// changed to TDUE
	set DOLDEL=$$ZERO(ln.tdue,12)	
	
	set GTDUE=$$ZERO(ln.gtdue,12)
	set LPDT=$$BLK($$DAT(ln.lpdt),10)
	set LADT=$$BLK($$DAT(ln.ladt),10)
	set WRKDTE=$$BLK($$DAT(ln.wrkdte),10)
	set CLS=$$BLK(XCLS,1)
	set TYPE=$$ZERO(ln.type,4)
	set ODT=$$BLK($$DAT(ln.odt),10)
	set DTC=$$BLK($$DAT(ln.dtc),10)
	set DIST1LD=$$BLK($$DAT(ln.dist1ld),10)
	set IRN=$$ZERO(ln.irn,8)
	set DUIN=$$ZERO(ln.duin,12)
	set LCHG=$$ZERO(ln.lchg,12)

	do CIF(ln.acn)
	do RFLG(ln.acn)

	set CID=$$ZERO(CID,12)

	set REC=CID_TAXID_TITLE1_TITLE2_MAD1_MAD2_MCITY_MSTATE_MZIP_EMAIL
	set REC=REC_HPH_BPH_BPHEXT_BAL_CRLMT_DAYSDELQ_DOLDEL_GTDUE_LPDT
	set REC=REC_LADT_WRKDTE_CLS_TYPE_ODT_DTC_OWN_MF_RFLG_DOB_DIST1LD
	set REC=REC_XNAME_IRN_DUIN_LCHG
	set REC=$$BLK(222_REC,598)

	do FILE(REC,DFLG,TYPE)
	quit


FILE(REC,dflg,TYPE)	// File record to temporary table TMPNCO

	/* The record is broken into 2 sections and written to a temporary
	   table denoted by sequence number.  This is done to keep record
	   size below the 512 requirement incase the TMP region under GTM
	   has not been increased. 
	*/

	set REC1=REC.extract(1,300)
        set REC2=REC.extract(301,REC.length())

	type RecordTMPNCO tmp()
        set tmp(1)=Class.new("RecordTMPNCO")
        set tmp(2)=Class.new("RecordTMPNCO")

	set tmp(1).cid=+CID
	set tmp(1).seq=1
	set tmp(1).record=REC1
	set tmp(1).dflg=dflg
	
	// remove comma
	set tmp(1).type=TYPE.piece(",",1) 		

	set tmp(2).cid=+CID
	set tmp(2).seq=2
	set tmp(2).record=REC2

	do tmp(1).bypassSave()
	do tmp(2).bypassSave()

	quit

	
CIF(XACN)	//  Customer Information

	type RecordCIF cif=Db.getRecord("CIF","XACN")
 
        set TAXID=$$BLK(cif.taxid,30)
        set MAD1=$$BLK(cif.mad1,40)
        set MAD2=$$BLK(cif.mad2,40)
        set MCITY=$$BLK(cif.mcity,40)
        set MSTATE=$$BLK(cif.mstate,2)
        set MZIP=$$BLK(cif.mzip,10)
        set EMAIL=$$BLK(cif.email,55)
	set HPH=$$BLK($TR(cif.hph,"-",""),12)
	set BPH=$$BLK($TR(cif.bph,"-",""),12)
	set BPHEXT=$$ZERO(cif.bphext,4)
	set OWN=$$BLK(cif.own,1)
        set MF=$$ZERO(cif.mf,1)
        set DOB=$$BLK($$DAT(cif.dob),10)
        set XNAME=$$BLK(cif.xname,40)

	quit

RFLG(XCID)	// Restriction Information

	set RFLG=""
	type ResultSet rs=Db.select("RFLG","RFLG","CID=:XCID AND EXDT>:XTJD1")
	if rs.isEmpty() set RFLG=$$BLK("",40) quit
	while rs.next() set RFLG=RFLG_rs.getCol(1)_"-"

	set RFLG=RFLG.piece("-",1,RFLG.length("-")-1)
	set RFLG=$$BLK(RFLG,40)

	quit
  
DTEST(RecordDEP dep)	// Deposit account selection criteria

	type public Number XOPT
	type Boolean FLAG

	if dep.bal>0 quit 0
        if (dep.bal*-1)<dep.colexthrsh quit 0
        if dep.stat=4 quit 0
        if (dep.deldt).isNull() quit 0
        if %SystemDate-dep.deldt<dep.colextrdys quit 0
        
	set FLAG=0

        set XOPT=dep.collst

	if 'XOPT.isNull() do {

	        type RecordUTBLCOLLST utblcollst=Db.getRecord("UTBLCOLLST","OPT=:XOPT",1)
        
        	if utblcollst.getMode() do {
	   		if +utblcollst.colextrflg=0 set FLAG=1
	        	}
		}

	if FLAG quit 0

        quit 1

LTEST(RecordLN ln)	// Loan account selection criteria

	new COEDATA,XRSNAR,XRSNS,XTHRSH,XTYPE				

	type public Number XOPT
	type Boolean FLAG
	
        if ln.stat=4 quit 0
        if ln.daysdelq.isNull() quit 0
        if ln.daysdelq<ln.colextrdys quit 0

	set FLAG=0

        set XOPT=ln.collst
	
	if 'XOPT.isNull() do {
	
 	       type RecordUTBLCOLLST utblcollst=Db.getRecord("UTBLCOLLST","OPT=:XOPT",1)
        
        	if utblcollst.getMode() do {
        		if +utblcollst.colextrflg=0 set FLAG=1
        		}
		}

        if FLAG quit 0	

        if +ln.gtdue=0 quit 0
        if ln.gtdue<ln.colexthrsh quit 0
	if ln.rec>0 quit 0
	set XTYPE=ln.type

	set COEDATA=""

	type RecordUTBLCOERSN utblcoersn=Db.getRecord("UTBLCOERSN","TYPE=:XTYPE",1)
	if utblcoersn.getMode() set COEDATA=utblcoersn.thrsh_"|"_utblcoersn.rsns
			
	if COEDATA.isNull() quit 1
	set XTHRSH=+COEDATA.piece("|",1)
	set XRSNAR=COEDATA.piece("|",2)
	if 'XRSNAR.isNull() for i=1:1 set XRSNS(XRSNAR.piece(",",i))="" quit:(XRSNAR.piece(",",i+1)).isNull()
	if (XRSNS($$CORES(ln.dlco), ln.cid).exists())&(('XTHRSH)!(+ln.coa>XTHRSH)) quit 1
	quit 0

CORES(Date XDLCO, Number CID)	// History search for charge off reason code

	type Number RSN = 0

	type ResultSet rs = Db.select("TSO", "HIST", "CID=:CID AND TJD=:XDLCO AND ETC='RCHP'", "TSEQ DESC")

	if rs.next() set RSN = $$FIELD^UTSO(rs.getCol("TSO"), "CORES")
	
	quit RSN

			
BLK(VAL,N)      //
 
        if VAL.length()>N quit VAL.extract(1,N)
        quit VAL_$J(" ",N).extract(1,N-VAL.length())

ZERO(VAL,N)     //
 
        set X=""
        set X.piece(0,N-VAL.length())=0
        quit X_VAL

DAT(val)        //
 
        quit val.toString("MM/DD/YEAR")

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
 type String vRECORD,CID
 for  set vRECORD=vINPUT.piece("|",1),vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD.isNull()  do {
 set CID=vRECORD.piece($C(9),1)
 do vPROC(CID)
 }
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
 type public String vBUFOVFL
 type String vRECORD,vrow,CID
 type Number vcur,vlen
 set vINPUT=vBUFOVFL.get()
 set vBUFOVFL="",vlen=0
 type public ResultSet vRESULT
 for  do { quit:'vcur
 set vcur=vRESULT.next() if 'vcur quit
 set vrow=vRESULT.getRow()_"|",vlen=vlen+vrow.length()
 if vlen>32000 set vBUFOVFL=vrow,vcur=0 quit
 set vINPUT=vINPUT_vrow if vlen+13>32000 set vcur=0 quit
 }
 set vINPUT=vINPUT.extract(1,vINPUT.length()-1)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	// create blank file incase there are no records

	new CO,DATE,HEADER,TRAILER

	type IO io()
	
	set DATE=%CurrentDate.toString("MMDDYEAR")
	
	set CO=CUVAR.co

	set io(1)=Class.new("IO")
	set io(2)=Class.new("IO")
	set io(1).fileName="NCOD_"_CO_"_"_DATE_".EXT"
	set io(2).fileName="NCOL_"_CO_"_"_DATE_".EXT"
        set io(1).openParams="/WRITE/NEWV"
	set io(2).openParams="/WRITE/NEWV"
	set io(1).recordSize=600
	set io(2).recordSize=600

	do io(1).open()
	do io(2).open()

	set HEADER=$$BLK("000NCO"_$$BLK(CO,8)_DATE,598)
        do io(1).write(.HEADER)
	do io(2).write(.HEADER)

	set TRAILER=$$BLK(999,598)
	do io(1).write(.TRAILER)
	do io(2).write(.TRAILER)

	do io(1).close()
	do io(2).close()

 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("CID","ACN","COLEXTRDYS>0")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	set XTJD1=%SystemDate-1
	set XTJD2=%SystemDate-2

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
	// write records stored in TMPNCO to extract file
	
	new t,type,CNT,CO,DATA,DATE,DFLG,HEADER,REC,REC1,REC2,TRAILER
	new TYPE,XCID,XCLS,XS1,XS2
 
	set (TDEP,TLN)=0

	set DATE=%CurrentDate.toString("MMDDYEAR")
	set CO=CUVAR.co
        set XS1=1
        set XS2=2
 
        type IO io()
	set io(1)=Class.new("IO")
	set io(2)=Class.new("IO")

	type RecordCOLEXTR ext=Class.new("RecordCOLEXTR")
 
        set io(1).fileName="NCOD_"_CO_"_"_DATE_".EXT"
	set io(2).fileName="NCOL_"_CO_"_"_DATE_".EXT"
        set io(1).openParams="/WRITE/NEWV"
	set io(2).openParams="/WRITE/NEWV"
	set io(1).recordSize=600
	set io(2).recordSize=600
 
        do io(1).open()
	do io(2).open()

	set CO=CUVAR.co
	set HEADER=$$BLK("000NCO"_$$BLK(CO,8)_DATE,598)
	do io(1).write(.HEADER)
	do io(2).write(.HEADER)

	type ResultSet rs1=Db.select("CID,RECORD,DFLG,TYPE","TMPNCO","SEQ=:XS1")
        if 'rs1.isEmpty() while rs1.next() do {
 
                set XCID=rs1.getCol(1)
		set REC1=rs1.getCol(2)
		set DFLG=rs1.getCol(3)
		set TYPE=rs1.getCol(4)
                
                type RecordTMPNCO tmpnco=Db.getRecord("TMPNCO","CID=:XCID,SEQ=:XS2")
 		set REC2=tmpnco.record
 
                set REC=REC1_REC2
 
		if REC.extract(1,3)=111 do io(1).write(.REC) set TDEP=TDEP+1
                else  do io(2).write(.REC) set TLN=TLN+1

		set ext.ctjd=%SystemDate-1
		set ext.cid=XCID
		set ext.dflg=DFLG

		do ext.bypassSave()
		}
 

	set DTRAIL=$$BLK(TDEP,12)
	set DTRAIL=$$BLK(999_TDEP,598)	
	do io(1).write(.DTRAIL)
        do io(1).close()
     
	set LTRAIL=$$BLK(TLN,12)
        set LTRAIL=$$BLK(999_TLN,598)
        do io(2).write(.LTRAIL)
        do io(2).close()

        do Db.fastDelete("TMPNCO")
 
        quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
