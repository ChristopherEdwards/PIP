ZUCT()	// PSL Test Set, main module (calls all)
  /*
  ORIG: Frans S.C. Witte; 2004-09-01
  DESC: PSL Test set, main module

  The PSL test set
  ================
  The ZUCT* procedures constitute the PSL Compiler Validation Suite.
  The suite is maintained using CR22843 in StarTeam view Profile04.
  This CR shall never be marked "fixed". Its only purpose is to provide a
  container for the maintenance and internal distribution of the validation
  suite. The validation suite shall be distributed in every Framework ut
  environment, using the standard TBXFPIN process.
  
  To validate the compiler, look at
  - the target code produced from the ZUCT* procedures
  - the output produced by the ZUCT* routines
  
  To run the entire validation suite enter
  	DO ^ZUCT()
  at the GT.M command prompt. Individual parts of the compiler can be validated
  by invoking one of the public entry points winthin the individual ZUCTxyz
  routine.

  Notes on the PSL test set
  =========================
  To systematically validate the code generated by the PSL compiler, the test
  set must take into account the compile time optimizations that influence what
  code gets generated. In the most general case, the following patterns for
  primitive instances and method parameters are distinguished:
  A - Absent parameter (does not apply to primitive instance).
	Trailing parameters are usually not included. Absent parameters in other
	places are the result of two adjacent parameter delimiters (",,", "(,"
	or ",)")
  N - Null parameter or primitive instance at compile time
	Null in this context means the empty string. In some methods the implied
	value of an Absent parameter is Null, but there are sufficient
	exceptions to treat these cases separately.
  E - Empty string parameter value or primitive instance value at runtime
	The behavior of the code generated in these cases shall be the same as
	for Null parameters and primitive instances.
  L - Literal parameter value or primitive instance value at compile time
	This may influece the kind of code that is generated. E.g. if the value
	of a Boolean parameter can be detected at compile time, only the code
	for the matching value will be included.
	If all parameters, and the primitive instance value are Literal, then
	the method can be applied at compile time, and the resulting value can
	be inserted directly in the code.
  V - Variable parameter value or primitive instance at compile time
	In this case, the compiler cannot perform compile time optimizations.
	Again, the behavior of the code generated in these cases shall be the
	same as for Literal parameters and primitive instances.

  Given the above 5 patterns, the number of potentially different test patterns
  for a method with NP parameters can be determined as follows:
  * For classes with $$primVar^UCPRIM()=1 (i.e. classes that are implemented as
    primitives) the number equals 4 * (5 ** NP)
  * For other classes the "primitive instance value" is irrelevant, which
    reduces the number to 5 ** NP
  * If the definition of the method in OBJECTMET specifies that a parameter is
    'literal', the number of testpatters for this parameter reduces to 4,
    because Empty and Variable can be tested in one scenario, and shall result
    in a compile time error.

  When writing a test procedure, the cases A, N, and L for a single parameter
  (the Compile time values) can be combined is a single procedure . The
  testcases shall include both valid and invalid values of the parameter.
  Similarly, the cases E and V (the Run time values) can be combined in a single
  test procedure. A procedure to test such behavior shall have formal parameters
  for each variable parameter (or privimitive instance) that it tests. The
  procedure shall be called with both valid and invalid values.
  For each method a single procedure shall be written that calls the procedures
  that test a specific combination.
  By combining testcases according to this classification, the number of test
  procedures for a method is 1 + 2 ** (NP + 1) for methods of primitive
  instances, and 1 + 2 ** NP for methods of other classes.

  Taking the method String.extract( Number first, Number last) as an example
  this yields (Cn = Compile time value, Rn = Runtime time value):
  * public extr()	    // test String.extract( Number first, Number last)
  * public extr0()	    // test C0.extract(C1,C2)
  * public extr1(R0)	    // test R0.extract(C1,C2)
  * public extr2(R1)	    // test C0.extract(R1,C2)
  * public extr3(R2)	    // test C0.extract(C1,R2)
  * public extr4(R0,R1)	    // test R0.extract(R1,C2)
  * public extr5(R0,R2)	    // test R0.extract(C1,R2)
  * public extr6(R1,R2)	    // test C0.extract(R1,R2)
  * public extr7(R0,R1,R2)  // test R0.extract(R1,R2)

  C0 and R0 take the values "", validValue, invalidValue
  Cn and Rn, for n>0 take the values absent, "", validValue and invalidValue

  Test function signatures
  ========================
  To speed up the implementation of test functions, and to encourage a single
  and consistent pattern, the following test function signatures have been
  developed:
  * ZUCTZ0P - procedure with test signatures for method without parameters
  * ZUCTZ1P - procedure with test signatures for method with 1 parameter
  * ZUCTZ2P - procedure with test signatures for method with 2 parameters
  * ZUCTZ3P - procedure with test signatures for method with 3 parameters
  * ZUCTZ4P - procedure with test signatures for method with 4 parameters

  All functions follow the same pattern. A series of global replacements will
  usually be sufficient to generate a standard set of validations. Specific
  examples can be added easily. See ZUCT2P for an explanation of the signatures,
  and how to use them.
 
  Additional test sets for RecordXXX classes
  ==========================================
  For descendents of the Record class, additional test rules are needed. The PSL
  compiler generates code that depends on the record type (1, 10, 11), and on
  instance scope (NEW, FORMAL but local, FORMAL and public).
  The resulting code may also depend on other properties of the table (e.g. does
  the table have a filer routine), or compile time options (e.g. #OPTIMIZE,
  Record.setAuditFlag()).
  The test set shall include code with records from tables of all three record
  types. For record types 10 and 11 separate testcases shall be included for the
  following cases:
  * only columns from the "top" node are accessed (case T, type 11 only)
  * only columns from a single "descendent" node are accessed (case D)
  * columns from multiple nodes including the "top" node are accessed (case TD,
    type 11 only)
  * columns from multiple nodes excluding the "top" node are accessed (case DD)
  
  Taking the method Record.compare( Record to) as an example this yields
  (Nn = scope NEW, Ln = scope FORMAL + local, Pn = scope FORMAL + public):
  * public comp()		// test Record.compare( Record to)

  * comp01()		 	// test N0.compare(N1) for record type 1
  * comp00D()			// test N0.compare(N1) for record type 10, case D
  * comp00DD()			// test N0.compare(N1) for record type 10, case DD
  * comp01D()			// test N0.compare(N1) for record type 11, case D
  * comp01DD()			// test N0.compare(N1) for record type 11, case DD
  * comp01T()			// test N0.compare(N1) for record type 11, case T
  * comp01TD()			// test N0.compare(N1) for record type 11, case TD

  * comp11(L0)			// test L0.compare(N1) for record type 1
  * comp10D(L0)			// test L0.compare(N1) for record type 10, case D
  * comp10DD(L0)		// test L0.compare(N1) for record type 10, case DD
  * comp11D(L0)			// test L0.compare(N1) for record type 11, case D
  * comp11DD(L0)		// test L0.compare(N1) for record type 11, case DD
  * comp11T(L0)			// test L0.compare(N1) for record type 11, case T
  * comp11TD(L0)		// test L0.compare(N1) for record type 11, case TD

  * public comp21(P0)		// test P0.compare(N1) for record type 1
  * public comp20D(P0)		// test P0.compare(N1) for record type 10, case D
  * public comp20DD(P0)		// test P0.compare(N1) for record type 10, case DD
  * public comp21D(P0)		// test P0.compare(N1) for record type 11, case D
  * public comp21DD(P0)		// test P0.compare(N1) for record type 11, case DD
  * public comp21T(P0)		// test P0.compare(N1) for record type 11, case T
  * public comp21TD(P0)		// test P0.compare(N1) for record type 11, case TD

  * comp31(L1)		 	// test N0.compare(L1) for record type 1
  * comp30D(L1)			// test N0.compare(L1) for record type 10, case D
  * comp30DD(L1)		// test N0.compare(L1) for record type 10, case DD
  * comp31D(L1)			// test N0.compare(L1) for record type 11, case D
  * comp31DD(L1)		// test N0.compare(L1) for record type 11, case DD
  * comp31T(L1)			// test N0.compare(L1) for record type 11, case T
  * comp31TD(L1)		// test N0.compare(L1) for record type 11, case TD

  * comp41(L0,L1)		// test L0.compare(L1) for record type 1
  * comp40D(L0,L1)		// test L0.compare(L1) for record type 10, case D
  * comp40DD(L0,L1)		// test L0.compare(L1) for record type 10, case DD
  * comp41D(L0,L1)		// test L0.compare(L1) for record type 11, case D
  * comp41DD(L0,L1)		// test L0.compare(L1) for record type 11, case DD
  * comp41T(L0,L1)		// test L0.compare(L1) for record type 11, case T
  * comp41TD(L0,L1)		// test L0.compare(L1) for record type 11, case TD

  * public comp51(P0,P1)	// test P0.compare(P1) for record type 1
  * public comp50D(P0,P1)	// test P0.compare(P1) for record type 10, case D
  * public comp50DD(P0,P1)	// test P0.compare(P1) for record type 10, case DD
  * public comp51D(P0,P1)	// test P0.compare(P1) for record type 11, case D
  * public comp51DD(P0,P1)	// test P0.compare(P1) for record type 11, case DD
  * public comp51T(P0,P1)	// test P0.compare(P1) for record type 11, case T
  * public comp51TD(P0,P1)	// test P0.compare(P1) for record type 11, case TD

  Other notes
  ===========
  The above set of test rules is largely based on the behavior of the PSL
  compiler itself. If significant changes are made to the compiler e.g. new
  types of optimzations, then the test rules must be updated accordingly to
  ensure that all possible code generating patterns have been covered.
  
  Labels Generated by PSL Class Methods
  =====================================
  The code generated by PSL class methods frequently results in labels within
  the generated routine. All labels generated by the compiler start with a
  lowercase 'v', followed by a class specific prefix (CPX), followed by a method
  specific abbreviation.
  For most of the primitive classes, a single subroutine is sufficient for all
  invocations of the method. In this case, the class specific prefix can be 3
  characters long. This leaves 4 characters for method specific abbreviations.
  On the other hand, most database oriented methods, each method invocation may
  require a separate subroutine. For example each Db.getRecord("TABLE",,new)
  will need its own subroutine. In this case, the class specific prefix shall be
  restricted to 2 characters. By restricting the method specific abbreviation to
  3 characters, 2 positions are left to differentiate within a routine.
  
  PSL Test Set Unit Naming Conventions
  ====================================
  The general prefix ZUCT will be used for all units that are part of the PSL
  Test Set. Because multiple units may be needed for a single class, and given
  the GT.M limitation of 8 characters per routine name, the name of the class
  will be coded in at most 3 characters, and the last character will be reserved
  for a single digit extension in case more than one unit is needed.
  
  Furthermore, for some of the CRs that present major compiler changes special
  validation units have been developed that may be useful for validation of
  future changes as well. These test units will also be included as part of the
  suite.
  This leads to the following set of names (not showing the final digit):
  
  Routinename	CPX	Classname
  ZUCTACN		RecordACN
  ZUCTBLB	Blb	Blob
  ZUCTBOO	Boo	Boolean
  ZUCTBTS	Bts	ByteString
  ZUCTCA	Ca	Cache
  ZUCTCIF		RecordCIF
  ZUCTCLM		SchemaColumn
  ZUCTCLS	Cl	Class
  ZUCTCOL	Co	Column
  ZUCTDAT	Dat	Date
  ZUCTDB	Db	Db
  ZUCTDBS	Ds	DbSet
  ZUCTDEP		RecordDEP
  ZUCTERR	Er	Error
  ZUCTHTM	Hm	HTML
  ZUCTIO	Io	IO
  ZUCTLN		RecordLN
  ZUCTLST	Lst	List
  ZUCTMEM	Mem	Memo
  ZUCTNUM	Num	Number
  ZUCTOBJ	Obj	Object	
  ZUCTP			PSL
  ZUCTPB		PSLBuffer
  ZUCTPC		PSLColumn
  ZUCTPEX		PSLExpression
  ZUCTPID		PSLIdentifier
  ZUCTPLR		PSLLabelRecord
  ZUCTPRC		PSLRecordMap (obsolete!)
  ZUCTPRM	Prm	Primitive
  ZUCTPSR		PSLSubrou
  ZUCTPT		PSLTable
  ZUCTREC	Re	Record
  ZUCTREF	Ref	Reference
  ZUCTROW	Row	Row
  ZUCTRS	Rs	ResultSet
  ZUCTRUN	Run	Runtime
  ZUCTRWS	Rws	RowSet
  ZUCTSTR	Str	String
  ZUCTTBL		SchemaTable
  ZUCTTIM	Tim	Time
  ZUCTTS	TSt	TranSet
  ZUCTXDD		PSLColumn, PSLTable, column indirection, et al.
  ZUCTXDDn		(n=0-9) hard-coded testcases for database access
  ZUCTXDDx		(x=A-Z) standard test cases for database access methods
 
  ZUCT7ccc		ccc = base 36 encoded CR number
  ZUCTZ*		special use (see also Test Function Signatures)

  ---------- Revision History --------------------------------------------------
  2006-10-20 Frans S.C. Witte - CR 22843
  	Added description ZUCT7* and functions $$b36dec() and $$b36enc()

  2006-10-16 Frans S.C. Witte - CR 22843
  	Added call to ^ZUCTCA()

  2006-08-29 Frans S.C. Witte - CR 22843
  	Added call to ^ZUCTBTS()

  2006-04-07 Frans S.C. Witte
  	Added call to ^ZUCTXDD()

  2005-05-03 Frans S.C. Witte
  	Added call to ^ZUCTLST().

  2005-04-12 Frans S.C. Witte
  	Added routinename - classname mapping.
  	Added call to ^ZUCTCLS() and ^ZUCTDAT().

  2004-09-01 Frans S.C. Witte
  	Original procedure.
  */
	write !,"======== test class ByteString ========",! do ^ZUCTBTS()
	write !,"======== test class Cache ========",!      do ^ZUCTCA()
	write !,"======== test class Class ========",!      do ^ZUCTCLS()
	write !,"======== test class Date ========",!       do ^ZUCTDAT()
	write !,"======== test class List ========",!       do ^ZUCTLST()

	write !,"======== test database access code ========",! do ^ZUCTXDD()
	quit

	// =====================================================================
public b36dec( String sB36val) // Name of procedure or base 36 number
	/* ---------------------------------------------------------------------
	This function accepts either the name of a procedure (6 or more
	characters), or a base 36 encoded number of up to 5 characters.

	If 6 or more characters are supplied, the value is treated as the name
	of a procedure, and the first 5 characters are treated as the prefix and
	stripped before decoding the value.

	Because all characters following the prefix will be interpreted, there
	is no limit on the maximum CR number that can be decoded. However, CR
	numbers that require more than 5 characters must be passed in using the
	procedure name syntax (e.g. by prepending 5 spaces).
	
	OUTPUTS:
	. the CR number as encoded in the value
	*/

	type Number nCr=0, nP

	if sB36val.isNull() quit ""
	if sB36val.length() > 5 set sB36val = sB36val.extract( 6, sB36val.length())

	for nP=1:1:sB36val.length() set nCr=(nCr*36) + "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".find( sB36val.extract( nP)) - 2

	quit nCr

	// =====================================================================
public b36enc( Number nCr) // CR number to encode
	/* ---------------------------------------------------------------------
	This function returns an encoded CR number.
	The CR number is coded as a "base 36 number", using the 36 characters
	that are allowed in M names (uppercase + digits). This leads to the
	following representation:
	0= 0, 1= 1, 2= 2, 3= 3, 4= 4, 5= 5, 6= 6, 7= 7, 8= 8, 9= 9
	A=10, B=11, C=12, D=13, E=14, F=15, G=16, H=17, I=18, J=19
	K=20, L=21, M=22, N=23, O=24, P=25, Q=26, R=27, S=28, T=29
	U=30, V=31, W=32, X=33, Y=34, Z=35

	With the above algorithm, the maximum CR number that can be coded into a
	routine beginning with 'ZUCT7' depends exclusively on the maximum number
	of characters in a routine name according to the formula
	MAXCR = (36 ** (MAXNAME-5)) - 1.
	The name length limit of GT.M up to V4.4 supports CR numbers 0 - 46655.
	*/
	set nCr = nCr\1

	if nCr < 0 quit ""
	if nCr < 10 quit nCr

	type String sB36val = ""

	while (nCr'=0)  set sB36val = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".extract((nCr#36)+1)_sB36val,nCr=nCr\36
	
	quit sB36val
 #OPTION ResultClass ON
Public String vSIG()	quit "60653^26268^Frans S.C. Witte^16082"	// Signature - LTD^TIME^USER^SIZE
