BCHLNLS //Batch BCHLNLS8 - Calculate Loan Sale Remittance Values
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 12:46 - shetyes
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHLNLS8 Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 set vBCHSTS=$$STATUS^BCHUTL("BCHLNLS8")
 if vBCHSTS=1 set ER=1,RM=$$^MSG(3410) quit
 if vBCHSTS=2 set ER=1,RM=$$^MSG(3414) quit
 if vBCHSTS=0 set %BatchRestart=1
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit do EXIT^BCHUTL("BCHLNLS8") quit
 do JOBMGR^BCHUTL(%FN,"BCHLNLS8",.vINPUT)
 do ^JOBMGR(.vINPUT)
 do EXIT^BCHUTL("BCHLNLS8")
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(INCD,PL) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHLNLS8","*","",INCD.get()_","_PL.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 if %BatchRestart,$$CHKLOG^BCHUTL(%SystemDate,%FN,"BCHLNLS8",INCD.get()_","_PL.get()) do { quit
 do LOG^BCHUTL(%SystemDate,%FN,"BCHLNLS8",INCD.get()_","_PL.get(),"Record already processed")
 }
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,INCD,PL)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHLNLS8","*","",INCD.get()_","_PL.get(),"",et)
 }
 do UPDLOG^BCHUTL(%SystemDate,%FN,"BCHLNLS8",INCD.get()_","_PL.get(),vCONTEXT)
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,INCD,PL) //
	type public Boolean ER
	type public String RM

	type Number CID,GRP,JOB

	type RecordLNLS2 lnls2 = Db.getRecord("LNLS2","INCD=:INCD,PL=:PL")

	set %EffectiveDate = %SystemDate - 1
	set JOB = %ProcessID

	// Get all sold loans for this pool
	type DbSet ds = Db.selectDbSet("LNLS8","INCD=:lnls2.incd AND PL=:lnls2.pl","INCD,PL,GRP,CID")
	while ds.next() do {
	
		type RecordLNLS8 lnls8 = ds.getRecord("LNLS8")
		
		set INCD = lnls8.incd
		set PL = lnls8.pl
		set GRP = lnls8.grp
		set CID = lnls8.cid
		
		// Process each account
		do EXEC(.lnls2,.lnls8)
		}

	// After processing all accounts in the pool, update
	// the remittance next date at the pool level.
	
	type Date NJD
	
	set NJD = lnls2.remnd
	for  set NJD = NJD.nextFreqDate(lnls2.remfre) quit:(NJD>%EffectiveDate)  if ER do { quit
		do EXC set RM="" set ER=0
		}
	
	do lnls2.setAuditFlag(1)
	
	set lnls2.premld=lnls2.remld
       	set lnls2.remld=%EffectiveDate
	set lnls2.remnd=NJD
	
       	do lnls2.save()
	
	quit


EXEC(RecordLNLS2 lnls2, RecordLNLS8 lnls8)	// Single account processing

	type public Cache %CACHE()

	new ACCD,ACDT,BALCMP,CRCD,CUIN,DIST1AF,DIST1LD,FORINT,FRE,INACTRMT,IRN
	new MAXYLD,MINYLD,MONDELQ,OPTR,PASSTHRU,PLRAP,PLRCD,PLRFC,PLRIC,PLRIR
	new PLROC,PLRPB,PLRPC,PLRPR,PLRRL,PLRRP,PLRSB,PLRSC,PMTPI,POAMT,POF
	new PORIC,PRNDF,PRNDM,REMND,SCHBAL,SDAT,SFCM,STAT,TRATE,TREXD,X
	new %PCM,%ICM

	type RecordLNLS1 lnls1=Db.getRecord("LNLS1","INCD")
	set GRPCTRL=lnls1.grpctrl

	set PP=lnls2.pp/100
        set SFF=lnls2.sff
        set PICM=lnls2.picm
        set RFRE=lnls2.remfre
        set REMLD=lnls2.remld
        set YLD=lnls2.yield/100
        set AGRMT=lnls2.efd
        set SFCM=lnls2.sfcm
        set POGD=lnls2.pogd
        set FRAPIO=lnls2.frapio
        set FRAPPO=lnls2.frappo
	set FEEP=lnls2.feep
	set PREMLD=lnls2.premld
	set FORGRINT=lnls2.forgrint
	set REMND=lnls2.remnd
 
        // Find annual factor of remittance frequency
        set FRE=RFRE,JD=EFD,NJD=$$NJD^UFRE(JD,FRE,.REMAF) quit:ER

	type RecordSTBLLSRCM lsrcm=%CACHE("STBLLSRCM").getRecord("STBLLSRCM","KEY=:PICM")

	set %PCM=lsrcm.rcc.extract(1,2)
	set %ICM=lsrcm.rcc.extract(3,4)

	set PSEQ=lnls8.pseq

	type RecordLNLS6 lnls6=Db.getRecord("LNLS6","CID,PSEQ")

	/*
	   Ignore account if inactive and not a scheduled remittance type,
	   need to continue processing scheduled to store lnls6.inactrmt
	*/

	if +%ICM'=3,+%ICM'=5,lnls6.rfpf=1 quit

	type RecordLN ln=Db.getRecord("LN","CID")

	set CRCD=ln.crcd
	set BALCMP=ln.bal if ln.aruf set BALCMP=BALCMP-ln.udbal
	set STAT=ln.stat
	set IRN=ln.irn/100,OPTR=lnls6.optr/100
	set PMTPI=ln.pmtpi
	set POAMT=ln.poamt,CUIN=ln.cuin
	set DIST1AF=ln.dist1af
	set DIST1LD=ln.dist1ld
	set TREXD=ln.trexd
	set TRATE=ln.trate
	set SCHBAL=ln.schbal

	set SDAT=lnls6.sdat   // Date sale posted	
	set PLRIC=lnls6.plric // Last remit. - interest (period)
	set PLRPB=lnls6.plrpb // Last remit. - prin balance
	set PLRPC=lnls6.plrpc // Last remit. - prin change
	set PLRAP=lnls6.plrap // Last remit. - cap def interest change
	set PLRRL=lnls6.plrrl // Last remit. - neg amort reduction (Life)
	set PLRRP=lnls6.plrrp // Last remit. - neg amort reduction (period)
	set PLRIR=lnls6.plrir // Last remit. - interest remitted
	set PLRPR=lnls6.plrpr // Last remit. - principal remitted
	set PLRCD=lnls6.plrcd // Last remit. - capitalized def int
	set PLRSB=lnls6.plrsb // Last remit. - scheduled balance
	set ACCD=lnls6.accd  // Action code
	set ACDT=lnls6.acdt  // Action date
	set PLRFC=lnls6.plrfc // Last remit. - late charges collected
	set PORIC=lnls6.poric // Payoff Report - interest calculated
	set PASSTHRU=lnls6.passthru // Pass-Through Margin
	set MAXYLD=lnls6.maxyld   // Maximum Yield
	set MINYLD=lnls6.minyld  // Minimum Yield
	set PRNDM=lnls6.prndm  // Pass-Through Rounding Method
	set PRNDF=lnls6.prndf  // Pass-Through Rounding Factor
	set INACTRMT=lnls6.inactrmt  // Scheduled Interest Since Inactive
	set FORINT=lnls6.forint	// Forfeited Grace Interest

	// Account Processing
	
	new exe,Q,vsql
	// Special processing for closed accounts
	set POP=0 if STAT=4 set POF=1 do { quit:POF
	
		//POF=0: Paid off within remittance period.  Include last time.
		//POF=1: Paid off prior to remittance period.  Exclude.
		
		if ln.dtc>REMLD set POF=0 do {
	
			// Determine whether closed before grace date
			if $$POF^LNLS9A(ln.dtc,.ln) set POF=1 quit
			
			new N,ETC,POEFD,HAMT
			
			type DbSet ds=Db.selectDbSet("HIST","CID=:CID","TSEQ DESC")
			while ds.next() do {
				type RecordHIST hist=ds.getRecord("HIST")
				if hist.itc="" quit		// FM
			
				set ETC=hist.etc quit:ETC=""
				if '$$TR^UAVB(5) quit		// Sets $T if payoff code
				
				set HAMT=hist.tamt
				set POP=$P(HAMT,"#",2) // Payoff prin
				set POEFD=hist.efd	// Payoff eff date
				if POEFD="" set POEFD=hist.tjd
			   	}

			set ACDT=$G(POEFD)		// Action date
			set ACCD=60			// Action code
		   	}
	
		if POF do {					// Paid off prev period
			do ZERO
			if ACCD=60 set (ACCD,ACDT)=""
	           	}
	      }

	// Last remit - neg amort reduced life
	set PLRRL=ln.narl
		
	// Last remit - capitalized deferred interest
	set PLRCD=ln.dic   
	
	// Determine collected amounts by passing history
	do INIT^UAVB(.ln,CID,(REMLD+1),EFD,"000000000000000001")
	
	// Last remittance - principal collected
	set PLRPC=$P(UAVB(5),"|",1)
	
	// Last remittance - interest collected
	set PLRIC=$P(UAVB(5),"|",3)
	
	// Last remittance - deferred interest capitalized
	set PLRAP=$P(UAVB(5),"|",24)	       
	
	// Last remittance - negative amortization reduction 
	set PLRRP=$P(UAVB(5),"|",23)             
	
	// Last remittance - principal-only amounts collected
	set PLROC=$P(UAVB(5),"|",25)             
	
	// Last remittance - Late charges collected
	set PLRFC=$P(UAVB(5),"|",7)
	
	// Last remittance - fees retained
        if SFCM do FEE(.lnls2,.lnls6)  						
        else  set PLRFR=""						
	
	// Calculate scheduled balance change without curtailment adjustments
	set PLRSC=PMTPI*DIST1AF/REMAF-(PLRSB*IRN/REMAF)
	if STAT=4 set PLRSC=PLRSB
	
	// Calculate scheduled balance adjustment from curtailments
	set PLRCA=0
	if %PCM="02",PLROC do {
		if STAT=4 quit
		new NJD set NJD=ln.dist1ld
		
		// Optionally modify due date based upon FNMA guidelines
		if NJD,$$DAY^SCADAT(NJD,1)'=1 do { quit:ER
			set NJD=$$NJD^UFRE(NJD,"1MA1")
			}
		if NJD'>EFD set PLRCA=$$^SCARND(PLROC*IRN/REMAF,0,CID)
	 	}

	// Adjust scheduled balance change by curtailment and adjustment
	set PLRSC=$$^SCARND(PLRSC+PLROC+PLRCA,0,CID)

        // Last remittance - scheduled balance from LN
        set PLRSB=SCHBAL
	
	// Interest remittance
	do PLRIR(.PLRIR,PLRIC,PP,REMAF,IRN,$G(C(51)),STAT,EFD,.lnls2,.lnls6)
	if SFF set PLRIR=PLRIR-PLRFR
	set PLRIR=$$^SCARND(PLRIR,0,CID)
	if lnls6.rfpf=1 set INACTRMT=INACTRMT+PLRIR
	
	// Principal remittance
	do PLRPR(.lnls6) set PLRPR=$$^SCARND(PLRPR,0,CID)
	
	// Last remittance - principal balance from LN
	set PLRPB=BALCMP

	// Calculate months delinquent
	set MONDELQ=$$DAYSDELQ^LNCDI(CID)
	set MONDELQ=MONDELQ\30
	if MONDELQ>3 set MONDELQ=3

	do FILE(.lnls6)

	quit


FILE(RecordLNLS6 lnls6)	//

	// Account is inactive, only file Scheduled Interest Since Inactive	
	if lnls6.rfpf do {
        	set lnls6.inactrmt=INACTRMT
        	do lnls6.bypassSave()
		}

	if lnls6.rfpf quit

	set lnls6.plric=PLRIC
	set lnls6.plrpb=PLRPB
	set lnls6.plrpc=PLRPC
	set lnls6.plrap=PLRAP
	set lnls6.plrrl=PLRRL
	set lnls6.plrrp=PLRRP
	set lnls6.plrir=PLRIR
	set lnls6.plrpr=PLRPR
	set lnls6.plrfr=PLRFR
	set lnls6.plrcd=PLRCD
	set lnls6.plrsb=PLRSB
	set lnls6.accd=ACCD
	set lnls6.acdt=ACDT
	set lnls6.plroc=PLROC
	set lnls6.plrsc=PLRSC
	set lnls6.plrpt=DIST1LD
	set lnls6.plrfc=PLRFC
	set lnls6.plrca=PLRCA
	set lnls6.forint=FORINT

        if GRPCTRL=1 do {

		type RecordTMPLSINV tmplsinv1=Db.getRecord("TMPLSINV","JOB=:JOB,INCD=:INCD,REMLD=:REMLD,PL=:PL",1)
		if 'tmplsinv1.getMode() do {
		
			type RecordTMPLSINV tmplsinv=Class.new("RecordTMPLSINV")
                        set tmplsinv.job=JOB
                        set tmplsinv.incd=INCD
                        set tmplsinv.remld=REMLD
                        set tmplsinv.pl=PL
                        
                        do tmplsinv.bypassSave()
			                       
			}

		type RecordTMPLSINV tmplsinv=Db.getRecord("TMPLSINV","JOB,INCD,REMLD,PL")
		set tmplsinv.tcnt=tmplsinv.tcnt+1
		set tmplsinv.tplric=tmplsinv.tplric+PLRIC
		set tmplsinv.tplrpc=tmplsinv.tplrpc+PLRPC
		set tmplsinv.tplrpb=tmplsinv.tplrpb+PLRPB
		set tmplsinv.tplroc=tmplsinv.tplroc+PLROC
		set tmplsinv.tplrfr=tmplsinv.tplrfr+PLRFR
		set tmplsinv.tplrca=tmplsinv.tplrca+PLRCA
		set tmplsinv.premld=REMLD
					
		// new loan totals
                if SDAT>REMLD,SDAT<(EFD+1) do {  // sold last period
			set tmplsinv.nplric=tmplsinv.nplric+PLRIC
			set tmplsinv.nplrpc=tmplsinv.nplrpc+PLRPC
			set tmplsinv.nplrpb=tmplsinv.nplrpb+PLRPB
			set tmplsinv.ntot=tmplsinv.ntot+1
                        }
		
		do tmplsinv.bypassSave()
                }
	
	do lnls6.bypassSave()

	// LNLSREM and LNLSRMDT tables for Group Control and Monthly Arrears reports
	type RecordLNLSREM lnlsrem=Class.new("RecordLNLSREM")
	set lnlsrem.incd=INCD

	// Months delinquent is as of today - not last remittance date
	set lnlsrem.remld=EFD
	set lnlsrem.pl=PL
	set lnlsrem.grp=GRP
	set lnlsrem.cid=CID
	set lnlsrem.pseq=PSEQ
	set lnlsrem.mondelq=MONDELQ
	do lnlsrem.save()
	quit


ZERO	// No activity - zero out period amounts

	set (PLRIC,PLRPB,PLRPC,PLRAP,PLRRP,PLRIR,PLRPR,PLRCD,PLRSB)=""
	set (PLROC,PLRSC,PLRPT,PLRFC)=""
	quit

	
PLRIR(PLRIR,PLRIC,PP,REMAF,IRN,C,STAT,EFD,RecordLNLS2 lnls2,RecordLNLS6 lnls6)	// Interest remit 
	
	if STAT=4 N Q set Q=1 do { quit:Q
	
		// If FRAPIO is equal to 0 do not calculate interest
		if 'FRAPIO set PLRIR=0 quit
		
		// If FRAPIO is equal to 1, then continue and calc normal int
		if FRAPIO=1 set Q=0 quit
		
		// If FRAPIO is equal to 2, grab interest calculated at payoff
		if FRAPIO=2 set PLRIR=PORIC quit
	     }

	if %ICM="01" set PLRIR=PLRIC*PP
	if %ICM="02" set PLRIR=PLRIC*$$RATE*PP/IRN
	if %ICM="03" set PLRIR=lnls6.plrpb*$$RATE*PP/REMAF
	if %ICM="05" set PLRIR=PLRSB*$$RATE*PP/REMAF
	
	// First remittance date, forfeit grace interest
	if $L(lnls2.igp),EFD-lnls2.igp<lnls6.sdat set PLRIR=0 if FORGRINT=1 set FORINT=PLRIR,FORINT=$$^SCARND(FORINT,0,CID) quit

	// If there was interest forfeited last period, subtract it out now
	if FORINT set PLRIR=PLRIR-FORINT set FORINT=0

	quit
	
PLRPR(RecordLNLS6 lnls6)	// Calculate principal remittance amount
	
	set PLRPR=0
	
	if STAT=4 do { quit
	
		// Exclude payoff principal
		if FRAPPO=1 set PLRPR=((PLRPC-POP)*PP) quit
		
		// Include payoff principal
		if FRAPPO=2 set PLRPR=PLRPC*PP quit
	
		// Scheduled principal
		if FRAPPO=3 set PLRPR=PLRSB*PP quit
	        }
	
	// Actual/Actual and Scheduled/Actual
	if %PCM="01" set PLRPR=PLRPC*PP quit
		
	// Scheduled/Scheduled
	if %PCM="02" set PLRPR=PLRSC*PP quit
		
	quit  


RATE()	// Extrinsic returns rate used in remittance and fee calculations

	new rate

	// Return override pass-through-rate if it exists
	if $G(OPTR) quit OPTR
	
	// Return investor yield if it exists
	if $G(YLD) quit YLD

	// Return account rate less service fee % if service fee % exists
	// if Fixed Fee Percentage exists.  Use teaser rates.
	if $G(TREXD)>$S($G(PLRPT):$G(PLRPT),1:TJD) if $g(TRATE) s IRN=TRATE
	if $g(FEEP) quit $g(IRN)-$g(FEEP)

	// Return Pass-Through Margin plus IRN if Pass-Through exists
	if $g(PASSTHRU) do {
		set rate=IRN+PASSTHRU
                if rate<MINYLD set rate=MINYLD
                if rate>MAXYLD set rate=MAXYLD
 
                // If rounding method and rounding factor exist - round
                if PRNDM'="",PRNDF'="",PRNDM'=0 do {
                        new up,down
                        set up=((rate\PRNDF)*(PRNDF))+(PRNDF)
		        set down=(rate\PRNDF)*(PRNDF)
                        // PRNDM from table STBLPRNDM
                        if PRNDM=2 set rate=up quit   // round up
                        if PRNDM=3 set rate=down quit // round down
                        if PRNDM=1 set rate=$S((rate-down)>(up-rate):up,1:down)
                        }
                }

        if $G(PASSTHRU) quit rate
 
        // Return loan rate if others don't exist
        quit $g(IRN)	


FEE(RecordLNLS2 lnls2,RecordLNLS6 lnls6)     // Calculate fee for investor for CID
        N EFD,INCD,PL,REMLD,REMND,SEQ

        set REMLD=lnls2.remld,REMND=lnls2.remnd
        set INCD=lnls6.incd,PL=lnls6.pl,SEQ=0,PLRFR=""

	type ResultSet lsdtj=Db.select("EFD,TSEQ","LNLSDT","INCD=:INCD AND PL=:PL AND CID=:CID")
	while lsdtj.next() do {
		set EFD=lsdtj.getCol(1) 
		if (EFD'>REMLD)!(EFD>REMND)!(EFD="") quit
		set TSEQ=lsdtj.getCol(2) 
		if TSEQ="" quit

		type RecordLNLSDT lnlsdt=Db.getRecord("LNLSDT","EFD,INCD,PL,CID,TSEQ") 
       		set PLRFR=PLRFR+lnlsdt.srvfee
		}

        quit


EXC     // Log error in exception file

	type public Number PL,%ZTSEQ
	type public String ET,FRE,INCD,RM

	type String DESC
	
        set DESC=$$^MSG(6872)_"|1"

	// Loan Sale Remittance Processing 
        do LOG^UTLEXC($T(+0),"*",DESC,$G(INCD)_" "_$G(PL)_" "_$G(FRE),$G(%ZTSEQ),$G(RM))
        kill ET,%ZTSEQ
        quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
 type String vRECORD,INCD,PL
 for  set vRECORD=vINPUT.piece("|",1),vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD.isNull()  do {
 set INCD=vRECORD.piece($C(9),1)
 set PL=vRECORD.piece($C(9),2)
 do vPROC(INCD,PL)
 }
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
 type public String vBUFOVFL
 type String vRECORD,vrow,INCD,PL
 type Number vcur,vlen
 set vINPUT=vBUFOVFL.get()
 set vBUFOVFL="",vlen=0
 type public ResultSet vRESULT
 for  do { quit:'vcur
 set vcur=vRESULT.next() if 'vcur quit
 set vrow=vRESULT.getRow()_"|",vlen=vlen+vrow.length()
 if vlen>32767 set vBUFOVFL=vrow,vcur=0 quit
 set vINPUT=vINPUT_vrow if vlen+17>32767 set vcur=0 quit
 }
 set vINPUT=vINPUT.extract(1,vINPUT.length()-1)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	do Db.fastDelete("TMPLSINV")

 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("INCD,PL","LNLS2","REMND<:TJD AND PICM<>6")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
	/* 
	 File investor/pool/remittance date totals
         Each time the batch is submitted the totals will accumulate 
         for each valid account, thus records may be overwritten.
        */

 	new EFD,IN,INCD,JOB,NPLRIC,NPLRPC,NPLRPB,NTOT,PL,PREMLD,REMLD
	new TCNT,TPLRIC,TPLRPC,TPLRPB,TPLROC,TPLRFR,TPLRCA
	set EFD=%SystemDate-1

	// tally totals for threads into IN array
	type ResultSet rs=Db.select("JOB,INCD,REMLD,PL,TCNT,TPLRIC,TPLRPC,TPLRPB,TPLROC,TPLRFR,TPLRCA,PREMLD,NPLRIC,NPLRPC,NPLRPB,NTOT","TMPLSINV")
	while rs.next() do {
		set JOB=rs.getCol(1)
		set INCD=rs.getCol(2)
		set REMLD=rs.getCol(3)
		set PL=rs.getCol(4)
		set TCNT=rs.getCol(5)
		set TPLRIC=rs.getCol(6)
		set TPLRPC=rs.getCol(7)
		set TPLRPB=rs.getCol(8)
		set TPLROC=rs.getCol(9)
		set TPLRFR=rs.getCol(10)
		set TPLRCA=rs.getCol(11)
		set PREMLD=rs.getCol(12)
		set NPLRIC=rs.getCol(13)
		set NPLRPC=rs.getCol(14)
		set NPLRPB=rs.getCol(15)
		set NTOT=rs.getCol(16)
		set $p(IN(INCD,REMLD,PL),"|",1)=$p($g(IN(INCD,REMLD,PL)),"|",1)+TCNT
		set $p(IN(INCD,REMLD,PL),"|",2)=$p($g(IN(INCD,REMLD,PL)),"|",2)+TPLRIC
		set $p(IN(INCD,REMLD,PL),"|",3)=$p($g(IN(INCD,REMLD,PL)),"|",3)+TPLRPC
		set $p(IN(INCD,REMLD,PL),"|",4)=$p($g(IN(INCD,REMLD,PL)),"|",4)+TPLRPB
		set $p(IN(INCD,REMLD,PL),"|",5)=$p($g(IN(INCD,REMLD,PL)),"|",5)+TPLROC
		set $p(IN(INCD,REMLD,PL),"|",6)=$p($g(IN(INCD,REMLD,PL)),"|",6)+TPLRFR
		set $p(IN(INCD,REMLD,PL),"|",7)=$p($g(IN(INCD,REMLD,PL)),"|",7)+TPLRCA
		set $p(IN(INCD,REMLD,PL),"|",8)=PREMLD
		set $p(IN(INCD,REMLD,PL),"|",9)=$p($g(IN(INCD,REMLD,PL)),"|",9)+NPLRIC
		set $p(IN(INCD,REMLD,PL),"|",10)=$p($g(IN(INCD,REMLD,PL)),"|",10)+NPLRPC
		set $p(IN(INCD,REMLD,PL),"|",11)=$p($g(IN(INCD,REMLD,PL)),"|",11)+NPLRPB
		set $p(IN(INCD,REMLD,PL),"|",12)=$p($g(IN(INCD,REMLD,PL)),"|",12)+NTOT
		}

	// file IN array in ^LNLSINV 
        new INCD,REMLD,PL
        set (INCD,REMLD,PL)=""
        for  set INCD=$o(IN(INCD)) quit:INCD=""  do {
 		for  set REMLD=$o(IN(INCD,REMLD)) quit:REMLD=""  do {
	                for  set PL=$o(IN(INCD,REMLD,PL)) quit:PL=""  do {
                	        type RecordLNLSINV lnlsinv=Class.new("RecordLNLSINV")
                        	set lnlsinv.incd=INCD
                       		set lnlsinv.remld=EFD
               		        set lnlsinv.pl=PL
                        	set lnlsinv.tcnt=$p(IN(INCD,REMLD,PL),"|",1)
                        	set lnlsinv.tplric=$p(IN(INCD,REMLD,PL),"|",2)
                        	set lnlsinv.tplrpc=$p(IN(INCD,REMLD,PL),"|",3)
                        	set lnlsinv.tplrpb=$p(IN(INCD,REMLD,PL),"|",4)
                        	set lnlsinv.tplroc=$p(IN(INCD,REMLD,PL),"|",5)
				set lnlsinv.tplrfr=$p(IN(INCD,REMLD,PL),"|",6)
				set lnlsinv.tplrca=$p(IN(INCD,REMLD,PL),"|",7)
                        	set lnlsinv.premld=$p(IN(INCD,REMLD,PL),"|",8)
                        	set lnlsinv.nplric=$p(IN(INCD,REMLD,PL),"|",9)
                        	set lnlsinv.nplrpc=$p(IN(INCD,REMLD,PL),"|",10)
                        	set lnlsinv.nplrpb=$p(IN(INCD,REMLD,PL),"|",11)
                        	set lnlsinv.ntot=$p(IN(INCD,REMLD,PL),"|",12)
                        	do lnlsinv.bypassSave()
                        	}
                	}
		}

        quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
