public UHFETCH
	/*
	ORIG: MATTSON - 04/01/2003
	DESC: Account History Utility

	---- Comments --------------------------------------------------------
	 
	Library program that provides database server utilities for account
	history tables.  Note that this procedure will become obsolete
	when the archiving and data transformation (Euro conversion)
	logic is moved into SQL and all calls into UHFETCH have been
	replaced with PSL methods.

	KEYWORDS:  Database

	LIBRARY:  $$OPEN	Create a results table
		  $$FETCH	Fetch the next record from a results table
		  $$CLOSE	Close a results table
		  $$RETREC	Return a History Record
		  $$SELECT	Special History Record Selection Criteria
		  $$HISTL	Return lower level of history

	---- Revision History ------------------------------------------------
	
	08/02/06 - KELLYP - CR 22048
		   Modified TEST section to eliminate BYPASS warning.
	
	06/09/05 - SmithCD - CR 15902
		   Extended the change done with CR 13686 to other extrinsic 
		   function calls into HISTUTL that were resulting in an 
		   undefined on rs variable. Removed old revision history 
		   and performed some cleanup.

	04/18/05 - Hillanbrand - CR13686
	    	   Modified HIST0 subsection.  Assigned a variable to 
		   $$HIST0^HISTUTL() and checked the value of the variable 
		   after the return.  Corrects a undefined on rs.
	           type Boolean flag=$$HIST0^HISTUTL(.rs,CID,XJD) if 'flag quit ""

	12/09/04 - Frans S.C. Witte - CRs 11445
		   Subroutine OPEN: Replaced "storeValue" by "setStoredValue" 
		   (2 occurrences). Multiple subroutines: Replaced Row.piece()
		   by Row.toString().piece() (5 occurrences).
	    
	 */

	/*
	UHFETCH relies on calls to HISTUTL (history database utility)
	and HISTDEF (history row/column definitions).  These routines
	are generated by procedure definitions HISTUCG and HISTUCG1,
	respectively.
	
	The following lines of code ensure procedure definition HISTUCG
	has been compiled and HISTUTL has been built.  [Similar code is
	contained in HISTUCG to compile procedure definition HISTUCG1
	and to build HISTDEF.]
	
	Effectively, when UHFETCH is compiled procedure definitions 
	HISTUCG and HISTUCG1 are also compiled and routines HISTUTL
	and HISTDEF are generated.
	*/

	// Compile procedure definition HISTUCG
	#XECUTE do COMPILE^DBSPROC("HISTUCG")

	// Compile routine HISTUTL
	#XECUTE do HISTUTL^HISTUCG()

	quit

	
public OPEN(ResultSet histrs,	// History result set		
            Number CID,		// Account Number		
            Number TSEQ,	// Transaction Sequence		/REF:RW
            Number DESC,	// Descending order flag	/NOREQ/DFT=N
            String Q(),		// DATA-QWIK Query Array	/NOREQ/REF:RW
            Number MIN,		// Starting history sequence	/NOREQ
            Number MAX)		// Ending history sequence	/NOREQ

	/*
	Open a history cursor

	KEYWORDS: Database

	Additional notes on ARGUMENTS:

	TSEQ      Transaction Sequence
	
			This parameter should normally be newed or initialized
			to NULL prior to calling OPEN^UHFETCH.  If it does have
			an initial value, only that record will be returned on
			the subsequent fetch.
	 
	Q         DATA-QWIK Query Array
	
			The array must be in the internal structure
			MUMPS executable, AFTER DBSQRYA is called.
	
	
	RETURNS:
	    . $$	Success code			/TYP=N
			0   = No records in database
			1-n = Success
	
	OUTPUT:
	    . ER	Error indicator			/TYP=N
	    . RM	Error message			/TYP=T

	EXAMPLE:
	     set vsql=$$OPEN^UHFETCH(.hist,CID,.TSEQ,.DESC) if vsql=0 quit
	*/

	type Date BJD
	type Number RETURN

	type public ResultSet histrs

	// Define selection criteria
	set BJD=$select(Q("BD").get():Q("BD"),1:0)
	set MIN=$select(TSEQ.get():TSEQ,MIN.get():MIN,1:1)
	set MAX=$select(TSEQ.get():TSEQ,MAX.get():MAX,1:1E9)
	
	// Open a history cursor (in ascending or descending order)
	if DESC.get() set RETURN=$$HISTDSC^HISTUTL(.histrs,CID,BJD,MIN,MAX)
	else  set RETURN=$$HISTASC^HISTUTL(.histrs,CID,BJD,MIN,MAX)

	// Result set is empty
	if RETURN=0 quit 0

	/*
	Store reversal information contained in table HISTR in the
	history ResultSet object for use in FETCH.
	*/
	
	type ResultSet rs=Db.select("TSEQ,REVFLG","HISTR","CID=:CID AND TSEQ NOT < :MIN AND TSEQ NOT > :MAX")
	while rs.next() do histrs.setStoredValue("RV#"_rs.getCol("TSEQ"),rs.getCol("REVFLG"))

	/*
	Store query information contained in the Q array in the history
	ResultSet object for use in FETCH.
	*/
	
	set Q=""
	for  set Q=Q(Q).order() quit:Q.isNull()  do histrs.setStoredValue(Q,Q(Q))

	quit 1
	

public FETCH(ResultSet histrs,	// History result set	/REF:RW
	     Number CID,	// No longer used
	     Number TSEQ,	// Transaction Sequence	/NOREQ/REF:W
	     String fHIST)	// The 'raw' record	/REF:W

	/*
	Fetch next record
	
	RETURNS:
	     . $$      Success code
	     
	               0   = No records in reference
	               1-n = Success

	EXAMPLE:
		set vsql=$$FETCH^UHFETCH(.hist,,.TSEQ,.fHIST)

	*/

	type String ITC,ML,MR
	type Number EC,EXIT,FM,HIT,REVFLG
	
	set EC=histrs.getStoredValue("EC")
	set FM=histrs.getStoredValue("FM")
	set ML=histrs.getStoredValue("ML")
	set MR=histrs.getStoredValue("MR")

	set EXIT=0
	while histrs.next() do { quit:EXIT
		type Row hist=histrs.getRow("|","#$$HIST^HISTDEF")

		set TSEQ=hist.tseq
		set ITC=hist.itc
		
		set REVFLG=histrs.getStoredValue("RV#"_TSEQ)
		if REVFLG set hist.itc=$$ITC^TTXEXT(ITC,$select(REVFLG=1:6,1:12))
			
		/*
		Error correct option (refer to subroutine SELECT for
		additional information).
		*/

		if EC=1,'(ITC.extract(6)=0&(ITC.extract(12)=0)) quit
		if EC=2,'(ITC.extract(6)=1!(ITC.extract(12)=1)) quit
				
		/*
		File maintenance option (refer to subroutine SELECT
		for additional information).
		*/
		
		if FM=1,ITC.isNull() quit
		if FM=2,'(ITC.isNull())&(+hist.tamt=0)) quit
		
		if 'ML.isNull() do { quit:HIT=0

			type Number I
			type String COL,VAL
			
			set HIT=1
			for I=1:1:ML.length(",") do { quit:HIT=0
				set COL=ML.piece(",",I)
				set VAL=MR.piece(",",I)
				if hist.@COL=VAL quit
				set HIT=0
				}
			}
		
		#IF 'CUVAR.emucrcd.isNull() do CNVHIST^HISTUTL(.hist)

		/*
		fHIST is the string returned to the application; it
		excludes the first two columns (CID, TSEQ) of the
		row and trailing delimiters removed
		*/

		set fHIST=hist.toString().piece("|",3,9999)
		set fHIST=fHIST.trim(1,"|")
		set EXIT=1
		}
	
	if EXIT quit 1
	
	set fHIST=""
	set TSEQ=""
	
	quit 0


public RETREC(Number CID,	// Account Number	
	      Number TSEQ,	// Transaction Sequence	
	      String DIR)	// Directory name	/NOREQ/REF:RW
	
	/*
	Return a history record

	Additional notes on ARGUMENTS:

	     DIR	Directory name

	     		Note that this argument was previously used
	     		to support history archiving; it remains so
	     		that application calls into $$RETREC did
	     		not have to change.
	
	RETURNS:
	
	     $$ 	fHIST
	     		History record (delimited string)
	     		
	EXAMPLES:
		S fHIST=$$RETREC^UHFETCH(CID,TSEQ,.DIR)
	*/

	type public ResultSet histrs

	type String fHIST
		
	if '$$OPEN(.histrs,CID,TSEQ) quit ""
	if '$$FETCH(.histrs,,,.fHIST) quit ""

	do CLOSE

	quit fHIST

	
public CLOSE	// External cursor CLOSE
	/*
	Close history cursor
	
	EXAMPLE:
		D CLOSE^UHFETCH
	*/

	type public ResultSet histrs

	kill histrs

	quit


public SELECT(String Q(),	// DATA-QWIK query array	/REF:RW
	      Date BD,		// Beginning date		/NOREQ
	      Number FM,	// File Maintenance Option	/NOREQ
	      Number EC,	// Error Correct Option		/NOREQ
	      String ML,	// Match field list		/NOREQ
	      String MR)	// Match Record Data		/NOREQ
       
	/*
	Special selection queries

	Call this utility to build special selection criteria after
	processing any user queries through DBSQRYA, and before 
	opening the cursor (OPEN^UHFETCH).

	KEYWORDS: Database

	Additional notes on ARGUMENTS:
	    Q		Query

	    		Note that this argument is no longer used; it
	    		remains so that application calls into SELECT
	    		did not have to change.

	    FM		File Maintenance Option
	    
			0 = All
			1 = No Maintenance
			2 = Maintenance Only
	
	    EC		Error Correct Option
	    
			0 = All
			1 = No error corrects or reversals
			2 = Error corrects and reversals only

	*/


	if BD.get() set Q("BD")=BD
	if EC.get() set Q("EC")=EC
	if FM.get() set Q("FM")=FM
	
	if 'ML.get().isNull() set Q("ML")=ML
	if 'MR.get().isNull() set Q("MR")=MR

	quit


public HIST0(Number CID,	// Account Number	  /TYP=N/REQ/MECH=VAL
	     Date XJD)		// HIST0 date key	  /TYP=N/REQ/MECH=VAL

	/*
	Retrieve HIST0 record (convert to EUR if applicable)
	
	RETURNS:
	       . $$    HIST0 record	    	/TYP=T
	
	EXAMPLE:
	       s hist0=$$HIST0^UHFETCH(TJD,CID)
	*/

	type ResultSet rs
	type String fHIST0
	type Boolean RETURN
	
	set RETURN=$$HIST0^HISTUTL(.rs,CID,XJD)
	if 'RETURN quit ""

	if 'rs.next() quit ""

	type Row hist0=rs.getRow("|","#$$HIST0^HISTDEF")

	#IF 'CUVAR.emucrcd.isNull() do CNVHIST0^HISTUTL(.hist0)

	set fHIST0=hist0.toString().piece("|",3,9999)
	
	quit fHIST0
	

public HISTL(Number CID,	// Account Number		
	     Number TSEQ,	// Transaction Sequence		
	     String ARR,	// Return Array			/REF:RW
	     String TYP)	// Record Type			

	/*
      	Return lower level of history
      	
	Additional notes on ARGUMENTS:

	    TYP		Record Type
			SB  = Satisfied Bills
			LST = Loan Secondary Transactions
			DST = Deposit secondary Transactions

	EXAMPLE:
			D HISTL^UHFETCH(CID,TSEQ,.H,"SB")
	*/

	kill ARR

	type String DIR,fHIST

	set fHIST=$$RETREC(CID,TSEQ,.DIR)
	if fHIST.isNull() quit

	set fHIST=CID_"|"_TSEQ_"|"_fHIST
	type Row hist=fHIST.toRow("#$$HIST^HISTDEF","|")

	/*
	=============================================
	Convert Deposit Secondary Transactions (DST)
	=============================================
	*/
	
	if TYP="DST" do { quit
		type ResultSet rs
		type Boolean RETURN
		
		set RETURN=$$HISTDST^HISTUTL(.rs,CID,TSEQ)
		if 'RETURN quit
	
		while rs.next() do {
			type Row histdst=rs.getRow("|","#$$HISTDST^HISTDEF")

			#IF 'CUVAR.emucrcd.isNull() do CNVDST^HISTUTL(.hist,.histdst)

			set ARR(ARR("").order(-1)+1)=histdst.toString().piece("|",4,9999)
			}
		}

	/*
	=============================================
	Convert Loan Secondary Transactions (LST)
	=============================================
	*/

	if TYP="LST" do { quit
		type ResultSet rs
		type Boolean RETURN
		
		set RETURN=$$HISTLST^HISTUTL(.rs,CID,TSEQ)
		if 'RETURN quit

		while rs.next() do {
			type Row histlst=rs.getRow("|","#$$HISTLST^HISTDEF")

			#IF 'CUVAR.emucrcd.isNull() do CNVLST^HISTUTL(.hist,.histlst)

			set ARR(ARR("").order(-1)+1)=histlst.toString().piece("|",4,9999)
			}
		}

	/*
	=============================================
	Convert Satisfied Bills (SB)
	=============================================
	*/

	if TYP="SB" do { quit
		type ResultSet rs
		type Boolean RETURN
		
		set RETURN=$$HISTSB^HISTUTL(.rs,CID,TSEQ)
		if 'RETURN quit

		while rs.next() do {
			type Row histsb=rs.getRow("|","#$$HISTSB^HISTDEF")

			#IF 'CUVAR.emucrcd.isNull() do CNVSB^HISTUTL(.hist,.histsb)
			
			set ARR(ARR("").order(-1)+1)=histsb.toString().piece("|",4,9999)
			}
		}

	quit
	

TEST(String IO,			// Output device		
     Number OPTION,		// Test option			/NOREQ
     Number BEGCID,		// Beginning account number	/NOREQ
     Number ENDCID,		// Ending account number	/NOREQ
     Number MAXREC,		// Maximum number of records	/NOREQ
     Date EURCNVD)		// Euro conversion date		/NOREQ

	/*
	Test UHFETCH
	
	This sub-routine is used for test purposes only.  Parameter
	'EURCNVD' is used to test the Euro conversion components of
	UHFETCH without requiring the accounts to have gone through
	an actual Euro conversion.

	Additional notes on ARGUMENTS:

	    IO		Output device

			The device that is used to record the output;
			the history record (and all lower levels) are
			written to the output device in the following
			format:
			
			***** Database *****
			^HIST(CID,tseq)=<database record>
	               ^HIST(CID,tseq,sseq)=<database record>
			***** UHFETCH  *****
			^HIST(CID,tseq)=<record returned from FETCH^UHFETCH>
			AR(i)=<record returned from HISTL^UHFETCH>
	
				where AR = Record Type (SB, DST or LST)
				       i = Sequence number (not sseq)
	
	     OPTION	Test option
	
			0 = No selection criteria
			1 = Apply random selection criteria
	
	     MAXREC	Maximum number of records
	
			The maximum number of history records to process;
			the default is 1E18 history records.
	
	     EURCNVD	Euro conversion date
	
			Optional parameter that simulates a Euro conversion
			if the account has not already been converted.
	*/

	//I18N=OFF

	type Date EJD
	type String fHIST,ORGCRCD,Q()
	type Number BEG,CID,CIDCNT,EC,END,FM,MAX,MIN,RECCNT,REV,TIM1,TIM2
	type Number TSEQ,vsql,X
	type ResultSet exe
	
	set OPTION=OPTION.get()
	set BEGCID=BEGCID.get()
	set ENDCID=ENDCID.get()
	set MAXREC=MAXREC.get()
	set EURCNVD=EURCNVD.get()

	if 'ENDCID set ENDCID=1E18
	if 'MAXREC set MAXREC=1E18

	do SYSVAR^SCADRV0()

	set X=$$FILE^%ZOPEN(IO,"WRITE/NEW",2,1024)
	if 'X quit
	use IO

	set X=$H
	set TIM1=(X*1E5)+X.piece(",",2)
	set (CIDCNT,RECCNT)=0

	type DbSet ds=Db.selectDbSet("ACN","CID NOT < :BEGCID AND CID NOT > :ENDCID")
	while ds.next() do { quit:CIDCNT>MAXREC
		set CIDCNT=CIDCNT+1

		set (BEG,EC,EJD,END,FM,MAX,MIN,REV)=""
		
		type RecordACN acn=ds.getRecord()

		if OPTION=1 do {
			do opt1(.acn,CIDCNT,.BEG,.END,.MIN,.MAX,.REV,.EC,.FM,.EJD)
			write !!," [",BEG,"-",END," rev=",REV," ejd=",EJD
			write " fm=",FM," ec=",EC," min=",MIN," max=",MAX
			write " ]"
			}	

		set CID=acn.cid

		if EURCNVD do {

			// Already converted
			if 'acn.eurcnvd.isNull() quit

			type String ORGCRCD
			set ORGCRCD=acn.crcd

			set acn.crcd="EUR"
			set acn.eurcnvd=EURCNVD
			set acn.orgcrcd=ORGCRCD
			}

		do SELECT^UHFETCH(.Q,EJD,FM,EC)
		set vsql=$$OPEN^UHFETCH(.exe,.CID,"",REV,.Q,MIN,MAX) quit:'vsql

		for  set vsql=$$FETCH^UHFETCH(.exe,"",.TSEQ,.fHIST) quit:vsql=0  do {
			set RECCNT=RECCNT+1 if RECCNT'<MAXREC set vsql=0

			write !!,"***** Database *****",!
			
			#ACCEPT DATE=08/02/06;PGM=KELLYP;CR=18140
			#BYPASS
			zwr ^HIST(CID,TSEQ,*)
			#ENDBYPASS

			write "***** UHFETCH  *****"
			write !,"^HIST(",CID,",",TSEQ,")=""",fHIST,""""

			if acn.cls="L" do {
				do histl(CID,TSEQ,"SB")
				do histl(CID,TSEQ,"LST")
				}

			else  do histl(CID,TSEQ,"DST")
			}

		}

	set X=$H
	set TIM2=(X*1E5)+X.piece(",",2)
	write !!,"Elapsed time: ",TIM2-TIM1," seconds"

	do CLOSE^SCAIO

	quit


histl(Number CID, Number TSEQ, String REC)

	// Retrieve lower levels of history

	type Number I
	type String TMP()

	do HISTL^UHFETCH(CID,TSEQ,.TMP,REC)
	
	for I=1:1 quit:'TMP(I).data()  write !,REC,"(",I,")=",TMP(I)
	
	quit


opt1(RecordACN acn,		// Account record		/REF:R
     Number CIDCNT,		// Number of accounts		
     Number BEG,		// Beginning			/REF:W
     Number END,		// Ending			/REF:W
     Number MIN,		// Minimum			/REF:W
     Number MAX,		// Maximum			/REF:W
     Number REV,		// Reversal			/REF:W
     Number EC,			// Error correct		/REF:W
     Number FM,			// File maintenance		/REF:W
     Date EJD)			// Ending date			/REF:W

	// Test Option 1;Random selection criteria

	type Number CID,NUM

	set CID=acn.cid
	
	set REV=CIDCNT#2
	set FM=CIDCNT#3
	set EC=CID#3

	if CIDCNT#5=0 do {
		type ResultSet rs=Db.select("TSEQ", "HIST", "TSEQ>0", "TSEQ ASC")

		if rs.next() set BEG=rs.getCol("TSEQ")
		else  set BEG=""

		type ResultSet rs1=Db.select("TSEQ", "HIST", "TSEQ>0", "TSEQ DESC")

		if rs1.next() set END=rs1.getCol("TSEQ")
		else  set END=""
		
		set NUM=CID#3

		set MIN=BEG+NUM
		set MAX=END-NUM
		
		if MAX>MIN set (MAX,MIN)=""

		if REV,END,NUM=0 do {
			type RecordHIST hist=Db.getRecord("HIST","CID=:CID,TSEQ=:END")
			set EJD=hist.tjd-5
			}
		}

	quit

vSIG()	quit "60479^60363^Pat Kelly^14998"	// Signature - LTD^TIME^USER^SIZE
