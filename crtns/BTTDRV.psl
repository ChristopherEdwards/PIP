BTTDRV //Batch BTTDRV - Accrual Driver
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 09/10/2007 15:36 - root
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BTTDRV Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit quit
 do JOBMGR^BCHUTL(%FN,"BTTDRV",.vINPUT)
 do ^JOBMGR(.vINPUT)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(RecordACN acn) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 type public String CID
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BTTDRV","*","",acn.cid, vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,acn)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BTTDRV","*","",acn.cid,"",et)
 }
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,RecordACN acn) //
	// RecordACN acn is passed into the EXEC section as defined
	// by the batch definition detail page

	type literal Date TODAY = %SystemDate

	type public Boolean ER
	type public String ET, RM 

	if (acn.acs = TODAY) quit
	if (acn.odt > TODAY) quit

	if (acn.cls = "D") do PROCDEP(acn.cid,.acn) quit:ER
	if (acn.cls = "L") do PROCLN(acn.cid,.acn)


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
	type public String cache(,,,)
	
	type Number BTTLAST, NEWCNT

	// Refresh cache for each block of accounts
	kill cache

	type RecordBTTACN bttacn = Db.getRecord("BTTACN", "SEQ = :vINPUT")

	set BTTLAST = bttacn.end
	if BTTLAST.isNull() set BTTLAST = 1E18

	type DbSet ds = Db.selectDbSet("ACN", "CID > :bttacn.beg AND CID <= :BTTLAST", "CID ASC")

	for NEWCNT = 0:1 quit:'ds.next()  do {

		type RecordACN acn = ds.getRecord("ACN")
		do vPROC(.acn)
	}

	// Update BTTACN if number of accounts within range has changed
	if (bttacn.cnt <> NEWCNT) do {

		set bttacn.cnt = NEWCNT
		do bttacn.bypassSave()
	}
	

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
	type ResultSet rs = Db.select("SEQ", "BTTACN", "SEQ>:vINPUT", "SEQ ASC")
	if rs.next() set vINPUT = rs.getCol("SEQ")
	else  set vINPUT = ""
	
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	type public Number SCHPID = %ProcessID

	do Db.fastDelete("TMPRPT3", "PID = :SCHPID")
	do Db.fastDelete("TMPRPT4", "PID = :SCHPID")


 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("CID","ACN","")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	type literal Date TODAY = %SystemDate
	type literal Date TOMORROW = %SystemDate + 1

	// Restrict restore of this process
	type RecordNOREST temp = Db.getRecord("NOREST", "JOBNUM = %ProcessID", 1)
	
	set temp.curdt = %CurrentDate
	set temp.curtim = %CurrentTime
	
	do temp.bypassSave()

	#IF $$VALID^%ZRTNS("ZBTTPP") do INIT^ZBTTPP


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
	do Db.fastDelete("NOREST", "JOBNUM = :%ProcessID")

	quit


PROCDEP(Number CID,	// Account number
	RecordDEP dep)	// Deposit object		/MECH=REFNAM:RW

	// Process deposit accounts

	/*
	Segments are in use for this section if Segments used for both 
	loans and deposits (0), or Segments used for deposits only (2), or 
	deposit product types exist that use segments
	*/
	type literal Boolean isSEGUSE = ('CUVAR.NOSEGMENTS ! (CUVAR.NOSEGMENTS = 2)) ! ($$SEGUSE^BTTOPTMZ("D"))
	
	type literal Date TODAY = %SystemDate
	type literal Date TOMORROW = %SystemDate + 1
	type literal Date AECDATE = CUVAR.dayend4 + TOMORROW	// Anticipate earnings checks

	type public Cache %CACHE()
	type public Boolean ER
	
	type Boolean isICHND
	type Number ACR, ANFACTOR, AWT, BALAVL, BALCOL, BALINT, BALPRIN, DAYSINP
	type Number OLDIRN, OLDCMP, IRCB, IRN, MAXACR, MINACR, UNCACR
	type String IACM, INDEX
	
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE = :dep.type")

	if prodctl.nonpa quit

	set (ANFACTOR, AWT, DAYSINP) = ""

	set BALCOL = dep.balcol
	set BALPRIN = dep.bal

	#IF ((CUVAR.LPND = %SystemDate & $$PACF^BTTOPTMZ("D")) ! (+(%SystemDate + 1).day() = 1))
	if (+BALPRIN = 0), (dep.stat = 4) do {  quit
	
		#IF (CUVAR.LPND = %SystemDate & $$PACF^BTTOPTMZ("D")) if prodctl.pacf do PACFDEP(.dep)
		
		#IF (+(%SystemDate + 1).day() = 1) 
		// If end of month, compute new month end balances before filing
		do AVGBALD(.dep) do dep.bypassSave()
		#ENDIF
	}
	#ELSE
	if (+BALPRIN = 0), (dep.stat = 4) quit
	#ENDIF

	#IF (CUVAR.DRMT + CUVAR.ESCH <> 0)
		// Flag account to move to a dormancy / inactive account 
		// status if applicable
		if '{List}"ESC,WASH".contains(dep.grp), (dep.stat <> 3) do DORM(.dep)
	#ENDIF

	set isICHND = 0

	type RecordTMPTTL tmpttl = Db.getRecord("TMPTTL", "TJD = "_TODAY_", JOB = :%ProcessID, CRCD = :dep.crcd, CLS = :dep.cls, GRP = :dep.grp, TYPE = :dep.type, GLSC = :dep.glsc, CC = :dep.cc", 1)

	set tmpttl.open = tmpttl.open + 1
	set tmpttl.bal = tmpttl.bal + BALPRIN
	set tmpttl.balcol = tmpttl.balcol + BALCOL
	set tmpttl.intavl = tmpttl.intavl + dep.intavl

	if (BALPRIN '< 0) do {	// Positive balance processing

		if (dep.resint <> 0), dep.deldt.isNull() set dep.deldt = TODAY
		if (+dep.resint = 0), 'dep.deldt.isNull() set dep.deldt = ""

		if 'dep.odstart.isNull() set dep.odstart = ""
		if 'dep.odexp.isNull() set dep.odexp = ""
	}

	else  do {		// Negative balance processing

		type RecordDAYENDNEG dayend = Db.getRecord("DAYENDNEG", "EFD = TOMORROW, CID = :CID", 1)
		
		set dayend.balneg = dep.bal
		do dayend.bypassSave()

		if (dep.odterm <> 0) do {
			
			if dep.odstart.isNull() set dep.odstart = TODAY
			if dep.odexp.isNull() set dep.odexp = $$EXT^UMDT(dep.odterm, TODAY) - 1
		}

		if 'dep.odexp.isNull(), (dep.odexp < TODAY) do {
		
			set tmpttl.balnegua = tmpttl.balnegua - BALPRIN
			if dep.deldt.isNull() set dep.deldt = TODAY
		}

		else  do {
			
			type Number ODLIM = dep.odlim

			if 'ODLIM.isNull(), (BALPRIN < -ODLIM) do {
			
				set tmpttl.balneg = tmpttl.balneg + ODLIM
				set tmpttl.balnegua = tmpttl.balnegua - (BALPRIN + ODLIM)
				if dep.deldt.isNull() set dep.deldt = TODAY
			}

			else  do {
				
				set tmpttl.balneg = tmpttl.balneg - BALPRIN
				if 'dep.deldt.isNull(), (BALPRIN '< -ODLIM), 'dep.resint set dep.deldt = ""
				else  if dep.deldt.isNull(), (BALPRIN - dep.resint < -ODLIM) set dep.deldt = TODAY
			}
		}
	}

	if (BALCOL < 0) do {		// Neg balance collected processing

		if 'dep.odexp.isNull(), (dep.odexp < TODAY) set tmpttl.balcnegu = tmpttl.balcnegu - BALCOL

		else  do {
			
			type Number ODLIM = dep.odlim

			if 'ODLIM.isNull(), (BALCOL < -ODLIM) do {
			
				set tmpttl.balcnega = tmpttl.balcnega + ODLIM
				set tmpttl.balcnegu = tmpttl.balcnegu - BALCOL + ODLIM
			}

			else  set tmpttl.balcnega = tmpttl.balcnega-BALCOL
		}
	}

	// Check if an entry exist in dep.collque or in dep.utblcollst.
	if ((BALPRIN < 0) ! (dep.collst <> 0) ! dep.collque) do {

		type RecordDAYENDQCOLL dayend = Db.getRecord("DAYENDQCOLL", "TJD = TODAY, CID = :CID", 1)
		do dayend.bypassSave()
	}

	#IF (CUVAR.DARCNPDT - CUVAR.DARCOFF = TODAY)
	// If account meets one of the following conditions, considered for reclassification.
	if ((BALPRIN < 0) ! (dep.darcls <> 0) ! (dep.darcovr <> 0)) do {

		type RecordDAYENDDOVRC dayend = Db.getRecord("DAYENDDOVRC", "NPDT = CUVAR.DARCNPDT, CID = :CID", 1)
		do dayend.bypassSave()
	}
	#ENDIF

	if 'prodctl.rclsbal.isNull(), (BALPRIN < prodctl.rclsbal) do {

		type RecordDAYENDRCLS dayend = Db.getRecord("DAYENDRCLS", "TJD = TODAY, BOO = :dep.boo, CRCD = :dep.crcd, CID = :CID", 1)
		
		set dayend.bal = BALPRIN
		do dayend.bypassSave()
	}

	#IF isSEGUSE
	if dep.segflg do { quit
		
		if (+dep.segacr = 0) set ER = $$SEGLEVDEP(.dep, .tmpttl)
		else  set ER = $$ACCTLEV(.dep, .tmpttl)
	}
	#ENDIF

	set IACM = dep.iacm
	set INDEX = dep.index
	set IRCB = dep.ircb
	set IRN = +dep.irn
	set MINACR = dep.minacr
	set MAXACR = dep.maxacr
	set OLDCMP = dep.cmp
	set OLDIRN = IRN

	if (IRCB = 1) set BALINT = BALPRIN
	else  if (IRCB = 3) set BALINT = dep.balcol
	else  if (IRCB = 4), (BALPRIN <> 0) set BALINT = dep.salesprc
	else  set BALINT = 0

	if 'MAXACR.isNull(), (BALINT > MAXACR) set BALINT = MAXACR

	if (dep.ichnd = TODAY) do { quit:ER

		set dep.ichnd = %SystemDate.nextFreqDate(dep.intfre) quit:ER
		set dep.ichld = TODAY
		set isICHND = 1
	}

	if (dep.inc = TODAY) do { quit:ER
		
		set dep.inc = %SystemDate.nextFreqDate(dep.icf) quit:ER
		set dep.cmp = dep.posacr
		set dep.ilc = TODAY
	}

	if 'INDEX.isNull() set dep.irn = $$INDEXDEP(.dep, .IRN, dep.ichld, dep.intspr, dep.rndmtd, dep.intmat, BALINT, INDEX, isICHND, "", 0) quit:ER

	// Determine calc parameters if acct uses scheduled period int calc
	if (+IACM.extract(1) = 0) do { quit:ER

		type Date INP, LASTDATE

		set ANFACTOR = dep.intaf
		set LASTDATE = ""

		#IF CUVAR.IPD
		if dep.ipda.isNull() set INP = dep.inp
		else  set INP = TODAY
		#ELSE
		set INP = dep.inp
		#ENDIF

		do IM0(.IACM, dep.icpf, dep.ipf, INP, .LASTDATE, .ANFACTOR, TODAY) quit:ER
		set DAYSINP = INP - LASTDATE
	}

	#IF CUVAR.DAYEND4
	if prodctl.aec, (dep.mdt = AECDATE), ((dep.imo = 1) ! (dep.imo = 3) ! (dep.rencd = 1)) do {

		type RecordDAYENDAEC dayend = Db.getRecord("DAYENDAEC", "TJD = TOMORROW, CID = :CID", 1)
		do dayend.bypassSave()
	}

	if prodctl.aeci, ((dep.iopt = 1) ! (dep.iopt = 3)) do {

		type Date X = dep.intchknd
		
		if X.isNull() set X = dep.inp
		
		if (X = AECDATE) do {

			type RecordDAYENDAEC dayend = Db.getRecord("DAYENDAEC", "TJD = TOMORROW, CID = :CID", 1)
			do dayend.bypassSave()
		}
	}
	#ENDIF

	#IF 'CUVAR.NOREGD do REGDCHK(.dep)

	if (+IRCB = 0) set ACR = 0 do STATDEP(.dep, .tmpttl, ACR, BALINT, IACM, ANFACTOR, DAYSINP, "", "", "", 0) quit

	// Continuous method or daily compounding?
	#IF CUVAR.IPD
	if dep.ipda.isNull(), ((IACM.extract(1) = 2) ! (dep.inc - dep.ilc = 1)) do {
	#ELSE
	if ((IACM.extract(1) = 2) ! (dep.inc - dep.ilc = 1)) do {
	#ENDIF

		// Save compounding data for daily and continuous methods
		if (IACM.extract(1) = 2) set dep.cmp = dep.posacr
		
		#IF $$SAVDBDA^BTTOPTMZ
		if prodctl.savdbda do {

			// Save old daily compounded amounts
			set dep.cmp4 = dep.cmp3
			set dep.cmp3 = dep.cmp2
			set dep.cmp2 = dep.cmp1

			if (OLDCMP + dep.daa <> dep.posacr) set dep.cmp1 = OLDCMP
			else  set dep.cmp1 = ""
		}
		#ENDIF
	}

	#IF CUVAR.IPD
	// Low balance buckets
	if dep.ipda.isNull() do { quit:ER
		
		if ((IRCB = 5) ! (IRCB = 6)) do {
			
			set ACR = ""
			do ^DEPLBB(.dep, .ACR, .IRCB, .BALINT, 1) quit:ER
			
			if (ACR < 0) do {		// Negative accrual low balance processing

				type Number ACRRNDED = ACR.roundDec(5, "", 0)

				set dep.posacr = dep.posacr + ACRRNDED
				set dep.ipdaadj = ACRRNDED
				
				if ((IRCB = 5) ! (IRCB = 6)) set ACR = 0
			}

			// Since DEPLBB can change IRCB when the balance is
			// negative, check again
			if ((IRCB = 5) ! (IRCB = 6)) set BALINT = dep.lbbcm

			if 'INDEX.isNull() set dep.irn = $$INDEXDEP(.dep, .IRN, dep.ichld, dep.intspr, dep.rndmtd, dep.intmat, BALINT, INDEX, isICHND, "", 0)
		}
	}

	else  do {
		
		set ACR = dep.ipda
		if ((IRCB = 5) ! (IRCB = 6)), (dep.bal < dep.lbbcm) do {
			if (dep.bal '< 0) set dep.lbbcm = dep.bal
			else  set dep.lbbcm = 0
		}
	}
	
	if ((IRCB = 5) ! (IRCB = 6)) do STATDEP(.dep, .tmpttl, ACR, BALINT, IACM, ANFACTOR, DAYSINP, "", "", "", 0) quit
	#ENDIF

	/*
	If dep.ipda is not null, then accrual was included at posting and we
	are on the interest posting day for the account. In this case, we will
	not recalculate ACR (it was calculated at posting and is set in low
	balance bucket section).
	*/
	if dep.ipda.isNull() set ACR = $$DETACRDEP(.dep, IRN, dep.posacr, BALINT, IACM, MINACR, dep.negacrpo, ANFACTOR, DAYSINP)
	else  set ACR = dep.ipda

	// If backup withholding flag is set and accr. withholding tax
	// processing is selected get the daily withholding amount.
	if (ACR > 0), dep.bwf, dep.awtp do { quit:ER
		
		type Number INTEREST, TAXRATE
		
		set TAXRATE = ""
		set INTEREST = ACR

		if 'dep.awti.isNull() set TAXRATE = $$AWT^DEPBW(dep.awti, INTEREST, .AWT, IRN, TODAY)
		else  do ^DEPBW(.dep, , INTEREST, .AWT, , CUVAR.BWAPGM, dep.awti, IRN, .TAXRATE)
		quit:ER

		set AWT = AWT.roundDec(5, "", 0)

		if (TAXRATE <> dep.awtr) do {
		
			set dep.fmld = TODAY
			do HIST(CID, "D", "AWTR", dep.awtr, TAXRATE, "")
			set dep.awtr = TAXRATE
		}
	}

	// Uncollected accruals calculation
	set UNCACR = ""
	set BALAVL = dep.balavl
	if (BALAVL < 0), 'dep.ufindex.isNull(), (dep.niao <> 0), (dep.niao <> 3) do { quit:ER

		// Calculate interest for use of uncollected funds taking into 
		// account Daily Uncollected Minimum Interest (dep.dumi)

		type Number CALCBASE

		if (BALPRIN '< 0) set CALCBASE = -BALAVL
		else  set CALCBASE = BALPRIN - BALAVL

		if (CALCBASE <> 0) do { quit:ER
  			// Cache for UINDX
  			type public String IX(), RATEINDX()
			type public Number IXCNT

			// Returned by CTL^UINDX
			type Number RATE = "", RRATE, SRATE, URATE

			type literal Number IXCNTMAX = 250		
			type String PAR()
			type Boolean isLOADED

			/*
			If the index array has not been loaded, or it is tiered, comparative or
			investment-sweep, call ^UINDX to calculate rate.
	
			If the index is basis store the standard (no offsets, rounding, and 
			limits) rate in RATEINDX(dep.ufindex, TODAY).
			*/
			set isLOADED = IX(dep.ufindex).exists()
	
			/* If loaded and Date Item Authorization Flag (INDEX.DIAUTH) set, 
			   re-load (column reference in index definition was converted to 
			   prior account's value)
			*/
			if isLOADED, (IX(dep.ufindex).piece("|", 14) <> 0) set isLOADED = 0, IXCNT = IXCNT.get() - 1
			
			else  if isLOADED set RATE = RATEINDX(dep.ufindex, TODAY).get()

			set PAR("INDEX") = dep.ufindex
			set PAR("IXLOAD") = isLOADED
			set PAR("NOTSER") = 1
			set PAR("MATFLG") = 1		// Ignore matrix
			
			// Skips standard rate calculation if RATE is defined, but still 
			// applies all offsets, rounding, and limits
			set PAR("SRATE") = RATE
			
			do CTL^UINDX(.dep, TODAY, CALCBASE, .PAR()) quit:ER
			
			// Maintain interest index caching
			if 'isLOADED do {
				if IXCNT.get() '< IXCNTMAX kill IX, RATEINDX set IXCNT=0 quit
				
				/* If Index Type (INDEX.BASREL) is 0 (Basis 
				   Index), store standard index value (without 
				   offsets, rounding, and limits); otherwise, 
				   mark index as loaded
				*/
				if (+IX(dep.ufindex).piece("|", 3) = 0) set RATEINDX(dep.ufindex, TODAY) = SRATE
				else  set RATEINDX(dep.ufindex, TODAY) = ""
				
				set IXCNT = IXCNT.get() + 1
			}

			set UNCACR = $$CALC(.dep, IACM, CALCBASE, RATE, ANFACTOR, DAYSINP, "", "")
			set UNCACR = UNCACR.roundDec(5, "", 0)

			if (dep.dumi <> 0), (UNCACR < dep.dumi) set UNCACR = dep.dumi
		}
	}

	if (IACM.extract(1) = 0) do ADJ(.tmpttl, ACR, BALINT, dep.ipdtrf, IACM, IRN, OLDIRN)
	
	do STATDEP(.dep, .tmpttl, ACR, BALINT, IACM, ANFACTOR, DAYSINP, "", UNCACR, AWT, 0)

	quit


STATDEP(RecordDEP dep,		// Deposit account		/REF:RW
	RecordTMPTTL tmpttl,	// System balance totals	/REF:RW
	Number ACR,		// Accrual amount		
	Number BALINT,		// Balance for interest		
	String IACM,		// Interest accrual method	
	Number ANFACTOR,	// Annual factor		
	Number DAYSINP,		// Days in period		
	Number AIACR,		// Avail int accrual amt [*]	
	Number UNCACR,		// Uncollected accrual		
	Number AWT,		// Accrued withholding tax	
	Boolean SEGFLG)		// Segments in use

	/*
	Accumulate deposit accruals into account
	
	Updates (files) statistical data in the deposit account and teller 
	totals tables.

	For IPD accts, dep.ipdtrf contains the interest amount transfered
	and the amount posted today. The interest posting process does not
	accrue on these amounts and we need to exclude it from the balance
	to set dep.dbi.

	ARGUMENT NOTES:
		. AIACR		for use with segmented account only
	*/

	/*
	Segments are in use for this section if Segments used for both loans 
	and deposits (0), or Segments used for deposits only (2), or deposit 
	product types exist that use segments
	*/
	type literal Boolean isSEGUSE = ('CUVAR.NOSEGMENTS ! (CUVAR.NOSEGMENTS = 2)) ! ($$SEGUSE^BTTOPTMZ("D"))
	
	type literal Date TODAY = %SystemDate

	type public Cache %CACHE()
	type public Boolean ER
	type public String IX()		// Cache for UINDX
	
	type Number NACR, NEGUNDAA

	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", ":dep.type")

	#IF $$SAVDBDA^BTTOPTMZ
	if prodctl.savdbda do {
		
		// Update the Int/Div Accrual balance for last 5 days
		set dep.dbi4 = dep.dbi3
		set dep.dbi3 = dep.dbi2
		set dep.dbi2 = dep.dbi1
		set dep.dbi1 = dep.dbi

		// Update daily accrued Int/Div amount for last 5 days
		set dep.daa4 = dep.daa3
		set dep.daa3 = dep.daa2
		set dep.daa2 = dep.daa1
		set dep.daa1 = dep.daa

		// Update daily accrued withholding for last 5 days
		set dep.dawa4 = dep.dawa3
		set dep.dawa3 = dep.dawa2
		set dep.dawa2 = dep.dawa1
		set dep.dawa1 = dep.dawa

		#IF CUVAR.IPD
		set dep.dbi = BALINT - dep.ipdtrf
		#ELSE
		set dep.dbi = BALINT
		#ENDIF
	}
	#ENDIF

	set dep.acs = TODAY
	set dep.daa = ACR

	#IF CUVAR.IPD
	if dep.ipda.isNull() set dep.awt = dep.awt + AWT
	#ELSE
	set dep.awt = dep.awt + AWT
	#ENDIF
	
	set dep.dawa = AWT

	// For IPD accts the interest buckets (posacr and negacr) are
	// incremented on interest posting process on posting dates.
	set (NACR, NEGUNDAA) = 0

	// Set proper positive/negative accrual fields
	#IF CUVAR.IPD
	if dep.ipda.isNull() do { quit:ER
	#ELSE
	do { quit:ER
	#ENDIF
	
		if (dep.negacrpo <> 0), (ACR < 0) do { quit:ER

			type Number NEGACR, NIAO
			
			set NIAO = dep.niao
			set NEGACR = -ACR

			if (dep.idomi <> 0), (dep.dbi1 > BALINT), (NEGACR < dep.idomi) set NEGACR = dep.idomi
			else  if (dep.sdomi <> 0), (NEGACR < dep.sdomi) set NEGACR = dep.sdomi

			// Accrue int for use of overdraft funds according to Neg Int Application Opt
			if ((+UNCACR = 0) ! ((UNCACR <> 0) & ((NIAO = 1) ! (NIAO = 3) ! ((NIAO = 4) & (UNCACR < NEGACR))))) do { quit:ER

				// Beyond expiration date - all unauthorized
				if 'dep.odexp.isNull(), (dep.odexp '> TODAY) set NEGUNDAA = NEGACR

				// Not using ODLIM processing (DEP.ODLIM = "")- all authorized
				else  if dep.odlim.isNull() set NACR = NEGACR

				// No overdraft limit - all unauthorized
				else  if (+dep.odlim = 0) set NEGUNDAA = NEGACR

				// Balance within overdraft limit - all authorized
				else  if (dep.bal '< -dep.odlim) set NACR = NEGACR

				// Calculate authorized/unauthorized
				else  do { quit:ER

					/* Reset RATE if incremental index for the purpose of
					   calculating negative unauthorized accrual. Otherwise,
					   use current RATE
					*/
					type Number BALINT = -dep.odlim, RATE = ""
					type String INDEX = dep.index

					if 'INDEX.isNull(), (IX(INDEX).piece("|", 2) = "I") do { quit:ER
					  	// Cache for UINDX
			  			type public String IX(), RATEINDX()
						type public Number IXCNT
						
						// Returned by CTL^UINDX
						type Number RRATE, SRATE, URATE

						type literal Number IXCNTMAX = 250
						type String PAR()
						type Boolean isLOADED

						/*
						If the index array has not been loaded, or it is tiered, comparative or
						investment-sweep, call ^UINDX to calculate rate.
	
						If the index is basis store the standard (no offsets, rounding, and 
						limits) rate in RATEINDX(INDEX, ICHLD).
						*/
						set isLOADED = IX(INDEX).exists()
	
						/* If loaded and Date Item Authorization Flag (INDEX.DIAUTH) set, 
						   re-load (column reference in index definition was converted to 
						   prior account's value)
						*/
						if isLOADED, (IX(INDEX).piece("|", 14) <> 0) set isLOADED = 0, IXCNT = IXCNT.get() - 1
						else  if isLOADED set RATE = RATEINDX(INDEX, dep.ichld).get()
						
						set PAR("INDEX") = INDEX
						set PAR("LOADIX") = isLOADED
						set PAR("NOTSER") = 1
						set PAR("IPMODE") = 1

						// Skips standard rate calculation if RATE is defined, but still 
						// applies all offsets, rounding, and limits
						set PAR("SRATE") = RATE
							
						do CTL^UINDX(.dep, dep.ichld, BALINT, .PAR())
						
						// Maintain interest index caching
						if 'isLOADED do {
							if IXCNT '< IXCNTMAX kill IX, RATEINDX set IXCNT=0 quit
		
							/* Index Type (INDEX.BASREL) cannot be 0 (Basis Index) 
							   for dep.odlim, so do not store RATE - mark index as 
							   loaded
							*/
							set RATEINDX(INDEX, dep.ichld) = ""
							set IXCNT = IXCNT.get() + 1
						}
					}
					
					// Use calculated (ODLIM) rate or "regular" rate if not defined
					if RATE.isNull() set RATE = dep.irn

					// Calculate authorized accrual
					set NACR = -$$CALC(.dep, IACM, BALINT, RATE, ANFACTOR, DAYSINP, dep.cmp, dep.posacr)
					set NACR = NACR.roundDec(5, "", 0)

					// Daily unauthorized accrual
					set NEGUNDAA = NEGACR - NACR
				}

				// Accumulate Authorized Accrual
				set dep.negacr = dep.negacr + NACR

				// Accumulate Unauthorized Accrual
				set dep.negacrun = dep.negacrun + NEGUNDAA
			}

			//Accrue int. for use of uncoll. funds according to Neg. Int. Appl.^
			if UNCACR.isNull() set UNCACR = 0
			if ((UNCACR <> 0) & ((NIAO = 1) ! (NIAO = 2) ! ((NIAO = 4) & (UNCACR > NEGACR)))) set dep.uncacr = dep.uncacr + UNCACR
		}

		else  do {
			
			set dep.posacr = dep.posacr + ACR
			if (UNCACR <> 0) set dep.uncacr = dep.uncacr + UNCACR
			#IF isSEGUSE
			if SEGFLG set dep.aiacr = dep.aiacr + AIACR
			#ENDIF
		}
	}
	
	//Accumulate Accrual totals for G/L Transfer
	if (ACR < 0), (dep.negacrpo <> 0) do {

		if 'dep.ipda.isNull() set NEGUNDAA = dep.negundaa, NACR = -ACR - NEGUNDAA
		set tmpttl.negdaa = tmpttl.negdaa + NACR
		set tmpttl.negundaa = tmpttl.negundaa + NEGUNDAA
	}

	#IF isSEGUSE
	else  do {
		
		set tmpttl.acr = tmpttl.acr + ACR
		if SEGFLG set tmpttl.aiacr = tmpttl.aiacr + AIACR
	}
	#ELSE
	else  set tmpttl.acr = tmpttl.acr + ACR
	#ENDIF

	set tmpttl.balacr = tmpttl.balacr + dep.posacr
	set tmpttl.negacr = tmpttl.negacr + dep.negacr
	set tmpttl.negacrun = tmpttl.negacrun + dep.negacrun
	set tmpttl.uncacr = tmpttl.uncacr + dep.uncacr

	#IF (CUVAR.LPND = %SystemDate & $$PACF^BTTOPTMZ("D"))
	
	if prodctl.pacf do PACFDEP(.dep)
	#ENDIF

	set dep.ipda = ""
	set dep.ipdtrf = ""
	set dep.negundaa = ""

	// If end of month, compute new month end balances before filing
	#IF (+(%SystemDate + 1).day() = 1) do AVGBALD(.dep)

	#IF $$DAY5BAL^BTTOPTMZ
	// Populate End of Day fields
	if (prodctl.day5bal > 0) do {
		
		set dep.eodbal5 = dep.eodbal4
		set dep.eodbal4 = dep.eodbal3
		set dep.eodbal3 = dep.eodbal2
		set dep.eodbal2 = dep.eodbal
		set dep.eodbal = dep.bal

		set dep.eodbalcol5 = dep.eodbalcol4
		set dep.eodbalcol4 = dep.eodbalcol3
		set dep.eodbalcol3 = dep.eodbalcol2
		set dep.eodbalcol2 = dep.eodbalco
		set dep.eodbalco = dep.balcol

		set dep.eodhldam5 = dep.eodhldam4
		set dep.eodhldam4 = dep.eodhldam3
		set dep.eodhldam3 = dep.eodhldam2
		set dep.eodhldam2 = dep.eodhldam
		set dep.eodhldam = dep.chkhld

		if (prodctl.day5bal > 1) do {
			
			set dep.eodbalavl5 = dep.eodbalavl4
			set dep.eodbalavl4 = dep.eodbalavl3
			set dep.eodbalavl3 = dep.eodbalavl2
			set dep.eodbalavl2 = dep.eodbalav
			set dep.eodbalav = dep.balavl
		}
	}
	#ENDIF

	#IF $$VALID^%ZRTNS("ZBTTPP") do DEP^ZBTTPP(.dep)

	do tmpttl.bypassSave()
	do dep.bypassSave()

	quit


INDEXDEP(RecordDEP dep,		// Deposit object		/MECH=REFNAM:RW
	 Number IRN,		// Interest rate		/MECH=REFNAM:RW
	 Date ICHLD,		// Int Change Last Date	
	 String SPREAD,		// Interest spread	
	 String RNDMTD,		// Rounding Method
	 String MATRIX,		// Interest matrix	
	 Number BALINT,		// Balance for interest		
	 String INDEX,		// Interest index		
	 Boolean isICHND,	// On interest change date	
	 Number SEGMENT,	// Segment Number		
	 Boolean isAICALC)	// Available int calc flag	
	 
	/*
	Calculate deposit rate based on index
	
	Determines the appropriate interest rate for any type of interest
	index, including account segment indexes and available interest
	indexes, for the purposes of interest accrual.

	RETURNS:
		. $$		New Interest Rate		/TYP=N
	*/

	/*
	Segments are in use for this section if Segments used for both loans 
	and deposits (0) or Segments used for deposits only (2) or deposit 
	product types exist that use segments
	*/
	type literal Boolean isSEGUSE = ('CUVAR.NOSEGMENTS ! (CUVAR.NOSEGMENTS = 2)) ! ($$SEGUSE^BTTOPTMZ("D"))

	type literal Date TODAY = %SystemDate

	type public Boolean ER
	type public String ET

	// Cache for UINDX
	type public String IX(), RATEINDX()
	type public Number IXCNT

	// Returned by CTL^UINDX
	type Number RATE = "", RRATE, SRATE, URATE

	type literal Number IXCNTMAX = 250		
	type Boolean isLOADED
	type Date EFD = ICHLD
	type String PAR()

	/*
	Teaser rate processing applies to standard index only - hence
	quit:dep.trexd>today
	Interest offset processing applies to standard index only
	*/
	#IF isSEGUSE
	if SEGMENT.isNull(), 'isAICALC quit:(dep.trexd > TODAY) IRN set ICHLD = ICHLD - dep.intoff
	#ELSE
	quit:(dep.trexd > TODAY) IRN
	set ICHLD = ICHLD - dep.intoff
	#ENDIF

	/*
	If the index array has not been loaded, or it is tiered, comparative or
	investment-sweep, call ^UINDX to calculate rate.
	
	If the index is basis store the standard (no offsets, rounding, and 
	limits) rate in RATEINDX(INDEX, ICHLD).
	*/
	set isLOADED = IX(INDEX).exists()
	
	/* If loaded and Date Item Authorization Flag (INDEX.DIAUTH) set, 
	   re-load (column reference in index definition was converted to 
	   prior account's value)
	*/
	if isLOADED, (IX(INDEX).piece("|", 14) <> 0) set isLOADED = 0, IXCNT = IXCNT.get()- 1
	else  if isLOADED set RATE = RATEINDX(INDEX, EFD).get()
	
	// If the rate is not scheduled to change and the index is a 
	// basis index, don't bother calculating / changing it
	if 'isICHND, isLOADED, (+IX(INDEX).piece("|", 3) = 0) quit IRN
		
	set PAR("INDEX") = INDEX
	set PAR("SPREAD") = SPREAD
	set PAR("RNDFC") = RNDMTD
	set PAR("IXLOAD") = isLOADED
	set PAR("NOTSER") = 1
	set PAR("IPMODE") = 1
	set PAR("MATRIX") = MATRIX

	// Limits processing applies to standard index only
	#IF isSEGUSE
		if 'SEGMENT.isNull() set PAR("SEG") = SEGMENT
		else  if 'isAICALC set PAR("LIMIT") = 1
	#ELSE
		set PAR("LIMIT") = 1
	#ENDIF

	// Skips standard rate calculation if RATE is defined, but still 
	// applies all offsets, rounding, and limits
	set PAR("SRATE") = RATE
		
	do CTL^UINDX(.dep, EFD, BALINT, .PAR()) quit:ER IRN

	// Rate has not been entered for effective date
	if EFD.isNull() set ER = 1, ET = "INDEX7" quit IRN

	// Maintain interest index caching
	if 'isLOADED do {
		if IXCNT.get() '< IXCNTMAX kill IX, RATEINDX set IXCNT=0 quit
		
		/* If Index Type (INDEX.BASREL) is 0 (Basis Index), store 
		   standard index value (without offsets, rounding, and 
		   limits); otherwise, mark index as loaded
		*/
		if (+IX(INDEX).piece("|", 3) = 0) set RATEINDX(INDEX, ICHLD) = SRATE
		else  set RATEINDX(INDEX, ICHLD) = ""
		
		set IXCNT = IXCNT.get() + 1
	}
	
	// If the rate is not scheduled to change and the index is a basis 
	// index, don't change it
	if 'isICHND, 'RATEINDX(INDEX, ICHLD).get().isNull() quit IRN

	if (IRN - RATE <> 0) do {

		set dep.fmld = TODAY
		
		#IF isSEGUSE
		do HIST(dep.cid, "D", "IRN", IRN, RATE, SEGMENT)
		#ELSE
		do HIST(dep.cid, "D", "IRN", IRN, RATE)
		#ENDIF

		set IRN = RATE
	}
	
	quit IRN


DORM(RecordDEP dep)	// Deposit object			/MECH=REFNAM:R

	/*
	Dormancy/Escheating
	*/

	type literal Date TODAY = %SystemDate
	type literal Date TOMORROW = %SystemDate + 1

	type public Cache %CACHE()
	
	type Date CCLD
	type Number DIN, DRMT, X
	
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", ":dep.type")

	set CCLD = dep.ccld
	if CCLD.isNull() set CCLD = dep.odt

	set DRMT = prodctl.drmt
	if DRMT.isNull() set DRMT = CUVAR.drmt

	set DIN = prodctl.din
	if (+DIN = 0) set DIN = CUVAR.din

	set X = TODAY - CCLD
	
	if (X '< DIN) do {

		type Number Y
		
		if (X '< CUVAR.esch) set Y = 3
		else  if (X '< DRMT) set Y = 2
		else  set Y = 1

		if (Y <> dep.stat) do {

			type RecordDAYENDSTAT dayend = Db.getRecord("DAYENDSTAT", "TJD = TOMORROW, CID = :dep.CID", 1)
			
			set dayend.stat = Y
			do dayend.bypassSave()
		}
	}
	
	quit


REGDCHK(RecordDEP dep)	// Deposit object			/MECH=REFNAM:R

	/*
	Build Reg 'D' Summary
	*/

	type public Number SCHPID
	
	type Number PERS = +dep.pers

	if (dep.regd = 6) do {

		type Number CATEGORY, TERM

		if dep.mdt.isNull() set TERM = ""
		else  if 'dep.dlr.isNull() set TERM = dep.mdt - dep.dlr
		else  set TERM = dep.mdt - dep.odt

		if (TERM < 547.5) do {
			if (dep.bal < 100000) set CATEGORY = 0
			else  set CATEGORY = 2
		}
		else  do {
			if (dep.bal < 100000) set CATEGORY = 1
			else  set CATEGORY = 3
		}

		type RecordTMPRPT4 tmprpt4 = Db.getRecord("TMPRPT4", "PID = :SCHPID, KEY1 = :%ProcessID, KEY2 = :PERS, KEY3 = :dep.regd, KEY4 = :CATEGORY", 1)
		
		set tmprpt4.data = tmprpt4.data + dep.bal
		do tmprpt4.bypassSave()
	}

	else  do {

		type RecordTMPRPT3 tmprpt3 = Db.getRecord("TMPRPT3", "PID = :SCHPID, KEY1 = :%ProcessID, KEY2 = :PERS, KEY3 = :+dep.regd", 1)
		
		set tmprpt3.data = tmprpt3.data + dep.bal
		do tmprpt3.bypassSave()
	}

	quit


DETACRDEP(RecordDEP dep,		// Deposit account		/REF:RW
         Number IRN,		// Interest rate		
         Number POSACR,		// Positive accrual		
         Number BALINT,		// Balance for interest		
         String IACM,		// Accrual calculation method	
         Number MINACR,		// Minimum balance to accrue	
         Number NEGACRPO,	// Negative accrual option	/REF:W
         Number ANFACTOR,	// Annual factor		
         Number DAYSINP)	// Days in period		
       
	/*
	Determine deposit accrual amount

	RETURNS:
		. $$		Accrual amount			/TYP=N
	*/

	type Number ACR

	/*
	In case dep.minacr is defined and it is more than BALINT (Balance for
	Interest Accrual), the value of ACR could be set to negative
	dep.posacr. In this case we want to set the negacrpo to be equal to
	zero, to "trick" the system into avoiding processing for negative int.
	*/

	if 'MINACR.isNull(), (BALINT < MINACR) do {
	
		if (dep.minopt <> 0) set ACR = 0		// minopt = 1,zero accrual
		else  set ACR = -dep.posacr, NEGACRPO = 0	// minopt = 0,keep accrual
	}

	else  do {
		
		type Number X = BALINT
		
		#IF CUVAR.IPD set X = X - dep.ipdtrf
		
		set ACR = $$CALC(.dep, IACM, X, IRN, ANFACTOR, DAYSINP, dep.cmp, POSACR)
		set ACR = ACR.roundDec(5, "", 0)
	}

	quit ACR


CALC(RecordACN acn,	// Account					/REF:R
     String IACM,	// Interest accrual method		
     Number BALINT,	// Balance to calc int			
     Number IRN,	// Interest rate			
     Number ANFACTOR,	// Annual factor			
     Number DAYSINP,	// Days in period			
     Number CMP,	// Compounded interest			
     Number POSACR)	// Positive accrual amount		

	/*
	Returns one day's interest amount
	
	Calculates the accrual amount based on the interest accrual method for
	any type of accrual, including account segment accrual and accrual on
	on available interest. Note that dep.cmp is used in the computations,
	but should be null for segmented accounts.

	RETURNS:
		. $$		Accrual Amount			/TYP = N
	*/

	#IF (%SystemDate.year() # 4)
	type literal Number DENOM = 36500
	#ELSE
	type literal Number DENOM = 36600
	#ENDIF

	//  Actual number days in period
	if IACM = "10" quit (BALINT + CMP) * IRN / 36000
	else  if IACM = "11" quit (BALINT + CMP) * IRN / DENOM
	else  if IACM = "13" quit (BALINT + CMP) * IRN / 36500

	// Standard number of days in period
	else  if IACM = "00" quit (BALINT + CMP) * IRN / ANFACTOR / 100 / DAYSINP
	else  if IACM = "01" quit (BALINT + CMP) * IRN * 360 / ANFACTOR / DENOM / DAYSINP
	else  if IACM = "03" quit (BALINT + CMP) * IRN * 360 / ANFACTOR / 36500 / DAYSINP

	// Continuous compounding
	else  if IACM = "20" quit (BALINT + POSACR) * ($$EXP^%ZFUNC(IRN / 36000) - 1)
	else  if IACM = "21" quit (BALINT + POSACR) * ($$EXP^%ZFUNC(IRN / DENOM) - 1)
	else  if IACM = "23" quit (BALINT + POSACR) * ($$EXP^%ZFUNC(IRN / 36500) - 1)
	
	// Process the custom interest calculation
	else  if IACM = "99" quit $$CALCINP^ZUIC(.acn, IACM, BALINT, IRN, CMP, POSACR, ANFACTOR, DAYSINP, DENOM)

	quit 0


IM0(String IACM,	// Interest accrual method		/MECH=REFNAM:RW
    String ICPF,	// Int Calc Period Freq			
    String IPF,		// Interest Posting Freq		
    Date INP,		// Int Next Posting Date		
    Date IPLD,		// Int Last Posting Date		/MECH=REFNAM:RW
    Number ANFACTOR,	// Annual Factor			/MECH=REFNAM:RW
    Date EXECDATE)	// Execute Date				/NONULL

	/*
	Interest methods with first character "0"
	
	Processing associated with Interest Accrual Method that indicates the
	standard number of days in a month (30) should be used for accrual
	calculations.
	*/

	type public Boolean ER
	
	type Date NJD

	// Use override parameters if Int/Div Calc Period Frequency defined
	if 'ICPF.isNull() set IPF = ICPF
	else  if IPF.isNull() set IACM = 1_IACM.extract(2) quit

	// Define next date if not defined
	if INP.isNull() set INP = EXECDATE.nextFreqDate(IPF, .ANFACTOR) quit:ER

	// Define last date if not defined
	if IPLD.isNull() set IPLD = INP.nextFreqDate("-"_IPF, .ANFACTOR) quit:ER

	// Ensure that last date is before TODAY
	for  quit:(IPLD '> EXECDATE)  set INP = IPLD, IPLD = INP.nextFreqDate("-"_IPF) quit:ER

	// Ensure that next date is after last
	if (INP '> IPLD) set INP = IPLD.nextFreqDate(IPF) quit:ER

	// Define annual factor if needed
	if (+ANFACTOR = 0) set NJD = EXECDATE.nextFreqDate(IPF, .ANFACTOR) quit:ER

	quit
	

PACFDEP(RecordDEP dep)	// Deposit object			/MECH=REFNAM:R

	/*
	Set up Profitability Analysis File for deposits
	*/

	type literal Date TODAY = %SystemDate

	type RecordPAA paa = Db.getRecord("PAA", "EFD = TODAY, CID = :dep.cid", 1)
	
	set paa.bal = dep.bal
	set paa.ipl = dep.ipl
	set paa.acr = (dep.posacr - dep.negacr - dep.negacrun - dep.uncacr).roundDec(2, "", 0)
	
	do paa.bypassSave()
	
	quit


INDEXAI(RecordDEP dep,	// Deposit object			/MECH=REFNAM:RW
	Number IRN,	// Interest rate			/MECH=REFNAM:RW
	Number BALINT,	// Balance for interest			
	String INDEX)	// Interest index			

	/*
	For segmented accounts - Available interest index
	*/

	type literal Date TODAY = %SystemDate
	
	type public Boolean ER

	type Boolean isICHND = 0

	set IRN = dep.aiirn

	if (dep.aiichnd = TODAY) do { quit:ER
		
		set dep.aiichnd = %SystemDate.nextFreqDate(dep.aiintfre) quit:ER
		set dep.aiichld = TODAY
		set isICHND = 1
	}

	set INDEX = dep.aiindex
	
	if 'INDEX.isNull() set dep.aiirn = $$INDEXDEP(.dep, .IRN, dep.aiichld, dep.aiintspr, dep.airndmtd, dep.aiintmat, BALINT, INDEX, isICHND, "", 1)

	quit


SEGLEVDEP(RecordDEP dep,	// Deposit object			/REF:RW
          RecordTMPTTL tmpttl)	// System balance totals object		/REF:W

	/*
	Accrue deposit account at segment level
	
	Process segmented account accruing at the segment level. For each
	segment, interest may accrue on the segment Ledger Balance and/or
	the segment Available Interest Balance.
		
	RETURNS:
		. $$		Error flag			/TYP=L
	*/
	
	type literal Date TODAY = %SystemDate
	
	type Boolean ER = 0
	type Number ANFACTOR, ACR, ACRSEG, AIACR, AIACRSEG, BALINT
	type Number DAYSINP, IRCB, MAXACR
	type String IACM

	set (ACR, ACRSEG, AIACR, AIACRSEG) = 0
	set IACM = dep.iacm
	set IRCB = dep.ircb
	set MAXACR = dep.maxacr
	
	// Pre-calculate dep.aiirn if applicable
	if dep.aiacrf, (dep.airdet <> 0) do INDEXAI(.dep, "", dep.intavlncr, dep.index) if ER quit ER

	type DbSet ds = Db.selectDbSet("DEPSEG", "CID = :dep.cid")

	// Not a valid segment for accrual
	if ds.isEmpty() do Runtime.setErrMSG("DEPSEG", 7890) quit ER

	while ds.next() do { quit:ER
		
		type Boolean isICHND
		type Number IRN, OLDIRN, SEGBAL
		type String INDEX

		type RecordDEPSEG depseg = ds.getRecord("DEPSEG")

		set (ANFACTOR, DAYSINP) = ""

		// --- Begin accrual on principal on segment level
		set isICHND = 0

		set IRN = depseg.irn
		set INDEX = depseg.index
		set OLDIRN = IRN

		set SEGBAL = depseg.bal - depseg.noacrbal

		if (+IRCB = 0) ! 'depseg.segval set BALINT = 0
		else  do {
			
			if 'MAXACR.isNull(), (SEGBAL > MAXACR) set BALINT = MAXACR
			else  set BALINT = SEGBAL
		}

		if (depseg.noacrexp = TODAY) do {
			
			set depseg.noacrbal = ""
			set depseg.noacrexp = ""
		}


		if (depseg.ichnd = TODAY) do { quit:ER
			
			set depseg.ichnd = %SystemDate.nextFreqDate(depseg.intfre) quit:ER
			set depseg.ichld = TODAY
			set isICHND = 1
		}

		if 'INDEX.isNull() set depseg.irn = $$INDEXDEP(.dep, .IRN, depseg.ichld, depseg.intspr, depseg.rndmtd, depseg.intmat, BALINT, INDEX, isICHND, depseg.segment, 0) quit:ER

		// Determine calc parameters if acct uses scheduled period int calc
		if (+IACM.extract(1) = 0) do { quit:ER
		
			type Date LASTDATE = ""
			
			set ANFACTOR = dep.intaf

			do IM0(.IACM, dep.icpf, depseg.ipf, depseg.inp, .LASTDATE, .ANFACTOR, TODAY) quit:ER
			set DAYSINP = depseg.inp - LASTDATE
		}

		if ((+IRCB = 0) ! 'depseg.segval) set ACRSEG = 0
		else  do {

			// Determine segment accrual
			set ACRSEG = $$DETACRDEP(.dep, IRN, depseg.posacr, BALINT, IACM, dep.minacr, dep.negacrpo, ANFACTOR, DAYSINP)
			set depseg.posacr = depseg.posacr + ACRSEG
			set ACR = ACR + ACRSEG

			// Total Accrual on Segment Prin (Matured)
			if (depseg.segment = 0) set dep.taspm = dep.taspm + ACRSEG
			
			// Total Accrual on Seg Prin (Non-Matured)
			else  set dep.taspnm = dep.taspnm + ACRSEG
		}
		// --- End accrual on principal on segment level

		if (IACM.extract(1) = 0) do ADJ(.tmpttl, ACRSEG, BALINT, dep.ipdtrf, IACM, IRN, OLDIRN)

		// Accrue on available interest on account level
		if dep.aiacrf do { quit:ER
		
			set BALINT = depseg.aibal
			if dep.airdet set IRN = dep.aiirn

			// Determine calc parameters if acct uses scheduled period int calc
			if (+IACM.extract(1) = 0) do { quit:ER
			
				type Date LASTDATE = ""

				set ANFACTOR = dep.intaf

				do IM0(.IACM, dep.icpf, dep.aiipf, dep.aiinp, .LASTDATE, .ANFACTOR, TODAY) quit:ER
				set DAYSINP = dep.aiinp - LASTDATE
			}

			if ((+IRCB = 0) ! 'depseg.segval) set AIACRSEG = 0
			else  do {

				// Calculate accrual on available interest balance
				set AIACRSEG = $$CALC(.dep, IACM, BALINT, IRN, ANFACTOR, DAYSINP, dep.cmp, depseg.aiacr)
				set AIACRSEG = AIACRSEG.roundDec(5, "", 0)
				set depseg.aiacr = depseg.aiacr + AIACRSEG
				set AIACR = AIACR + AIACRSEG

				// Total Avail Int Accrual on Matured Seg
				if (depseg.segment = 0) set dep.taiams = dep.taiams + AIACRSEG
				
				// Total Avail Int Accrual on Non-Mat Seg
				else  set dep.taianms = dep.taianms + AIACRSEG
			}
		}

		do depseg.bypassSave()
	}

	if 'ER do STATDEP(.dep, .tmpttl, ACR, BALINT, IACM, ANFACTOR, DAYSINP, AIACR, "", "", 0)

	quit ER


ACCTLEV(RecordDEP dep,		// Deposit object			/MECH=REFNAM:RW
	RecordTMPTTL tmpttl)	// System balance totals object		/MECH=REFNAM:W

	/*
	Accrue at account level
	
	Process segmented account accruing at the account level. Interest
	may accrue on the Total Segment Non-Matured Prin Balance and/or the
	Total Segment Available Balance.

	RETURNS:
		. $$		Error flag			/TYP=L
	*/
	
	type literal Date TODAY = %SystemDate

	type Boolean ER, isICHND
	type Number ACR, ANFACTOR, AIACR, BALINT, DAYSINP, IRCB, IRN, OLDIRN
	type String IACM, INDEX
	
	set (ER, isICHND) = 0
	set (ANFACTOR, DAYSINP) = 0
	
	set IACM = dep.iacm
	set INDEX = dep.index
	set IRCB = dep.ircb
	set IRN = dep.irn
	set OLDIRN = IRN

	// --- Begin accrual on principal on account level
	if (+IRCB = 0) set BALINT = 0
	else  do {
		
		// Total Segment Non-Matured Prin Balance
		if 'dep.maxacr.isNull(), (dep.tsnmpb > dep.maxacr) set BALINT = dep.maxacr
		else  set BALINT = dep.tsnmpb
	}

	if (dep.ichnd = TODAY) do { if ER quit ER
		
		set dep.ichnd = %SystemDate.nextFreqDate(dep.intfre) quit:ER
		set dep.ichld = TODAY
		set isICHND = 1
	}

	if 'INDEX.isNull() set dep.irn = $$INDEXDEP(.dep, .IRN, dep.ichld, dep.intspr, dep.rndmtd, dep.intmat, BALINT, INDEX, isICHND, "", 0) quit:ER

	// Determine calc parameters if acct uses scheduled period int calc
	if (+IACM.extract(1) = 0) do { if ER quit ER
	
		type Date LASTDATE = ""
		
		set ANFACTOR = dep.intaf

		do IM0(.IACM, dep.icpf, dep.ipf, dep.inp, .LASTDATE, .ANFACTOR, TODAY) quit:ER
		set DAYSINP = dep.inp - LASTDATE
	}

	if (+IRCB = 0) set ACR = 0
	else  do {
		
		set ACR = $$DETACRDEP(.dep, IRN, dep.posacr, BALINT, IACM, dep.minacr, dep.negacrpo, ANFACTOR, DAYSINP)

		// Total Accrual on Seg Prin (Non-Matured)
		set dep.taspnm = dep.taspnm + ACR
	}
	// --- End accrual on principal on account level

	set AIACR = 0
	
	// Accrue on available interest on account level. Ignore IRCB for available interest
	if dep.aiacrf do {

		set BALINT = dep.tsab

		if dep.airdet do INDEXAI(.dep, .IRN, BALINT, INDEX) quit:ER

		// Determine calc parameters if acct uses scheduled period int calc
		if (+IACM.extract(1) = 0) do { quit:ER

			type Date LASTDATE = ""
			
			set ANFACTOR = dep.intaf

			do IM0(.IACM, dep.icpf, dep.aiipf, dep.aiinp, .LASTDATE, .ANFACTOR, TODAY) quit:ER
			set DAYSINP = dep.aiinp - LASTDATE
		}

		if (IRCB <> 0) do {

			// Calculate accrual on available interest balance
			set AIACR = $$CALC(.dep, IACM, BALINT, IRN, ANFACTOR, DAYSINP, dep.cmp, dep.aiacr)
			set AIACR = AIACR.roundDec(5, "", 0)

			// Total Avail Int Accrual on Matured Seg
			set dep.taiams = dep.taiams + AIACR
		}

	}	
	
	if 'ER do {

		if (IACM.extract(1) = 0) do ADJ(.tmpttl, ACR, BALINT, dep.ipdtrf, IACM, IRN, OLDIRN)
	
		do STATDEP(.dep, .tmpttl, ACR, BALINT, IACM, ANFACTOR, DAYSINP, AIACR, "", "", 0)
	}

	quit ER


PROCLN(Number CID,	// Account number
       RecordLN ln)	// Loan account			/MECH=REFNAM:RW

	// Process loan accounts

	/* 
	Segments are in use for this section if Segments used for both loans 
	and deposits (0) or Segments used for loans only (2) or loan product 
	types exist that use segments
	*/
	type literal Boolean isSEGUSE = ('CUVAR.NOSEGMENTS ! (CUVAR.NOSEGMENTS = 3)) ! ($$SEGUSE^BTTOPTMZ("L"))
	
	type literal Date TODAY = %SystemDate
	type literal Date TOMORROW = %SystemDate + 1
	type literal Number DELDIS = TOMORROW - CUVAR.DELDIS
		
	type public Cache %CACHE()
	type public Boolean ER
	type public String cache(,,), ET
		
	type Boolean doNOTICE, isICHND, isOFSDYS, isTEASER
	type Date DIST1ND
	type Number ACR, ANFACTOR, BALINT, BALPRIN, CATEGORY, DAYSINP, IRN
	type String IACM, INDEX, TYPE
	
	set TYPE = ln.type
	
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE = :TYPE")

	if prodctl.nonpa quit

	set (ANFACTOR, DAYSINP) = ""

	set BALPRIN = ln.bal
	set DIST1ND = ln.dist1nd
	set IACM = ln.iacm

	#IF ((CUVAR.LPND = %SystemDate & $$PACF^BTTOPTMZ("L")) ! (+(%SystemDate + 1).day() = 1))
	if (+BALPRIN = 0), (ln.stat = 4) do {  quit
	
		#IF (CUVAR.LPND = %SystemDate & $$PACF^BTTOPTMZ("L")) if prodctl.pacf do PACFLN(.ln)
		
		#IF (+(%SystemDate + 1).day() = 1)
		// If end of month, compute new month end balances before filing
		do AVGBALL(.ln) do ln.bypassSave()
		#ENDIF
	}
	#ELSE
	if (+BALPRIN = 0), (ln.stat = 4) quit
	#ENDIF
	
	set isICHND = 0

	type RecordTMPTTL tmpttl = Db.getRecord("TMPTTL", "TJD = "_TODAY_", JOB = :%ProcessID, CRCD = :ln.crcd, CLS = :ln.cls, GRP = :ln.grp, TYPE = :TYPE, GLSC = :ln.glsc, CC = :ln.cc", 1)

	set tmpttl.open = tmpttl.open + 1
	set tmpttl.bal = tmpttl.bal + BALPRIN
	set tmpttl.balcol = tmpttl.balcol + ln.balcol

	if (BALPRIN < 0) do {
		
		set tmpttl.balneg = tmpttl.balneg - BALPRIN

		type RecordDAYENDNEG dayend = Db.getRecord("DAYENDNEG", "EFD = TOMORROW, CID = :CID", 1)
		
		set dayend.balneg = BALPRIN
		do dayend.bypassSave()
	}

	// Late charge due
	if (ln.lchg <> 0) set tmpttl.lchg = tmpttl.lchg + ln.lchg

	/*
	Collect undisbursed balance for those loans using undisbursed
	processing (aruf = 1). Collect uncollected interest for add-on/dis-
	count loans (iam). For ARUF loans, base negative balance check on
	ledger less undisbursed balance.
	*/

	// Undisbursed principal
	if ln.aruf, (ln.udbal <> 0) do {
		
		set tmpttl.udbal = tmpttl.udbal + ln.udbal
		
		if (BALPRIN - ln.udbal < 0) do {

			type RecordDAYENDNEG rec = Db.getRecord("DAYENDNEG", "EFD = TOMORROW, CID = :CID", 1)
			
			set rec.balneg = BALPRIN
			do rec.bypassSave()
		}
	}

	// Miscellaneous charge due
	set tmpttl.mchg = tmpttl.mchg + ln.mchg

	// Uncollected interest
	if (ln.iam <> 0) set tmpttl.iunt = tmpttl.iunt + ln.iun - ln.ipl

	// Unapplied funds
	if (ln.unapf <> 0) set tmpttl.unapf = tmpttl.unapf + ln.unapf

	// Principal charge-off balance
	if (ln.coa <> 0) set tmpttl.coa = tmpttl.coa + ln.coa

	// Principal recovery balance
	if (ln.rec <> 0) set tmpttl.rec = tmpttl.rec + ln.rec

	// Determine calc parameters if loan uses scheduled period int calc
	if (+IACM.extract(1) = 0) do { quit:ER
	
		type Date LASTDATE, NEXTDATE

		set ANFACTOR = ln.dist1af
		set NEXTDATE = ln.schnd
		set LASTDATE = ln.schld
		
		do IM0(.IACM, ln.icpf, ln.dist1fre, .NEXTDATE, .LASTDATE, .ANFACTOR, TODAY)
		set DAYSINP = NEXTDATE - LASTDATE
		}

	set doNOTICE = 0

	// Initialize cache for "LNN", "LNO", "LDC" & "isOFSDYS" if not yet loaded
	set isOFSDYS = cache("BTTDRV", "PRODCTL", TYPE, "isOFSDYS").get()
	if isOFSDYS.isNull() do LTYPE(TYPE) set isOFSDYS = cache("BTTDRV", "PRODCTL", TYPE, "isOFSDYS")

	// Loan notice days. 'doNOTICE' determines whether or not to send notice
	if 'ln.schld.isNull(), $$FIND(cache("BTTDRV", "PRODCTL", TYPE, "LNO"), ln.schld) set doNOTICE = 1

	// If PF flag is set - compare tomorrow to next scheduled date
	else  if isOFSDYS, (ln.schnd = TOMORROW) set doNOTICE = 1

	// Check if an entry exist in ln.collque or in ln.collst
	if ((ln.collst <> 0) ! ln.collque ! (DIST1ND < TODAY)) do {

		type RecordDAYENDQCOLL rec = Db.getRecord("DAYENDQCOLL", "TJD = TODAY, CID = :CID", 1)
		do rec.bypassSave()
	}

	// Loan payment status in advance
	if (DIST1ND > TOMORROW) do {

		/*
		If late charge balance - put in 1st notice category
		If loan is identified as suspect, it should be considered for
		delinquency reclassification. Else, if loan is delinquent it
		should be considered for delinquency reclassification.
		*/
		if doNOTICE, (ln.lchg <> 0), ln.custnot.isNull() do LATE(CID, 1)

		#IF (CUVAR.DARCNPDT - CUVAR.DARCOFF = TODAY)
		// If loan is current but PRODCTL.DARCCU is enabled, consider
		// for delinquency reclassification.
		if ((ln.suspect <> 0) ! (ln.darcls <> 0) ! prodctl.darccu) do {

			type RecordDAYENDDARC rec = Db.getRecord("DAYENDDARC", "NPDT = CUVAR.DARCNPDT, CID = :CID", 1)
			do rec.bypassSave()
		}
		#ENDIF
	}
	
	// Loan processing based on DIST1ND
	else  do {

		// If loan is current but PRODCTL.DARCCU is enabled, consider
		// for delinquency reclassification.

		#IF (CUVAR.DARCNPDT - CUVAR.DARCOFF = TODAY)
		type RecordDAYENDDARC dayend = Db.getRecord("DAYENDDARC", "NPDT = CUVAR.DARCNPDT, CID = :CID", 1)
		do dayend.bypassSave()
		#ENDIF

		#IF 'CUVAR.DELDIS.isNull()
		// Loans Falling into # Days Delq to Display
		if (DIST1ND '> DELDIS) do {

			type RecordLNDELA dayend = Db.getRecord("LNDELA", "TJD = TOMORROW, ACN = :ln.acn", 1)
			do dayend.bypassSave()
		}
		#ENDIF

		// --------------  Loans Due Tomorrow and Before --------------

		// If tommorrow is late charge action date, put in charge file
		if (ln.lcad = TOMORROW) do {
			
			type RecordDAYENDLCHG dayend = Db.getRecord("DAYENDLCHG", "TJD = TOMORROW, CID = :CID", 1)
			if dayend.getMode() = 0 do dayend.bypassSave()
		}

		// Deliquent Loan (only) processing
		if (DIST1ND '= TOMORROW) do { quit:ER
		
			type Number X
		
			// Check for nonaccrual. If loan is ANPP days delinquent for
			// subsequent processing.

			if 'ln.anpp.isNull(), 'ln.nai, ((TOMORROW - DIST1ND + CUVAR.ANAOFF) > (ln.anpp - 1)) do {

				type literal Number XJDOFF = TOMORROW + CUVAR.ANAOFF
				
				type Number NAUID = cache("BTTDRV", "LNNA_UID_BTTDRV",1).get()
				
				// Need to get the UID for non-accrual teller.
				// UID is a required field when setting up DAYENDLNNAO.

				if NAUID.isNull() do { quit:ER
				
					do SOURCE^BCHSOURC("LNNA", "ALL", .NAUID) quit:ER
					
					set cache("BTTDRV", "LNNA_UID_BTTDRV",1) = NAUID
				}

				type RecordDAYENDLNNAO dayend = Db.getRecord("DAYENDLNNAO", "EJD = :XJDOFF, CID = :CID", 1)

				set dayend.auto = prodctl.ana
				set dayend.uid = NAUID
				do dayend.bypassSave()
			}

			// If 2 days from now is sched date, put in principal variable file
			// if appropriate
			if (ln.pvo <> 0), (ln.schnd = (TODAY + 2)), (ln.pvar > 0) do {

				type RecordDAYENDPVO dayend = Db.getRecord("DAYENDPVO", "TJD = TOMORROW, CID = :CID", 1)

				set dayend.pvar = ln.pvar
				set dayend.dueamt = ln.tdue + ln.lchg + ln.mcnd
				set dayend.type = TYPE
				do dayend.bypassSave()
			}

			// Don't send notice or update counters if delinquency covered
			if (ln.pvo <> 0) set X = ln.unapf + ln.pvar
			else  set X = ln.unapf
			quit:(X '< ln.tdue)

			/*
			If no custom notice, determine which notice category (by upper limit)
			should include account. Find category by finding the next LNN for
			TJD-DIST1ND. This allows the upper limit to equal the number of
			days late.
			Else, determine notice from [UTBLCUSNOT].
			*/
			
			if ln.custnot.isNull(),doNOTICE do {
				
				type Number I
				type String LNN = cache("BTTDRV", "PRODCTL", TYPE, "LNN")
				
				for I = 1:1:LNN.length(",") if (LNN.piece(",", I) > (TODAY - DIST1ND)) do LATE(CID, I) quit
				}

			else  do ^LNCUSNOT(.ln, CID) quit:ER


			type String LDC

			#IF 'CUVAR.DCCUP
				// Update LN delinquency counters for oldest delinquent bill
				set CATEGORY = $$FIND(cache("BTTDRV", "PRODCTL", TYPE, "LDC"), DIST1ND)

				if CATEGORY = 0 quit	// No need to create DAYENDLDC record if no match

				set LDC = "LDC"_CATEGORY

				type RecordDAYENDLDC dayend = Db.getRecord("DAYENDLDC", "EFD = TOMORROW, LDC = :LDC, CID = :CID", 1)
				do dayend.bypassSave()
			#ENDIF
				
			#IF CUVAR.DCCUP=1
				// Update LN delinquency counters for each delinquent bill
				type Date DUEDT
				type ResultSet rsduedt = Db.select("CDPD","LNBIL1","CID=:ln.cid AND SCHSEQ>=:ln.oseq AND CDPD<"_TOMORROW)
				while rsduedt.next() do {

					set DUEDT = rsduedt.getCol("CDPD")
				
					set CATEGORY = $$FIND(cache("BTTDRV", "PRODCTL", TYPE, "LDC"), DUEDT)
				
					if CATEGORY = 0 quit	// No need to create DAYENDLDC record if no match

					set LDC = "LDC"_CATEGORY

					type RecordDAYENDLDC dayend = Db.getRecord("DAYENDLDC", "EFD = TOMORROW, LDC = :LDC, CID = :CID", 1)
					do dayend.bypassSave()				
					}				
			#ENDIF			
			}
		}

	#IF isSEGUSE if ln.segments set ER = $$SEGLEVLN(.ln, .tmpttl, .prodctl) quit

	if (ln.ircb <> 0) set BALINT = ln.balint
	else  set BALINT = 0

	if (ln.ichnd = TODAY) do { quit:ER
		
		set ln.ichnd = %SystemDate.nextFreqDate(ln.intfre) quit:ER
		set ln.ichld = TODAY
		set isICHND = 1
		}
	
	if (ln.trexd > TODAY) set IRN = ln.trate, isTEASER = 1
	else  set IRN = +ln.irn, isTEASER = 0

	if 'ln.index.isNull() do {
		type Date EFD = $$INTOFFDT^LNCDI(ln.ichld, ln.intoff, ln.intoffcl)
		set ln.irn = $$INDEXLN(.ln, .IRN, EFD, ln.intspr, ln.rndmtd, ln.intmat, BALINT, ln.index, isICHND, "") quit:ER
		}
	else  do NOINDEX(.ln)
	
	set ACR = $$DETACRLN(.ln, .tmpttl, IRN, ln.acr, BALINT, IACM, ln.minacr, ANFACTOR, DAYSINP) quit:ER
	
	do STATLN(.ln, .tmpttl, .prodctl, ACR, BALINT, IACM, ANFACTOR, DAYSINP)

	quit


PACFLN(RecordLN ln)	// Loan object				/MECH=REFNAM:RW

	/*
	Set up Profitability Analysis File for loans
	*/

	type literal Date TODAY = %SystemDate

	type Number IUN, NDFB

	// Unamortized net fee balance = original amount - amoritized to date
	// - non-performing deferred amount
	
	type RecordLNAMOAO lnamoao = Db.getRecord("LNAMOAO", "CID = :ln.cid, TYP = ""PTS""", 1)
	
	if lnamoao.getMode() set NDFB = lnamoao.amt - lnamoao.caltd - lnamoao.npda
	else  set NDFB = ""

	// Uncollected interest balance for accts w/add-on or discount interest

	if (ln.iam > 0) set IUN = ln.iun - ln.ipl
	else  set IUN = ""

	type RecordPAA paa = Db.getRecord("PAA", "EFD = TODAY, CID = :ln.cid", 1)
	
	set paa.bal = ln.bal
	set paa.ipl = ln.ipl
	set paa.acr = ln.acr.roundDec(2, "", 0)
	set paa.udbal = ln.udbal
	set paa.ndfb = NDFB
	set paa.iun = IUN
	do paa.bypassSave()
	
	quit


ADJ(RecordTMPTTL tmpttl,	// System balance totals object		/MECH=REFNAM:W
    Number ACR,			// Accrual amount			
    Number BALINT,		// Balance for interest			
    Number IPDTRF,		// dep.ipdtrf				
    String IACM,		// Interest accrual method		
    Number IRN,			// Interest rate			
    Number OLDIRN)		// Old interest rate			

	/*
	Calculate balance * rate and call ERT to save to system balance totals.
	
	For IPD accts, dep.ipdtrf contains the interest amount transfered
	and the amount posted today. The interest posting process doesn't
	accrue on these amounts and we need to exclude it from the balance.
	
	Note:  This section is only done for IACM code where the first digit
	is 0, indicating the numerator is STANDARD.
	*/

	type Number BALXRATE

	#IF CUVAR.IPD 
	set BALXRATE = (BALINT - IPDTRF) * OLDIRN
	#ELSE
	set BALXRATE = BALINT * IRN
	#ENDIF

	do ERT(.tmpttl, ACR, BALXRATE, IACM)
	
	quit


ERT(RecordTMPTTL tmpttl,	// System balance totals object		/MECH=REFNAM:W
    Number ACR,			// Accrual amount			
    Number BALXRATE,		// Balance times rate			
    String IACM)		// Interest accrual method		

	/*
	Save balance * rate and accrual information to system balance totals
	for IACM = 00 or 01
	*/

	if (IACM <> 0) do {
		
		set tmpttl.balrt01 = tmpttl.balrt01 + BALXRATE
		set tmpttl.acr01 = tmpttl.acr01 + ACR
	}

	else  do {
		
		set tmpttl.balrt00 = tmpttl.balrt00 + BALXRATE
		set tmpttl.acr00 = tmpttl.acr00 + ACR
	}

	quit


HIST(Number CID,	// Account number			
     String CLS,	// Account class			
     String COLNAME,	// Column name				
     String OLDVALUE,	// Old value				
     String NEWVALUE,	// New value				
     Number SEGMENT)	// Segment number			
     
	// File column change into HIST and DTJFM tables

	/*
	Segments are in use for this section if it's not the case that No 
	segmented account processing used (1), or if any product types exist 
	that use segments
	*/
	type literal Boolean isSEGUSE = (CUVAR.NOSEGMENTS '= 1) ! ($$SEGUSE^BTTOPTMZ(""))

	type literal Date TODAY = %SystemDate

	type Number TSEQ
	type String TCMT

	#IF isSEGUSE
	if (CLS = "D") do {
		
		if ('SEGMENT.isNull()) set TCMT = "[DEPSEG]"_COLNAME_":"_OLDVALUE_":"_NEWVALUE_";"_SEGMENT
		else  set TCMT = "[DEP]"_COLNAME_":"_OLDVALUE_":"_NEWVALUE
	}
	
	#ELSE
	if (CLS = "D") set TCMT = "[DEP]"_COLNAME_":"_OLDVALUE_":"_NEWVALUE
	#ENDIF

	else  set TCMT = "[LN]"_COLNAME_":"_OLDVALUE_":"_NEWVALUE

	set TSEQ = Db.nextVal("HIST", "CID")

	type RecordHIST hist = Class.new("RecordHIST", "CID = :CID, TSEQ = :TSEQ")
	
	set hist.tjd = TODAY
	set hist.tcmt = TCMT
	set hist.time = %CurrentTime
	set hist.cdt = %CurrentDate
	if (%UserID.exists() <> 0) set hist.uid = %UserID
	else  set hist.uid="BATCH"
	do hist.bypassSave()
	
	quit


FIND(String STR,	// Main string				
     String SUBSTR)	// Sub-string				
     
	/*
	Return field number of SUBSTR in STR
	*/

	if (","_STR_"," '[ (","_SUBSTR_",")) quit 0
	quit (","_STR_",").piece(","_SUBSTR_",", 1).length(",")
	

LATE(Number CID,	// Account number			
     Number CATEGORY)	// Category				

	/*
	Update DAYEND late notice file
	*/

	type literal Date TOMORROW = %SystemDate + 1

	type String KEY = "LND"_CATEGORY

	type RecordLNDELNDA rec = Db.getRecord("LNDELNDA", "EFD = TOMORROW, KEY = :KEY, CID = :CID", 1)
	do rec.bypassSave()
	
	quit


LTYPE(Number TYPE)	// Loan type				

	/*
	Initialize loan counters
	*/

	type literal Date TOMORROW = %SystemDate + 1

	type public Cache %CACHE()
	type public String cache(,,,)
	
	type Boolean isOFSDYS = 0
	type String LDC, LNN, LNO
	
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE = :TYPE")

	// Loan Delinquency Counters
	set LDC = ""
	set LDC.piece(",", 1) = TOMORROW-prodctl.dcc1
	set LDC.piece(",", 2) = TOMORROW-prodctl.dcc2
	set LDC.piece(",", 3) = TOMORROW-prodctl.dcc3
	set LDC.piece(",", 4) = TOMORROW-prodctl.dcc4
	set LDC.piece(",", 5) = TOMORROW-prodctl.dcc5
	set LDC.piece(",", 6) = TOMORROW-prodctl.dcc6
	set LDC.piece(",", 7) = TOMORROW-prodctl.dcc7

	set cache("BTTDRV", "PRODCTL", TYPE, "LDC") = LDC

	// Late notice days
	set LNN = ""
	set LNN.piece(",", 1) = prodctl.dnc1
	set LNN.piece(",", 2) = prodctl.dnc2
	set LNN.piece(",", 3) = prodctl.dnc3
	set LNN.piece(",", 4) = prodctl.dnc4
	set LNN.piece(",", 5) = prodctl.dnc5

	set cache("BTTDRV", "PRODCTL", TYPE, "LNN") = LNN

	// Loan notice offsets
	set LNO = ""
	do DNCO(1, prodctl.dnc01, .isOFSDYS, .LNO)
	do DNCO(2, prodctl.dnc02, .isOFSDYS, .LNO)
	do DNCO(3, prodctl.dnc03, .isOFSDYS, .LNO)
	do DNCO(4, prodctl.dnc04, .isOFSDYS, .LNO)
	do DNCO(5, prodctl.dnc05, .isOFSDYS, .LNO)

	set cache("BTTDRV", "PRODCTL", TYPE, "LNO") = LNO
	set cache("BTTDRV", "PRODCTL", TYPE, "isOFSDYS") = isOFSDYS
	
	quit


DNCO(Number CATEGORY,	// Notice category			
     Number DNCO,	// Offset days				
     Boolean isOFSDYS,	// Offset days flag [*]			/MECH=REFNAM:W
     String LNO)	// Offset days string			/MECH=REFNAM:W
     
	/*
	Set up LNO array for Loan notice offsets
	
	ARGUMENT NOTES:
		. isOFSDYS	Flag that offset days exist for at least one category
	*/

	type literal Date TOMORROW = %SystemDate + 1
	
	if DNCO set LNO.piece(",", CATEGORY) = TOMORROW - DNCO
	else  if DNCO = 0  set isOFSDYS = 1
	
	quit
	

AVGBALD(RecordDEP dep)	// Deposit object			/MECH=REFNAM:RW

	/*
	Compute new average balances
	
	This subroutine will only be called on the last day of the month.
	Dollar day balances will be moved during this period from the
	current month to the corresponding month. Also, the month end
	balance will be moved to the appropriate bucket.
	*/
	
	type literal Date TOMORROW = %SystemDate + 1

	#IF (+%SystemDate.month() = 1) set dep.ddbal1 = dep.ddbalcur, dep.mebal1 = dep.bal
	#IF (+%SystemDate.month() = 2) set dep.ddbal2 = dep.ddbalcur, dep.mebal2 = dep.bal
	#IF (+%SystemDate.month() = 3) set dep.ddbal3 = dep.ddbalcur, dep.mebal3 = dep.bal
	#IF (+%SystemDate.month() = 4) set dep.ddbal4 = dep.ddbalcur, dep.mebal4 = dep.bal
	#IF (+%SystemDate.month() = 5) set dep.ddbal5 = dep.ddbalcur, dep.mebal5 = dep.bal
	#IF (+%SystemDate.month() = 6) set dep.ddbal6 = dep.ddbalcur, dep.mebal6 = dep.bal
	#IF (+%SystemDate.month() = 7) set dep.ddbal7 = dep.ddbalcur, dep.mebal7 = dep.bal
	#IF (+%SystemDate.month() = 8) set dep.ddbal8 = dep.ddbalcur, dep.mebal8 = dep.bal
	#IF (+%SystemDate.month() = 9) set dep.ddbal9 = dep.ddbalcur, dep.mebal9 = dep.bal
	#IF (+%SystemDate.month() = 10) set dep.ddbal10 = dep.ddbalcur, dep.mebal10 = dep.bal
	#IF (+%SystemDate.month() = 11) set dep.ddbal11 = dep.ddbalcur, dep.mebal11 = dep.bal
	#IF (+%SystemDate.month() = 12) set dep.ddbal12 = dep.ddbalcur, dep.mebal12 = dep.bal

	// Recalculate the dollar day balance for the next month
	set dep.ddbalcur = dep.bal * TOMORROW.daysInMonth()

	quit
	

AVGBALL(RecordLN ln)   // Loan object				/MECH=REFNAM:RW

	/*
	Compute new average balances
	
	This subroutine will only be called on the last day of the month.
	Dollar day balances will be moved during this period from the
	current month to the corresponding month. Also, the month end
	balance will be moved to the appropriate bucket.
	*/
	
	type literal Date TOMORROW = %SystemDate + 1

	#IF (+%SystemDate.month() = 1) set ln.ddbal1 = ln.ddbalcur, ln.mebal1 = ln.bal
	#IF (+%SystemDate.month() = 2) set ln.ddbal2 = ln.ddbalcur, ln.mebal2 = ln.bal
	#IF (+%SystemDate.month() = 3) set ln.ddbal3 = ln.ddbalcur, ln.mebal3 = ln.bal
	#IF (+%SystemDate.month() = 4) set ln.ddbal4 = ln.ddbalcur, ln.mebal4 = ln.bal
	#IF (+%SystemDate.month() = 5) set ln.ddbal5 = ln.ddbalcur, ln.mebal5 = ln.bal
	#IF (+%SystemDate.month() = 6) set ln.ddbal6 = ln.ddbalcur, ln.mebal6 = ln.bal
	#IF (+%SystemDate.month() = 7) set ln.ddbal7 = ln.ddbalcur, ln.mebal7 = ln.bal
	#IF (+%SystemDate.month() = 8) set ln.ddbal8 = ln.ddbalcur, ln.mebal8 = ln.bal
	#IF (+%SystemDate.month() = 9) set ln.ddbal9 = ln.ddbalcur, ln.mebal9 = ln.bal
	#IF (+%SystemDate.month() = 10) set ln.ddbal10 = ln.ddbalcur, ln.mebal10 = ln.bal
	#IF (+%SystemDate.month() = 11) set ln.ddbal11 = ln.ddbalcur, ln.mebal11 = ln.bal
	#IF (+%SystemDate.month() = 12) set ln.ddbal12 = ln.ddbalcur, ln.mebal12 = ln.bal

	// recalculate the dollar day balance for the next month
	set ln.ddbalcur = ln.bal * TOMORROW.daysInMonth()

	quit


INDEXLN(RecordLN ln,		// Loan acount			/REF:RW
	Number IRN,		// Interest rate		/REF:RW
	Date EFD,		// Int Change Last Date	
	String SPREAD,		// Interest spread	
	String RNDMTD,		// Rounding Method
	String MATRIX,		// Interest matrix	
	Number BALINT,		// Balance for interest		
	String INDEX,		// Interest index		
	Boolean isICHND,	// On interest change date	
	Number SEGMENT)		// Segment Number		

	/*
	Calculate loan rate based on index
	
	Determines the appropriate interest rate for any type of interest
	index, including account segment indexes, for the purposes of interest 
	accrual.

	RETURNS:
		. $$		New Interest Rate		/TYP=N
	*/

	/*
	Load index and calculate rate. If Teaser Rate needs to change
	back to the nominal rate for fixed rate accounts change it.
	*/

	// Cache for UINDX
	type public String IX(,,), RATEINDX()
	type public Number IXCNT

	type public Boolean isTEASER, ER
	type public Number CID
	type public String ET

	/*
	Segments are in use for this section if Segments used for both loans 
	and deposits (0), or Segments used for loans only (3), or loan product 
	types exist that use segments
	*/
	type literal Boolean isSEGUSE = ('CUVAR.NOSEGMENTS ! (CUVAR.NOSEGMENTS = 3)) ! ($$SEGUSE^BTTOPTMZ("L"))
	
	type literal Number IXCNTMAX = 250	
	type literal Date TODAY = %SystemDate

	// Returned by CTL^UINDX
	type Number RATE = "", RRATE, SRATE, URATE
	
	type Date ORIGDT
	type String PAR()
	type Boolean isLOADED = 0

	/*
	If Revolving Account, use Account Opening Date instead of
	Original Disbursement Date to determine how far back to allow
	the effective date (used to determine set of tiers to get 
	rate from)
	*/
	if ln.revf set ORIGDT = ln.odt
	else  set ORIGDT = ln.odd

	if (EFD < ORIGDT) set EFD = ORIGDT
		
	// Is the IX array fully loaded for the EFD for this account?
	if IX(INDEX,EFD).data()	set isLOADED = 1
		
	// If the rate is not scheduled to change and the index is a
	// basis index, don't bother calculating / changing it
	if 'isICHND, isLOADED, (+IX(INDEX).piece("|", 3) = 0) quit IRN
		
	if isLOADED set RATE = RATEINDX(INDEX, EFD).get()

	set PAR("INDEX") = INDEX
	set PAR("IXLOAD") = isLOADED
	set PAR("LIMIT") = 1
	set PAR("NOTSER") = 1
	
	#IF isSEGUSE if 'SEGMENT.isNull() set PAR("SEG") = SEGMENT

	// Skips standard rate calculation if RATE is defined, but 
	// still applies all offsets, rounding, and limits
	set PAR("SRATE") = RATE
		
	do CTL^UINDX(.ln, EFD, BALINT, .PAR()) quit:ER IRN

	// Rate has not been entered for effective date
	if EFD.isNull() set ER = 1, ET = "INDEX7" quit IRN

	// If teaser rate is changing - make a history entry
	if 'isTEASER, (ln.trexd = TODAY) do {
		set ln.fmld = TODAY
		do HIST(CID, "L", "IRN", ln.trate, RATE)
		}
		
	// Maintain interest index caching
	if 'isLOADED do {
		if IXCNT.get() '< IXCNTMAX kill IX, RATEINDX set IXCNT=0 quit
				
		/*
		If Index Type (INDEX.BASREL) is 0 (Basis Index), 
		store standard index value (without offsets, 
		rounding, and limits); otherwise, mark index as 
		loaded
		*/
		if (+IX(INDEX).piece("|", 3) = 0) set RATEINDX(INDEX, EFD) = SRATE
		else  set RATEINDX(INDEX, EFD) = ""

		set IXCNT = IXCNT.get() + 1
		}

	// If the rate is not scheduled to change and the index is a 
	// basis index, don't change it
	if 'isICHND, (+IX(INDEX).piece("|", 3) = 0) quit IRN

	if (ln.irn - RATE = 0) set:'isTEASER IRN = RATE quit IRN

	// If TREXD equals today we already logged the entry in history
	if 'isTEASER, (ln.trexd '= TODAY) do {
		set ln.fmld = TODAY

		#IF isSEGUSE
			do HIST(CID, "L", "IRN", ln.irn, RATE, SEGMENT)
		#ELSE
			do HIST(CID, "L", "IRN", ln.irn, RATE)
		#ENDIF
		}

	if 'isTEASER set IRN = RATE if ((ln.pcm = "5") ! (ln.pcm = "5N")) set ln.air = 1

	quit IRN


NOINDEX(RecordLN ln)		// Loan acount			/REF:RW

	// Process non-interest-indexed loan account

	type public Boolean isTEASER
	type public Number CID, IRN
	
	type literal Date TODAY = %SystemDate

	if 'isTEASER, (ln.trexd = TODAY) do {
		set ln.fmld = TODAY
		do HIST(CID, "L", "IRN", ln.trate, ln.irn)
		}

	// Check Minimum Rate Differential for fixed rate only, variable
	// rates done in CTL^UINDX
	if (ln.minrate <> 0) do {

		type Number RATEDIFF = $$MINRATE^LNCDI(CID, 1)
		
		quit:(+RATEDIFF = 0)

		if (IRN < (RATEDIFF + ln.minrate)) do {
			
			type Number RATE
			
			set IRN = RATEDIFF + ln.minrate
			set RATE = IRN
			
			// Compare rate to limits
			if (RATE <> ln.irn) do {

				// Minimum/maximum decrease
				if (RATE < ln.irn) do {

					type Boolean isDONE = 0
					type Number V1, V2

					if 'ln.intmndc.isNull() do { quit:isDONE
					
						set V1 = IRN - ln.intmndc
						if (RATE > V1) do {
							
							if (ln.intmno <> 0) set RATE = +V1
							else  set RATE = +ln.irn
							if (RATE = +ln.irn) set isDONE = 1
						}
					}

					set (V1, V2) = ""
					if 'ln.intmxdc.isNull() set V1 = ln.irn - ln.intmxdc
					if 'ln.intmxdy.isNull() set V2 = ln.aniro - ln.intmxdy

					if (V1 < V2) set V1 = V2
					if 'V1.isNull(), (RATE < V1) set RATE = V1
				}
				
				// Minimum/maximum increase
				if (RATE '< ln.irn) do {

					type Boolean isDONE = 0
					type Number V1, V2

					if 'ln.intmnic.isNull() do { quit:isDONE
					
						set V1 = IRN + ln.intmnic
						if (RATE < V1) do {
							
							if (ln.intmno <> 0) set RATE = +V1
							else  set RATE = +ln.irn
							if (RATE = +ln.irn) set isDONE = 1
						}
					}

					set (V1, V2) = ""
					if 'ln.intmxic.isNull() set V1 = ln.irn + ln.intmxic
					if 'ln.intmxiy.isNull() set V2 = ln.aniro + ln.intmxiy

					if 'V2.isNull(), ((V1 > V2) ! (V1.isNull())) set V1 = V2
					if 'V1.isNull(), (RATE > V1) set RATE = V1
				}

				// Maximum/minimum rate - life of loan
				if ln.intmx, (RATE > ln.intmx) set RATE = ln.intmx
				if ln.intmn, (RATE < ln.intmn) set RATE = ln.intmn
			}

			set IRN = RATE
			set ln.irn = IRN
		}
	}

	quit	

	
DETACRLN(RecordLN ln,		// Loan account			/REF:RW
         RecordTMPTTL tmpttl,	// System balance totals	/REF:W
         Number IRN,		// Interest rate		
         Number POSACR,		// Positive accrual		
         Number BALINT,		// Balance for interest		
         String IACM,		// Accrual calculation method	
         Number MINACR,		// Minimum balance to accrue	
         Number ANFACTOR,	// Annual factor		
         Number DAYSINP)	// Days in period
         
	/*
	Determine loan accrual amount

	RETURNS:
		. $$		Accrual amount			/TYP=N
	*/

	type Number ACR
         
	if (ln.ircb <> 0) do {		
		if 'ln.minacr.isNull(), (BALINT < ln.minacr) do {
			if (ln.minopt <> 0) set ACR = 0
			else  set ACR = -ln.acr
			}
		else  do {
			set ACR = $$CALC(.ln, IACM, BALINT, IRN, ANFACTOR, DAYSINP, "", "")
			set ACR = ACR.roundDec(5, "", 0)
			}

		if (IACM.extract(1) = 0) do ERT(.tmpttl, ACR, BALINT * IRN, IACM)
		}
	else  set ACR = 0
       
	quit ACR


STATLN(RecordLN ln,		// Loan account			/REF:RW
       RecordTMPTTL tmpttl,	// System balance totals	/REF:W
       RecordPRODCTL prodctl,	// Product type			/REF:R
       Number ACR,		// Accrual amount		
       Number BALINT,		// Balance for interest		
       String IACM,		// Interest accrual method	
       Number ANFACTOR,		// Annual factor		
       Number DAYSINP)		// Days in period		

	/*
	Accumulate loan accruals into account
	
	Updates (files) statistical data in the loan account and teller 
	totals tables.
	*/
	
	type literal Date TODAY = %SystemDate
	
	set ln.acs = TODAY
	set ln.daa = ACR

	if (ACR < 0), ln.negacrpo do {		
		set ln.negacr = ln.negacr - ACR
		set tmpttl.negdaa = tmpttl.negdaa - ACR
		}
	else  do {
		set ln.acr = ln.acr + ACR
		set tmpttl.acr = tmpttl.acr + ACR
		}

	set tmpttl.balacr = tmpttl.balacr + ln.acr
	set tmpttl.negacr = tmpttl.negacr + ln.negacr

	if '((IACM = "00") ! (IACM = "01")) set tmpttl.acraacm = tmpttl.acraacm + ACR

	#IF (CUVAR.LPND = %SystemDate & $$PACF^BTTOPTMZ("L")) if prodctl.pacf do PACFLN(.ln)

	// If month end, compute new month end balances before filing
	#IF (+(%SystemDate + 1).day() = 1) do AVGBALL(.ln)

	#IF $$VALID^%ZRTNS("ZBTTPP") do LN^ZBTTPP(.ln)

	do tmpttl.bypassSave()
	do ln.bypassSave()
	
	quit


SEGLEVLN(RecordLN ln,		// Loan account			/REF:RW
         RecordTMPTTL tmpttl,	// System balance totals	/REF:W
         RecordPRODCTL prodctl)	// Prodcut type			/REF:R

	/*
	Accrue loan account at segment level
	
	Process segmented account accruing at the segment level. For each
	segment, interest may accrue on the segment Ledger Balance.
		
	RETURNS:
		. $$		Error flag			/TYP=L
	*/
	
	type public Number ANFACTOR, DAYSINP
	type public String IACM
	
	type literal Date TODAY = %SystemDate
	
	type Boolean ER = 0, isTEASER = 0
	type Number ACR, ACRSEG, BALINT, CPACR, ONEAGOACR, TWOAGOACR

	set (ACR, ACRSEG) = 0

	type DbSet ds = Db.selectDbSet("LNSEG", "CID = :ln.cid")

	// Not a valid segment for accrual
	if ds.isEmpty() do Runtime.setErrMSG("LNSEG", 7890) quit ER

	while ds.next() do { quit:ER
		
		type Boolean isICHND
		type Number IRN

		type RecordLNSEG lnseg = ds.getRecord("LNSEG")

		set isICHND = 0
		set IRN = lnseg.irn

		if (+ln.ircb = 0) set BALINT = 0
		else  set BALINT = lnseg.bal

		if (lnseg.ichnd = TODAY) do { quit:ER
			set lnseg.ichnd = %SystemDate.nextFreqDate(lnseg.intfre) quit:ER
			set lnseg.ichld = TODAY
			set isICHND = 1
			}

		if 'lnseg.index.isNull() set lnseg.irn = $$INDEXLN(.ln, .IRN, lnseg.ichld, lnseg.intspr, lnseg.rndmtd, lnseg.intmat, BALINT, lnseg.index, isICHND, lnseg.segment) quit:ER

		if (+ln.ircb = 0) set ACRSEG = 0
		else  do {
			// Determine segment accrual
			set ACRSEG = $$DETACRLN(.ln, .tmpttl, IRN, lnseg.acr, BALINT, IACM, ln.minacr, ANFACTOR, DAYSINP)
			set ACR = ACR + ACRSEG
			
			// Classify segment accrual
			if (BALINT <> 0) do {
				set CPACR = (ACRSEG * (lnseg.cpbal / BALINT)).roundDec(5, "", 0)
				set ONEAGOACR = (ACRSEG * (lnseg.oneagobal / BALINT)).roundDec(5, "", 0)
				set TWOAGOACR =(ACRSEG * (lnseg.twoagobal / BALINT)).roundDec(5, "", 0)
				}
			else  set (CPACR, ONEAGOACR, TWOAGOACR) = 0
			
			// Update segment accrual fields
			set lnseg.cpacr = lnseg.cpacr + CPACR
			set lnseg.oneagoacr = lnseg.oneagoacr + ONEAGOACR
			set lnseg.twoagoacr = lnseg.twoagoacr + TWOAGOACR
			set lnseg.acr = lnseg.acr + ACRSEG

			// Reflect in loan counterparts
			set ln.cpacr = ln.cpacr + CPACR
			set ln.oneagoacr = ln.oneagoacr + ONEAGOACR
			set ln.twoagoacr = ln.twoagoacr + TWOAGOACR
			}

		do lnseg.bypassSave()
		}

	if 'ER do STATLN(.ln, .tmpttl, .prodctl, ACR, BALINT, IACM, ANFACTOR, DAYSINP)

	quit ER
	
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
	#IF $$VALID^%ZRTNS("ZBTTPP") do INIT^ZBTTPP

	do RESET^BTTUTL

	set vINPUT = 0


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
	#IF $$VALID^%ZRTNS("ZBTTPP") do EXIT^ZBTTPP

	do TTL, REGD

	quit


TTL	// 

	/*
	System balance totals
	
	Summarize information in TMPTTL accumulated by each of the threads
	into TTL. Do not round currency fields until all of the thread
	information has been summarized in TTL to avoid rounding errors.
	*/

	type literal Date TODAY = %SystemDate

	type DbSet ds = Db.selectDbSet("TMPTTL", "TJD = "_TODAY)

	while ds.next() do {

		type RecordTMPTTL tmpttl = ds.getRecord("TMPTTL")
		type RecordTTL ttl = Db.getRecord("TTL", "TJD = "_TODAY_", CRCD = :tmpttl.crcd, CLS = :tmpttl.cls, GRP = :tmpttl.grp, TYPE = :tmpttl.type, GLSC = :tmpttl.glsc, CC = :tmpttl.cc", 1)
		
		set ttl.open = ttl.open + tmpttl.open

		set ttl.acr = ttl.acr + tmpttl.acr
		set ttl.acr00 = ttl.acr00 + tmpttl.acr00
		set ttl.acr01 = ttl.acr01 + tmpttl.acr01

		set ttl.negacr = ttl.negacr + tmpttl.negacr
		set ttl.negdaa = ttl.negdaa + tmpttl.negdaa

		set ttl.bal = ttl.bal + tmpttl.bal
		set ttl.balacr = ttl.balacr + tmpttl.balacr
		set ttl.balcol = ttl.balcol + tmpttl.balcol
		set ttl.balneg = ttl.balneg + tmpttl.balneg
		set ttl.balcnega = ttl.balcnega + tmpttl.balcnega

		set ttl.balrt00 = ttl.balrt00 + tmpttl.balrt00
		set ttl.balrt01 = ttl.balrt01 + tmpttl.balrt01

		if (tmpttl.cls = "D") do {

			set ttl.intavl = ttl.intavl + tmpttl.intavl
			set ttl.balnegua = ttl.balnegua + tmpttl.balnegua
			set ttl.negundaa = ttl.negundaa + tmpttl.negundaa
			set ttl.negacrun = ttl.negacrun + tmpttl.negacrun
			set ttl.aiacr = ttl.aiacr + tmpttl.aiacr
			set ttl.uncacr = ttl.uncacr + tmpttl.uncacr
			set ttl.balcnegu = ttl.balcnegu + tmpttl.balcnegu
		}

		if (tmpttl.cls = "L") do {

			set ttl.coa = ttl.coa + tmpttl.coa
			set ttl.rec = ttl.rec + tmpttl.rec
			set ttl.lchg = ttl.lchg + tmpttl.lchg
			set ttl.mchg = ttl.mchg + tmpttl.mchg
			set ttl.iunt = ttl.iunt + tmpttl.iunt
			set ttl.unapf = ttl.unapf + tmpttl.unapf
			set ttl.udbal = ttl.udbal + tmpttl.udbal
			set ttl.acraacm = ttl.acraacm + tmpttl.acraacm
		}
		
		do ttl.bypassSave()
	}

	do Db.fastDelete("TMPTTL", "TJD = "_TODAY)

	// Pass through TTL for current system date and round currency fields.
	type DbSet ds2 = Db.selectDbSet("TTL", "TJD = "_TODAY)

	while ds2.next() do {

		type Number CRCDDEC

		type RecordTTL ttl = ds2.getRecord("TTL")

		set CRCDDEC = $$curdec^CRCDUTL(ttl.crcd)
		
		set ttl.acr = ttl.acr.roundDec(CRCDDEC, "", 0)
		set ttl.negacr = ttl.negacr.roundDec(CRCDDEC, "", 0)
		set ttl.negdaa = ttl.negdaa.roundDec(CRCDDEC, "", 0)

		set ttl.bal = ttl.bal.roundDec(CRCDDEC, "", 0)
		set ttl.balacr = ttl.balacr.roundDec(CRCDDEC, "", 0)
		set ttl.balcol = ttl.balcol.roundDec(CRCDDEC, "", 0)
		set ttl.balneg = ttl.balneg.roundDec(CRCDDEC, "", 0)
		set ttl.balcnega = ttl.balcnega.roundDec(CRCDDEC, "", 0)

		set ttl.balrt00 = ttl.balrt00.roundDec(CRCDDEC, "", 0)
		set ttl.balrt01 = ttl.balrt01.roundDec(CRCDDEC, "", 0)

		if (ttl.cls = "D") do {

			set ttl.intavl = ttl.intavl.roundDec(CRCDDEC, "", 0)
			set ttl.balnegua = ttl.balnegua.roundDec(CRCDDEC, "", 0)
			set ttl.negundaa = ttl.negundaa.roundDec(CRCDDEC, "", 0)
			set ttl.negacrun = ttl.negacrun.roundDec(CRCDDEC, "", 0)
			set ttl.aiacr = ttl.aiacr.roundDec(CRCDDEC, "", 0)
			set ttl.uncacr = ttl.uncacr.roundDec(CRCDDEC, "", 0)
			set ttl.balcnegu = ttl.balcnegu.roundDec(CRCDDEC, "", 0)
		}

		if (ttl.cls = "L") do {

			set ttl.coa = ttl.coa.roundDec(CRCDDEC, "", 0)
			set ttl.rec = ttl.rec.roundDec(CRCDDEC, "", 0)
			set ttl.lchg = ttl.lchg.roundDec(CRCDDEC, "", 0)
			set ttl.mchg = ttl.mchg.roundDec(CRCDDEC, "", 0)
			set ttl.iunt = ttl.iunt.roundDec(CRCDDEC, "", 0)
			set ttl.unapf = ttl.unapf.roundDec(CRCDDEC, "", 0)
			set ttl.udbal = ttl.udbal.roundDec(CRCDDEC, "", 0)
			set ttl.acraacm = ttl.acraacm.roundDec(CRCDDEC, "", 0)
		}

		do ttl.bypassSave()
	}

	quit


REGD	// Accumulate Reg 'D' summary

	type literal Date TODAY = %SystemDate

	type public Number SCHPID

	do Runtime.start("BA")

	type DbSet dsrpt3 = Db.selectDbSet("TMPRPT3", "PID = :SCHPID AND DATA <> 0")

	while dsrpt3.next() do {

		type RecordTMPRPT3 tmprpt3 = dsrpt3.getRecord("TMPRPT3")
		type RecordREGD regd = Db.getRecord("REGD", "TJD = "_TODAY_", PERS = :tmprpt3.key2, REGD = :tmprpt3.key3", 1)

		set regd.tamt = regd.tamt + tmprpt3.data
		do regd.bypassSave()

		type DbSet dsrpt4 = Db.selectDbSet("TMPRPT4", "PID = :SCHPID AND KEY1 = :tmprpt3.key1 and KEY2 = :tmprpt3.key2 and KEY3 = :tmprpt3.key3 and DATA <> 0")

		while dsrpt4.next() do {

			type RecordTMPRPT4 tmprpt4 = dsrpt4.getRecord("TMPRPT4")
			type RecordREGDD regdd = Db.getRecord("REGDD", "TJD = "_TODAY_", PERS = :tmprpt4.key2, REGD = :tmprpt4.key3, CAT = :tmprpt4.key4", 1)

			set regdd.tamt = regdd.tamt + tmprpt4.data
			do regdd.bypassSave()
		}
	}

	do Db.fastDelete("TMPRPT3", "PID = :SCHPID")
	do Db.fastDelete("TMPRPT4", "PID = :SCHPID")

	do Runtime.commit()

	quit


 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
