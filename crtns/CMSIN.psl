CMSIN	//
	/*
	       ORIG:  Mike Winigrad (6969) - 12/05/86
	  CALLED BY:
	      CALLS:
	   PROJ #'S:  1628
	       DESC:  Custom card transaction formatting
	              Source ID: CMSHLD CTBLINC

	                    THIS ROUTINE IS TO BE COMPILED WITH TTXFMT
	                        DO NOT RUN THIS ROUTINE STANDALONE

	  ---- Revision History ------------------------------------------------

		12/12/05 -  SPR - 18555
	  	      	    Card Management - General DBI3 System Area Clean up.

	   	12/05/05 - KinI - CR18478
	   	      	   Modified ISOCRCD section to replace obsoleted UTBLCRCDNO
 	        	   index table with CRCD main table.

	  ----------------------------------------------------------------------

	*/
	
	quit
	

public RECCALL	// Record menu section

	type public Boolean ER
	type public String REC,RECTYPE

	if ER.get()>0 quit

	// Following is custom for RS/2
	set REC=$$TRANSLATE(REC)

	// Header record
	if RECTYPE="FH" do REC1 quit

	// Unknown record - Abort
	if RECTYPE.isNull() quit

	// Trailer record
	if RECTYPE="FT" do REC9 quit

	// Must be detail record
	do REC6

	quit


public ALLREC	// All records section

	type public Number ERR,RECCNT
	type public String RECTYPE
	
	if RECCNT=1,RECTYPE'="FH" set ERR=11 do RECERR(1)
	
	quit


public UFILINIT	// File intialization

	type public Number CRCDTOT
	type Number BADBATCH,NUMTRAN,TOTAMT,TYPEPOS1,TYPEPOS2
	
	// Record type
	set TYPEPOS1=1
	set TYPEPOS2=2
	set BADBATCH=0

	// Initialize number of transactions and total amount.
	set NUMTRAN=0
	set TOTAMT=0
	do MCCLIST

	quit


REC1	// File header record

	type public Number %UserID,ERR
	type public Date %EffectiveDate,FDATE
        type public String %DIR,%INST,REC,SRC
        type Number BRCD,FID,LASTTTXSEQ
	
	/* 
	  Calculate last TTX sequence number for this %UID and BRCD.
	  This is later used to kill out new TTX records if the batch
	  happens to be bad.
	*/

	set LASTTTXSEQ=""

	type RecordCTBLINC ctblinc=Db.getRecord("CTBLINC","KEY=:SRC",1)
 
        set BRCD=ctblinc.brcd
        set %UserID=ctblinc.teller
 
        type ResultSet rs=Db.select("TSEQ","TTX","TJD=:%SystemDate AND BRCD=:BRCD AND UID=:%UserID","TSEQ DESC")
        if rs.next() set LASTTTXSEQ=rs.getCol("TSEQ")
 
        // Destination Directory
        do INT^%DIR
 
        set %INST=%DIR
 
        // Following is custom at RS/2 and would change at other sites

        // File ID
        set FID=REC.extract(3,8)
 
        // Merchant Payment
        if FID'="CRDTRN" set ERR=15 do RECERR(1) quit
 
        // File Creation Date
        set FDATE=REC.extract(9,16)
 
	// not using this for card input.
        set %EffectiveDate=%SystemDate
        do BCHINIT
 
	quit


UBCHINIT	// User batch intialization

	quit


UBCHEND	// User batch end

	type public Boolean ER
	type public Number BCHCR,BCHDR,BCHTOT,BRCD,HTLCA,NUMBRTR,NUMTRAN,TOTAMT
	

	// Verify Debit and Credit Totals
	set BCHTOT=$S(BCHDR>BCHCR:BCHDR-BCHCR,1:BCHCR-BCHCR)

	/* 
	   Compare information collect in batch processing with that
	   found in the trailer record.
	*/
	if ER.get()>0 do KILLTTX quit

	if ((NUMBRTR=NUMTRAN)&(HTLCA=TOTAMT)) do {

		// if batch is good, post transactions from TTX records.
		set BRCD=CUVAR.bobr
		}
	else  do KILLTTX
	quit


RBLDOFF( String ARRAY)	

	/* 
	   This is where the array of offsetting transactions
	   gets redefined for effective date.  This is code that is added to
	   allow for for posting of accumulated offsets on different dates.
	*/

	type public Number BRCD,MULTEFD
	type public Date %EffectiveDate
	type public String %UserID,AN,OFF(),TLO
	type Number ITC
	type String CRCD,KEY3,OCC

	kill OFF
	
	set CRCD=""
	for  set CRCD=ARRAY(CRCD).order() quit:CRCD.isNull()  do {
		set %EffectiveDate=""
		for  set %EffectiveDate=ARRAY(CRCD,%EffectiveDate).order() quit:%EffectiveDate.isNull()  do {
			set KEY3=""
			for  set KEY3=ARRAY(CRCD,%EffectiveDate,KEY3).order() quit:KEY3.isNull()  do {
				set OCC=""
				for  set OCC=ARRAY(CRCD,%EffectiveDate,KEY3,OCC).order() quit:OCC.isNull()  do {
					set OFF(CRCD,%EffectiveDate,KEY3,OCC)=ARRAY(CRCD,%EffectiveDate,KEY3,OCC)
					set ITC=""
					for  set ITC=ARRAY(CRCD,%EffectiveDate,KEY3,OCC,ITC).order() quit:ITC.isNull()  do {
						set OFF(CRCD,%EffectiveDate,KEY3,OCC,ITC)=ARRAY(CRCD,%EffectiveDate,KEY3,OCC,ITC)
						}
					}
				}

			set AN="OFF"
			set TLO=""

			do OFFSET^UMSC(%EffectiveDate,BRCD,%UID,.AN,0)

			kill OFF
			}
		}

	set MULTEFD=1
	quit


KILLTTX	// If the batch is bad, kill out the TTX records

	type public Number BRCD
	type public Date %EffectiveDate
	type public String %UserID,SVEFD()
	type Number SEQ

	set %EffectiveDate=""
	for  set %EffectiveDate=SVEFD(%EffectiveDate).order() quit:%EffectiveDate.isNull()  do {
		set SEQ=SVEFD(%EffectiveDate)
		do Db.delete("TTX","TJD=:%EffectiveDate AND BRCD=:BRCD AND UID=:%UserID AND TSEQ>:SEQ")
		}
	quit


PREOPEN	//

	quit


POSTREAD	// This handles the offsetting transactions

	type public String CRCDTOT(),OFFSET

	// Offset to the source specific GL
	do RBLDOFF(.OFFSET)

	/* 
	   Offset to the position accounts of the currencies of the
	   original transaction account and the source specific GL
	   account
	*/
	if 'CRCDTOT("").order().isNull() do RBLDOFF(.CRCDTOT)

	quit


TRANSLATE( String REC)	// Translates the unwritable characters in a record.

	set REC=REC.translate($CHAR(144)," ")
	quit REC


TRNAMT( Number AMT, Number EXP)	// Transaction amount with decimal value

	if EXP.get()>0 quit AMT/(10**EXP)
	
	quit AMT.get()


SHVZRO1( String FIELD)	// This removes the zero filler from the front of a string.

	// Shave zeros from beginning of string.
	for  quit:FIELD.extract()'=0  do {
		if FIELD.extract()=0 set FIELD=FIELD.extract(2,(FIELD.length()))
		}
		
	quit FIELD


SHVSP1( String FIELD)	// Shave space from beginning of account string.

	type Number SPC

	for  quit:FIELD.extract()'=" "  do {
		if FIELD.extract()=" " set FIELD=FIELD.extract(2,(FIELD.length()))
		}

	// Shave spaces from end of account string.
	set SPC=FIELD.find(" ")
	
	if SPC>0 set FIELD=FIELD.extract(1,(SPC-2))
	quit


public ACCCHECK( Number CID)	// Check if this is a valid profile account.

	/*
	ARGUMENTS:

	. CID			/REQ/NONULL/MECH=VAL
	*/

	type public Boolean ER
	type public Number %NET
	type public String ET,RM
	
	set %NET=0

	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	if acn.getMode()=0 set ER=1,ET="RECNOF" D ^UTLERR

	if ER.get()'=0 quit

	/* Check if the account has an active status.
	   Inactive account
	*/
	if acn.stat'=0 set ER=1 set RM=$$^MSG("3310")
	quit


REC6	// Detail record

	// Extract and initialize data

	type public Boolean ER
	type public Number CRCDTOT,CROFF,DROFF,ETC,MCC,NUMTRAN,OAMT,TAMT,TOTAMT
	type public String CRCD,KEY3,LOCEXP,OCC,OCRCD,POS,REC,RM,SVEFD(),TCMT,TCRCD,TLO,TSO
	type public Date %JD,%EffectiveDate,KEY2
	type Number AITCO,AUTCODE,ITCO,LOCAMT,MATCH,REVIND,SAMT,SettlEXP
	type Date DATE
	type String AcctEXP,AUTHNUM,BCHEFD,CID,TRANFIELD,TRANSOURCE,TRANTYPE,TRCRDNUM

	// Increment number of transactions.
	set NUMTRAN=NUMTRAN+1

	// Local exponent
	set LOCEXP=REC.extract(250)

	// Local Currency Amount
	set LOCAMT=$$EXTAMT(235,249)

	// Total - verified in trailer record
	set TOTAMT=TOTAMT+LOCAMT

	// PROFILE RBS Account Number
	set CID=REC.extract(162,185)
	do SHVSP1(.CID)

	// Card Number
	set TRCRDNUM=REC.extract(56,71)

	// Transaction Source
	set TRANSOURCE=REC.extract(44,55)

	// Transaction Type
	set TRANTYPE=REC.extract(80,80)

	// Reversal Indicator
	set REVIND=REC.extract(81,82)

	// Merchant Category Code
	set MCC=REC.extract(130,133)
	set ETC=$$TRANCODE(TRANSOURCE,TRANTYPE,REVIND,MCC)

	// Account Amount
	set TAMT=$$EXTAMT(254,268)

	// Settlement Amount
	set SAMT=$$EXTAMT(216,230)

	// cpb - used by TTXFMT
	set OAMT=SAMT

	// Processing Date
	set BCHEFD=REC.extract(3,10)

	set %JD=BCHEFD.toDate("YEARMMDD")

	set BCHEFD=%JD

	// Effective date may not be in the future
	if BCHEFD>%SystemDate set ER=1 set RM=$$^MSG(876) quit

	/* Stores the %EffectiveDate and the last seq in case the transactions that
	   get stored in TTX need to be killed out later.
	*/
	if ((%EffectiveDate.get()'="")&'SVEFD(%EffectiveDate).get()) do TTXEFD

	/* This will sort the offsetting transaction by the effective date
	   of the card holder transaction if the effective date is in the future
	*/
	set KEY2=$S(%EffectiveDate<BCHEFD:BCHEFD,1:%EffectiveDate)

	// Terminal Location
	set TLO=$$TLO^UTLO

	set TSO=""

	// Transaction Source
	do SETTSO(.TSO)

	// Transaction Comment
	set TCMT=$$^MSG(3589,TRCRDNUM)

	// Settlement Currency
	set OCRCD=REC.extract(213,215)
	set OCRCD=$$ISOCRCD(OCRCD)

	if ER quit
	set TCRCD=REC.extract(194,196)

	// Transaction Currency
	set TCRCD=$$ISOCRCD(TCRCD)

	if ER quit

	// Account Currency
	set CRCD=REC.extract(251,253)
	set CRCD=$$ISOCRCD(CRCD)
	
	if ER quit

	// Acct CRCD Position Acct
	set POS=$$otcgl^CRCDUTL(CRCD)

	if OCC.get().isNull() do %UID

	if (TCRCD'=CRCD)!(CRCD'=OCRCD) do CRCDTOT
	else  set CRCDTOT=""

	// Set Offset Account
	set KEY3=TRANSOURCE
	type RecordUTBLCMSASSOC cmsassoc=Db.getRecord("UTBLCMSASSOC","ASSOC=:TRANSOURCE",1)
	if cmsassoc.getMode() set DROFF=cmsassoc.cid
	else  do {
		type RecordSCAU scau=Db.getRecord("SCAU","UID=:%UserID",1)
		set CROFF=scau.tscr
		set DROFF=scau.tsdr
		}

	if 'DROFF.get().isNull() do SHVSP1(.DROFF)

	if CROFF.get().isNull() set CROFF=DROFF.get()

	// Remove Hold
	do RMVHLD
	
	do TTXFILE
	
	quit


EXTAMT( Number STRT, Number STP)	// Extracts the amount and translates it based upon exponent

	type Number EXP,VALUE
	type public String REC

	set VALUE=REC.extract(STRT,STP)
	set EXP=REC.extract(STP+1)
	if EXP>0 set VALUE=VALUE/(10**EXP)
	quit VALUE


TTXEFD	// This sets up the %EffectiveDate for the the TTX file

	type Date %SystemDate,TPD
	type public Number BRCD,TRC
	type public Date %EffectiveDate
	type public String %UserID,SVEFD()	

	type ResultSet rs=Db.select("TSEQ","TTX","TJD=:%EffectiveDate AND BRCD=:BRCD AND UID=:%UserID","TSEQ DESC")
	if rs.next() set SVEFD(%EffectiveDate)=rs.getCol("TSEQ")

	set TPD=%EffectiveDate

	do ^TTXLOK

	set TRC=SVEFD(%EffectiveDate)
	quit


ISOCRCD( String CURR)	

	type public Boolean ER

	// Translates the numeric standard code to the alphnumeric ISO code

	type ResultSet rs=Db.select("CRCD","CRCD","CO=:CUVAR.CO AND CRCDNO=:CURR")
	if rs.next() set CURR=rs.getCol("CRCD")

	// Invalid currency code
	if CURR.isNull() do Runtime.setErrMSG("CRCD",1293) quit:ER

	quit CURR


CRCDTOT	// set up CRCDTOT array for an offset.

	
	type public Number ITCO,LOCAMT,OAMT,OCC,POS,TAMT
	type public String CRCD,CRCDTOT(),ETCLOAD,ITC,KEY2,OCRCD
	type Number AITCO,CECR,CEDR

	if OCC.isNull() do %UID

	set ITCO=ITC.extract()
	set AITCO=$S(ITC.extract()=0:1,1:0)
	set ETCLOAD=CUVAR.%crcd
	set CEDR=ETCLOAD.piece("|",2)
	set CECR=ETCLOAD.piece("|",3)

	if 'CRCDTOT(CRCD,KEY2,"*",OCC).exists() set CRCDTOT(CRCD,KEY2,"*",OCC)=POS_"|"_CEDR_"|"_POS_"|"_CECR
	set CRCDTOT(CRCD,KEY2,"*",OCC,AITCO).piece("|",1)=CRCDTOT(CRCD,KEY2,"*",OCC,AITCO).get().piece("|",1)+TAMT
	set CRCDTOT(CRCD,KEY2,"*",OCC,AITCO).piece("|",2)=CRCDTOT(CRCD,KEY2,"*",OCC,AITCO).get().piece("|",2)+LOCAMT

	set POS=$$otcgl^CRCDUTL(OCRCD)
	if 'CRCDTOT(OCRCD,KEY2,"*",OCC).exists() set CRCDTOT(OCRCD,KEY2,"*",OCC)=POS_"|"_CEDR_"|"_POS_"|"_CECR
	set CRCDTOT(OCRCD,KEY2,"*",OCC,ITCO).piece("|",1)=CRCDTOT(OCRCD,KEY2,"*",OCC,ITCO).get().piece("|",1)+OAMT
	set CRCDTOT(OCRCD,KEY2,"*",OCC,ITCO).piece("|",2)=CRCDTOT(OCRCD,KEY2,"*",OCC,ITCO).get().piece("|",2)+LOCAMT
	quit


MCCLIST	/* This builds the list of Merchant Category Codes that are used
	   in determining the PROFILE transaction code
	*/

	type Number MCC
	type public String MCCD()

	type ResultSet rs=Db.select("MCC","UTBLCMSETC2")
	while rs.next() do {
		set MCC=rs.getCol("MCC")
		set MCCD(MCC)=""
		}
		
	quit


TRANCODE( String TRSRC, String TRTYP, Number REVIND, String MCC)	//

	type public Number ITC,OCC
	type public String MCCD()
	type Number CNTRL,ETC,MCCLIST
	type RecordTRN trn()

	set CNTRL=0
	set MCCLIST=""
	for  set MCCLIST=MCCD(MCCLIST).order() quit:MCCLIST.isNull()  do {
		if MCC=MCCLIST set CNTRL=1
		}

	if CNTRL do {
		type RecordUTBLCMSETC2 cmsetc2=Db.getRecord("UTBLCMSETC2","TRSRC=:TRSRC,TRTYP=:TRTYP,REVIND=:REVIND,MCC=:MCC",1)
		set ETC=cmsetc2.etc
		}
	else  do {
		type RecordUTBLCMSETC cmsetc=Db.getRecord("UTBLCMSETC","TRSRC=:TRSRC,TRTYP=:TRTYP,REVIND=:REVIND",1)
		set ETC=cmsetc.etc
		}

	if ETC.isNull() set ETC=0

	// Determine internal tran code
	set trn(ETC)=Db.getRecord("TRN","ETC=:ETC",1)

	if trn(ETC).getMode()=0 set (ETC,ITC)=0
	else  do {

		// Internal Transaction Code
		set ITC=trn(ETC).itc
		}

	//reinitialize teller info
	if OCC.isNull() do %UID

	quit ETC


RMVHLD	// Remove Pre-authorized Hold

	type public Number AUTCODE,AUTHNUM,CID,HLDAMT,HLDSEQ,HOLDRANGE,LOWRLIM,MATCH,PRGDYS,TAMT,TRMRG,UPPRLIM
	type public Date DATE

	set MATCH=0
	type RecordCMSOPT cmsopt=Db.getRecord("CMSOPT")
	set PRGDYS=cmsopt.prgdys
	
	set DATE=$S('PRGDYS.get().isNull():%SystemDate-PRGDYS-1,1:"")

	// We are trying to match the CID and Authorization code.
	if 'AUTCODE.get().isNull() do {

		type ResultSet rs=Db.select("TJD","DAYENDCMSHLD","TJD>:DATE")
		while rs.next() set DATE=rs.getCol("TJD") quit:(DATE>%SystemDate)  do {
		
			type Number XX

			// If we match CID, and a record exists with this AUTHNUM,
			if MATCH=1 quit

			type RecordDAYENDCMSHLD cmshld=Db.getRecord("DAYENDCMSHLD","TJD=:DATE,CID=:CID,AUTHNUM=:AUTCODE",1)		
			if cmshld.getMode() do {
				set MATCH=1
				set HLDSEQ=cmshld.hldseq
				set HLDAMT=cmshld.hldamt
				
				set XX=$$DELHOLD^PHLD(CID,HLDSEQ)

				//remove this entry from the DAYEND file.
				do Db.delete("DAYENDCMSHLD","TJD=:DATE AND CID=:CID AND AUTHNUM=:AUTCODE")
				}
			}
		}

	if MATCH=0 do {

		/* if we didn't find an exact match for CID and authorization,
		   then we will try to find the CID with a hold amount close 
		   to the amount in question. We calculate a holdrange based
		   on a value in File CMSOPT.
		*/
		set TRMRG=cmsopt.trmrg
		set HOLDRANGE=(TRMRG/100)*TAMT

		// set upper, lower limits.
		set UPPRLIM=TAMT+HOLDRANGE
		set LOWRLIM=TAMT-HOLDRANGE
		set DATE=$S('PRGDYS.get().isNull():%SystemDate-PRGDYS-1,1:"")
	
		type ResultSet rs=Db.select("TJD","DAYENDCMSHLD","TJD>:DATE")
		while rs.next() do {
			
			if MATCH=1 quit
			set DATE=rs.getCol("TJD")
			set AUTHNUM=""
	
			type DbSet rs=Db.selectDbSet("DAYENDCMSHLD","TJD=:DATE AND CID=:CID")
			while rs.next() do {

				if MATCH=1 quit
				
				type RecordDAYENDCMSHLD cmshld=rs.getRecord("DAYENDCMSHLD")
				set AUTHNUM=cmshld.authnum
				set HLDAMT=cmshld.hldamt

				// see if hold amount is within limits.
				if (((HLDAMT<UPPRLIM)&(HLDAMT>LOWRLIM))!(HLDAMT=TAMT)) do {
					type Number XX

					set HLDSEQ=cmshld.hldseq

					// if so, remove hold
					// kill out HLD
					set XX=$$DELHOLD^PHLD(CID,HLDSEQ)

					//remove entry from dayend file
					do Db.delete("DAYENDCMSHLD","TJD=:DATE AND CID=:CID AND AUTHNUM=:AUTHNUM")

					set MATCH=1
					}
				}
			}
		}
	quit


public SETETC( Number CID, Number OPT)

	/*

	ARGUMENTS:

	. CID	Account Number		/REQ/NONULL/MECH=VAL
	. OPT	Credit Flag		/REQ/NONULL/MECH=VAL

	   Once a valid profile account number is obtained,
	   return the ETC (general purpose tran code) from utility SKLL-OAD

	   OPT=1 - DEBIT           OPT=2 - CREDIT

	   Set product type and currency code.
	*/

	type public Boolean ER
	type public Number ERR
	type public String CRCD,RGP,RM
	type Number PRODTYPE

	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)
	set PRODTYPE=acn.type

	// Invalid product type
	if PRODTYPE.isNull() set ER=1 set ERR=1 set RM=$$^MSG(1503) quit
	
	set CRCD=acn.crcd

	// Invalid currency code
	if CRCD.isNull() set ER=1 set ERR=1 set RM=$$^MSG(1293) quit

	// Get general purpose tran code.
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:PRODTYPE",1)
	if OPT=1 set RGP=prodctl.drtrgp
	if OPT=2 set RGP=prodctl.crtrgp

	quit RGP


SETTSO( String TSO) 

	// build TSO, (a piece in TR array, with subpieces of its own.)
	type public Number AUTCODE
	type public String REC,TCRCD,TYPEOFCARD,TRCRDNUM,x()
	type Number ACTEXP,TRANAMT,TREXP
	type String MCITY,MTDNME


	/* Set TSO field "ATM Card Number"
	   to detailed record field "Transaction Card Number"
	*/
	set x("ATMC")=TRCRDNUM

	/* Set TSO field "Authorization Code"
	   (to detailed record field of same name).
	*/
	set AUTCODE=REC.extract(83,88)
	do SHVSP1(.AUTCODE)

	set x("AUTCODE")=AUTCODE

	// Set TSO field "Merchant City"
	set MCITY=REC.extract(114,126)
	set x("MCITY")=MCITY

	// Set TSO field "Merchant Country"
	set x("MCNTRY")=REC.extract(127,129)

	// Set TSO field "Merchant Trade Name"
	set MTDNME=REC.extract(89,113)
	set x("MTDNME")=MTDNME

	// Set TSO field "Transaction Currency"
	set TCRCD=REC.extract(194,196)
	set x("TCRCD")=TCRCD

	// Set TSO field "Transaction Currency Exponent"
	set TREXP=REC.extract(212,212)
	set x("TREXP")=TREXP

	// Set TSO field "Transaction Currency Transaction Amount"
	set TRANAMT=REC.extract(197,211)
	set TRANAMT=TRANAMT/1
	set x("TRAMT")=TRANAMT

	// Set TSO field "Account Currency Exponent"
	set ACTEXP=REC.extract(269,269)
	set x("ACTEXP")=ACTEXP

	// Find out Card Type from CRD File.
	// Loop by account.
	type ResultSet rs=Db.select("CRDTYP","CRD","CRDNUM=:TRCRDNUM","CRDTYP")
	if rs.next() set TYPEOFCARD=rs.getCol("CRDTYP")

	// If a cardtype has been found for this card number, set it here.
	if 'TYPEOFCARD.get().isNull() set x("CRDTYPE")=TYPEOFCARD

	// Construct and return TSO.
	do IN^UTSO(.x,.TSO)
	
	quit


REC9	// File control (trailer) record

	type public String HTLCA,LOCEXP,NUMBRTR,REC

	set NUMBRTR=REC.extract(3,8)
	set HTLCA=REC.extract(9,23)
	set NUMBRTR=$$SHVZRO1(NUMBRTR)

	set HTLCA=$$SHVZRO1(HTLCA)

	set HTLCA=$$TRNAMT(HTLCA,LOCEXP)

	quit


RECERR( Number ABORT)	// Record error

	type public Number ERR,ERRIND
	type public String ERRMSG

	//ERRIND used in UBCHEND
	set ABORT=ABORT.get() set ERRIND=1

	// Missing file header record
	if ERR=11 set ERRMSG=$$^MSG(3038)

	// Invalid file type
	if ERR=15 set ERRMSG=$$^MSG(3039)

	// Process error
	if ABORT do ABORT^TPINERR quit

	do ^TPINERR

	if ABORT.get()=0 set ERR=""

	quit


%STOPLOD	// Stop %ZRTNLOD from this point on down
	
	quit


BCHINIT	// Dummy line reference for GT.M
	
	quit
	
		
BCHEND	// Dummy line reference for GT.M

	quit

TTXFILE	// Dummy line reference for GT.M

	quit

%UID	// Dummy line reference for GT.M

	quit
	
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60254^34948^Renga SP^17633"	// Signature - LTD^TIME^USER^SIZE
