PROC1DB		/*
	---- Revision History ------------------------------------------------

	09/20/06 - KELLYP - CR 23207
		   Modified PROC section to prevent compilation errors that
		   occurred when OPTIMIZE FUNCTIONS OFF.  Removed pre-2003
		   revision history.

	12/14/05 - KumarSS - 16671
		   Replaced the calls to QA^DBSFILB with COMPILE^DBSFILB.

	12/08/03 - Spier -7403
		   Cleanup of psl compiler messages.
	   
	01/13/03 - Spier - 51423
		   Corrected code identified as an error by new compiler
		   exclusive new and getonerow without correct keys (replaced
		   with getRecord(PRODCTL)

	----------------------------------------------------------------------
	*/

	// I18N=OFF
	
	/* 
	   Functions
	   . RESULTS Return validation rules error messages
	   . CHANGED Verify if rules should be applied in update mode
	   . VALID  Validate column rules
	   . LINK  Link filer routines to PBS server
	   . BLDFILER Compile DEP and LN run-time filers
	   . BLDRULES Compile rules/results run-time routine	
	*/

	quit 

RESULTS(%ProcessMode,CID,vdata,vzux,vdft)
	/*
	   ARGUMENTS:
	
	   . %ProcessMode
			Processing Mode			/TYP=N/REQ/MECH=VAL
	                0 = create 1 = update
	
	   . CID	Account number			/TYP=N/REQ/MECH=VAL
	   . vdata	Column values			/TYP=T/REQ/MECH=REFARRY:R
			column values required to process the
			rules/results logic (ACN,TYPE,BRCD)
	
	   . vzux	Column maintenance array	/TYP=T/REQ/MECH=REFARRY:R
	   . vdft	Defaults from product table	/TYP=T/REQ/MECH=REFARRY:RW
			Create by PRODDFT utility initially based on values in
			the product table
	   OUTPUTS:
	
	   . ER   Error flag
	   . RM   Error message
	
	   EXAMPLES:
	              S DATA("ACN")=123,DATA("TYPE")=100,DATA("BOO")=4
	              S DFT("IRN")=6.5,DFT("INTMAX")="STEP RATE"
	              D ^PROD1DB(0,12345,.DATA,,.DFT)
	
	*/

	new cls,data,dft,dfv,i,p1,p2,p3,p4,vq1,vq2,vq3,vq4,vq5,vq6,vq7,vq8,vq9
	new list,min,max,pgm,rules,seq,type,v,v1,vc,vcnt,vzkil
	new ACN,BRCD,COL,RSEQ,RULEID,RESULTID,TYPE,ZMARSEG,ZSEGID
	set seq=0
	set ER=0
	set ACN=$G(vdata("ACN"))	
	set TYPE=$G(vdata("TYPE"))
	set BRCD=$G(vdata("BOO"))
	if '%ProcessMode do { if ER quit 
		if ACN="" set ER=1 set RM=$$^MSG(1767,"ACN") quit     // Required
		if TYPE="" set ER=1 set RM=$$^MSG(1767,"TYPE") quit   // Required
		if BRCD="" set ER=1 set RM=$$^MSG(1767,"BRCD") quit   //Missing required data item ~p1
		}
	if %ProcessMode do { if ER quit        // Fetch TYPE,BOO,ACN
		if $G(TYPE)'="",$G(BRCD)'="",$G(ACN)'="" quit 
		set data=Db.getOneRow("TYPE,BOO,ACN","ACN","CID")
		set TYPE=$P(data,$C(9),1)
		set BRCD=$P(data,$C(9),2)	
		set ACN=$P(data,$C(9),3)
		}
	
	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE",1)
	// Rules not defined for this product
	if prodctl.getMode()=0 set rules="" quit
	set cls=prodctl.cls
	
	// Search all market segment and ID for definitions

	set MARSEG=1
	if 'Db.isDefined("UTBLMARSEGDT","MARSEG,BRCD") quit
	set v=Db.getOneRow("MARSEG","UTBLMARSEGDT","1,BRCD")
	if v="" quit					// Invalid segment/ID
	set ZMARSEG=1
	set ZSEGID=BRCD					// Start at market segment 1
	do PROC						// Process rules
	
	// Go up one level
	for  do PARENT(.ZMARSEG,.ZSEGID) quit:ZMARSEG=""  do PROC      
	
	if 'seq kill rules quit				// No rules returned
	if ER kill rules quit				// Error condition
	set i="" for  set i=$O(rules(i)) quit:i=""  do { if ER quit 
		set v=$G(vdata($P(i,".",2)))
		do VALID(v,i)
		if ER quit				// Validation error
		set v=$P(rules(i),"|",1)		// Default value
		if v="" quit 
		set vdft(i)=v				// Replace original default
		if $G(vdft) set ztrace(i)=1		// Audit information
		}
	quit 
	
VALID(v,dinam)	// Private ; validate column value against results table
	/*
	   Called by DEPFILE1 and LNFILE1 routines to validate column value
	
	   ARGUMENTS:
	
	   . v  Input value /TYP=N/REQ/MECH=VAL
	   . dinam  Column name /TYP=T/REQ/MECH=VAL
	
	   RETURNS:
	   . ER  Error flag
	   . RM  Error message
	*/

	new list,min,max,x
	if v="" quit 

	// Definition
	set x=$G(rules(dinam))

	if x="" quit 
	set list=$P(x,"|",2)
	set min=$P(x,"|",3)
	set max=$P(x,"|",4)

	// Not in the list
	if list'="",'$$IN(v,list) set ER=1 set RM=$$^MSG(1485,dinam_" - "_v) quit
	
	// Below minimum value
	if min'="",v<min set ER=1 set RM=$$^MSG(6746,dinam,min) quit   

	// Above maximum value
	if max'="",v>max set ER=1 set RM=$$^MSG(6745,dinam,max) quit   
	quit 
	
	
PARENT(ZMARSEG,ZSEGID)	// Return parent segment and ID
	
	set v=Db.getOneRow("PARSEG,PARSEGID","UTBLMARSEGDT","ZMARSEG,ZSEGID")
	if v="" set ZMARSEG="" quit 
	set ZMARSEG=$P(v,$C(9),1)
	set ZSEGID=$P(v,$C(9),2)
	quit 
	
PROC
	type ResultSet rs=Db.select("COLNAME,RULEID,RESULTSID,APPMOD","UTBLPRODLNK","TYPE=:TYPE AND MARSEG=:ZMARSEG AND SEGID=:ZSEGID")
	while rs.next() do {
		type String COLNAME = rs.getCol("COLNAME")
		if COLNAME'=cls quit				// Not valid class (DEP.col) or (LN.col)

		if %ProcessMode,('rs.getCol("APPMOD")) quit	// Not valid in update mode (APPMOD=0)
	
		// Option 1 and column value not changed
		if %ProcessMode,(rs.getCol("APPMOD")=1),('$$inux(COLNAME)) quit 
	
		do RULES(.rs)					// Apply rules
		}
	quit 
	
RULES(ResultSet rs)

	new data	
	set COL=rs.getCol(1)
	set RULEID=rs.getCol(2)
	set RESULTID=rs.getCol(3)
	#accept PGM=SPIER;DATE=12/8/03
	set pgm="S RSEQ=$$vr"_RULEID_"^VRULES(ACN)" xecute pgm         // Return rule sequence
	if 'RSEQ quit                          // Test failed
	set seq=1
	set data=Db.getOneRow("DEFAULT,LIST,RANGEMIN,RANGEMAX","UTBLPRODRTDT","COL,RESULTID,RSEQ")
	do COMPARE(COL,data)
	quit 
	
COMPARE(dinam,data)	// compare rule sets
	
	kill list
	if '$D(rules(dinam)) do { quit
		set rules(dinam)=$TR(data,$C(9),"|")  // save attributes
		if '$D(vdft(dinam)) quit              // default not defined
		set v=$P(data,$C(9),1)                // default value
		if v="" set $P(data,$C(9),1)=vdft(dinam)      // use value from product table
		}
	// ----- old values
	set v=rules(dinam)
	set dfv=$P(v,"|",1)
	set list=$P(v,"|",2)
	set min=$P(v,"|",3)
	set max=$P(v,"|",4)
	// ----- new values
	set p1=$P(data,$C(9),1)
	set p2=$P(data,$C(9),2)
	set p3=$P(data,$C(9),3)
	set p4=$P(data,$C(9),4)
	set list=$$list(list,p2) if ER quit    // No common element in list
	if min="" set min=p3
	else  if p3>min set min=p3             // Use higher level min value
	if max="" set max=p4
	else  if p4'="",p4<max set max=p4      // Use higher level max value
	if list'="" set list=$$range(list,min,max)
	set dft=$$dft(dfv,p1)                  // Default value
	if dft'="",list'="" set dft=$$list(dft,list)   // Must be a valid entry in list
	set rules(dinam)=dft_"|"_list_"|"_min_"|"_max  // Save new rules
	quit 
	
	
list(a,b)	// Join list a and v
	/*
	   ARGUMENTS:
	
	   . a List a (comma separated) /TYP=T/REQ/REF=VAL
	   . b List b (comma separated) /TYP=T/REQ/REF=VAL
	
	   RETURNS:
	
	   . $$ New list (duplicate entries removed)
	
	*/

	if a="",b="" quit ""
	if a="",b'="" quit b				// Use list from lower level

	// Join two lists to return a list with common elements
	set v=""
	for i=1:1:$L(a,";") set v1=$P(a,";",i) if $$IN(v1,b) set v=v_";"_v1
	set v=$E(v,2,9999)				// New list

	// The system is unable to resolve conflicts in product rule definitions
	if v="" set ER=1 set RM=$$^MSG(3646) quit ""	//The system is unable to resolve conflicts in product rule definitions
	quit v						// Return new list
	
	
IN(v,list)	// Check if v is a element in list
	
	quit (";"_list_";")[(";"_v_";")
	
inux(colname)	// Check if colname is in the changed array
	
	quit $D(zvux($P(colname,".",1),$P(colname,".",2)))
	
	
range(list,minval,maxval)
	
	// Remove elements from list if the value is not in the minval/maxval range
	
	set v=""
	for i=1:1:$L(list,";") do {
		if minval'="",$P(list,";",i)<minval quit 
		if maxval'="",$P(list,";",i)>maxval quit 
		set v=v_";"_$P(list,";",i)
		}
	quit $E(v,2,999)
		
dft(cv,hv)	// cv = lower level default  hv = higher level default
	
	if cv="",hv="" quit ""
	if cv="",hv'="" quit hv
	if cv'="",hv="" quit $$range(cv,min,max)	// Make sure it's in range
	if $$range(cv,min,max)="" quit hv		// Use higher level default
	if list="" quit cv				// No list
	if $$list(cv,list)="" quit hv			// not in the list
	quit cv						// Use lower level default
	
CHANGED(fid,array,list)	// verify if column name is in the rule list
	
	new chg,di
	set di="" set chg=0
	for  set di=$O(array(fid,di)) quit:di=""  if $$IN(di,list) set chg=1 quit 
	quit chg
	
QA	// Access accounts from ACN table to test product overlay logic
	
	new ACN,BRCD,CID,line,TYPE,vdata
	set line=""
	set $P(line,"-",50)=""
	type ResultSet rs=Db.select("CID,TYPE,BOO,ACN","ACN")
	if rs.isEmpty() quit 
	
	while rs.next() do {
		set CID=rs.getCol(1)
		set TYPE=rs.getCol(2)
		set BRCD=rs.getCol(3)
		set ACN=rs.getCol(4)
		kill rules
		write !,line,!,CID,?20,BRCD,?30,TYPE,!
		set vdata("ACN")=ACN
		set vdata("BOO")=BRCD
		set vdata("TYPE")=TYPE
		do RESULTS(1,CID,.vdata)
		write !,line,!
		}
	quit 
	
LINK	// Link run-time filer routines into server image
	
	new i
	for i="RULEFILE","RULEDTFL","VALUEFIL","VALUEDFL","RRLNKFIL" do {
		do LINK^PBSUTL("SCA$IBS",i)
		}
	quit 

	
BLDFILER	// Compile DEP and LN filers

	do COMPILE^DBSFILB("DEP",1)                 // Build deposit filer
	do COMPILE^DBSFILB("LN",1)                  // Build loan filer
	quit 


BLDRULES	// Compile rules/results run-time routine VRULES
	
	do ^DBSRULE(1)                         // Build run-time routine VRULES
	quit 

vSIG()	quit "60528^47714^Pat Kelly^9075"	// Signature - LTD^TIME^USER^SIZE
