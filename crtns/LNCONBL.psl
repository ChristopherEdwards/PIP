public LNCONBL
	/*
	       ORIG:  Neal E. Gorman

	---- Revision History ------------------------------------------------

	05/25/06 - DESHPANDE S K - CR 20748
		   Removed unused reference to public variable %TRNMODE from 
		   section SCHND.
		   
	01/31/06 - SmithCD - CR 19343 (16890)
		   Replaced CTL parameter in call to EXTERN^BCHLNSCH with ln.

	03/07/05 - KELLYP - CR 14452
	 	   Procedure was previously converted but not added to 
	   	   StarTeam.  Modified entire procedure to conform to
	   	   current PSL standards and removed pre-2004 revision 
	   	   history.
	*/
	
	do INIT
	
	quit
	
INIT	

	type Public Boolean ER

	type Boolean TEST
	type Date CEFD
	type Number CID,OLNTB,%PAGE,%PG
	type String LIST(),VFMQ

	set ER=0
	set %PG=0 
	set %PAGE=1

	do VPG00
	
	if "Q"[VFMQ do VER quit
	
	set %PG=%PG+1
	
	do VPG01

	do VER
	
	quit

VPG00	// Set up

	type Public Boolean TEST
	type Public Date CEFD
	
	type String %READ,%TAB()

	set CEFD=%SystemDate-1 
	set TEST=1 

	set %TAB("CEFD")=".CEFD1"
	set %TAB("TEST")=".TEST1"

	set %READ="@@%FN,,,CEFD/REQ,TEST/REQ"
	do ^UTLREAD
	quit

VPG01	// Screen

	type Public Boolean TEST
	type Public Number ER,OLNTB
	type Public String VFMQ

	type String %READ,%TAB()

	set %TAB("CID")=".CID3/HLP=[LN]CID/XPP=D CID^LNCONBL"
	set OLNTB=5030

	if 'TEST do { quit
		
		type String ARRAY()
		
		type ResultSet lnrs=Db.select("DISTINCT TYPE","LN")
		if lnrs.isEmpty() quit
		while lnrs.next() set ARRAY(lnrs.getCol(1))=""

		// Display prompt: Account type: ________________
		do ^UTLLIST("ARRAY","LIST(",$$^MSG("3945")) quit
		}

	set %READ="CID/REQ" 
	do ^UTLREAD 
	if VFMQ="Q" set ER=1 quit
	quit

CID	// Post processor for CID screen prompt

	type Public Boolean ER
	type Public Number CID

	type Number %EXT

	set %EXT=1
	do ^UACN quit:ER

	type RecordXCNVMAN xcnvman=Db.getRecord("XCNVMAN","CID",1)
	
	// Conversion data has not been entered
	if 'xcnvman.getMode() do Runtime.setErrMSG("LN","608") quit:ER

	// Account already converted
	if xcnvman.conflg do Runtime.setErrMSG("LN","52") quit:ER
	
	quit

ERR	// Handle errors

	type Public Number ER
	type Public String VFMQ

	set ER=1 
	do ^UTLERR
	set VFMQ="Q"
	
	quit

VER

	type Public String VFMQ
	
	type Boolean END,MANBIL
	type Time %TIM

	if %ProcessMode=2!(%ProcessMode=4)!(VFMQ="Q") do END quit

	// Start: ~p1
	write $$^MSG("3947",$$TIM^%ZM(%CurrentTime))

	set END=0
	set MANBIL=0
	
	do FILE
	
	set %TIM=$$TIM^%ZM(%CurrentTime)
	
	do END
	
	quit

FILE

	type Public Boolean END,ER,TEST
	type Public Number CID
	type Public String LIST()

	type Date ACRSTMP,XTJD
	type Number CNT

	catch vError {
		do ZT^LNCONBL
		}
			
	set ACRSTMP=%SystemDate-1	
	set CNT=0 
	
	set XTJD=%SystemDate
	
	// Needed to protect TJD/%SystemDate for multiple iterations
	type Date TJD
	#ACCEPT DATE=02/09/05;PGM=KELLYP
	set %SystemDate=XTJD
	
	// Disable Interrupt
	do DISABLE^%ZBREAK

	// Multiple accounts conversion
	if 'TEST do {
		set CID=""
		catch vError {
			do ZT^LNCONBL
			}

		type DbSet ds=Db.selectDbSet("XCNVMAN")
		while ds.next() do {
			type RecordXCNVMAN xcnvman=ds.getRecord()
			
			// Account already converted
	   		if xcnvman.conflg quit
			
			do Runtime.start("BA")
			
			type RecordLN ln=Db.getRecord("LN","CID")
			
			// Account's product type is not on user-selected list
			if 'LIST(ln.type).exists() quit
			
			do MAIN(.ln)
			
			if ER!END do Runtime.rollback("BA") quit
			
			do ln.bypassSave()
			
			do Runtime.commit()
			}
		}
	// Single account conversion
	else  do {
		
		do Runtime.start("BA")
		
		type RecordLN ln=Db.getRecord("LN","CID")
		
		do MAIN(.ln)
		
		// Fatal account condition was discovered, cannot convert
		if ER do Runtime.rollback("BA") quit
		
		do ln.bypassSave()
		
		do Runtime.commit()
		}

	quit

MAIN(RecordLN ln)
	/*
	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/	

	type Public Boolean END,ER,MANBIL,%REPOST,TEST
	type Public Number CID
	
	type String ET

	if '%REPOST.exists() use 0 write "." if $X>75 use 0 write !,CID

	// Account Locked - Not Converted
	lock +ACN(CID):2 else  set ET=$$^MSG("3944") do LOGERR quit

	// Exclude closed accounts
	if ln.stat=4 do { quit
		if TEST.get() set END=1
		}

	type Date BNDT,%DIST1ND,SCHLD,SCHND,STPDT
	type Number BLOFF,%SVBAL,%TYP,XBAL,XCNT
	type String CLS,CRCD,FRE,%GRP,PCM,SAVGRP,XBAL()

	// Product Type
	set %TYP=ln.type

	// Product Group
	set %GRP=ln.grp

	// Product Class 
	set CLS="L"

	// Currency Code
	set CRCD=ln.crcd 
	if CRCD.isNull() set CRCD=%SystemCurrency

	// History Cut-Off Date is set on the account
	if ln.hisctf do { quit
		if TEST.get() set END=1
		}
			
	// Temporarily reset Account Linkage Group
	set SAVGRP=ln.acngrp
	set ln.acngrp=1
	
	// Reset Total Escrow Balance
	set ln.teb=0
	
	/*
	 ^LNCONES loads bill file and escrow data.  It also determines
	 whether a loan is manual bill entry or not (sets MANBIL flag). This
	 is determined based on existence of a valid PCM for this account.
	*/
	do ^LNCONES(.ln)

	do MANBIL(.ln) if ER do LOGERR quit

	// Modify LN file for conversion - Manual Entry
	do ^LNCONLN(.ln)
	
	/*
	 Determine what the value of BALINT will be if unpaid principal 
	 is subtracted from the ledger balance (LNINTRC builds XBAL array)
	*/
	do ^LNINTRC(.ln)

	set XCNT=XBAL("").order()

	// Reset back the Account Linkage Group
	set ln.acngrp=SAVGRP

	// If there's no payment frequency, there's very little we can do
	if ln.dist1fre.isNull() do { quit
		if 'MANBIL set ln.balint=XBAL(XCNT)
		do ln.bypassSave()
		do SKP(.ln)
		}

	set %SVBAL=+ln.bal
	
	// Update balances
	if 'MANBIL do {
		set ln.balint=XBAL(XCNT)
		set ln.bal=XBAL(XCNT)
		}

	// File updated account information
	do ln.bypassSave()
	
	//  Billing - Next Date
	set BNDT=ln.bndt
	
	// Generate next bill
	if MANBIL do BNDT(.ln) quit

	// Scheduled Payment - Next Date
	set SCHND=ln.schnd
	
	// Scheduled Payment - Last Date
	set SCHLD=ln.schld
	
	// Save current value of DIST1ND, as it must change to bill properly
	set %DIST1ND=ln.dist1nd
	
	// Distribution 1 Next Due
	set ln.dist1nd=SCHND
	
	// Distribution 1 Last Due
	set ln.dist1ld=SCHLD
	
	// Generate next bill
	if BNDT<SCHND do BNDT(.ln) quit
	
	// Billing Date Offset
	set BLOFF=ln.bloff
	if BLOFF'="1P" do {
	
		set BNDT=SCHND-BLOFF
		
		// Billing - Next Date
		set ln.bndt=BNDT
		
		// Billing - Last Date
		set ln.bldt=SCHLD-BLOFF
		}
	else  do { quit:ER
		
		// Distribution 1 Frequency
		set FRE=ln.dist1fre
		
		set BNDT=SCHLD
		
		// Billing - Next Date
		set ln.bndt=BNDT
		
		set ln.bldt=$$NJD^UFRE(BNDT,FRE,,1) quit:ER
		}

	if ER do LOGERR do FIN(.ln) quit

	// File updated account information (billing)
	do ln.bypassSave()
	
	// Generate next bill
	do BNDT(.ln)
	
	quit

BNDT(RecordLN ln)	// Generate next bill
	/*

	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/
	
	type Public Boolean ER,MANBIL
	type Public Date BNDT,CEFD,%DIST1ND,STPDT
	type Public Number BLOFF,CID
	
	type Boolean DONE
	
	set DONE=0

	for  do { quit:DONE
		set ln.bndt=BNDT
		do ln.bypassSave()
		
		set BLOFF=ln.bloff 
		if BLOFF="1P" set BLOFF=0
		
		/*
		 Note: STPDT is setup in END^LNCONLN and MANBIL is set up in 
		 LNCONES. Due date is less than or equal to effective date.
		 Bill up to and including the effective date.
		*/
		
		// Distribution 1 Next Due
		if '%DIST1ND.exists() set %DIST1ND=ln.dist1nd
		
		if MANBIL do SCHND(.ln) quit
		
		if (%DIST1ND'>CEFD)&(BNDT>CEFD)&((BNDT+BLOFF)>STPDT) do SCHND(.ln) quit

		/*
		 Due date is greater than the effective date.  Bill up to but
		 not including the stop date since the stop date is in the
		 future and not ready to bill yet.
		*/
		if (%DIST1ND>CEFD)&(BNDT'<CEFD)&((BNDT+BLOFF)'<STPDT) do SCHND(.ln) quit

		#ACCEPT DATE=02/09/05;PGM=KELLYP
		set %SystemDate=BNDT
		
		type String PGM,XECUTE
		
		set PGM=$$GET^UBCHID("BCHLNBLDB")
		if PGM.isNull() set DONE=1 quit
		
		set XECUTE="do EXEC^"_PGM_"(CID,1)"
		
		#ACCEPT DATE=02/09/05;PGM=KELLYP
		xecute XECUTE

		if ER do { quit
			do LOGERR 
			do FIN(.ln)
			set DONE=1
			}

		kill DEP,PR,NPMT,DATA,%BAL,%INT,%PT,HIST,KVAR,AF,ECID
		kill LBAL,LPRI,NBS,PMT,PC,P1,DIA,AVGBC,BALINT,BAOLA,BLDT,INTX
		kill LBDD,LBIC,LBLB,PMTTRS,TBA,XDI,MCOBS,LUMP

		do SCHND(.ln)
		}
	quit

SCHND(RecordLN ln)	// Roll scheduled date
	/*

	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/

	type Public Boolean DONE,ER,MANBIL
	type Public Date BNDT,STPDT
	type Public Number CID, XCNT
	type Public String XBAL()

	type Date SCHND

	set SCHND=ln.schnd
	
	// Create entry in  Scheduled Payment - Next Date DAYEND file
	set ln.schnd=SCHND

	if MANBIL do SAT2(.ln) set DONE=1 quit
	if SCHND'<STPDT do SAT(.ln) set DONE=1 quit

	// Set up variables for call to BCHLNSCH that also calls TRNDRV
	type Date TPD
	type Number BRCD
	
	set TPD=%SystemDate
	#ACCEPT DATE=02/09/05;PGM=KELLYP
	set %SystemDate=SCHND
	
	// Branch of Origin
	set BRCD=CUVAR.bobr
	
	// Call Scheduled Date Roll batch for single account
	do EXTERN^BCHLNSCH(.ln) 
	if ER do { quit
		do LOGERR
		do FIN(.ln)
		set DONE=1
		}

	// Scheduled Payment - Next Date
	set ln.dist1nd=ln.schnd
	
	// Scheduled Payment - Last Date
	set ln.dist1ld=ln.schld
	
	do ln.bypassSave()
	set BNDT=+ln.bndt

	set XCNT=XBAL(XCNT).order()
	
	// Return to BNDT section for next pass 
	if XCNT.isNull() quit
	
	// Ledger Balances
	set ln.bal=XBAL(XCNT)
	
	// Adjusted Balance for Accrual Calculation
	set ln.balint=XBAL(XCNT)
	
	do ln.bypassSave()
	
	quit 	// Return to BNDT section for next pass

SAT(RecordLN ln)	// Satisfy future bills
	/*

	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/

	type Public Boolean ER
	type Public Date %DIST1ND
	type Public Number %SVBAL

	set ln.bal=%SVBAL
	
	do ln.bypassSave()
	
	// Distribution 1 Next Due
	set ln.dist1nd=%DIST1ND
	set ln.dist1ld=$$NJD^UFRE(%DIST1ND,ln.dist1fre,,1) if ER do FIN(.ln) quit

	do SAT2(.ln)

	quit
	
SAT2(RecordLN ln) 
	/*

	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/

	type Public Boolean ER,MANBIL
	type Public Date XTJD
	type Public Number CID

	type Date DIST1ND,SCHND
	type Number IDP
	type String DIST1FRE

	#ACCEPT DATE=02/09/05;PGM=KELLYP
	set %SystemDate=XTJD
	
	// Distribution 1 Frequency
	set DIST1FRE=ln.dist1fre
	
	// Scheduled Payment - Next Date
	set SCHND=ln.schnd

	// Setup Schedule and Billing dates
	do SCHU^LNCONLN(.ln) quit:ER

	if MANBIL do FIN(.ln) quit
	
	// Interest Determination Point
	set IDP=ln.idp
	
	// Scheduled Payment - Next Date
	set SCHND=ln.schnd
	
	// Distribution 1 Next Due
	set DIST1ND=ln.dist1nd
	
	if DIST1ND'>SCHND do { quit
		if 'ln.ppa do FIN(.ln) quit
		
		type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=1",1)
		if 'lnbil1.getMode() quit

		do BSAT(.lnbil1,ln.ppa)
		do lnbil1.bypassSave()
	 	do FIN(.ln)
		}			      
				  
	// Partially satisfy the first bill if Partial Payment Amount defined
	if ln.ppa do { 
		
		type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=1",1)
		if 'lnbil1.getMode() quit
		
		do BSAT(.lnbil1,ln.ppa)
		do lnbil1.bypassSave()
		}

	// Satisfy advance bills
	type DbSet ds=Db.selectDbSet("LNBIL1","CID=:CID","SCHSEQ ASC")
	while ds.next() do {

		type Number PA
		type RecordLNBIL1 lnbil1=ds.getRecord()

		set PA=lnbil1.casd
		if ln.ppa,lnbil1.schseq=ln.bseq set PA=ln.ppa
		do BSAT(.lnbil1,PA)
		do lnbil1.bypassSave()
		}
			
	do FIN(.ln)
	quit

BSAT(RecordLNBIL1 lnbil1,Number PAMT)
	/*

	ARGUMENTS:
		. lnbil1   Internal Bill Detail	 TYP=RecordLNBIL1/REQ/MECH=REF

		. PAMT	   Payment Amount	 TYP=N/REQ/MECH=VAL
	*/
	
	type Public Number IDP
	
	type Number I
	type String IBCI,DATAROW
	
	set DATAROW=$$BIL1ELE^BILFUNCS(.lnbil1)

	// Internal Bill Control Information - lnbil1.bp1
	set IBCI=DATAROW.piece($C(9),1)
	set IBCI.piece("#",1)=IBCI.piece("#",1)-PAMT
	
	for I=2:1:21 quit:(DATAROW.piece($C(9),I).isNull())!('PAMT)  do {
		
		type Number AMT
		type String ACRONYM,PELMNT
		
		set PELMNT=DATAROW.piece($C(9),I)
		set AMT=PELMNT.piece("#",4)
		if 'AMT,'IDP quit
		
		set ACRONYM=PELMNT.piece("#")
		if IDP,(ACRONYM="P"!(ACRONYM="I")) do { quit
			set AMT=PAMT
			set PAMT=0
			set IBCI.piece("#",5)=IBCI.piece("#",5)-AMT
			}
		if AMT'<PAMT do { quit 
			set PELMNT.piece("#",4)=AMT-PAMT
			set AMT=PAMT
			set PAMT=0
			set DATAROW.piece($C(9),I)=PELMNT
        		if '(ACRONYM="P"!(ACRONYM="I")) quit
			set IBCI.piece("#",5)=IBCI.piece("#",5)-AMT
			}
		set PELMNT.piece("#",4)=0
		set PAMT=PAMT-AMT
		set DATAROW.piece($C(9),I)=PELMNT
		if '(ACRONYM="P"!(ACRONYM="I")) quit
		set IBCI.piece("#",5)=IBCI.piece("#",5)-AMT
		}

	// Update lnbil1 object with modified Internal Bill Control Information
	set lnbil1.bp1=IBCI
	
	// Update payment elements in lnbil1 object
	for I=2:1:21 quit:DATAROW.piece($C(9),I).isNull()  do SETELMT^BILFUNCS(.lnbil1,I-1,DATAROW.piece($C(9),I))
	
	// File to database
	do lnbil1.bypassSave()

	quit

FIN(RecordLN ln)	// Finish processing	
	/*

	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/	

	type Date SCHLD,SCHND
	type Number BAL,ICPA,IPL,IUN,SCHSEQ,UDBAL

	// Scheduled Payment - Last Date
	set SCHLD=ln.schld
	set SCHSEQ=""

	type DbSet ds=Db.selectDbSet("LNBIL1","CID=:CID","SCHSEQ ASC")
	while ds.next(),SCHSEQ.isNull() do {
		type RecordLNBIL1 lnbil1=ds.getRecord()
		if lnbil1.cirn=SCHLD set SCHSEQ=lnbil1.schseq
		}

	// Scheduled Internal Bill Sequence Number
	set ln.schseq=+SCHSEQ
	
	// Unadvanced Balance
	set UDBAL=ln.udbal
	
	// Scheduled Payment - Next Date
	set SCHND=ln.schnd
	
	// Ledger Balances
	set BAL=ln.bal
	
	// Interest Calc Principal Adjustments
	set ICPA=ln.icpa
	
	// Interest - Unearned (Original)
	set IUN=ln.iun
	
	// Int/Div Paid - Life
	set IPL=ln.ipl
	
	// Loan bill re-set
	do EXEC1^LNUBIL(.ln)
	
	do SKP(.ln)
	
	quit

SKP(RecordLN ln) 
	/*

	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/
	
	type Public Boolean TEST
	type Public Date CEFD,XTJD
	type Public Number BAL,CID,CNT,%TYP
	type Public String %GRP
	
	type Boolean CON,KILL
	type Number BALCMP,HABL,NCID,OCID,TSEQ
	type String CLS,CRCD

	set CON=1
	set KILL=0
	set CLS="L"
	set OCID=CID
	set NCID=CID
	
	// Currency Code
	set CRCD=ln.crcd 
	if CRCD.isNull() set CRCD=%SystemCurrency
	
	// Set up 0 history level to justify the conversion "transaction"
        set TSEQ=Db.currVal("HIST","CID")

	type RecordHIST0 hist0=Class.new("RecordHIST0")	
	set hist0.cid=CID
	set hist0.jd=CEFD
	set hist0.bal=+BAL
	set hist0.seqzero=TSEQ
	set hist0.baola=ln.baola
	set hist0.ladt=ln.ladt
	set hist0.habl1=ln.habl1
	set hist0.habl2=ln.habl2
	set hist0.teb=ln.teb
	set hist0.udbal=ln.udbal
	if ln.iam set hist0.iunt=ln.iun-ln.ipl
	else  set hist0.iunt=ln.iun
	do hist0.bypassSave()

	#ACCEPT DATE=02/09/05;PGM=KELLYP
	set %SystemDate=CEFD
	/*
	 Set up Loan Conversion DAYEND entries and update LNCYC* files.
	 Previously the update was done here, but it will now be handled
	 inside LNCONDE procedure.
	*/
	do ^LNCONDE(.ln)
	
	#ACCEPT DATE=02/09/05;PGM=KELLYP
	set %SystemDate=XTJD

	// Set collected balance [LN]BALCOL	
	set ln.balcol=ln.bal
	
	// Unadvanced Balance
	if ln.aruf set ln.balcol=ln.intmno-ln.udbal

	// Set high balance - life LN.HABL1	
	set HABL=ln.tdr
	
	// Credit Limit - Current
	if HABL>ln.crlmt set HABL=ln.crlmt
	
	set BALCMP=ln.bal 
	
	if ln.aruf set BALCMP=BALCMP-ln.udbal
	if BALCMP>HABL set HABL=BALCMP
	
	// High Account Balance - Life
	if 'ln.habl1 set ln.habl1=HABL
	
	// Principal and Interest Payment
	if ln.pmtpi do SCHBAL(.ln)

	do ln.bypassSave()

	// Create record in Manual Loan Conversion Completed file
	type RecordLNCONCMP lnconcmp=Class.new("RecordLNCONCMP")		
	set lnconcmp.cefd=CEFD
	set lnconcmp.cls=CLS
	set lnconcmp.grp=%GRP
	set lnconcmp.type=%TYP
	set lnconcmp.cid=CID
	
	// Automatic entry
	if TEST set lnconcmp.desc=$$^MSG(5584)
	
	// Manual entry
	else  set lnconcmp.desc=$$^MSG(5583)
	
	do lnconcmp.bypassSave()
	 
	// Set converted flag in Manual Loan Conversion X-REF file
	type RecordXCNVMAN xcnvman=Db.getRecord("XCNVMAN","CID=:CID")
	set xcnvman.conflg=1
	do xcnvman.bypassSave()

	set CNT=CNT+1

	quit	

END	
	type Public Boolean END,TEST
	type Public Date CEFD
	type Public Number CID,CNT,%TYP
	type Public String CLS,ER,%GRP,RM,VFMQ
	type Public Time %TIM

	if ER.get()!END.get()!(VFMQ.get()="Q") quit
	if TEST.get() set CNT=Db.isDefined("LNCONCMP","CEFD=:CEFD,CLS=:CLS,GRP=:%GRP,TYPE=:%TYP,CID=:CID")

	set ER="W"
	
	// Completed at ~p1.  ~p2 loan record processed.
	set RM=$$^MSG(592,%TIM.get(),CNT.get())
	
	quit


ZT	// Error catch logic

	type Public Number %ZTHALT

	type String ET

	// MUMPS error
	set %ZTHALT=0 
	do ZE^UTLERR
	
	// System processing error
	set ET=$$^MSG("2575")
	
	do LOGERR
	quit


LOGERR	// Log error in exception file

	type Public Number CID,%ZTSEQ
	type Public String ET

	// Manual Loan Conversion
	do LOG^UTLEXC($T(+0),"*",$$^MSG("3946"),CID.get(),%ZTSEQ.get(),ET.get(),"")
	kill %ZTSEQ
	
	quit
	

MANBIL(RecordLN ln)	//
	/*

	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/
	
	type Public Boolean ER
	type Public Number CID
	
	type Boolean QT
	type Date BNDT,DIST1ND,DT,JD,NJD
	type Number BLOFF,BSEQ,I
	type String DATAROW,FRE
	
	// Quit if P&I
	if ln.pcmval.extract() quit
	
	type ResultSet rs=Db.select("BSEQ","LNCONBL1","CEFD=:CEFD AND CID=:CID")
	if 'rs.isEmpty() quit
	
	// Distribution 1 Next Due
	set DIST1ND=ln.dist1nd
	
	// Date of First Payment
	set JD=ln.dfp
	
	// Distribution 1 Frequency
	set FRE=ln.dist1fre
	
	set JD=$$NJD^UFRE(JD,FRE,,1) if ER do FIN(.ln) quit
	
	// Billing Date Offset
	set BLOFF=ln.bloff
	
	// Billing Date Offset
	if BLOFF="1P" set DT=DIST1ND
	else  set DT=DIST1ND-BLOFF
	
	// Bill must be created for ~p1
	if DT<(%SystemDate-1) do Runtime.setErrMSG("LN","351",$$DAT^%ZM(DIST1ND)) quit:ER

        set BSEQ=Db.currVal("LNBIL1","CID")
	
	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID")
	set DATAROW=$$BIL0ELE^BILFUNCS(.lnbil0)
	
	// Update payment elements
	for I=2:1:21 quit:DATAROW.piece($C(9),I).isNull()  do {
		type String PMTELMT
		set PMTELMT=DATAROW.piece($C(9),I) 
		set DATAROW.piece($C(9),I)=PMTELMT.piece("#",1,2)_"#0#0"
		}

	// Check to see if zero bills need to be created
	set QT=0
	for  set NJD=$$NJD^UFRE(JD,FRE) do { quit:QT
		
		type String BP1
		
		if ER do FIN(.ln) set QT=1 quit
		if BLOFF="1P" set BNDT=JD
		else  set BNDT=NJD-BLOFF
		
		if BNDT'<(%SystemDate-1),NJD'<DIST1ND do { quit
			// Billing - Last Sequence Number
			set ln.bseq=BSEQ
			set QT=1
			}
		
		if NJD<%SystemDate set JD=NJD quit
		set BP1="0#"_BNDT_"#"_NJD_"#0#0#0#"
		set BSEQ=BSEQ+1
		
		type RecordLNBIL1 lnbil1=Class.new("RecordLNBIL1")
		set lnbil1.cid=CID
		set lnbil1.schseq=BSEQ
		
		// Set Internal Bill Control Information
		set lnbil1.bp1=BP1
		
		// Create payment records for the elements in LNBIL1
		for I=2:1:21 quit:DATAROW.piece($C(9),I).isNull()  do SETELMT^BILFUNCS(.lnbil1,I-1,DATAROW.piece($C(9),I))
		
		// File to database
		do lnbil1.bypassSave()
		set JD=NJD
		}
	quit

SCHBAL(RecordLN ln)	// Amortize the loan's scheduled balance to SCHLD
	/*

	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/

	type Public Date CEFD

	type Date DFP
	type Number CNTCR,DIST1AF,FV,IAFA,IAM,IRN,NP,PMTPI
	
	// Credit Limit - Current
	set FV=ln.crlmt
	set CNTCR=0
	set NP=0
	set DFP=ln.dfp
	
	if DFP>CEFD do LNUPD(.ln) quit

	// Distribution 1 Annual Factor
	set DIST1AF=ln.dist1af
	
	// Principal and Interest Payment
	set PMTPI=ln.pmtpi
	
	set IAFA=365/DIST1AF
	
	// Distribution 1 Last Due
	set CNTCR=(((ln.dist1ld-DFP)/IAFA)+1.1).roundDec(0,,0)
	
	// Scheduled Payment - Last Date
	set NP=(((ln.schld-DFP)/IAFA)+1.1).roundDec(0,,0)
	set IAM=ln.iam 
	if IAM do { quit 
		do IAM(.ln) 
		do LNUPD(.ln)
		}
	// Nominal Int/Div Rate
	set IRN=ln.irn
	
	// Get Future Value
	set FV=$$FV^UFINC(FV,IRN,NP,ln.pmtpi,DIST1AF)
	set FV=FV.roundDec()
	
	do LNUPD(.ln)
	
	quit

LNUPD(RecordLN ln)	// Update fields in loan file
	/*
	   This section updates LN.CNTCR, LN.SCHNUM and LN.SCHBAL

        ARGUMENTS:
                . ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/
	
	type Public Number CNTCR,FV,NP
	
	// Payments Satisfied
	set ln.cntcr=CNTCR	
	
	// Scheduled Payment Number
	set ln.schnum=NP
	
	// Scheduled Balance
	set ln.schbal=FV
	
	quit

IAM(RecordLN ln)	// Determine the first payment due date
	/*

	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/

	type Public Number BAL,CID,CNTCR,DIST1AF,FV,IAM

	type Number DF,I,IPL,IR,IUN,NF,NR,ONP,%ORG,REM,%REM,X
	
	// Original Number of Payments
	set ONP=ln.onp
	
	// Interest - Unearned (Original)
	set IUN=ln.iun
	
	// Int/Div Paid - Life
	set IPL=ln.ipl
	
	if (IPL),(IAM.extract(2)'<1),(IAM.extract(2)'>4) do IAM1(.ln) quit

	// Rule of 78ths loans specific
	if IAM.extract(2)=2 do { quit
		set REM=BAL/ln.crlmt*ONP
		set CNTCR=(ONP-REM)\1
		set ln.ipl=$$^SCARND(IUN-(IUN*REM*(REM+1)/(ONP*(ONP+1))),0,CID) 
		do IAM1(.ln)
		}
	// Straight line calculation method
	if IAM.extract(2)=1 do { quit
		set ln.ipl=$$^SCARND(CNTCR/ONP*IUN,0,CID)
		do IAM1(.ln)
		}	
	// Declining Balance Method
	if IAM.extract(2)=4 do { quit
		type Number A
		set NR=ONP-CNTCR
		set A=IUN
		for I=1:1:NR set A=A-$$^SCARND(A/ONP,0,CID)
		set ln.ipl=A
		do IAM1(.ln)
		}
	// Actuarial calculation method
	if IAM.extract(2)=3 do { quit
		set NR=ONP-CNTCR
		set IR=ln.irn/(DIST1AF*100)
		set X=$$LNX^%ZFUNC(1+IR)*NR 
		set %REM=$$EXP^%ZFUNC(X)
		set X=$$LNX^%ZFUNC(1+IR)*ONP 
		set %ORG=$$EXP^%ZFUNC(X)
		if '%ORG set ln.ipl=0 quit
		set NF=((1/%REM)+(IR*NR))-1
		set DF=((1/%ORG)+(IR*ONP))-1
		if 'DF set ln.ipl=0 quit
		set ln.ipl=$$^SCARND(IUN*(NF/DF),0,CID)
		do IAM1(.ln)
		}
	set FV=ln.bal
	quit

IAM1(RecordLN ln)	
	/*
	 This section will calculate Add-on/Discount loans - Scheduled Balance:
	 Commitment minus (Scheduled number of payments times payment amount)
	  
	ARGUMENTS:
		. ln	Loan Account Object	TYP=RecordLN/REQ/MECH=REF
	*/
	
	type Public Number FV,NP,PMTPI
	
	set FV=ln.crlmt-(NP*PMTPI)
	
	quit
 #OPTION ResultClass ON
Public String vSIG()	quit "60460^57873^Shriram Deshpande^20797"	// Signature - LTD^TIME^USER^SIZE
