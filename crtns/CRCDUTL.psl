CRCDUTL		/*	
	   DESC: Currency exchange utility
	
	   KEYWORDS: Transaction Processing
	
	   LIBRARY:
	   
	   . EXC^CRCDUTL	Calculate exchange amounts
	   . $$desc^CRCDUTL	Return Currency code description
	   . $$crcdno^CRCDUTL	Return Currency code number
	   . $$retail^CRCDUTL	Return Currency code retail use flag
	   . $$buy^CRCDUTL	Return Currency code buy flag
	   . $$sell^CRCDUTL	Return Currency code sell flag
	   . $$variance^CRCDUTL	Return Currency code variance %
	   . $$curdec^CRCDUTL	Return Currency code decimal prec
	   . $$ratdec^CRCDUTL	Return Currency code rate prec
	   . $$cntry^CRCDUTL	Return Currency country code
	   . $$calendar^CRCDUTL	Return Currency calendar
	   . $$cashcur^CRCDUTL	Return Currency cash flag
	   . $$minrate^CRCDUTL	Return Currency Min rate value
	   . $$maxrate^CRCDUTL	Return Currency max rate value
	   . $$chkdesc^CRCDUTL	Return Currency check description
	   . $$sysceq^CRCDUTL	Return Currency system equivalent flag
	   . $$mincash^CRCDUTL	Return Currency min cash denomination
	   . $$factor^CRCDUTL	Return POACC data item vaalue
	   . $$conv^CRCDUTL	Return Convertable Currency flag
	   . $$otcgl^CRCDUTL	Return 'Over the Counter rate' G/L link
	   . $$spotgl^CRCDUTL	Return 'Spot rate' G/L link
	   . $$bsotcgl^CRCDUTL	'Over the Counter rate' Base Equiv G/L
	   . $$bsspotgl^CRCDUTL	'Spot Rate' Base Equiv G/L
	   . $$terms^CRCDUTL	Return Multiply Rate X Base Flag
	   . $$tresamt^CRCDUTL	Return test amount for getting margins
	   . $$tfsgl^CRCDUTL	Return Trade Finance G/L acct linkage
	   . RATE^CRCDUTL	Return Effective dated rate for R8TYP
	   . MINMAX^CRCDUTL	Minimum/maximum rates
	   . CAMT^CRCDUTL	Return Cash value in base currency
	   . EXCH^CRCDUTL	Compute exchange if necessary
	   . CONV^CRCDUTL	Compute exchange for service fee
	   . CRCDRATE^CRCDUTL	Compute rate based on mult/div
	
	---- Revision History ------------------------------------------------

	03/01/07 - SENTHIL J. KUMAR - CR 25451
		   Modified EXC section to check the conversion currency and 
		   display the message "Currency ~p1 is not convertible", 
		   if the currency is set as non-convertible.
	
	02/20/07 - SWARNALP - CR 25321
		   Replicated the changes done in CR 24694 from Profile 04 
		   view whose revision changes are mentioned as follows:
		   Modified CAMT section to initialize Exchange Amount EXCAMT 
		   with zero before currency exchange so as to avoid 
		   "UNDEFINED" error for the variable EXCAMT since the 
		   variable may not always be set with a value due to various 
		   validations during conversion.

	12/21/06 - chhabris - CR24591
		   Removed ccscreen section from this procedure as [CRCD]CCSCREEN
		   column has been obsoleted.
	
	05/25/06 - DESHPANDE S K - CR 20748
		   Replaced public variable %TRNMODE with variable ORIGTM in 
		   section EXC and tresamt. Replaced $$^MSG(2041) with 
		   setErrMsg() call in EXC. 
		   
		
	01/04/06 - KinI - 16664
		   Modified IBDA section to type CRCD record inside rather then 
		   pass it in (without that, one of crcdsec or crcdbse object 
		   is conditionally killed later).
		   Modified C section to set VARIANCE variable. 
	
	09/29/05 - RussellDS - CR16911
		   Correct logic error in RATE section.

	09/23/05 - KELLYP - CR 17273
		   Modified MARGINS section to $O through the THRSH array
		   instead of trying to $O through the THRSH variable (this
		   was apparently a conversion typo) to resolve an undefined
		   error.  Also removed pre-2003 revision history.

        07/27/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.
	
		---------------------------------------------------------------------
	*/
	quit 

	
public	EXC(String BSE,		// Base Currency Code
	    String SEC,		// Secondary Currency Code
	    Number AMT,		// Exchange Amount
	    Boolean BSEAMT,	// Base amount indicator
	    Number TRNTYP,	// Transaction Type
	    Number CASH,	// Cash Transaction Flag
	    Number CUSTCD,	// Customer Code
	    Date EFD,		// Effective Date
	    Number R8TYP,	// Rate Type
	    String CO,		// Company Code (Name)
	    String %CRCD,	// Base Currency
	    Number DEC)		// Decimal Precision

	/*
	   Exchange Currencies
	
	   DESC:
	   Calculate Exchange amount for a given transaction screen
	   based upon base and secondary currencies, know transaction
	   amount, know components of transaction (ie, Cash/Non-Cash,
	   Debit / Credit, etc.)
	
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . BSE	Base Currency Code			/REQ/MECH=VAL
	
	   . SEC	Secondary Currency Code			/REQ/MECH=VAL
	
	   . AMT	Exchange $ amount either in base	/REQ/MECH=VAL
	     		currency or secondary currency
	
	   . BSEAMT	Indicator usedto determine if		/REQ/MECH=VAL
	       		amount AMT is in 'Base' (1) or
	     		'Secondary' (0) currency
	
	   . TRNTYP	Transaction type			/REQ/MECH=VAL
	     		Either Debit or Credit transaction where
	     		0 = Debit, margin applies
	     		1 = Credit, margin applies
	     		2 = Cash value, no margins apply
	
	   . CASH	Cash transaction flag			/REQ/MECH=VAL
	                11=Base and secondary currencies are cash
	                00=Base and secondary currencies are non-cash
	                10=Base currency is cash, secondary is non-cash
	                01=Base currency is non-cash, secondary is cash
	
	   . CUSTCD	Customer Code				/NOREQ/DFT=0
	     		Used for finding rate for a given
	     		customer type
	
	   . EFD	Effective Date				/NOREQ/MECH=VAL
	
	   . R8TYP	Rate Type (1-8), ...			/NOREQ/DFT=0
	   		Where:
	    		1 - MID-RATE 8 - FINSPOT
	    		2 - SPOTBID 3 - SPOTOFFER
	    		4 - OTCBID 5 - OTCOFFER
	    		6 - OFFBID 7 - OFFOFFER
	
	   . CO		Company Code				/NOREQ/DFT=CUVAR.CO
	
	   . %CRCD	System Base Currency			/NOREQ/DFT=CUVAR.CRCD
	
	   . DEC	Decimal Precision			/NOREQ/DFT=""
	
	   RETURNS:
	   . RATE	Exchange rate				/TYP=N
	   . EXCAMT	Exchange amount				/TYP=$
	   . MINRATE	Minimum allowable exchange rate		/TYP=N
	   . MAXRATE	Maximum allowable exchange rate		/TYP=N
	   . MULTIPLY	Mulitply/Divide flag			/TYP=N
	   . TRESREF	Treasury ref indicator			/TYP=L
	   . VARIANCE	% Variance before Tres Ref		/TYP=N
	   . ER		Error Flag				/TYP=L/COND
	   . RM		Return Message				/TYP=T/COND
	
	---------------------------------------------------------------------
	*/

	type Public Cache %CACHE()
	type Public Number ER,EXCAMT,RATE,ORIGTM 
	type Public String RM

	type Number DPBSE,DPSEC,EURCHK,MARGINS,MARGINT,MAX,MIN,TERMS
	type String CONVCRCD,DATA

	#ACCEPT DATE=5/20/03;PGM=Erik Scheetz
	if %SystemCurrency.get().isNull() set %SystemCurrency=CUVAR.%CRCD
	if 'CO.data() set CO=CUVAR.CO

	// To accomodate FMS
	#ACCEPT DATE=5/20/03;PGM=Erik Scheetz
	if %SystemDate.get().isNull() new %SystemDate set %SystemDate=+%CurrentDate
	if EFD.get().isNull() set EFD=%SystemDate
	
	type RecordCRCD crcdbse=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:BSE")
	type RecordCRCD crcdsec=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:SEC")
	
	// Set up rate decimal precision for each currency (used in RNDRT section)
	set DPBSE=crcdbse.ratdec
	set DPSEC=crcdsec.ratdec
	
	/*
	If either the base or the secondary currency is flagged as not
	for retail use AND the exchange is made via the teller posting
	module, the exchange cannot be made.  
	The ORIGTM public variable is a Transaction Mode for all transactions.
	*/

	// Not for retail use
	if (ORIGTM.get() = 1) , ('(crcdbse.retail)!'(crcdsec.retail)) set RATE="" do Runtime.setErrMSG("CRCD",2041) quit

	set CONVCRCD=$S(BSEAMT:BSE,1:SEC)
	
	// Currency is not convertible
	if '$$conv(CONVCRCD) do Runtime.setErrMSG("CRCD" ,679,CONVCRCD) quit:ER

	// Determine type of deal
	set EURCHK=$$EURCHK(.crcdbse,.crcdsec)
	if EURCHK set:DEC.get()'="" EXCAMT=EXCAMT.roundDec(DEC) quit

	type RecordCRCD0 crcd0=Db.getRecord("CRCD0","CO=:CO,CRCD=:BSE,RELCRCD=:SEC",1)
	if crcd0.getMode()=1 do NORMAL(.crcdbse,.crcdsec,.crcd0) quit
	if BSE=%SystemCurrency!(SEC=%SystemCurrency) do NORMAL(.crcdbse,.crcdsec,.crcd0) quit

	if crcdbse.sysceq do { if RATE=1 do NORMAL(.crcdbse,.crcdsec,.crcd0) quit
		set RATE=$$RATE(BSE,EFD)
		}
	if crcdsec.sysceq do { if RATE=1 do NORMAL(.crcdbse,.crcdsec,.crcd0) quit
		set RATE=$$RATE(SEC,EFD)
		}
	
	do CROSS(.crcdbse,.crcdsec)
	quit

CROSS(RecordCRCD crcdbse,RecordCRCD crcdsec)
	// Cross deal - Neither currency is the system base
	
	type Public Boolean BSEAMT,MULTIPLY
	type Public Date EFD
	type Public Number AMT,CASH,CUSTCD,ER,MARGINS,MARGINT,RATE,TRNTYP
	type Public String BSE,SEC
	
	type Number CSH,TERMS,TESTAMT
	type String CRCD

	/*
	 CRCD will equal the base currency(BSE) or the secondary currency
	 (SEC) based on the BSEAMT flag.
	*/

	type RecordCRCD crcd
	if BSEAMT set CRCD=BSE,CSH=CASH.extract(),crcd=crcdbse
	else  set CRCD=SEC,CSH=CASH.extract(2),crcd=crcdsec
	set MULTIPLY=BSEAMT
	
	set RATE=$$RATE(CRCD,EFD)
	set TESTAMT=$select(TERMS:AMT/RATE,1:AMT*RATE)
	if 'TESTAMT set TESTAMT=$$tresamt(CRCD,RATE)

	if TRNTYP=2 do IBDA(.crcdbse,.crcdsec) quit
	
	do MARGINS(TESTAMT,CRCD,CUSTCD.get(),EFD,.MARGINS) quit:ER 

	if TRNTYP,BSEAMT do { quit
		do SELL(.crcd,MARGINS,MARGINT,.RATE,CSH,EFD) quit:ER
		do IBDA(.crcdbse,.crcdsec)
		}
	if BSEAMT!(TRNTYP) do { quit
		do BUY(.crcd,MARGINS,MARGINT,.RATE,CSH,EFD) quit:ER
		do IBDA(.crcdbse,.crcdsec)
		}

	do SELL(.crcd,MARGINS,MARGINT,.RATE,CSH,EFD) quit:ER
	do IBDA(.crcdbse,.crcdsec)

	quit
	
IBDA(RecordCRCD crcdbse,
     RecordCRCD crcdsec)	

	/*
	Intermediate Base Currency
	
	Called by CROSS^CRCDUTL

	Under ARQ 43980, RATE is no longer flipped in the RATE section.
	Therefore it is necessary to consider the multiplicative indicator
	(CRCD.TERMS) of the RATE currency when calculating the intermediate
	amount (INTAMT).

	NOTE: The naming of variables SELLRATE and SELLTERM may be a bit
	misleading.  These are the intermediate rate and the TERMS flag of
	the currency represented by this rate.  It may either be a buy or
	a sell rate depending on from where subroutine IBDA has been called.
	*/

	type Public Boolean BSEAMT
	type Public Date EFD
	type Public Number AMT,CASH,CSH,CUSTCD,ER,MARGINS,MARGINT,RATE,TERMS
	type Public Number TESTAMT,TRNTYP
	type Public String BSE,CRCD,SEC
	
	type Number INTAMT,SELLRATE,SELLTERM=TERMS

	set INTAMT=$select(SELLTERM:AMT*RATE,1:AMT/RATE)
	set SELLRATE=RATE
	if 'INTAMT set INTAMT=TESTAMT         

	type RecordCRCD crcd
	if BSEAMT set CRCD=SEC,CSH=CASH.extract(2),crcd=crcdsec
        else  set CRCD=BSE,CSH=CASH.extract(),crcd=crcdbse

	set RATE=$$RATE(CRCD,EFD)
	if TRNTYP=2 do C(.crcdbse,.crcdsec) quit
	
	do MARGINS(INTAMT,CRCD,CUSTCD.get(),EFD,.MARGINS) quit:ER 

	if TRNTYP,BSEAMT do { quit
		do BUY(.crcd,MARGINS,MARGINT,.RATE,CSH,EFD) quit:ER
		do C(.crcdbse,.crcdsec)
		}
	if BSEAMT!(TRNTYP) do { quit
		do SELL(.crcd,MARGINS,MARGINT,.RATE,CSH,EFD) quit:ER
		do C(.crcdbse,.crcdsec)
		}
	
	do BUY(.crcd,MARGINS,MARGINT,.RATE,CSH,EFD) quit:ER
	do C(.crcdbse,.crcdsec)

	quit 
	
NORMAL(RecordCRCD crcdbse,RecordCRCD crcdsec,RecordCRCD0 crcd0) 
	// Normal deal - One of the currencies is the system base

	type Public Boolean BSEAMT
	type Public Date EFD
	type Public Number AMT,CASH,CUSTCD,ER,RATE,SAVRAT,TRNTYP
	type Public String BSE,SEC
	
	type Boolean MARGINT,TERMS
	type Number CSH,EXCHRAT,TESTAMT
	type String CB,CRCD,CRCDM="",CS,MARGINS
	
	/*
	Determine currency base (CB) & secondary currency (CS) for this deal.
	If currencies are related, the base is defined by the relationship.
	*/

	if crcd0.getMode()=1 do {
		set CRCDM=crcd0.dircrcd
		if crcd0.relbase set CB=BSE,CS=SEC
		else  set CB=SEC,CS=BSE
		
		}	
	/*
	Otherwise, if either currency is equal to the system currency,
	the base is the currency equal to the system currency.
	*/

	else  if BSE=%SystemCurrency set CB=BSE,CS=SEC
	else  if SEC=%SystemCurrency set CB=SEC,CS=BSE
	
	/*
	Otherwise, if either currency is a system currency equivalent,
	the base is the currency which is a system equivalent.
	*/
	
	else  if crcdbse.sysceq set CB=BSE,CS=SEC
	else  set CB=SEC,CS=BSE
	
	/*
	Calculate TESTAMT based upon the currency for which the transaction
	amount is known.  The use of the rate infers that the thresholds
	are expressed in the system equivalency.  If it is determined that the
	current exchange is already in the system equivalent, then use the
	value for AMT in the TESTAMT variable for the purposes of getting
	the correct margins.
	*/

	set CRCD=$select(CB=BSE:SEC,1:BSE)
	set RATE=$$RATE(CRCD,EFD)
	set TESTAMT=AMT
	
	// Set up variable to hold exchange rate
        set EXCHRAT=RATE                       

	/*
	If a rate already exists on the teller screen use that rate for the
	calculation of TESTAMT
	*/
	if SAVRAT.get()'="" set RATE=SAVRAT      

	// Compute only if not already in system base
	if 'crcdsec.sysceq,SEC'=%SystemCurrency,'(BSE=%SystemCurrency&(BSEAMT=1)) set TESTAMT=$select(TERMS:AMT/RATE,1:AMT*RATE)
	
	// Set RATE back to the exchange rate for margin calculation
	if RATE'=EXCHRAT set RATE=EXCHRAT      
	if 'TESTAMT set TESTAMT=$$tresamt(CRCD,RATE)
 
	if CRCDM.isNull() set CRCDM=CS
	if CRCDM'=CRCD do {
		set CRCD=CRCDM
		set RATE=$$RATE(CRCD,EFD)
		}
	
	/*
	If margins do not apply, the exchange rate is equal to the rate.
	Otherwise, the margins are determined from the secondary currency.
	*/
	if TRNTYP=2 do { quit
		if (CB=BSE) do A(.crcd0) quit
		do B(.crcd0)
		}

	do MARGINS(TESTAMT,CRCD,CUSTCD.get(),EFD,.MARGINS) quit:ER 
	if crcd0.getPointer()!(BSE=CB) set CRCD=CS
	else  set CRCD=CB

	type RecordCRCD crcd	
	if CRCD=BSE set CSH=CASH.extract(),crcd=crcdbse
	else  set CSH=CASH.extract(2),crcd=crcdsec
	
	if TRNTYP,CB=BSE do { quit
		do BUY(.crcd,MARGINS,MARGINT,.RATE,CSH,EFD) quit:ER
		do A(.crcd0)
		}

	if TRNTYP do { quit
		do SELL(.crcd,MARGINS,MARGINT,.RATE,CSH,EFD) quit:ER
		do B(.crcd0)
		}
		
	if CB=BSE do { quit
		do SELL(.crcd,MARGINS,MARGINT,.RATE,CSH,EFD) quit:ER
		do A(.crcd0)
		}
	do BUY(.crcd,MARGINS,MARGINT,.RATE,CSH,EFD) quit:ER
	do B(.crcd0)

	quit 
	
	// Exit Points A, B and C
	
A(RecordCRCD0 crcd0)
	
	type Public Boolean BSEAMT,MULTIPLY
	type Public Number DEC,EXCAMT,TERMS
	type Public String CRCD
	
	if crcd0.getMode()=1 set CRCD=crcd0.dircrcd

	do MINMAX(CRCD)

	if TERMS set MULTIPLY=$select(BSEAMT:1,1:0)
	else  set MULTIPLY=$select(BSEAMT:0,1:1)

	do EXCAMT

	if DEC.get()'="" set EXCAMT=EXCAMT.roundDec(DEC)
	quit 

	
B(RecordCRCD0 crcd0) 
	
	type Public Boolean BSEAMT,MULTIPLY
	type Public Number DEC,EXCAMT,TERMS
	type Public String CRCD
	
	if crcd0.getMode()=1 set CRCD=crcd0.dircrcd
	
	do MINMAX(CRCD)
	
	if TERMS set MULTIPLY=$select(BSEAMT:0,1:1)
	else  set MULTIPLY=$select(BSEAMT:1,1:0)
	
	do EXCAMT

	if DEC.get()'="" set EXCAMT=EXCAMT.roundDec(DEC)
	quit 


C(RecordCRCD crcdbse,RecordCRCD crcdsec)	// Generate Cross Rate, Min and Max rate

	type Public Boolean BSEAMT,MULTIPLY
	type Public Number MAXRATE,MINRATE,RATE,SELLRATE,SELLTERM,TERMS,VARIANCE
	type Public String BSE,CRCD

	type Number MAXBSE,MAXSEC,MINBSE,MINSEC,VARBSE
	
	set MINBSE=crcdbse.minrate
	set MAXBSE=crcdbse.maxrate
	
	set MINSEC=crcdsec.minrate
	set MAXSEC=crcdsec.maxrate


	/*
	Inverted & Non-Inverted is express relative to the screen base
	currency if both are non-inverted then express the rate as
	non-inverted (CRCD/CRCDBASE) if both are inverted then express the
	rate as inverted (CRCDBASE/CRCD) if neither TERMS are the same then
	invert the non-inverted rate so both will be inverted (CRCDBASE/CRCD)
	*/

	if TERMS'=SELLTERM do {    
		/*
		Invert the non-inverted rate and
		extrapolate a MINRATE & MAXRATE
		
		Since the RATE is inverted it is necessary to extrapolate
		a MINRATE & MAXRATE based on the relative change to the RATE.
		Calculate the relative change in the rate using the formula
		1/RATE/RATE and multiply that by each rate to extrapolate the
		new rates.

		Example: RATE=3, MINRATE=1, MAXRATE=6
		newrate=RATE*(1/RATE/RATE)-->3*(1/3/3)=.33333
		newmin=MINRATE*(1/RATE/RATE)-->1*(1/3/3)=.11111
		newmax=MAXRATE*(1/RATE/RATE)-->6*(1/3/3)=.66667
		*/

		type Number VAR
		if TERMS do {
			set VAR=RATE
			set RATE=1/RATE
			set VAR=RATE/VAR
			if CRCD=BSE do {
				if MINBSE set MINBSE=VAR*MINBSE
				if MAXBSE set MAXBSE=VAR*MAXBSE
				}
			else  do {
				if MINSEC do {
					set MINSEC=VAR*MINSEC
					set MINRATE=MINSEC
					}
				if MAXSEC do {
				set MAXSEC=VAR*MAXSEC
				set MAXRATE=MAXSEC
				}
			}
		}
		else  do {
			set VAR=SELLRATE
			set SELLRATE=1/SELLRATE
			set VAR=SELLRATE/VAR
			if CRCD=BSE do {
				if MINSEC do {
					set MINSEC=VAR*MINSEC
					set MINRATE=MINSEC
					}
				if MAXSEC do {
					set MAXSEC=VAR*MAXSEC
					set MAXRATE=MAXSEC
					}
				}
			else  do {
				if MINBSE set MINBSE=VAR*MINBSE
				if MAXBSE set MAXBSE=VAR*MAXBSE
				}
			}
		set TERMS=0
		}

	set MINRATE=$select(MAXBSE:MINSEC/MAXBSE,1:"")             
	set MAXRATE=$select(MINBSE:MAXSEC/MINBSE,1:"")

	if crcdbse.variance<crcdsec.variance set VARIANCE=crcdbse.variance
	
	if BSEAMT set RATE=RATE/SELLRATE
	else  set RATE=SELLRATE/RATE
	
	set MULTIPLY=$select(TERMS:BSEAMT,1:'BSEAMT)

	do EXCAMT
	quit 


EXCAMT	// Calculate exchange amount
	
	type Public Boolean MULTIPLY
	type Public Number AMT,EXCAMT,RATE

	if 'AMT set EXCAMT=0 quit 
	
	if MULTIPLY set EXCAMT=AMT*RATE quit 
	set EXCAMT=AMT/RATE
	quit 
	

RNDALL	// Round RATE, MINRATE, and MAXRATE
	
	type Public Number MAXRATE,MINRATE,RATE
	
	set RATE=$$RNDRT(RATE)
	set MINRATE=$$RNDRT(MINRATE.get())
	set MAXRATE=$$RNDRT(MAXRATE.get())
	quit 
	

RNDRT(Number RATE)	// Round a rate

	type Public Number DPBSE,DPSEC
			
	if RATE.isNull() quit ""
	if DPBSE>DPSEC quit $$^SCARND(RATE,0,"","",DPBSE)
	quit $$^SCARND(RATE,0,"","",DPSEC)


public	EURRND(Number AMT,String FRCRCD,String TOCRCD,Boolean RND)
	/*
	   Equivalent amount calculated and
	   rounded for euro compliance
	
	   DESC:
		Given an amount in any currency this function will return the
		euro equivalent amount if the amount is an 'IN' currency, the
		'IN' equivalent amount if the amount is in euro, or null if the
		amount is in neither an 'IN' currency nor euro.  This function
		will round to the nearest "to" currency decimal.
	
	   KEYWORDS:
	        'IN' currency
		This is the national currency of a country that has
		opted to use the euro in place of its original currency.
	
		For example Germany has decided to take the
		euro as its new national currency.  Therefore "DEM" is
		an 'IN' currency.
	
		NOTE: The euro ("EUR") is NOT considered an 'IN'currency.
	
	   ARGUMENTS:
	   . AMT	Exchange $ Amount		/REQ/MECH=VAL
	
	   . FRCRCD	From Currency			/REQ/MECH=VAL
	                This is the currency of the amount
	
	   . TOCRCD	To Currency			/REQ/MECH=VAL
	                This is the currency into which the
	                amount is being exchanged
	
	   . RND	Round Flag			/NOREQ/MECH=VAL
	   		0 or Null - Do not round euro for IN to IN exch.
	     		1 - Round euro for IN to IN exchange
	
	   INPUTS:
	   . CO		Company Code			/TYP=T
	
	   RETURNS:
	   . $$		Equivalent Amount Rounded (EQVAMT)	/TYP=$
	   . FNCRATE	Fixed Notional Conversion Rate		/TYP=N

	
	   EXAMPLE:
	         S EQVAMT=$$EURRND^CRCDUTL(1000,"DEM","EUR")
	*/

	type Number DEC,EQVAMT
	
	if 'RND.data() set RND=0
	set EQVAMT=$$EUREQV(AMT,FRCRCD,TOCRCD,RND)

	quit $$^SCARND(EQVAMT,0,"",TOCRCD,DEC.get())


private EUREQV(Number AMT,String FRCRCD,String TOCRCD,Boolean RND)
	/*
	   Equiv amt calculated for euro compliance.
	   This will be called from EURCHK and EURRND.
	
	   DESC:
		Given an amount in any currency this function will return the
		euro equivalent amount if the amount is an 'IN' currency, the
		'IN' equivalent amount if the amount is in euro, or null if the
		amount is in neither an 'IN' currency nor euro.  It will round
	   	the intermediate amount based upon the value EMURND from
		institution variables if the round flag is set to 1.
	
	   ARGUMENTS:
	   . AMT	Exchange $ Amount			/REQ/MECH=VAL
	
	   . FRCRCD	From Currency				/REQ/MECH=VAL
	                This is the currency of the amount
	
	   . TOCRCD	To Currency				/REQ/MECH=VAL
	                This is the currency into which the
	                amount is being exchanged
	
	   . RND	Round Flag				/NOREQ/MECH=VAL
	     		0 - Do not round the euro amount
	     		1 - Round euro amount as specified in CUVAR
	
	   RETURNS:
	   . FNCRATE	Fixed Notional Conversion Rate		/TYP=N
	   . $$		Equivalent Amount (EQVAMT)		/TYP=$
	
	   EXAMPLE:
	         S EQVAMT=$$EUREQV^CRCDUTL(1000,"DEM","EUR")
	*/
	
	type Public Cache %CACHE()
	type Public Number EMURND,ER=0,FNCRATE
	type Public String CO,EMUCRCD
	
	type Number EQVAMT,RATE

	if RND.get().isNull() set RND=0
	if CO.get().isNull() set CO=CUVAR.CO
	if EMUCRCD.get().isNull() set EMUCRCD=CUVAR.EMUCRCD
	if EMURND.get().isNull() set EMURND=CUVAR.EMURND

	type RecordCRCD crcdemu=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:EMUCRCD")
	type RecordCRCD crcdfrom=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:FRCRCD")
	type RecordCRCD crcdto=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:TOCRCD")
	
	if 'crcdfrom.emu,'crcdto.emu quit ""
	set EQVAMT=AMT
	
	// Convert to euro
	if crcdfrom.emu do { quit:ER ""                
		set EQVAMT=$$EURCNV(.crcdfrom,AMT,0) quit:ER
		set RATE=FNCRATE
		if RND=1,EMURND'=9 set EQVAMT=$$^SCARND(EQVAMT,0,"","",EMURND)
		}
		
	// Convert to IN
	if crcdto.emu do { quit:ER ""                
		set EQVAMT=$$EURCNV(.crcdto,EQVAMT,1) quit:ER
		if RATE.data() set FNCRATE=$$^SCARND(FNCRATE/RATE,0,"","",crcdemu.ratdec)
		}

	quit EQVAMT
	
EURCNV(RecordCRCD crcd,Number AMT,Boolean MULT) // Called by EUREQV. 

	//Tool to convert currency using the fixed notional rate.

	type Public Number ER,FNCRATE=crcd.fncrate
	type Public String RM
	type Number EQVAMT

	// IN currency, ~p1, must have a fixed notional conversion rate
	if FNCRATE.isNull() set ER=1,RM=$$^MSG(3262,crcd.crcd) quit ""        
	set EQVAMT=$select(MULT:AMT*FNCRATE,1:AMT/FNCRATE)
	quit EQVAMT
	
EURCHK(RecordCRCD crcdbse,RecordCRCD crcdsec)
	/*
	This is only intended to be called from EXC^CRCDUTL
	It uses the arguments established in EXC.
	
	   RETURNS:
	   . RATE	Exchange rate				/TYP=N
	   . EXCAMT	Exchange amount				/TYP=$
	   . MINRATE	Minimum allowable exchange rate		/TYP=N
	   . MAXRATE	Maximum allowable exchange rate		/TYP=N
	
	*/

	type Public Boolean BSEAMT,MULTIPLY
	type Public Date EFD
	type Public Number AMT,CASH,CUSTCD,EXCAMT,MAXRATE,MINRATE,R8TYP,RATE,TRNTYP
	type Public String BSE,EMUCRCD,SEC
	
	new EURAMT,FNCRATE

	if EMUCRCD.get().isNull() set EMUCRCD=CUVAR.EMUCRCD

	// CASE1: IN to IN currency exchange
	if crcdbse.emu,crcdsec.emu do { quit 1

		type String FRCRCD,TOCRCD

		if BSEAMT set FRCRCD=BSE,TOCRCD=SEC
		else  set FRCRCD=SEC,TOCRCD=BSE

		// Option to Round (4th parameter)
		set EXCAMT=$$EUREQV(AMT,FRCRCD,TOCRCD,1)
		set (RATE,MINRATE,MAXRATE)=FNCRATE
		do RNDALL
		set MULTIPLY=1
		}
	
	// Non-IN to non-IN
	if 'crcdbse.emu,'crcdsec.emu quit 0

	// Base currency is not IN
	if 'crcdbse.emu do {
	
		// CASE2: From secondary to non-IN base currency
		if BSEAMT=0 do {
			set EURAMT=$$EUREQV(AMT,SEC,EMUCRCD,0)
			if BSE=EMUCRCD do { quit 
				set EXCAMT=EURAMT
				set (RATE,MINRATE,MAXRATE)=FNCRATE
				do RNDALL
				}
			do EXC(BSE,EMUCRCD,EURAMT,BSEAMT,TRNTYP,CASH,CUSTCD.get(),EFD,R8TYP.get())

			// exit state- MULTIPLY:BSE/EUR DIVIDE:EUR/BSE       
			set RATE=$select(MULTIPLY:RATE/FNCRATE,1:RATE*FNCRATE)
			set MINRATE=$select(MINRATE.get().isNull():"",MULTIPLY:MINRATE/FNCRATE,1:MINRATE*FNCRATE)     
			set MAXRATE=$select(MAXRATE.get().isNull():"",MULTIPLY:MAXRATE/FNCRATE,1:MAXRATE*FNCRATE)     
			}
	
		// CASE3: From non-IN base to secondary currency
		else  do {
			type Number MNR,MXR,NEWAMT,RT
			
			set NEWAMT=AMT
			if BSE'=EMUCRCD do {
				do EXC(BSE,EMUCRCD,AMT,BSEAMT,TRNTYP,CASH,CUSTCD.get(),EFD,R8TYP.get())
				set RT=RATE
				set NEWAMT=EXCAMT
				set MNR=MINRATE
				set MXR=MAXRATE
				}
			set EXCAMT=$$EUREQV(NEWAMT,EMUCRCD,SEC)
			if RT.get().isNull() set (RATE,MINRATE,MAXRATE)=FNCRATE
			else  do {
				set RATE=$select(MULTIPLY:RT*FNCRATE,1:RT/FNCRATE)    
				set MINRATE=$select(MNR.get().isNull():"",MULTIPLY:MNR*FNCRATE,1:MNR/FNCRATE)     
				set MAXRATE=$select(MXR.get().isNull():"",MULTIPLY:MXR*FNCRATE,1:MXR/FNCRATE)     
				}
			}
		}
	
	// Base currency is IN
	else  do {
	
		// CASE4: From secondary to IN base currency
		if BSEAMT=0 do {
			type Number MNR,MXR,NEWAMT,RT

			set NEWAMT=AMT
			if SEC'=EMUCRCD do {
				do EXC(EMUCRCD,SEC,AMT,BSEAMT,TRNTYP,CASH,CUSTCD.get(),EFD,R8TYP.get())
			
				// exit state- MULTIPLY:EUR/SEC, DIVIDE:SEC/EUR
				set RT=RATE
				set NEWAMT=EXCAMT
				set MNR=MINRATE
				set MXR=MAXRATE
				}
			set EXCAMT=$$EUREQV(NEWAMT,EMUCRCD,BSE,0)

			// Normal exchange returns 'multiply by' rate
			if %SystemCurrency=EMUCRCD do {
				set RATE=$select(RT.get().isNull():FNCRATE,MULTIPLY:RT*FNCRATE,1:RT*FNCRATE)
				set MINRATE=$select('MNR.data():FNCRATE,MNR.isNull():"",MULTIPLY:RT*FNCRATE,1:MNR*FNCRATE)
				set MAXRATE=$select('MXR.data():FNCRATE,MXR.isNull():"",MULTIPLY:RT*FNCRATE,1:MXR*FNCRATE)
				}

			// Cross exchange returns 'divide by' rate
			else  do {
				set RATE=$select(RT.get().isNull():FNCRATE,1:RT/FNCRATE)
				set MINRATE=$select('MNR.data():FNCRATE,MNR.isNull():"",1:MNR/FNCRATE)
				set MAXRATE=$select('MXR.data():FNCRATE,MXR.isNull():"",1:MXR/FNCRATE)
				}
			}
	
		// CASE5: From IN base to secondary currency
		else  do {
			set EXCAMT=$$EUREQV(AMT,BSE,SEC,0)
			set (RATE,MINRATE,MAXRATE)=FNCRATE
			if SEC'=EMUCRCD do {
				do EXC(EMUCRCD,SEC,EXCAMT,BSEAMT,TRNTYP,CASH,$G(CUSTCD),EFD,$G(R8TYP)) 
				/*
				Exit state MULTIPLY:SEC/EUR DIVIDE:EUR/SEC
				Normal exchange returns 'divide by' rate
				*/
				if %SystemCurrency=EMUCRCD do {
					set RATE=RATE*FNCRATE
					set MINRATE=$select(MINRATE.get().isNull():"",1:MINRATE*FNCRATE)
					set MAXRATE=$select(MAXRATE.get().isNull():"",1:MAXRATE*FNCRATE)
					}

				// Cross exchange returns 'multiply by' rate
				else  do {
					set RATE=$select(MULTIPLY:RATE/FNCRATE,1:RATE*FNCRATE)
					set MINRATE=$select(MINRATE.get().isNull():"",MULTIPLY:MINRATE/FNCRATE,1:MINRATE*FNCRATE)
					set MAXRATE=$select(MAXRATE.get().isNull():"",MULTIPLY:MAXRATE/FNCRATE,1:MINRATE*FNCRATE)
					}
				}
			}
		}
	
	do RNDALL
	quit 1
	

BUY(RecordCRCD crcd,	// Buying Base, Selling Quoted
	Number MARGINS,
	Number MARGINT,
	Number RATE,
	Number CSH,
	Date EFD)
	
	// Output: RATE - Exchange rate used in purchase

	type Public Number ER,RM,TERMS
	type Number BUY

	// Not valid for purchase
	if 'crcd.buy set RATE="",ER=1,RM=$$^MSG(2052,crcd.crcd) quit      

	// See MARGINS subroutine for structure of MARGINS
	if CSH set BUY=MARGINS.piece("|",2)       //Cash transaction
	else  set BUY=MARGINS.piece("|",4)        //Non-cash transaction
	set BUY=$select(TERMS:BUY,1:-BUY)
	
	if MARGINT set RATE=RATE+(RATE*(BUY/100))      	//   Margin type is %
	else  set RATE=RATE+BUY                		//   Margin type is fixed
	quit 
	

SELL(RecordCRCD crcd,	// Selling Base, buying Quoted
	Number MARGINS,
	Number MARGINT,
	Number RATE,
	Number CSH,
	Date EFD)

	//   Output: RATE - Exchange rate used in sale

	type Public Number ER,RM,TERMS
	type Number SELL

	//   Not valid for sale
	if 'crcd.sell set RATE="" set ER=1 set RM=$$^MSG(2053,crcd.crcd) quit

	
	// See MARGINS subroutine for structure of MARGINS
	if CSH set SELL=MARGINS.piece("|",3) 		//Cash transaction 
	else  set SELL=MARGINS.piece("|",5)		//Non-cash transaction
	set SELL=$select(TERMS:-SELL,1:SELL)	
	
	if MARGINT set RATE=RATE+(RATE*(SELL/100))	// Margin type is %
	else  set RATE=RATE+SELL			// Margin type is fixed
	quit 
	

public MINMAX(String CRCD)	// Minimum/maximum rates
	/*
	
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency Code			/REQ/MECH=VAL
	
	   RETURNS:
	   . MAXRATE  - Maximum rate allowed		/TYP=$
	   . MINRATE  - Minimum rate allowed		/TYP=$
	   . VARIANCE - Percent Variance Before		/TYP=N
	         	Treasury Reference Required
	
	   EXAMPLE:
	   . do MINMAX^CRCDUTL("USD")
	
	*/
	type Public Cache %CACHE()
	type Public Number MAXRATE,MINRATE,VARIANCE
	type Public String CO

	if CO.get().isNull() set CO=CUVAR.CO
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")

	set MINRATE=crcd.minrate
	set MAXRATE=crcd.maxrate
	set VARIANCE=crcd.variance
	
	quit 

	
public RATE(String CRCD,Date EFD)
	/*
	
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency Code				/REQ/MECH=VAL
	
	   . EFD	Effective Date				/NOREQ/DFT=%SystemDate
	
	   INPUT:
	   . CO		Company Code				/TYP=T/REQ

	   . R8TYP	Rate Type				/TYP=N/NOREQ/DFT=1


	   RETURNS:
	   . $$		The Rate based upon rate type		/TYP=N

	   . TERMS	Multiply by base indicator
			0 - Inverted Rate - Divide by base
			1 - Non-inverted  - Multiply by base
	
	   EXAMPLE:
	   . S RATE=$$RATE^CRCDUTL("USD",TJD-1)
	
	*/

	type Public Boolean TERMS
	type Public Number ER,R8TYP
	type Public String CO,RM
	type Date DT
	type Number RATE,SEQ

	// Undefined Host Variable ~p1	
	if CO.get().isNull() set ER=1,RM=$$^MSG(8592,":CO") quit
	if CRCD.get().isNull() set ER=1,RM=$$^MSG(8592,":CRCD") quit
	
	if EFD.get().isNull() set EFD=%SystemDate
	
	// Default to Mid-rate  			
	if R8TYP.get().isNull() set R8TYP=1            			
	
	set (RATE,TERMS)=""
	if EFD<%SystemDate do {
		type DbSet ds=Db.selectDbSet("CRCDRATEH","CO=:CO AND CRCD=:CRCD AND EFD<:EFD+1","EFD DESC,SEQ DESC")
		quit:ds.isEmpty()
							
		type String X=ds.next()
		type RecordCRCDRATEH  crcdrate=ds.getRecord("CRCDRATEH")
		set TERMS=crcdrate.terms
		if R8TYP=1 set RATE=crcdrate.midrate quit
		if R8TYP=2 set RATE=crcdrate.spotbid quit
		if R8TYP=3 set RATE=crcdrate.spotoffer quit
		if R8TYP=4 set RATE=crcdrate.otcbid quit	
		if R8TYP=5 set RATE=crcdrate.otcoffer quit
		if R8TYP=6 set RATE=crcdrate.offbid quit
		if R8TYP=7 set RATE=crcdrate.offoffer quit
		if R8TYP=8 set RATE=crcdrate.finspot
	}
	
	if RATE.isNull() do {

		type Public Cache %CACHE()
		type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")

		set TERMS=crcd.terms
		if R8TYP=1 set RATE=crcd.midrate quit
		if R8TYP=2 set RATE=crcd.spotbid quit
		if R8TYP=3 set RATE=crcd.spotoffer quit
		if R8TYP=4 set RATE=crcd.otcbid quit	
		if R8TYP=5 set RATE=crcd.otcoffer quit
		if R8TYP=6 set RATE=crcd.offbid quit
		if R8TYP=7 set RATE=crcd.offoffer quit
		if R8TYP=8 set RATE=crcd.finspot
	}

	// Default to inverted format
	if TERMS.isNull() set TERMS=0			
	if RATE.isNull() set RATE=1
	
	quit RATE
	
	
public MARGINS(Number AMT,
		String CRCD,
		Number CUSTCD,
		Date EFD,
		Number MARGINS)
	/*
	
	   This subroutine will return the margin type and in a variable called
	   MARGINS, the pertinent threshhold and the four corresponding margins
	   will be placed, "|" delimited.
	
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . AMT	Exchange amount				/REQ/MECH=VAL
	     		Used to determine treasury reference
	
	   . CRCD	Currency Code				/REQ/MECH=VAL
	
	   . CUSTCD	Customer Code				/REQ/MECH=VAL
	
	   . EFD	Effective Date				/NOREQ/DFT=TJD
	
	   . MARGINS	Margins to use for rate calculation	/MECH=REF
	
	
	   RETURNS:
	   . MARGINT	Margin type
	   . MARGINS	Buy/sell margins
	     		Margin information:
	        	THRESHOLD - piece 1  (threshold amount)
	        	BUYCASH  - piece 2  (buy margin cash)
	        	SELLCASH - piece 3  (sell margin cash)
	        	BUYNCASH - piece 4  (buy margin non cash)
	        	SELLNCASH - piece 5  (sell margin non cash)
	
	   . TRESREF	Treasury reference req'd
	     		(0=no, 1=yes)
	     		(May already be defined)
	
	   EXAMPLES:
	   . D MARGINS^CRCDUTL(1000.00,"USD",0,"",.MARGINS)
	
	*/

	type Public Number MARGINT,TRESREF
	type Public String CO
	
	type Boolean THRSHHI=0
	type Date EDATE=%EffectiveDate.get(),TDATE=%SystemDate.get()
	type Number ER=0,I,THRSH()
	
	set (MARGINT,MARGINS)=""
	set TRESREF=+TRESREF.get()
	set CUSTCD=+CUSTCD.get()
	if CO.get().isNull() set CO=%CompanyName
	if TDATE.isNull() set TDATE=%CurrentDate
	if EDATE.isNull() set EDATE=TDATE

	type RecordCRCDMG crcdmg=Class.new("RecordCRCDMG")
	if EDATE<TDATE do {
		type DbSet ds=Db.selectDbSet("CRCDMGH","CO=:CO and CRCD=:CRCD and CUSTCD=:CUSTCD and EFD<:EDATE+1","EFD DESC,SEQ DESC")
		if 'ds.next() quit

		type RecordCRCDMGH crcdmgh=ds.getRecord("CRCDMGH")
		set crcdmg=crcdmgh.copy()
		do crcdmg.setMode(1)
		}

	if crcdmg.getMode()=0 set crcdmg=Db.getRecord("CRCDMG","CO=:CO,CRCD=:CRCD,CUSTCD=:CUSTCD",1)
	
	set MARGINT=crcdmg.margint
	
	// No thresholds set            
	if crcdmg.tresref.curVal.isNull() quit

	set THRSH(1)=crcdmg.tresref_"|"_crcdmg.buycash_"|"_crcdmg.sellcash_"|"_crcdmg.buyncash_"|"_crcdmg.sellncash
	set THRSH(2)=crcdmg.tresref2_"|"_crcdmg.buycash2_"|"_crcdmg.sellcash2_"|"_crcdmg.buyncsh2_"|"_crcdmg.sellncsh2
	set THRSH(3)=crcdmg.tresref3_"|"_crcdmg.buycash3_"|"_crcdmg.sellcash3_"|"_crcdmg.buyncsh3_"|"_crcdmg.sellncsh3

	set MARGINS=THRSH(1)
	
	for I=3,2,1 do {
		set THRSH=THRSH(I).piece("|",1)
		if THRSH.isNull() kill THRSH(I) quit
		if THRSHHI quit
		set THRSHHI=1
		if AMT'>THRSH quit
		set TRESREF=1
		}

	set I=""
	for  set I=THRSH(I).order() quit:I.isNull()  do {	// Compare against each threshhold
		type Number N
		if AMT'>THRSH(I) quit                 	// Amount is w/i threshhold
		set N=THRSH(I).order()
		if N.isNull() quit		 	// No higher threshholds exist
		set MARGINS=THRSH(N)                  	// margins for that threshhold
		}
	quit 

	
public CAMT(String BSE,String SEC,Number AMT)	// Cash value in base currency
	/*
	
	   DESC:
	   Cash value in base currency
	
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . BSE	Base Currency Code			/REQ/MECH=VAL
	
	   . SEC	Secondary Currency Code			/REQ/MECH=VAL
	
	   . AMT	Exchange $ amount			/REQ/MECH=VAL
	    		either in base currency or secondary currency
	
	   RETURNS:
	   . AMT	Cash value of argument AMT		/TYP=$
	    		After doing exchange where no margins
	    		apply (ie cash flag=2 when calling EXC^CRCDUTL)
	
	*/

	type Public Number ER="" 
	type Boolean MULTIPLY
	type Number EXCAMT,MAXRATE,MINRATE,RATE,TRESREF

	set EXCAMT=0
	do EXC(BSE,SEC,AMT,1,2,"")
	set AMT=$$^SCARND(EXCAMT,0,"",SEC)  
	quit 
	
public desc(String CRCD)	// Currency code description
	/*
	
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Description from the CRCD file
	*/
	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.desc
	
public	crcdno(String CRCD)	// Currency code number
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Currency code number from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.crcdno
	
public	retail(String CRCD)	// Available for retail use flag
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Retail use flag from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.retail
	
public	buy(String CRCD)	// Currency Available for buy
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Available for buy flag from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.buy
	
public	sell(String CRCD)	// Avail for sell flag
	/*
	
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Available for sell flag from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.sell
	
public	variance(String CRCD)	// Variance % before Treasury ref required
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Variance % for treasury ref from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.variance
	
public curdec(String CRCD)	// Currency deciaml precision for rounding $$$ fields
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Currency decimal precision from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.curdec
	
public	ratdec(String CRCD)	// Rate decimal precision
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Currency rate decimal prec from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.ratdec

public	cntry(String CRCD)	// Country code for given currency
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Country code from the CRCD file
	*/
	
	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.cntry
	
public	calendar(String CRCD)	// Currency Calendar
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Currency calendar from the CRCD file
	*/
	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.calendar
	

public	cashcur(String CRCD)	// Cash currency flag
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Cash Currency flag from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.cashcur
	

public	minrate(String CRCD)	// Minimum rate allowed for exchange
	/*
	
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Minimum rate allowed for exchange from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.minrate
	
public	maxrate(String CRCD)	// Maximum rate allowed for exchange
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Maximum rate allowed for exchange from the CRCD file
	*/
	
	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.maxrate
	
public	chkdesc(String CRCD)	// Check print description
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Check print description from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.chkdesc
	
public	sysceq(String CRCD)	// System Currency equivalent (Y/N)
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		System currency equivalent flag from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.sysceq
	
public	mincash(String CRCD)	// Minimum cash denomination amount
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Minimum cash denomination amount from the CRCD file
	*/
	
	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.mincash
	
public factor(String CRCD)	// Returns 'Payment Order Accepted' value ([CRCD]POACC)
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Returns 'Payment Order Accepted' value ([CRCD]POACC)
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.poacc
	
public	conv(String CRCD)	// Convertible currency flag
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Convertible currency flag from the CRCD file
	*/
	
	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.conv

public	otcgl(String CRCD)	// Over the counter position G/L account linkage
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$ 	Over the counter position G/L account from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.otcgl
	
public	tfsgl(String CRCD)	// Trade Finance position G/L account linkage
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Trade Finance position G/L account from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.tfsgl
	
public	spotgl(String CRCD)	// Spot position G/L account linkage
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Spot position G/L account from the CRCD file
	*/
	
	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.spotgl
	

public	bsotcgl(String CRCD)	// Over the counter base position G/L account linkage
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Over the counter base position G/L from the CRCD file
	*/

	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.bsotcgl
	
public	bsspotgl(String CRCD)	// Spot base position G/L account linkage
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		Spot base position G/L account from the CRCD file
	*/
	
	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.bsspotgl
	
	
public	terms(String CRCD)	// Multiply Rate X Base
	/*
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . CRCD	Currency code			/REQ/MECH=VAL
	
	   RETURNS:
	   . $$		A flag that indicates whether the exchange rates for this 
	   		currency is inverted or non-inverted.
	*/
	
	type Public Cache %CACHE()
	type Public String CO
	
	if CO.get().isNull() set CO=CUVAR.CO
	
	type RecordCRCD crcd=%CACHE("CRCD").getRecord("CRCD","CO=:CO,CRCD=:CRCD")
	quit crcd.terms

	
	
tresamt(String CRCD,Number RATE)	// Return  appropriate amount to use in MARGINS
	/*
	   This function is called when an exchange is being performed and the
	   amount is defaulted.  It is used to determine what amount to use when
	   calling in to MARGINS.
	
	   INPUTS:
	   . CRCDBASE 	- Screen base currency
	*/

	type Public Number TRESAMT()
	type Public String CRCDBASE
	
	type Number bseamt
	type String crcd
	
	if CRCDBASE.get().isNull() quit 0
	
	set bseamt=TRESAMT(CRCDBASE).get()
	
	set crcd=""
	for  set crcd=TRESAMT(crcd).order() quit:crcd.isNull()  if crcd'=CRCDBASE set bseamt=bseamt-TRESAMT(crcd)

	// Already in base currency
	if CRCDBASE=%SystemCurrency quit bseamt	
	
	quit bseamt*RATE


public	EXCH(RecordTTX ttx())	// Compute exchange if necessary
	/*
	   DESC:
	   Performs exchanged based upon entries with ttx array, also
	   generates the secondary balancing exchange offsets to
	   postion accounts.
	
	   KEYWORDS: Transaction Processing
	
	   ARGUMENTS:
	   . ttx()	Transaction record		/TYP=RecordTTX/REQ/MECH=REFARY:RW

	   RETURNS:
	   . ttx	Updated transaction record	/TYP=RecordTTX
	    		array.
	
	   . ER		Error flag			/TYP=L/COND
	
	   . RM		Return error message		/TYP=T/COND=(ER=1)

	*/

	type Public Number ACCFLG,ER=0,ORIGTM

	type Boolean BSEAMT
	type Number CASH,CCODE,CID,EXCAMT,R8TYP,SEQ,TAMT,TRNTYP
	type String CLS,CRCD
	
	/*
	If we only have 1 side of a transaction, then don't
	perform the exchange.  This will end up in the
	exception file.
	*/

	if $order(ttx(""),-1)'>1 quit

	for SEQ=1:1 quit:'ttx(SEQ).getPointer()  do EXCH1(.ttx(SEQ)) quit:ER 
	
	if 'ACCFLG.data() do EXCHOFF^TTXEXT(.ttx())
	
	/*
	If were running in batch mode, don't kill the
	entire batch if we hit an error...
	*/
	
	if (ORIGTM.get() = 0) set ER=0

	quit 
	

EXCH1(RecordTTX ttx)
	/*
	   Check each transaction to see if the currency of the transaction
	   matches the currency of the account.
	*/

	type Public Number CID,ER
	type Public String CLS,CRCD,R8TYP,RM,TAMT
	
	type Boolean BSEAMT
	type Number EXCAMT,RATE,TRNTYP
	type String CASH,CCODE,TTXCRCD,XCRCD
	
	// Don't process inquiries
	set CID=ttx.cid 
	if CID.isNull() quit
	
	set TAMT=ttx.tamt
	do {
		type String ETC=ttx.etc
		type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC")
		set CLS=trn.cls
		}
	
	set TTXCRCD=ttx.crcd
	if TTXCRCD.isNull() set TTXCRCD=%SystemCurrency
	
	if CLS="M" do { quit:XCRCD.isNull()!'TAMT
		set CRCD=TTXCRCD
		set TAMT=ttx.bseamt
		set XCRCD=ttx.udprin
		}
	
	else  do {
		set CCODE=ttx.custcd
		type RecordACN acn=Db.getRecord("ACN","CID=:CID")
		set CRCD=acn.crcd
		set XCRCD=TTXCRCD
		}
	
	if CRCD=XCRCD quit
	
	// Currency is not convertible
	if '$$conv(XCRCD) set ER=1,RM=$$^MSG(679,XCRCD) quit

	if XCRCD=TTXCRCD set BSEAMT=1
	else  set BSEAMT=0		
		
	if 'R8TYP.data() set R8TYP=1
	set TRNTYP=$select(ttx.itc.curVal.extract():0,1:1)
	set CASH="00"
	do EXC(XCRCD,CRCD,TAMT,BSEAMT,TRNTYP,CASH,CCODE,%EffectiveDate.get(),R8TYP,%CompanyName)
	quit:ER

	set EXCAMT=$$^SCARND(EXCAMT,0,"",CRCD)     
	
	// Transaction Amount
	set ttx.tamt=EXCAMT

	// Currency Code
	set ttx.crcd=CRCD

	// Exchange Rate
	set ttx.rate=RATE

	// Screen Base Amount (Currency Exchange)
	set ttx.bseamt=TAMT

	// Undisbursed Principal
	set ttx.udprin=XCRCD
	
		
	quit 
	
public CONV(Number AMT,String CRCD,String BSE,Number R8TYP,Date EFD)	// Exchange value
	/*
	   DESC: Calculate an exchange amount which is used for multi-currency
	         service fee plans.
	
	   KEYWORDS: Service Fee Processing
	
	   ARGUMENTS:
		. AMT	Exchange $ amount			/REQ/MECH=VAL
	    		either in base currency or secondary currency
	
		. CRCD	Accounts Currency Code			/REQ/MECH=VAL
	
		. BSE	Base Currency Code			/REQ/MECH=VAL
	
		. R8TYP	Rate Type (1-8), ...			/NOREQ/DFT=0
	    		Where:
	    		1 - MID-RATE	8 - FINSPOT
	   		2 - SPOTBID	3 - SPOTOFFER
	    		4 - OTCBID	5 - OTCOFFER
	    		6 - OFFBID	7 - OFFOFFER
	
		. EFD   Effective date   			/NOREQ/MECH=VAL
		
	   RETURNS:
		. $$	Exchange amount   /TYP=$
	
	*/

	type Public Number CUSTCD
	type Boolean MULTIPLY
	type Number EXCAMT,MAXRATE,MINRATE,RATE,TRESREF,VARIANCE
	type String CSH

	if BSE.isNull() set BSE=%SystemCurrency
	if CRCD=BSE quit AMT

	if R8TYP.get().isNull() set R8TYP=0
	set EFD=EFD.get()

	do EXC(BSE,CRCD,AMT,1,2,11,CUSTCD.get(),EFD,R8TYP)
	
	set EXCAMT=$$^SCARND(EXCAMT,0,"",CRCD)
	quit EXCAMT
	
	
public	CRCDRATE(String CRCD,Number AMT,Number BAMT,String CO)
	/*
	DESC:  Exchange Amount
	
	ARGUMENTS:

		. CRCD	Secondary Currency Code		/REQ/MECH=VAL

		. AMT	Secondary $ amount		/REQ/MECH=VAL

		. BAMT	Base $ amount			/REQ/MECH=VAL

		. CO	Company Code			/NOREQ/DFT=CUVAR.CO

	RETURNS:
		. $$	Exchange amount   		/TYP=$

	*/

	type Public String BSE
	
	type Boolean TERMS
	type Number RATE

	if CRCD=BSE quit AMT
		
	set TERMS=$$terms(CRCD)
	if TERMS=1 set RATE=AMT*BAMT
	else  set RATE=BAMT/AMT
	
	quit RATE
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60690^22093^Senthilkumar Jeyaeasan^47250"	// Signature - LTD^TIME^USER^SIZE
