CHKALL	// Check Allocation
	/*
	       ORIG: Marty Ronky - (3623) 05/22/91

	 ---- Revision History ------------------------------------------------
	 
	 04/15/06 - PUTTASWH - CR20665
	 	    Modified VER section to update CHKINS record with the
	 	    LOW check number.
	 	    
	 04/11/06 - KinI - CR20537
	 	    Modified VPG00 section to correct query syntax.
	 
	 02/28/06 - PUTTASWH - CR19783
	 	    Modified DELRNG section to pick appropriate records.
	 	    
	 10/13/05 - PUTTASWH - CR17011
	 	    Modified page control logic according to new standard.
	  	    Modified INIT section to contain the code of VPG and 
	  	    VPG0 sections. Removed VPG and VPG0 sections.	 	   
	 
	 01/05/03 - CARROLLJ - CR7658
		    Corrected parameter mismatch errors.

	 06/17/02 - Geetha Krishna - ARQ# 49794
		    Converted to PSL
	-----------------------------------------------------------------------
	*/
	
	do UPD

	quit

	
UPD
	set %ProcessMode=0 
	do INIT 
	
	quit


DEL
	set %ProcessMode=3
	do INIT
	
	quit


INIT

	type public Number %PAGE,%PG
	type Boolean FINISH
	
	set %PG=0 
	set %PAGE=1
	set FINISH=0

	kill OLNTB,VFMQ,TYPQRY
	set CLASS=$G(CLASS)

	if CLASS set TYPQRY="[UTBLCHKS]CHKCLS=1"
	else  set TYPQRY="[UTBLCHKS]CHKCLS'=1"	
	
	for  do { quit:FINISH
                if %PG=0 do VPG00 if ER set FINISH=1 quit
               
                if %PG>0 do VPG01

                if "DFQ"[VFMQ!$G(ER) do VER set FINISH=1 quit

                set %PG=%PG+1
                }
	
	quit


VPG00	// Entry for page 1

	set %TAB("BRCD")=".BRCD1/TBL=[UTBLBRCD]"
	set %TAB("TYPE")=".CHKTYP1/TBL=""[UTBLCHKS]:QU """""_TYPQRY_"""""""/XPP=D PP^CHKALL"
	set %READ="@@%FN,,,BRCD/REQ,TYPE/REQ" 
	set %NOPRMT="N"

	do ^UTLREAD 

	if VFMQ="Q" set ER=1

	quit


PP	
	quit:X=""	

	type RecordUTBLCHKS utblchks=Db.getRecord("UTBLCHKS","CHKS=:X",1)
	if 'utblchks.getMode() quit

	set CHKCLS=utblchks.chkcls

	if $G(CHKCLS)=1,(%OSAVE=0) do { quit:$G(ER)

		// check type not avaliable at institution
		if 'Db.isDefined("CHKINSSEQ","CHKS=:X") do Runtime.setErrMSG("CHKINSSEQ",8686) quit
		}

	if %OSAVE=0 quit

	// No ~p1 checks are allocated to branch ~p2
	type ResultSet rs=Db.select("TYPE","CHKALLOC","BRCD=:BRCD AND TYPE=:X")
	if rs.isEmpty() set ER=1 set RM=$$^MSG(2002,X,BRCD) 

	quit


VPG01	

	set %READ=""
	set OLNTB=5000
	if $G(CHKCLS)=1 do {  quit:ER

		set %TAB("CHKB")=$$DI^SCATAB("[CHKALLOC]LOW",,,,"D POSLOW^CHKALL")
		set %TAB("CHKE")=$$DI^SCATAB("[CHKALLOC]HIGH",,,,"D POSHIGH^CHKALL")

		lock +CHKINS(TYPE):2 else  set ER=1 set ET="RECLOC" do ^UTLERR quit

		quit:%ProcessMode

		set %TAB("CHKN")=".CHKCNT1/XPP=D POSCHKN^CHKALL"
		set %READ="CHKN,"
		}
	else  do {
		set %TAB("CHKB")=".CKNB1/XPP=D POS1^CHKALL/XPR=D PRE1^CHKALL"
		set %TAB("CHKE")=".CHKE1/XPP=D POS2^CHKALL"
		}

	quit:$G(ER)=1

	set %READ=%READ_"CHKB/REQ"
	if (%ProcessMode=0)!($G(CHKCLS)=1) set %READ=%READ_",CHKE/REQ"

	do ^UTLREAD 

	if VFMQ="Q" set ER=1
	quit


POSCHKN

	quit:'+X

	// value must be greater than zero
	if +X<0 do Runtime.setErrMSG("CHKALLOC",2921) quit

	new AUX,HI,LO
 
	set AUX=""
	type ResultSet rs=Db.select("HIGH","CHKINS","CHKS=:TYPE","HIGH")
	while rs.next() set AUX=rs.getCol(1) do { quit:(((AUX'?.N)&(HI']]AUX)&(HI'=""))!((AUX?.N)&(HI'>AUX)&(HI'="")))

		type RecordCHKINS chkins=Db.getRecord("CHKINS","CHKS=:TYPE,HIGH=:AUX")
		set LO=chkins.low
		set HI=$$CHKNXT^CHKNUTL(LO,X-1)

		if HI="" set ER=0 kill RM
		}

	if AUX'="" do {
		set RM($O(RM(""),-1)+1)=LO_"|"_(NI+1) set CHKB=LO kill vdft(NI+1)
		set RM($O(RM(""),-1)+1)=HI_"|"_(NI+2) set CHKE=HI kill vdft(NI+2)
		}
	else  do {

		// No check range big enough
		do Runtime.setErrMSG("CHKINS",8709)
		}

	quit


PRE1

	if %OSAVE'=3 quit

	kill CEND,CEND1

	new Y,Z

        type ResultSet rs=Db.select("HIGH,LOW","CHKALLOC","BRCD=:BRCD AND TYPE=:TYPE","HIGH")
	while rs.next() do {

			set Y=rs.getCol(1)
			set Z=rs.getCol(2)
	
			//   through ~p1
			set CEND(Z)=$$^MSG(6407,Y)
			set CEND1(Z)=Y
		}
	set I(3)="CEND("
	quit


POSLOW

	quit:$$INVFMT^CHKNUTL(X)

	new EXT

	// Allocation
	if '%OSAVE do { quit
		set EXT=$$EXTINST^CHKINS(TYPE,X,X)

		// Check range not allocated to institution
		if EXT'=2 do Runtime.setErrMSG("CHKINS",8699) quit

		// Default the high check number if CHKN is not null.
		if CHKN'="" do {
			set CHKE=$$CHKNXT^CHKNUTL(X,CHKN-1)
			set RM($O(RM(""),-1)+1)=CHKE_"|"_(NI+1)
			kill vdft(NI+1)
			}
		}

	// Deallocation

	set EXT=$$EXTBRCD^CHKINS(TYPE,X,X,BRCD)
	if EXT'=2 set ER=1 quit

	quit


POSHIGH

	quit:$$INVFMT^CHKNUTL(X)

	if X?.N do {
		if CHKB>X do { quit

			/* Ending check number must be greater than or equal
			   to starting check number
			*/
			do Runtime.setErrMSG("CHKINS",895)
			}
		}
	else  do {

		// Ending check number must be greater than or equal to starting check number
		if CHKB]]X set ER=I do Runtime.setErrMSG("CHKINS",895)
		}
	
	quit:ER.get()
	
	new EXT

	// Allocate
	if '%OSAVE do { quit
		set EXT=$$EXTINST^CHKINS(TYPE,CHKB,X)

		// check range not allocated to institution
		if EXT'=2 do Runtime.setErrMSG("CHKINS",8699) quit
		}

	// Deallocate
	set EXT=$$EXTBRCD^CHKINS(TYPE,CHKB,X,BRCD)

	if EXT'=2 set ER=1 quit

	quit


POS1

	if %OSAVE=3 set CHKE=$G(CEND1(X)) quit

	// Ensure that the starting check isn't allocated if %O=0,
	// and that it is if %O=3.
	
	new BR,HIGH

	type ResultSet rs=Db.select("BRCD,HIGH,LOW","CHKALLOC","TYPE=:TYPE","BRCD,HIGH")
	while rs.next() do { quit:$G(ER)

		set BR=rs.getCol(1)
		set HIGH=rs.getCol(2)
		set LOW=rs.getCol(3)

		// Check ~p1 is allocated to branch ~p2
		if X?.N do {

			// Check ~p1 is allocated to branch ~p2
			if X'<LOW,X'>HIGH set ER=1 set RM=$$^MSG(545,X,BR) quit
			}
		else  do {
	
			// Check ~p1 is allocated to branch ~p2
			if X=LOW!(X]]LOW),X']]HIGH set ER=1 set RM=$$^MSG(545,X,BR) quit
			}
		}
	
	quit


POS2

	type Number BR
	type String HIGH,LOW
	
	quit:$G(ER)

	// Ensure that checks in the range aren't allocated if %O=0,
	// and that they are if %O=3.

	// Ending check number must be greater than or equal to starting check number
	if X<CHKB do Runtime.setErrMSG("CHKINS",895)	
	
	type ResultSet rs=Db.select("BRCD,HIGH,LOW","CHKALLOC","TYPE=:TYPE")
	while rs.next() do {		
		
		set BR=rs.getCol("BRCD")
		set HIGH=rs.getCol("HIGH")
		set LOW=rs.getCol("LOW")
		
		if %OSAVE=0 do {
			
			if X?.N do {

				// Check ~p1 is allocated to branch ~p2
				if X'<LOW,X'>HIGH set ER=1 set RM=$$^MSG(545,X,BR) quit

				// Range ~p1 to ~p2 are allocated to branch ~p3
				if LOW>CHKB,X'<LOW set ER=1 set RM=$$^MSG(2308,LOW,HIGH,BR)

				//Range ~p1 to ~p2 are allocated to branch ~p3
				if CHKB>HIGH,X'>HIGH set ER=1 set RM=$$^MSG(2308,LOW,HIGH,BR)
				}
			else  do {

				// Check ~p1 is allocated to branch ~p2
				if X=LOW!(X]]LOW),X']]HIGH set ER=1 set RM=$$^MSG(545,X,BR) quit

				// Range ~p1 to ~p2 are allocated to branch ~p3
				if LOW]]CHKB,X=LOW!(X]]LOW) set ER=1 set RM=$$^MSG(2308,LOW,HIGH,BR)

				// Range ~p1 to ~p2 are allocated to branch ~p3
				if CHKB]]HIGH,X']]HIGH set ER=1 set RM=$$^MSG(2308,LOW,HIGH,BR)
				}
			}
			
		quit:$G(ER)		
		}
	
	quit


VER

	if $G(ER)!(VFMQ="Q") do END quit

	type RecordCHKALLOC chkalloc
	
	type RecordCHKINS chkins=Db.getRecord("CHKINS","CHKS=:TYPE,HIGH=:CHKE",1)	

	set chkins.low=CHKB
	
	if $G(CHKCLS)=1 do { do END quit
		 
		if %ProcessMode=0 do { quit
		
			set chkalloc=Class.new("RecordCHKALLOC")

			// Deallocate from institution
			do DELRNG^CHKINS(.chkins,CHKB)

			set chkalloc.low=CHKB
			set chkalloc.issd=%SystemDate
			set chkalloc.uid=%UserID

			// Allocate to branch			
			set chkalloc.brcd=BRCD
			set chkalloc.type=CHKS
			set chkalloc.high=HIGH

			do chkalloc.bypassSave()
			}

		if %ProcessMode=3 do { quit

			// Deallocate from the branch
			do DELRNG(BRCD,TYPE,CHKE,CHKB)

			// Allocate to institution
			do INSRNG^CHKINS(.chkins)
			}
		}
		
	set chkalloc=Db.getRecord("CHKALLOC","BRCD=:BRCD,TYPE=:TYPE,HIGH=:CHKE",1)
	do chkalloc.setAuditFlag(1)
	set chkalloc.low=CHKB
	set chkalloc.issd=%SystemDate
	set chkalloc.uid=%UserID
	do chkalloc.bypassSave()	

	do END
	
	quit


END

	lock

	quit:$G(ER)

	if VFMQ="Q" do {
	
		// Check type ~p1 for branch ~p2 not created
		if %ProcessMode=0 set RM=$$^MSG(542,TYPE,BRCD) quit

		// Check type ~p1 for branch ~p2 not deleted
		set RM=$$^MSG(543,TYPE,BRCD)
		}

	else  do {

		// Check type ~p1 for branch ~p2 created
		if %ProcessMode=0 set RM=$$^MSG(540,TYPE,BRCD) quit

		// Check type ~p1 for branch ~p2 deleted
		set RM=$$^MSG(541,TYPE,BRCD)
		}

	set ER="W"

	quit


ERR	
	set ER=1 do ^UTLERR
	set VFMQ="Q"

	quit


DELRNG(Number BRCD,	// Branch code
	String CHKS,	// Check type
	Number HIGH,	// High check number
	Number CHKB1)	// Begin check number 

	// Delete part or a range in CHKALLOC
	
	type Date ISSD
	type String AUX,HI,LO,UID		

	set (HI,LO,UID,ISSD)=""
	set AUX=HIGH
	
	type ResultSet rs=Db.select("HIGH,LOW,ISSD,UID","CHKALLOC","BRCD=:BRCD AND TYPE=:CHKS AND HIGH>=:AUX")
	if rs.next() do {
		set AUX=rs.getCol("HIGH")
		set LO=rs.getCol("LOW")
		set ISSD=rs.getCol("ISSD")
		set UID=rs.getCol("UID")
		}

	// Deallocate entire range
	do Db.delete("CHKALLOC","BRCD=:BRCD AND TYPE=:CHKS AND HIGH=:AUX")

	if LO'=CHKB1 do {

		// Allocate the beginning range
		set HI=$$CHKPRV^CHKNUTL(CHKB1)
		
		type RecordCHKALLOC chkalloc2=Db.getRecord("CHKALLOC","BRCD=:BRCD,TYPE=:CHKS,HIGH=:HI",1)
				
		set chkalloc2.low=LO
		set chkalloc2.issd=ISSD
		set chkalloc2.uid=UID

		do chkalloc2.bypassSave()
                }

	if AUX'=HIGH do {

		type RecordCHKALLOC chkalloc1=Db.getRecord("CHKALLOC","BRCD=:BRCD,TYPE=:CHKS,HIGH=:AUX",1)
		
		// Allocate the ending range
		set LO=$$CHKNXT^CHKNUTL(HIGH)

		set chkalloc1.low=LO
		set chkalloc1.issd=ISSD
		set chkalloc1.uid=UID
		do chkalloc1.bypassSave()

		}

	quit
	
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60370^24661^Hema Puttaswamy^9226"	// Signature - LTD^TIME^USER^SIZE
