DENLIM
	/*	
	   ORIG: SAVITSKYS - 08/31/95
	   DESC: Denomination Limit Maintenance Routine

	   This procedure is used to handle all Denomination Limits processing
	   for Branch, Userclass and User levels. It enables the creation,
	   maintenance, and deletion of all the three levels, as well as the
	   copying of branch and userclass limit information from one selected
	   branch or userclass to one or more recipients.

	   ------------ Revision History ---------------------------------------

	   01/25/06 - TITOVE - CR 19226
	   	      Added instantiation of UTBLDENOM table to VPG01 and VPG02
	   	      sections. Restored scoping and array-naming logic for
	   	      limits copying processing.

	   05/05/05 - TITOVE - CR 14192
		      Modified as part of DBI2 project. Removed unused sections
		      BRINQ, UCINQ and URINQ. Created CSEQ section for computed
		      column UTBLDENOM.CSEQ.

	   03/25/02 - CHHABRIAS - 49451
		      Converted to PSL.

	   ---------------------------------------------------------------------
	*/
	quit
	

public	BRNEW	// Branch Denomination Limit Creation Entry Point

	type Boolean CPYFLG = 0
	type String TYPE = "BR"

	do INIT(0)
	
	quit


public	BRMAIN	// Branch Denomination Limit Maintenance Entry Point

	type Boolean CPYFLG = 0
	type String TYPE = "BR"
	
	do INIT(1)
	
	quit


public	BRCPY	// Branch Denomination Limit Copy Entry Point

	type Boolean CPYFLG = 1
	type String TYPE = "BR"
	
	do INIT(1)
	
	quit


public	BRDEL	// Branch Denomination Limit Deletion Entry Point

	type Boolean CPYFLG = 0
	type String TYPE = "BR"
	
	do INIT(3)
	
	quit


public	UCNEW	// Userclass Denomination Limit Creation Entry Point

	type Boolean CPYFLG = 0
	type String TYPE = "UC"
	
	do INIT(0)
	
	quit


public	UCMAIN	// Userclass Denomination Limit Maintenance Entry Point

	type Boolean CPYFLG = 0
	type String TYPE = "UC"
	
	do INIT(1)
	
	quit


public	UCCPY	// Userclass Denomination Limit Copy Entry Point

	type Boolean CPYFLG = 1
	type String TYPE = "UC"

	do INIT(1)
	
	quit


public	UCDEL	// Userclass Denomination Limit Deletion Entry Point

	type Boolean CPYFLG = 0
	type String TYPE = "UC"
	
	do INIT(3)
	
	quit


public	URNEW	// User Denomination Limit Creation Entry Point

	type Boolean CPYFLG = 0
	type String TYPE = "UR"
	
	do INIT(0)
	
	quit


public	URMAIN	// User Denomination Limit Maintenance Entry Point

	type Boolean CPYFLG = 0
	type String TYPE = "UR"
	
	do INIT(1)
	
	quit


public	URDEL	// User Denomination Limit Deletion Entry Point

	type Boolean CPYFLG = 0
	type String TYPE = "UR"
	
	do INIT(3)
	
	quit


INIT(Number %ProcessMode)	// Intitalize Denomination Limit Processing

	type Number %PAGE, %PG, %REPEAT, BRCD, I, MCNTMAX(), MCNTMIN(), MBRCD()
	type Number OLNTB, SAVBRCD, ZPG
	type String CRCD, MAST, MDESC(), MUCLS(), SAVUCLS, SAVUID, UCLS, UID, VFMQ

	set %PG = 0
	set ZPG = 0
	set %PAGE = 1

	type RecordUTBLDENOM fUTBLDEN
	type RecordUTBLDENLIMBR fBRDNLIM
	type RecordUTBLDENLIMUC fUCDNLIM
	type RecordUTBLDENLIMUR fURDNLIM

	do VPG(.fUTBLDEN,.fBRDNLIM,.fUCDNLIM,.fURDNLIM)
	
	quit


VPG(RecordUTBLDENOM fUTBLDEN,RecordUTBLDENLIMBR fBRDNLIM,RecordUTBLDENLIMUC fUCDNLIM,RecordUTBLDENLIMUR fURDNLIM)

	type public Boolean CPYFLG
	type public Number %PG, ZPG
	type public String VFMQ

	type Boolean DCPY, FINISH
	
	set DCPY = 0
	set FINISH = 0
	
	for  do { quit:FINISH
		
		if (%PG = 0) do { quit:FINISH
			
			do VPG00(.fUTBLDEN,.fBRDNLIM,.fUCDNLIM,.fURDNLIM)
			if VFMQ = "Q" set FINISH = 1
			}
 
		if CPYFLG,'DCPY,(%PG > 0) do { quit:FINISH
		
			do VPG02(.fBRDNLIM,.fUTBLDEN,.fUCDNLIM)
			if VFMQ = "Q" set FINISH = 1
			}
 
		if CPYFLG,DCPY,(%PG > 0) do { quit:FINISH
			
			do VPG01(.fUTBLDEN,.fBRDNLIM,.fUCDNLIM,.fURDNLIM)
			if VFMQ = "Q" set FINISH = 1
			}

		if 'CPYFLG,(%PG > 0) do { quit:FINISH
		
			do VPG01(.fUTBLDEN,.fBRDNLIM,.fUCDNLIM,.fURDNLIM)
			if VFMQ = "Q" set FINISH = 1
			}

		if "DFQ"[VFMQ do VER set FINISH = 1 quit

		set %PG = %PG + 1
		set ZPG = %PG
		}
 	quit


VPG00(RecordUTBLDENOM fUTBLDEN,RecordUTBLDENLIMBR fBRDNLIM,RecordUTBLDENLIMUC fUCDNLIM,RecordUTBLDENLIMUR fURDNLIM)

	type public Number %REPEAT, AMTMIN(), AMTMAX(), CNTMAX(), CNTMIN(), I
	type public String DESC(), TYPE, VFMQ

	type String %READ, %TAB

	set %READ="@@%FN,,"

	// Prompt for Branch and Currency Code
	if (TYPE = "BR") do {
		                
		if (%ProcessMode = 0) do {
			
			set %TAB("BRCD") = ".BRCD1/TBL=[UTBLBRCD]/REQ"
			set %TAB("CRCD") = ".CRCD1/TBL=[CRCD]/REQ/XPP=D PPCRCD^DENLIM"
			}
		else  do {
			
			set %TAB("BRCD") = ".BRCD1/TBL=[UTBLDENLIMBR]BRCD:DISTINCT/REQ"
			set %TAB("CRCD") = ".CRCD1/TBL=[UTBLDENLIMBR]CRCD:DISTINCT:QU ""[UTBLDENLIMBR]BRCD=<<BRCD>>""/REQ/XPP=D PPCRCD^DENLIM"
			}
			
		set %READ = %READ_"BRCD,CRCD"
		}

	// Prompt for Userclass and Currency Code
	if (TYPE = "UC") do {
		
		if (%ProcessMode = 0) do {
			
			set %TAB("UCLS") = ".UCLS4/TBL=[SCAU0]/REQ"
			set %TAB("CRCD") = ".CRCD1/TBL=[CRCD]/REQ/XPP=D PPCRCD^DENLIM"
			}
		else  do {
			
			set %TAB("UCLS") = ".UCLS4/TBL=[UTBLDENLIMUC]UCLS:DISTINCT/REQ"
			set %TAB("CRCD") = ".CRCD1/TBL=[UTBLDENLIMUC]CRCD:DISTINCT:QU ""[UTBLDENLIMUC]BRCD=<<BRCD>>""/REQ/XPP=D PPCRCD^DENLIM"
			}
			
		set %READ = %READ_"UCLS,CRCD"
		}

	// Prompt for User ID and Currency Code
	if (TYPE = "UR") do {
		                 
		if (%ProcessMode = 0) do {
			
			set %TAB("UID") = ".UID1/TBL=[SCAU]/REQ"
			set %TAB("CRCD") = ".CRCD1/TBL=[CRCD]/REQ/XPP=D PPCRCD^DENLIM"
			}
		else  do {
			
			set %TAB("UID") = ".UID1/TBL=[UTBLDENLIMUR]UID:DISTINCT/REQ"
			set %TAB("CRCD") = ".CRCD1/TBL=[UTBLDENLIMUR]CRCD:DISTINCT:QU ""[UTBLDENLIMUR]BRCD=<<BRCD>>""/REQ/XPP=D PPCRCD^DENLIM"
			}
			
		set %READ = %READ_"UID,CRCD"
		}

	do ^UTLREAD

	if (VFMQ = "Q") quit 

	set I = 0
	
	set (AMTMIN,AMTMAX,CNTMAX,CNTMIN,DESC) = ""
	
	set %REPEAT = 16

	if TYPE = "BR" do BRSETUP
	
	if TYPE = "UC" do UCSETUP
	
	if TYPE = "UR" do URSETUP

	quit 


VPG01(RecordUTBLDENOM fUTBLDEN,RecordUTBLDENLIMBR fBRDNLIM,RecordUTBLDENLIMUC fUCDNLIM,RecordUTBLDENLIMUR fURDNLIM)

	// Screen Setup for normal Limit definitions
	
	type public Number %PAGE, AMTMIN(), AMTMAX(), BRCD, CNTMAX(), CNTMIN(), SAVPG
	type public String CRCD, DESC(), SAVSID, TYPE, UCLS, UID, VFMQ
	
	type String SID
	
	set %PAGE = SAVPG
	set SID = SAVSID

	do LOAD
	
	set fUTBLDEN = Class.new("RecordUTBLDENOM")
	set fUTBLDEN.crcd = CRCD

	if (TYPE = "BR") do {
		
		set fBRDNLIM = Class.new("RecordUTBLDENLIMBR")
		set fBRDNLIM.brcd = BRCD
		set fBRDNLIM.crcd = CRCD
		}
 
	if (TYPE = "UC") do {
		
		set fUCDNLIM = Class.new("RecordUTBLDENLIMUC")
		set fUCDNLIM.ucls = UCLS
		set fUCDNLIM.crcd = CRCD
		}

	if (TYPE = "UR") do {
		
		set fURDNLIM = Class.new("RecordUTBLDENLIMUR")
		set fURDNLIM.uid = UID
		set fURDNLIM.crcd = CRCD
		}

	if (SID = "BRLIM") do DRV^USID(%ProcessMode,SID,.fUTBLDEN,.fBRDNLIM)

	if (SID = "UCLLIM") do DRV^USID(%ProcessMode,SID,.fUTBLDEN,.fUCDNLIM)

	if (SID = "USRLIM") do DRV^USID(%ProcessMode,SID,.fUTBLDEN,.fURDNLIM)

	if (VFMQ = "Q") quit
	
	do SAVE

	kill AMTMAX,AMTMIN,CNTMAX,CNTMIN,DESC
	
	quit 


VPG02(RecordUTBLDENLIMBR fBRDNLIM,RecordUTBLDENOM fUTBLDEN,RecordUTBLDENLIMUC fUCDNLIM)

	// Copy Limits screen Setup
	
	type public Boolean DCPY
	type public Number %PAGE, %PG, BRCD, BRCD()
	type public String CRCD, TYPE, UCLS, UCLS(), VFMQ
	
	type Number SAVB
	type String SAVU, SID
	
	set %PAGE = 999
	
	do CLOAD

	set fUTBLDEN = Class.new("RecordUTBLDENOM")
	set fUTBLDEN.crcd = CRCD

	if (TYPE = "BR") do {
		
		set fBRDNLIM = Class.new("RecordUTBLDENLIMBR")
		set fBRDNLIM.brcd = BRCD
		set fBRDNLIM.crcd = CRCD
		
		type RecordUTBLBRCD UTBL = Db.getRecord("UTBLBRCD", "BRCD = :BRCD", 1)
		
		set SID = "BRLIMC"
		
		do DRV^USID(%ProcessMode,SID,.fBRDNLIM,.fUTBLDEN,.UTBL)
		}
 
	if (TYPE = "UC") do {
		
		set fUCDNLIM = Class.new("RecordUTBLDENLIMUC")
		set fUCDNLIM.ucls = UCLS
		set fUCDNLIM.crcd = CRCD
		
		type RecordSCAU0 fSCAU0 = Db.getRecord("SCAU0", "UCLS = :UCLS", 1)
		
		set SID = "UCLLIMC"
		
		do DRV^USID(%ProcessMode,SID,.fUCDNLIM,.fUTBLDEN,.fSCAU0)
		}

	if (VFMQ = "Q") quit
	
	do CSAVE
	
	// Need to reset Branch or User Class values for next screen
	if (TYPE = "BR") do {
		
		set SAVB = BRCD
		kill BRCD
		set BRCD = SAVB
		}
	
	if (TYPE = "UC") do {
		
		set SAVU = UCLS
		kill UCLS
		set UCLS = SAVU
		}

	// If proceeding with limits copy, need to reset values for next screen
	if (VFMQ = "F") do {
		
		set %PG = 0
		set DCPY = 1
		set VFMQ = "0"
		}
	quit


LOAD	// Load screen Arrays from Master Arrays

	type public Number %PG, %REPEAT, AMTMAX(), AMTMIN(), CNTMAX(), CNTMIN()
	type public Number MCNTMAX(), MCNTMIN()
	type public String DESC(), MAST(), MDESC(), X
	
	type Number I, INDX, Y, Z

	set INDX = (%PG - 1) * %REPEAT
	
	for I = 1:1:%REPEAT set X = MDESC(I + INDX).get() quit:X.isNull()  set DESC(I) = X
	
	for I = 1:1:%REPEAT do {
		
		set Y = MCNTMIN(I + INDX).get()	quit:Y.isNull()  set CNTMIN(I) = Y
		
		set AMTMIN(I) = CNTMIN(I) * MAST(I + INDX).piece("|",4)
		}

	for I = 1:1:%REPEAT do {
		
		set Z = MCNTMAX(I + INDX).get() quit:Z.isNull()  set CNTMAX(I) = Z
		
		set AMTMAX(I) = CNTMAX(I) * MAST(I + INDX).piece("|",4)
		}
	quit 


SAVE	// Save Screen Arrays to Master Arrays

	type public Number %REPEAT, CNTMAX(), CNTMIN(), MCNTMAX(), MCNTMIN(), ZPG

	type Number I, INDX

	set INDX = (ZPG - 1) * %REPEAT
	
	for I = 1:1:%REPEAT do {
		
		set MCNTMIN(I + INDX) = CNTMIN(I).get()
		
		set MCNTMAX(I + INDX) = CNTMAX(I).get()
		}

	quit 


CLOAD	// Load copy screen Arrays from Master Arrays

	type public Number %PG, %REPEAT, BRCD()
	type public String MBRCD(), MUCLS(), TYPE, UCLS()
	
	type Number I, INDX, X

	set INDX = (%PG - 1) * %REPEAT
	
	if (TYPE = "BR") for I = 1:1:%REPEAT set X = MBRCD(I + INDX).get() quit:X.isNull()  set BRCD(I) = X

	if (TYPE = "UC") for I = 1:1:%REPEAT set X = MUCLS(I + INDX).get() quit:X.isNull()  set UCLS(I) = X

	quit 


CSAVE	// Save copy screen Arrays to Master Arrays

	type public Number %REPEAT, BRCD(), ZPG
	type public String MBRCD(), MUCLS(), TYPE, UCLS()

	type Number I, INDX

	set INDX = (ZPG - 1) * %REPEAT
	
	if (TYPE = "BR") for I = 1:1:%REPEAT set MBRCD(I + INDX) = BRCD(I).get()

	if (TYPE = "UC") for I = 1:1:%REPEAT set MUCLS(I + INDX) = UCLS(I).get()

	quit 


BRSETUP	// Branch Denomination Limit Setup

	type public Number %REPEAT, BRCD, MCNTMAX(), MCNTMIN(), SAVBRCD
	type public String CRCD, MAST(), MDESC(), SAVPG, SAVSID, UCLS
	
	type Number CSEQ, IDX, TMP

	set SAVSID = "BRLIM"
	set SAVBRCD = BRCD
	set UCLS = %UserClass
	set CSEQ = ""

	type ResultSet rs = Db.select("CSEQ","UTBLDENLIMBR","BRCD=:BRCD AND CRCD=:CRCD")

	// It is actually an update, not insert
	if 'rs.isEmpty(),'%ProcessMode set %ProcessMode = 1

	type DbSet ds = Db.selectDbSet("UTBLDENOM","CRCD=:CRCD")
	while ds.next() do {
		
		type RecordUTBLDENOM udm = ds.getRecord("UTBLDENOM")

		set IDX = MDESC("").order(-1) + 1
		
		set MAST(IDX) = udm.cseq

		set MAST(IDX).piece("|",2) = udm.desc_"|"_udm.tpcshlnk_"|"_udm.mult_"|"_udm.roll_"|"_udm.strap_"|"_udm.denomination
		
		set MDESC(IDX) = MAST(IDX).piece("|",2)
		
		type RecordUTBLDENLIMBR fBRDNLIM1 = Db.getRecord("UTBLDENLIMBR", "BRCD = :BRCD, CRCD = :CRCD, CSEQ = :udm.cseq", 1)

		// Minimum Denomination Count
		set MCNTMIN(IDX) = fBRDNLIM1.mincnt
		
		// Maximum Denomination Count
		set MCNTMAX(IDX) = fBRDNLIM1.maxcnt 
		}

	set TMP = (IDX \ %REPEAT)
	
	if (TMP - (IDX / %REPEAT)) set SAVPG = TMP + 1
	
	else  set SAVPG = 1

	quit 


UCSETUP	// Userclass Denomination Limit Setup

	type public Number %REPEAT, BRCD, MCNTMAX(), MCNTMIN()
	type public String CRCD, MAST(), MDESC(), SAVPG, SAVSID, SAVUCLS, UCLS
	
	type Number CSEQ, IDX, TMP
	
	set SAVSID = "UCLLIM"
	set SAVUCLS = UCLS
	set CSEQ = ""
	
	type ResultSet rs = Db.select("CSEQ","UTBLDENLIMUC","UCLS=:UCLS AND CRCD=:CRCD")
	
	// It is actually an update, not insert
	if 'rs.isEmpty(),'%ProcessMode set %ProcessMode = 1

	type DbSet ds = Db.selectDbSet("UTBLDENOM","CRCD=:CRCD")
	while ds.next() do {
		
		type RecordUTBLDENOM udm = ds.getRecord("UTBLDENOM")

		set IDX = MDESC("").order(-1) + 1
		
		set MAST(IDX) = udm.cseq

		set MAST(IDX).piece("|",2) = udm.desc_"|"_udm.tpcshlnk_"|"_udm.mult_"|"_udm.roll_"|"_udm.strap_"|"_udm.denomination
		
		set MDESC(IDX) = MAST(IDX).piece("|",2)
		
		type RecordUTBLDENLIMUC fUCDNLIM1=Db.getRecord("UTBLDENLIMUC", "UCLS = :UCLS, CRCD = :CRCD, CSEQ = :udm.cseq", 1)

		// Minimum Denomination Count
		set MCNTMIN(IDX) = fUCDNLIM1.mincnt

		// Maximum Denomination Count
		set MCNTMAX(IDX) = fUCDNLIM1.maxcnt
		}

	set TMP = (IDX \ %REPEAT)
	
	if (TMP - (IDX / %REPEAT)) set SAVPG = TMP + 1
	
	else  set SAVPG = 1

	quit  


URSETUP // User Denomination Limit Setup

	type public Number %REPEAT, BRCD, MCNTMAX(), MCNTMIN()
	type public String CRCD, MAST(), MDESC(), SAVPG, SAVSID, SAVUID, UID
	
	type Number CSEQ, IDX, TMP
	
	set SAVSID = "USRLIM"
	set SAVUID = UID
	set CSEQ = ""

	type ResultSet rs = Db.select("CSEQ","UTBLDENLIMUR","UID=:UID AND CRCD=:CRCD")

	// It is actually an update, not insert
	if 'rs.isEmpty(),'%ProcessMode set %ProcessMode = 1

	type DbSet ds = Db.selectDbSet("UTBLDENOM","CRCD=:CRCD")
	while ds.next() do {
		
		type RecordUTBLDENOM udm = ds.getRecord("UTBLDENOM")

		set IDX = MDESC("").order(-1) + 1
		
		set MAST(IDX) = udm.cseq

		set MAST(IDX).piece("|",2) = udm.desc_"|"_udm.tpcshlnk_"|"_udm.mult_"|"_udm.roll_"|"_udm.strap_"|"_udm.denomination
		
		set MDESC(IDX) = MAST(IDX).piece("|",2)
		
		type RecordUTBLDENLIMUR fURDNLIM1 = Db.getRecord("UTBLDENLIMUR", "UID = :UID, CRCD = :CRCD, CSEQ = :udm.cseq", 1)

		// Minimum Denomination Count
		set MCNTMIN(IDX) = fURDNLIM1.mincnt

		// Maximum Denomination Count
		set MCNTMAX(IDX) = fURDNLIM1.maxcnt  
		}

	set TMP = (IDX \ %REPEAT)
	
	if (TMP - (IDX / %REPEAT)) set SAVPG = TMP + 1
	
	else  set SAVPG = 1

	quit


VER	//

	type public String VFMQ

	if (%ProcessMode = 2) ! (%ProcessMode = 4) ! (VFMQ = "Q") do END quit

	do FILE

	do END

	quit


FILE	// Create denomination tables records

	type public Boolean CPYFLG
	type public Number BRCD, MCNTMAX(), MCNTMIN()
	type public String CRCD, MAST(), MBRCD(), MDESC(), MUCLS(), TYPE, UCLS, UID

	type Number CSEQ, SEQ, SEQ1, SEQ2, TMP, TMPBRCD
	type String TMPUCLS

	set SEQ = ""
	set CSEQ = ""
	
	if 'CPYFLG do {

		do RECDEL

		for  set SEQ = MAST(SEQ).order() quit:SEQ.isNull()  do {
			
			set CSEQ = MAST(SEQ).piece("|",1)

			// Save Branch Limits
			if ((%ProcessMode = 0) ! (%ProcessMode = 1)),(TYPE = "BR"),(MCNTMIN(SEQ).get() ! MCNTMAX(SEQ).get()) do {
				
				type RecordUTBLDENLIMBR fBRDNLIM = Db.getRecord("UTBLDENLIMBR"," BRCD = :BRCD, CRCD = :CRCD, CSEQ = :CSEQ", 1)

				// Minimum Denomination Count
				set fBRDNLIM.mincnt = MCNTMIN(SEQ).get()

				// Maximum Denomination Count
				set fBRDNLIM.maxcnt = MCNTMAX(SEQ).get()

				do fBRDNLIM.save()
				}
	
			// Save Userclass Limits
			if ((%ProcessMode = 0) ! (%ProcessMode = 1)),(TYPE = "UC"),(MCNTMIN(SEQ).get() ! MCNTMAX(SEQ).get()) do {

				type RecordUTBLDENLIMUC fUCDNLIM = Db.getRecord("UTBLDENLIMUC", "UCLS = :UCLS, CRCD = :CRCD, CSEQ = :CSEQ", 1)

				// Minimum Denomination Count
				set fUCDNLIM.mincnt = MCNTMIN(SEQ).get()

				// Maximum Denomination Count
				set fUCDNLIM.maxcnt = MCNTMAX(SEQ).get()

				do fUCDNLIM.save()
				}
	
			// Save User Limits
			if ((%ProcessMode = 0) ! (%ProcessMode = 1)),(TYPE = "UR"),(MCNTMIN(SEQ).get() ! MCNTMAX(SEQ).get()) do {

				type RecordUTBLDENLIMUR fURDNLIM = Db.getRecord("UTBLDENLIMUR", "UID = :UID, CRCD = :CRCD, CSEQ = :CSEQ", 1)

				// Minimum Denomination Count
				set fURDNLIM.mincnt = MCNTMIN(SEQ).get()

				// Maximum Denomination Count
				set fURDNLIM.maxcnt = MCNTMAX(SEQ).get()

				do fURDNLIM.save()
				}
			}
	
		// Delete Branch, Userclass, User Limits
		if (%ProcessMode = 3) do RECDEL
		}
	
	if CPYFLG do {

		// These are really inserts (need to keep the scope local)
		type Number %ProcessMode = 0
	
		// Copy Branch Limits
		if (TYPE = "BR") do {

			type Number BRCD
			
			set (SEQ1,SEQ2,CSEQ,TMPBRCD) = ""
			
			for  set SEQ1 = MBRCD(SEQ1).order() quit:SEQ1.isNull()  do {
				
				for TMP = 1:1:6 set BRCD = MBRCD(SEQ1).piece("|",TMP) if 'BRCD.isNull()  do {
					
					for  set SEQ2 = MDESC(SEQ2).order() quit:SEQ2.isNull()  do {
						
						set CSEQ = MAST(SEQ2).piece("|",1)
						
						type RecordUTBLDENLIMBR fBRDNLIM = Db.getRecord("UTBLDENLIMBR", "BRCD = :BRCD, CRCD = :CRCD, CSEQ = :CSEQ", 1)

						// Minimum Denomination Count
						set fBRDNLIM.mincnt = MCNTMIN(SEQ2).get()

						// Maximum Denomination Count
						set fBRDNLIM.maxcnt = MCNTMAX(SEQ2).get()

						do fBRDNLIM.save()
						}
					}
				}
			}
	
		// Copy Userclass Limits
		if (TYPE = "UC") do {

			type Number UCLS
			
			set (SEQ1,SEQ2,CSEQ,TMPUCLS) = ""
			
			for  set SEQ1 = MUCLS(SEQ1).order() quit:SEQ1.isNull()  do {
				
				for TMP = 1:1:4 set UCLS = MUCLS(SEQ1).piece("|",TMP) if 'UCLS.isNull()  do {
				
					for  set SEQ2 = MDESC(SEQ2).order() quit:SEQ2.isNull()  do {
							
						set CSEQ = MAST(SEQ2).piece("|",1)
							
						type RecordUTBLDENLIMUC fUCDNLIM = Db.getRecord("UTBLDENLIMUC", "UCLS = :UCLS, CRCD = :CRCD, CSEQ = :CSEQ", 1)

						// Minimum Denomination Count
						set fUCDNLIM.mincnt = MCNTMIN(SEQ2).get()

						// Maximum Denomination Count
						set fUCDNLIM.maxcnt = MCNTMAX(SEQ2).get()

						do fUCDNLIM.save()
						}
					}
				}
			}
		}
	
	quit 


END	// Display information messages

	type public Boolean CPYFLG
	type public Number ER, SAVBRCD
	type public String CRCD, RM, SAVUCLS, SAVUID, TYPE, VFMQ

	if ER.get() ! (%ProcessMode = 2) ! (%ProcessMode = 4) quit
	
	set ER = "W"
	
	// Branch ~p1's denomination limits created for currency ~p2
	if TYPE="BR",%ProcessMode=0,VFMQ'="Q" set RM=$$^MSG(8662,SAVBRCD,CRCD) 

	// Branch ~p1's denomination limits not created for currency ~p2
	if TYPE="BR",%ProcessMode=0,VFMQ="Q" set RM=$$^MSG(8663,SAVBRCD,CRCD)

	// Branch ~p1's denomination limits modified for currency ~p2
	if TYPE="BR",'CPYFLG,%ProcessMode=1,VFMQ'="Q" set RM=$$^MSG(8671,SAVBRCD,CRCD) 

	// Branch ~p1's denomination limits not modified for currency ~p2
	if TYPE="BR",'CPYFLG,%ProcessMode=1,VFMQ="Q" set RM=$$^MSG(8672,SAVBRCD,CRCD)    

	// Branch ~p1's denomination limits copied for currency ~p2
	if TYPE="BR",CPYFLG,%ProcessMode=1,VFMQ'="Q" set RM=$$^MSG(8652,SAVBRCD,CRCD) 

	// Branch ~p1's denomination limits not copied for currency ~p2
	if TYPE="BR",CPYFLG,%ProcessMode=1,VFMQ="Q" set RM=$$^MSG(8653,SAVBRCD,CRCD)       

	// Branch ~p1's denomination limits deleted for currency ~p2
	if TYPE="BR",%ProcessMode=3,VFMQ'="Q" set RM=$$^MSG(8664,SAVBRCD,CRCD)

	// Branch ~p1's denomination limits not deleted for currency ~p2
	if TYPE="BR",%ProcessMode=3,VFMQ="Q" set RM=$$^MSG(8665,SAVBRCD,CRCD)
	
	// Userclass ~p1's denomination limits created for currency ~p2
	if TYPE="UC",%ProcessMode=0,VFMQ'="Q" set RM=$$^MSG(8654,SAVUCLS,CRCD)

	// Userclass ~p1's denomination limits not created for currency ~p2
	if TYPE="UC",%ProcessMode=0,VFMQ="Q" set RM=$$^MSG(8667,SAVUCLS,CRCD)

	// Userclass ~p1's denomination limits modified for currency ~p2
	if TYPE="UC",%ProcessMode=1,'CPYFLG,VFMQ'="Q" set RM=$$^MSG(8673,SAVUCLS,CRCD) 

	// Userclass ~p1's denomination limits not modified for currency ~p2
	if TYPE="UC",%ProcessMode=1,'CPYFLG,VFMQ="Q" set RM=$$^MSG(8674,SAVUCLS,CRCD)

	// Userclass ~p1's denomination limits copied for currency ~p2
	if TYPE="UC",%ProcessMode=1,CPYFLG,VFMQ'="Q" set RM=$$^MSG(8666,SAVUCLS,CRCD)

	// Userclass ~p1's denomination limits not copied for currency ~p2
	if TYPE="UC",%ProcessMode=1,CPYFLG,VFMQ="Q" set RM=$$^MSG(8655,SAVUCLS,CRCD)

	// Userclass ~p1's denomination limits deleted for currency ~p2
	if TYPE="UC",%ProcessMode=3,VFMQ'="Q" set RM=$$^MSG(8668,SAVUCLS,CRCD)

	// Userclass ~p1 denomination limits not deleted for currency ~p2
	if TYPE="UC",%ProcessMode=3,VFMQ="Q" set RM=$$^MSG(8669,SAVUCLS,CRCD)

	// User ~p1's denomination limits created for currency ~p2
	if TYPE="UR",%ProcessMode=0,VFMQ'="Q" set RM=$$^MSG(8656,SAVUID,CRCD)

	// User ~p1's denomination limits not created for currency ~p2
	if TYPE="UR",%ProcessMode=0,VFMQ="Q" set RM=$$^MSG(8657,SAVUID,CRCD)

	// User ~p1's denomination limits modified for currency ~p2
	if TYPE="UR",%ProcessMode=1,VFMQ'="Q" set RM=$$^MSG(8658,SAVUID,CRCD)

	// User ~p1's denomination limits not modified for currency ~p2
	if TYPE="UR",%ProcessMode=1,VFMQ="Q" set RM=$$^MSG(8659,SAVUID,CRCD)

	// User ~p1's denomination limits deleted for currency ~p2
	if TYPE="UR",%ProcessMode=3,VFMQ'="Q" set RM=$$^MSG(8660,SAVUID,CRCD)

	// User ~p1's denomination limits not deleted for currency ~p2
	if TYPE="UR",%ProcessMode=3,VFMQ="Q" set RM=$$^MSG(8661,SAVUID,CRCD) 

	quit 


public	DENOM	// Determine Denomination Teller Cash Count Linkage
	/*
	   This subroutine, called as part of the User Table Maintenance
	   for currency denominations (UTBLDENOM.MULT), will create a table
	   lookup array for the Teller Cash Count Linkage field
	   ([UTBLDENOM]TPCSHLNK). Valid table entries will be based on
	   the multiplier, and will provide a linkage to the hard-coded teller
	   cash count functionality.
	*/

	type public Number CSEQ, MULT
	type public String CRCD, TLRCSH()
	
	type Number DENOM, I, XSEQ
	type String DI

	kill TLRCSH
	
	if MULT.isNull() quit 

	// Initialize DENOM array
	do INIT^RTPCSH

	set I = 0
	
	for  set I = DENOM(I).order() quit:I.isNull()  do {

		// Skip if it is strapped, rolled, decoy or mutilated currency
		if (I > 16),(I < 22) quit 

		if (DENOM(I) '= MULT) quit 

		// Find the corresponding data item in TPCASH table
		set DI = $$DILIST^DBSUTL8("TPCASH","CRCD",I,"SYSDEV")

		if DI.isNull() quit 

		type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID='TPCASH',DI=:DI")

		set TLRCSH(DI) = dbtbl1d.des

		type ResultSet rs = Db.select("CSEQ","UTBLDENOM","CRCD=:CRCD","CSEQ DESC")

		while rs.next() do {
			
			set XSEQ = rs.getCol("CSEQ")
			
			type RecordUTBLDENOM utbldenom = Db.getRecord("UTBLDENOM", "CRCD = :CRCD, CSEQ = :XSEQ", 1)
			
			if (XSEQ '= CSEQ),(DI = utbldenom.tpcshlnk) kill TLRCSH(DI)
			}
		}
	quit 


PPCRCD	// Post processor on currency code

	type public String X

	type ResultSet rs = Db.select("CSEQ","UTBLDENOM","CRCD=:X")

	// Denominations not defined for currency ~p1
	if rs.isEmpty() do Runtime.setErrMSG("UTBLDENOM",8736,X)

	quit
	

public	PPSTRAP	// Post processor for UTBLDENOM.STRAP column
 
	type public Boolean ROLL, STRAP, X
	type public String TPCSHLNK

        set STRAP = X
 
        // Select either Rolled or Strapped, or link to a Teller Cash Count data item
        if X,(ROLL ! 'TPCSHLNK.isNull()) do Runtime.setErrMSG(8730) quit
 
        // Select either Rolled or Strapped, or link to a Teller Cash Count data item
        if 'X,'ROLL,TPCSHLNK.isNull() do Runtime.setErrMSG(8730) quit
        
        quit


RECDEL

	type public Number BRCD
	type public String CRCD, TYPE

	if (TYPE = "BR") do Db.delete("UTBLDENLIMBR","BRCD=:BRCD AND CRCD=:CRCD")
	
	if (TYPE = "UC") do Db.delete("UTBLDENLIMUC","UCLS=:UCLS AND CRCD=:CRCD")
	
	if (TYPE = "UR") do Db.delete("UTBLDENLIMUR","UID=:UID AND CRCD=:CRCD")
	
	quit
	

public	CSEQ(String CRCD)

	// Calculate next Denomination Sequence (UTBLDENOM.CSEQ) value

	type Number MAXNUM, SQ
	
	set MAXNUM = 1E18
	set SQ = 10

	type ResultSet rs = Db.select("CSEQ", "UTBLDENOM", "CRCD = :CRCD AND CSEQ < :MAXNUM", "CSEQ DESC")

	if rs.next() set SQ = rs.getCol("CSEQ") + 10
	
	quit SQ

vSIG()	quit "60290^59967^Eugene Titov^22488"	// Signature - LTD^TIME^USER^SIZE
