public EFTNDPO(CID,SEQ,OPT,POST,SWSENT,RecordTTX ttx1(),RecordTTX ttx2())

	/*
	 ORIG:	Chris Rickards - 05/06/2002
	 DESC:	Foreign Payment Processor
		This procedure will build and post the transactions necessary
		to complete a foreign payment order.

	 ARGUMENTS:
		CID	Payment account number
		SEQ	Payment sequence number
		OPT	Processing option
			(0-Process, 1-Cancel, 2-Reverse, 3-Post Return)
		POST	Posting option
			(0-Anticipated, 1-Post Transactions)
		SWSENT	SWIFT sent flag
			(0-SWIFT messages not sent, 1-SWIFT messages sent)

	 RETURNS:
		ttx1	Process date transaction object array
		ttx2	Effective date transaction object array

	 ---- Comments --------------------------------------------------------

	 ---- Revision History ------------------------------------------------

	01/25/06 - KELLYP - CR 18292
		Modified SWIFT section to call DIS section instead of top level
		of SWIFTPNT.

	12/12/05 - KELLYP - CR 18292
		Modified POST section to adjust the parameters being passed to
		TRNSET^TRNDRV.  The last two parameters were not being passed
		in the correct place.

	09/07/05 - KELLYP - CR 17118
		Removed references to the MT100 message which has been 
		obsoleted by SWIFT.  Also replaced CUVAR DB retrievals with
		direct CUVAR references and removed pre-2003 revision history.

	12/08/03 - CARROLLJ - CR7239
		Corrected paramter mismatch errors.
	
	10/10/03 - CARROLLJ - 51630
		Remove toArray and fromArray methods.

	05/28/03 - CARROLLJ - 51349
		Removed the use of the TR array and called TRANSET^TRNDRV to
		post transaction.
	*/

	new BRCD,EFDKEY,EFTTYPE,ERR,ERRMSG,HLDREM,OFFCID,PROCKEY,REJMET
	new SETAMT,SETCRCD,UBRCD,UID

	type RecordEFTPAY eftpay
	type RecordCTBLEFTTYPE ctbleft
	type RecordSCAU scau
	type RecordSIGNON signon

	catch vERROR {
		new ET,RM
		set ET=vERROR.type,RM=""

		if ET["%GTM-" do ZE^UTLERR quit

		set ET=ET_"-"_vERROR.thrownAt
		set RM=vERROR.description
		do ^UTLERR
	}

	// Reset error values
	set (ER,ERR)=0
	set (ERRMSG,RM)=""

	// Validate payment exists
	// STBLMSG - Sequence does not exist
	if (CID="")!(SEQ="") set ER=1,RM=$$^MSG(7227) quit
	if 'Db.isDefined("EFTPAY","CID,SEQ") set ER=1,RM=$$^MSG(7227) quit

	// Retrieve payment
	set eftpay=Db.getRecord("EFTPAY","CID,SEQ")
	do eftpay.setAuditFlag(1)

	// Verify payment is approved
	// STBLMSG - Foreign payment for account ~p1 not approved
	if (OPT=0),POST,(eftpay.status'="AP") set ER=1,RM=$$^MSG(7741,CID) quit

	// Retrieve payment type defaults
	set EFTTYPE=eftpay.efttype
	set ctbleft=Db.getRecord("CTBLEFTTYPE","EFTTYPE")

	// Determine the settlement amount and currency
	do SETAMT(.eftpay,CUVAR.emucrcd,CUVAR.udrc,.SETAMT,.SETCRCD)
	if ER quit

	/*
	 If an outgoing payment is being returned, or the payment is being
	 reversed and the required SWIFT messages have been sent, then the
	 (offset account is the return foreign payments GL account.
	 For all other processing the offset account is the GL account
	 incoming/outgoing account defined for the payment type.
	*/
	set OFFCID=$S(EFTTYPE="NDPOIN":ctbleft.glin,1:ctbleft.glout)
	if (OPT=2),SWSENT set OFFCID=CUVAR.rtnfpgl
	if (EFTTYPE'="NDPOIN"),(OPT=3) set OFFCID=CUVAR.rtnfpgl

	// Determine current rates and amounts for approved payments
	if OPT=0 do NEWRATE(.eftpay)
	if ER quit

	// Retrieve user information
	set UID=%UserID
	set (REJMET,UBRCD)=""
	if (UID'=""),Db.isDefined("SCAU","UID") do {
		set scau=Db.getRecord("SCAU","UID")
		set UBRCD=scau.brcd
		set REJMET=scau.batrej
	}
	if REJMET="" set REJMET=1
	
	// Determine branch code
	set BRCD=""
	if (UID'=""),Db.isDefined("SIGNON","UID") do {
		set signon=Db.getRecord("SIGNON","UID")
		set BRCD=signon.brcd
	}
	if BRCD="" set BRCD=UBRCD
	if BRCD="" set BRCD=$$DBRCD^UBRCD(%UserStation)
	if BRCD="" set BRCD=CUVAR.bobr

	/*
	 Process date processing
	 Outgoing payments post transactions to the payment account on the
	 processing date, and incoming payments post settlement transactions
	 on the processing date.
	*/
	if (OPT'=3)!(EFTTYPE="NDPOIN") do {

		// Format financial transactions
		if EFTTYPE="NDPOIN" do OFFSET(.eftpay,.ttx1(),ctbleft.ccdft,CUVAR.emucrcd,CUVAR.glts,eftpay.procdt,OPT,SETAMT,SETCRCD,OFFCID)  if 1
		else  if OPT=0 do TRAN(.eftpay,.ttx1(),ctbleft.ccdft,CUVAR.futbld,CUVAR.glts,eftpay.procdt,SETAMT,SETCRCD,OFFCID,ctbleft.etc)  if 1
		else  do REV(.eftpay,.ttx1(),OPT,BRCD,eftpay.prockey)
		if ER quit
		if ERR set ER=ERR,RM=ERRMSG quit

		// Do not post transactions if anticipated
		if 'POST quit

		// Remove holds for outgoing payments from customer accounts
		if (EFTTYPE'="NDPOIN"),(eftpay.ttype<2),eftpay.hldauto do {
			// Check if hold will be removed when transaction is posted
			if (OPT=0),ctbleft.hldpst,(eftpay.procdt>%SystemDate) quit

			// Remove hold & clear hold sequence
			set HLDREM=$$RMHLDS^EFTFUNCS(CID,SEQ)
			// STBLMSG - Error deleting hold
			if 'HLDREM set ER=1,RM=$$^MSG(8343)
		}
		if ER quit

		// Post formatted transactions
		do POST(.eftpay,.ttx1(),eftpay.procdt,BRCD,REJMET,.PROCKEY)
		if ER do { quit
			do UPDATE(.eftpay,OPT,SWSENT)
			if ERR set ER=ERR,RM=ERRMSG
		}

		if OPT=0 set eftpay.prockey=PROCKEY
	}
	if ER quit

	/*
	 Effective date processing
	 Outgoing payments post transactions to the settlement transactions on the
	 effective date, and incoming payments post transactions to the payment
	 account on the effective date.
	*/
	if 'SWSENT!(OPT=3)!(EFTTYPE="NDPOIN") do {

		// Format financial transactions
		if EFTTYPE'="NDPOIN" do OFFSET(.eftpay,.ttx2(),ctbleft.ccdft,CUVAR.emucrcd,CUVAR.glts,eftpay.efd,OPT,SETAMT,SETCRCD,OFFCID)  if 1
		else  if OPT=0 do TRAN(.eftpay,.ttx2(),ctbleft.ccdft,CUVAR.futbld,CUVAR.glts,eftpay.efd,SETAMT,SETCRCD,OFFCID,ctbleft.etc)  if 1
		else  do REV(.eftpay,.ttx2(),OPT,BRCD,eftpay.efdkey)
		if ER quit
		if ERR set ER=ERR,RM=ERRMSG quit

		// Do not post transactions if anticipated
		if 'POST quit

		// Post formatted transactions
		do POST(.eftpay,.ttx2(),eftpay.efd,BRCD,REJMET,.EFDKEY)
		if ER do { quit
			do UPDATE(.eftpay,OPT,SWSENT)
			if ERR set ER=ERR,RM=ERRMSG
		}

		if OPT=0 set eftpay.efdkey=EFDKEY
	}
	if ER quit

	// Update foreign payment
	if POST do UPDATE(.eftpay,OPT,SWSENT)
	if ER quit
	if ERR set ER=ERR,RM=ERRMSG quit

	// Generate SWIFT messages
	if 'SWSENT,POST do SWIFT(.eftpay)

	quit


public TRAN(RecordEFTPAY eftpay,RecordTTX ttx(),CCDFT,FUTFLG,GLTS,DATE,SETAMT,SETCRCD,OFFCID,OFFETC)

	/*
	 Format financial transactions

	 ARGUMENTS:
		eftpay		Foreign payment object
		CCDFT		Default cost center
		FUTFLG		Future build flag
		GLTS		Transaction suspense GL
		DATE		Processing date of transactions
		SETAMT		Payment settlement amount
		SETCRCD		Payment settlement currency
		OFFCID		Offset account
		OFFETC		Offset transaction code

	 RETURNS:
		ttx()		Transaction object array

	*/

	new CC,CID,CIDTSO,CRCD,ERI,ETC,ETCDR,EXCAMT,FEECR,FEEGL
	new FEETYPE,FUTBLD,GLTSO,MAXRATE,MINRATE,MULTIPLY,OFFTSO,RATE,RESCD
	new TAMT,TR,TRESREF,TSO,TYPE,VARIANCE

	type RecordACN acn
	type RecordPRODCTL prodctl
	type RecordEFTFEE eftfee

	set CID=eftpay.cid
	set CRCD=eftpay.crcdcid

	// Determine FUTBLD
	if (eftpay.efttype="NDPOIN"),(eftpay.efd>%SystemDate),FUTFLG set FUTBLD=1
	else  set FUTBLD=0

	// Define customer account values
	if eftpay.ttype<2 do {
		// STBLMSG - Invalid account ~p1
		if 'Db.isDefined("ACN","CID") set ER=1,RM=$$^MSG(1259,CID) quit
		set acn=Db.getRecord("ACN","CID")
		set TYPE=acn.type
		set CC=acn.cc
		set RESCD=acn.rescd

		// Determine transaction code
		set prodctl=Db.getRecord("PRODCTL","TYPE")
		if eftpay.efttype="NDPOIN" set ETC=$S(prodctl.nostro:prodctl.drtrgp,1:prodctl.crtrgp)
		else  set ETC=$S(prodctl.nostro:prodctl.crtrgp,1:prodctl.drtrgp)
		set ETCDR=$S(prodctl.nostro:prodctl.crtrgp,1:prodctl.drtrgp)
	}

	// Define GL account values
	else  do {
		set TYPE=""
		// Determine cost center
		set CC=$S(eftpay.cc'="":eftpay.cc,1:CCDFT)
		set RESCD=1			// Resident
		set ETC=$S(eftpay.efttype="NDPOIN":"MCR",1:"MDR")
		set ETCDR="MDR"
	}
	if ER quit

	// Build TSO
	set CIDTSO("FCID")=$S(eftpay.ttype<2:CID,1:CC_"-"_CID)
	set CIDTSO("SEQ")=eftpay.seq				// Payment sequence
	set CIDTSO("EFT")=eftpay.efttype			// Payment type
	set CIDTSO("SPEC")=eftpay.refno				// Transaction reference number
	if eftpay.consndpo'="" set CIDTSO("ZSTAT")=eftpay.consndpo // Constant field (DS1)
	if eftpay.varndpo'="" set CIDTSO("ZARES")=eftpay.varndpo  // Variable field (DS2)
	if eftpay.source'="" set CIDTSO("TSO")=eftpay.source 	// Input source
	if eftpay.met'="" set CIDTSO("MET")=eftpay.met  	// Payment method
	if eftpay.thold'="" do OUT^UTSO(.CIDTSO,eftpay.thold)	// Payment threshold
	if FUTBLD set CIDTSO("FUTBLD")=1
	if eftpay.erivalid do {
		/*
		 Extract the amount and currency from the euro-related information
		 (assume a format of /OCMT/INC1000000,/)
		*/
		set ERI=$P(eftpay.msgfp1,"/",3)
		set CIDTSO("TCUR")=$E(ERI,1,3)_$$INT^%ZM($E(ERI,4,$L(ERI)),"$",",.",2)
	}
	do IN^UTSO(.CIDTSO,.TSO)
	if ER quit

	// Build offset TSO
	set GLTSO("ZSTAT")=eftpay.consndpo	// Constant field (DS1)
	set GLTSO("ZARES")=eftpay.varndpo	// Variable field (DS2)
	set GLTSO("SPEC")=eftpay.refno		// Transaction reference number
	set GLTSO("EFT")=eftpay.efttype		// Payment type
	if FUTBLD set GLTSO("FUTBLD")=1
	do IN^UTSO(.GLTSO,.OFFTSO)
	if ER quit

	/*
	 Format main debit/credit transaction to the payment account for the
	 actual amount and format the offset to the main debit/credit. The
	 receiver charges are included in actamt, which is in the account
	 currency for customer accounts and is in the payment currency for
	 GL accounts. The offset amount will equal the settlement currency
	 amount (eftpay.amount) which is in the settlement currency
	 (eftpay.crcd). If eftpay.setcrcd=1 (settlement in EUR), then the
	 offset amount will equal the EUR equivalent of eftpay.amount. If the
	 transactions are future-dated and the future build flag is set
	 (FUTBLD=1), then the settlement amount and currency is used as the
	 transaction amount and currency because the exchange amount will be
	 determined on the future-date.
	*/
	if FUTBLD set TAMT=SETAMT,CRCD=SETCRCD
	else  set TAMT=$S(eftpay.efttype="NDPOIN":eftpay.actamt,1:eftpay.actamt-eftpay.actrcvrchg)
	do BLDTR(.ttx(),CID,ETC,TAMT,DATE,TSO,eftpay.relrefno,CC,CRCD,eftpay.ccode)
	if ER quit

	// Payment offset transaction
	do BLDTR(.ttx(),OFFCID,OFFETC,SETAMT,DATE,OFFTSO,eftpay.relrefno,CCDFT,SETCRCD,eftpay.ccode)
	if ER quit

	/*
	 Create exchange transactions using the exchange utility for main transactions only.
	 Foreign payment processing was originally designed to avoid the extra exchange
	 transactions that would be generated by standard transaction processing when all
	 of the transactions for a single payment are posted.
	*/
	if 'FUTBLD do EXCHANGE(.ttx())
	if ER quit
	
	// Determine fee offset transaction code and fee offset GL account
	do FEETYPE(eftpay.feetype,RESCD,GLTS,.eftfee,.FEEGL,.FEECR)
	if ER quit

	/*
	 Format fee transaction to the payment account for the actual fee
	 amount and format the offset to the fee transaction. eftpay.actfee
	 is in the account currency for customer accounts and is in the
	 payment currency for GL accounts. eftpay.feeamt may be in the
	 account/payment currency or the base currency, but it is ignored.
	 To avoid extra currency exchanges, the account currency is used
	 in place of eftpay.feecrcd. If the transactions are future-dated
	 and the future build flag is set (FUTBLD=1), then the fee
	 transactions will be determined on the future-date. 
	*/
	if (eftpay.actfee>0),Class.isValid(eftfee),'FUTBLD do {

		// Add "NDPO" field to TSO fields
		// STBLMSG - Payment Fee
		set TSO=$$FIELDIN^UTSO(TSO,"NDPO",$$^MSG(7759))
		set OFFTSO=$$FIELDIN^UTSO(OFFTSO,"NDPO",$$^MSG(7759))

		// Fee transaction
		do BLDTR(.ttx(),CID,ETCDR,eftpay.actfee,DATE,TSO,eftpay.relrefno,CC,CRCD,eftpay.ccode)
		if ER quit

		// Fee offset transaction(s)
		do FEECC(.eftpay,.ttx(),.eftfee,DATE,CC,CRCD,FEEGL,FEECR)
	}
	if ER quit

	/*
	 Format conversion fee transaction to the payment account for the
	 actual conversion fee amount and format the offset to the conversion
	 fee transaction. eftpay.feeconv is in the account currency for 
	 customer accounts and is in the payment currency for GL accounts.
	 The offset amount will equal eftpay.feeconv which is in the account
	 currency. eftpay.feecrcd2 should equal the account currency. If the
	 transactions are future-dated and the future build flag is set
	 (FUTBLD=1), then the conversion fee transaction will be formatted
	 on the future-date.
	*/
	if eftpay.actcnv>0,'FUTBLD do {

		// Add "NDPO" field to TSO
		// STBLMSG - Conversion Fee
		set TSO=$$FIELDIN^UTSO(TSO,"NDPO",$$^MSG(7758))
		set OFFTSO=$$FIELDIN^UTSO(OFFTSO,"NDPO",$$^MSG(7758))

		// Conversion fee transaction
		do BLDTR(.ttx(),CID,ETCDR,eftpay.actcnv,DATE,TSO,eftpay.relrefno,CC,CRCD,eftpay.ccode)
		if ER quit

		// Conversion fee offset transaction
		do BLDTR(.ttx(),FEEGL,FEECR,eftpay.feeamt2,DATE,OFFTSO,eftpay.relrefno,CCDFT,eftpay.feecrcd2,eftpay.ccode)
	}
	if ER quit

	/*
	 Format receiver's charge transaction to the payment account for the
	 converted receiver's charge amount and format the offset to the
	 receiver's charge transaction. eftpay.actrcvrchg is in the account
	 currency and eftpay.rcvrchg is in the payment currency, but rcvrchg
	 is ignored. To avoid extra currency exchanges, the account currency
	 is used in place of eftpay.rcvrchgc and eftpay.rcvrchg. If the
	 transactions are future-dated and the future build flag is set
	 (FUTBLD=1), then the receiver charge transaction will be formatted
	 on the future-date.
	*/
	if eftpay.actrcvrchg>0,'FUTBLD do {

		// Add "NDPO" field to TSO
		// STBLMSG - Receiver's charge
		set TSO=$$FIELDIN^UTSO(TSO,"NDPO",$$^MSG(4507))
		set OFFTSO=$$FIELDIN^UTSO(OFFTSO,"NDPO",$$^MSG(4507))

		// Receiver's charge transaction
		do BLDTR(.ttx(),CID,ETCDR,eftpay.actrcvrchg,DATE,TSO,eftpay.relrefno,CC,CRCD,eftpay.ccode)
		if ER quit

		// Receiver's charge offset transaction
		do BLDTR(.ttx(),FEEGL,FEECR,eftpay.actrcvrchg,DATE,OFFTSO,eftpay.relrefno,CCDFT,CRCD,eftpay.ccode)
	}

	quit


public REV(RecordEFTPAY eftpay,RecordTTX ttx(),OPT,BRCD,TTXKEY)

	/*
	 Format reversal transactions

	 ARGUMENTS:
		eftpay		Foreign payment object
		OPT		Processing option
		BRCD		Teller posting branch code
		TTXKEY		Teller transaction key

	 RETURNS:
		ttx()		Transaction object array
	*/

	catch Error1 {
		new ET

		set ET=Error1.type
		set RM=""

		// Log error to the Profile error log
		if ET["%GTM-" do ZE^UTLERR quit

		set ERR=1
		set ERRMSG=Error1.description
	}

	new nseq,ETC,FLG,NDPO,RELREFNO,SCREEN,STOP,TAMT,TPD,TRAN,TRC
	new TSEQ,TTXBRCD,UID

	if TTXKEY="" quit

	// Determine TTX/TTXFDT keys
	set TPD=$P(TTXKEY,",",1)		// System posting date
	set TTXBRCD=$P(TTXKEY,",",2)		// Branch code
	set UID=$P(TTXKEY,",",3)		// User id
	set TRC=$P(TTXKEY,",",4)		// Transaction screen
	set SCREEN=TRC

	// Format reversal transactions
	set (nseq,STOP)=0
	for  do {  quit:ER!STOP
		new TSO,UTSO

		type RecordTTX ttxrev
		type RecordTTXFDT ttxfdt
		type RecordTRN trn

		set TRC=TRC+1

		// Verify that the transaction exists & retrieve transaction
		if TPD>%SystemDate do {
			if 'Db.isDefined("TTXFDT","TPD,TTXBRCD,UID,TRC") set STOP=1 quit
			set ttxfdt=Db.getRecord("TTXFDT","TPD,TTXBRCD,UID,TRC")
			set ttxrev=Class.new("RecordTTX")
			set ttxrev=ttxfdt.copy()
			set ttxrev.tjd=ttxfdt.tjd
			set ttxrev.brcd=ttxfdt.brcd
			set ttxrev.uid=ttxfdt.uid
			set ttxrev.tseq=ttxfdt.tseq
		}
		else  do {
			if 'Db.isDefined("TTX","TPD,TTXBRCD,UID,TRC") set STOP=1 quit
			set ttxrev=Db.getRecord("TTX","TPD,TTXBRCD,UID,TRC")
		}
		if STOP quit

		// Verify transaction has not already been reversed or error-corrected
		// STBLMSG - Transaction already error-corrected
		if ttxrev.itc6 set ER=1,RM=$$^MSG(2676) quit
		// STBLMSG - Transaction previously reversed
		if ttxrev.itc12 set ER=1,RM=$$^MSG(3544) quit

		// Determine transactions TSO.NDPO value
		do OUT^UTSO(.UTSO,ttxrev.tso)
		set NDPO=$G(UTSO("NDPO"))

		// Verify this transaction is related to this payment
		if $G(UTSO("SPEC"))'=eftpay.refno set ER=1,RM=$$^MSG(7553) quit
	
		// Do not reverse fee transactions for cancellations. Only outgoing payments are cancelled
		// STBLMSG - Payment Fee
		if (OPT=1),(NDPO=$$^MSG(7759)) quit	// Fee transaction
		// STBLMSG - Conversion Fee
		if (OPT=1),(NDPO=$$^MSG(7758)) quit	// Conversion fee transaction

		/*
		 Delete future-dated transactions because future-dated transactions
		 cannot be reversed. Since there is no guarantee that reversals,
		 cancellation, and returns are processed by the same user, future-dated
		 transactions are deleted.
		*/
		if TPD>%SystemDate do Db.delete("TTXFDT","TJD=:TPD AND BRCD=:TTXBRCD AND UID=:UID AND TSEQ=:TRC") quit

		// Include transaction in transaction object array
		set nseq=nseq+1
		set ttx(nseq)=ttxrev.copy()

		// Retrieve transaction code information
		set ETC=ttx(nseq).etc
		if ETC="" set ER=1,RM=$$^MSG(1498)
		if 'Db.isDefined("TRN","ETC") set ER=1,RM=$$^MSG(1498,ETC)
		set trn=Db.getRecord("TRN","ETC")

		// Determine the history transaction sequence number
		set TSEQ=""
		if trn.cls'="M" do {
			set TAMT=ttx(nseq).tamt
			set RELREFNO=eftpay.relrefno
			type ResultSet rs=Db.select("TSEQ","HIST","CID=:CID AND ETC=:ETC AND TAMT=:TAMT AND TCMT=:RELREFNO","TSEQ DESC")
			if 'rs.isEmpty(),rs.next() set TSEQ=rs.getCol(1)
		}

		// Update TSO field with reversal or error-correct information
		if (ttx(nseq).tjd=%SystemDate),(ttx(nseq).brcd=BRCD),(ttx(nseq).uid=%UserID),(ttx(nseq).tseq=ttx(nseq).trc) do {
			set UTSO("EC")=ttx(nseq).trc
			set UTSO("REV")=TSEQ
			// STBLMSG - (EC) SEQ # ~p1
			// STBLMSG - REVERSAL: G/L
			set ttx(nseq).tcmt=$S(trn.cls'="M":$$^MSG(7651,TSEQ),1:$$^MSG(3539))
			set FLG=6
		}
		else  do {
			set UTSO("REV")=TSEQ
			// STBLMSG - REVERSE ~p1 ~p2
			// STBLMSG - REVERSAL: G/L
			set ttx(nseq).tcmt=$S(trn.cls'="M":$$^MSG(3543,$$DAT^%ZM(ttx(nseq).tjd),ttx(nseq).etc),1:$$^MSG(3539))
			set FLG=12
		}
		if ER quit

		// Define TSO
		do IN^UTSO(.UTSO,.TSO)
		set ttx(nseq).tso=TSO

		// Reverse component transaction amounts
		set ttx(nseq).tamt=$$TAMT^TRNUTL(ttx(nseq).tamt)
		if ER quit

		// Update ITC with reversal or error-correct flag
		set ttx(nseq).itc=$$ITC^TTXEXT(ttx(nseq).itc,FLG,1)

		/*
		 Create exchange transactions using the exchange utility for main transactions only.
		 Foreign payment processing was originally designed to avoid the extra exchange
		 transactions that would be generated by standard transaction processing when all
		 of the transactions for a single payment are posted.
		*/
		if TRC#SCREEN=2 do EXCHANGE(.ttx())
	}

	quit


OFFSET(RecordEFTPAY eftpay,RecordTTX ttx(),CCDFT,EMUCRCD,GLTS,DATE,OPT,SETAMT,SETCRCD,OFFCID)

	/*
	 Format nostro/vostro offset transactions

	 ARGUMENTS:
		eftpay		Foreign payment object
		CCDFT		Default cost center
		EMUCRCD		EMU currency code
		GLTS		Transaction suspense GL
		DATE		Processing date of transactions
		OPT		Processing option
		SETAMT		Payment settlement amount
		SETCRCD		Payment settlement currency
		OFFCID		Offset account

	 RETURNS:
		ttx()		Transaction object array
	*/

	new CRETC,DRETC,ETC1,ETC2,EXCAMT,FEECR,FEEGL,MAXRATE,MINRATE
	new MULTIPLY,RATE,TCMT,TRESREF,TSO,UTSO,VARIANCE

	// Determine transaction date
	if (eftpay.efttype="NDPOIN"),(OPT=3) set DATE=$S(eftpay.rtndt'<eftpay.procdt:eftpay.rtndt,1:eftpay.procdt)

	set UTSO("ZSTAT")=eftpay.consndpo
	set UTSO("ZARES")=eftpay.varndpo
	set UTSO("SPEC")=eftpay.refno
	set UTSO("NDPO")=""
	do IN^UTSO(.UTSO,.TSO)

	// Determine nostro/vostro settlement account's external transaction code
	// STBLMSG - Invalid account ~p1
	if eftpay.sendnos="" set ER=1,RM=$$^MSG(1259) quit
	do NOSETC(eftpay.sendnos,.DRETC,.CRETC)
	if ER quit

	// Determine transaction comment & transaction code
	if OPT=0 do {					// Process
		set TCMT=eftpay.relrefno
		if eftpay.efttype="NDPOIN" set ETC1="MCR",ETC2=DRETC
		else  set ETC1="MDR",ETC2=CRETC
	}
	else  do {					// Returned funds
		// STBLMSG - Payment Returned
		set TCMT=$$^MSG(7753)
		if eftpay.efttype="NDPOIN" set ETC1="MDR",ETC2=CRETC
		else  set ETC1="MCR",ETC2=DRETC
	}

	// Format offset transaction from suspense account
	do BLDTR(.ttx(),OFFCID,ETC1,SETAMT,DATE,TSO,TCMT,CCDFT,SETCRCD,eftpay.ccode)
	if ER quit

	/*
	 Determine returned amount. The returned amount is converted to EMU
	 currency if setcrcd is set because rtntotpmt is always in the 
	 payment currency.
	*/
	if (eftpay.efttype="NDPOIN"),(OPT=3) do {
		set SETAMT=eftpay.rtntotpmt
		if 'eftpay.setcrcd!(eftpay.crcd=EMUCRCD) quit

		// Convert payment amount to EMUCRCD (no margins, non-cash, mid-rate)
		do EXC^CRCDUTL(eftpay.crcd,EMUCRCD,SETAMT,1,2,"00",eftpay.ccode,"",1)
		if ER quit
		set SETAMT=$$^SCARND(EXCAMT,0,,EMUCRCD)
	}

	/*
	 Format transaction to nostro/vostro account. Returned incoming payments
	 format a transaction to the nostro/vostro account for the returned amount.
	*/
	do BLDTR(.ttx(),eftpay.sendnos,ETC2,SETAMT,DATE,TSO,TCMT,CCDFT,SETCRCD,eftpay.ccode)

	if (eftpay.efttype'="NDPOIN")!(OPT'=3) quit

	/*
	 Format return fee transactions
	 The feeamtpmt and rtnfeeamt2 amounts are in the payment currency, not the
	 original fee currency or the settlement currency.
	*/

	// Retain original fee transaction, so re-format fee transaction
	if eftpay.origfee,(eftpay.feeamtpmt>0) do {

		// Determine fee offset transaction code and fee offset GL account
		do FEETYPE(eftpay.feetype,1,GLTS,,.FEEGL,.FEECR)

		// Format transaction
		do BLDTR(.ttx(),FEEGL,FEECR,eftpay.feeamtpmt,DATE,"",eftpay.relrefno,CCDFT,eftpay.crcd,eftpay.ccode)
	}
	if ER quit

	// Format Payment/processing fee transaction
	if eftpay.rtnfeeamt2>0 do {

		// Determine fee offset transaction code and fee offset GL account
		do FEETYPE(eftpay.rtnfeetype,1,GLTS,,.FEEGL,.FEECR)

		// Format transaction
		do BLDTR(.ttx(),FEEGL,FEECR,eftpay.rtnfeeamt2,DATE,"",eftpay.relrefno,CCDFT,eftpay.crcd,eftpay.ccode)
	}
	quit

FEECC(RecordEFTPAY eftpay,RecordTTX ttx(),RecordEFTFEE eftfee,DATE,CC,CRCD,FEEGL,FEECR)

	/*
	 Format fee offset transactions
	 Split fee offsets across multiple cost centers based upon the fee plan.

	 ARGUMENTS:
		eftpay		Foreign payment object
		ttx()		Transaction object array
		eftfee		Payment fee type object
		DATE		Processing date of transactions
		CC		Cost center
		CRCD		Fee currency code
		FEEGL		Fee GL account
		FEECR		Fee transaction code

	 RETURNS:
		ttx()		Transaction object array
	*/

	new CCT,CNT,FEECC,FEETSO,PCT,TAMT,TOT,TOTPCT,UTSO

	// Determine cost centers
	set CCT(1)=CC			// Payment branch cost center
	set CCT(2)=eftfee.cc1		// Cost center 1
	set CCT(3)=eftfee.cc2		// Cost center 2
	set CCT(4)=eftfee.cc3		// Cost center 3
	set CCT(5)=CC			// Unallocated percentage

	// Determine allocated percentages
	set PCT(1)=eftfee.pctbrcd
	set PCT(2)=eftfee.pctcc1
	set PCT(3)=eftfee.pctcc2
	set PCT(4)=eftfee.pctcc3

	// Determine unallocated percentage
	set TOTPCT=PCT(1)+PCT(2)+PCT(3)+PCT(4)
	if 'TOTPCT set PCT(1)=100,TOTPCT=100
	set PCT(5)=100-TOTPCT

	// Build fee offset TSO
	// STBLMSG - Payment Fee
	set UTSO("NDPO")=$$^MSG(7759)
	set UTSO("CON")=eftfee.constant
	set UTSO("SPEC")=eftpay.refno
	do IN^UTSO(.UTSO,.FEETSO)
	if ER quit

	// Format fee offset transactions based on the cost center percentages
	set TOT=0
	for CNT=1:1:5 do { quit:ER
		set TAMT=eftpay.actfee*(PCT(CNT)/100)
		if 'TAMT quit
		set FEECC=CCT(CNT)
		if FEECC="" quit

		// Round up or down depending on amount
		set TAMT=$$^SCARND(TAMT,,,CRCD,,$S(TAMT>0:"-",1:"+"))
		if ER quit

		// Format transaction
		do BLDTR(.ttx(),FEEGL,FEECR,TAMT,DATE,FEETSO,eftpay.relrefno,FEECC,CRCD,eftpay.ccode)
		set TOT=TOT+TAMT
	}
	if ER quit

	// To prevent a possible out-of-balance condition, post any remainder of fees
	// to the branch cost center
	if +TOT'=+eftpay.actfee do {
		set TAMT=eftpay.actfee-TOT
		do BLDTR(.ttx(),FEEGL,FEECR,TAMT,DATE,FEETSO,eftpay.relrefno,CCT(1),CRCD,eftpay.ccode)
	}

	quit

FEETYPE(FEETYPE,RESCD,GLTS,RecordEFTFEE eftfee,FEEGL,FEECR)

	/*
	 Determine fee offset transaction code and fee offset GL account

	 ARGUMENTS:
		FEETYPE		Fee type
		RESCD		Residency code
		GLTS		Transaction suspense GL

	 RETURNS:
		eftfee		Payment fee type object
		FEEGL		Fee GL account
		FEECR		Fee transaction code
	*/

	set FEEGL=GLTS
	set FEECR="MCR"
	if (FEETYPE'=""),Db.isDefined("EFTFEE","FEETYPE") do {
		set eftfee=Db.getRecord("EFTFEE","FEETYPE")
		set FEECR=eftfee.etccr
		set FEEGL=$S(RESCD:eftfee.feeglnr,1:eftfee.feegl)
	}

	quit


public NEWRATE(RecordEFTPAY eftpay)

	/*
	 Calls ^EFTFCALC to calculate the actual amounts and rate using 
	 the current system exchange rates.

	 ARGUMENTS:
		eftpay		Foreign payment object

	 RETURNS:
		eftpay		Foreign payment object

	 The following fields may be updated:
	  eftpay.rate		Payment exchange rate
	  eftpay.actamt		Actual amount
	  eftpay.actfee		Actual fee amount
	  eftpay.actcnv		Actual conversion fee amount
	  eftpay.actrcvrchg	Actual receiver charges
	  eftpay.actamtfee	Actual amount plus fees
	  eftpay.feeamt		Fee amount charged
	  eftpay.feecrcd	Fee currency
	  eftpay.feeamt2	Conversion fee amount charged
	  eftpay.feecrcd2	Conversion fee currency
	*/

	new AAMT,ACNF,AFEE,AHLD,ARTE,ARVR,CNVAMT,CNVCRCD,FEEAMT,FEECRCD

	do ^EFTFCALC(.eftpay,.FEEAMT,.FEECRCD,.CNVAMT,.CNVCRCD,.AAMT,.ARTE,.AFEE,.ACNF,.AHLD,.ARVR)

	// Update actual amounts and actual rate
	do eftpay.setAuditFlag(1)
	set eftpay.rate=ARTE
	set eftpay.actamt=AAMT
	set eftpay.actfee=AFEE
	set eftpay.actcnv=ACNF
	set eftpay.actrcvrchg=ARVR
	set eftpay.feeamt=$$^SCARND(FEEAMT,0,"",FEECRCD)
	set eftpay.feecrcd=FEECRCD
	set eftpay.feeamt2=$$^SCARND(CNVAMT,0,"",CNVCRCD)
	set eftpay.feecrcd2=CNVCRCD

	// Calculate total amount charged to the payment account (outgoing only)
	// Receiver charges are included in the actual amount (AAMT)
	if eftpay.efttype'="NDPOIN" set eftpay.actamtfee=AAMT+AFEE+ACNF

	quit


BLDTR(RecordTTX ttx(),CID,ETC,TAMT,EFD,TSO,TCMT,CC,CRCD,CUSTCD)

	/*
	 Build transaction based upon input parameters.

	 ARGUMENTS:
		ttx()		Transaction object array
		CID		Transaction account number
		ETC		Transaction code
		TAMT		Transaction amount
		EFD		Transaction effective date
		TSO		Transaction source
		TCMT		Transaction comment
		CRCD		Fee currency code
		CUSTCD		Transaction customer code

	 RETURNS:
		ttx()		Transaction object array
	*/

	new seq

	type RecordTRN trn

	// STBLMSG - Invalid transaction code ~p1
	if ETC="" set ER=1,RM=$$^MSG(1498) quit
	if 'Db.isDefined("TRN","ETC") set ER=1,RM=$$^MSG(1498,ETC) quit
	set trn=Db.getRecord("TRN","ETC")

	// Determine next primary transaction sequence
	set seq=($O(ttx(""),-1)\1)+1

	// Build the transaction
	set ttx(seq)=Class.new("RecordTTX")
	set ttx(seq).cid=CID
	set ttx(seq).itc=trn.itc
	set ttx(seq).etc=ETC
	set ttx(seq).tamt=TAMT
	set ttx(seq).efd=EFD
	set ttx(seq).tlo=%UserStation
	set ttx(seq).tso=TSO
	set ttx(seq).tcmt=TCMT
	set ttx(seq).cc=CC

	if %MCP do {
		set ttx(seq).crcd=CRCD
		set ttx(seq).bseamt=TAMT
		set ttx(seq).custcd=CUSTCD
	}

	quit


POST(RecordEFTPAY eftpay,RecordTTX ttx(),DATE,BRCD,REJMET,TTXKEY)

	/*
	 Post formatted transactions

	 ARGUMENTS:
		eftpay		Foreign payment object
		ttx()		Transaction object array
		DATE		Processing date of transactions
		BRCD		Teller branch code
		REJMET		Teller rejection method

	 RETURNS:
		TTXKEY		Teller transaction key
	*/

	type RecordTTXUID ttxuid
	type RecordTTXFDTUID fdtuid

	new seq,x,LPSEQ,INPAR,RJ,TOPTRC,TPD,TSPV,UID

	/*
	 Verify that there are transactions to post. Future-dated transactions
	 may not generate any transactions to post because future-dated
	 transactions are deleted, not reversed.
	*/
	if $O(ttx(""))="" quit

	set TTXKEY=""

	// Determine next transaction trace number
	set TPD=%SystemDate
	set UID=%UserID
	if DATE>%SystemDate do {
		if 'Db.isDefined("TTXFDTUID","DATE,BRCD,UID") set LPSEQ="" quit
		set fdtuid=Db.getRecord("TTXFDTUID","DATE,BRCD,UID")
		set LPSEQ=fdtuid.endseq
	}
	else  do {
		if 'Db.isDefined("TTXUID","TPD,BRCD,UID") set LPSEQ="" quit
		set ttxuid=Db.getRecord("TTXUID","TPD,BRCD,UID")
		set LPSEQ=ttxuid.lpseq
	}
	set (TOPTRC,LPSEQ)=(LPSEQ+1)*1000

	// Define the transaction trace values
	set seq=""
	for  set seq=$O(ttx(seq)) quit:seq=""  do {
		set ttx(seq).trc=LPSEQ+(seq\1)
		}

	// Determine process key
	set TTXKEY=$S(DATE'>%SystemDate:TPD,1:DATE)_","_BRCD_","_%UserID_","_TOPTRC

	set %IPMODE="NOINT"
	set TSPV("*")=%UserID_"|"_%UserClass

	do TRNSET^TRNDRV(.ttx(),TPD,BRCD,3,,.RJ,.TSPV)
	// STBLMSG - Error Posting Transactions.
	if $D(RJ) set ER=1,RM=$S(RM="":$$^MSG(3764),1:RM)

	quit


UPDATE(RecordEFTPAY eftpay,OPT,SWSENT)

	/*
	 Update foreign payment

	 ARGUMENTS:
		eftpay		Foreign payment object
		OPT		Processing option
		SWSENT		SWIFT sent flag
	*/

	catch Error2 {
		new ET

		set ET=Error2.type
		set RM=""

		// Log error to the Profile error log
		if ET["%GTM-" do ZE^UTLERR quit

		set ERR=1
		set ERRMSG=Error2.description
	}

	new STATUS

	// Update payment status
	do eftpay.setAuditFlag(1)
	if (eftpay.efttype'="NDPOIN"),'SWSENT,(OPT=2) set STATUS="RET"
	else  set STATUS=$S(ER:"R",OPT=1:"CA",OPT=2:"REV",OPT=3:"RET",1:"C")
	set eftpay.status=STATUS

	// Update payment last changed date
	set eftpay.lchdt=%SystemDate

	// Update database
	do eftpay.save()

	quit


SWIFT(RecordEFTPAY eftpay)

	/*
	 Generate SWIFT messages

	 ARGUMENTS:
		eftpay		Foreign payment object
	*/

	new EFTPAY,MSGLIST

	// SWIFT messages are sent for incoming payments only if it is returned
	if (eftpay.efttype="NDPOIN"),(OPT'=3) quit

	set MSGLIST=$S(eftpay.mt103flg:"103",1:"")
	
	/*
	 If no ord inst, send MT103 to correspondent and put the ordering
	 institution as the beneficiary on MT202
	*/
	if eftpay.efttype="NDPOIN" do {
		if eftpay.ordinst'="" do {
			set eftpay.recv=eftpay.ordinst
			set eftpay.beninst1=eftpay.ordinst
		}
		else  do {
			set eftpay.recv=eftpay.sendcorr
			set eftpay.beninst1=eftpay.ordinst1
			set eftpay.beninst2=eftpay.ordinst2      
			set eftpay.beninst3=eftpay.ordinst3
			set eftpay.beninst4=eftpay.ordinst4
		}

		set eftpay.amount=eftpay.rtntotpmt
		set eftpay.efd=eftpay.rtndt

		// Beneficiary becomes orderer, orderer becomes beneficiary
		set eftpay.acn=eftpay.benacn
		set eftpay.ord1=eftpay.benad1
		set eftpay.ord2=eftpay.benad2
		set eftpay.ord3=eftpay.benad3
		set eftpay.ord4=eftpay.benad4
		set eftpay.benad1=eftpay.ord1
		set eftpay.benad2=eftpay.ord2
		set eftpay.benad3=eftpay.ord3
		set eftpay.benad4=eftpay.ord4

		// No messages
		if MSGLIST="" quit

		// Generate MT103 message and/or MT202 message
		do NDPO^SWIFTGEN(eftpay.cid,eftpay.seq,MSGLIST,.eftpay)
	}
	else  do {
		if eftpay.mt202flg set MSGLIST=$S(MSGLIST'="":",202",1:"202")

		// No messages
		if MSGLIST="" quit

		// Generate MT103 message and/or MT202 message
		do NDPO^SWIFTGEN(eftpay.cid,eftpay.seq,MSGLIST,.eftpay)
		if ER quit

		// Print SWIFT reports
		do DIS^SWIFTPNT(.eftpay)
		}

	quit


public SETAMT(RecordEFTPAY eftpay,EMUCRCD,UDRC,SETAMT,SETCRCD)

	/*
	 Determine the settlement amount and currency
	 The user-defined rate is used to determine the settlement amount
	 for payments with the EMU settlement flag set and an account
	 currency equal to the EMU currency, otherwise the system exchange rate
	 is used. The user-defined rate is used for payments with an account
	 currency equal to the EMU currency because a user specifies a rate
	 between the payment currency and the account currency. Since the
	 account currency is equal to the new settlement currency (EMU currency),
	 the user-defined rate is used.

	 ARGUMENTS:
		eftpay		Foreign payment object
		EMUCRCD		EMU currency code
		UDRC		User-defined rate code

	 RETURNS:
		SETAMT		Settlement amount
		SETCRCD		Settlement currency
	*/

	new EXCAMT,MAXRATE,MINRATE,MULTIPLY,RATE,TRESREF,VARIANCE

	set SETAMT=eftpay.amount
	set SETCRCD=eftpay.crcd
	if eftpay.setcrcd,(SETCRCD'=EMUCRCD) do {
		if (eftpay.ccode=UDRC),(eftpay.antrate'=""),(eftpay.crcdcid=EMUCRCD) set SETAMT=eftpay.amount*eftpay.antrate,SETCRCD=EMUCRCD quit

		// Convert payment amount to EMUCRCD (no margins, non-cash, mid-rate)
		do EXC^CRCDUTL(SETCRCD,EMUCRCD,SETAMT,1,2,"00",eftpay.ccode,"",1)
		if ER quit
		set SETAMT=$$^SCARND(EXCAMT,0,,EMUCRCD)	
		set SETCRCD=EMUCRCD
	}

	quit


EXCHANGE(RecordTTX ttx())

	/*
	 Create exchange transactions using the exchange utility.
	 ACCFLG is newed because of code in CRCDUTL

	 ARGUMENTS:
		ttx		Transaction object

	 RETURNS:
		ttx		Transaction object
	*/

	new ACCFLG


	do EXCH^CRCDUTL(.ttx())

	quit


NOSETC(SENDNOS,DRETC,CRETC)

	/*
	 Determine nostro/vostro transaction codes

	 ARGUMENTS:
		SENDNOS		Nostro/vostro account

	 RETURNS:
		DRETC		Nostro/vostro debit transaction code
		CRETC		Nostro/vostro credit transaction code
	*/

	new TYPE

	type RecordACN acn
	type RecordPRODDFTD proddftd
	type RecordPRODCTL prodctl

	set (DRETC,CRETC)=""

	if SENDNOS="" quit
	if 'Db.isDefined("ACN","SENDNOS") quit

	set acn=Db.getRecord("ACN","SENDNOS")
	set TYPE=acn.type
	set prodctl=Db.getRecord("PRODCTL","TYPE")
	set proddftd=Db.getRecord("PRODDFTD","TYPE")

	if acn.trb set DRETC=prodctl.crtrgp,CRETC=prodctl.drtrgp
	else  set DRETC=prodctl.drtrgp,CRETC=prodctl.crtrgp

	quit


XEFTNDPO(CID,SEQ,OPT,POST,SWSENT,TR1,TR2)

	/*
	 This procedure will build and post the transactions necessary
	 to complete a foreign payment order.

	 XEFTNDPO should only be used by non-PSL routines (i.e., Data-Qwik
	 screens) that require transaction arrays to be returned. All other
	 non-PSL routines and ALL PSL code should call directly into
	 ^EFTNDPO for processing.

	 ARGUMENTS:
		CID	Payment account number
		SEQ	Payment sequence number
		OPT	Processing option (0-Process, 1-Cancel, 2-Reverse, 3-Post Return)
		POST	Posting option (0-Anticipated, 1-Post Transactions)
		SWSENT	SWIFT sent flag (0-SWIFT messages not sent, 1-SWIFT messages sent)

	 RETURNS:
		TR1	Process date transaction array
		TR2	Effective date transaction array
	*/

	type RecordTTX ttx1()
	type RecordTTX ttx2()

	// Process the foreign payment
	do ^EFTNDPO(CID,SEQ,OPT,POST,SWSENT,.ttx1(),.ttx2())
	if ER quit


	quit

vSIG()	quit "60290^62401^Pat Kelly^32875"	// Signature - LTD^TIME^USER^SIZE
