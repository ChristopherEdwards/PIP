BCHROLL //Batch BCHROLL - Automatic Rollover
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 12:46 - shetyes
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHROLL Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit quit
 do JOBMGR^BCHUTL(%FN,"BCHROLL",.vINPUT)
 do ^JOBMGR(.vINPUT)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(CID) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHROLL","*","",CID.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,CID)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHROLL","*","",CID.get(),"",et)
 }
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,CID) //
	set ER=0
	Type RecordACN acn=Db.getRecord("ACN","CID=:CID")
	do MAIN(.acn)
	quit

MAIN(RecordACN acn)	 // Main processing block

	new %UX,BAL,FSN
 
	new ts,tsrenew,prenew
 
	type TranSet ts,tsrenew,prenew
 
	set ts=Class.new("TranSet")
	set tsrenew=Class.new("TranSet")
	set prenew=Class.new("TranSet")
	
	do DTL(.acn,.ts,.tsrenew,.prenew) if ER do EXC

	do ts.postTSet(TPD,BRCD,.par) quit:ER
 	do tsrenew.postTSet(TPD,BRCD,.par) quit:ER
	do prenew.postTSet(TPD,BRCD,.par) quit:ER

	quit

Public EXTERN(RecordACN acn)  // External Entry Tag
 
	/*
	  Modified to provide Inquiry-only capability for cash flow.
		. CID - Account Number
	*/
 
	new %UX,RSAVSEQ,FSN
 
	do INITVAR
 
	set RSAVSEQ=$G(SEQ)
 
	// Initialize Source, User ID, Userclass, and GL accounts.
	do SOURCE^BCHSOURC("ROLL","ROLL",.%UserID,.BRCD,.%UserClass,.TSDRCID,.TSCRCID)
 
	do MAIN(.acn)
 
	quit


Public MANUAL(CID)    // Manual rollover
 
	/*
 
	 Modified to provide Inquiry-only capability for cash flow.
 
		. CID - Account Number
 
	*/ 

	if $D(ITS) quit
	new EFD
 
	do INITVAR
	new scau
	type RecordSCAU scau
	set scau=Db.getRecord("SCAU","%UID")

	do { quit:ER
		if '%NET set ET="NETWORK",ER=1 do ^UTLERR quit
		set TPD=TJD,BRCD=0
 
		new %UserID,BRCD,%UserClass
 
		do SOURCE^BCHSOURC("ROLL","ROLL",.%UserID,.BRCD,.%UserClass,.TSDRCID,.TSCRCID)
 
		if TSDRCID="" set TSDRCID=GLACN
		if TSCRCID="" set TSCRCID=GLACN
 
		set $P(GLACN,"|",2)=TSDRCID     	// Transaction Suspense (DR)
		set $P(GLACN,"|",3)=TSCRCID     	// Transaction Suspense (CR)
 
		}

	set TRC=Db.prevVal("TTX","TPD,BRCD,%UID,""""")
 
	set SVCID=CID new CID set CID=SVCID 
 
	new ts,tsrenew,prenew
	type TranSet ts,tsrenew,prenew
	set ts=Class.new("TranSet")
	set tsrenew=Class.new("TranSet")
	set prenew=Class.new("TranSet")
 
 	type RecordACN acn=Db.getRecord("ACN","CID")
 
	do DTL(.acn,.ts,.tsrenew,.prenew)
 
	if ER do EXC quit

	do ts.postTSet(TPD,BRCD,.par)
	do tsrenew.postTSet(TPD,BRCD,.par)
	do prenew.postTSet(TPD,BRCD,.par)
	do OFFSET^TTXBLD(%SystemDate,BRCD,%UserID,"BCHROLL")

	quit


 
DTL(RecordACN acn,TranSet ts,TranSet tsrenew,TranSet prenew)     // Process single account
 
	set ER=0,SVCID=CID
	set trseq=0

	new CUMINT
	set CUMINT=0 ;ahmeds

	new INTANC
	
	if acn.stat=4 quit			// closed account
	if acn.cls="L" do ROLL1(.acn,.ts) quit	// Loan account 

	// must be a deposit account from here
	type RecordDEP dep={RecordDEP}acn

	/*
	If the balance on the account is not greater than zero place it
	in the exception file.
	*/

	if dep.bal<0 set ER=1,ET="NEGBAL" quit

	if dep.segflg=1 quit		// skip segmented accounts

	new prodctl
	type RecordPRODCTL prodctl
	set prodctl=Db.getRecord("PRODCTL","dep.type")

	if dep.mdt>%SystemDate quit	// maturity date in the future
	set BAL=dep.bal
	set TYPE=dep.type
	set CRCD=dep.crcd
	set GLSC=dep.glsc
	set IACM=dep.iacm 			// force load of node 49
	set PRENA=dep.prena			// Partial Renewal Amount
	if PRENA'="" set PRENA=$$^SCARND(PRENA,0,CID)
	set MINBAL=dep.minbal	   	// Minimum Balance
	new CC set CC=dep.cc		
	
	// check exception - Partial renewal amount greater than account balance
	if PRENA>BAL set ER=1,RM=$$^MSG("3856") quit

	// check exception - Partial renewal amount less than minimum balance
	if PRENA'="",PRENA<MINBAL set ER=1,RM=$$^MSG("8621") quit

	if '$D(GLSC(GLSC)) do {
		new utblglsc
		type RecordUTBLGLSC utblglsc
		set utblglsc=Db.getRecord("UTBLGLSC","GLSC")
		set $P(GLSC(GLSC),"|",1)=utblglsc.dgl2	 // Dep G/L # (Accrued Int)
		set $P(GLSC(GLSC),"|",2)=utblglsc.dgli  // Interest Expense G/L		
		}

	if '$D(TC(dep.type)) do INI(.prodctl)

	set INTAVLNCR=dep.intavlncr   // Interest Paid not Credited  

	type Number DWA,DSWA

	set DWA=0,DSWA=0
	set IMO=dep.imo			// Interest Maturity Option
	set INT=$$^SCARND(dep.acr,0,CID)	// Accrued Positive Interest
	set NINT=$$^SCARND(dep.negacr,0,CID)	// Accrued Negative Int.	
 
	set OINT=INT,ONINT=NINT
 
	set CHKAMT=dep.aecamt			// Anticipated check amount
	set INTAMT=$P(CHKAMT,"#",3)		// Interest portion of check
	set WTHAMT=$P(CHKAMT,"#",5)		// Withholding portion of check
 
	set MININT=dep.minint			// Minimum Balance to Pay Int.
 
	if MININT="" set MININT=-1E15
 
	set IRAPO=""

	if dep.rpaseq do {
		new ira
		type RecordIRATYPE ira=Db.getRecord("IRATYPE","dep.acn,dep.rpaseq")

		set IRAPO=ira.iradis
		// IRA Default Dist Code
		if IRAPO="" do {
			type RecordCUVAR cuvar=Db.getRecord("CUVAR")
			set IRAPO=cuvar.iradis
			}
		}
 
	/* 
	If projected maturity date is greater than the current date,
	calculate an accrual adjustment if the balance is not less
	than the minimum balance to pay interest.
	*/

	set ADJ=0
	if dep.pmedat>%SystemDate,dep.bal'<MININT do {
 
		do {
			new EFD,INT
			set PRIN=dep.bal
			set EFD=dep.pmedat

			set POPT=0
			do EXEC^DEPAES
			set ADJ=$$^SCARND(ACR-dep.posacr,0,CID)
			set ACR=$$^SCARND(ACR,0,CID)
 	
			if ADJ do {
				new TCMT
				set TCMT=$$^MSG(3465)
 
				if ADJ<0 set ETC=prodctl.dradin,TAMT=-ADJ
				else  set ETC=prodctl.cradin,TAMT=ADJ
 
				do CRTTX(.ts,ETC,TAMT,CID,TSO,TCMT)
 
				new CID
				set CID=+GLSC(GLSC)	
				if ADJ<0 set ETC="MCR"
				else  set ETC="MDR"
 
				do CRTTX(.ts,ETC,TAMT,CID,TSO,TCMT)
				}
			}
	
		set INT=ACR
		}
 
	/*
	If an anticipated check amount is outstanding, ensure component
	amounts reflect the current account status (i.e. principal amt
	equals the account balance, interest amount equals the accrued
	plus adjustments).
	*/
 
	if CHKAMT do CHKAMT(.acn) if ER set ET="CHKERR" quit  // Ant check error
	
	/*
	If the balance is less than the minimum to credit interest,
	the accrual amount is adjusted to zero, by the negative of
	the current accrual amount, unless an anticipated interest
	check amount is outstanding.
	I18N=OFF
	*/
 
	if dep.bal<MININT,INT,'INTAMT do {
 
		set TCMT="BAL < MININT"
		set ADJ=-INT,INT=0
 
	 	if ADJ<0 set ETC=prodctl.dradin,TAMT=-ADJ
		else  set ETC=prodctl.cradin,TAMT=ADJ
	 	do CRTTX(.ts,ETC,TAMT,CID,TSO,TCMT)
 
		new CID
		set CID=+GLSC(GLSC)			
		if ADJ<0 set ETC="MCR"
		else  set ETC="MDR"
	 	do CRTTX(.ts,ETC,TAMT,CID,TSO,TCMT)
 
		set ADJ=0
		}
 
	/*
	I18N=ON
	Adjust the accrued interest to equal the interest amount of the
	anticipated check, if applicable.
	*/

	if 'dep.ero,INTAMT do { quit:ER  set INT=INTAMT
		set MAXADJ=prodctl.maxadj,ADJ=INTAMT-$$^SCARND(dep.posacr,0,CID)
		quit:'ADJ
		if $$FN^SCARND(ADJ,"-",CID)>MAXADJ,MAXADJ'="" set ER=1,ET="MAXADJ" do EXC quit
 
		set TMCT=$$^MSG(3464)
	 	if ADJ<0 set ETC=prodctl.dradin,TAMT=-ADJ
		else  set ETC=prodctl.cradin,TAMT=ADJ
	 	do CRTTX(.ts,ETC,TAMT,CID,TSO,TCMT)
 
		new CID
		set CID=+GLSC(GLSC)				
		if ADJ<0 set ETC="MCR"
		else  set ETC="MDR"
	 	do CRTTX(.ts,ETC,TAMT,CID,TSO,TCMT)
		}
 
	/*
	Deal with rounding error when accrual ends in .005 equivalent
	Only calculate adjustment if no other adjustments have been
	made, (e.g., PME or anticipated checks)
	*/
 
	if INT=OINT set INTADJ=$$^SCARND(dep.posacr-INT,0,CID)
	else  set INTADJ=0
 
	if NINT=ONINT set NINTADJ=$$^SCARND(dep.negacr-NINT,0,CID)
	else  set NINTADJ=0
 
	set SAVINT=INT				// Retain variable

 	// Decrease accrued, credit interest, adjust accrued, if applicable.
	set RENCD=dep.rencd 
	do ACR(.acn,.ts,.prodctl) if ER quit
 
	if ADJ<0 set ADJ=-ADJ do {
	 	if ADJ<0 set ETC=prodctl.dradin,TAMT=-ADJ
		else  set ETC=prodctl.cradin,TAMT=ADJ
	 	do CRTTX(.ts,ETC,TAMT,CID,TSO,TCMT)
 
		new CID
		set CID=+GLSC(GLSC)				
		if ADJ<0 set ETC="MCR"
		else  set ETC="MDR"
	 	do CRTTX(.ts,ETC,TAMT,CID,TSO,TCMT)
		}

	if RENCD=0 do dep0(.acn,.tsrenew) quit
	if RENCD=1 do dep1(.acn,.tsrenew,.prodctl,.prenew) quit
	if RENCD=2 do dep2(.acn,.tsrenew,.prodctl,.prenew) quit
	if RENCD=3 do dep3(.acn,.tsrenew) quit
	
	if RENCD=4 do {  quit
		set payamt=dep.bal
		if dep.imo=0 set payamt=payamt+SAVINT
		do EFTBUILD(0,payamt,.acn,.tsrenew)
		}
	if RENCD=5 do dep5(.acn,.tsrenew) quit
	if RENCD=6 do dep6(.acn,.tsrenew,.prodctl) quit
	quit

 
dep0(RecordDEP dep,TranSet tsrenew)	// No action unless:
 
	if $$ACT(.dep) do dep3(.dep,.tsrenew) quit
 
	do FILE(.dep)
	quit
	
ACT(RecordDEP dep)	// Determine if there is an action to take
 
	if dep.ero'="" quit 1		// Earnings renewal option specified
	if dep.rro'="" quit 1		// Rate renewal option specified
	if dep.dftmdt'="" quit 1	// Default group specified

	// Renewal information specified in lower level of node 65
	if Db.isDefined("ROLLOVR","CID")>1 quit 1
 
	quit 0
 
dep1(RecordDEP dep,TranSet tsrenew,RecordPRODCTL prodctl,TranSet prenew)	

	// Pay by Check
	new xpdo
	new AECAMT,CLCUMINT,FEEACT,FEEAMT,SVBALCL,SVCFEECID,XPDOKY
 
	set AECAMT=dep.aecamt
	set SVCFEECID=dep.svcfeecid

	set CKTYP=prodctl.ckmdt

	if CKTYP="" set CKTYP=$P(TC(TYPE,10),"|",2)   

	set ETC=prodctl.drtrgp			
	if ('(PRENA>0)&(dep.imo'=4)) do {
		if dep.imo=5&INTANC'=0 quit
		set ETC=prodctl.drtrci		//Closeout tran code
		if ETC="" set ETC=prodctl.drtrgp
 		}

	new trn
	type RecordTRN trn
	set trn=Db.getRecord("TRN","ETC")
	set ITC=trn.itc

	set SVBALCL=dep.bal+INT+INTADJ-BWA-NINT-NINTADJ   

	if 'dep.rpaseq set TSO=""

	else  do {  if ER quit
	 	set TSO=$$RPATSO("IRAD",dep.ira,21,IRAPO)	
		do DWA(.dep,.TAMT) if ER quit
		}

	do FEES^DEPDBS(.dep,.trn,.FEEAMT,.FEEACT,.DWA,.DSWA)
	
	// Get correct cumulative interest amount for closeout
	set CLCUMINT=0
	if dep.cumdep,ETC=prodctl.drtrci do { quit:ER
		new CUMINT,INTAVLNCR     
		set CUMINT=0
		do CUMDEP^DEPDBS(.dep,INT,dep.ipl) quit:ER
		set CLCUMINT=CUMINT
		}	
 
	set TCMT=$$^MSG(7094)
	set TAMT=SVBALCL-FEEACT-FEEAMT+CLCUMINT
	
	if $G(PRENA)>0 set TAMT=TAMT-PRENA
	if dep.imo=5 set PRENA=PRENA+INTANC
	if dep.imo'=5 set TAMT=TAMT+INTAVLNCR

	set CKSEQ=""
	if 'CHKAMT do XPDO(.dep)		
	set XPDOKY=TJD_"*"_CKTYP_"*"_CKSEQ

	do CRTTX(.tsrenew,ETC,TAMT,CID,TSO,TCMT,XPDOKY) if ER quit
	do GL(.dep,.tsrenew,"mat") if ER quit	
	do FILE(.dep)
	if $G(PRENA)>0 do dep3(.dep,.prenew)
	
	quit
 
dep2(RecordDEP dep,TranSet tsrenew,RecordPRODCTL prodctl,TranSet prenew)	
						// Transfer to another Account
 
	new TACN,TAMT,TCMT,XCID,CCODE
	
	set ETC=prodctl.drtrgp
	if ('(PRENA>0)&(dep.imo'=4)) do {
		if dep.imo=5&INTANC'=0 quit
		set ETC=prodctl.drtrci		//Closeout tran code
		if ETC="" set ETC=prodctl.drtrgp
 		}

	set TACN=dep.racn
	set CCODE=dep.ccode				
	set TCMT="TFR-"_TACN
	set TAMT=dep.bal+INT+INTADJ-BWA-NINT-NINTADJ+CUMINT

	if 'dep.rpaseq set TSO=""

	else  do { if ER quit
		set TSO=$$RPATSO("IRAC",dep.ira,24,IRAPO)
		do DWA(.dep,.TAMT) if ER quit
		}
 	
	if $G(PRENA)>0 set TAMT=TAMT-PRENA
	if dep.imo=5 set PRENA=PRENA+INTANC
	if dep.imo'=5 set TAMT=TAMT+INTAVLNCR

	do CRTTX(.tsrenew,ETC,TAMT,CID,"",TCMT) if ER quit

	new TTXPTR,tseq					
	set tseq=1
	set TTXPTR(tseq)=x
 
	set XCID=CID
	set CID=TACN
 
	new tacn
	type RecordACN tacn=Db.getRecord("ACN","TACN",1)
	
	// Invalid tfr account ~p1
	if tacn.getMode()=0 set TCMT=$$^MSG(4677,CID) do TSCR(.tsrenew) quit

	//Tfr account ~p1 closed
	new ORIGTRB set ORIGTRB=$$TRB^UTRB(XCID)	
	if tacn.stat=4 do { quit
		set TCMT=$$^MSG(5816,CID)
		if ORIGTRB=1 do TSDR(.tsrenew)
		if ORIGTRB'=1 do TSCR(.tsrenew)
		}

	new racntype
	type RecordPRODCTL racntype=Db.getRecord("PRODCTL","tacn.type")

	set EXCH=0
	#if CUVAR.%MCP do CRCD(.tacn,.dep) 
	
	if '$D(TC(tacn.type)) do INI(.prodctl)
 
	if $$TRB^UTRB(XCID)=$$TRB^UTRB(CID) set ETC=racntype.crtrgp
	else  set ETC=racntype.drtrgp
 
	set TCMT="TFR-"_SVCID
	if 'dep.rpaseq set TSO="TFR#"_SVCID
	else  set TSO=$$RPATSO("IRAC",dep.ira,25,IRAPO)	// Use Tfr In TSO (25)
 
	set CCODE=tacn.ccode				
	do CRTTX(.tsrenew,ETC,TAMT,CID,TSO,TCMT) if ER quit
	set tseq=$O(TTXPTR(""),-1)\1+1			
	set TTXPTR(tseq)=x

	set tsseq=""
	type RecordTTX ttx()
	for  set tsseq=$O(TTXPTR(tsseq)) quit:tsseq=""  do {
		type RecordTTX tsx
		set tsx=tsrenew.getTran(TTXPTR(tsseq))
		set ttx(tsseq)=tsx.copy()
		}

	if EXCH do CURXFR^TTXBLD(.ttx(),.TTXPTR)	

	set CID=XCID
	do FILE(.dep)
	if $G(PRENA)>0 do dep3(.dep,.prenew)
	quit
 
dep3(RecordDEP dep,TranSet tsrenew)	// Automatically Renew
 
 	// Construct ETC to "@RO"_GRP - MRR
	
	set ETC="@RO"_dep.grp
 
 	// ROLLOVER
 
	set TAMT="",TCMT=$$^MSG(7132)

        if dep.ero,INT set IPND=INT-BWA set TSO="IPND#"_IPND    
  	else  set TSO=""

	do CRTTX(.tsrenew,ETC,TAMT,CID,TSO,TCMT) if ER quit
	quit
 
dep5(RecordDEP dep,TranSet tsrenew)	// No action, no accrual

	do dep.setAuditFlag(1)	 
	
	set dep.ircb=0	
	do dep.save()
	
	quit

dep6(RecordDEP dep,TranSet tsrenew,RecordPRODCTL depprod)

	// Pledged account maturity

	new LNCID,LOANBAL,DEPBAL,TAMT,TCMT,DPABAL,DPACID,XTAMT,LOANLEFT
	new DEPCID,CID,ETC,TSO,PAYOFF

	set DEPCID=dep.cid,CID=DEPCID

	// invalid pledged account
	if 'dep.pldg set ET=$$^MSG(3524) do EXC,FILE(.dep) quit

	set LNCID=$$LOANCIDP^LNPTDPW      // get CID of associated loan

	// account does not exist
	if LNCID="" set ET=$$^MSG(7617,"",TCMT) do EXC,FILE(.dep) quit

	new ln
	type RecordLN ln=Db.getRecord("LN","LNCID")

	// get the loan payoff amount in loan's currency
	set PAYOFF=$$PAYOFF^LNPTDPW(.ln)
	set LOANBAL=PAYOFF

	do CAMT^CRCDUTL(ln.crcd,dep.crcd,.LOANBAL)  // convert to deposit crcd
	set LOANBAL=$$^SCARND(LOANBAL,,DEPCID)

	set DEPBAL=dep.bal+INT+INTADJ-BWA-NINT-NINTADJ+CUMINT
	set DEPBAL=$$^SCARND(DEPBAL,,DEPCID)

	new depprod
	type RecordPRODCTL depprod=Db.getRecord("PRODCTL","dep.type")
	if '$D(TC(dep.type)) do INI(.depprod)

	new lnprod
	type RecordPRODCTL lnprod=Db.getRecord("PRODCTL","ln.type")
	if '$D(TC(ln.type)) do INI(.lnprod)

	set TCMT=$$^MSG(3013) // Pledged account maturity processing

	if LOANBAL'>DEPBAL do { quit
		// payoff loan from pledged account
		set ETC=""
		if LOANBAL=DEPBAL set ETC=depprod.drtrci    //Closeout tran code
		if ETC="" set ETC=depprod.drtrgp

		set CRCD=dep.crcd
		do CRTTX(.tsrenew,ETC,LOANBAL,DEPCID,"",TCMT) if ER quit

 		//Tfr account ~p1 closed
		if ln.stat=4 set TCMT=$$^MSG(5816,LNCID),TAMT=LOANBAL do TSCR(.tsrenew) quit
 
		set ETC=lnprod.crtrci     // closeout trancode
		if ETC="" set ETC=lnprod.crtrgp
		set TSO="TFR#"_DEPCID
 
		set CRCD=ln.crcd
		do CRTTX(.tsrenew,ETC,PAYOFF,LNCID,TSO,TCMT) if ER quit

		set CRCD=dep.crcd
		if LOANBAL=DEPBAL do FILE(.dep) quit
		do dep3(.dep,.tsrenew)
		}

	// not enough to payoff loan

	set ETC=""
	
	// how much of the loan will our deposit account pay ??
	set XTAMT=DEPBAL
	do CAMT^CRCDUTL(dep.crcd,ln.crcd,.XTAMT)
	set XTAMT=$$^SCARND(XTAMT,,LNCID)

	new dpa
	set DPACID=ln.dpa    // see if we have a deposit payoff account
	Type RecordDEP dpa
	
	if DPACID="" set DPABAL=0
	else  do {
		set dpa=Db.getRecord("DEP","DPACID")
		if dpa.stat=4 set DPABAL=0,DPACID="" quit  // dpa is closed
		set DPABAL=dpa.bal
		set LOANLEFT=(PAYOFF-XTAMT)
		do CAMT^CRCDUTL(ln.crcd,dpa.crcd,.LOANLEFT)
		set LOANLEFT=$$^SCARND(LOANLEFT,,DPACID)
		if DPABAL>LOANLEFT set ETC=depprod.drtrci  //Closeout tran code
		}

	if ETC="" set ETC=depprod.drtrgp

	set CRCD=dep.crcd
	do CRTTX(.tsrenew,ETC,DEPBAL,DEPCID,"",TCMT) if ER quit

 	//Tfr account ~p1 closed
	if ln.stat=4 set TCMT=$$^MSG(5816,LNCID),TAMT=DEPBAL do TSCR(.tsrenew) quit
 
	set ETC=lnprod.crtrgp
	set TSO="TFR#"_DEPCID
 
	set CRCD=ln.crcd
	do CRTTX(.tsrenew,ETC,XTAMT,LNCID,TSO,TCMT) if ER quit
	set CRCD=dep.crcd

	if DPACID="" do { quit     // no deposit payoff account - oh dear !
		set dep.mdt=%SystemDate+1   // set dep to mature again
		set ET=$$^MSG(2992,ln.crcd_" "_(PAYOFF-XTAMT))
		do EXC,FILE(.dep)
		}

	new dpaprod
	type RecordPRODCTL dpaprod=Db.getRecord("PRODCTL","dpa.type")

	if '$D(TC(dpa.type)) do INI(.dpaprod)

	if LOANLEFT'>DPABAL do { quit    // we can pay the rest from DPA

		set ETC=dpaprod.drtrgp
		set CRCD=dpa.crcd
		do CRTTX(.tsrenew,ETC,LOANLEFT,DPACID,"",TCMT) if ER quit

		set ETC=lnprod.crtrci       // loan payoff code
		if ETC="" set ETC=lnprod.crtrgp
		set TSO="TFR#"_DPACID
		set CRCD=ln.crcd
		do CRTTX(.tsrenew,ETC,PAYOFF-XTAMT,LNCID,TSO,TCMT) if ER quit
		set CRCD=dep.crcd
		do FILE(.dep)
		}

	set ETC=dpaprod.drtrgp

	set CRCD=dpa.crcd
	do CRTTX(.tsrenew,ETC,DPABAL,DPACID,"",TCMT) if ER quit

	set ETC=lnprod.crtrgp       // loan payment code
	set TSO="TFR#"_DPACID

	// convert amount
	do CAMT^CRCDUTL(dpa.crcd,ln.crcd,.DPABAL)
	set DPABAL=$$^SCARND(DPABAL,,LNCID)

	set CRCD=ln.crcd
	do CRTTX(.tsrenew,ETC,DPABAL,LNCID,TSO,TCMT) if ER quit

	set dep.mdt=%SystemDate+1   // set dep to mature again

	set CRCD=dep.crcd
	set XTAMT=PAYOFF-XTAMT-DPABAL
	
	set ET=$$^MSG(2992,ln.crcd_" "_XTAMT)
	do EXC,FILE(.dep)

	quit


DWA(RecordDEP dep,TAMT) // Determine Distribution Withholding Amt for Retirement account

	type Number ACN,X,STTAX
 
	set X=TAMT
	set ACN=dep.acn

	for STTAX=0:1:1 do CLOSE^IRAWH(.dep)

	if $G(DWA) set TAMT=TAMT-DWA
	if $G(DSWA) set TAMT=TAMT-DSWA

	quit
  

GL(RecordDEP dep,TranSet ts,LIT)	// Update GL array
 
	new BCHID,CC,CRCD,GLSC,JOB,TYPE
	set BCHID="BCHROLL"
	set JOB=%ProcessID
	set CRCD=dep.crcd
	set TYPE=dep.type
	set GLSC=dep.glsc
	set CC=dep.cc

	type RecordTMPBCHOFF tbchoff=Db.getRecord("TMPBCHOFF","TJD,BCHID,JOB,LIT,CRCD,TYPE,GLSC,CC",1)

	if tbchoff.getMode()=0 do BDOFFSET^BCHSOURC("BCHROLL",LIT,dep.crcd,dep.type,dep.glsc,dep.cc,GLACN,GLACN,"MDR",GLTRN,TCMT)

	do UPOFFSET^BCHSOURC("BCHROLL",LIT,dep.crcd,dep.type,dep.glsc,dep.cc,1,TAMT)
 
	quit



XPDO(RecordDEP dep)	// Set XPDO file to print checks

	set CKSEQ=Db.nextVal("XPDO","TJD,CKTYP")

	new xpdo
	type RecordXPDO xpdo=Class.new("RecordXPDO")

	set xpdo.tjd=TJD
	set xpdo.cktyp=CKTYP
	set xpdo.ckseq=CKSEQ
	set xpdo.brcd=BRCD
	set xpdo.uid=%UserID
	set xpdo.cid=SVCID
	set xpdo.tamt=TAMT
	set xpdo.efd=$S(dep.pmedat>%SystemDate:dep.pmedat,1:%SystemDate)
	if dep.rpaseq set xpdo.tso=IRAPO		

	do xpdo.save()
	quit
 
ACR(RecordDEP dep,TranSet ts,RecordPRODCTL prodctl)	// Accrual Section

	set (AWTI,BWA,IRN,NTAX,RATE)=0
 
	/*
	We do not want to calculate the backup withholding amount now for
	RPA accounts.  It will be done in ^DEPPO when the funds are
	transfered for an RPA account.
	*/
 
	/*
	Routine ^DEPBW is called if Backup Withholding (DEP.BWF) is selected
	and Accrued Withholding Tax Processing (DEP.AWTP) is not selected. The
	additional check on RPA Type (DEP.IRA) before calling this routine that
	existed has been removed and replaced with a check if INT>0
	because withholding tax can only be calculated on positive interest
	amounts, regardless of DEP.IRA.
	The returned backup withholding amount (DEP.BWA) from ^DEPBW is rounded
	to two decimal places. 
	If DEP.BWF is selected and DEP.AWTP is also selected, BWA (variable
	containing backup withholding amount) will be set to Accrued
	Withholding Tax (DEP.AWT).
	*/
	if INTAMT set BWA=WTHAMT
	else  if dep.bwf,INT>0 do {
		if dep.awtp set BWA=dep.awt
		else  do {

			type RecordTTX ttx
			set ttx=ts.getTran(1)
			do ^DEPBW(.dep,.ttx,.INT,.BWA,.NTAX,BWAPGM,AWTI,IRN,.TAXRATE)

			set BWA=$$^SCARND(BWA,0,CID)

			if dep.awtr'=TAXRATE do {
				do FMHTRN^BCHINTPS("DEP","AWTR",dep.awtr,TAXRATE,%SystemDate,"")
				set dep.awtr=TAXRATE
				}
			}
		}

 
	if INT do { if ER quit
 
		new TAMT
		set TAMT=INT
		
		set TSO=$$FIELDIN^UTSO(TSO,"EXACTACR",dep.acr)
		
		/*
		Set backup withholding amount to piece 5 of TAMT where piece
		5 of TAMT represents TTX.WHLD (Tran Detail:D:W/H L:Und Prl)
		*/
		if dep.iaf=2 set $P(TAMT,"#",8)=TAMT-BWA       ; Int/Div Available Not Credited
                else  if BWA do { quit:ER
			set $P(TAMT,"#",2)=TAMT-BWA            ; Principal
             		set $P(TAMT,"#",5)=BWA
			}

		// DR Adj Accrued Interest Tran Code
  
		do CRTTX(.ts,prodctl.dradin,TAMT,CID,TSO,"") if ER quit
 
		if 'dep.rpaseq do {
			set TSO="INT#"
			set TSO=$$FIELDIN^UTSO(TSO,"EXACTACR",dep.acr)
			}
		else  set TSO=$$RPATSO("IRAC",dep.ira,0,IRAINT) // IRA int credit TSO
 
		// CR Interest Tran Code
 
		do CRTTX(.ts,prodctl.crtrin,INT,CID,TSO,"",INT-BWA,INT-BWA) if ER quit	
	 	}
 
	if NINT do { if ER quit
		// DR Adj Neg Accrued Interest Tran Code
 
		do CRTTX(.ts,prodctl.dradna,NINT,CID,"","") if ER quit
 
		if 'dep.rpaseq set TSO="NEGINT#"
		else  set TSO=$$RPATSO("IRAC",dep.ira,0,IRAINT)	// IRA int credit TSO
 
		// CR Adj Neg Interest Posted Tran Code
 
		do CRTTX(.ts,prodctl.cradni,NINT,CID,TSO,"") if ER quit
		}

	
	if dep.cumdep do CUMDEP(INT,.dep,.ts,.prodctl) quit:ER 

	set ACR=$G(INT)
	set NACR=$G(NINT)
	set INTANC=dep.intavlncr+ACR-NACR       // Interest Avail Not Credited  

	/*
	Removed coding related to backup withholding and negative tax as
	will be handled by DEPINT when interest posts
	*/
 
	if dep.ero quit
	set TAMT=INT-BWA-NTAX+dep.intchkbkt
	if '$$^SCARND(TAMT,0,$G(CID)) set (INT,BWA,NTAX)=0 quit
 
	if dep.imo=1!(dep.imo=3),(dep.rencd-1) do { quit
		do INTCHK(.dep,.ts,.prodctl)
		set (INT,BWA,NTAX,INTAVLNCR)=0
		}
 
	if dep.imo=2 do { if ER quit
		do INTTFR(.dep,.ts,.prodctl)
		set CID=SVCID
		set (INT,BWA,NTAX,INTAVLNCR)=0
		}
	
	if dep.imo=4 do { quit
		do INTAVL(.dep,.ts,.prodctl)
		do EFTBUILD(1,INT,.dep,.ts)
		set (INT,BWA,NTAX,INTAVLNCR)=0
		if ER quit
		}

	if (dep.imo=5) do { quit
		do INTAVL(.dep,.ts,.prodctl)
		set (INT,BWA,NTAX)=0
		if ER quit
		}
	quit

CUMDEP(INT,RecordDEP dep,TranSet ts,RecordPRODCTL prodctl)
 
	// Calculate the Cumulative Interest
 
	new TCMT
 
	set CUMINT=$$CALC^UACRIND(dep.schdepf,dep.icf,dep.irn,dep.schdepa,dep.odt,dep.schdepn)
	set CUMINT=$$^SCARND(CUMINT,0,CID) quit:ER
 
	set CUMINT=CUMINT-(INT+dep.ipl)
 
	if CUMINT do { quit:ER
		do POSINT(CUMINT,.dep,.ts,.prodctl) quit:ER
		do EXPENSE(CUMINT,.dep,.ts) quit:ER
		}
 
	quit


POSINT(ADJ,RecordDEP dep,TranSet ts,RecordPRODCTL prodctl)
 
	new TAMT,TCMT,etc
 
	if ADJ<0 set etc=prodctl.drtrin,TAMT=-ADJ   // DR Pos. Interest Paid TC
	else  set etc=prodctl.crtrin,TAMT=ADJ       // CR Interest Paid TC
 
	set TCMT=$$^MSG(4681)                // Cumulative interest posting adj

	if 'dep.rpaseq set TSO="INT#"
	else  set TSO=$$RPATSO("IRAC",dep.ira,0,IRAINT)   // IRA int credit TSO
 
	do CRTTX(.ts,etc,TAMT,CID,TSO,TCMT) quit:ER
 
	quit

EXPENSE(ADJ,RecordDEP dep,TranSet ts)
 
	// Offset interest or accrual adjustments
 
	new etc,CID,TAMT
 
	set CID=$P(GLSC(GLSC),"|",2)                    
	
	// Invalid bank number.  No G/L number found.
	if CID="" set ER=1,RM=$$^MSG(1270) quit
 
	if 'dep.trb do {
		if ADJ<0 set etc="MCR",TAMT=-ADJ        // Misc Credit
		else  set etc="MDR",TAMT=ADJ            // Misc Debit
		}
	else  do {
		if ADJ<0 set etc="MDR",TAMT=-ADJ        // Misc Debit
		else  set etc="MCR",TAMT=ADJ            // Misc Credit
		}
 
	do CRTTX(.ts,etc,TAMT,CID,"","") quit:ER
 
	quit

INTCHK(RecordDEP dep,TranSet ts,RecordPRODCTL prodctl)	// Pay Only Interest by Check 
	new GLACN,GLTRN					
	set GLACN=GLINT					// Use Interest GL
	set GLTRN=GLINTTRN				

	set CKTYP=prodctl.ckint

	if CKTYP="" set CKTYP=$P(TC(TYPE,10),"|",1)     

	set TCMT="PDO"
	set TAMT=TAMT+INTAVLNCR
	set CKSEQ=""
	if 'CHKAMT do XPDO(.dep)			
 
	set ETC=prodctl.drtrip					// DR Interest Payout Tran Code
	if ETC="" set ETC=prodctl.drtrgp		        // DR General Purpose Tran Code
 
	set XPDOKY=%SystemDate_"*"_CKTYP_"*"_CKSEQ
	do CRTTX(.ts,ETC,TAMT,CID,"",TCMT,XPDOKY) if ER quit
	do GL(.dep,.ts,"int") if ER quit		
	quit
 
INTTFR(RecordDEP dep,TranSet ts,RecordPRODCTL prodctl)	// Transfer Interest
 
	new ETC,TACN,TCMT,TTXPTR,tseq,CCODE		
	set ETC=prodctl.drtrit				// DR Interest Transfer Tran Code
	if ETC="" set ETC=prodctl.drtrgp		// DR General Purpose Tran Code

	set TACN=dep.intmatita
	set CCODE=dep.ccode				
	set TCMT="TFR-"_TACN
	if 'dep.rpaseq set TSO=""
	else  set TSO=$$RPATSO("IRAD",dep.ira,21,IRAPO)	// Use Paid Out TSO (21)
 
	set TAMT=TAMT+INTAVLNCR

	do CRTTX(.ts,ETC,TAMT,CID,TSO,TCMT) if ER quit
	set tseq=1
	set TTXPTR(tseq)=x

	set CID=TACN
 
	new tacn
	type RecordACN tacn=Db.getRecord("ACN","TACN",1)

	// Invalid account
	if tacn.getMode()=0 set TCMT=$$^MSG(1259) do TSCR(.ts) quit

 	// Account closed
	if tacn.stat=4 set TCMT=$$^MSG(55) do TSCR(.ts) quit

	set EXCH=0
	#if CUVAR.%MCP do CRCD(.tacn,.dep)
	
	if '$D(TC(tacn.type)) do INI(.prodctl)

	new iprodctl
	type RecordPRODCTL iprodctl=Db.getRecord("PRODCTL","tacn.type")
 
	if $$TRB^UTRB(SVCID)=$$TRB^UTRB(CID) do {
		set ETC=iprodctl.crtrit
		if ETC="" set ETC=iprodctl.crtrgp
		}
 
	else  do {
		set ETC=iprodctl.drtrit
		if ETC="" set ETC=iprodctl.drtrgp
		} 
	if 'dep.rpaseq set TSO="TFR#"_SVCID
	else  set TSO=$$RPATSO("IRAC",dep.ira,23,"")	// Use IRA Int P/I TSO (23)
	set TCMT="TFR-"_SVCID
	set CCODE=tacn.ccode				
 
	do CRTTX(.ts,ETC,TAMT,CID,TSO,TCMT) if ER quit
	set tseq=$O(TTXPTR(""),-1)\1+1			
	set TTXPTR(tseq)=x

	set tsseq=""
	type RecordTTX ttx()
	for  set tsseq=$O(TTXPTR(tsseq)) quit:tsseq=""  do {
		type RecordTTX tsx
		set tsx=ts.getTran(TTXPTR(tsseq))
		set ttx(tsseq)=tsx.copy()
		}

	if EXCH do CURXFR^TTXBLD(.ttx(),.TTXPTR)		

	quit

EFTBUILD(PRININT,TAMT,RecordDEP dep,TranSet tsrenew)    // Create Outgoing
							// Payment Order
	// PRININT - 0 = principal, 1 = interest 
	if (dep.primatetc=dep.intmatetc)&(dep.primatets=dep.intmatets)&(PRININT=1)&(RENCD=4) set SAVINT=SAVINT+INTAVLNCR quit
	if (dep.primatetc=dep.intmatetc)&(dep.primatets=dep.intmatets)&(IMO=4)&(RENCD=4) set TAMT=TAMT+SAVINT
	
	if PRININT=1 do {
		set EXTACN=dep.intmatetc,EXTSEQ=dep.intmatets
		if EXTACN="" set EXTACN=dep.intdisetc
		if EXTSEQ="" set EXTSEQ=dep.intdisets
			}
	if PRININT=0 do {
		set EXTACN=dep.primatetc,EXTSEQ=dep.primatets
		if EXTACN="" set EXTACN=$S(dep.intmatetc'="":dep.intmatetc,1:dep.intdisetc)
		if EXTSEQ="" set EXTSEQ=$S(dep.intmatets'="":dep.intmatets,1:dep.intdisets)
		}
	new cifext
	type RecordCIFEXT cifext=Db.getRecord("CIFEXT","EXTACN,EXTSEQ")
 	set RCID=cifext.extacct
	set RINS=cifext.extinst
	set CRCD=dep.CRCD
	if ($G(PRENA)>0)&(PRININT=0) set TAMT=TAMT-PRENA
	if dep.imo=5 set PRENA=PRENA+INTANC
	if dep.imo'=5 set TAMT=TAMT+INTAVLNCR

	do ^EFTBUILD(dep.cid,,RCID,RINS,TAMT,CRCD,TJD,,"PO",0)
	if ($G(PRENA)>0)&(PRININT=0) do dep3(.dep,.tsrenew)
	quit 

INTAVL(RecordDEP dep,TranSet ts,RecordPRODCTL prodctl)
	// Get interest available not credited.
 	
	set ETC=prodctl.drtrin		   // DR Back office Tran Code
	if ETC="" set ETC=prodctl.drtrgp	// DR General Purpose Tran Code
 	
	do CRTTX(.ts,ETC,INTANC,CID,"","") if ER quit
	set ETC=prodctl.crtrgp		      // CR General Purpose Tran Code
	do CRTTX(.ts,ETC,INTANC,CID,"","") if ER quit   // offset tran
 
	quit
 
CRTTX(TranSet ts,ETC,TAMT,CID,TSO,TCMT,XPDKY,IPND)	// Create TTX global
 
	/*
 
 	ETC  -   External Transaction Code.
 	TAMT  -   Transaction Amount.
 	CID   -   Customer Id.
 	TSO   -   Transaction Source.
 	TCMT  -   Teller Comment.
 	XPDKY -   Keys to ^XPDKY (OPTIONAL: used for TTX Reversals)
 	IPND  -   Interest paid, not disbursed, for piece 16 to pass
  		  to DEPARO
 
 	With these parameters it will create a TTX record for TRNDRV to post.
 	*/
 
	new trn 
	type RecordTRN trn
	set trn=Db.getRecord("TRN","ETC")
	set ITC=trn.itc
	if TSO["INT#" set ITC=$$ITC^TTXEXT(ITC,4)	     

	new ttx
	type RecordTTX ttx=Class.new("RecordTTX")
 
	set ttx.cid=CID
	set ttx.itc=ITC
	set ttx.etc=ETC
	set ttx.tamt=TAMT
	set ttx.efd=EFD
	set ttx.tlo=%UserStation
	set ttx.tso=TSO
	set ttx.tcmt=TCMT
	set ttx.crcd=CRCD
	set ttx.custcd=$g(CCODE)			
	set ttx.xpdo=$g(XPDKY)
	set ttx.lnerc=$g(IPND)				
	set ttx.cc=$g(CC)                               
	
	set x=ts.copyTran(ttx)

	quit
 
CHKAMT(RecordDEP dep)	// Anticipated check amount error (principal and/or interest)
 
 	// Validate pay by check
 
	//wvb - 41132
	if dep.rencd=1 S:$P(CHKAMT,"#",2)-dep.bal ER=1 quit  
 
 	// All other RENCDs
 
	if dep.iopt'=1,dep.iopt'=3 set ER=1 quit
	if $P(CHKAMT,"#",2) set ER=1 quit
	quit
 
TSCR(TranSet ts)	// Transaction suspense (credit)
 
	set ET=TCMT do EXC
 
	do CRTTX(.ts,"TSCR",TAMT,TSCRCID,"TRF#"_CID,TCMT) if ER quit
	quit

TSDR(TranSet ts)	// Transaction suspense (debit)		
 
	set ET=TCMT do EXC
 
	do CRTTX(.ts,"TSDR",TAMT,TSCRCID,"TRF#"_CID,TCMT) if ER quit
	quit

CRCD(RecordACN tacn,RecordDEP dep)	// Flag transfer between currencies
 
	if tacn.crcd=dep.crcd set EXCH=0
	else  set EXCH=1 
	quit
 
FILE(RecordDEP dep)	// Update Maturity Last Date and Rate Last Maturity

	do dep.setAuditFlag(1)			// keep track of changes  

	set dep.penpw=""
	set dep.mld=%SystemDate
	set dep.irlm=dep.irn
 
	do dep.save()
	quit
 
RPATSO(TSOTYPE,RPA,PIECE,DFT)   // Determine TSO contribution/distribution codes
 
 	/*
	Parameters:
 	TSOTYPE	= "IRAD" or "IRAC"
 	RPA	= Retirement Plan Account type
 	PIECE	= UTBL("RSPDEF" piece
 	DFT	= Default from CUVAR
 	*/
 
	type Public RecordUTBLRSPDEF utblrpf()
	type Number IRACD
	type String TSO
 
	set DFT=TSOTYPE_"#"_DFT
 
	// Drop back to default
	if 'PIECE quit DFT

	// Table problem
	if 'utblrpf(RPA).getPointer() quit DFT
	
	if PIECE=21 set IRACD=utblrpf(RPA).iraipo
	if PIECE=23 set IRACD=utblrpf(RPA).iraipi
	if PIECE=24 set IRACD=utblrpf(RPA).iraclto
	if PIECE=25 set IRACD=utblrpf(RPA).iraclti

	// Drop back to default
	if IRACD.isNull() quit DFT
                	 
	// Reason codes
	set TSO=TSOTYPE_"#"_IRACD

	// IRA reason code
	quit TSO
 
 
INI(RecordPRODCTL prodctl)      //
 
	set TC(TYPE,10)=prodctl.ckint_"|"_prodctl.ckmdt
	for I=1,2 do CHKTYP
 
	quit
 
CHKTYP  // Load check type (8=interest 9=maturity default="STND")
 
	set X=$P(TC(TYPE,10),"|",I)
	if X="" set X="STND",$P(TC(TYPE,10),"|",I)=X
 
	quit 


ROLL1(RecordLN ln,TranSet ts)	// Maturity Transfer Processing - Loans
 
	new %TRN,TCMT,TSO,TYPE,RENCD,TAMT,ITC,TRACN,PAYOFF,XLN09,CRCD

	if ln.mdt>%SystemDate quit		// maturity date in the future
  
	if "1,2,3"'[$E(ln.rencd) quit
	if ln.stat=4 quit			   // closed account
	set RENCD=ln.rencd			  // initialize RENCD  
	set TYPE=ln.type			

	if 'ln.tracn quit			// no transfer account
	set TRACN=ln.tracn
	set BAL=ln.bal
 
	if RENCD=1 do LN1(.ln,.ts) quit
	if RENCD=2 do LN2(.ln,.ts) quit
	if RENCD=3 do LN3(.ln,.ts) quit
	if RENCD="1C" do LNC1(.ln,.ts) quit
	if RENCD="2C" do LNC2(.ln,.ts) quit
	if RENCD="3C" do LNC3(.ln,.ts) quit
	quit
 
LN1(RecordLN ln,TranSet ts)	// Option 1 - Payoff account 1 with funds from account 2
 
	set EFD=TJD
 
	type RecordTTX ttx
	set ttx=ts.getTran(1)
	do PAYOFF^LNPO2(.ln,0,.ttx)

	set TAMT=PAYOFF,EFD=""
 
	if (ln.iam),'TAMT do TR(.ln,.ts,CID,TYPE,1,2,"")
 
	do TR(.ln,.ts,CID,TYPE,1,2,"TFR-"_TRACN) if 'ER do OS(.ln,.ts,7,12)
	quit
 
LN2(RecordLN ln,TranSet ts)	// Option 2 - Satisfy principal balance with funds from account 2
 
	set TAMT=$$BALCMP^LNCDI(ln.aruf,ln.bal,ln.udbal) if 'TAMT quit
 
	do TR(.ln,.ts,CID,TYPE,3,4,"TFR-"_TRACN) if 'ER do OS(.ln,.ts,8,12)
	quit
	
LN3(RecordLN ln,TranSet ts)	// Option 3 - Satisfy principal, adjust accrued interest
 
	set TAMT=$$^SCARND(ln.acr,0,CID)
	if TAMT do TR(.ln,.ts,CID,TYPE,5,5,"TFR - "_TRACN) if 'ER do OS(.ln,.ts,9,11)

	do LN2(.ln,.ts)

	set ln.bal=0
	set ln.acr=0
	do LN1(.ln,.ts)
	quit
 
LNC1(RecordLN ln,TranSet ts)	// Option 1C - Intra-commitment transfer (payoff)
 
	do LNC2(.ln,.ts) if ER quit
	set ln.bal=0
	do LN1(.ln,.ts)
	quit
 
LNC2(RecordLN ln,TranSet ts)	// Option 2C - Intra-commitment transfer (principal only)

	/*
	For credit limit transfers, the credit limit is transferred in the
	amount of the principal transfer. The transaction codes are ln.crtrct
	and ln.drtrct. For example, for commercial loans tied to a commercial
	commitment, these codes are CMCTO and CMCTI.
	*/

	set TAMT=ln.bal if 'TAMT quit

	//MCA 7/25/01: Changed tran codes to ln.crtrct and ln.drtrct.
	do TR(.ln,.ts,CID,TYPE,15,15,"TFR-"_TRACN) if 'ER do OS(.ln,.ts,16,16)
	quit
 
LNC3(RecordLN ln,TranSet ts)	// Option 3C - Satisfy principal, adjust interest, transfer credit limit
 
	do LNC2(.ln) if ER quit
	set TAMT=$$^SCARND(ln.acr,0,CID)
	if TAMT do TR(.ln,.ts,CID,TYPE,5,5,"TFR - "_TRACN) if 'ER do OS(.ln,.ts,9,11)

	set ln.bal=0
	set ln.acr=0
	do LN1(.ln,.ts)
	quit

OS(RecordLN ln,TranSet ts,PC1,PC2)      // Offset debit transaction
 
	new acn
	type RecordACN acn
	set acn=Db.getRecord("ACN","CID=:TRACN")
 
	do TR(.ln,.ts,TRACN,acn.type,PC1,PC2,"TFR-"_CID)
 
	quit 

TR(RecordLN ln,TranSet ts,CID,TYP,PC1,PC2,TCT)	// Build transaction
 
 	/*
	CID = Account
	TYP = Product type

	PC1, PC2 are numeric, representing the position within the record 
	returned by SQL of the required field. If this tag is called for
	new data items, the new data item should be appended to the list
	of data items being requested.

	TCT = Transaction comment
 	*/
 
	new rs
	type ResultSet rs

	//MCA 7/25/01: Added columns CRTRCT and DRTRCT
	set rs=Db.select("CRTACN1,CRTRCI,CRTACN2,CRTRPR,CRADIN,CRTRRL,DRTACN1,DRTACN2,DRADIN,DRTRRL,DRADPR,DRTRGP,CRTRGP,DRTRIN,CRTRCT,DRTRCT","PRODCTL","TYPE=:TYP")
	if rs.next()
	set rs1=rs.getCol(1)_"|"_rs.getCol(2)_"|"_rs.getCol(3)_"|"_rs.getCol(4)
	set rs2=rs.getCol(5)_"|"_rs.getCol(6)_"|"_rs.getCol(7)_"|"_rs.getCol(8)
	set rs3=rs.getCol(9)_"|"_rs.getCol(10)_"|"_rs.getCol(11)_"|"_rs.getCol(12)_"|"_rs.getCol(13)_"|"_rs.getCol(14)
	set rs4=rs.getCol(15)_"|"_rs.getCol(16)         

	set PRODCTL(TYP)=rs1_"|"_rs2_"|"_rs3_"|"_rs4    
 
	set ETC=$P(PRODCTL(TYP),"|",PC1)
	if ETC="" set ETC=$P(PRODCTL(TYP),"|",PC2)

	new trn
	type RecordTRN trn=Db.getRecord("TRN","ETC")

	// Internal Transaction Code
	set ITC=trn.itc

	new ttx,x

	type RecordTTX ttx=Class.new("RecordTTX")

	set ttx.cid=CID
	set ttx.itc=ITC
	set ttx.etc=ETC
	set ttx.tamt=TAMT
	set ttx.efd=EFD
	set ttx.tlo=%UserStation
	set ttx.tso=$G(TSO)		
	set ttx.tcmt=$G(TCT)
	set ttx.crcd=ln.crcd

	set x=ts.copyTran(ttx)

	quit


EXC	// Log errors into the standard exception file
  
	if $D(ITS) quit
 
	if $G(ET)="" set ET=$G(RM)
 
 	// Automatic Rollovers
	do LOG^UTLEXC($T(+0),"*",$$^MSG(4676),$G(CID),$G(%ZTSEQ),$G(ET),$S($G(CID):$G(BAL),1:""))
	kill ET,%ZTSEQ
	quit
 
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
 type String vRECORD,CID
 for  set vRECORD=vINPUT.piece("|",1),vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD.isNull()  do {
 set CID=vRECORD.piece($C(9),1)
 do vPROC(CID)
 }
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
 type public String vBUFOVFL
 type String vRECORD,vrow,CID
 type Number vcur,vlen
 set vINPUT=vBUFOVFL.get()
 set vBUFOVFL="",vlen=0
 type public ResultSet vRESULT
 for  do { quit:'vcur
 set vcur=vRESULT.next() if 'vcur quit
 set vrow=vRESULT.getRow()_"|",vlen=vlen+vrow.length()
 if vlen>32767 set vBUFOVFL=vrow,vcur=0 quit
 set vINPUT=vINPUT_vrow if vlen+13>32767 set vcur=0 quit
 }
 set vINPUT=vINPUT.extract(1,vINPUT.length()-1)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	set XTJD=%SystemDate

 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("CID","ACN","ACN.MDT=:XTJD")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	type Public RecordUTBLRSPDEF utblrpf()
	do INITVAR
 
	set TPD=%SystemDate
 
	// Initialize Source, User ID, Userclass, and GL accounts.
	do SOURCE^BCHSOURC("ROLL","ROLL",.%UserID,.BRCD,.%UserClass,.TSDRCID,.TSCRCID)

	type ResultSet rs=Db.select("KEY","UTBLRSPDEF")
	while rs.next() do {
		set RPA=rs.getCol("KEY")
		set utblrpf(RPA)=Db.getRecord("UTBLRSPDEF","RPA")
		}


	quit


INITVAR //

	new cuvar
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

 	// IRA Interest Reason Code
	set IRAINT=cuvar.iraint

	// Rollover Payout G/L Offset Account
	set GLACN=cuvar.rlcid

	// Interest Payout G/L Offset Account
	set GLINT=cuvar.ipcid

	// Rollover Payout G/L Offset Tran Code
	set GLTRN=cuvar.rletc

	// Interest Payout G/L Offset Tran Code
	set GLINTTRN=cuvar.ipetc

	// Custom Interest Witholding Routine
	set BWAPGM=cuvar.bwapgm
 
	set (EFD,TCMT,TSO)=""
	kill ETC,GL,MAXADJ,TC
 
	quit

 
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
	if $D(ITS) quit
	set ER=0
 
	do SOURCE^BCHSOURC("ROLL","ROLL",.%UserID,.BRCD,.%UserClass,.TSDRCID,.TSCRCID)
	if ER quit
 
	do ^TTXLOK

	quit
 
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
	do OFFSET^TTXBLD(%SystemDate,BRCD,%UserID,"BCHROLL")
 
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
