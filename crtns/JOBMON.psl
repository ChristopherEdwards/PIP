JOBMON
 	/*
 	 PROCEDURE ID:	JOBMON
 	     Original:	ZENGF
		 Date:	11/16/95
 	         Desc:	Job Monitor Data APIs
 
 	---- Comments --------------------------------------------------------
 
 	This routine provides a library of standard PROFILE application
	programming interface (API) calls to be used for the Job Monitor.

	It also implements a job monitor displaying three types of
	information about batch jobs that use the monitor facility:
	. Jobs that have abnormally terminated
	. Status of each currently active job
	. Completed jobs, by time of completion, for the last 24 hours

	KEYWORDS: Monitor

	LIBRARY:

	. $$INIT^JOBMON  - Initialize Job Monitor Data Record
	. UPDATE^JOBMON  - Update Job Monitor Data Record
	. CLOSE^JOBMON  - Close  Job Monitor Data Record
		
 	---- Revision History ------------------------------------------------

	03/14/07 - KumarSS - CR 25177
		   Removed Invalid Unicode Characters.

 	07/21/06 - VanithaK - CR22163
 		   Modified the call VLOD^@pgm in exec section to the runtime
 		   program to execute the screens JOBMON and JOBMON1 to avoid
 		   the PSL compiler error. Modified to eliminate PSL compiler
 		   warnings. Modified CLOSE section to use classNew parameter
 		   with getRecord method. 
 		   
 	06/16/05 - RussellDS - CR16320
 		   Fix invalid reference to getRow that generates PSL error.
 		   
 		   Minor code clean-up to reduce warnings.
 	
 	01/06/05 - RussellDS - CR13817
 		   Set %REPEAT=9 to deal with change in screens JOBMON and
 		   JOBMON1 to go to two row displays.
 		   
 		   Eliminated PSL precendence warnings (but left scope warnings).
 		   
 		   Removed old revision history.

	------------------------------------------------------------------------
	*/
	quit

public	INIT(func)	// Initialize Job Monitor Data Record
	/*
	Creates a new monitor data record and returns a unique job monitor ID
	for use in subsequent calls.

	ARGUMENTS:
	. func Function ID   /TYP=T/REQ/LEN=12/MECH=VAL

	RETURNS:
	. $$ Job Monitor ID   /TYP=T

	EXAMPLE:
	S X=$$INIT^JOBMON("QUE009")
	*/

	type Number pid

	set pid=$$PID^%ZFUNC

	type RecordJOBMON jobmon=Db.getRecord("JOBMON","func,pid",1)

	set jobmon.stdate=%CurrentDate
	set jobmon.sttime=%CurrentTime
	set jobmon.recid=0

	do jobmon.bypassSave()

	quit func_$C(0)_pid


public	UPDATE(jobmonid,reccnt,recid)	// Update Job Monitor Data Record
	/*
	Updates the current status of the job monitor data of this process.

	ARGUMENTS:
		. jobmonid 	Job monitor ID returned from INIT call
			/TYP=T/REQ/MECH=VAL
		. reccnt 	Current record count for the process
			/TYP=N/REQ/LEN=9/MECH=VAL
		. recid  	Identifier of last record processed
			/TYP=T/REQ/LEN=20/MECH=VAL

	EXAMPLE:
		D UPDATE^JOBMON("QUE009_O7E0",35767,1000876)
	*/

	type Number pid
	type String func
	
	do PARSE(jobmonid,.func,.pid)
	if func=""!(pid="") quit

	type RecordJOBMON jobmon=Db.getRecord("JOBMON","func,pid",1)
	if 'jobmon.getMode() quit

	set reccnt=+$G(reccnt)
	set recid=$TR($G(recid),"|","-")

	set jobmon.lasttime=%CurrentTime
	set jobmon.reccnt=reccnt
	set jobmon.recid=$E(recid,1,20)

	do jobmon.bypassSave()

	quit


public	CLOSE(jobmonid,reccnt)	// Close  Job Monitor Data Record
	/*
	Record completion time and final record count in the job monitor data
	record.

	ARGUMENTS:
		. jobmonid 	Job monitor ID returned from INIT call
			/TYP=T/REQ/MECH=VAL
		. reccnt 	Final record count for the process
			/TYP=N/REQ/LEN=9/MECH=VAL

	EXAMPLE:
		D CLOSE^JOBMON("QUE009_O7E0",3000876)
	*/

	type Number pid
	type String func
	
	do PARSE(jobmonid,.func,.pid)
	if func=""!(pid="") quit
			
	type RecordJOBMON jobmon = Db.getRecord("JOBMON","func,pid",1)
	if 'jobmon.getMode() quit
	
	set jobmon.func = func
	set jobmon.pid = pid
		
	set reccnt=+$G(reccnt)

	set jobmon.lasttime=%CurrentTime
	set jobmon.reccnt=reccnt
	set jobmon.compdate=%CurrentDate

	do jobmon.bypassSave()

	quit


PARSE(id,fid,pid)	// Parse job monitor ID into function ID and process ID

	set id=$G(id)
	set fid=$P(id,$C(0),1)		// Function name
	set pid=$P(id,$C(0),2)		// Process ID

	quit


START	//Private; Entry point for the job monitor function

	type public Boolean ER

	type String %READ,%TAB(),freq,mnuevent,menu1,menu2,menu3,pgms,trans,scntitle,VFMQ

	set ER=0
	// Set up menu options, related events and transition table
	do initset quit:ER

	// Prompt for refresh frequency
	set %TAB("freq")=".FRE3"

	set %READ="@@%FN,,freq/REQ" 
	set freq=5
	do ^UTLREAD 
	if VFMQ="Q" quit

	// Convert to seconds
	set freq=freq*60

	// Monitor driver
	do drv

	quit


drv	//Private; Control the display of multiply screens of jobs
	/*
	A FIFO event queue is used to store events from menu input and events
	generated by another event.

	The monitor uses three states to diplay jobs in different status. Some
	events cause a state transition. Each state correponds to a job
	status.
	*/

	type String event,joball,lastrfs,pgm,prvstate,queue,sel,state,title
	// Used in compiled program
	type Number %ProcessMode,%PAGE,%PG,%MODS,%REPEAT
	type String KVAR

	// Start from "active" state
	set state="ACT"
	set %ProcessMode=2

	// Initialize event queue
	set queue=""
	// Refresh upon start
	do queadd(.queue,"RFS")

	// Process events in the queue until empty
	for  do { quit:queue=""
		set event=$P(queue,",",1)
		set queue=$P(queue,",",2,999)
		// Process event
		do exec(event)
		// State transition
		do transit(.state,event)
	}
	quit


exec(event)	//Private; event handler
	/*
	PARAMETER
		. event	event in the queue	/TYP=T/MECH=VAL/REQ
	*/

	type public Number %MODS, %OSAVE, %PAGE, %PG, %REPEAT
	type public String freq, IO, joball(), lastrfs, menu(), mnuevent(,)
	type public String pgm, pgms(), jobstat(), prvstate, queue, RM, scntitle(), state, title

	type Number i, njob, pgnum, pid
	type String func, mbar, mnuout, sel

	// Change state to "aborted" (generated event)
	if event="ABT" do { quit
		set prvstate=state
		do queadd(.queue,"LOD")
	}

	// Continue to next page (menu event)
	if event="CNT" do { quit
		if %PG<%PAGE do queadd(.queue,"DEL,NXT")
		else  do queadd(.queue,"DEL,RTN")
	}

	// Delete aborted jobs (generated event)
	if event="DEL" do { quit
		for i=%MODS:1:(%MODS+%REPEAT-1) if jobstat(i)'="" do {
			set func=$P(jobstat(i),"|",1)
			set pid=$P(jobstat(i),"|",2)
			do Db.fastDelete("JOBMON","func,pid")
		}
	}

	// Display menu and wait for seletion (generated event)
	if event="MNU" do { quit
		// Page ~p1 of ~p2
		if state'="ABT" set RM=$$^MSG(2127,%PG,%PAGE)
		else  set RM=""

		// time in second to refresh
		set mnuout=freq+lastrfs-$$time($h)
		if mnuout<0 set mnuout=0
		// make up for the rounding error
		set mnuout=mnuout+1

		// use proper menu bar
		set mbar=menu(state)
		// no time out for aborted job screen
		if state="ABT" do {
			set sel=$$^DBSMBAR(mbar,"","",1)
		}
		else  if state="ACT" do {
			set sel=$$^DBSMBAR(mbar,"","",1,"",mnuout)
		}
		else  if state="CPL" do {
			set sel=$$^DBSMBAR(mbar,"","",1,"",mnuout)
		}

		// refresh timeout
		if sel="" do queadd(.queue,"RFS") quit
		do queadd(.queue,mnuevent(state,sel)) quit
	}

	// Load data for a monitor state (generated event)
	if event="LOD" do { quit
		
		// compiled routine for screen
		set pgm=pgms(state)
		
		// Screen title
		set title=scntitle(state)

		kill %REPEAT,%MODS
		
		set %REPEAT=9			// Force to 9 since two rows per record
		if '%MODS.exists() set %MODS = 1
		
		// load jobs in the status
		do vlod(state)
		
		// total number of jobs
		set njob=$O(jobstat(""),-1)
		
		// total number of pages
		set %PAGE=(njob\%REPEAT)+1

		if njob>0,njob#%REPEAT=0 set %PAGE=%PAGE-1
		set %PG=1

		if state="ABT",njob="" do queadd(.queue,"RTN")
		else  do queadd(.queue,"SCN,MNU")
	}

	// Display next page (menu event)
	if event="NXT" do { quit
		if %PG<%PAGE do {
			set %PG=%PG+1
			set %MODS=((%PG-1)*%REPEAT)+1
			do queadd(.queue,"SCN")
		}
		do queadd(.queue,"MNU")
	}

	// Print current page (menu event)
	if event="PRT" do { quit
		set %OSAVE=%ProcessMode
		set %ProcessMode=4
		do VREPRNT^@pgm
		do CLOSE^SCAIO
		kill IO
		set %ProcessMode=%OSAVE

		do queadd(.queue,"SCN,MNU")
	}

	// Display previous page (menu event)
	if event="PRV" do { quit
		if %PG>1 do {
			set %PG=%PG-1
			set %MODS=((%PG-1)*%REPEAT)+1
			do queadd(.queue,"SCN")
		}
		do queadd(.queue,"MNU")
	}

	// Refresh monitor display (menu and generated event)
	if event="RFS" do { quit
		
		// last refresh time
		set lastrfs=$$time($h)
		
		// load jobs in all status
		do lodall

		if $O(joball("ABT",""))'="" do queadd(.queue,"ABT")
		else  do queadd(.queue,"LOD")
	}

	// Return from state "aborted" (generated event)
	if event="RTN" do queadd(.queue,"RFS") quit

	// Display current page on CRT (generated event)
	if event="SCN" do VREPRNT^@pgm quit

	// Toggle between state "active" and "completed" (menu event)
	if event="TGL" do queadd(.queue,"RFS") quit

	// Exit monitor (menu event)
	if event="QUT" set queue="" quit
	
	quit


transit(state,event)	// Private; Determine next state of monitor

	type public String prvstate, trans(,)

	// Unconditional transition   // $D(trans(state,event))
	if trans(state,event).exists() set state=trans(state,event) quit

	// Conditional transition
	if state="ABT",event="RTN" set state=prvstate quit
	quit


time(time)	// Private; convert time in $h format into seconds

	quit ($P(time,",",1)*86400)+$P(time,",",2)


lodall		//Private; load all jobs in all status

	type public String joball, mnuevent()
	
	type Date compdate
	type Number cnt, lasttime, pid, pids()
	type String finish, func, status

	kill joball
	set func=""
	set status=""

	for  set status=$O(mnuevent(status)) quit:status=""  set cnt(status)=1
	do ^%ZPID(.pids)

	type ResultSet jmonrs=Db.select("FUNC,PID,STDATE,STTIME,LASTTIME,RECCNT,RECID,COMPDATE","JOBMON")
	if 'jmonrs.isEmpty() while jmonrs.next() do {

		set func=jmonrs.getCol(1)
		set pid=jmonrs.getCol(2)
		set lasttime=jmonrs.getCol(3)
		set compdate=jmonrs.getCol(8)

		set status=$$status(compdate,pid,.pids)

		// Remove jobs age more than 24 hours
		set finish=compdate_","_lasttime
		if status="CPL",($$time($h)-$$time(finish))>86400 do Db.fastDelete("JOBMON","func,pid") quit

		set joball(status,cnt(status))=jmonrs.getRow().toString("|")
		set cnt(status)=cnt(status)+1
	}
	quit


status(cdate,pid,pids)	// Private; Return the status of a job

	if cdate'="" quit "CPL"
	if 'pids($$HEXDEC^%ZHEX(pid)).exists() quit "ABT"
	quit "ACT"



vlod(status)	//Private; Load data for monitor screen

	type public String joball(,), jobstat()

	type Number i

	kill jobstat

	for i=1:1:$O(joball(status,""),-1) set jobstat(i)=joball(status,i)
	if status="CPL" do sortcpl
	quit


sortcpl	// Private; Sort completed jobs in the order of the time they completed

	type public String jobstat(), tmp(,)
	
	type Number i, n, time
	
	set i=""
	for  set i=$O(jobstat(i)) quit:i=""  do {
		set time=$P(jobstat(i),"|",8)*86400
		set time=time+$P(jobstat(i),"|",5)
		set tmp(time,i)=jobstat(i)
		}

	set time=""
	set n="" 
	set i=0
	for  set time=$O(tmp(time),-1) quit:time=""  do {
		for  set n=$O(tmp(time,n)) quit:n=""  do {
			set i=i+1 
			set jobstat(1)=tmp(time,n)
			}
		}
	quit


queadd(queue,event)	//Private; Add events to the event queue

	if queue="" set queue=event
	else  set queue=queue_","_event
	quit


initset	// Private;  Set up menu options, related events and transition table

	type public Boolean ER
	type public String ET, menu(), mnuevent(,), pgms(), scntitle(), trans(,)

	type String SID,PGM

	/* menu items and event generated menu for aborted job screen
	Continue Print Quit  */
	set menu("ABT")=175
	set mnuevent("ABT",1)="CNT"
	set mnuevent("ABT",2)="PRT"
	set mnuevent("ABT",3)="QUT"

	/* menu for active job screen
	Next Previous Refresh Complete_Jobs Quit  */
	set menu("ACT")=173
	set mnuevent("ACT",1)="NXT"
	set mnuevent("ACT",2)="PRV"
	set mnuevent("ACT",3)="RFS"
	set mnuevent("ACT",4)="TGL"
	set mnuevent("ACT",5)="QUT"

	/* menu for completed job screen
	Next Previous Refresh Active_Jobs Print Quit  */
	set menu("CPL")=174
	set mnuevent("CPL",1)="NXT"
	set mnuevent("CPL",2)="PRV"
	set mnuevent("CPL",3)="RFS"
	set mnuevent("CPL",4)="TGL"
	set mnuevent("CPL",5)="PRT"
	set mnuevent("CPL",6)="QUT"

	// state transition table
	set trans("ACT","ABT")="ABT"
	set trans("ACT","TGL")="CPL"
	set trans("CPL","ABT")="ABT"
	set trans("CPL","TGL")="ACT"

	// screen title
	set scntitle("ABT")=$$^MSG(300)		// Abnormally terminated jobs
	set scntitle("ACT")=$$^MSG(287)		// Active jobs
	set scntitle("CPL")=""			// Screen title is hard coded

	set SID="JOBMON" 			// Job Monitor (Active Jobs)
	do ^USID
	if PGM="" set ER=1 set ET="INVLDSCR" quit
	set pgms("ABT")=PGM
	set pgms("ACT")=PGM

	set SID="JOBMON1" 			// Job Monitor (Completed Jobs)
	do ^USID
	if PGM="" set ER=1 set ET="INVLDSCR" quit
	set pgms("CPL")=PGM

	quit


public	SAVCNTXT(vzid,vzcntxt)	// Save process specific context
	/*
	ARGUMENTS:
		.vzid Job Monitor ID   /TYP=T/REQ/MECH=VAL
			The job monitor ID returned from $$INIT^JOBMON

		. context Process context   /TYP=T/REQ/MECH=VAL
			A comma separated list of the local variables that 
			are to be saved for restart purposes.
	RETURNS:
		$$ Condition value

	EXAMPLE:
		S ET=$$SAVCNTXT^JOBMON(jobmonid,"lv1,lv2,arr1,arr2")
	*/

	new CNTXT,VZFUNC,VZPID

	do PARSE(vzid,.VZFUNC,.VZPID)
	if VZFUNC=""!(VZPID="") quit "JM_INVLDID"

	set CNTXT=$$VSAV^PBSUTL(vzcntxt)

	type RecordJOBCNTXT jobcntxt=Db.getRecord("JOBCNTXT","FUNC=:VZFUNC,PID=:VZPID,MTDT=""CNTXT""",1)

	set jobcntxt.cntxt=CNTXT
	do jobcntxt.bypassSave()

	quit ""


public	RESCNTXT(vzid)	// Save process specific context
	/*
	ARGUMENTS:
		. vzid Job Monitor ID   /TYP=T/REQ/MECH=VAL
		The job monitor ID of
		the failed process.

	RETURNS:
		$$ Condition value	Null = success

	EXAMPLE:
		S ET=$$RESCNTXT^JOBMON(jobmonid)
	*/

	new vzermsg,vzx

	set vzermsg=""
	set vzx=""
	do {
		new FUNC,MTDT,PID,state

		do PARSE(vzid,.FUNC,.PID)
		if FUNC=""!(PID="") set vzermsg="JM_INVLDID" quit

		set state=$$STATE(FUNC,.vzid)
		if state'=0 set vzermsg="JM_INVLDST" quit

		set MTDT="CNTXT"
		type ResultSet rs=Db.select("CNTXT","JOBCNTXT","FUNC=:FUNC AND PID=:PID AND MTDT=:MTDT")
		if 'rs.isEmpty(),rs.next() set vzx=rs.getCol(1)
		}

	if vzx'="" do VLOD^PBSUTL(vzx)
	quit vzermsg


public	STATE(FUNC,id)	// Save process specific context
	/*
	ARGUMENTS:
		. FUNC Function ID   /TYP=T/REQ/LEN=12/MECH=VAL
			The function ID of the process, generally %FN

		. id Job Monitor ID   /TYP=T/REQ/REF:W
			The job monitor ID of the last process that was run for 
			function 'func'.
	RETURNS:
		$$ Process state
			0 - Process not active; batch not closed
			1 - Process active ; batch not closed
			2 - Process not active; batch closed
			(Null - state unknown)
	EXAMPLE:
		S STATE=$$STATE^JOBMON("QUE039",.jobmonid)
	*/

	new dat,date,compdate,newtime,pid,pids,state,status,tim,time

	set id=""
	set state=""
	set time=""

	do ^%ZPID(.pids)

	type ResultSet jmonrs=Db.select("PID,STDATE,STTIME,COMPDATE","JOBMON","FUNC=:FUNC")
	if 'jmonrs.isEmpty() while jmonrs.next() do {

		set pid=jmonrs.getCol(1)
		set dat=jmonrs.getCol(2)
		set tim=jmonrs.getCol(3)
		set compdate=jmonrs.getCol(4)
		
		set newtime=$$time(dat_","_tim)
		if newtime<time quit
		set time=newtime

		set id=FUNC_$C(0)_pid
		
		set status=$$status(compdate,pid,.pids)
		set state=$S(status="ABT":0,status="ACT":1,1:2)
		}

	quit state
 #OPTION ResultClass ON
Public String vSIG()	quit "60703^23199^Sudanthiran S. Kumar^14667"	// Signature - LTD^TIME^USER^SIZE
