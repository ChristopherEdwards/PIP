CHKPROC		/*
	  ORIG: GRAY - 01/04/2000
	  DESC: European Check processing procedures

	---- Comments --------------------------------------------------------

	---- Revision History ------------------------------------------------
	
	11/04/05 - PUTTASWH - CR17011
		   Added section VEROUT in order to check whether the 
		   number of outstanding checks exceeds the parameter 
		   CHKOUT defined at the account.  Modified section 
		   EUROCHK to reference ACN table instead of DEP table. 
		   Deleted CHKFOR section.
											   
	12/02/03 - CARROLLJ - CR7239
		   Added #ACCEPT to CHKACT linetag to correct compile errors.

	06/16/03 - CARROLLJ - 51349
		   Removed the use of the TR array.

	06/30/02 - Erik Scheetz - 43583
		   Remove GetOneRow methods from procedure.

	06/26/02 - ZWITKOWITSM - 43583
		   Modified for PSL transaction processing testing.

	06/13/02 - SELVANATHANS - 49709
		   In section VALTR modified code to check the CID and
		   CHKNUM before the error message is executed.

	*/

	quit	//  must call at a specific linetag


Public EUROCHK(Number CID)	// Account Number	
	// verify that CID is using new european check functionality

	/*  
	  returns: 0 - CID is not using this functionality
	 	   1 - CID is using it and CHKTYP=check type on account

	  Communication failure. Network off-line.
	  if off-line, cannot determine if account uses european check
	  processing.
	*/

	if '$G(%NET) quit 0

	type RecordACN acn=Db.getRecord("ACN","CID",1)
	if 'acn.getMode() quit 0 

	// no check type defined on account
	if acn.chks="" quit 0

	new CHKTYP

	set CHKTYP=acn.chks

	// does not use European check processing
	if 'Db.isDefined("XCHKPRD","CID,CHKTYP"),'acn.chkeuro quit 0

	quit 1

	
Public CSHLIM(RecordTTX ttx,	// Record TTX
	String INST,		// Institution Number
	Number AMT,		// Amount
	Boolean CTL)		// CTL
	// verify institution's check cashing limit (foreign check)

	new BASEAMT,FOUND,SYSCRCD,TMPAMT,TRCRCD

	type RecordUTBLEFTINST ueftinst=Db.getRecord("UTBLEFTINST","KEY=:INST",1)
	if 'ueftinst.getMode() set ER=1 quit 0

	// null means there is no limit
	if ueftinst.chklim="" quit 0

	type RecordCUVAR cuvar=Db.getRecord("CUVAR")

	set FOUND=0
	set TMPAMT=AMT
	set SYSCRCD=cuvar.%crcd			// system currency
	set TRCRCD=ttx.crcd			// transaction currency
	if TRCRCD="" set TRCRCD=ttx.bcrcd	// get base currency

	// convert TAMT to system base...
	if TRCRCD'=SYSCRCD do CAMT^CRCDUTL(TRCRCD,SYSCRCD,.TMPAMT)

	// Maximum transaction amount ~pl
	if TMPAMT>ueftinst.chklim do {
		set FOUND=1
		if CTL set OVR("*","OVR","CSHLIM")=ueftinst.chklim
		}

	quit FOUND


Public CHKACT(String CHKACT,	// Check Action
	String CHKNUM,		// Check Number
	Number CHKCID,		// Account Number
	String CHKTYP,		// Check Type 
	Number CHKSTS,		// Check Status				
	Number STSNEW,		// New status resulting from this action
	String VARLST)		// The customer variables to send to HOST "abc,f"	
	// Check Action
	
	/*	
	CHKSTS: If status= "*" the check is at ^CHKALLOC, not
		in ^CHECK and is converted to status 10-Unissued 
	*/	
	
	set CHKACT=$G(CHKACT),CHKNUM=$G(CHKNUM)
	set CHKCID=$G(CHKCID),CHKTYP=$G(CHKTYP),CHKSTS=$G(CHKSTS)

	// Invalid parameter
	// Convert to PSL
	if CHKACT="" do Runtime.setErrMSG("CHECK",8602) set STSNEW="" quit
	if CHKTYP="",(CHKCID="") do Runtime.setErrMSG("DEP",8602) set STSNEW="" quit
	if CHKNUM="",(CHKSTS="") do Runtime.setErrMSG("CHECK",8602) set STSNEW="" quit

	if CHKTYP="" do {

		type ResultSet rs=Db.select("CHKS","DEP","CID=:CHKCID")

		if rs.isEmpty() quit

		if rs.next() set CHKTYP=rs.getCol(1)
		}

	// account's check type not defined
	if CHKTYP="" do Runtime.setErrMSG("DEP",8687) set STSNEW="" quit
										
	/* 
	Can be an action without status. Example PRTTST - Printing test
	This action occurs when the check is allocated to the
	branch, is not defined in ^CHECK global and doesn't have
	check status. In this case we test for status "*"
	*/
	if CHKNUM'="",CHKSTS'="*" do { quit:$G(ER)
		if 'Db.isDefined("CHECK","CHKTYP,CHKNUM") do Runtime.setErrMSG("CHECK",1277) set STSNEW=""
		}

	if CHKSTS="" do {

		type ResultSet rs=Db.select("CHKSTS","CHECK","CHKS=:CHKTYP AND CHKNUM=:CHKNUM")

		if rs.isEmpty() quit

		if rs.next() set CHKSTS=rs.getCol(1)
		}

	// Status is ~p1
	if CHKSTS="" do Runtime.setErrMSG("CHKSTS",8413,"''") set STSNEW="" quit

	new CHKLVL,CHKSEQ,CHKFLG,STSRET,STSRTN

	set CHKLVL=""
	new X set X="SCA"
	if Db.isDefined("UTBLCHKACT2","CHKTYP,CHKACT") set CHKLVL=CHKTYP
	else  if Db.isDefined("UTBLCHKACT2","X,CHKACT") set CHKLVL="SCA"

	// invalid check action
	if CHKLVL="" do Runtime.setErrMSG("UTBLCHKACT2",8706) set STSNEW="" quit
										
	/* 
	The status 10 must be hard-coded here to try validate an action
	like print a check and determine the new status for the check.
	The check is in ^CHKALLOC not at ^CHECK and it doesn't have a status.
	*/
	if CHKSTS="*" set CHKSTS=10		// Unissued

	// RM is defined here for allow new messages in routine STSRTN

	// Action ~p1 not allowed for status ~p2
	new des

	type RecordSTBLCHKSTS schksts=Db.getRecord("STBLCHKSTS","CHKSTS")

	set des=schksts.desc
	do Runtime.setErrMSG("STBLCHKSTS",8688,"CHKACT~des")

	// Runtime Method above should not have ER set. The intent is to set RM.
	set ER=0			

	new rs
	set STSRET=""
	type ResultSet rs=Db.select("CHKSEQ","UTBLCHKACT3","CHKS=:CHKLVL AND CHKACT=:CHKACT AND CHKSTS=:CHKSTS")
	if 'rs.isEmpty() while rs.next() do { quit:STSRET'=""
		set CHKSEQ=rs.getCol(1)
		new utblchkact3
		type RecordUTBLCHKACT3 utblchkact3=Db.getRecord("UTBLCHKACT3","CHKLVL,CHKACT,CHKSTS,CHKSEQ")

		set STSNEW=utblchkact3.stsnew
		set STSRTN=utblchkact3.stsrtn
		if STSRTN="" set STSRET=STSNEW quit

		new X
		set X="set CHKFLG="_STSRTN
		#ACCEPT DATE=12/02/03;PGM=John Carroll
		xecute X
		if CHKFLG set STSRET=STSNEW
		}

	if STSRET="" set ER=1
	else  kill RM

	set STSNEW=STSRET

	quit


Public CHKVER(RecordTTX ttx,	// Record TTX
	String CHKNUM,		// Check Number
	Number CID,		// Account Number
	Number SEQ)		// Sequence Number
	// verify check information from check # prompt
	/* 
	  This is called as a post processor on STBL(MFVARP("TSO(""CK"")")
	  (used to prompt for check number on teller screen.
	  NOTE: This should also be BATCH-PROCESSOR on the trancode.  This
	        is necessary so the validations also get done if we are not
	        checking after entering the check number (e.g., when offline
	        we can't verify upon entering check number so validation
	        still needs to be done before posting the ^STF entry on the
	        server.)
	*/

	if $G(CID)="" quit
	if $G(SEQ)="" quit

	/*
	ARQ 48321 - NK
	Before this fix, CHKNUM was defined from the teller screen and
	contained the check number of a primary transaction.  If there were
	multiple transaction with other check numbers, these other check
	numbers were not verified.  When processing a secondary transaction 
	that did not contain a check number, this section created a runtime 
	error.  Processing will now re-define CHKNUM for each transaction 
	(primary and secondary) being processed.  If CHKNUM is not defined 
	processing will quit, otherwise processing verifies that the check 
	number is not used in any other transaction sequence.
	*/

	set CHKNUM=$$FIELD^UTSO(TSO,"CK")
	if $G(CHKNUM)="" quit

	do VALCID(CHKNUM,CID) quit:$G(ER)

	set BRCD=ttx.brcd
	set UID=ttx.uid
	do VALTR(CHKNUM,SEQ,CID) quit:$G(ER)

	if $$EUROCHK(CID) new TMP,X set X="PAY" do CHKACT(X,CHKNUM,CID,,,.TMP) quit:$G(ER)

	quit


VALCID(String CHKNUM,		// Check Number
	Number CID)		// Account Number
	// Verify if the check belongs to the account

	if '$G(%NET) quit	// can't verify if we are offline

	if '$$EUROCHK(CID) quit

	// Account's check type not defined
	if $G(CHKTYP)="" do Runtime.setErrMSG("DEP",8687) quit

	// Invalid Check Number
	new X

	type ResultSet rs=Db.select("CID","CHECK","CHKS=:CHKTYP AND CHKNUM=:CHKNUM")

	if rs.isEmpty() set X=""

	else  if rs.next() set X=rs.getCol(1)

	if X'=CID do Runtime.setErrMSG("CHECK",1277) 

	quit


VALTR(String CHKNUM,		// Check Number
	Number SEQ,		// Skip this sequence (actual sequence)
	Number RCID)		// Account Number
	// Verify if this check is used in this teller screen
	
	new NSEQ
	set NSEQ=SEQ\1000*1000
	type ResultSet rs=Db.select("TSO,CID","TTX","TJD=:%SystemDate AND BRCD=:BRCD AND UID=:UID AND TSEQ>:NSEQ AND TSEQ<:SEQ AND CID=:RCID")
	if rs.isEmpty() quit
	while rs.next() do {
		// Check range already in use by this process
		if ($$FIELD^UTSO(rs.getCol(1),"CK")=CHKNUM) do Runtime.setErrMSG("CHECK",8692)
		}

	quit


Public STPFIL(Number CID,	// Account Number
	String CHKTYP,		// Check Type 
	String START,		// Starting Check Number
	String END,		// End Check Number
	Number %O,		// Process Mode
	String OLDSTART)	// Old Start Check Number
	// Update check status in stop payments 

	quit:'$G(%NET)

	new CHKCNT,CHKARR,I,CHKNUM,NEWSTAT

	/* 
	In modify mode if the low check number is changed, we must 
	delete the stop in range OLDSTART to START-1
	*/
	if %ProcessMode=1,$G(OLDSTART)'="" do { quit:$G(ER)
		quit:START']]OLDSTART
		set CHKCNT=$$CHKCNT^CHKNUTL(OLDSTART,START)-2
		do CHKRNG^CHKNUTL(OLDSTART,CHKCNT)
		set CHKARR(0)=OLDSTART
		for I=0:1:CHKCNT do { quit:$G(ER)
			set CHKNUM=CHKARR(I)
			lock +CHECK(CHKTYP,CHKNUM):2 else  set ET="RECLOC" do ERR quit
			new X set X="STOPD" do CHKACT(X,CHKNUM,CID,,,.NEWSTAT)
			if '$G(ER) do Db.update("CHECK","CHKSTS=:NEWSTAT","CHKS=:CHKTYP AND CHKNUM=:CHKNUM")
			lock -CHECK(CHKTYP,CHKNUM)
			}
		}
	set CHKCNT=$$CHKCNT^CHKNUTL(START,END)-1
	do CHKRNG^CHKNUTL(START,CHKCNT)
	set CHKARR(0)=START
	for I=0:1:CHKCNT do { quit:$G(ER)
		set CHKNUM=CHKARR(I)
		lock +CHECK(CHKTYP,CHKNUM):2 else  set ET="RECLOC" do ERR quit
		if %ProcessMode=0 new X set X="STOPC" do CHKACT(X,CHKNUM,CID,,,.NEWSTAT)
		if %ProcessMode=1 new X set X="STOPM" do CHKACT(X,CHKNUM,CID,,,.NEWSTAT)
		if %ProcessMode=3 new X set X="STOPD" do CHKACT(X,CHKNUM,CID,,,.NEWSTAT)
		if NEWSTAT'="" do Db.update("CHECK","CHKSTS=:NEWSTAT","CHKS=:CHKTYP AND CHKNUM=:CHKNUM")
		lock -CHECK(CHKTYP,CHKNUM)
		}

	quit


Public STPVER(Number CID,	// Account Number
	String START,		// Starting Check Number
	String END,		// End Check Number
	Number %O,		// Process Mode
	Date TJD,		// System Processing Date
	String OLDSTART,	// Old Starting Check Number
	Date OLDEXP)		// Old expiration date
	/* 
	Validate European Check Statuses for Range
	of checks this is used as a post-processor for check numbers when
	creating, modifying, and deleting stops.  If the account uses
	european checks, we must verify the check statuses based upon %O.
	*/

	set OLDSTART=$G(OLDSTART)		// Old starting check number
	set OLDEXP=$G(OLDEXP)			// Old expiration date

	if '$$EUROCHK(CID) quit

	if START]]END do Runtime.setErrMSG("DEP",530) quit

	new CHKCNT,CHKARR,I,CHKNUM,NEWSTAT,CKDATA

	set CHKCNT=$$CHKCNT^CHKNUTL(START,END)-1

	do CHKRNG^CHKNUTL(START,CHKCNT)

	set CHKARR(0)=START
	for I=0:1:CHKCNT do { quit:$G(ER)
		set CHKNUM=CHKARR(I)

		// Test if the check belongs to account
		do VALCID(CHKNUM,CID) quit:$G(ER)

		// If %ProcessMode=1 (Modify) test if we already have a 
		// stop in this check

		if %ProcessMode=1 do { quit:$G(ER)
			if OLDSTART="" set OLDSTART=END
			if ((OLDEXP'="")&(OLDEXP'>TJD))
			else  quit:OLDSTART']]CHKNUM
			if $$STPEXP1^STPPROC(CID,CHKNUM,TJD) do Runtime.setErrMSG("CHECK",6016,CHKNUM) quit
			}
		if %ProcessMode=0 new X set X="STOPC" do CHKACT(X,CHKNUM,CID,,,.NEWSTAT)
		if %ProcessMode=1 new X set X="STOPM" do CHKACT(X,CHKNUM,CID,,,.NEWSTAT)
		if %ProcessMode=3 new X set X="STOPD" do CHKACT(X,CHKNUM,CID,,,.NEWSTAT)
		}

	quit

ERR	// error handler
	set ER=1
	do ^UTLERR
	set VFMQ="Q"

	quit

Public VEROUT(Number CID)	// Account Number
	// verify number of outstanding checks to allow new request

	type public Boolean ER	
	type public String CHKARR(),RM
	type Number CHKCNT,CHKOUT,CHKS,HIGH,I,LOW,NUMOUT,STSNEW
	type String CHKNUM
	
	set (CHKOUT,CHKS)=""
	
	type RecordACN acn=Db.getRecord("ACN","CID",1)
	if acn.getMode() do {  
	
		set CHKOUT=acn.chkout
		set CHKS=acn.chks
	
	}
	
	quit:(CHKOUT="")!(CHKS="") // Can have any number of outstanding checks
				   // Check type is not defined at the account
	
	set NUMOUT=0,HIGH=""
		
	type ResultSet rs=Db.select("HIGH,LOW","XCHECK","CID=:CID AND CHKS=:CHKS")	
	
	while rs.next() do {		
		set HIGH=rs.getCol("HIGH")
		set LOW=rs.getCol("LOW")
		set CHKCNT=$$CHKCNT^CHKNUTL(LOW,HIGH)-1
		do CHKRNG^CHKNUTL(LOW,CHKCNT)
		set CHKARR(0)=LOW
		
		for I=0:1:CHKCNT do {  quit:NUMOUT>CHKOUT
			set CHKNUM=CHKARR(I)
			do CHKACT("CHKOUT",CHKNUM,,CHKS,,.STSNEW)
			if STSNEW="" set NUMOUT=NUMOUT+1
			if $G(ER)=1 set ER=0,RM=""
			}
			
		}
	
	// Number of outstanding checks exceeds ~p1
	if NUMOUT>CHKOUT do Runtime.setErrMSG("XCHECK",8714,CHKOUT) quit:ER
	
	quit	
	

vSIG()	quit "60235^19410^Hema Puttaswamy^12315"	// Signature - LTD^TIME^USER^SIZE
