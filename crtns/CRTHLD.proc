CRTHLD  // Online Check Hold Allocation
	/*
          DESC:   Allocates float/check/value date holds
	
		***************NOTE*******************
	   Applying check transaction (CK) before the account transaction (e.g. DD)
	   automatically applies the hold to the account. When applying holds to
	   multiple accounts or accounts with negative or below minimum balances,
	   the account transaction must be done before the check transaction (CK)
	   and the check hold transaction (CH) must follow to place the hold on
	   the specified account(s). If a CH is attempted against an account
	   with a negative or below minimum available balance, an Override
	   Restriction will appear.	
	
	  ---- Revision History ------------------------------------------------
	   10/23/06 - chhabris - CR23516
		      Modified BRCD section to refer UTBLRTH.NUM instead of 
		      UTBLRTH.RT as the primary key RT for UTBLRTH table was
		      replaced with NUM in order to have foriegn key relationship
		      between UTBLRT and UTBLRTH tables.

	   07/14/06 - DESHPANDE S K - CR 20748
	   	      Modified section INI0 by renaming %TRNCK as TRNCK.	
	   
	   06/03/06 - TITOVE - CR 21602
	   	      Modified FINDCID section by placing trn.cls check inside
	   	      the DO, to ensure that nodes are loaded. Same change done
	   	      in ER section for trn.trntyp check. Replaced BALAVL
	   	      section with call to identical section BALCALC^CRTCH.
	   	      Cleaned up logic and brought up to standards.

	   02/08/06 - NATRAJAH - 19442
	   	      In INI0 section, added line of code to set %TRNCK value 
	   	      based on TRNTYP.
	   	      
	   11/29/05 - NATRAJAH - 13734
	   	      . Modified UPD section parameter to accepting ttx object 
	   	        instead of ttx() object and added acn object as 
	   	        parameter.
	   	      . Referred BRCD instead of ttx(seq).brcd in BRCD section, 
	   	        since ttx(seq).brcd is getting null value.
	   	      . In ER section, corrected the for loop quit condition.
	  	      . General DBI3 Cleanup.
	  	     
	   01/03/05 - TITOVE - CR 13734
	   	      Cleaned up logic as part of DBI2 project.

	*/

	quit
	

public	INIT(RecordTTX ttx(),	// Transactions array
	     String H(,))	// Hold allocation detail array to be filed by UHLDSCA

	// Process transactions to determine if holds to be applied

	type public Number ER = 0

	type Boolean BSEFLG()
	type Number %SQ, AMT, CHLD, CID, DFT, FHLD, PASS, SEQ, SQ, TCK, VD()
	type String CH(), CHS(), CK(), CR(), RT, UTSO
	
	type RecordTRN trn()

	kill H

	set SEQ = ""
	for  set SEQ = ttx(SEQ).order() quit:SEQ.isNull()  do {
		
		set CID = ttx(SEQ).cid
		
		set trn(SEQ) = Db.getRecord("TRN", "ETC = :ttx(SEQ).etc")
		
		do INI0(.ttx(), .trn(), .SEQ)
		}	
	
	// Save the CH array, if any, for later use in A2 section
	if (CH.data() > 1) do {
		
		type Number CHSC = ""
		for  set CHSC = CH(CHSC).order() quit:CHSC.isNull()  set CHS(CHSC) = CH(CHSC)
		}
	
	if (CK.data() '> 1) do {
	
		if (CH.data() '> 1) quit 

		type Number SQ = ""
		for  set SQ = CH(SQ).order() quit:SQ.isNull()  if (+CH(SQ) > 0) set DFT = DFT + CH(SQ)
			
		set SEQ = CH("").order()

		do A1CH(.ttx(), .trn(), SEQ) quit:ER
		}
	else  do {
		
		set SQ = "" 
		for  set SQ = CK(SQ).order() quit:SQ.isNull()  do A1(.ttx(), .trn(), SQ) quit:ER
		}

	if ER do { quit
		
		kill H
		
		// Special case - hold amounts are not balanced (except for EC/REV)
		if (ER = 2) do ER(.ttx(), .trn(), SEQ)
		}	

	quit
	
	
INI0(RecordTTX ttx(),		// Transactions array
     RecordTRN trn(),		// Transaction codes array
     Number SEQ) 		// Transaction sequence
	/*
	  Create array of manual check hold (CH) transactions.
	  Create array of auto-allocated check hold (CK) transactions.
	  Find principal amount of all loan transactions.
	*/
		
	type public String CH(), CK(), H(,), UTSO
	type public Number VD()
	type public Boolean TRNCK

	type Date TREFD, VDT	
	type Number TRTYP
	type String Z
	
	if SEQ#1 quit
	
	if ttx(SEQ).etc.isNull(), ttx(SEQ).tamt.isNull() quit
	
	// Set transaction effective date
	set TREFD = ttx(SEQ).efd

	if TREFD.isNull() set TREFD = %SystemDate
	
	// Value date
	set VDT = ttx(SEQ).vdt
	
	// Extract TSO from ttx
	do OUT^UTSO(.UTSO, ttx(SEQ).tso)
	
	// Set the number of Value days, if any, in the VD array by ttx sequence
	if 'VDT.isNull(), (VDT > TREFD) do {
	
		set VD(SEQ) = VDT - TREFD
		
		// Set the H(SEQ,0) detail for Value date holds
		set H(SEQ,0).piece("|",1) = ttx(SEQ).cid
		set H(SEQ,0).piece("|",2) = ttx(SEQ).tamt
		set H(SEQ,0).piece("|",6) = VD(SEQ)
		}
	else  set VD(SEQ) = ""
	
	// Check Hold type
	set TRTYP = trn(SEQ).trntyp
	
	// Check transaction or Manual Check Hold transaction (CH)
	if (TRTYP = 3) ! (TRTYP = 2) do {
		
		do INI1(.trn(), .ttx(), SEQ, .Z)
		
		if (TRTYP = 2) do {			
			set CK(SEQ) = Z
			set TRNCK = 1
			} 
		else  do {			
			set CH(SEQ) = Z
			
			do ^CRTCH(.ttx(), SEQ)
			}
		}
	quit 
	

INI1(RecordTRN trn(),		// Transaction codes array
     RecordTTX ttx(),		// Transactions array
     Number SEQ,		// Transaction sequence
     String Z)			// Returned hold information		/REF:W

	// If not multi-currency, extract transaction amount.
	// Build hold information based on the transaction record.
	
	type public Boolean BSEFLG()
	type public Number %MCP, CHLD, CRT, FHLD
	type public String %IPMODE
	
	set Z = ""
	
	// Extract user-defined check hold, if any
	set CHLD = $$FIELD^UTSO(ttx(SEQ).tso, "CHLD")
	if CHLD set Z.piece("|",3) = CHLD
	
	// Extract user-defined float hold, if any
	set FHLD = $$FIELD^UTSO(ttx(SEQ).tso, "FHLD")
	if FHLD set Z.piece("|",4) = FHLD
	
	// If not multicurrency env. set piece 1 of Z to amount in ttx
	if '%MCP set Z.piece("|",1) = ttx(SEQ).tamt quit 
	
	// Online, non-teller application
	if (ttx(SEQ).getStoredValue("TranMode") = 2), '%IPMODE.get().isLike("%NOINT%") set Z = ttx(SEQ).tamt quit 
	
	// If multi-currency, extract base amount; if it is null - default TAMT
	if 'ttx(SEQ).bseamt set Z.piece("|",1) = (ttx(SEQ).tamt)
	else  set Z.piece("|",1) = ttx(SEQ).bseamt
	
	if (trn(SEQ).trntyp = 2) do {
		
		// Check is in base currency
		if ttx(SEQ).tamt = ttx(SEQ).bseamt set BSEFLG(SEQ) = 1
		else  set BSEFLG(SEQ) = 0
		}

	// Quit if no exchange rate
	if 'ttx(SEQ).rate quit
	
	// If multiply/divide indicator = 1, set piece 2 of Z to exchange rate
	if ttx(SEQ).bseamt set Z.piece("|",2) = ttx(SEQ).rate
	
	// Otherwise, set piece 2 of Z to inverted value of exchange rate
	else  set Z.piece("|",2) = 1 / ttx(SEQ).rate
	
	quit 
	

A1(RecordTTX ttx(),		// Transactions array
   RecordTRN trn(),		// Transaction codes array
   Number SEQ)			// Transaction sequence
	
	type public Boolean ER
	type public Number CK(), DFT, H(,), HLD, TCK
	
	type Number RT

	// Set TCK equal to check amount
	set TCK = +CK(SEQ)
	set DFT = TCK 
	set HLD = 0
	set H(SEQ) = ""
	
	// Get routing table name from transaction record
	set RT = $$FIELD^UTSO(ttx(SEQ).tso, "RT")
	
	// If Routing table is defined - get check holds defined on branch level	
	if 'RT.isNull(), Db.isDefined("UTBLRT", "NUM=:RT") do BRCD(.ttx(), .trn(), SEQ) quit:ER
	
	do A1CH(.ttx(), .trn(), SEQ) quit:ER
	
	quit
	

A1CH(RecordTTX ttx(),		// Transactions array
     RecordTRN trn(),		// Transaction codes array
     Number SEQ)		// Transaction sequence

	// Collate through the CH array and resolve allocations
	
	type public Boolean ER
	type public Number ACK, CHLD, CID, DFT, PASS
	type public String CH(), CHS(), CK(), CR(), UTSO

	type Boolean QT = 0
	type Number %SQ, CNT, CKAMT, DEPAMT
	
	set %SQ = ""
	for  set %SQ = CH(%SQ).order() quit:%SQ.isNull()  do { quit:ER
		
		set CHLD = CH(%SQ).piece("|",3)
		
		do CH(CHLD, .ttx(), .trn(), %SQ)
		}
		
	// Allocations are resolved or error encountered
	if 'DFT ! ER quit
	
	// Load offsetting credits
	do LOAD(.ttx(), .trn(), SEQ)
	
	// Hold deposit amount
	set PASS = 1
	
	do A3(.ttx(),.trn())
	
	// Allocations are resolved
	if 'DFT quit
	
	// Determine if this is a split (cash back) transaction, then calculate
	// the check(s) total amount and deposit amount, for later comparison
	set (CKAMT,DEPAMT) = 0
	set CNT = ""
	for  set CNT = ttx(CNT).order() quit:QT!(CNT.isNull())  do {
		
		if CNT#1 quit

		// Customer account number (not a GL associated with CH transaction)
		if ttx(CNT).cid = CID, (trn(CNT).trntyp '= 3) set DEPAMT = ttx(CNT).tamt
		
		// Check Transaction Amount
		if (trn(CNT).trntyp = 2) set CKAMT = CKAMT + ttx(CNT).tamt
		
		// Manual Check Hold transaction encountered
		if (trn(CNT).trntyp = 3) set QT = 1
		}
	
	// Check if any funds remain unallocated (for cash back transactions)
	if (CK.data() > 1), (CR.data() > 1), (CKAMT > DEPAMT) do { quit:ER
		
		type Number AMR, ACR, AMH, CMH, CCK, CCR
		
		set (CMH,CCK,CCR) = ""
		set (ACK,AMR,AMH) = 0
		
		// Calculate total check, credit and hold allocation amounts
		for  set CCK = CK(CCK).order() quit:CCK.isNull()  set ACK = ACK + CK(CCK)
		for  set CCR = CR(CCR).order() quit:CCR.isNull()  set AMR = AMR + CR(CCR)
		
		if (CHS.data() > 1) do {
			
			for  set CMH = CHS(CMH).order() quit:CMH.isNull()  set AMH = AMH + CHS(CMH)
			}
		else  set AMH = 0

		/* 
		If check amount is more than credit amount + hold allocation
		amount (total of CH transactions amounts), then return error
		~p1 of check holds remain unallocated
		*/
		if (ACK > (AMR + AMH)) do Runtime.setErrMSG("HLD", 23, $$FN^SCARND(ACK - (AMR + AMH), ",", CID.get())) 
		}
	
	// Hold available balance
	set PASS = 2
	
	do A3(.ttx(),.trn())

	// Allocations are resolved
	if 'DFT quit

	/*
	When reversing split-hold (CH tran. code) transactions we do not have
	credit offset transations in the ttx() array, but we still want to
	create H() array entries for them instead of setting the ER.
	*/	
	if UTSO("EC").exists() ! UTSO("REV").exists() quit
	
	// Allocations were not resolved, return error indicator
	set ER = 2
	
	quit 
	

A3(RecordTTX ttx(),		// Transactions array
   RecordTRN trn())		// Transaction codes array
   
	// Collate through remaining credit transactions

	type public Number AMT, CID, DFT, PASS
	type public String CR()
	
	type Number %SQ = ""
	
	for  set %SQ = CR(%SQ).order() quit:%SQ.isNull()  do { quit:'DFT
		
		set CID = ttx(%SQ).cid
		
		if (PASS = 1) set AMT = +CR(%SQ)
		
		if (PASS = 2) set AMT = $$AVL(.ttx(), CID)
	
		// Allocate holds
		do HLD(.ttx(), .trn(), %SQ)		
		}
	quit


CH(Number CHLD,			// Manual check hold amount
   RecordTTX ttx(),		// Transactions array
   RecordTRN trn(),		// Transaction codes array
   Number %SQ)			// Transaction sequence	

	// Allocate CH transactions prior to system auto-allocation

	type public Number AMT, CID
	type public String CH(), CR()
	
	set CID = ttx(%SQ).cid
	set CHLD = CHLD.get()
	
	set AMT = CH(%SQ).piece("|",1) 
	
	if 'AMT quit
	
	set CR(%SQ) = CH(%SQ)
	
	// Allocate holds
	do HLD(.ttx(), .trn(), .%SQ)
	
	set CH(%SQ).piece("|",1) = CH(%SQ) - AMT
	
	if 'CH(%SQ) kill CH(%SQ)
	
	quit 
	

HLD(RecordTTX ttx(),		// Transactions array
    RecordTRN trn(),		// Transaction codes array
    Number %SQ)			// Transaction sequence 

	// Allocate hold
	
	type public Boolean BSEFLG()
	type public Number %MCP, AMT,CID,CHLD,DFT, ER, EXCAMT, FHLD, HLD, SEQ
	type public String CR(), CH(), H(,), VD()

	type Boolean CRDR
	type Number %AMT, %S, FSEQ, HSEQ, PRSEQ, VDAYS, VDSEQ, VSEQ
	type String CRCD, CRCDBASE, CCODE, HREC
	
	set %S = H(SEQ,"").order(-1) + 1
	
	if 'HLD.exists() set HLD = 0               
	
	if (AMT < 0) ! (DFT < 0) set:AMT < DFT AMT = DFT
	else  set:AMT > DFT AMT = DFT
	
	set DFT = DFT - AMT
	set %AMT = AMT

	// We should always set CRCD to be equal to currency of the account
	set CRCD = ttx(%SQ).crcd	
	if CRCD.isNull() set CRCD = %SystemCurrency

	set CRCD = ttx(%SQ).crcd 
	if CRCD.isNull() set CRCD = %SystemCurrency
	
	// If multicurrency environment, exchange rate defined and account
	// currency is different from Base currency - perform exchange, set %AMT 

	// Base Currency
	set CRCDBASE = ttx(%SQ).bcrcd 
	if CRCDBASE.isNull() set CRCDBASE = %SystemCurrency
	
	// Credit or debit type of transaction
	set CRDR = ttx(%SQ).itc.extract(1)

	// Only perform the exchange for the check (CK) transactions
	if (trn(%SQ).trntyp = 2), %MCP, CR(%SQ).piece("|",2)&(CRCD '= CRCDBASE) do { quit:ER 

		// If Customer Code is not defined in ttx, use account data (default = 0)
		
		set CCODE = ttx(%SQ).custcd
		
		if CCODE.isNull() do {

			type RecordACN acn = Db.getRecord("ACN", "CID = :CID", 1)
			
			set CCODE = acn.ccode
			}

		do EXC^CRCDUTL(CRCDBASE, CRCD, %AMT, BSEFLG(SEQ), CRDR, "00", +CCODE, ttx(SEQ).efd)
		
		set %AMT = EXCAMT
		}
	
	// Set the check/float/value hold record (H array)

	// Account number that hold will be applied against
	set HREC.piece("|",1) = CID
	// Check amount
	set HREC.piece("|",2) = %AMT
	// Sequence number of the ttx object
	set HREC.piece("|",3) = %SQ
	// Check hold days
	set HREC.piece("|",4) = CHLD.get()
	// Float hold days
	set HREC.piece("|",5) = FHLD.get()
	// Transaction trace from CR transaction. This enables updating database
	// one transaction at a time in UHLDSCA.
	set HREC.piece("|",7) = ttx(%SQ).trc
	
	// If hold is distributed among multiple accounts (use of CH tr. code),
	// get the SEQ number of starting transaction, if it used value date
	if CH.exists() do {
		
		set PRSEQ = H(SEQ).order(-1)
		
		if PRSEQ, H(PRSEQ,0).exists() set VDSEQ = PRSEQ		
		else  set VDSEQ = ""
		}
	else  set VDSEQ = ""
	
	// If any transaction in a transaction set has Value date defined and
	// greater than EFD, set number of Value days in H array for this SEQ
	if 'VDSEQ.isNull() set VSEQ = VDSEQ
	else  set VSEQ = SEQ
	
	for HSEQ = VSEQ:1:%SQ if 'VD(HSEQ).get().isNull() do {
	
		set VDAYS = VD(HSEQ)
		
		// Value days
		set HREC.piece("|",6) = VDAYS

		// Delete Float hold days from top level of H to indicate that
		// value days are to be used instead of float hold days
		if H(SEQ).data() for FSEQ = 1:3:24 set H(SEQ).piece("|",FSEQ) = ""
		}
	
	set H(SEQ,%S) = HREC
	
	quit
	
	
LOAD(RecordTTX ttx(),		// Transactions array
     RecordTRN trn(),		// Transaction codes array
     Number SEQ)		// Transaction sequence 
     
	// Load account data

	type public Boolean ER
	type public Number %SQ = SEQ
	type public String CR

	type Number CHLD, F, FHLD
	type String Z

	set F = 0
	kill CR
	
	for  set %SQ = ttx(%SQ).order() quit:(%SQ.isNull())!(%SQ#1 '= 0)  do { quit:ER!((ttx(%SQ).itc.extract(1) = 0)&(F = 1)) 

		if ttx(%SQ).itc.isNull() ! (ttx(%SQ).itc.extract(1) = 0) quit

		set F = 1
		
		// Transaction Group check
		if "RC|COM|CD|DDA|SAV|WASH|LN"'[trn(%SQ).grp quit
		
		// Create CR array containing offsetting credits
		do INI1(.trn(), .ttx(), %SQ, .Z)
		
		set CR(%SQ) = Z
		}
	
	quit
	

AVL(RecordTTX ttx(),
    Number CID)
    
	// Calculate available balance

	type public Number %NET
	type public String H

	type Number AVL, X, Y
	
	set AVL = 0
	
	if '%NET.get() quit AVL
	
	type RecordACN acn = Db.getRecord("ACN", "CID = :CID")
	
	// Get account's available balance
	set AVL = $$BALCALC^CRTCH(.acn)
	
	// Increase/decrease available balance by hold amounts
	set (X,Y) = ""
	for  set X = H(X).order() quit:X.isNull()  do {
		
		for  set Y = H(X,Y).order() quit:Y.isNull()  do {
			
			if (H(X,Y).piece("|",1) '= CID) quit
			
			if (acn.cls = "D") set AVL = AVL - H(X,Y).piece("|",2)			
			// Use principal
			else  set AVL = AVL - ttx(X).tamt.piece("#",2)
			}
		}

	quit AVL
	
	
public	UPD(RecordTTX ttx,	// Transactions array
	    RecordACN acn,	// Account
	    String H(,))	// Hold allocation detail

	// UHLDSCA call will create the array ttxhld with the levels of the hold table
	// that will be updated upon successful processing of the CR transactions

	type String HLDPGM = CUVAR.CHKHLDRTN
	
	if HLDPGM.isNull() do ^UHLDSCA(.ttx, .acn, .H(,)) quit

	// Custom hold program will need to accept same arguments as UHLDSCA,
	// or this procedure will need to be customized
	set HLDPGM = HLDPGM_"(.ttx,.acn,.H)"
	
	do @HLDPGM

	quit
	
	
FINDCID(RecordTTX ttx(),	// Transactions array
	RecordTRN trn())	// Transaction codes array
	
	type public Number CID = ""

	type Number I = ""
	
	for  set I = ttx(I).order() quit:I.isNull()  do { quit:'CID.isNull()
		
		if (trn(I).cls '= "M") set CID = ttx(I).cid
		}
		
	quit CID
	

BRCD(RecordTTX ttx(),		// Transactions array
     RecordTRN trn(),		// Transaction codes array
     Number SEQ)		// Transaction sequence 

	// Branch level float/check holds (Branch 0 default)
	
	type public Number BRCD, CHLD, ER
	type public String H(,), RT
	
	type Number CID, HLDTBL, POS, XBRCD
	type String HVAL

	set CID = $$FINDCID(.ttx(), .trn()) quit:CID.isNull()
	
	// Check if it is a REGCC account
	type RecordACN acn = Db.getRecord("ACN", "CID = :CID", 1)
	
	if acn.getMode() do {
		
		// Check Hold Routing and Transit Table
		if 'acn.hldtbl, 'acn.hldp1 set HLDTBL = 1
		else  set HLDTBL = acn.hldtbl
		
		// Determine if it is a REGCC check hold
		set POS = (HLDTBL * 3) - $select(acn.regcc:1,1:0)
		}
	
	set (XBRCD,HVAL) = ""

	// Routing table defined for the branch BRCD
	if 'BRCD.isNull(),Db.isDefined("UTBLRTH","NUM=:RT,BRCD=:BRCD") set XBRCD = BRCD

	// Use branch 0 as default if not otherwise defined
	if XBRCD.isNull() do { quit:ER
		
		if Db.isDefined("UTBLRTH", "NUM=:RT,BRCD=0") set XBRCD = 0 quit
		
		// R & T number for branch ~p1 not defined
		do Runtime.setErrMSG("UTBLRTH", 2303, BRCD)
		}

	type RecordUTBLRTH utblrth = Db.getRecord("UTBLRTH", "NUM = :RT, BRCD = :XBRCD")

	// Set top level of H array - branch level holds (in days)
	do HVALSET(.utblrth, .HVAL)

	set H(SEQ) = HVAL.extract(1,24)

	// Set the number of check hold days
	set CHLD = H(SEQ).piece("|",POS)
	
	quit
	
	
ER(RecordTTX ttx(),
   RecordTRN trn(),
   Number SEQ)

	// Return hold allocation error message

	type public Number CID, DFT
	
	// Transaction Amount
	for SEQ = SEQ+1:1 quit:'trn(SEQ).exists()  do {
		
		if (trn(SEQ).trntyp = 2) set DFT = DFT + ttx(SEQ).tamt
		}
		
	// ~p1 of check holds remain unallocated
	do Runtime.setErrMSG("HLD8", 23, $$FN^SCARND(DFT, ",", CID.get()))
	
	quit 
	

public	HLDD(String STR,	// Check/float hold string
	     String HTD,	// Type of hold
	     Number NUM,	// Check/float hold number
	     String TYP)	// Type of data
	/*
	  Parse check/float hold detail record. Used by HLDD table's computed columns.
	
	  Additional notes on arguments:
	   
	       . HTD    CHK = Check hold
			FLT = Float hold
	
	       . TYP    D = Expiration date
	    	     	$ = Hold amount
	
	  EXAMPLE:
	   
	        set CHKAMT1 = $HLDD^CRTHLD(X,"CHK",1,"$")
	
	   	Where if X = "CHK/55155/100.00^CHK/55156/25.00"
	   	then the returned value would be 100.00
	*/
	
	type String HLDDREC
	
	set HLDDREC = STR.piece(HTD,NUM+1).piece("^",1)		     
	 
	if HLDDREC.isNull() quit ""
	
	if (TYP = "D") quit HLDDREC.piece("/",2)
	
	if (TYP = "$") quit HLDDREC.piece("/",3)
	
	quit ""
	
	
HVALSET(RecordUTBLRTH utblrth,		// Routing And Transit Holds
	String HVAL)			// Hold Days			/REF:W

	set HVAL=utblrth.flt1_"|"_utblrth.rcc1_"|"_utblrth.hld1
	set HVAL=HVAL_"|"_utblrth.flt2_"|"_utblrth.rcc2_"|"_utblrth.hld2
	set HVAL=HVAL_"|"_utblrth.flt3_"|"_utblrth.rcc3_"|"_utblrth.hld3
	set HVAL=HVAL_"|"_utblrth.flt4_"|"_utblrth.rcc4_"|"_utblrth.hld4
	set HVAL=HVAL_"|"_utblrth.flt5_"|"_utblrth.rcc5_"|"_utblrth.hld5
	set HVAL=HVAL_"|"_utblrth.flt6_"|"_utblrth.rcc6_"|"_utblrth.hld6
	set HVAL=HVAL_"|"_utblrth.flt7_"|"_utblrth.rcc7_"|"_utblrth.hld7
	set HVAL=HVAL_"|"_utblrth.flt8_"|"_utblrth.rcc8_"|"_utblrth.hld8

	quit

vSIG()	quit "60562^16470^Sanjay Chhabria^18667"	// Signature - LTD^TIME^USER^SIZE
