BCHLNLAT //Batch BCHLNLATE - Late Charge Assessment
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 08/30/2007 15:08 - joynerd
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHLNLATE Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 set vBCHSTS=$$STATUS^BCHUTL("BCHLNLATE")
 if vBCHSTS=1 set ER=1,RM=$$^MSG(3410) quit
 if vBCHSTS=2 set ER=1,RM=$$^MSG(3414) quit
 if vBCHSTS=0 set %BatchRestart=1
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit do EXIT^BCHUTL("BCHLNLATE") quit
 do JOBMGR^BCHUTL(%FN,"BCHLNLATE",.vINPUT)
 do ^JOBMGR(.vINPUT)
 do EXIT^BCHUTL("BCHLNLATE")
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(TJD,CID) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHLNLATE","*","",TJD.get()_","_CID.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 if %BatchRestart,$$CHKLOG^BCHUTL(%SystemDate,%FN,"BCHLNLATE",TJD.get()_","_CID.get()) do { quit
 do LOG^BCHUTL(%SystemDate,%FN,"BCHLNLATE",TJD.get()_","_CID.get(),"Record already processed")
 }
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,TJD,CID)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHLNLATE","*","",TJD.get()_","_CID.get(),"",et)
 }
 do UPDLOG^BCHUTL(%SystemDate,%FN,"BCHLNLATE",TJD.get()_","_CID.get(),vCONTEXT)
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,TJD,CID) //
 
	new ER
	set ER=0
	
	type RecordLN ln=Db.getRecord("LN","CID=:CID")
	type RecordDAYENDLCHG delchg=Db.getRecord("DAYENDLCHG","TJD=:%SystemDate,CID=:CID")

	set BAL=ln.bal
	set XTJD=%SystemDate

	type Number CC,TYPE
	type String CRCD,GLSC,GRP,RESULT
	type Boolean REPROC

	set GRP=ln.grp
	set POPT=ln.popt
	if POPT="" quit
	
	type RecordLNPOPT lnpopt=Db.getRecord("LNPOPT","GRP,POPT")
	set SCHSEQ=ln.schseq

	/*
	 Create ttx in this section only to allow compiler to
	 pass it, it is not used by normal batch processing, but must
	 be passed to EXEC because the EXTERN line tag does require
	 the data and passes it into the EXEC line tag
	*/
	type RecordTTX ttx=Class.new("RecordTTX")

	set RESULT=$$EXEC(.ln,.delchg,.lnpopt,.ttx,CID,%SystemDate)
	if 'ER do FILE(.ln,.delchg,.lnpopt,+RESULT)
	
	quit


public EXTERN(RecordLN ln,RecordTTX ttx,CID,TD,FD,CTL,INCLTR)

	// Interface for calling EXEC^BCHLNLATE by LNILCHG and by LNLCEFD

	if $G(TD)="" set TD=%SystemDate
	if $G(FD)="" set FD=%SystemDate

	set SCHSEQ=ln.schseq

	set XTJD=%SystemDate
	type RecordDAYENDLCHG delchg=Db.getRecord("DAYENDLCHG","XTJD,CID",1)
 
	if ln.popt="" quit ""
	type RecordLNPOPT lnpopt=Db.getRecord("LNPOPT","GRP=:ln.grp,POPT=:ln.popt")
	
	new RESULT
	set RESULT=$$EXEC(.ln,.delchg,.lnpopt,.ttx,CID,TD,FD,CTL.get(),INCLTR.get())

	quit RESULT


EXEC(RecordLN ln,RecordDAYENDLCHG delchg,RecordLNPOPT lnpopt,RecordTTX ttx,CID,TD,FD,CTL,INCLTR)	// 
	
	//Process single account 
 
	/*
	   CID    - Account Number
	   TD     - Calculation through date (defaults to system date)
	   FD     - Calculation from date (defaults to system date)
	   CTL    - 0 Coming in with LN array
		     1 Coming in with %A,A arrays
	   INCLTR - 0 Do not include transaction
 		     1 Include transaction (%SEQ must be set to tran sequence)
	*/

	new BASEOPT,CMP,DIST1AF,DIST1FRE,DLCAF,GPCU,ICPF,IRN
	new LBDD,LCEFD,LCAD,LCLA,MAX,MAXO,MIN,MINO,PCT,PCTO,PENMET,POPTFLG
	new SCHLD,SCHND
	set XTJD=%SystemDate

	set LCEFD=""	
	if Db.isDefined("DAYENDLCHG","XTJD,CID") do {
		type RecordDAYENDLCHG delchg1
		set delchg1=Db.getRecord("DAYENDLCHG","XTJD,CID")
		// Late Charge Effective Date
		set LCEFD=delchg1.lcefd
		}
 
	if $G(TD)="" set TD=%SystemDate
	if $G(FD)="" set FD=%SystemDate
 
	set CTL=$G(CTL)
	
	if '$E(CTL) new TAMT
	if $G(INCLTR)="" set INCLTR=0
 
	do INITVAR(.ln,.lnpopt)
 
	// No Penalty Option is specified
	if POPT="" quit ""
	
 	if ln.stat quit ""
 	
	/*
	 Determine whether or not the account has already been processed
	 if ^DAYEND(TJD,"LCHG",CID) is defined, assume we are processing
	 DAYEND, otherwise, do: S ^DAYEND(TJD,"LCHG")=CID
	*/

	if LCLA=TD,delchg.getPointer(),delchg.lcefd,'delchg.lchg.isNull() do { quit P1_"|"_P2
		set REPROC=1
		set P1=delchg.lchg
		set P2=delchg.lcefd
		}
	
	/*
	Calculate back to late charge effective date only if Grace Period 
	Catch-up is indicated, we have not yet started Daily Late Charge 
	Assessments and current LCEFD is less than From date.
	*/
 
	if GPCU,'DLCAF,LCEFD<FD set FD=LCEFD

	// Create WIRN array with account value changes on given dates
 
	new WIRN,UAVBCTL
	set UAVBCTL="1000001000"_INCLTR
	
	type RecordLN ln2=ln.copy()
	
	do INIT^UAVB(.ln2,CID,$S(FD'>%SystemDate:FD,1:%SystemDate),$S(TD'>%SystemDate:%SystemDate,1:TD),UAVBCTL,,,,.WIRN())

	// Manipulate WIRN array if next scheduled date is before TD
 
	if SCHND<TD do WIRN(.ln) if ER quit 0
	if INCLTR do UPDPRIN(.ttx)
 
 	// Determine whether or not a late charge should be assessed
 
	if '$$LC(.ln,.lnpopt) quit ""
 	
	// Comparison
	set CMP=lnpopt.comp

	// Collate through comparison bases 1-6
	new X

	// Comparison Base 1
	set X(4)=lnpopt.base1

	// Comparison Base 2
	set X(5)=lnpopt.base2

	// Comparison Base 3
	set X(6)=lnpopt.base3

	// Comparison Base 4
	set X(7)=lnpopt.base4

	// Comparison Base 5
	set X(8)=lnpopt.base5

	// Comparison Base 6
	set X(9)=lnpopt.base6
 
	for PIECE=4:1:9 do {
		set BASEOPT=X(PIECE)
		if BASEOPT="" quit

		// Compare calculation bases

		set TAMT(PIECE)=$$CALC(.ln,.lnpopt,PENMET,BASEOPT) quit:ER
		if $G(TAMT)="" set TAMT=TAMT(PIECE) quit
		if CMP="L" set:TAMT(PIECE)<TAMT TAMT=TAMT(PIECE) quit
		if TAMT(PIECE)>TAMT set TAMT=TAMT(PIECE)
 		}

	if ER quit 0
 
	// Do limit checking if appropriate to do so at time of assessment
 
	// Min/Max Checking at Collection Flag	
	new MMCOL
	set MMCOL=lnpopt.mmcol

	if 'MMCOL set ET=$$LIM(.ln,MMCOL,.lnpopt) if ET'="" set ER=1 quit 0

	if TAMT<.01 set TAMT=0
 
	quit TAMT_"|"_LCEFD


 
INITVAR(RecordLN ln,RecordLNPOPT lnpopt)	// Initialize variables

 	type public String CRCD,GLSC,GRP,POPT
 	type public Number CC,TAMT,TYPE
 	type public Boolean CDF,GPCU,REPROC
 
	set (REPROC,TAMT)=""
	 
	// Late Charge Calc Method
	set POPT=ln.popt
	
	if POPT.isNull() set (POPT,CDF,GPCU)="" quit
	
	// Product Type
	set TYPE=ln.type

	// Product Group
	set GRP=ln.grp

	// Cost Center
	set CC=ln.cc

	// Currency Code
	set CRCD=ln.crcd

	// General Ledger Set Code
	set GLSC=ln.glsc


	// Daily Late Charge Assessment Flag
	set DLCAF=ln.dlcaf

	// Late Charge Last Assessed
	set LCLA=ln.lcla

	// Intrest Calc Period Frequency
	set ICPF=ln.icpf

	// Scheduled Payment - Next Date
	set SCHND=ln.schnd

	// Scheduled Payment - Last Date
	set SCHLD=ln.schld


	// Distribution 1 Next Due
	set DIST1ND=ln.dist1nd

	// Distribution 1 Frequency
	set DIST1FRE=ln.dist1fre

	// Distribution 1 Annual Factor
	set DIST1AF=ln.dist1af

	// Late Charge Action Date
	set LCAD=ln.lcad

	// Last Bill - Due Date Billed
	set LBDD=ln.lbdd

	// Percentage Base Override
	set PCTO=ln.pcto

	// Late Chrg Method Max Ovr
	set MAXO=ln.maxo

	// Late Chrg Method Min Ovr 
	set MINO=ln.mino
	
	/* 
	Late Charge Effective Date is set first from the dayend record 
	(set up in billing).  Otherwise use the Last Scheduled Date
	*/
 
	
	if LCEFD="" set LCEFD=SCHLD
 
	/*
	Load penalty options
	If calc method is equal to fixed charge - base should not be null
 	*/
	if lnpopt.met=1 set lnpopt.base1=+lnpopt.base1

	/*
	If Percentage Base Override, Maximum Override and Minimum Override
	values are not null, use the Override values.
	*/
	// Penalty Method
	set PENMET=lnpopt.met

	// Percentage Of Base
	set PCT=lnpopt.pct

	// Maximum Late Charge
	set MAX=lnpopt.maxlc

	// Minimum Late Charge
	set MIN=lnpopt.minlc
	
	// Calc Method flag
	if POPT'="" set POPTFLG=1
	
	if POPTFLG,((PENMET=2)!(PENMET=4)!(PENMET=5)) do {
		if PCTO'="" set PCT=PCTO
		}
	
	if (MAXO'="")!(MINO'="") set MAX=MAXO,MIN=MINO

	
	// Calculate Daily Flag
	set CDF=lnpopt.cdf

	// Grace Period Catch-up
	set GPCU=lnpopt.gpcu

	quit
 


LC(RecordLN ln,RecordLNPOPT lnpopt)	// 

	//Determine whether (1) or not (0) to assess late charge
 
	new CHG
	set CHG=1
	
	// Determine if account's due date is greater than effective pmt date
 
	if DIST1ND>LCEFD quit 0
 
	new DGPI,DGPMT,NFP

	// Payment Period for Latecharge override
	set NFP=lnpopt.nfp

	// Calculated Due Amount Greater Than P&I
	set DGPI=lnpopt.dgpi

	// Calculated Due Greater Than Payment
	set DGPMT=lnpopt.dgpmt
 	set DLFP=ln.dlfp
	set PMTGRC=ln.pmtgrc

	//Current month
	set TJDMM=+$$DAT^%ZM(%SystemDate,"MM")

	//Month of lastfull payment
	set DLFPMM=+$$DAT^%ZM(DLFP,"MM")
	if NFP=0 quit CHG
	if NFP=1 set:DLFPMM=TJDMM CHG=0	  
	// Checks if the payment is within late charge grace period
	if NFP=2 set:DLFP'<LCEFD CHG=0

	if '(DGPI+DGPMT) quit CHG
 
	// Ensure that using PMT and PMTPI associated with LCEFD
	do PMT(.ln)
 
 	// Calculate appropriate payment due amount
 
	set DUE=$$DUE(.ln,.lnpopt,TD) 
 
	if DGPI set:DUE<PMTPI CHG=0
	if DGPMT set:DUE<PMT CHG=0
 
	quit CHG
 

PMT(RecordLN ln)  // Define appropriate values of PMT and PMTPI
 
	/*
	 This section is necessary because the payment and P&I amounts found
	 in the account record may relate to a payment billed after LCEFD.
 	*/

	// Default from current account
 
	// Payment - Current Amount
 	set PMT=ln.pmt

	// Principal and Interest Payment
	set PMTPI=ln.pmtpi

	if TD'<LBDD quit
 
	new IBCI,MATCH,SCHSEQ
 
	set MATCH=0

	// Internal Bill Control Info
	set IBCI=""

	// Scheduled Internal Bill SequenceNumber 
	set SCHSEQ=ln.schseq
	

	// Search bill file for Late Charge Eff Date and Payment Due Date match

	do { quit:'SCHSEQ!(MATCH)
		/*
		if Db.isDefined("LNBIL1","CID,SCHSEQ") do { quit
			set IBCI=lnbil1.bp1
			if IBCI'="",LCEFD=$P(IBCI,"#",3) do {
				set MATCH=1

				// Total Amount Due per Payment
				set PMT=$P(IBCI,"#",4)

				// Total Prin Plus Int Amount
				set PMTPI=$P(IBCI,"#",6)
				}
			set SCHSEQ=$O(BL(CID,SCHSEQ),-1)
			}
		*/
		Type RecordLNBIL1 lnbil1=Db.getRecord("LNBIL1","CID,SCHSEQ",1)
		// Internal Bill Control Information
		set IBCI=lnbil1.bp1

		// Pmt Due Date
		if IBCI'="",LCEFD=lnbil1.cdpd do { quit
			set MATCH=1

			// Total Amount Billed
			set PMT=lnbil1.ctab

			// Total Prin Plus Interest Amount Billed
			set PMTPI=lnbil1.cpib
			}
		set SCHSEQ=Db.prevVal("LNBIL1","CID,SCHSEQ") quit:'SCHSEQ
		}

	quit
 

DUE(RecordLN ln,RecordLNPOPT lnpopt,JD)	// Extrinsic - returns due amount for purposes of LC processing
	
 	// JD   = Effective date 
 
	set DUE=0
	set WIRN=WIRN($O(WIRN(JD+1),-1))
	set PVO=ln.pvo
  
	// Add in amounts as indicated
 
	// Current Interest
	if lnpopt.pcuin set DUE=DUE+$P(WIRN,"|",6)

	// Uncollected Interest
	if lnpopt.punin set DUE=DUE+$P(WIRN,"|",7)

	// Current Principal
	if lnpopt.pcupr set DUE=DUE+$P(WIRN,"|",8)

	// Uncollected Principal
	if lnpopt.punpr set DUE=DUE+$P(WIRN,"|",9)

	// Current Escrow
	if lnpopt.pcues set DUE=DUE+$P(WIRN,"|",10)

	// Uncollected Escrow
	if lnpopt.punes set DUE=DUE+$P(WIRN,"|",11)
	
	/*
	 To check if there is a late fee to be charged.
	 If there is a fee, adding the amount due to the total. 
	 LN array required for LATE^LNFEEU(CID,JD)
	*/

	// Misc Charges
	if lnpopt.pmchg set DUE=DUE+$$LATE^LNFEEU(.ln,CID,JD)
 
	/*
	 Subtract amounts as indicated
	 Subtract Prin Variance Bal if LN Prin Variance Option is in effect
	*/

	if lnpopt.spvar,PVO set DUE=DUE-$P(WIRN,"|",23)
 
	// Unapplied Funds
	if lnpopt.sunapf set DUE=DUE-$P(WIRN,"|",22)
 
	quit DUE
 

WIRN(RecordLN ln)	// Add entry to WIRN array if next scheduled less than effective date
 
	new SCHSEQ
	type RecordLNBIL1 lnbil1

 	set SCHSEQ=ln.schseq
	
	if Db.isDefined("LNBIL1","CID,SCHSEQ") do {
		set lnbil1=Db.getRecord("LNBIL1","CID,SCHSEQ")  
		set WIRN=$O(WIRN(lnbil1.cdpd),-1)
		}
	
	else  quit

	// Pmt Due Date 
	if lnbil1.cdpd'<TD quit

	if WIRN'="" set WIRN=WIRN(WIRN) quit:'$L(WIRN)
	// Unable to process - check for integrity errors
	else  set ER=1,ET=$$^MSG(8354) quit

	// Increase uncollected int,prin by previous current int,prin amount
 
	set $P(WIRN,"|",7)=$P(WIRN,"|",7)+$P(WIRN,"|",6)
	set $P(WIRN,"|",9)=$P(WIRN,"|",9)+$P(WIRN,"|",8)
 
 	// Set interest,principal from bill into current interest,principal
 
	// Pmt Element 1 - Amount StillDue
	set $P(WIRN,"|",6)=lnbil1.pe01ad

	// Pmt Element 2 - Amount StillDue
	set $P(WIRN,"|",8)=lnbil1.pe02ad
 
	// Pmt Due Date
	set WIRN(lnbil1.cdpd)=WIRN

	quit
 


UPDPRIN(RecordTTX ttx)	// Update principal amount in WIRN entries when transaction is included
 
	new DATE,PRIN,TAMT
 
	set TAMT=ttx.tamt

	// Principal + Undisbursed Prin
	set PRIN=$P(TAMT,"#",2)+$P(TAMT,"#",5)
 
	set DATE=""
	for  set DATE=$O(WIRN(DATE)) quit:DATE=""  set $P(WIRN(DATE),"|",2)=$P(WIRN(DATE),"|",2)-PRIN
	quit

 
CALC(RecordLN ln,RecordLNPOPT lnpopt,PENMET,BASEOPT)	// Calculate late charge
 
	/*
	 PENMET (Penalty Method)
	 1)=Fixed Late Charge Found in Account Record
	 2)=Fixed Rate Applied to Specified Base
	 4)=Fixed Annual Rate Applied to Specified Base
	 5)=Marginal Annual Rate Plus Account Rate Applied to Specified Base
	*/
	type public Date FD, LCAD, TD
	type public Boolean CDF, DLCAF, ER, LNPTSRV
	type public Number PCT
	type public String WIRN()
	type Number AMT, CALCAMT, I, NUMLCHGS, OFF, RANGE
	type Date DATE,JD,NJD
	
	set (DATE,AMT)=""
 
	if PENMET=1,'CDF do { quit $$^SCARND(AMT,0,ln.cid)
		
		/*
		 Calculate number of fixed late charge amounts due
		 between last LCAD and TD
		*/

		if TD<LCAD set AMT=ln.flca quit	
		set JD=FD

		for I=1:1 set NJD=$$NJD^UFRE(JD,ln.dist1fre) quit:ER!(NJD+ln.pmtgrc>TD)  set JD=NJD

		set NUMLCHGS=I
		set AMT=$$BASE(.ln,.lnpopt,BASEOPT)
		set AMT=AMT*NUMLCHGS
		}
       
	for  set DATE=$O(WIRN(DATE)) quit:DATE=""  do {
		
		/*
		If From Date is not same as Through Date and the DATE in 
		WIRN array is equal to system date and Calculate Daily Flag
		is 1 then OFF variable is set to 1 otherwise set to 0.
		
		If we got here from reversals, don't set OFF=1 because 
		every calculation for PENMET=4 or PENMET=5 will be short by 
		1 day.
		*/ 
		
		if (FD'=TD),(DATE=%SystemDate),(CDF&DLCAF),('LNPTSRV.get()) set OFF=1
		else  set OFF=0

		set RANGE=$$ENDATE(DATE,'OFF)-DATE quit:'RANGE
		set CALCAMT=$$BASE(.ln,.lnpopt,BASEOPT)
 
		/* If the Base option is 0 then the amount is a
		   fixed amount and we do not need to calculate
		   this as a percentage.
		*/
		if (PENMET=2),(BASEOPT>0) set CALCAMT=CALCAMT*(PCT/100)
		if (PENMET=4)!(PENMET=5) set CALCAMT=$$PENINT(CALCAMT,ln.iacm,DATE,PCT)
 
		set CALCAMT=$$^SCARND(CALCAMT,0,ln.cid)
		if CDF set CALCAMT=RANGE*CALCAMT
		set AMT=AMT+CALCAMT
		}
 
	quit AMT
 
ENDATE(NJD,OFF)	// Returns end date
	
	// OFF = Offset from TD if NJD is null
	
	set NJD=$O(WIRN(NJD))
	if NJD'="" quit NJD
	
	quit TD+OFF
 

PENINT(BAL,IM,LJD,PCT)	// Calculate true penalty interest amount
 
	if PENMET=4 set IRN=PCT
	else  set IRN=PCT+WIRN($O(WIRN(LJD+1),-1))

	quit $$^UIC(BAL,LJD,LJD,IM,IRN,0,DIST1AF,DIST1FRE,ICPF,SCHND,SCHLD)
 

BASE(RecordLN ln,RecordLNPOPT lnpopt,BASEOPT)	
	
	
	// Returns appropriate late charge base
 
	// Fixed Late Charge Amount
	if BASEOPT=0 quit ln.flca

	// P & I Payment Amount
	if BASEOPT=1 do PMT(.ln) quit PMTPI

	// Total Payment Amount
	if BASEOPT=2 do PMT(.ln) quit PMT

	// Principal Bal
	if BASEOPT=3 quit $P(WIRN(DATE),"|",2)

	// Balance for Interest Calc
	if BASEOPT=4 quit $P(WIRN(DATE),"|",5)

	// Total Due
	if BASEOPT=5 quit $$DUE(.ln,.lnpopt,DATE)

	// Current Principal Due
	if BASEOPT=6 quit $P(WIRN(DATE),"|",8)

	// Current Interest Due
	if BASEOPT=7 quit $P(WIRN(DATE),"|",6)

	quit ""
 

LIM(RecordLN ln,MMCOL,RecordLNPOPT lnpopt)	// Limit checking
 
	if 'MMCOL do { quit:'TAMT ""
		// Adjust by minimum and maximum limits
 
		set TAMT=$$MIN(TAMT,MIN,lnpopt.mlco)
		set TAMT=$$MAX(TAMT,MAX)		
		}
 
	// Maximum Number of Late Charges perYear
 	set LCANL=ln.lcanl

	// Check Number Late Charges Year-to-Date
 	
	if LCANL,ln.lcan+1>LCANL quit "EX_YEAR_LIM"
	
	// Maximum Late Charge Assessment Count 
	set LCLNL=ln.lclnl

	// Check Total Number of Late Charge Assessments
 
	if LCLNL,ln.lcanlf+1>LCLNL quit "EX_LIFE_LIM"

	quit ""
 


public MIN(AMT,MIN,MLCO)	// Minimum late charge amount (Extrinsic)
 
	if $G(MIN)="" quit AMT
	if AMT'<MIN quit AMT
	if $G(MLCO) quit 0
	quit MIN
 

public MAX(AMT,MAX)	// Maximum late charge amount (Extrinsic)
 
	if $G(MAX)="" quit AMT
	if AMT'>MAX quit AMT
	quit MAX
 

FILE(RecordLN ln,		// Loan account				/REF:RW
     RecordDAYENDLCHG delchg,	// DAYEND Late Charge Setup		/REF:RW
     RecordLNPOPT lnpopt,	// Lending penalty options		/REF:R
     Number TAMT)		// Late charge transaction amount

	// File late charge data either summary or detail
 
	// Should be called by dayend processing only
	
	type public String CRCD,GL(,,,),GLSC,RM
	type public Boolean ER,CDF
	type public Number CC,CID,TYPE
 
	new SCHSEQ,SUMM
		
	type Number VATAMT
	set VATAMT=0

	catch error {
		set ER=1,RM=error.description
		if error.type["GTM" do ZE^UTLERR quit

		throw error
		}

	if 'TAMT do { quit 
		do NOCHG(.ln,.delchg) 
		do ln.bypassSave()
		}
	
	if lnpopt.subtovat do {
		type RecordUTBLBRCD utblbrcd=Db.getRecord("UTBLBRCD","BRCD=:ln.boo")
		if utblbrcd.vatpct.isNull() quit							
		set VATAMT=(TAMT*(utblbrcd.vatpct/100)).roundCur(ln.crcd)
		}
	else  set VATAMT=0
	
	// Summary Only (No History Transaction)
	set SUMM=lnpopt.summ

	
	// Summary posting
	if SUMM do FILESUM(.ln,.lnpopt) quit:ER

	// Create transaction
	if 'SUMM do FILEDTL(.ln,.lnpopt) quit:ER
	
	// Credit Late Charge Income offset summary array
	if 'GL(CRCD,TYPE,GLSC,CC).exists() do GLINI	
	do UPOFFSET^BCHSOURC("BCHLNLATE","GL",CRCD,TYPE,GLSC,CC,1,TAMT)
	if VATAMT do UPOFFSET^BCHSOURC("BCHLNLATE","VATGL",CRCD,TYPE,GLSC,CC,1,VATAMT) 		
 
	// System Date
	set delchg.tjd=%SystemDate

	// Account Number
	set delchg.cid=CID

	// Calculated Late ChargeAmount
	set delchg.lchg=$P(RESULT,"|",1)

	// Late Charge Effective Date
	set delchg.lcefd=$P(RESULT,"|",2)
	do delchg.bypassSave()

 	if CDF do {
 		type Date NXTTJD
 		set NXTTJD=%SystemDate+1
 		type RecordDAYENDLCHG delchg2=Db.getRecord("DAYENDLCHG","TJD=:NXTTJD,CID=:CID",1)
		set delchg2.lcefd=""
		set delchg2.lchg=""
		do delchg2.bypassSave()
		}

	// Add late fee to Bill file
	set SCHSEQ=ln.schseq
	if SCHSEQ do {
		
		type RecordLNBIL5 lnbil5=Db.getRecord("LNBIL5","CID=:CID,SCHSEQ=:SCHSEQ,DUEAMT=0,FEETYP='L'",1)

		// Fee Amount Original
		set lnbil5.bfamt=lnbil5.bfamt+TAMT

		//  Fee Amount Still Due
		set lnbil5.brfamt=lnbil5.brfamt+TAMT

		do lnbil5.bypassSave()
		
		if 'VATAMT quit 

                set lnbil5=Db.getRecord("LNBIL5","CID=:CID,SCHSEQ=:SCHSEQ,DUEAMT=0,FEETYP='VL'",1)
 
                // Fee Amount Original
                set lnbil5.bfamt=lnbil5.bfamt+VATAMT 

                //  Fee Amount Still Due
                set lnbil5.brfamt=lnbil5.brfamt+VATAMT 

                do lnbil5.bypassSave()	
		}			
	quit
	
FILESUM(RecordLN ln,			// Loan account			/REF:RW
	RecordLNPOPT lnpopt)		// Lending penalty options	/REF:R

	// Summary posting
  	
	// Debit Late Charge Receivable offset summary array

	type public String CRCD,GL(,,,),GLSC
	type public Number BALINT,CC,TAMT,TYPE,VATAMT
	type public Boolean REPROC

	new POPT,CUVAR2
	
	// Debit Late Charge Reveivable offset summary array (for non-summary 
	// posting, this will be updated via ttx.penalty - piece 4 of TAMT)
	if 'GL(CRCD,TYPE,GLSC,CC).exists() do GLINI
 	do UPOFFSET^BCHSOURC("BCHLNLATE","GL",CRCD,TYPE,GLSC,CC,0,TAMT)
 	if VATAMT do UPOFFSET^BCHSOURC("BCHLNLATE_VAT","GL",CRCD,TYPE,GLSC,CC,0,VATAMT) 		

	if REPROC quit

	// Interest Calc Principal Adjustments 
	set ICPA=ln.icpa

	// Adjusted Balance for AccrualCalculation
	set BALINT=ln.balint
	
	if '$D(ICPA(ICPA)) do {
		type RecordUTBLICPA utblicpa
		set utblicpa=Db.getRecord("UTBLICPA","ICPA")
		// Priorities
		set ICPA(ICPA)=utblicpa.prio
		}

	if $E(ICPA(ICPA),6) set BALINT=BALINT+TAMT
 
	/*
	 Copy lnpopt to POPT array, since this is a record type 11, the 2nd 
	 key level will be stored in variable POPT. It is this level which
	 we want to pass to the routine LNPTS9
	*/
	set CUVAR2=%SystemDate
	do SET^LNPTS9(.ln,ln.popt,RESULT,%SystemDate,VATAMT)
	do ln.bypassSave()

	quit
 

FILEDTL(RecordLN ln, 		// Loan account			/REF:RW
	RecordLNPOPT lnpopt)	// Lending Penalty Options	/REF:R
 
 	// File using transaction
 
	type public Boolean ER
	type public Cache %CACHE()
	type public Date TPD
	type public Number BRCD, CC, CID, TAMT, TYPE
	type public String CRCD		
	type public Number VATAMT		
	type String PAR(), GLTC, SAVOFFST, TCMT, TSO, x
	
	set (TCMT,TSO)=""
		
	type RecordPRODCTL prodctl = %CACHE("PRODCTL").getRecord("PRODCTL", "TYPE=:TYPE")
	
 	type RecordTRN trn = %CACHE("TRN").getRecord("TRN","ETC = :prodctl.drtrpe")
		
	if 'trn.dc set GLTC = $select(ln.trb:"MCR", 1:"MDR")
	else  set GLTC = $select(ln.trb:"MDR", 1:"MCR")
	
	// Add Offset to TSO field
	set TSO="LCHGADJ#"
	type RecordUTBLGLSC utblglsc=Db.getRecord("UTBLGLSC","GLSC=:ln.glsc")
	set SAVOFFST=GLTC_":"_utblglsc.lgll
	set TSO=$$FIELDIN^UTSO(TSO,"OFFST",SAVOFFST)

	// Process Late Charge Assessment transaction
 
	// Create transaction array entry
	type TranSet ts=Class.new("TranSet")
	type RecordTTX ttx=Class.new("RecordTTX")
			
	// Account Number
	set ttx.cid=CID

	// External Transaction Code
	set ttx.etc=prodctl.drtrpe		

	// Transaction Amount
	set ttx.tamt=TAMT

	// Transaction Location
	set ttx.tlo=%UserStation

	// Transaction Source of Funds
	set ttx.tso=TSO

	// Transaction Comment
	set ttx.tcmt=TCMT

	// Cost Center
	set ttx.cc=CC

	// Currency Code
	#IF CUVAR.%MCP set ttx.crcd=CRCD
	
	/*
	If Value Added Tax is applicable, increase the transaction amount by 
	it, store it in ttx.vatlchg, store the late charge amount in ttx.penalty,
	and save the offsets in Teller Source. The posting program (LNPTS9) 
	will use these fields when posting the transaction.
	*/
	if VATAMT do {
		set ttx.tamt=TAMT+VATAMT

		// Tran Detail: D:Penalty L:Late Charge
		do GL^LNPTSU(.ttx,TAMT,4)
		
		// Tran Detail: L:Val Tax Lchg
		do GL^LNPTSU(.ttx, VATAMT,17)
				
		set SAVOFFST=GLTC_":"_utblglsc.lgll_","_GLTC_":"_utblglsc.lglvatlchgi
		set TSO=$$FIELDIN^UTSO("","OFFST",SAVOFFST)
		// Transaction Source of Funds
		set ttx.tso=TSO										
		}
	
	set x=ts.copyTran(ttx)
		
	// System generated
	set PAR("IPMODE")=3

	// Process tran, update database
	set PAR("OPTION")=2
	
	if lnpopt.cwa do { quit:ER
		
		if prodctl.crtrpe.isNull() do ETCERR^TTXEXT(TYPE, "CRTRPE") quit
		if prodctl.drtrpr.isNull() do ETCERR^TTXEXT(TYPE, "DRTRPR") quit
		
		// Capitalize with assessment
		set ttx.tso=""
		
		// Reset ttx.tamt in case it was modified above for VAT
		set ttx.tamt=TAMT
		
		// CR Late Charge Tran Code to pay the late charge
		set ttx.etc=prodctl.crtrpe
		type RecordTRN trn
		set trn=%CACHE("TRN").getRecord("TRN","ETC=:prodctl.crtrpe")
		set ttx.itc=trn.dc
		set x=ts.copyTran(ttx)
			
		/* 
		  The transaction code the system uses to post a debit transaction 
		  for principal only payments.
		*/
		set ttx.etc=prodctl.drtrpr
		set trn=%CACHE("TRN").getRecord("TRN","ETC=:prodctl.drtrpr")
		set ttx.itc=trn.dc
		set ttx.tamt=+TAMT
		set x=ts.copyTran(ttx)
		}
	
		
	// File transaction
	do ts.postTSet(TPD,BRCD,.PAR())
	
	quit
	
	
GLINI	// Initialize G/L array
 
 	type public String CRCD,GLSC
 	type public Number CC,TYPE
 
	type String TCMT
	type Number CRGL,DRGL
	
	type RecordUTBLGLSC utblglsc=Db.getRecord("UTBLGLSC","GLSC=:GLSC")

	if 'Db.isDefined("TMPBCHOFF","TJD=:%SystemDate,BCHID='BCHLNLATE',JOB=:%ProcessID,DESC='GL',CRCD=:CRCD,TYPE=:TYPE,GLSC=:GLSC,CC=:CC") do {
		set TCMT=$$^MSG(4122)
		// Loan G/L # (Late Charge Rec)
		set DRGL=utblglsc.lgl3

		// Loan G/L # (Late Charge Inc)
		set CRGL=utblglsc.lgll
	 	do BDOFFSET^BCHSOURC("BCHLNLATE","GL",CRCD,TYPE,GLSC,CC,DRGL,CRGL,"MDR","MCR",TCMT)								
	 	
		set TCMT=$$^MSG(6185)			// VAT on late charge										
		set DRGL=utblglsc.lglvatlchgr     	// Loan G/L# (VAT Receivable)
            	set CRGL=utblglsc.lglvatlchgi     	// Loan G/L # (VAT Income)
            	do BDOFFSET^BCHSOURC("BCHLNLATE","VATGL",CRCD,TYPE,GLSC,CC,DRGL,CRGL,"MDR","MCR",TCMT)			
		}
	
	quit		
	

NOCHG(RecordLN ln,RecordDAYENDLCHG delchg)	

	type public Boolean CDF
	type public String RESULT

	/*
 	 If we will not be assessing a charge (RESULT first piece is null) and 
 	 this is a daily late charge plan, set [LN]DLCAF equal to zero.  This 
 	 means that the system has determined that the amounts on the account 
 	 have been satisfied and that the account shouldn't be evaluated for 
 	 late charge assessments on a daily basis until after the next scheduled
 	 payment due date (DAYENDLCHG record handled by BCHLNBLDB in this case).
	*/

	// No charge is calculated
 	if RESULT.piece("|",1).isNull(),CDF set ln.dlcaf = 0 quit

	/*
	 Zero charge is calculated for a non-daily late charge.  The next
	 late charge assessment evaluation will take place after the next 
	 scheduled payment due date.
	*/
	if 'CDF quit

	/*
	 If the calculated amount is zero and this is a daily late charge
	 plan, it means that the account was delinquent but the basis for
	 the calculation produced a zero amount.  The account should be 
	 evaluated on the next system date to determine if a late charge
	 can then be assessed based on the calculation at the time.
 	*/

	type RecordDAYENDLCHG dlzeroch = Db.getRecord("DAYENDLCHG","TJD=:(%SystemDate+1),CID=:CID",1)

        set dlzeroch.lcefd = delchg.lcefd
        set dlzeroch.lchg = delchg.lchg 
	
	set ln.dlcaf = 1
	
	do dlzeroch.bypassSave()

	quit


ZT	// Mumps error (from PROC or FILE section)
 
	set %ZTHALT=0
	// Log mumps error
	do ZE^UTLERR
	
	// System processing error
	set ET=$$^MSG(2575)

	do EXC
	quit

 
ZTEXEC	// Mumps error (from EXEC extrinsic functions)
 
	do ZT
	quit
 
EXC	// Log error in exception file

	// Loan Late Charge Assessment
	set DESC=$$^MSG(7117)_"|1"

	do LOG^UTLEXC($T(+0),"*",DESC,$G(CID),$G(%ZTSEQ),$G(ET),$S($G(CID):BAL,1:""))
	kill ET,%ZTSEQ
	
	quit
 
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
 type String vRECORD,TJD,CID
 for  set vRECORD=vINPUT.piece("|",1),vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD.isNull()  do {
 set TJD=vRECORD.piece($C(9),1)
 set CID=vRECORD.piece($C(9),2)
 do vPROC(TJD,CID)
 }
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
 type public String vBUFOVFL
 type String vRECORD,vrow,TJD,CID
 type Number vcur,vlen
 set vINPUT=vBUFOVFL.get()
 set vBUFOVFL="",vlen=0
 type public ResultSet vRESULT
 for  do { quit:'vcur
 set vcur=vRESULT.next() if 'vcur quit
 set vrow=vRESULT.getRow()_"|",vlen=vlen+vrow.length()
 if vlen>100 set vBUFOVFL=vrow,vcur=0 quit
 set vINPUT=vINPUT_vrow if vlen+24>100 set vcur=0 quit
 }
 set vINPUT=vINPUT.extract(1,vINPUT.length()-1)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
        
	set XTJD=%SystemDate

 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("TJD,CID","DAYENDLCHG","TJD=:XTJD")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	// Teller Posting Date
	set TPD=%SystemDate
	do SOURCE^BCHSOURC("LC","ALL",.%UserID,.BRCD,.%UserClass,.TSDRCID,.TSCRCID)

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
 
 	type public Boolean ER
 
	// Teller Posting Date
	set TPD=%SystemDate
	
	do SOURCE^BCHSOURC("LC","ALL",.%UserID,.BRCD,.%UserClass,.TSDRCID,.TSCRCID)
 	if ER do EXC quit
 
	set STATUS=0
	
	do ^TTXLOK if ER set:'$G(ET) ET="TTXLOK" quit

	quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
  
	do OFFSET^TTXBLD(TPD,BRCD,%UserID,"BCHLNLATE")

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
