HISTCDI		/*

	 This procedure definition replaces [.MRTNS]HISTCDI.M
	 ORIG: JIAQ - 04/29/97
	 DESC: computed data items for HIST and CIFH
	
	 LIBRARY:
	 $$EENDBAL	Equivalent Ending Balance
	 $$ETAMT	Equivalent Transaction Amount
	 $$GETKEY	Comupted data based on TCMT
	 $$HISTRSEQ	Error-Correcting/Reversing Sequence
	 $$HISTRFLG	Error-correct/Reversal Flag
	 $$NOTES	Transaction Notes on File Flag
	 $$REVTRN	Reverse Transaction
	 $$REVTRN2      Reverse/Error Correct transaction
	 $$TCMTBLD	Column Information
	 $$EFDTCMT	SQL TCMT reformated
	 $$EFDTCMT1	SQL TCMT reformatted to a message or single col
	 $$EFDTCMT2	SQL TCMT reformated with <~~> to indicate <cr,lf>
	 $$EFDTCMT3	SQL TCMT reformatted for Xpress
	 $$XMLFLTR	Convert Reserved XML-Specific Characters
	 $$XHS16PC	Returns value taken from [HIST]XHS16 depending on PSQ (Piece sequence)
         $$STMTRD       Statement Detail Category
         $$STMTRDDES    Statement Detail Category Description
         $$STMTRS       Statement Summary Category
         $$STMTRSDES    Statement Summary Category Description
	 $$CHGVAL       Changed Value
	 $$OLDVDESC     Old Value File Maintenance Description
         $$NEWVDESC     New Value File Maintenance Description
	 $$DECBAL	Decrease Balance Amount
	 $$INCBAL	Increase Balance Amount
	 
	---- Revision History ------------------------------------------------
	
	07/2/07 - KinI - CR 28440
		  Reinstated INCBAL and DECBAL sections as respective columns
		  are used by Profile Direct.
		  
	12/29/06 - VANITHAK - CR 27289
		   Modified REVTRN2 section to return either 
		   Error Correction/Reversal transaction byte when either 
		   one of them is occured. This modifies the changes of 
		   CR 22136 which introduced this section and the issue given 
		   in this CR has been tested after the changes with 
		   the new CR.
	
	01/03/07 - SWARNALP - CR 24539
                   Added OLDVDESC and NEWVDESC new sections to return the Old
                   and New Value File Maintenance Descriptions that describes
                   HIST.OLDV and HIST.NEWV values of the corresponding
                   table and column when file maintenance is performed.
	
	12/29/06 - PUTTASWH - CR 24538
		   Added section STMTSRT required for DocuCorp functionality.
		   
	12/18/06 - GIRIDHAL - CR 24544
		   Retrofit of Profile changes from Profile01 to Profile04.
		   Introduced sections EFDTCMT3 and XMLFLTR to reformat SQL
		   TCMT fields for Xpress display.
	
	10/05/06 - SANTHUMS - CR 22136 
		   Modified to add new REVTRN2 section and it is used to 
		   compute HIST.ITC6 and HIST.ITC12 fields.
		   	 
	09/07/06 - KinI - 22447
	   	   Modified EFDTCMT section to check if data item protection 
	   	   scheme is set up on the column(s) referenced in TCMT. 
	   	   After protection value on the column is determined, and it 
	   	   appears that the user class has no access to this columns 
	   	   value, protected column's value in RETURN variable will be 
	   	   reset to null.
	   	   In addition, modified this section to consider different
	   	   formatting when called from SCA234 report to correctly 
	   	   display EFD.SQL formatted field in Oracle. Previously, using 
	   	   EFD.EFDTCMT on the report was causing part of expression 
	   	   after $C(13,10) to be cut out.
	   	   
	   	   Removed INCBAL, DECBAL, STMTSRT and ITC14 sections as 
	   	   respective HIST columns have been obsoleted.
	 	 
	10/04/05 - RussellDS - CR17395
		   Eliminate EQVAMT and PRIN sections.  Computeds that called
		   them have been modified to just have the formula.  No
		   need for a function.
		   
		   Eliminate use of deprecated PSL features.
		   
		   Remove old revision history.
	*/
	
	quit
	

public	EENDBAL(Number ENDBAL,		// Ending Balance
	 	String CRCD,		// Currency Code
	 	Number CID,		// Account Number
	 	Date %SystemDate)	// Transaction Date	
	/*
	 The assignment expression for the computed data item HIST.EENDBAL
	
	 RETURNS:
	 . $$		Equivalent Ending Balance     /TYP=$
	
	 EXAMPLE:
	 	$$EENDBAL^HISTCDI(1000,"DEM",123456)
	*/

	if $G(%EMUCRCD)="" quit ""
	             
	type Public Cache %CUVAR
	type RecordCUVAR cuvar=%CUVAR.getRecord("CUVAR")
	if CRCD="" do {
		set EURCNVDT=cuvar.eurcnvdt		
		#ACCEPT DATE=12/08/03;PGM=John Carroll
		set %SystemCurrency=$S($D(%SystemCurrency):%SystemCurrency,1:cuvar.%crcd)
		if EURCNVDT=""!(%SystemDate'<EURCNVDT) set CRCD=%SystemCurrency
		else  set CRCD=cuvar.origcrcd
		}

	set EMUCRCD=cuvar.emucrcd		
	if EMUCRCD="" quit ""                  

	if CRCD=EMUCRCD do {
		
		type RecordACN acn = Db.getRecord("ACN", "CID=:CID", 1)
		set ORGCRCD = acn.orgcrcd
		if ORGCRCD="" set EENDBAL=""
		else  set EENDBAL=$$EURRND^CRCDUTL(ENDBAL,EMUCRCD,ORGCRCD)
		}
	else  set EENDBAL=$$EURRND^CRCDUTL(ENDBAL,CRCD,EMUCRCD)

	quit +EENDBAL


public	ETAMT(Number TAMT,	// Transaction Amount
	      String CRCD,	// Currency Code
	      Number CID,	// Account Number
	      Date %SystemDate)	// Transaction Date
	/*
	 The assignment expression for the computed data item HIST.ETAMT
	
	 RETURNS:
	 . $$		Equivalent Transaction Amount     /TYP=$
	
	 EXAMPLE:
	 	$$ETAMT^HISTCDI(1000,"DEM",123456)
	*/
		
	if $G(%EMUCRCD)="" quit ""             

	type Public Cache %CUVAR
	type RecordCUVAR cuvar=%CUVAR.getRecord("CUVAR")
	if CRCD="" do {
		set EURCNVDT=cuvar.eurcnvdt     
		#ACCEPT DATE=12/08/03;PGM=John Carroll
		set %SystemCurrency=$S($D(%SystemCurrency):%SystemCurrency,1:cuvar.%crcd)
		if EURCNVDT=""!(%SystemDate'<EURCNVDT) set CRCD=%SystemCurrency
		else  set CRCD=cuvar.origcrcd
		}

	set EMUCRCD=cuvar.emucrcd
	if EMUCRCD="" quit ""                  

	if CRCD=EMUCRCD do {
		
		type RecordACN acn = Db.getRecord("ACN", "CID=:CID", 1)
		set ORGCRCD = acn.orgcrcd
		if ORGCRCD="" set ETAMT=""
		else  set ETAMT=$$EURRND^CRCDUTL(TAMT,EMUCRCD,ORGCRCD)
		}
	else  set ETAMT=$$EURRND^CRCDUTL(TAMT,CRCD,EMUCRCD)

	quit +ETAMT


public	GETKEY(String INPUT)	// Transaction Comment 	

	/*
	 The assignment expressions for computed HISTCDI in HIST file and
	 CIFHCDI in CIFH file

	 RETURNS:
	 . $$		Comupted data based on TCMT	/TYP=T
	
	 EXAMPLE:
	 	$$GETKEY^HISTCDI(HIST.TCMT)
	*/

	new NODE1,NODE2,abc,DATA,TYP,KEY1NAME,KEY2NAME,KEY3NAME,KEY4NAME,KEY1VAL,KEY2VAL,KEY3VAL,KEY4VAL,KEY,FILE,VAL,fsn

	if (INPUT="")!(INPUT'["[")!(INPUT'["]") quit ""

	set NODE1=$F(INPUT,"[") set NODE2=$F(INPUT,"]")-2
	set FILE=$E(INPUT,NODE1,NODE2)
	if FILE["," quit ""

	do fsn^SQLDD(.abc,FILE)			// get primary keys of file
	if (FILE="")!($D(abc)=0) quit ""

	set KEY=$P(abc(FILE),"|",3)
	set VAL=$P(INPUT,"[",1)

	if KEY="" quit ""

	set KEY1NAME=$P(KEY,",",1) set KEY2NAME=$P(KEY,",",2) set KEY3NAME=$P(KEY,",",3) set KEY4NAME=$P(KEY,",",4)
	set KEY1VAL=$P(VAL,",",1) set KEY2VAL=$P(VAL,",",2) set KEY3VAL=$P(VAL,",",3) set KEY4VAL=$P(VAL,",",4)

	if KEY1NAME'="" do {
		set DATA=FILE_"."_KEY1NAME
		set TYP=$$TYP^SQLDD(DATA)	// check data type of the first PK
		if TYP="D" set KEY1VAL=$$DAT^%ZM(KEY1VAL)
		}

	if KEY2NAME'="" do {
		set DATA=FILE_"."_KEY2NAME
		set TYP=$$TYP^SQLDD(DATA)	// check data type of the second PK
		if TYP="D" set KEY2VAL=$$DAT^%ZM(KEY2VAL)
		}

	if KEY3NAME'="" do {
		set DATA=FILE_"."_KEY3NAME
		set TYP=$$TYP^SQLDD(DATA)	// check data type of the third PK
		if TYP="D" set KEY3VAL=$$DAT^%ZM(KEY3VAL)
		}

	if KEY4NAME'="" do {
		set DATA=FILE_"."_KEY4NAME
		set TYP=$$TYP^SQLDD(DATA)	// check data type of the fourth PK
		if TYP="D" set KEY4VAL=$$DAT^%ZM(KEY4VAL)
		}

	set KEY=KEY1NAME_$C(9)_KEY1VAL_$C(9)_KEY2NAME_$C(9)_KEY2VAL_$C(9)_KEY3NAME_$C(9)_KEY3VAL_$C(9)_KEY4NAME_$C(9)_KEY4VAL

	quit KEY

	
public	HISTRFLG(Number CID,	// Account Number
		 Number TSEQ)	// Transaction Sequence Number	
	/*
	 The function is used to compute HIST.HISTRFLG field
	
	 RETURNS:
	 . $$		Error-correct/Reversal Flag	/TYP=L
	
	 EXAMPLE:
	 	write $$HISTRFLG^HISTCDI(1234,1)
	*/

	type RecordHISTR histr = Db.getRecord("HISTR", "CID=:CID,TSEQ=:TSEQ", 1)

	quit histr.revflg


public	HISTRSEQ(Number CID,	// Account Number
		 Number TSEQ)	// Transaction Sequence Number	
	/*
	 The function is used to compute HIST.HISTRSEQ field
	
	 RETURNS:
	 . $$	Error-Correcting/Reversing Sequence	/TYP=N
	
	 EXAMPLE:
	 write $$HISTRSEQ^HISTCDI(1234,1)
	*/

	type RecordHISTR histr = Db.getRecord("HISTR", "CID=:CID,TSEQ=:TSEQ", 1)

	quit histr.rseq


public	NOTES(Number CID,	// Account Number
	      Number TSEQ)	// Transaction Sequence Number	
	/*
	 The function is used to compute HIST.NOTES field
	
	 RETURNS:
	 . $$	Transaction Notes on File Flag  /TYP=L
	
	 EXAMPLE:
	 write $$NOTES^HISTCDI(1234,1)
	*/

	quit Db.isDefined("HISTN","CID,TSEQ")


public	REVTRN(Number CID,	// Account Number
	       Number TSEQ)	// Transaction Sequence Number
	/*
	 The function is used to compute HIST.REVTRN field
	
	 RETURNS:
	 . $$	Reverse Transaction  /TYP=L
	
	 EXAMPLE:
	 write $$REVTRN^HISTCDI(1234,1)
	*/

	quit Db.isDefined("HISTR","CID,TSEQ")


public	REVTRN2(Number CID,	// Account Number
	       Number TSEQ,	// Transaction Sequence Number
	       String ITC,	// Internal Transaction Code
	       Boolean ECREVFLAG) // Error Correction/Reversal Flag
	/*
	 The function is used to compute HIST.ITC6 and HIST.ITC12 fields
	 Error Correction/Reversal Flag value indicate the following.
	 0 - Error Corrected
	 1 - Reversal
	
	 RETURNS:
	 . $$	Reverse/Error Correct Transaction  /TYP=L
	
	 EXAMPLE:
	 write $$REVTRN2^HISTCDI(1234,1,1000102,0)
	*/
	
	if 'ECREVFLAG,(ITC.extract(6)=1) quit 1
	else if ECREVFLAG,(ITC.extract(12)=1) quit 1

	if Db.isDefined("HISTR","CID,TSEQ") quit 1
	else  quit 0
		
		
public	TCMTBLD(Memo SQL)	// SQL EFD transaction (SQL format)

	/*
	 Build TCMT from EFD filer for HIST and CIFH files.
	 
	 The function is used to compute EFD.COLUMN field.
	
	 RETURNS:
	 . $$ Column Information /TYP=T
	
	 EXAMPLE:
	 write $$TCMTBLD^HISTCDI([EFD]SQL)
	*/
	
	new COMMENT,LEN
	
	//I18N=OFF
	set COMMENT=$P($P(SQL,"SET ",2)," WHERE",1)
	
	//I18N=ON
	set LEN=$L(COMMENT)	
	if LEN>400 do {
		set COMMENT=$E(COMMENT,1,400)
		set COMMENT=$P(COMMENT,"=",1,$L(COMMENT,"=")-1)
		for I=$L(COMMENT),-1 quit:$E(COMMENT,I)=" " 
		set COMMENT=$E(COMMENT,1,I-1)
		}

	quit COMMENT

	
public	EFDTCMT(String DATA,		// Transaction Comment
		Number PW,		// "Called by PFW" Indicator
		Number CNT,		// Multiple Columns Update Indicator
		Boolean RPTFLG)		// Called from SCA234 report
	/*
	 Reformat SQL TCMT into tab seperated data item change info.
	 	
	 This section is used to convert a sql command stored in HIST,CIFH
	 or EFD into a memo field. The entire return value has a double quote 
	 on either side of it. This is a requirement of the Power Builder 
	 application. 

	 This label will be called from computed fields 
	 [DTJFM,HIST,CIFH,EFD]EFDTCMT. Also called from EFDTCMT1 and EFDTCMT2 
	 sections and SCA234, Effective-Dated File Maintenance and SCA229, 
	 History Inquiry reports.
	 
	 Examples of incoming DATA:
	  - for CIFH.EFDTCMT DATA="[CIF]ATM:0:1"	 	
	  - for EFD.SQL DATA="UPDATE CIF SET SEX='M',TAXID='333-77-8989' WHERE ACN=44"
	 
	 RETURN:
	 	Change column CIF.SEX
		Sex
		To: M
		
		Change column CIF.TAXID
		TIN/SID
		To: 333-77-8989		
	  or
	  	Change column CIF.SEX To: M
	  	
	  	Change column CIF.TAXID To: 111-23-4444			 	
	*/

	type String FID, ITEM, RETURN, VAL, X, XDATA, ZUX
	
	set PW = PW.get()
	set CNT = CNT.get()
	set RPTFLG = RPTFLG.get()
	
	if (DATA.extract(1,6) = "SET UP") quit ""   // new account setup, not SQL
	set RETURN = ""

	if (DATA.get().isNull()) quit ""

	if (DATA.piece("SET",1)["UPDATE") set FID = DATA.piece("UPDATE",2).piece("SET",1).translate(" ","")
	else  if (DATA["SET") set FID = DATA.piece(".",1).piece("SET",2).translate(" ","")

	if (FID.get().isNull()) , (DATA["INSERT INTO") set FID = DATA.piece("INSERT INTO ",2).piece(" (",1)

	if (FID.get().isNull()) quit ""

	if (DATA["INSERT INTO") do INSERT quit RETURN

	// Retrieve file short name so we can new it
	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:FID", 1)
	if dbtbl1.fsn.isNull() quit ""
	
	/*
	  SQL TO SHORT will convert this sql command into a short name array
	  and a ZUX array. The ZUX array will be used to determine all of the
	  TO values which need to be displayed.

	  Examples of ZUX entries:
	  	ZUX("CIF","SEX")="|M|10|2"
		ZUX("CIF","TAXID")="|333-77-8989|2|1"	  
	*/
	
	set X = $$SQLTOSHR^SQLFUNCS(DATA,FID,.ZUX)

	// Loop through the ZUX array and build the return value for each field.
	set ITEM = ""
	for  set ITEM = ZUX(FID,ITEM).order() quit:ITEM.isNull()  do {
		
		type String DES, TYP, PROTVAL = ""

		// Retrieve description and format type
		type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D", "%LIBS='SYSDEV',FID=:FID,DI=:ITEM", 1)
		set DES = dbtbl1d.des
		set TYP = dbtbl1d.typ

		// Check data item protection scheme on ITEM column from FID table
		#ACCEPT DATE=09/08/05; PGM=Irina Kin; CR=22447
		type ResultSet rs = Db.select(ITEM,FID,,,,"/PROTECTION=2")
		if rs.next() set PROTVAL = rs.getColProt(1)				
		
		// Host calls
		if 'PW do {
			// For SCA234 exclude concatenating $C(13,10)
		
			// Change column FID.ITEM
			set VAL = $$^MSG(2459,FID_"."_ITEM)    
			if RPTFLG.isNull() set VAL = VAL_$C(13,10)_DES_$C(13,10)
			}
		// PFW calls
		else  do {
			set VAL = DES_" ("_FID_"."_ITEM_")" 
			set CNT = CNT + 1
			if (PW = 1) set VAL = VAL_"<~~>"
			if (PW = 2) set VAL = VAL_": "
			}
		
		// Get column's new value
		set XDATA = ZUX(FID,ITEM).piece("|",2)

		if (XDATA.translate(" ","").isNull()) do {
			//   To: Null
			if (PW < 2) set VAL = VAL_$$^MSG(6725) quit        
			set VAL = VAL_$$^MSG(922)           // null
			}
			
		else  do {
			// Convert dates and logical to external format
			if ("DL"[TYP) set XDATA = $$EXT^%ZM(XDATA,TYP)
			
						 
			// If PROTVAL is 3, the user class has no access to the 
			// protected column's value. Replace it with NULL.						
			if PROTVAL=3 set XDATA = ""
			
			if (PW = 2) set VAL = VAL_XDATA quit 
			
			// To: ~p1
			if 'RPTFLG.isNull() set VAL = VAL_" "_$$LTRIM^%ZS($$^MSG(6726,XDATA)) // SCA234 call
			else  set VAL = VAL_$$LTRIM^%ZS($$^MSG(6726,XDATA)) 
			}
			
		// Upper limit is 2000, we have a few control characters to 
		// worry about also 		
		if ((RETURN.length() + VAL.length()) > 1990) quit
		
		if PW set RETURN = RETURN_VAL_"<~~>" quit 

		set RETURN = RETURN_VAL_$C(13,10)_$C(13,10)
		
	}

	/*
	 Return the computed field with quotes around it. Powerbuilder
	 requires this format for the method that our application will
	 display this field. Sanchez reports have been modified to handle
	 the data as it has been formatted.
	*/

	if PW quit RETURN.piece("<~~>",1,RETURN.length("<~~>")-1)
	
	quit $C(34)_RETURN.piece($C(13,10),1,RETURN.length($C(13,10))-2)_$C(34)

	
private	INSERT	// Return values for non-literal keys of a sql insert record

	/*	
	 This label is called from EFDTCMT when it detects that the SQL
	 command is a insert rather then a update. This function will
	 return information only about the access keys into the new record
	 When one of the keys is sequential and has not been determined
	 the value will indicate that also.

	 Example:
	 INSERT INTO LNPL3A (RDTE,PLTYP,ROFC,PLRES,CID,RSEQ)
	    VALUES ('56993',0,1,1,50085,LNPL3A.NEXTVAL)

	 Returns:
	 Create new LNPL3A record
	 LNPL3A.CID
	 Account Number
	 Value: 50085
	 LNPL3A.RSEQ
	 Sequence Number
	 Value: Next Available Sequence
	*/

	new ACCKEYS,INTO,J,VALUES,X,columns,fsn,i,map,table,tok,vdd,v,values

	// Determine which fields should be returned
	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:FID", 1)
	set ACCKEYS = dbtbl1.acckeys
	
	// Use SQL coding to breakup the sql statement
	set X=$$TOK^SQL(DATA,"INTO,VALUES",.tok)
	
	//determine columns in the sql statement
	set table=$$FUN^SQL(INTO,.columns,tok)
	
	if $G(columns)="" set columns=$$LIST^SQLDD(table,1)    
	
	//set data values into an array by position in the record
	for i=1:1:$L(VALUES,",") do {
		set v=$P(VALUES,",",i)                // Move value into array
		if v[$C(0) set v=$$UNTOK^%ZS(v,.tok)  // Get original raw data
		set v=$$TRIM^%ZS(v)                   
		if $E(v)="'" set v=$$QSWP^%ZS(v,"'","""")
		set values(i)=v
	}

	kill VALUES
	
	if columns[$C(0) set columns=$$UNTOK^%ZS(columns,.tok)
	
	/*
	  setup array of the access keys so that the data values can be stored
	  easily in it.
	*/

	for J=1:1 quit:$P(ACCKEYS,",",J)=""  do {
		// do not setup literal keys
		if $P(ACCKEYS,",",J)["""" quit 
		if +$P(ACCKEYS,",",J)=$P(ACCKEYS,",",J) quit 
		set ACCKEYS($P(ACCKEYS,",",J))=""
	}

	for J=1:1 quit:$P(columns,",",J)=""  if $D(ACCKEYS($P(columns,",",J))) set ACCKEYS($P(columns,",",J))=$G(values(J))
	set ITEM="" set RETURN=$$^MSG(2460,FID)        //Add new FID record
	if 'PW set RETURN=RETURN_$C(13,10)
	if PW set RETURN=RETURN_"<~~>"
	
	/*
	  we have the data items and values for the ACCKEYS now build
	  the record that will be returned.
	*/

	for  set ITEM=$O(ACCKEYS(ITEM)) quit:ITEM=""  do {
		
		type String DES, TYP

		//get description and format type of the field
		type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D", "%LIBS='SYSDEV',FID=:FID,DI=:ITEM", 1)
		set DES = dbtbl1d.des
		set TYP = dbtbl1d.typ

		if 'PW do {
			set VAL=$$^MSG(2459,FID_"."_ITEM)    //"Change column FID.DATAITEM"
			set VAL=VAL_$C(13,10)_DES_$C(13,10)
		}
		else  do {
			set VAL=DES_" ("_FID_"."_ITEM_")"
			set:PW=1 VAL=VAL_"<~~>"
			set:PW=2 VAL=VAL_" "
		}

		// convert dates and logical to external format
		if "D"[TYP set ACCKEYS(ITEM)=$$EXT^%ZM(ACCKEYS(ITEM),TYP)

		//check for sequencial number
		if ACCKEYS(ITEM)["NEXTVAL" set ACCKEYS(ITEM)=$$^MSG(2464)     //Next available sequence

		set VAL=VAL_$$LTRIM^%ZS($$^MSG(2461,ACCKEYS(ITEM)))   //Value: ~p1

		if PW set RETURN=RETURN_VAL_"<~~>" quit 

		set RETURN=RETURN_VAL_$C(13,10)_$C(13,10)
	}

	quit 


public	EFDTCMT1(String DATA)	// Transaction Comment

	/*	
	Reformat SQL tcmt fields for P/W display.

	This label is used for lookup table purposes only.
	In order to prevent display problems, if more then one
	column has been changed, a generic message(3481) is displayed.

	EXAMPLE:
	 	write $$EFDTCMT^HISTCDI("UPDATE CIF SET TAXID='333-77-8989' WHERE ACN=44")
	RETURNS:	
		TIN/SID (CIF.TAXID)<~~>To: 333-77-8989
	*/

	type Number CNT = 0
	type String RET

	set RET = $$EFDTCMT(DATA,1,.CNT,)
	
	// Changes made to multiple attributes
	if (CNT > 1) quit $$^MSG(3481)
	             
	if (CNT = 0) quit RET.piece("<~~>",1)

	quit RET


public	EFDTCMT2(String DATA)	// Transaction Comment

	/*
	Reformat SQL tcmt fields for P/W display.
	
	This label was designed for use by P/W only. It returns changed
	field infomation in a single line per change. There will be no
	blank lines between changes.  This is being done to help solve
	a P/W issue which deals with the display of more then one page of data.
	
	EXAMPLE:
	 	write $$EFDTCMT^HISTCDI("UPDATE CIF SET SEX='M',TAXID='333-77-8989' WHERE ACN=44")
	RETURNS:
		Sex (CIF.SEX): M<~~>TIN/SID (CIF.TAXID): 333-77-8989
	*/
	
	quit $$EFDTCMT(DATA,2,,)

Public EFDTCMT3(SQLUPD)	// Reformat SQL TCMT fields for Xpress display
	/* This function is designed to parse out an update statement and
	reformat it to an XML message.

	Arguments:
		. SQLUPD	/TYPE=T/REQ/MECH=REF
			SQL update statement.
	Returns:
		. $$ 		/TYPE=T
			XML String with the following information:
			-	Table name
			-	Column name
			-	Column description
			-	Column data type
			-	Column length
			-	New column value
			-	Lookup table name,key,description column
	
			XML DTD:	
			<!ELEMENT table (name,column)>
			<!ELEMENT column (name,desc,type,length,value,dropdown)+>
			<!ELEMENT name (#PCDATA)>
			<!ELEMENT desc (#PCDATA)>
			<!ELEMENT type (#PCDATA)>
			<!ELEMENT length (#PCDATA)>
			<!ELEMENT value (#PCDATA)>
			<!ELEMENT dropdown (#PCDATA)>
						
			Example:
			W $$EFDTCMT3^HISTCDI("UPDATE LN SET ALPDUE=6 WHERE 
			CID=12345")
			
			"<table><name>LN</name><column><name>ALPDUE</name>
			<desc>Automatic Loan Payment Due Method</desc><type>
			N</type><length>1</length><value>6</value><dropdown>
			STBLALPDUE,KEY,FMDESC</dropdown></column></table>"

	Limitation: This computation will not return lookup table name if 
		lookup table has multiple primary key. The reason 
		is that there is no way to know first/previous primary key
		value. For example [UTBLIACM]. Its keys are GRP and IACM.
		Since no CID is passed into - the GRP is unknown.
		Also no lookup will be returned if table does not have FMDESC
		column.
	*/

	type String ARRUPD,COLUMN,RETURN,TABLE

	if SQLUPD'["UPDATE" quit ""

	set TABLE=$P(SQLUPD," ",2)

	// Parse update statement out and place it into an array. Returns ER.
	if $$SQLTOSHR^SQLFUNCS(SQLUPD,TABLE,.ARRUPD) quit ""

	set RETURN="<table><name>"_$$XMLFLTR(TABLE)_"</name>"

	set COLUMN=""
	for  set COLUMN=ARRUPD(TABLE,COLUMN).order() quit:COLUMN=""  do {
		type String TBLATTR
				
		set RETURN=RETURN_"<column><name>"_$$XMLFLTR(COLUMN)_"</name>"
		
		type RecordDBTBL1D dbtbl1d=Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=TABLE,DI=COLUMN",1)
		set RETURN=RETURN_"<desc>"_$$XMLFLTR(dbtbl1d.des)_"</desc>"
		set RETURN=RETURN_"<type>"_$$XMLFLTR(dbtbl1d.typ)_"</type>"
		set RETURN=RETURN_"<length>"_dbtbl1d.len_"</length>"
		set RETURN=RETURN_"<value>"_$$XMLFLTR(ARRUPD(TABLE,COLUMN).piece("|",2))_"</value>"
		
		/* If lookup table has more then 1 primary key - skip it 
		(see limitation) */
		set TBLATTR=$$FMTABLE^DBSMACRO(TABLE_"."_COLUMN)
		if (TBLATTR'=""),(TBLATTR'[",") do {
			set RETURN=RETURN_"<dropdown>"_$$XMLFLTR($P($P(TBLATTR,"[",2),"]",1))
			set RETURN=RETURN_","_$$XMLFLTR($P(TBLATTR,"]",2))_",FMDESC</dropdown>"
			}
		set RETURN=RETURN_"</column>"
	}
	
	set RETURN=RETURN_"</table>"

	quit RETURN
	
XMLFLTR(STRING)	// Convert Reserved XML-Specific Characters
	/* 
	Arguments:	
		.STRING 	String to filter	/TYPE=T/REQ/MECH=REF

	Format:	$$XMLFLTR^HISTCDI("STRING")

	Returns:
		.$$ 		Filtered string		/TYPE=T
	
	Replace the following characters with corresponding codes:
		< - &lt;
		> - &gt;
		& - &amp;
		" - &quot;
		' - &apos;
	*/

	type String CHAR,I,EDITED
	
	if (STRING'["<"),(STRING'[">"),(STRING'["&"),(STRING'[""""),(STRING'["'") quit STRING
	
	set EDITED=""
	for I=1:1:$L(STRING) set CHAR=$E(STRING,I) do {
		if CHAR="<" set EDITED=EDITED_"&lt;" quit
		if CHAR=">" set EDITED=EDITED_"&gt;" quit
		if CHAR="&" set EDITED=EDITED_"&amp;" quit
		if CHAR="""" set EDITED=EDITED_"&quot;" quit
		if CHAR="'" set EDITED=EDITED_"&apos;" quit
		set EDITED=EDITED_CHAR
	}

	quit EDITED


public	XHS16PC(Number CID,	// Account Number
		Number TSEQ,	// Transaction Sequence Number
		Number PSQ)  	// Piece Sequense	
		       
	/*
	 Returns value taken from HIST.XHS16 depending on PSQ
 
         RETURNS:
         . $$   Error-Correcting amount   /TYP=$
 
         EXAMPLE:
         write $$XHS16PC^HISTCDI(1234,1,30)
        */
	
	type RecordHIST hist = Db.getRecord("HIST", "CID=:CID,TSEQ=:TSEQ", 1)
	
	quit hist.xhs16.piece("#", PSQ)


public	STMTRD(String XETC)	// External Transaction Code	

	// Statement Detail Category Code

        set XETC=$G(XETC)
	if XETC="" quit ""
        
        type RecordTRN trn = Db.getRecord("TRN", "ETC=:XETC", 1)
        
        quit trn.stmtrd

        
public STMTRS(String XETC)	// External Transaction Code

	// Statement Summary Category Code

        set XETC=$G(XETC)
        if XETC="" quit ""
        
        type RecordTRN trn = Db.getRecord("TRN", "ETC=:XETC", 1)
        
        quit trn.stmtrs       

        
public	STMTRDDS(String XETC)	// External Transaction Code

	// Statement Detail Category Description

        set XETC=$G(XETC)
        if XETC="" quit ""
        
        type RecordTRN trn = Db.getRecord("TRN", "ETC=:XETC", 1)
        
        if trn.stmtrd.isNull() quit ""

	type RecordUTBLSTMTR ustmtr = Db.getRecord("UTBLSTMTR", "CAT=:trn.stmtrd", 1)
	
	quit ustmtr.des
	
        
public	STMTRSDS(String XETC)	// External Transaction Code	

	// Statement Summary Category Description

        set XETC=$G(XETC)
        if XETC="" quit ""
        
        type RecordTRN trn = Db.getRecord("TRN", "ETC=:XETC", 1)
        
        if trn.stmtrs.isNull() quit ""

	type RecordUTBLSTMTR ustmtr = Db.getRecord("UTBLSTMTR", "CAT=:trn.stmtrs", 1)
	
	quit ustmtr.des
	

public	CHGVAL(String TCMT,	// Transaction Comment
	       Number p) 	// Piece Number
	       
               /*
               The function is used to compute HIST.CHGVAL
 
               EXAMPLE:
               W $$CHGVAL^CIFCDI(HIST.TCMT,4)
               */

       new DI,VALUE
       
       if $L(TCMT,":")<3 quit ""       // Return null if not data item
       set DI=$$getdi(TCMT)
       if DI="" quit ""
       set VALUE=TCMT.piece(":",p)     // Get Value

       do {          		       // Format date values
                new X
                set X=DI
		new DI
                set DI=X
                do ^DBSDI
 		if ER set ER=0 set RM="" quit  // Leave original value if error
 		if $G(DI(9))="D" set VALUE=$$DAT^%ZM(VALUE,$G(%MSKD))
        }
        
	// msg text NULL
        if VALUE="" set VALUE=$$^MSG(922)
        
        quit VALUE


private	getdi(String TCMT)	// Transaction Comment

	// Get DI from TCMT, return null if no data item
        new di
        
	set di=TCMT.piece(":",1)
        if di'["[" quit ""
        set di.piece("[",1)=""   // Strip any keys
        
        quit di    
        
public STMTSRT(String XETC)	// Statement Extract History Sort Column

        type String STMTRD      
        
        set XETC=XETC.get()
        if XETC.isNull() quit ""
        
        type RecordTRN trn=Db.getRecord("TRN","ETC=:XETC",1)
        set STMTRD=trn.stmtrd
        if STMTRD.isNull() quit ""
        
        type RecordUTBLSTMTR fUTBLSTM=Db.getRecord("UTBLSTMTR","CAT=:STMTRD",1)       
        quit fUTBLSTM.srt

public OLDVDESC(String TCMT)	// Get Old Value File Maintenance Description

	/*
	 ARGUMENTS:
         . TCMT    Transaction Comment   /TYP=T/REQ/MECH=VAL
 
         RETURNS:
         . $$        HIST.OLDVDESC - Old Value File Maintenance Description /TYP=T
                                     Computed data based on TCMT
         EXAMPLE:
                 $$OLDVDESC^HISTCDI(HIST.TCMT)
	*/
        type public Boolean ER
        
        type String EXPR,FID,FMDESC,FMTBL,KEY2,KEY3,KEYS,OLDV
       
        // Determine the HIST.FMTABLE value (the 6th ":" piece of TCMT). 
        set FMTBL=TCMT.piece(":",6)
 
        /*
          If there is no FMTABLE value or it is not a valid DBTBL1.FID File Name, 
          quit with the HIST.OLDV Old Value
        */
        set OLDV=$$oldv^CIFDBS(TCMT)
        if (FMTBL="")!(FMTBL'["[") quit OLDV
        
        // Determine the DBTBL1.ACCKEYS Primary Keys.
        set FID=FMTBL.piece("]",1)      // e.g., [STBLIACM]IACM --> [STBLIACM
        set FID=FID.piece("[",2)        // e.g., [STBLIACM --> STBLIACM
 
        /*
          Determine the second piece of ACCKEYS (comma delimited).
          This represents the second access key for the description lookup.
        */
        type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","""SYSDEV"",FID")
        set KEYS=dbtbl1.acckeys
 
        set KEY2=KEYS.piece(",",2)
        set KEY3=KEYS.piece(",",3)
 
        /*
          STBL, UTBL, and CTBL tables that have more than two keys will   
          not return the text values for HIST.OLDVDESC and HIST.NEWVDESC.
          These instances will return the HIST.OLDV Old Value.
        */
        if KEY3.get()'="" quit OLDV
 
        /*
          Use $$^SQL since PSL methods expect definite file name passed in
          while we deal with FID variable not recognizable by the compiler
        */
        set EXPR="Select FMDESC from "_FID_" where "_KEY2_"=:OLDV"
        set ER=$$^SQL(EXPR,,,.FMDESC)
        if (ER)!(FMDESC="") quit OLDV
 
        quit FMDESC
 
 
NEWVDESC(TCMT)  ; Public ; Get New Value File Maintenance Description

        /*
        ARGUMENTS:
        . TCMT    Transaction Comment   /TYP=T/REQ/MECH=VAL
 
        RETURNS:
        . $$        HIST.NEWVDESC - New Value File Maintenance Description /TYP=T
                                     Computed data based on TCMT
        EXAMPLE:
                $$NEWVDESC^HISTCDI(HIST.TCMT)
 
        */
        type public Boolean ER
        
        type String EXPR,FID,FMDESC,FMTBL,KEY2,KEY3,KEYS,NEWV
        
        // Determine the HIST.FMTABLE value (the 6th ":" piece of TCMT).
        set FMTBL=TCMT.piece(":",6)
 
        /*
          If there is no FMTABLE value or it is not a valid DBTBL1.FID File Name, 
          quit with the HIST.NEWV New Value
        */
        set NEWV=$$newv^CIFDBS(TCMT)
        if (FMTBL="")!(FMTBL'["[") quit NEWV
  
        // Determine the DBTBL1.ACCKEYS Primary Keys.
        set FID=FMTBL.piece("]",1)      // e.g., [STBLIACM]IACM --> [STBLIACM
        set FID=FID.piece("[",2)        // e.g., [STBLIACM --> STBLIACM
  
        /*
          Determine the second piece of ACCKEYS (comma delimited).
          This represents the second access key for the description lookup.
        */
        type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","""SYSDEV"",FID")
        set KEYS=dbtbl1.acckeys
 
        set KEY2=KEYS.piece(",",2)
        set KEY3=KEYS.piece(",",3)
 
        /*
          STBL, UTBL, and CTBL tables that have more than two keys will 
          not return the text values for HIST.OLDVDESC and HIST.NEWVDESC.
          These instances will return the HIST.OLDV Old Value.
        */
        if KEY3.get()'="" quit NEWV
  
        /*
          Use $$^SQL since PSL methods expect definite file name passed in
          while we deal with FID variable not recognizable by the compiler
        */
        set EXPR="Select FMDESC from "_FID_" where "_KEY2_"=:NEWV"
        set ER=$$^SQL(EXPR,,,.FMDESC)
        if (ER)!(FMDESC="") quit NEWV
  
        quit FMDESC
        
        
public	DECBAL(	String ITC,	// Internal Transaction Code
		Number CID,	// Account Number
		String ETC,	// External Transaction Code
		String TAMT)	// Transaction Amount	

	/*	
	Return decrease balance amount.
	
	Return NULL, if ETC is equaled to NULL.
	Return TAMT, if balance is decreased.
	Return NULL, if balance is not decreased.
	*/

	if ETC.isNull() quit ""

	type Number DC
	
	type RecordACN acn = Db.getRecord("ACN", "CID=:CID", 1)
	
	set DC = +ITC.extract(1)
	if (DC = acn.trb) quit +TAMT

	quit ""
	
	
public	INCBAL(	String ITC,	// Internal Transaction Code
		Number CID,	// Account Number
		String ETC,	// External Transaction Code
		String TAMT)	// Transaction Amount
	/*
	Return increase balance amount.

	Return NULL, if ETC is equaled to NULL.
	Return TAMT, if balance is increased.
	Return NULL, if balance is not increased.
	*/

	if ETC.isNull() quit ""

	type Number DC
	
	type RecordACN acn = Db.getRecord("ACN", "CID=:CID", 1)

	set DC = +ITC.extract(1)
	if (DC '= acn.trb) quit +TAMT

	quit ""

	                            
 #OPTION ResultClass ON
Public String vSIG()	quit "60837^62693^Irina Kin^29751"	// Signature - LTD^TIME^USER^SIZE
