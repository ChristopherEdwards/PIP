APPLDEF	 // 
 // ORIG: SKLYUTD - 10/20/1999
 // DESC: Loan Applicaton to New Loan Defaults
 // 
 // ---- Comments --------------------------------------------------------
 // 
 // ---- Revision History ------------------------------------------------
 /*
	11/04/03 - CARROLLJ - CR7239
		   Modified call to ^UINDX to pass correct parameters.

	09/26/02 - CARROLLJ - 43583
		   Added parameter to LNCNVST call.

	02/25/02 - EDWARDSM - 44167
		   Updated copy section, FEEGRPO now resides in file PRODDFTL.
		   Changed "PRODCTL" to "PRODDFTL". The data item FEEGRP was
		   renamed to FEEGRPO and moved to PRODDFTL so that the fee
		   group that defaults from the product type could be changed
		   during account creation.

	08/24/00 - SKLYUTD - 41497
		   Modified sections insert and update to add a checking on the
		   column data type before building sql statement.  Previously
		   all the values were passed in as a strings.

	08/02/00 - SKLYUTD - 41312
		   Modified section calc1 to set $g around ln("INTMAT") var.
		   Was causing an undefined if interest matrices not defined
		   on product type.

	07/11/00 - SKLYUTD - 41011
		   Modified section copy to make sure that NULL defaults from
		   UTBLLAPPD do not overlay product parameters.

	05/31/00 - SKLYUTD - 39544:01
		   Modified section copy to make sure that defaults from
		   UTBLLNAPPD do not overlay passed in parameters.

	05/01/00 - SKLYUTD - 39544
		   Modified section calc2 to only reset CNTDR for the
		   refinnaced loan.

	04/04/00 - SKLYUTD - 37656
		   Modifications made to insert and update sections to
		   populate "FPLDG" and "PCTPLDG" columns in LNCOL file with
		   values from LNAP1COL file to provide the same type of
		   functionality available when adding collateral for a loan.

	04/03/00 - SKLYUTD - 36841:013
		   Modified section calc1 to set ln("PMT") and ln("PMTPI") to
		   null if not defined instead of if defined.  Fixes a problem
		   where incorrect payment amounts were defaulted to a new loan.

	03/29/00 - SKLYUTD - 36841:012
		   Modified section copy to populate FEEGRPO and NFPLNORG loan
		   field with a value from prodctl.feegrp and prodctl.fpln.
		   Because that value was coming in from prodctl not proddftl 
		   UPRODDFT procedure was not populating it.

	03/27/00 - SKLYUTD - 37740
		   Added section chksps to handle dafaulting values with
		   apostrophe in them.

	03/24/00 - KESTELMANN - 36841
		Added code to set up account title information from CIF
		file.  It fixes the problem with restriction PCIF (Pledged
		account owners not owners of loan account).

	03/08/00 - SKLYUTD - 36841:004
		   Added section calc,calc1,ln2dft,dft2ln to corectly calculate
		   payment amounts.  Simulate logic of loan creation process.
		   Also some clean up to resolve problems discovered during
		   testing.

	02/24/00 - KESTELMANN - 37160
		Modified insert and update section to add check for SFRE.
 		If SFRE set, do not insert record into CMBSTM.

	12/28/99 - SKLYUTD - 33756:12
		Modified section copy to set up dft("LN.GENPRN") variable to 0.
		The value of LN.GENPRN (Generate Promissory Number Flag) will
		be checked by the system to verify whether a promissory number 
		should be generated by the disbursement transaction.

	12/15/99 - SKLYUTD - 33756:07
		Modified insert section to properly set ans sql insert statment
		in case there are multiple owners on the application.

 	12/13/99 - SKLYUTD - 33756:05
		Removed the following line of code:
		if $g(data("BRCD"))'="" set dft("LN.BOO")=data("BRCD").
		Change to the LNAP1 filer AU_STS trigger as of 12/13/99 
		fixes the problem where dft("LN.BOO") was not being set.
 */
	quit

start(ACN,APPS,APPNUM,CID,data,mode)
	new TABLE,COLUMN,RELTABLE,RELCOL,IN
	if mode'=3 new FROMV,FRMCOLL,ACNADDR,RELCIF,dft

	// If no defaults for product are defined
	// I guess we can't do much?
	if '$D(data)&(mode=0) quit	// maybe an error message???
	// First get all the product type and r&r and lld defaults
	do calc(.data,mode,.dft) if $g(ER) s errmess=$g(RM) quit
	// Second get all the defaults from the application record.
	do appl quit:$G(ER)
	// Copy all the loan application defaults into dft array.  Prepare for sql
	do copy quit:$G(ER)
	// Create/File Maintain Loan account
	do default(mode) quit:$G(ER)
	// mode three (3) is to test the results no acctual defaulting will take place
	quit

	//----------------------------------------------------------------------
appl	// Application defaults
	//----------------------------------------------------------------------
	//Get all the clolumns from UTBLLNAPPD
	new rs
	type ResultSet rs
	set rs=Db.select("TABLE,COLUMN,RELTABLE,RELCOL","UTBLLNAPPD","MODE=0","TABLE ASC, RELTABLE ASC")
	
	if rs.isEmpty() quit

	//populate the arrays
	set (TABLE,COLUMN,RELTABLE,RELCOL)=""

	for  quit:'rs.next()  do {
		set TABLE=rs.getCol(1)
		set COLUMN=rs.getCol(2)
		set RELTABLE=rs.getCol(3)
		set RELCOL=rs.getCol(4)
		// IN column index
		set IN(TABLE,RELTABLE,COLUMN,RELCOL)=""
		// from value array
		set FROMV(RELTABLE,RELCOL)=""
	}

	// get defaults 
	do getdef

	quit

	//----------------------------------------------------------------------
getdef	// Build an sql to get the defaults from the tables specified in FROMV
	// array.  Populate FROMV array with results of sql.
	//----------------------------------------------------------------------
	new TABLE,WHERE,COL,collist,colcnt

	set (TABLE,WHERE,COL)=""

	for  set TABLE=$o(FROMV(TABLE)) quit:TABLE=""  do {
		set collist="",colcnt=0,WHERE="",COL=""
		for  set COL=$o(FROMV(TABLE,COL)) quit:COL=""  do {
			if collist=""  set collist=COL
			else  set collist=collist_","_COL
			set colcnt=colcnt+1
		}

		// Set up where clause
		// Loan Application
		if TABLE="LNAP1" set WHERE="LNAP1.ACN=:ACN and LNAP1.APPS=:APPS"
		// Loan ownership - primary owner only.(*for now*)
		if TABLE="LNAP1OWN" set WHERE="LNAP1OWN.ACN=:ACN and LNAP1OWN.APPS=:APPS and LNAP1OWN.APPNUM=:APPNUM and LNAP1OWN.SECACN=:ACN"
		// Customer File - only for the primary owner
		if TABLE="CIF" set WHERE="CIF.ACN=:ACN"

		// If where clause is not set - get out - invalid table.
		if WHERE="" quit

		set sqlexpr=collist_" FROM "_TABLE_" WHERE "_WHERE
		new data
		do SELECT^SQL(sqlexpr,,,.data)
		// populate that data
		new i
		for i=1:1:colcnt do {
			set COL=$o(FROMV(TABLE,COL))
			set FROMV(TABLE,COL)=$p(data,$c(9),i)
		}

	}

	// Colateral Record Information - uses FRMCOLL array
	new rscol,fcol
	set fcol=0
	type ResultSet rscol
	set rscol=Db.select("COLL","LNAP1COL","ACN=:ACN AND APPS=:APPS AND APPNUM=:APPNUM")

	if 'rscol.isEmpty() for  quit:'rscol.next()  do {
		new COLL,colist,data,sql,where,i,val,di
		set COLL=rscol.getCol(1)
		set fcol=fcol+1		// number of collateral records
		set colist=$$LIST^SQLOADER("LNAP1COL")	; get column list
		set where="ACN=:ACN AND APPS=:APPS AND APPNUM=:APPNUM AND COLL=:COLL"
		set sql=colist_" FROM LNAP1COL WHERE "_where
		// get column values
		do SELECT^SQL(sql,,,.data)
		// start with 4 because the first 4 columns are keys.
		for i=4:1:$l(colist,",") do {
			set val=$P(data,$C(9),i)	// column value
			if val="" quit			// null value
			S di=$P(colist,",",i)		// column name
			set FRMCOLL(fcol,"COL."_di)=val
		}
		set FRMCOLL(fcol,"COL.COLL")="COL.NEXTVAL"
		set FRMCOLL=fcol
		// set up primary collateral code for the loan
		if fcol=1 set dft("LN.COLCD")=FRMCOLL(fcol,"COL.COLCD")
	}
	else  set FRMCOLL=fcol 	// number of collateral records

	// ACNADDR,RELCIF info
	new rs2
	type ResultSet rs2
	set rs2=Db.select("SECACN,MAD1,MAD2,MAD3,MCITY,MCNTRY,MSTATE,MZIP,RELCOD,RELDESC","LNAP1OWN","ACN=:ACN AND APPS=:APPS AND APPNUM=:APPNUM","RELCOD ASC")

	new cnt set cnt=0
	if 'rs2.isEmpty() for  quit:'rs2.next()  do {
		set cnt=cnt+1
		N SECACN S SECACN=rs2.getCol(1)
		// ACNADDR
		if SECACN=ACN do {
			// Primary owner address only
			set ACNADDR("ACNADDR.AD1")=rs2.getCol(2)
			set ACNADDR("ACNADDR.AD2")=rs2.getCol(3)
			set ACNADDR("ACNADDR.AD3")=rs2.getCol(4)
			set ACNADDR("ACNADDR.CITY")=rs2.getCol(5)
			set ACNADDR("ACNADDR.STATE")=rs2.getCol(7)
			set ACNADDR("ACNADDR.CNTRY")=rs2.getCol(6)
			set ACNADDR("ACNADDR.MZIP")=rs2.getCol(8)
			set ACNADDR("ACNADDR.CID")=CID
		}

		// RELCIF
		set RELCIF(cnt,"RELCIF.ROLE")=rs2.getCol(9)
		set RELCIF(cnt,"RELCIF.ACN")=rs2.getCol(1)
		//set RELCIF(cnt,"RELCIF.OWNER")=ACN
		set RELCIF(cnt,"RELCIF.CID")=CID
		
		// Also set up account title information here
		if cnt>4 quit
		n rs21,pref,xnam
		type ResultSet rspref
		set rs21=Db.getOneRow("NAM,PREF","CIF","SECACN")
		set xnam=$P(rs21,$C(9),1)
		set pref=$P(rs21,$C(9),2)
		if pref'="" set pref=pref_" " //prefiX
		set dft("LN.TITLE"_cnt)=pref_xnam
		if SECACN'=ACN set dft("LN.TITLE"_cnt)=dft("LN.TITLE"_cnt)_" "_rs2.getCol(10)

	}

	// Set up Bulk Repayment next date and amount(only first)
	new rs4,stop
	type ResultSet rs4
	set rs4=Db.select("SPD,AMT","LNAP1SCH","ACN=:ACN AND APPS=:APPS")
	set stop=0

	if 'rs4.isEmpty() for  quit:('rs4.next())!(stop=1)  do {
		set dft("LN.BLKPRINND")=rs4.getCol(1)
		set dft("LN.BLKPRINPAN")=rs4.getCol(2)
		// only set up the first set
		set stop=1
	}

	quit
	//----------------------------------------------------------------------
copy	// Copy defaults into dft array here.
	// By this time we will have all of the loan defaults defined
	// by product, rules and results, low level defaults
	// and loan application.
	//----------------------------------------------------------------------
	new intbl,incol,ftbl,fcol,table,col
	set (intbl,incol,ftbl,fcol)=""
	for  set intbl=$o(IN(intbl)) quit:intbl=""  do {
		for  set ftbl=$o(IN(intbl,ftbl)) quit:ftbl=""  do {
			for  set incol=$o(IN(intbl,ftbl,incol)) quit:incol=""  do {
				for  set fcol=$o(IN(intbl,ftbl,incol,fcol)) quit:fcol=""  do {
					// Make sure that defaults from UTBLLAPPD do not overlay passed in parameters
					if (incol="TYPE")!(incol="ACN")!(incol="BOO")!(incol="CRCD")!(incol="TRM")!(incol="CID")!(incol="AMTREQ")!(incol="CRLMT")!(incol="DIST1FRE")!(incol="PMTPI")!(incol="FPA") quit
					if $g(FROMV(ftbl,fcol))="" quit
					set dft(intbl_"."_incol)=FROMV(ftbl,fcol)
				}
			}
		}
	}
	set dft("LN.CID")=CID
	// Set up "Genarate Promissory Number Flag" to 0 ("no").
	set dft("LN.GENPRN")=0
	// DS 03/29/00
	new TYPE set TYPE=dft("LN.TYPE")
	set dft("LN.FEEGRPO")=Db.getOneRow("FEEGRPO","PRODDFTL","TYPE")
	set dft("LN.NFPLNORG")=Db.getOneRow("FPLN","PRODCTL","TYPE")
	quit

	//----------------------------------------------------------------------
default(mode)	// 
	// Create a buffer - populate it with an SQL inserts or updates
	// (depending on a mode), and file it.
	//----------------------------------------------------------------------
	if mode=3 quit			// Test mode
	if mode=0 do insert quit	// insert logic
	if mode=1 do update quit	// update logic
	
	quit

	//----------------------------------------------------------------------
insert	// insert logic
	//----------------------------------------------------------------------
	new sql,tbl,col,val,inv,colist,valist,cnt,lncolist,typ

	set (sql,tbl,col,val,inv,colist,valist)=""
	set sql="BUFFER NEW LNAPP INSERT INTO LN"	// set up initial buffer
	// Loan (dft will only contain entries for LN)
	for  s inv=$o(dft(inv)) quit:inv=""  do {
		set tbl=$p(inv,".",1),col=$p(inv,".",2)
		set val=$g(dft(inv))
		if tbl'="LN" quit	// Invalid table
		if val="" quit		// Null value

		if colist="" set colist=col
		else  set colist=colist_","_col

		// Check if a value contains a "'" and parse it.
		if val["'" do chksps(.val)

		//  Check the data type
		set typ=$$TYP^SQLDD(inv)
		if valist="" do {
			if "$BLN"[typ set valist=val
			else  set valist="'"_val_"'"
		}
		else  do {
			if "$BLN"[typ set valist=valist_","_val
			else  set valist=valist_","_"'"_val_"'"
		}

	}

	set sql=sql_" ("_colist_") VALUES ("_valist_")"
	// Process first buffer
	set ER=$$^SQL(sql,,,.errmess) 
	if ER do { 
		if errmess="" set errmess=$g(RM)
		new ER	// Need to new ER here because SQL will redefine it.
		set ER=$$^SQL("BUFFER DELETE LNAPP")
	}
	quit:ER

	// Set Up entries for ACNADDR
	set (sql,tbl,col,val,inv,colist,valist)=""
	set sql="BUFFER ADD LNAPP INSERT INTO ACNADDR"
	for  set inv=$o(ACNADDR(inv)) quit:inv=""  do {
		set tbl=$p(inv,".",1),col=$p(inv,".",2)
		set val=$g(ACNADDR(inv))
		if tbl'="ACNADDR" quit	// Invalid table
		if val="" quit		// Null value

		if colist="" set colist=col
		else  set colist=colist_","_col


		// Check if a value contains a "'" and parse it.
		if val["'" do chksps(.val)

		//  Check the data type
		set typ=$$TYP^SQLDD(inv)
		if valist="" do {
			if "$BLN"[typ set valist=val
			else  set valist="'"_val_"'"
		}
		else  do {
			if "$BLN"[typ set valist=valist_","_val
			else  set valist=valist_","_"'"_val_"'"
		}
	}
	set sql=sql_" ("_colist_") VALUES ("_valist_")"
	// Process first buffer
	set ER=$$^SQL(sql,,,.errmess) 
	if ER do { 
		if errmess="" set errmess=$g(RM)
		new ER	// Need to new ER here because SQL will redefine it.
		set ER=$$^SQL("BUFFER DELETE LNAPP")
	}
	quit:ER

	// Set up RELCIF
	set (sql,tbl,col,val,inv,colist,valist,cnt)=""
	for  set cnt=$o(RELCIF(cnt)) quit:(cnt="")!(ER)  do {
		set (sql,tbl,col,val,inv,colist,valist)=""
		set sql="BUFFER ADD LNAPP INSERT INTO RELCIF"
		for  set inv=$o(RELCIF(cnt,inv)) quit:(inv="")!(ER)  do {
			set tbl=$p(inv,".",1),col=$p(inv,".",2)
			set val=$g(RELCIF(cnt,inv))
			if tbl'="RELCIF" quit	// Invalid table
			if val="" quit		// Null value

			if colist="" set colist=col
			else  set colist=colist_","_col


			// Check if a value contains a "'" and parse it.
			if val["'" do chksps(.val)
			//  Check the data type
			set typ=$$TYP^SQLDD(inv)
			if valist="" do {
				if "$BLN"[typ set valist=val
				else  set valist="'"_val_"'"
			}
			else  do {
				if "$BLN"[typ set valist=valist_","_val
				else  set valist=valist_","_"'"_val_"'"
			}

		}
		set sql=sql_" ("_colist_") VALUES ("_valist_")"
		// Process buffer
		set ER=$$^SQL(sql,,,.errmess) 
		if ER do { 
			if errmess="" set errmess=$g(RM)
			new ER	// Need to new ER here because SQL will redefine it.
			set ER=$$^SQL("BUFFER DELETE LNAPP")
		}
		quit:ER
	}
	quit:ER

	// Set up an entry for the statment group if needed
	new smet,TYPE,sfre,xdata
 	set TYPE=Db.getOneRow("TYPE","LNAP1","ACN,APPS")
	set xdata=Db.getOneRow("SMET,SFRE","PRODDFTL","TYPE")
	set smet=$P(xdata,$C(9),1)
	set sfre=$P(xdata,$C(9),2)

	// For new accounts if SFRE=1 do not insert into CMBSTM
	if sfre="",smet=1 do {
		set (sql,tbl,col,val,inv,colist,valist,cnt)=""
		set sql="BUFFER ADD LNAPP INSERT INTO CMBSTM"
		set sql=sql_" (CID,ACN,STMGRP) VALUES ("_CID_","_ACN_",1)"
		set ER=$$^SQL(sql,,,.errmess) 
		if ER do { 
			if errmess="" set errmess=$g(RM)
			new ER	// Need to new ER here because SQL will redefine it.
			set ER=$$^SQL("BUFFER DELETE LNAPP")
		}
		quit:ER
	}
	quit:ER

	// Set up Colateral
	set (sql,tbl,col,val,inv,colist,valist,cnt,lncolval,lncolist)=""
	set sql="BUFFER ADD LNAPP INSERT INTO COL"
	for  s cnt=$o(FRMCOLL(cnt)) quit:(cnt="")!(ER)  do {
		set (sql,tbl,col,val,inv,colist,valist,lncolist,lncolval)=""
		set sql="BUFFER ADD LNAPP INSERT INTO COL"
		for  s inv=$o(FRMCOLL(cnt,inv)) quit:inv=""  do {
			set tbl=$p(inv,".",1),col=$p(inv,".",2)
			if tbl'="COL" quit	// Invalid table
			set val=$g(FRMCOLL(cnt,inv))
			if val="" quit		// null value

			if (col="FPLDG")!(col="PCTPLDG") do {  quit
				//these are the columns from lncol file
				if lncolist="" set lncolist=col
				else  set lncolist=lncolist_","_col

				if lncolval="" set lncolval=val
				else  set lncolval=lncolval_","_val
			}

			if colist="" set colist=col
			else  set colist=colist_","_col

			// Need speciall handeling for NEXTVAL
			if val="COL.NEXTVAL" do { quit
				if valist="" set valist=val
				else  set valist=valist_","_val
			}

			// Check if a value contains a "'" and parse it.
			if val["'" do chksps(.val)

			//  Check the data type
			set typ=$$TYP^SQLDD(inv)
			if valist="" do {
				if "$BLN"[typ set valist=val
				else  set valist="'"_val_"'"
			}
			else  do {
				if "$BLN"[typ set valist=valist_","_val
				else  set valist=valist_","_"'"_val_"'"
			}
		}
		set sql=sql_" ("_colist_") VALUES ("_valist_")"
		// Process collateral record
		set ER=$$^SQL(sql,,,.errmess) 
		if ER do { 
			if errmess="" set errmess=$g(RM)
			new ER	// Need to new ER here because SQL will redefine it.
			set ER=$$^SQL("BUFFER DELETE LNAPP")
		}
		quit:ER
		// Process LNCOL record
		set sql="BUFFER ADD LNAPP INSERT INTO LNCOL "

		if lncolist="" set lncolist="CID,COLL"
		else  set lncolist="CID,COLL,"_lncolist

		if lncolval="" set lncolval=CID_",COL.CURRVAL"
		else  set lncolval=CID_",COL.CURRVAL,"_lncolval

		set sql=sql_" ("_lncolist_") VALUES ("_lncolval_")"
		set ER=$$^SQL(sql,,,.errmess) 
		if ER do { 
			if errmess="" set errmess=$g(RM)
			new ER	// Need to new ER here because SQL will redefine it.
			set ER=$$^SQL("BUFFER DELETE LNAPP")
		}
		quit:ER

	}
	quit:ER

	// Commit Buffer
	set sql="BUFFER COMMIT LNAPP"
	set ER=$$^SQL(sql,,,.errmess) 
	if ER do {
		if errmess="" set errmess=$g(RM)
		new ER
		set ER=$$^SQL("BUFFER DELETE LNAPP")
	}
	
	quit

	//----------------------------------------------------------------------
update	// Update Logic
	//----------------------------------------------------------------------
	new sql,tbl,col,val,inv,colist,valist,cnt,lncolval,lncolist

	// delete all of the suporting tables
	// ACNADDR, RELCIF, COL, LNCOL, CMBSTM
	// treat this as a new loan.
	do Db.fastDelete("ACNADDR","CID")
	
	new rsr
	type ResultSet rsr
	set rsr=Db.select("ACN","RELCIF","CID=:CID")
	if 'rsr.isEmpty() for  quit:'rsr.next()  do {
		new ACN
		set ACN=rsr.getCol(1)
		do Db.fastDelete("RELCIF","ACN,CID")
	}

	new rss
	type ResultSet rss
	set rss=Db.select("STMGRP","CMBSTM","ACN=:ACN AND CID=:CID")
	if 'rss.isEmpty() for  quit:'rss.next()  do {
		new STMGRP
		set STMGRP=rss.getCol(1)
		do Db.fastDelete("CMBSTM","ACN,STMGRP,CID")
	}
	
	new rs3
	type ResultSet rs3
	set rs3=Db.select("COLL","LNCOL","CID=:CID")
	if 'rs3.isEmpty() for  quit:'rs3.next()  do {
		new COLL
		set COLL=rs3.getCol(1)
		//do Db.fastDelete("COL","COLL")
		do Db.delete("LNCOL","CID=:CID AND COLL=:COLL")
	}

	// Set Up entries for ACNADDR
	set (sql,tbl,col,val,inv,colist,valist)=""
	set sql="BUFFER NEW lnapp INSERT INTO ACNADDR"
	for  set inv=$o(ACNADDR(inv)) quit:inv=""  do {
		set tbl=$p(inv,".",1),col=$p(inv,".",2)
		set val=$g(ACNADDR(inv))
		if tbl'="ACNADDR" quit	// Invalid table
		if val="" quit		// Null value

		if colist="" set colist=col
		else  set colist=colist_","_col

		// Check if a value contains a "'" and parse it.
		if val["'" do chksps(.val)
		//  Check the data type
		set typ=$$TYP^SQLDD(inv)
		if valist="" do {
			if "$BLN"[typ set valist=val
			else  set valist="'"_val_"'"
		}
		else  do {
			if "$BLN"[typ set valist=valist_","_val
			else  set valist=valist_","_"'"_val_"'"
		}
	}
	set sql=sql_" ("_colist_") VALUES ("_valist_")"
	// Process first buffer
	set ER=$$^SQL(sql,,,.errmess) 
	if ER do { 
		if errmess="" set errmess=$g(RM)
		new ER	// Need to new ER here because SQL will redefine it.
		set ER=$$^SQL("BUFFER DELETE lnapp")
	}
	quit:ER

	// Set up RELCIF
	set (sql,tbl,col,val,inv,colist,valist,cnt)=""
	for  set cnt=$o(RELCIF(cnt)) quit:(cnt="")!(ER)  do {
		set sql="BUFFER ADD lnapp INSERT INTO RELCIF"
		set (colist,valist)=""
		for  set inv=$o(RELCIF(cnt,inv)) quit:(inv="")!(ER)  do {
			set tbl=$p(inv,".",1),col=$p(inv,".",2)
			set val=$g(RELCIF(cnt,inv))
			if tbl'="RELCIF" quit	// Invalid table
			if val="" quit		// Null value

			if colist="" set colist=col
			else  set colist=colist_","_col

			// Check if a value contains a "'" and parse it.
			if val["'" do chksps(.val)

			//  Check the data type
			set typ=$$TYP^SQLDD(inv)
			if valist="" do {
				if "$BLN"[typ set valist=val
				else  set valist="'"_val_"'"
			}
			else  do {
				if "$BLN"[typ set valist=valist_","_val
				else  set valist=valist_","_"'"_val_"'"
			}
		}
		set sql=sql_" ("_colist_") VALUES ("_valist_")"
		// Process buffer
		set ER=$$^SQL(sql,,,.errmess) 
		if ER do { 
			if errmess="" set errmess=$g(RM)
			new ER	// Need to new ER here because SQL will redefine it.
			set ER=$$^SQL("BUFFER DELETE lnapp")
		}
		quit:ER

	}
	quit:ER

	// Set up an entry for the statment group if this is a statment account
	new smet,sfre,xdata
	set xdata=Db.getOneRow("SMET,SFRE","LN","CID") 
	set smet=$P(xdata,$C(9),1)
	set sfre=$P(xdata,$C(9),2)

	 // For new accounts if SFRE=1 do not insert into CMBSTM
	if sfre="",smet=1 do {

		set (sql,tbl,col,val,inv,colist,valist,cnt)=""
		set sql="BUFFER ADD lnapp INSERT INTO CMBSTM"
		set sql=sql_" (CID,ACN,STMGRP) VALUES ("_CID_","_ACN_",1)"
		set ER=$$^SQL(sql,,,.errmess) 
		if ER do { 
			if errmess="" set errmess=$g(RM)
			new ER	// Need to new ER here because SQL will redefine it.
			set ER=$$^SQL("BUFFER DELETE lnapp")
		}
		quit:ER
	}
	quit:ER

	// Set up Colateral
	set (sql,tbl,col,val,inv,colist,valist,cnt)=""
	for  s cnt=$o(FRMCOLL(cnt)) quit:(cnt="")!(ER)  do {
		set sql="BUFFER ADD lnapp INSERT INTO COL"
		set (valist,colist,lncolval,lncolist)=""
		for  s inv=$o(FRMCOLL(cnt,inv)) quit:(inv="")!(ER)  do {
			set tbl=$p(inv,".",1),col=$p(inv,".",2)
			if tbl'="COL" quit	// Invalid table
			set val=$g(FRMCOLL(cnt,inv))
			if val="" quit		// null value


			if (col="FPLDG")!(col="PCTPLDG") do {  quit
				//these are the columns from lncol file
				if lncolist="" set lncolist=col
				else  set lncolist=lncolist_","_col

				if lncolval="" set lncolval=val
				else  set lncolval=lncolval_","_val
			}

			if colist="" set colist=col
			else  set colist=colist_","_col

			// Need speciall handeling for NEXTVAL
			if val="COL.NEXTVAL" do { quit
				if valist="" set valist=val
				else  set valist=valist_","_val
			}

			// Check if a value contains a "'" and parse it.
			if val["'" do chksps(.val)
			//  Check the data type
			set typ=$$TYP^SQLDD(inv)
			if valist="" do {
				if "$BLN"[typ set valist=val
				else  set valist="'"_val_"'"
			}
			else  do {
				if "$BLN"[typ set valist=valist_","_val
				else  set valist=valist_","_"'"_val_"'"
			}

		}
		set sql=sql_" ("_colist_") VALUES ("_valist_")"
		// Process collateral record
		set ER=$$^SQL(sql,,,.errmess) 
		if ER do { 
			if errmess="" set errmess=$g(RM)
			new ER	// Need to new ER here because SQL will redefine it.
			set ER=$$^SQL("BUFFER DELETE lnapp")
		}
		quit:ER

		// Process LNCOL record
		set sql="BUFFER ADD lnapp INSERT INTO LNCOL "

		if lncolist="" set lncolist="CID,COLL"
		else  set lncolist="CID,COLL,"_lncolist

		if lncolval="" set lncolval=CID_",COL.CURRVAL"
		else  set lncolval=CID_",COL.CURRVAL,"_lncolval

		set sql=sql_" ("_lncolist_") VALUES ("_lncolval_")"
		set ER=$$^SQL(sql,,,.errmess) 
		if ER do { 
			if errmess="" set errmess=$g(RM)
			new ER	// Need to new ER here because SQL will redefine it.
			set ER=$$^SQL("BUFFER DELETE lnapp")
		}
		quit:ER

	}
	quit:ER

	// Need to reset STAT on the loan.
	set dft("LN.STAT")=0

	set (sql,tbl,col,val,inv,colist,valist)=""
	set sql="BUFFER ADD lnapp UPDATE LN SET "
	// Loan (dft will only contain entries for LN)
	for  set inv=$o(dft(inv)) quit:inv=""  do {
		set tbl=$p(inv,".",1),col=$p(inv,".",2)
		set val=$g(dft(inv))
		if tbl'="LN" quit	// Invalid table
		// Do not include CID in the update
		if col="CID" quit
		if val="" quit

		// Check if a value contains a "'" and parse it.
		if val["'" do chksps(.val)

		//  Check the data type
		set typ=$$TYP^SQLDD(inv)
		if colist="" do {
			if "$BLN"[typ set colist=col_"="_val
			else  set colist=col_"='"_val_"'"
		}
		else  do {
			if "$BLN"[typ set colist=colist_","_col_"="_val
			else  set colist=colist_","_col_"='"_val_"'"
		}
		//if colist="" set colist=col_"='"_val_"'"
		//else  set colist=colist_","_col_"='"_val_"'"
			
	}
	set sql=sql_colist_" WHERE CID="_CID
	// Process
	set ER=$$^SQL(sql,,,.errmess)
	if ER do { 
		if errmess="" set errmess=$g(RM)
		new ER	// Need to new ER here because SQL will redefine it.
		set ER=$$^SQL("BUFFER DELETE lnapp")
	}
	quit:ER

	// Commit Buffer (rest)
	set sql="BUFFER COMMIT lnapp"
	set ER=$$^SQL(sql,,,.errmess) 
	if ER do { 
		if errmess="" set errmess=$g(RM)
		new ER	// Need to new ER here because SQL will redefine it.
		set ER=$$^SQL("BUFFER DELETE lnapp")
	}
	quit:ER
	
	quit
	//-------------------------------------------------------------------
calc(ln,mode,dft) //
	/*
	 This section is called to calculate initial values both during
	 original application filing and loan creation/refinnancing
	ln("column_name") - array that contains the values passed in from

	 mode - mode flag
		0 - insert (new loan account)
		1 - update (refinnance)
	 	3 - modifications to applicaton
		    (new/modify loan application that caused a need to
		     recalculate values on application)
	
	 Required data in ln:
	 ACN,TYPE,CRCD,AMTREQ,BOO,dist1fre,trm,cid
		
	--------------------------------------------------------------------
	*/
	if (mode=0)!(mode=3) do calc1 quit	// new loan or called from application
	if mode=1 do calc2	// Refinancing need a different subset of calculations
	quit

calc1	// new loan or called from application
	new TYPE,CRCD,BOO,ACN,ddata,PCMVAL
	set (ACN,ddata("ACN"))=ln("ACN")
	set (BOO,ddata("BOO"))=ln("BOO")
	set (CRCD,ddata("CRCD"))=ln("CRCD")
	set (TYPE,ddata("TYPE"))=ln("TYPE")

	// Check if comming in from regular application create/modify or
	// to create/refinnace a loan (LNAP1 filer AU_STS).
	if (mode=3)!(mode=0) do {
		do ^UPRODDFT(.ddata,.dft)
		do dft2ln(.dft,.ln)		// Copy defaults from ln() to dft()
		do ln2dft(.dft,.ln)		// Copy dft() to ln().
	}

	// All Calculations as of System Date. !!!!!!
	set ln("ODD")=%SystemDate
	set ln("ODT")=%SystemDate	// Account Openning Date
	set ln("DTNT")=%SystemDate	// Date of Note

	do {  quit:ER
		new ppinfo
		set ppinfo=$$PPINFO^LNFUNCS(ln("TYPE"),ln("CRCD"))
		set ln("TRB")=$P(ppinfo,"|",2)		// Trans to reduce bal
		set ln("PAP")=$P(ppinfo,"|",1)		// Payment path
		set ln("PAS")=$P(ppinfo,"|",3)		// Payment string
		if $g(ln("DIST1FRE"))'="" do {
			set ln("PDAG")=$P(ppinfo,"|",4)	// Pmt due action grid
			set ln("PCM")=$P(ppinfo,"|",5)	// Payment calc method
		}
	}
	set PCMVAL=$$PCMVAL^LNCDI($g(ln("PCM")))
	/*
	if $e(PCMVAL,3)=3 do {  quit:($g(ln("FPA"))'="")!ER
		if $g(ln("FPA"))="" set ER=1,RM="Erorr in FPA amount"
		set ln("PMTPI")=$g(ln("FPA"))
		do dft2ln(.dft,.ln) quit
	*/
 
	if $g(ln("INDEX"))'="" do {  quit:ER
		new BASE,ISCR,RATE,SRATE
		set BASE=ln("CRLMT")
		// Again: All Calculations Are as of SystemDate
		set PAR("IXLOAD")=0
		set PAR("NOTSER")=0
		set PAR("IPMODE")=0
		set PAR("ROUND")=1
		set PAR("LIMIT")=0
		set PAR("INDEX")=ln("INDEX")
		set PAR("SPREAD")=$g(ln("INTSPR"))
		set PAR("MATRIX")=$g(ln("INTMAT"))
		do CTLCID^UINDX(CID,%SystemDate,BASE,PAR) quit:ER
		set ln("IRN")=RATE
	}

	if $g(ln("IRN")) do {    					// Interest related info
		N x
		if $g(ln("TRATE")),($g(ln("TREXD"))>$g(ln("ODD"))) set ln("IRO")=ln("TRATE")	// Teaser Rate
		E  set ln("IRO")=ln("IRN")   				// Original int rate
		set x=+$J(ln("IRN")/365,0,5)
		set ln("IDF")=x   					// Daily factor
	}
	// Again: All Calculations are as of system date.
	if $g(ln("DIST1FRE"))'=""&($g(ln("DIST1ND"))=""!($g(ln("DIST1LD"))="")) do {  quit:ER
		new x,prodppif,prodfpf,CTL
		S x=$$PMTF^LNFUNCS(TYPE,CRCD)
		S prodppif=$P(x,"|",1),prodfpf=$P(x,"|",2)
		if prodfpf set CTL="00001"
		else  set CTL="00000"
		// Next Date
		set ln("DIST1ND")=$$NJD^UFRE(%SystemDate,ln("DIST1FRE"),.AF,CTL) quit:ER
		set ln("DIST1AF")=AF
		if prodfpf set CTL="10001"
		else  set CTL="10000"
		// Last Date
		set ln("DIST1LD")=$$NJD^UFRE(%SystemDate,ln("DIST1FRE"),.AF,CTL) quit:ER
	}

	if $g(ln("DIST1FRE"))'="" do {  quit:ER
		//calculate DFP
		set ln("BLOFF")=$$BLOFF^LNFUNCS(ln("TYPE"),ln("CRCD"))
		set ln("DFP")=$$DFP^PROCLN(ln("TYPE"),ln("CRCD"),%SystemDate,ln("DIST1FRE"),$g(ln("DFP")),$g(ln("DIST1ND")),$g(ln("BLOFF"))) quit:ER
		set ln("SCHND")=ln("DFP"),ln("SCHLD")=%SystemDate
		if $g(ln("DIST1ND"))="" set ln("DIST1ND")=ln("DFP")
	}

	// Default payment term to term if product indicates to do so
	if $g(ln("PTRM"))="",$$PTMF^LNFUNCS(ln("TYPE"),ln("CRCD")) set ln("PTRM")=ln("TRM")
 
	// Calculate Value for AMODT
	N lstpmtdt,amdt
	set ln("AMODT")=$$AMODT^PROCLN(ln("TYPE"),ln("CRCD"),ln("ODD"),ln("DIST1FRE") ,ln("DFP"),.lstpmtdt) quit:ER
	set ln("MDT")=$$MDT^PROCLN(ln("DTNT"),ln("ODD"),$g(ln("PTRM")),ln("TRM"),$g(ln("BUSOPT")),$g(ln("NBDC")),lstpmtdt,PCMVAL,ln("DIST1FRE"),.amdt,$g(ln("MDT"))) quit:ER

	if 'ln("ARUF") set ln("UDBAL")=ln("CRLMT")		// Unadvanced balance
 
	// Initialize following to zero if no current values
	if $g(ln("BAL"))="" set ln("BAL")=0
	set ln("CNTDR")=0		// Reset debit counter
	set ln("CNTCR")=0		// Reset credit counter
	if $g(ln("PMTPI"))="" set ln("PMTPI")=""		// Payment amounts will be recalculated
	if $g(ln("PMT"))="" set ln("PMT")=""
	if $g(ln("TEB"))="" set ln("TEB")=0
	if $g(ln("ORG"))="" set ln("ORG")=0
	if $g(ln("TDR"))="" set ln("TDR")=0
	if $g(ln("ACR"))="" set ln("ACR")=0
	if $g(ln("IUN"))="" set ln("IUN")=0
	if $g(ln("UNPR"))="" set ln("UNPR")=0
	if $g(ln("CUES"))="" set ln("CUES")=0
	if $g(ln("UNES"))="" set ln("UNES")=0
	set ln("SCHSEQ")=0
	if $g(ln("AUO"))="" set ln("AUO")=0
	if $g(ln("BAOLA"))="" set ln("BAOLA")=0
	if $g(ln("TBA"))="" set ln("TBA")=0
	set ln("BSEQ")=0

	// Calculate maturity date and other values
	if $g(ln("MDT"))'="" D {
		N ODT
		if (ln("DIST1ND")="")!("*"[ln("DIST1FRE")) set ODT=ln("ODD")
		E  set ODT=lstpmtdt
		if '$g(ln("ONP")),(ln("DIST1FRE")'="") set ln("ONP")=$$NBROPMT^PROCLN(ln("MDT"),ODT,ln("DIST1FRE"),lstpmtdt,ln("DIST1AF"))
		if '$g(ln("AMBAS")),($g(ln("DIST1FRE"))'="") do {
			if $g(ln("MDT"))=amdt set ln("AMBAS")=ln("ONP") quit
			set ln("AMBAS")=$$NBROPMT^PROCLN(amdt,ODT,ln("DIST1FRE"),lstpmtdt,ln("DIST1AF"))
		}
	}
 
	// Ensure that first due date value is reflected in related columns
	set ln("SCHND")=ln("DIST1ND")
	set ln("DFP")=ln("DIST1ND")

	// Calculate payment string information
	if $g(ln("PAP"))'="",ln("PAS")'="" do {
		N npc,pmtdist,pmtdistf,ppdcat,LN
		set $p(LN(50),"|",1)=TYPE,$p(LN(50),"|",12)=CRCD
		set pmtdist=$g(ln("PMTDIST")),pmtdistf=$g(ln("PMTDISTF"))
		do ^LNCNVST(,ln("CID"),ln("PAS"),ln("PAP"),.pmtdist,.pmtdistf,.npc,.ppdcat) quit:ER
		set ln("PMTDIST")=pmtdist,ln("PMTDISTF")=pmtdistf,ln("NPC")=npc
		set ln("PPDCAT1")=ppdcat(1),ln("PPDCAT2")=ppdcat(2),ln("PPDCAT3")=ppdcat(3)
		set ln("PPDCAT4")=ppdcat(4),ln("PPDCAT5")=ppdcat(5),ln("PPDCAT6")=ppdcat(6)
		set ln("PPDCAT7")=ppdcat(7),ln("PPDCAT8")=ppdcat(8),ln("PPDCAT9")=ppdcat(9)
		set ln("PPDCAT10")=ppdcat(10)
	}
 
	// Determine whether call to lnNEW10 is necessary
	N calc
	do {
		set calc=1
		if $E(PCMVAL),$g(ln("PMTPI"))="" quit
		if $E(PCMVAL),$g(ln("PMT"))="" quit
		if $E(PCMVAL,2)=2,(ln("FIA")="") quit
		if $g(ln("DIST1FRE"))'="",ln("AMODT")="" quit
		if $g(ln("DISAPR"))="" quit
		if $g(ln("DISTINT"))="" quit
		if $g(ln("DISAMF"))="" quit
		if $g(ln("CRLMT"))="" quit
		if $g(ln("TRM"))'="",($g(ln("MDT"))=""!($g(ln("ONP"))="")!($g(ln("AMBAS"))="")) quit
		set calc=0
	}

	if calc do {
		N in,out

		do RPC^LNNEW10(.ln,,,,.out)

		if $g(out("SCHLD"))'="" set ln("SCHLD")=out("SCHLD")
		if $d(out("AMODT"))&(ln("AMODT")=""!(ln("AMODT")=ln("ODD"))) set ln("AMODT")=$g(out("AMODT"))
		if $g(ln("COMFA"))="" set ln("COMFA")=$g(out("COMFA"))
		if $g(ln("DISAPR"))="" set ln("DISAPR")=$g(out("DISAPR"))
		if $g(ln("DISTINT"))="" set ln("DISTINT")=$g(out("DISTINT"))
		if $g(ln("DISTPMT"))="" set ln("DISTPMT")=$g(out("DISTPMT"))
		if $g(ln("DISAMF"))="" set ln("DISAMF")=$g(out("DISAMF"))
		if $g(ln("DISPPID"))="" set ln("DISPPID")=$g(out("DISPPID"))
		if $g(ln("DISPPI"))="" set ln("DISPPI")=$g(out("DISPPI"))
		if $g(ln("DISPMP"))="" set ln("DISPMP")=$g(out("DISPMP"))
		if $g(ln("DISMIP"))="" set ln("DISMIP")=$g(out("DISMIP"))
		if $g(ln("DISAMF"))="" set ln("DISAMF")=$g(out("DISAMF"))
		if $g(ln("FIA"))="" set ln("FIA")=$g(out("FIA"))
		if $g(ln("CRLMT"))="" set ln("CRLMT")=$g(out("CRLMT"))
		if $g(ln("MDT"))="" set ln("MDT")=$g(out("MDT"))
		if $g(ln("AMBAS"))="" set ln("AMBAS")=$g(out("AMBAS"))
		if $g(ln("ONP"))="" set ln("ONP")=$g(out("ONP"))
		if $g(ln("ORGFA"))="" set ln("ORGFA")=$g(out("ORGFA"))
		if $g(ln("PMTPI"))="" set ln("PMTPI")=$g(out("PMTPI"))
		if $g(ln("PMT"))="" set ln("PMT")=$g(out("PMT"))
		if $g(ln("PMTTRS"))="" set ln("PMTTRS")=$g(out("PMTTRS"))
		if $g(ln("SCHLD"))="" set ln("SCHLD")=$g(out("SCHLD"))
		if $g(ln("IAM")) do {
			set ln("IUN")=$g(out("IUN"))
			set ln("CRLMT")=$g(out("CRLMT"))
			set ln("UDBAL")=$g(out("CRLMT"))
		}
	}

	do dft2ln(.dft,.ln)

	quit
	//----------------------------------------------------------------------
calc2	// Refinnaced Loan Defaults.
	//----------------------------------------------------------------------
	//set ln("TDR")=0
	//set ln("ARUF")=Db.getOneRow("ARUF","LN","CID")
	//if 'ln("ARUF") set ln("UDBAL")=ln("CRLMT")
	//set ln("TDR")=0
	//set ln("BAOLA")=0
	//set ln("BALINT")=0
	set ln("CNTDR")=0		// Reset debit counter
	//set ln("SCHBAL")=0

	do dft2ln(.dft,.ln)

	quit
	//----------------------------------------------------------------------
ln2dft(dft,ln)	// This section is used to copy defaults obtained from UPRODDFT
	// into an array of a different key structure.
	// UPRODDFT will return array("file.column")=value
	// we need array("column")=value to LNNEW10 processing.
	//----------------------------------------------------------------------
	n col,i,tabl,val
	set (col,i,tabl,val)=""

	for  set tabl=$o(dft(tabl)) quit:tabl=""  do {
		s col=$p(tabl,".",2)
		if $g(ln(col))="" set ln(col)=$g(dft(tabl))
	}
	quit
	//---------------------------------------------------------------------
dft2ln(dft,ln)	// Copy back to dft array
	//	All of the columns that are in ln array are from LN table.
	//----------------------------------------------------------------------
	new col,i,tabl,val
	set (col,i,tabl,val)=""

	for  set col=$o(ln(col)) quit:col=""  do {
		//if $g(savelnc(col))'=$g(ln(col)) set dft("LN."_col)=ln(col)
		set dft("LN."_col)=ln(col)
	}
	quit
	//---------------------------------------------------------------------
Public chksps(val)	//
	// This section is responsible for checking if a value defaulted
	// contains a "'" in it.  If so parse value to an SQL standard ''
	// 
	//---------------------------------------------------------------------
	new pos,pass,count,saveval,numbr
	
	set numbr=$l(val,"'") if numbr=1 quit
	set count=0,saveval="",pass=""
	for count=1:1:numbr do {
		set pos(count)=$f(val,"'",$g(pos(count-1)))
	}
 
	for  set pass=$o(pos(pass)) quit:pass=""  do {
		if pos(pass)=0 set saveval=saveval_$e(val,pos(pass-1),999) quit
		if saveval="" set saveval=$e(val,1,pos(pass)-1)_"'"
		else  set saveval=saveval_$e(val,pos(pass-1),pos(pass)-1)_"'"
	}
	set val=saveval
	quit

vSIG()	quit "60211^40763^Irina Kin^33702"	// Signature - LTD^TIME^USER^SIZE
