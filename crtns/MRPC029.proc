MRPC029(String RETURN,String VERSN,String FQUAL,String TQUAL,String GQUAL,String SPVOVR)
	/*
	 Public ; Funds Transfer

	 ORIG: Phil Chenard/Gordon Joyner - 04/15/97
	 DESC: Account Transfer Financial Transaction RPC
	 KEYWORDS: RPC,Client/Server

	 This MRPC will provide simplified monetary transfer capabilities.

	 ARGUMENTS:
	 	. RETURN	Transaction Results /TYP=T/REQ/MECH=REFNAM:W

		. VERSN		^MRPC029 version number /TYP=N/REQ/MECH=VAL
			 	Current version = 1

	 	. FQUAL		From Account Qualifiers
	 	. TQUAL		To Account Qualifiers
				ACCT	- Account number  /REQ
					  Default Keyword
				ETC	- Transaction code
				INST	- Institution ID
				OCC	- Cost center override
					  Required for local act, if local act
					  is a GL act and other act is at 
					  diff Inst.
				BRCD	- Branch Code
					  This Branch Code is only for EFTPAY
					  record for Payment/Collection orders.
				IRAD	- Distribution code
					  ** only valid for from acct **
				IRAC	- Contribution code
					  ** only valid for to acct **
				BEN	- Beneficiary
				XFR	- Transferred to/from account
				CUSTCD	- Customer Code for Currency Exchange
				BSEAMT	- Base Currency Amount.
				TRESREF	- Treasury Reference.
				RATE	- Exchange Rate

				** Payment/Collection System Parameters **
				FREQUENCY - Payment frequency
				SOURCE	- Input Source
				MET	- Payment method
				AMTTYP	- Amount type
				EFTTYPE	- Electronic payment type
				EXPDT	- Expiration date
				CONSTANT- Constant field
				VARIABLE- Variable field
				SPECIFIC- Specific field
				UNIQTSO	- Unique TSO field
				TTXFDT	- TTXFDT use indicator
					  Used for EFT transfers.
					  Set to 0 to force future dated
					  transfer into EFTPAY instead of
					  TTXFDT.
					  Default: 1 - Store in TTXFDT
				PROCESS	- Process EFTPAY record
					  Default: 1 - Process now
				RECTYPE - Recipient Account Type
				EFTPAY.Column - Valid EFTPAY Table Column

		. GQUAL		Global scope qualifiers to the transaction  /TYP=T/REQ/MECH=VAL
				TAMT	- Transaction amount	/REQ
					  Default Keyword
				BRCD	- Branch Code for Teller Processing
				BCRCD	- Base Currency.
					  If not defined, system will:
					  * Use CRCD of from act if it is a
					    local act and not a GL act.
					  * Use CRCD of to act if it is a
					    local act and not a GL act.
					  * Use %CRCD
				EFD	- Effective date
				VDT	- Value date
				TPD	- Transaction posting date
				EFDOFF	- Effective Date Offset
				 	  +1=TJD+1, 1=TJD+1, -2=TJD-2
				SDT	- Starting date of the transaction. 
					  This date will be use to determine the
					  next available business date for the 
					  transaction's effective date
				FORM	- SQL Stored Procedure name, that
				 	  will be called to format a non-error
				 	  reply. From and to Records are
				 	  seperated by a Carriage Return and
				 	  Line Feed.
				FDTRESP	- Future dated response definition.
					  0 = Return HIST.TSEQ of comment
					  in HIST that say TTXFDT created
					  Default: 1 - Return as an error
				INTRFACE- Interface in table UTBLEXTINT

				** Teller System Parameters **
				MRPC29	- MRPC029 Transaction ID
					  Unique Transaction ID that will
					  be stored in the TSO field to
					  identify original transactions
					  for reversals.
					  Default: ETC^TAMT
				REVERSE	- Set to 1 to process REV/EC for a
					  previous transfer.  Message must
					  match original message.
				TCK	- Check Amount
				TCMT	- Transaction comment/memo

		. SPVOVR	Supervisory override information  /TYP=T/NOREQ/MECH=VAL
				SEQ	- "F" or "T"
				REST	- Restriction id
			  		  "OVR.id" or "RFLG.id" or "*"
				UID	- Supervisor ID
				PWD	- Supervisor Password

	 INPUTS:
		. TLO	- Transaction location
		. TJD	- Transaction posting date
		. %UID	- Teller posting ID
		. %MCP	- Multi-currency flag
		. %CRCD	- System base currency

	 RETURNS:
	 	. $$	- Error Message	/TYP=T
			- Null= No Error
		. RETURN- reply message.	/TYP=T
			  Standard reply is:
			  From CID, Trans SEQ, Amount, Endbal, Hist SEQ
			  Fields are separated by TAB and records are
			  separated by Carriage Return and Line Feed.

	 RELATED:
	 	. $$^PBSMRPC - MRPC Service Class Driver

	 EXAMPLES:

		S RET=$$^MRPC029(.VAL,1,300012,400012,37.25)
		S RET=$$^MRPC029(.VAL,1,"ACCT=300012","ACCT=400012","TAMT=37.25")
		S RET=$$^MRPC029(.VAL,1,"ACCT=300012","ACCT=1234999/INST=043311497
		/CONSTANT=22/MET=CC/EFTTYPE=PO","TAMT=100")
		S RET=$$^MRPC029(.VAL,1,"ACCT=1","ACCT=2","TAMT=100",
		"SEQ=T/REST=RFLG.006/UID=1/PWD=XXX")

	 This function will create and post teller and payment
	 system transactions

	 ---- Revision History ------------------------------------------------
	 
	01/09/07 - MBUIM - CR 24717
		   Modified GETCLS section to add check for ER to the runtime 
		   call as this resulted in any G/L transfers not working.
		   Variable ER is now defined as public. The TRN record 
		   instantiation is modified to include the 3rd parameter 1 to
		   prevent %PSL-E-RECNOFL errors. The cache of the object TRN 
		   was removed because, %CACHE doesn’t support a (,,1) 
		   parameter so the keys you specify have to exist in the table
		   you’re specifying otherwise it would throw a PSL-E-RECNOFL.
		   Removed the set EFD=SVEFD line in section EFTPAY, as SVEFD 
		   only needs to exist in the do loop. This was causing 
		   undefined error for SVEFD.

	12/19/06 - SHRIRAM - CR 24547
		   Modified MRPC to make use of automatic autorization defined by
		   CUVAR.AUTOAUTH.		  
		    
	08/09/06 - CHHABRIS - CR22501
		   Retrofited the below code from P01DEV1.

		03/27/06 - Ed Sigda - CR 20273
	 	o Modified section STFEFT to use lowercase variable sqldta.
	 	o Modified section EFTPAY to perform an incremental rollback
	 	  around the validation of the EFTPAY record when TTXFDT=1.
	 	o Modified section SPODBC to set RM=ERRMSG for Authorization 
	 	  Errors.
	 	o Modified section EFTPAY to define a starting date for the call
	 	  to DATES^EFTFUNCS based on the order's frequency.  This will
	 	  allow for the Starting Date to be valid for multiple period
	 	  frequencies (2WA, 3MA, 2QA, etc.).
	 	  
		Changes were made to introduce a new global parameter: SDT.  
		A client can use SDT to define the starting date of the 
		transaction.  This date will be used to determine the next 
		available business date for the transaction's effective date.
		o TTX section: Modified to enhance the logic which determines
		  the effective date for teller system transactions.  Added new
		  parameter TRANG.  Added default and validation logic for TPD
		  and EFD which originally existed in CHKGLOB section.  Added 
		  new start date logic.
		o EFT section: Added new parameter TRANG.
		o EFTPAY section: Modified to enhance the logic which determines
		  the effective date for payment system transactions. Added new
		  parameter TRANG. Modified setting of EFD value. Added new 
		  EFDOFF and start date logic. Changed the way that TTXFDT is
		  defined to agree with new EFDOFF and start date logic.
		o TPD section (new): Added to provide logic which determines the
		  correct TPD (Teller Posting Date) from various input dates. 
		  This section also validates the TPD for a specified teller 
		  and is called from the TTX section and the TTXFDT portion of 
		  EFTPAY section.
		o CHKGLOB section: Modified logic which extracts date values
		  from the various input fields.  Added new start date logic and
		  removed code that validates TPD.
		o PROC section: Reset ER to 1 after call to OUT^PBSTSSP since
		  that function will reset ER.
		  
	12/14/05 - PUTTASWH - CR 18157
		   Modified the code according to DBI standarads.
		   
	09/07/05 - KELLYP - CR 17118
		   Replaced all references to MSG100DT with MSG103DT.  The MT100
		   has been obsoleted by SWIFT and all references to it have 
		   been removed from the system.  Also fixed several ORDER BY
		   clauses and removed pre-2003 revision history.

        07/26/05 - SkariahV- CR16679
	           Removed #WARN directive.
	              	 
	12/01/04 - Frans S.C. Witte - CR 12564
		   Changed error.type="RECNOFL" to error.type="%PSL-E-RECNOFL"
		   (2 occurrences).

	08/02/04 - KELLYP - CR 11429
		   Changed name of XRM variable to ZRM.  An XRM variable is
		   used in PROCEFT so if XRM is defined it doesn't mean that
		   the error was trapped by the catch block.  This prevents
		   a situation from occurring where the wrong message was
		   being returned to the client.

	07/12/04 - KELLYP - CR 11007
		   Changed scope of TRANG variable in EFT section from private
		   to public to prevent an undefined error from occurring in
		   EFTPAY section.  Also modified top level to initialize
		   XER="" instead of XER=0 to ensure that errors are reported
		   to the client properly.

	11/07/03 - CARROLLJ - 51630
		   Pass correct parameters to ATMUTL.

	09/23/03 - GRAY - 51349
		   Corrected undefined error on ERRMSG.  Also, corrected a
		   problem with RM not being defined properly when verifying
		   the to and from qualifiers, resulting in additional
		   undefined errors on the TRANT and TRANF arrays. 

	07/08/03 - Erik Scheetz - 51349
		   Replaced calls to FDT2TTX with Record copy
		   method.

	06/12/03 - Spier - 51423
		   Modified GETCLS section to initialize ER to prevent
		   PSL reported error "undefined".
		   Also, corrected undefined error on EFD in section
		   CHKGLOB.

	01/27/03 - Spier - 51423
		   Modified CHKGBL section to correct Db.isDefined syntax
		   missing quotes around keys.
	*/

	type Public Number ER=""
	type Public String RM=""
	type Number XER=""
	type String ERRMSG="",ZRM=""

	do PROC(.RETURN,VERSN.get(),FQUAL.get(),TQUAL.get(),GQUAL.get(),SPVOVR.get())

	// Error caught in catch block
	if 'XER.isNull() set ER=XER
	if 'ZRM.isNull() set RM=ZRM

	// Error occurred, PROC formatted the response
	if ER,'ERRMSG.isNull() quit ERRMSG

	// Error occurred, response not formatted
	if ER quit $$ERRMSG^PBSUTL(RM)

	set RETURN=$$V2LV^MSG(RETURN)

	quit ""


PROC(String RETURN,	// Return Value
	String VERSN,	// Version
	String FQUAL,	// FQUAL
	String TQUAL,	// TQUAL
	String GQUAL,	// Global Qualifier String
	String SPVOVR)	// Supervisory override	
	// Process MRPC029 request	

	type Public Number ER=0
	type Public Number %STFHOST,XER,vzstfflg
	type Public String ERRMSG,RM,ZRM,vzrectyp

	type String BCRCD,BRCD,EFD,FCID,FCIDINST,INTRFACE,ISO,REVERSE,RATE,RJ,TAMT,TCID
	type String TCIDINST,TCK,TCMT,TRANF(),TRANG(),TRANT(),TPD,TSO,TSPV,VDT,vzfrn

	type RecordTTX ttx()

	catch error {
		set XER=1,ZRM=error.description
		if error.type["GTM" do ZE^UTLERR
		}

	set vzfrn=+(vzrectyp.get())			// Native or foreign client
	set (RETURN,RM)=""
	set %STFHOST=%STFHOST.get()
	set vzstfflg=vzstfflg.get()

	// Verify required parameters have been supplied

	// Invalid account number
	if (FQUAL.get().isNull())!(TQUAL.get().isNull()) do Runtime.setErrMSG("ACN",7774) quit

	// Missing Required Fields
	if GQUAL.get().isNull() do Runtime.setErrMSG("TTX",1768) quit

	// parse global qualifier
	set RM=$$CHKGLOB(GQUAL,.TRANG) quit:'RM.isNull()

	set ISO=CUVAR.iso

	// Parse FQUAL string
	set RM=$$CHKQUAL(.FQUAL,"F",TRANG("BCRCD"),ISO,.TRANF,.FCID,.FCIDINST) quit:'RM.isNull()

	// Parse TQUAL string
	set RM=$$CHKQUAL(.TQUAL,"T",TRANG("BCRCD"),ISO,.TRANT,.TCID,.TCIDINST) quit:'RM.isNull()

	// One Institution Must Be Local
	if FCIDINST'=ISO,TCIDINST'=ISO do Runtime.setErrMSG("ACN",2086) quit

	// Identical FROM and TO accounts
	if FCID=TCID,FCIDINST=TCIDINST do Runtime.setErrMSG("ACN",2325) quit
	

	/*
	 Define Base Currency now that from and to qualifiers have been
	 parsed.
	*/
	if TRANG("BCRCD").isNull() do {
		if FCIDINST=ISO,TRANF("CLS").get()'="M" set TRANG("BCRCD")=TRANF("CRCD")
		else  if TCIDINST=ISO,TRANT("CLS").get()'="M" set TRANG("BCRCD")=TRANT("CRCD")
		else  set TRANG("BCRCD")=%SystemCurrency
	}

	if TRANF("CRCD")="*" set TRANF("CRCD")=TRANG("BCRCD")
	if TRANT("CRCD")="*" set TRANT("CRCD")=TRANG("BCRCD")

	// Build supervisory override array
	if '(SPVOVR.get().isNull()) do SPVOVR(.TSPV,SPVOVR)
	if ER quit

	// Teller system transactions OR Payment system transactions
	if (TRANF("EFTTYPE").get().isNull()),(TRANT("EFTTYPE").get().isNull()),FCIDINST=TCIDINST do {
		do TTX(.RETURN,.TRANF,.TRANT,.TRANG)
		}
	else  do EFT(.RETURN,.TRANF,.TRANT,.TRANG)

	if ER do { quit
		type String EC
		set RETURN=""
		set EC=$$OUT^PBSTSSP(.ttx(),1,.ERRMSG,0)

		// OUT^PBSTSSP resets ER value to 0
		set ER=1
	}

	quit


TTX(String REPLY,		// Reply message 
	String TRANF(),		// From Acct Transaction array
	String TRANT(),		// To Acct Transaction array
	String TRANG())		// Global Transaction array

	/*
	 Process Teller System transfer

	 ARGUMENTS:
		. REPLY - Reply message containing 	/TYP=T/REQ/MECH=REFNAM:W
			  results of the processed
			  transactions

		. TRANF - From Acct Transaction array	/TYP=ARRAY/REQ/MECH=REF:R
				
		. TRANT - To Acct Transaction array	/TYP=ARRAY/REQ/MECH=REF:R
				
	*/

	type Public Number ER,REVERSE,vzstfflg
	type Public String BRCD,RM,TSPV
	type Public Date TPD

	type String CID,ETC,OM,TFTYPE,TTTYPE

	type Public Cache %CACHE()
	type public RecordTTX ttx()

	set REVERSE=REVERSE.get()
	set (ER,REPLY,RM)=""

	// execute pre-processor
	#if $$VALID^%ZRTNS("ZMRPC029") do PRETTX^ZMRPC029 quit:ER

	// Check for valid transfer relationships between products
	set TFTYPE=TRANF("TYPE"),TTTYPE=TRANT("TYPE")

	do { quit:ER

		// Continue if no record on file
		catch error {
		}

		// If list defined, TTTYPE must be in list to be valid
		type RecordUTBLTFRTYPE tfrtype=%CACHE("UTBLTFRTYPE").getRecord("UTBLTFRTYPE",TFTYPE)
		if tfrtype.totype1=TTTYPE quit
		if tfrtype.totype2=TTTYPE quit
		if tfrtype.totype3=TTTYPE quit
		if tfrtype.totype4=TTTYPE quit
		if tfrtype.totype5=TTTYPE quit
		if tfrtype.totype6=TTTYPE quit
		if tfrtype.totype7=TTTYPE quit
		if tfrtype.totype8=TTTYPE quit
		if tfrtype.totype9=TTTYPE quit
		if tfrtype.totype10=TTTYPE quit
		if tfrtype.totype11=TTTYPE quit
		if tfrtype.totype12=TTTYPE quit
		if tfrtype.totype13=TTTYPE quit
		if tfrtype.totype14=TTTYPE quit
		if tfrtype.totype15=TTTYPE quit
		if tfrtype.totype16=TTTYPE quit
		if tfrtype.totype17=TTTYPE quit
		if tfrtype.totype18=TTTYPE quit
		if tfrtype.totype19=TTTYPE quit
		if tfrtype.totype20=TTTYPE quit
		if tfrtype.totype21=TTTYPE quit
		if tfrtype.totype22=TTTYPE quit
		if tfrtype.totype23=TTTYPE quit
		if tfrtype.totype24=TTTYPE quit
		if tfrtype.totype25=TTTYPE quit
		if tfrtype.totype26=TTTYPE quit
		if tfrtype.totype27=TTTYPE quit
		if tfrtype.totype28=TTTYPE quit
		if tfrtype.totype29=TTTYPE quit
		if tfrtype.totype30=TTTYPE quit
		if tfrtype.totype31=TTTYPE quit
		if tfrtype.totype32=TTTYPE quit
		if tfrtype.totype33=TTTYPE quit
		if tfrtype.totype34=TTTYPE quit
		if tfrtype.totype35=TTTYPE quit

		// None are valid
		set ER=1,RM=$$^MSG(tfrtype.ernum)
	}

	// Determine and validate tran codes
	set ER=$$ETCCHK(.TRANF,"F") quit:ER
	set ER=$$ETCCHK(.TRANT,"T") quit:ER

	/*
	  Logic to determine effective date:
	   o If SDT is passed, EFD will default to the next available business 
	     date, including the start date, using the teller system calendar.
	   o else, if EFDOFF is passed, EFD will default to today's System Date
	     plus the offset. (Currently business days are not considered.)
	   o else, if EFD is passed, EFD will be used
	   o else, if EFD is not passed, EFD will default to today's System Date
	*/

	if 'TRANG("SDT").isNull() set %EffectiveDate=$$NBD^UNBD(%SystemDate,1)
        else  if 'TRANG("EFDOFF").get().isNull() set %EffectiveDate=%SystemDate+TRANG("EFDOFF")
        else  set %EffectiveDate=TRANG("EFD")
        if %EffectiveDate,%EffectiveDate=%SystemDate set %EffectiveDate=""

	set TPD=$$TPD(TRANG("TPD")) quit:ER

	// Find original transactions to reverse
	if REVERSE do REVERSE(.ttx()) quit:ER

	if 'REVERSE do {
		type String CRCD
		// Build From transaction
		do BLDTTX(.ttx(),.TRANF,.TRANG) quit:ER

		// Build To transaction
		do BLDTTX(.ttx(),.TRANT,.TRANG) quit:ER
		}

	// Determine Profile account for use by STFHOST process
	if TRANF("CLS")'="M" set CID=TRANF("ACCT")
	else  set CID=TRANT("ACCT")

	do POST^ATMUTL(.ttx(),CID,TPD,BRCD,.TSPV,vzstfflg) quit:ER

	// Transactions future-dated
	if %EffectiveDate>%SystemDate,TRANG("FDTRESP") do Runtime.setErrMSG("TTX",2330) quit

	// Build response array
	do TTXFMT(.ttx(),.REPLY,.OM,TRANG("FORM"))

	quit


TPD(TPD) // Determine correct TPD value

	type public Boolean ER
	type public String %MSGID,RM
	type Date SAVTPD,X

	set SAVTPD=TPD

	if (TPD=""),(Db.isDefined("SIGNON","%UserID")) do {
		type RecordSIGNON signon
		set signon=Db.getRecord("SIGNON","%UserID")
		set TPD=signon.tpd
		}
 
	if TPD.isNull() set TPD=%SystemDate

	/* 
	  Validate TPD for this teller. If TPD is not explicitly defined and 
	  TPD is invalid, try to roll date forward to next business day.
	*/

	set X=TPD
	do TPD^SIGNON
	if ER,(SAVTPD.isNull()) do { quit:ER RM
		type Number ID
		set ID=%MSGID.get().piece("|",1)

		// Catch the following errors as RELEVANT ignore all others
		if ",1123,1275,2208,2573,2618,"'[(","_ID_",") quit
		set TPD=$$NBD^UNBD(TPD+1,1)
		set ER=0
		set RM=""
		set X=TPD
		do TPD^SIGNON
		}

	// TPD^SIGNON defines ER="W" and RM="Teller balancing is on ~p1"
	set ER=0

	set RM=""

	quit TPD


TTXFMT(RecordTTX ttx(),		// Record TTX
	String REPLY,		// Standard Response
	String OM(),		// Trans Proc Output Array
	String FORM)		// SQL Stored Procedure name	

	// Build Teller System Response

	// If no output is requested then quit.
	if FORM="NOFORM" set REPLY="" quit

	if %EffectiveDate.isNull() set %EffectiveDate=%SystemDate

	// Create standard response
	type String RESP,seq
	for seq=1,2 do {
		if '(OM(seq).exists()) set OM(seq).piece("|",4)=ttx(seq).tamt
		set RESP(seq).piece($C(9),1)=ttx(seq).cid
		set RESP(seq).piece($C(9),2)=OM(seq).piece("|",3)
		set RESP(seq).piece($C(9),3)=ttx(seq).etc
		set RESP(seq).piece($C(9),4)=OM(seq).piece("|",4)
		set RESP(seq).piece($C(9),5)=ttx(seq).crcd
		set RESP(seq).piece($C(9),6)=OM(seq).piece("|",5)

		// Future dated transaction, use last HIST entry for HSEQ
		if %EffectiveDate>%SystemDate do {
			type Public Cache %CACHE()
			type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ttx(seq).etc")
			quit:trn.cls="M"
			type Number CID
			set CID=ttx(seq).cid
			set OM(seq).piece("|",6)=Db.nextVal("HIST","CID")-1
		}

		set RESP(seq).piece($C(9),7)=OM(seq).piece("|",6)
		set RESP(seq).piece($C(9),11)=%EffectiveDate
		set RESP(seq).piece($C(9),12)=""
	}

	// Return standard response
	if FORM.isNull() set REPLY=RESP(1)_$C(13,10)_RESP(2)

	// Use specified stored procedure to format a reply.
	else  do SPFMT(.REPLY,.RESP,FORM)
	
	quit


SPFMT(REPLY,		// Standard Response
	RESP,		// Response Array
	FORM)		// Output Procedure Name	
	// Use specified stored procedure to format a reply.	

	type Number EC,SEQ

	set EC=0

	for SEQ=1,2 do { quit:EC
		type String CID,ETC,HSEQ,RESP,SQLDTA,SQLEXP,TRC

		/*
		 The following variables are being set for use by
		 the stored procedure call.
		*/
		set CID=RESP(SEQ).piece($C(9),1)
		set TRC=RESP(SEQ).piece($C(9),2)
		set ETC=RESP(SEQ).piece($C(9),3)
		set HSEQ=RESP(SEQ).piece($C(9),7)

		set SQLDTA=""
		set SQLEXP="EXECUTE"_" "_FORM
		set EC=$$^SQL(SQLEXP,,,.SQLDTA)

		set REPLY=REPLY_$S(REPLY="":"",1:$C(13,10))_SQLDTA
	}

	quit


CHKGLOB(String GQUAL,		// Global Qualifier String
	String TRANG())		// Global Qualifier Array
	/*
	 Check Global qualifiers

	 RETURNS:
		. $$		Error message	/TYP=T
		. TPD		Teller Posting Date
		. EFD		Effective Date
		. TAMT		Transaction Amount
		. BRCD		Teller Branch Code
		. TCMT		Transaction Comment
		. TLO		Transaction Location
		. INTRFACE	External Interface being used

		. BCRCD		Base Currency
		. FORM		Output format
		. FDTRESP	Future Dated Response specifier
		. VDT		Value Date
	*/

	type Public Number ER
	type Public String BCRCD,BRCD,EFD,EFDOFF,FDTRESP,FORM,INTRFACE,%MSGID
	type Public String RM,SDT,TAMT,TCMT,TLO,TPD,VDT
	type String PSTBRN,VAR,X

	set RM=""
	set X=GQUAL.piece("/",1)
	if X?1.N!(X?1.N1".".N)!(X?1"."1.N) set GQUAL="TAMT="_GQUAL
	do STR2ARR^UTLMRPC(GQUAL,.TRANG,"/")
	set VAR=""
	for  set VAR=TRANG(VAR).order() quit:VAR=""  set @VAR=TRANG(VAR)

	// Invalid transaction amount
	if TAMT.get().isNull() set ER=1 quit $$^MSG(6070)

	if INTRFACE.get().isNull() set INTRFACE="IVR"
	set TRANG("INTRFACE")=INTRFACE

	// Examine Effective date offset and if valid set EFD
	if '(EFDOFF.get().isNull()),((EFDOFF?1.N)!(EFDOFF?1"-"1.N)!(EFDOFF?1"+"1.N)) set TRANG("EFDOFF")=EFDOFF

	// Set date qualifiers and if not in julian format, convert
	if TPD.get().isNull() set TPD=""
	else  if TPD'?5N set TPD=$$FDAT^%ZM(TPD) if ER quit RM
	if EFD.get().isNull() set EFD=""
	else  if EFD'?5N set EFD=$$FDAT^%ZM(EFD) if ER quit RM
	if VDT.get().isNull() set VDT=""
	else  if VDT'?5N set VDT=$$FDAT^%ZM(VDT) if ER quit RM
	if SDT.get().isNull() set SDT=""
	else  if SDT'?5N set SDT=$$FDAT^%ZM(SDT) if ER quit RM

	set BRCD=BRCD.get()

	// Invalid branch code
	if 'BRCD.isNull(),'Db.isDefined("UTBLBRCD","BRCD") set ER=1 quit $$^MSG(1273)

	type RecordSIGNON signon=Db.getRecord("SIGNON","%UserID",1)
	if 'signon.getMode() set PSTBRN=""
	else  set PSTBRN=signon.brcd

	if BRCD.isNull() do { if ER quit RM
		if 'PSTBRN.isNull() set BRCD=PSTBRN
		else  do {
			type RecordSCAU scau=Db.getRecord("SCAU","%UserID")
			set BRCD=scau.brcd

			// Branch Code Not Defined
			if BRCD.isNull() set ER=1,RM=$$^MSG(6654)
		}
	}

	// User ID ~p1 is currently signed on to branch ~p2
	if 'PSTBRN.isNull(),BRCD'=PSTBRN set ER=1 quit $$^MSG(2850,%UserID,PSTBRN)
	set TRANG("BRCD")=BRCD

	set TCMT=TCMT.get()
	set %UserStation=%UserStation.get()
	if '((FDTRESP.get()=1)!(FDTRESP.get()=0)) set FDTRESP=1

	set TRANG("FDTRESP")=FDTRESP
	set TRANG("BCRCD")=BCRCD.get()
	set TRANG("FORM")=FORM.get()
	set TRANG("VDT")=VDT
	set TRANG("EFD")=%EffectiveDate
	set TRANG("TPD")=TPD
	set TRANG("SDT")=SDT

	quit ""


CHKQUAL(String QUAL,		// Input Qualifier		
	Number SEQ,		// Sequence "F" or "T"
	String BCRCD,		// Base Currency Code	
	String INST,		// Local Institution Number	
	String TRAN,		// Output Parameter array
	Number CID,		// Output account field
	String CIDINST)		// Output institution fld
	/*
	 Validate Account qualifier

	 RETURNS:
		. $$		Error Message  /TYP=T
	*/

	type Public String RM

	type String CODE

	if QUAL?1.N!(QUAL?1.N1"/".E) set QUAL="ACCT="_QUAL
	do STR2ARR^UTLMRPC(QUAL,.TRAN,"/")
	set CID=TRAN("ACCT").get()

	// Invalid FROM account number
	// Invalid TO account number
	if CID.isNull() set CODE=$S(SEQ="F":2095,1:2096) quit $$^MSG(CODE)

	if TRAN("INST").get().isNull() set TRAN("INST")=INST
	set CIDINST=TRAN("INST")

	// Load account info
	if $$GETCLS(.TRAN,BCRCD,INST) quit RM

	quit ""


BLDTTX(RecordTTX ttx(),		// Transaction array
	String TRAN,		// From/To Parameter Array
	String TRANG)		// Global Parameter Array	
	// Build a transaction record from Account Qualifiers

	type Public Number ER
	type Public String BCRCD,RM
	type String seq,BSEAMT,CRCD,CUSTCD,ETC,MRPC29,MULTIPLY,RATE,SPR,TAMT
	type String TCMT,TRESREF,TSO,UNIQTSO,UTSO

	set ETC=TRAN("ETC")

	type Public Cache %CACHE()
	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")

	// The following qualifiers can be From/To and/or Global.
	set BCRCD=TRAN("BCRCD").get()
	if BCRCD.isNull() set BCRCD=TRANG("BCRCD")

	set CUSTCD=TRAN("CUSTCD").get()
	if CUSTCD.isNull() set CUSTCD=TRANG("CUSTCD").get()

	set MULTIPLY=TRAN("MULTIPLY").get()
	if MULTIPLY.isNull() set MULTIPLY=TRANG("MULTIPLY").get()

	set RATE=TRAN("RATE").get()
	if RATE.isNull() set RATE=TRANG("RATE").get()

	set SPR=TRAN("SPR").get()
	if SPR.isNull() set SPR=TRANG("SPR").get()

	set TAMT=TRAN("TAMT").get()
	if TAMT.isNull() set TAMT=TRANG("TAMT").get()

	set TCMT=TRAN("TCMT").get()
	if TCMT.isNull() set TCMT=TRANG("TCMT").get()

	set TRESREF=TRAN("TRESREF").get()
	if TRESREF.isNull() set TRESREF=TRANG("TRESREF").get()

	set TSO=TRAN("TSO").get()
	if TSO.isNull() set TSO=TRANG("TSO").get()

	set UNIQTSO=TRAN("UNIQTSO").get()
	if UNIQTSO.isNull() set UNIQTSO=TRANG("INIQTSO").get()

	set CRCD=TRAN("CRCD")

	set MRPC29=TRANG("MRPC29").get()
	if MRPC29.isNull() set MRPC29=ETC_"^"_TAMT

	// Build TSO
	if 'TSO.isNull() do OUT^UTSO(.UTSO,TSO)

	set UTSO("MRPC29")=MRPC29
	if 'UNIQTSO.isNull() do OUT^UTSO(.UTSO,UNIQTSO)
	if TRAN("IRA").exists() set UTSO("IRA")=TRAN("IRA")
	if TRAN("BEN").exists() set UTSO("BEN")=TRAN("BEN")
	if TRAN("XFR").exists() set UTSO("XFR")=TRAN("XFR")
	do IN^UTSO(.UTSO,.TSO)

	// Multi-currency logic
	set BSEAMT=TAMT

	// Profile account transactions must be in the account currency
	if trn.cls'="M" do {
		type Number CID

		set CID=TRAN("ACCT")

		// Retrieve account information
		type RecordACN acn=Db.getRecord("ACN","CID",1)

		// Invalid account
		if 'acn.getMode() do Runtime.setErrMSG("ACN",1259,CID) quit 

		// Conversion needed
		if acn.crcd'=BCRCD do {
			type Number EXCAMT,TRNTYP

			// Convert amount to account currency (margins, non-cash, mid-rate)
			if CUSTCD.isNull() set CUSTCD=acn.ccode
			set TRNTYP=$S(trn.itc.extract():0,1:1)
			do EXC^CRCDUTL(BCRCD,acn.crcd,TAMT,1,TRNTYP,"00",CUSTCD,%EffectiveDate,1)

			if ER quit
			set CRCD=acn.crcd
			set TAMT=$$^SCARND(EXCAMT,0,"",CRCD)

			// Add TCUR to TSO
			set TSO=$$FIELDIN^UTSO(TSO,"TCUR",BSEAMT_BCRCD)
		}
	}
	if ER quit

	set seq=ttx("").order(-1)+1
	set ttx(seq)=Class.new("RecordTTX")
	set ttx(seq).cid=TRAN("ACCT")
	set ttx(seq).itc=trn.itc
	set ttx(seq).etc=ETC
	set ttx(seq).tamt=TAMT
	set ttx(seq).efd=EFD
	set ttx(seq).tlo=%UserStation
	set ttx(seq).tso=TSO
	set ttx(seq).tcmt=TCMT
	set ttx(seq).spr=SPR
	set ttx(seq).crcd=CRCD
	if TRAN("OCC").exists() set ttx(seq).cc=TRAN("OCC")
	if TRAN("CHKTYP").exists() set ttx(seq).chktyp=TRAN("CHKTYP")
	if TRAN("MSD").exists() set ttx(seq).msd=TRAN("MSD")

	#IF CUVAR.%MCP

	// Multi-currency fields
	set ttx(seq).rate=RATE
	set ttx(seq).vdt=TRANG("VDT")
	set ttx(seq).mult=MULTIPLY
	set ttx(seq).bseamt=BSEAMT
	set ttx(seq).custcd=CUSTCD
	set ttx(seq).tresref=TRESREF
	set ttx(seq).bcrcd=BCRCD
	#ENDIF

	quit


ETCCHK(String TRAN(),	// Transaction Array
	Number SEQ)	// Sequence Number	
	// Determine and validate tran codes	

	type Public Number ER
	type Public String ETC,INTRFACE,RM
	type Public Cache %CACHE()

	type Number CID

	set CID=TRAN("ACCT")
	set ETC=TRAN("ETC").get()

	// ETC not passed, check UTBLEXTTRN1 and/or PRODCTL for value
	if ETC.isNull() do { 
		type String CODE

		if TRAN("CLS")="M" set CODE="M"
		else  set CODE=TRAN("TYPE")

		/*
		 Tran code not included in message, get default from
		 external interface table
		*/
		do {
			// If no record on file
			catch error {
				set ETC=""
				}
			type Public Cache %CACHE()
			type RecordUTBLEXTTRN1 exttrn1=%CACHE("UTBLEXTTRN1").getRecord("UTBLEXTTRN1","INTRFACE=:INTRFACE,CODE=:CODE") 
			if SEQ="F" set ETC=exttrn1.dretc
			else  set ETC=exttrn1.cretc
		}

		if 'ETC.isNull() quit

		// No defaults for MSC in PRODCTL
		if TRAN("CLS")="M" quit

		// Check product table for tran code, use local vars TYPE

		do {
			// If no record on file
			catch error {
				set ETC=""
				}
			type RecordPRODCTL prodctl=%CACHE("PRODCTL").getRecord("PRODCTL","TYPE=:CODE") 
			if SEQ="F" set ETC=prodctl.drtrgp
			else  set ETC=prodctl.crtrgp
		}
	}

	// Product ~p1 missing transaction code - ~p2
	if ETC.isNull() do Runtime.setErrMSG("PRODCTL",2268,TRAN("TYPE")) quit 1

	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")

	// Invalid transaction code ~p1
	if 'trn.getMode() do Runtime.setErrMSG("TRN",1498,ETC) quit 1

	// Check for valid CLS and GRP matches.
	if TRAN("CLS")'=trn.cls!(TRAN("GRP")'=trn.grp) do { if ER quit ER
		if TRAN("CLS")=trn.cls,trn.grp="*"!(TRAN("CLS")="M") quit

		// Invalid transaction code ~p1
		set ER=1,RM=$$^MSG(1498,ETC)
		do LOG^UTLEXC("MRPC029","","",CID,"",RM)
	}

	// Check for valid debit/credit code
	// Invalid transaction code ~p1
	if trn.itc.isNull()!($S(SEQ="F":0,1:1)'=trn.itc.extract(1)) set RM=$$^MSG(1498,ETC) quit 1

	set TRAN("ETC")=ETC

	quit 0


GETCLS(String TRAN(),	// Parameter Array  /TYP=T/MECH=REF:RW/REQ
	String BCRCD,	// Base Currency Code
	String INST)	// Local Institution Number
	/*
	 Get CLS,GRP and TYPE for account

	 RETURNS:
		. $$		Error Code  /TYP=N
		. TRAN("CLS")	/TYP=T
		. TRAN("GRP")	/TYP=T
		. TRAN("TYPE")	/TYP=N
		. TRAN("CRCD")	/TYP=T
		. TRAN("CUSTCD")/TYP=N
	*/

	type public String ETC, RM
	type public Boolean ER=0

	type Number CID
	type String CLS,CRCD,SQLDTA

	// Foreign account
	if TRAN("INST")'=INST do { quit 0
		set TRAN("CLS")="EXT"
		set TRAN("CRCD")=BCRCD
		if TRAN("CRCD").isNull() set TRAN("CRCD")=%SystemCurrency
	}

	set CLS=TRAN("CLS").get()
	set CID=TRAN("ACCT")

	if '(TRAN("ETC").get().isNull()) do { quit:ER 1
		set ETC=TRAN("ETC")
	
		type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC",1)

		// Invalid transaction code ~p1
		if 'trn.getMode() do Runtime.setErrMSG("TRN",1498,ETC) quit 
		set CLS=trn.cls
	}

	if CLS'="M" do { quit:ER 1

		// Get details from ACN
		type RecordACN acn=Db.getRecord("ACN","CID",1)
		if 'acn.getMode() do {
			/* Assume for now that it's a G/L account
			   will verify in next section.
			*/
			if CLS.isNull() set CLS="M" quit

			// Invalid account ~p1
			if ER do Runtime.setErrMSG("ACN",1259,CID) quit
		}

		else  do {
			set TRAN("CLS")=acn.cls
			set TRAN("GRP")=acn.grp
			set TRAN("TYPE")=acn.type
			set TRAN("CRCD")=acn.crcd
			set TRAN("CUSTCD")=acn.ccode
		}
	}

	if CLS="M" do { quit:ER 1

		// Check if account is a G/L
		do GLAD^TTXEXT(CID)

		// Invalid account ~p1
		if ER do Runtime.setErrMSG("ACN",1259,CID) quit

		set TRAN("CLS")="M"
		set TRAN("GRP")="MISC"
		set TRAN("TYPE")="G/L"
		set TRAN("CRCD")="*"
		set TRAN("CUSTCD")=""
	}

	quit 0


EFT(String REPLY,		// Reply message 
	String TRANF(),		// Transaction information From array
	String TRANT(),		// Transaction information To array
	String TRANG())		// Global Transaction information array
	// Process EFT record

	type Public Number ER,%STFHOST,vzstfflg
	type Public String BRCD,RM,TSPV
	type Public Date EFD,TPD

	// Host Store and Forward transaction
	if %STFHOST do STFEFT quit

	type Number CID,CRT,EFTSEQ,SEQ
	type String OM,PROCESS
	type Date EFTDAT,TTXFDT

	// Variables used outside this code - review these after PSL rewrite
	type String ACR,ADJINT,BALANCE
	type String BALPHLD,BL,BJD,BSEAMT,CC,CO,COL,CRCDT,DLR,EMULIM,EXP,GLSC,GRP,HLD
	type String HLDAMT,IACM,ICF,ICHND,INCCR,INDEX,INP,INTFRE,INTMAT,IPF,IPLD,IRA
	type String IRN,LSEQ,LSP,MATURITY,MINACR,MINODA,MINOPT,N,NEGBJD,NEGINP,NOTICE
	type String NOTMIN,NUMDAYS,ODT,OUTFLG,PCA,PCFD21,PDYS,PENINT,PINDX,PIPW,POPT
	type String POSBJD,POSTBAL,PP,PRATE,PRS,PXD,RETURNED,RODT,SCHPROC,SEGEUR,SIXM
	type String TCK,TRB,TRC,TRM,XLSP

	set (REPLY,ER,RM)=""

	// execute pre-processor
	#if $$VALID^%ZRTNS("ZMRPC029") do PREEFT^ZMRPC029 quit:ER

	// Initialize CRT for accounts that have override.
	set CRT=0

	// Collection order
	if TRANF("EFTTYPE").exists() set EFTSEQ=$$EFTPAY(.TRANT,.TRANF,.CID,.PROCESS,.TRANG)
	// Payment order
	else  set EFTSEQ=$$EFTPAY(.TRANF,.TRANT,.CID,.PROCESS,.TRANG)
	quit:ER

	/*
	 This next section of code is to support the TTXFDT=1 option,
	 which will only support the limited set of EFTPAY fields.

	 The entry will then be created and processed via TTXFDT
	*/
	if TTXFDT do { quit
		type String EXTTRF,ITC,OM

		type String CLS,COL,CRCD,GLSC,GRP,HLD,I,CRCDF,CRCDT
		type String IRA,PTRC,SEQ,TCK,TNSEQ,TTXHDR,TYPE,TRC,TSTTRC,NEWTRC

		type RecordTTX ttx()

		// Collection order
		if TRANF("EFTTYPE").exists() do BLDTTX2(.ttx(),.TRANT,.TRANF,.TRANG,"T") quit:ER
			
		// Payment order
		if TRANT("EFTTYPE").exists() do BLDTTX2(.ttx(),.TRANF,.TRANT,.TRANG,"F") quit:ER

		do POST^ATMUTL(.ttx(),CID,TPD,BRCD,.TSPV,vzstfflg) quit:ER

		// Transactions future-dated
		if EFD>%SystemDate,TRANG("FDTRESP") do Runtime.setErrMSG("TTX",2330) quit

		// Build response array
		do TTXFMT(.ttx(),.REPLY,.OM,TRANG("FORM"))
	}

	// If not processing, build response array and quit
	if 'PROCESS do EFTFMT(.REPLY,.OM,TRANG("FORM")) quit

	// Set up supervisory override.
	set TSPV("*")=%UserID_"|"_%UserClass	// SPG 4/13/00

	// Now call BCHEFT to process the order.
	set EFTDAT=%SystemDate			// Set Date for EFT
	do public^BCHEFT(CID,EFTSEQ,,,,1) quit:ER

	// Get newly processed Status and update local array for response

	type RecordEFTPAY eftpay=Db.getRecord("EFTPAY","CID,EFTSEQ")

	// Collection order
	if TRANF("EFTTYPE").exists() set TRANT("EFTPAY.STATUS")=eftpay.status
	// Payment order
	else  set TRANF("EFTPAY.STATUS")=eftpay.status

	// Build response array
	do EFTFMT(.REPLY,.OM,TRANG("FORM"))

	quit


EFTPAY(String LOCAL(),		// LOCAL Array
	String EFTPAY(),	// EFTPAY Array
	Number CID,		// Account Number
	Number PROCESS,		// Parameter to indicate the process order time
	String TRANG())		// Global Transaction information array
	/*
	 Create EFTPAY record

	 RETURNS:
		. $$	EFTPAY Sequence Number
	*/

	type Public Number level,ER,TAMT
	type Public String RM
	type Public Date EFD,TPD,TTXFDT

	type String BRCD,CC,EFTSEQ,LNM,TTYPE
	type Date SVEFD

	// Determine whether we should process order immediately
	set PROCESS=EFTPAY("PROCESS").get()
	if PROCESS.isNull() set PROCESS=1

	// Define variables to create record in [EFTPAY]
	set CID=LOCAL("ACCT")		// local host CID
	set BRCD=LOCAL("BRCD").get()
	set CC=LOCAL("OCC").get()

	// Customer Account
	if LOCAL("CLS")'="M" do {
		type RecordACN acn=Db.getRecord("ACN","CID")

		set LNM=acn.lnm
		if CC.isNull() set CC=acn.cc
		if BRCD.isNull() set BRCD=acn.boo

		// Customer to Customer
		if EFTPAY("CLS")'="M" set TTYPE=0
		// Customer to G/L
		else  set TTYPE=1
	}
	// G/L Account
	else  do { quit:ER ""
		type RecordGLAD glad=Db.getRecord("GLAD","CID")

		set LNM=glad.desc1.extract(1,20)

		// G/L to Customer
		if EFTPAY("CLS")'="M" set TTYPE=2
		// G/L to G/L
		else  set TTYPE=3
		}

	// Cost Center Undefined
	if CC.isNull() do Runtime.setErrMSG("ACN",6573) quit ""

	type RecordEFTPAY eftpay=Class.new("RecordEFTPAY")
	do eftpay.overlay("EFTPAY")

	// Set primary keys
	set eftpay.cid=CID
	set eftpay.seq=Db.nextVal("EFTPAY","CID")

	// Backwards compatible fields
	if eftpay.recacct.isNull() set eftpay.recacct=EFTPAY("ACCT")
	if eftpay.recinst.isNull() set eftpay.recinst=EFTPAY("INST")
	if eftpay.crcd.isNull() set eftpay.crcd=TRANG("BCRCD")
	if eftpay.frequency.isNull() set eftpay.frequency=EFTPAY("FREQUENCY").get()
	if eftpay.status.isNull() set eftpay.status=EFTPAY("STATUS").get()
	if eftpay.met.isNull() set eftpay.met=EFTPAY("MET").get()
	if eftpay.tries.isNull() set eftpay.tries=EFTPAY("TRIES").get()
	if eftpay.actamt.isNull() set eftpay.actamt=EFTPAY("ACTAMT").get()
	if eftpay.thold.isNull() set eftpay.thold=EFTPAY("THOLD").get()
	if eftpay.amttyp.isNull() set eftpay.amttyp=EFTPAY("AMTTYP").get()
	if eftpay.efttype.isNull() set eftpay.efttype=EFTPAY("EFTTYPE").get()
	if eftpay.pri.isNull() set eftpay.pri=EFTPAY("PRI").get()
	if eftpay.expdt.isNull() set eftpay.expdt=EFTPAY("EXPDT").get()
	if eftpay.variable.isNull() set eftpay.variable=EFTPAY("VARIABLE").get()
	if eftpay.constant.isNull() set eftpay.constant=EFTPAY("CONSTANT").get()
	if eftpay.specific.isNull() set eftpay.specific=EFTPAY("SPECIFIC").get()
	if eftpay.uniqtso.isNull() set eftpay.uniqtso=EFTPAY("UNIQTSO").get()
	if eftpay.source.isNull() set eftpay.source=EFTPAY("SOURCE").get()
	if eftpay.msg103dt.isNull() set eftpay.msg103dt=EFTPAY("CPA").get()
	if eftpay.rectype.isNull() set eftpay.rectype=EFTPAY("RECTYPE").get()

	/*
	 Check if it is an effective dated transaction that
	 needs to be processed via TTXFDT.  Redfine TTXFDT.
	*/
	set TTXFDT=EFTPAY("TTXFDT").get()
	if TTXFDT do {
		if (TRANG("EFD")),TRANG("EFD")'>%SystemDate set TTXFDT=0
		if TRANG("EFDOFF")'>0 set TTXFDT=0
		}

	/*
	  Logic to determine effective date:

	  One time Orders
	   o If SDT is passed, EFD will default to the next available business
	      date, including the start date, using the payment system calendar*
	   o Else, if EFDOFF is passed, EFD will default to next available
	     business date, a minimum of offset days ahead of today's system 
	     date, using the payment system calendar*.  
	   o Else, if EFD is passed, EFD will be used, but may be bumped to the
	     next valid business date.
	   o Else, if EFD is not passed, EFD will default to the next available
	     business date, including today's system date, using the payment
	     system calendar*.

	  Standing Orders 
	   o If SDT is passed, EFD will default to the next available business
	     date, including the start date, using the payment system calendar*
	     based on the order's frequency.
	   o Else, if EFDOFF is passed, EFD will default to next available
	     business date, a minimum of offset days ahead of today's system
	     date, using the payment system calendar* based on the order's
	     frequency.
	   o Else, if EFD is passed, EFD will default to the next available 
	     business date, not including today's system date, based on the 
	     order's frequency.
	   o Else, If EFD is not passed, EFD will default to the next available
	     business date, not including today's system date, based on the
	     order's frequency.

	     * denotes that DATES^EFTFUNCS will be used.
	*/

	// Use starting date of System Date plus offset
	if TRANG("EFDOFF").get() set TRANG("SDT")=%SystemDate+TRANG("EFDOFF")

	// Prior to starting date logic, first standing order could not be today
	if 'eftpay.frequency.isNull(),TRANG("SDT").isNull() set TRANG("SDT")=%SystemDate+1

	// Use starting date logic if EFD is not passed  
	if TRANG("EFD").isNull(),TRANG("SDT").isNull() set TRANG("SDT")=%SystemDate
	if TRANG("EFD").isNull() set TRANG("EFD")=%SystemDate

	if TRANG("SDT") do {

		type String EFTTYPE,RECINST
		type Number FREQ
		type Date SDT

		if 'eftpay.frequency.isNull() set FREQ=eftpay.frequency
		else  set FREQ="1DA" 
        
		set RECINST=eftpay.recinst
		set EFTTYPE=eftpay.efttype

		if 'Db.isDefined("UTBLEFTINST","RECINST") do {  quit
			set ER=1
			set RM=$$^MSG(979,"UTBLEFTINST.RECINST "_$$^MSG(1485,RECINST))
		}
		
		type RecordUTBLEFTINST eftinst=Db.getRecord("UTBLEFTINST","RECINST")
		
		if 'Db.isDefined("CTBLEFTTYPE","EFTTYPE") do {  quit
			set ER=1
			set RM=$$^MSG(979,"CTBLEFTTYPE.EFTTYPE "_$$^MSG(1485,EFTTYPE))
		}
		
		type RecordCTBLEFTTYPE efttype=Db.getRecord("CTBLEFTTYPE","EFTTYPE")
		
		/*
		 Go backwards to assign the correct starting date to allow for the Starting Date
		 to be a possible valid effective date. 
		*/
		set SDT=$$NJD^UFRE(TRANG("SDT"),FREQ,,1) quit:ER

		set eftpay.efd=$$DATES^EFTFUNCS(SDT,FREQ,eftinst.onus,0,efttype.stbleft,eftpay.crcd)
		}
	else  set eftpay.efd=TRANG("EFD")

	if ER quit ""

	// Set code generated fields
	set eftpay.amount=TAMT
	set eftpay.cc=CC
	set eftpay.lnm=LNM
	set eftpay.ttype=TTYPE

	/*
	 This next section of code is to support the TTXFDT=1 option,
	 which will only support the limited set of EFTPAY fields.

	 The code below will validate the EFTPAY fields for today's
	 date and if OK return the entry back in array TTXEFT.

	 The entry will then be created and processed via TTXFDT
	*/
	if TTXFDT do { quit ""
		type Date SVEFD

		set SVEFD=eftpay.efd
		set TPD=$$TPD(TRANG("TPD")) quit:ER

		// Redefine EFD to be today
		set eftpay.efd=$S(TPD.get():TPD,1:%SystemDate)

		/*
		 Perform and incremental rollback so no updates occur 
		 during the validation process.
		*/

		TStart ():transactionid="CS"

		set level=$TLevel-1

		do eftpay.save("VALDD/VALRI/VALREQ")

		if level'<($TLevel-1) TrollBack:$TLevel level
		
		// Error processing EFT transaction
		if ER set RM=$S('(RM.get().isNull()):RM,1:$$^MSG(3530)) quit

		set eftpay.efd=SVEFD
		set EFD=SVEFD

		set EFTPAY("EXTTRF")=$$EXTTRF(.eftpay)
	}

	do eftpay.save("VALDD/VALRI/VALREQ")

	// Error processing EFT transaction
	if ER set RM=$S('(RM.get().isNull()):RM,1:$$^MSG(3530)) quit ""

	set EFTSEQ=eftpay.seq

	// Update arrays with info needed for response
	type RecordEFTPAY eftpay2=Db.getRecord("EFTPAY","CID=:CID,SEQ=:EFTSEQ")

	set LOCAL("EFTPAY.SEQ")=eftpay2.seq
	set LOCAL("EFTPAY.EFTTYPE")=eftpay2.efttype
	set LOCAL("EFTPAY.STATUS")=eftpay2.status
	set (LOCAL("EFD"),EFTPAY("EFD"))=eftpay2.efd
	kill EFTPAY("EFTPAY.EFTTYPE")

	/*
	 If status not equal to 'A'dded, or process date not today or it's a
	 standing order set PROCESS=0 (do not process immediately).
	*/
	if '((eftpay2.status="A")&(eftpay2.frequency="")&(eftpay2.procdt=%SystemDate)) set PROCESS=0

	quit eftpay2.seq


EXTTRF(RecordEFTPAY eftpay)
	// Build TSO field EXTTRF	

	type String EXTTRF=""

	set EXTTRF.piece("^",1)=eftpay.recacct
	set EXTTRF.piece("^",2)=eftpay.recinst
	set EXTTRF.piece("^",3)=eftpay.amount
	set EXTTRF.piece("^",4)=eftpay.crcd
	set EXTTRF.piece("^",5)=eftpay.variable
	set EXTTRF.piece("^",6)=eftpay.constant
	set EXTTRF.piece("^",7)=eftpay.specific
	set EXTTRF.piece("^",8)=eftpay.efd
	set EXTTRF.piece("^",9)=eftpay.frequency
	set EXTTRF.piece("^",10)=eftpay.source
	set EXTTRF.piece("^",11)=eftpay.cc
	set EXTTRF.piece("^",12)=eftpay.status
	set EXTTRF.piece("^",13)=eftpay.met
	set EXTTRF.piece("^",14)=eftpay.tries
	set EXTTRF.piece("^",15)=eftpay.actamt
	set EXTTRF.piece("^",16)=eftpay.thold
	set EXTTRF.piece("^",18)=eftpay.amttyp
	set EXTTRF.piece("^",19)=eftpay.efttype
	set EXTTRF.piece("^",20)=eftpay.pri

	set EXTTRF.piece("^",22)=eftpay.expdt

	set EXTTRF.piece("^",24)=eftpay.cid

	set EXTTRF.piece("^",26)=eftpay.lnm
	set EXTTRF.piece("^",27)=eftpay.ttype

	if 'eftpay.msg103dt.isNull() set EXTTRF.piece("^",32)=eftpay.msg103dt
	if 'eftpay.hldauto.isNull() set EXTTRF.piece("^",33)=eftpay.hldauto
	
	quit EXTTRF


BLDTTX2(RecordTTX ttx(),	// TTX Record
	String LOCAL,		// Profile Account Parameter Array
	String EFTPAY,		// EFT Parameter Array
	String TRANG,		// Global Parameter Array
	Number SEQ)		// From or To Sequence
	// Build EFT transaction records from Account Qualifiers

	type Public Number ER

	type String ITC,TSO,UTSO,XETC

	// Build TSO, TRANG("TSO") not passed for EFT transactions
	set UTSO("EXTTRF")=EFTPAY("EXTTRF")
	if TRANG("HLDDYS").exists() set UTSO("HDYS")=TRANG("HLDDYS")
	do IN^UTSO(.UTSO,.TSO)
	set TRANG("TSO")=TSO

	if SEQ="F" set XETC="EXTCR",ITC=1
	else  set XETC="EXTDR",ITC=0

	// Determine and validate tran code
	set ER=$$ETCCHK(.LOCAL,SEQ) quit:ER

	// Build Profile transaction
	do BLDTTX(.ttx(),.LOCAL,.TRANG) quit:ER

	set ttx(2)=ttx(1).copy()
	set ttx(2).cid=$$GETGL(XETC,ITC)
	set ttx(2).itc=ITC
	set ttx(2).etc=XETC

	quit


EFTFMT(String REPLY,		// Standard Response
	String OM(),		// Trans Proc Output Array
	String FORM)		// SQL Stored Procedure name
	// Build EFT Response Array

	// If no output is requested then quit.
	if FORM="NOFORM" set REPLY="" quit

	type Public Number ER
	type Public String TRANG()

	// Create standard response
	type String KEY,RESP,SEQ,XSEQ

	set (SEQ,XSEQ)=0
	for KEY="F","T" set SEQ=SEQ+1 do { quit:ER
		type String CRCD,EBAL,TAMT,TRC,HSEQ
		set XSEQ=XSEQ+1
		set (CRCD,EBAL,HSEQ,TRC)=""
		set TAMT=TRANG("TAMT")
		set CRCD=TRANG("BCRCD")

		if OM(SEQ).exists() do {
			set TRC=OM(SEQ).piece("|",3)
			set TAMT=OM(SEQ).piece("|",4)
			set EBAL=OM(SEQ).piece("|",5)
			set HSEQ=OM(SEQ).piece("|",6)
		}

		set RESP(XSEQ).piece($C(9),1)=$$TRAN(KEY,"ACCT")
		set RESP(XSEQ).piece($C(9),2)=TRC
		set RESP(XSEQ).piece($C(9),3)=""
		set RESP(XSEQ).piece($C(9),4)=TAMT
		set RESP(XSEQ).piece($C(9),5)=CRCD
		set RESP(XSEQ).piece($C(9),6)=EBAL
		set RESP(XSEQ).piece($C(9),7)=HSEQ
		set RESP(XSEQ).piece($C(9),8)=$$TRAN(KEY,"INST")
		set RESP(XSEQ).piece($C(9),9)=$$TRAN(KEY,"EFTPAY.EFTTYPE")
		set RESP(XSEQ).piece($C(9),10)=$$TRAN(KEY,"EFTPAY.SEQ")
		set RESP(XSEQ).piece($C(9),11)=$$TRAN(KEY,"EFD")
		set RESP(XSEQ).piece($C(9),12)=$$TRAN(KEY,"EFTPAY.STATUS")
	}

	// Return standard response
	if FORM="" set REPLY=RESP(1)_$C(13,10)_RESP(2)
	// Use specified stored procedure to format a reply.
	else  do SPFMT(.REPLY,.RESP,FORM)

	quit


STFEFT
	// Process EFT request using Host Store and Forward	

	type Public Number ER,%STFHOST
	type Public String FQUAL,GQUAL,REPLY,SQLDTA,TQUAL

	type String X,CID,X2
	set X="EXECUTE $$SPODBC^MRPC029(1,"
	set X=X_$$QADD^%ZS(FQUAL)_","
	set X=X_$$QADD^%ZS(TQUAL)_","
	set X=X_$$QADD^%ZS(GQUAL)_")"

	/*
	 Determine if From or To qualifier is local and
	 get account number from it.
	*/
	set X2=""
	if FQUAL'["EFTTYP" set X2=+(FQUAL.piece("ACCT=",2))
	if TQUAL'["EFTTYP" set X2=+(TQUAL.piece("ACCT=",2))
	if X2 set CID(X2)=""
	type RecordTTX ttx()
	do STFHNDL^STFUTL(.ttx(),%STFHOST,5,X,,.CID)
	quit:ER
	set REPLY=SQLDTA.get()
	quit


TRAN(String CAT,	// Catagory "F" or "T"
	String KEY)	// Key Into tran* array
	/*
	 Return entry from appropriate TRAN* array
	 
	 INPUTS:
		. TRANF		From Transaction info /TYP=T/REQ

		. TRANT 	To Transaction info /TYP=T/REQ

	 RETURNS:
		. $$ 		Entry from tran* array /TYP=T
	*/

	type Public String TRANF(),TRANT()

	if CAT="F" quit TRANF(KEY).get()
	quit TRANT(KEY).get()


SPVOVR(String TSPV(),	// Supervisory override Array
	String SPVOVR)	// Supervisory override parameter

	/*
	 Translate the SPVOVR variable into the supervisory override array
	 for the appropriate sequence.

	 EXAMPLE:
		set EQ="F"/REST=RFLG.001/UID=1/PWD=XXX/REST=RFLG.002/UID=22/PWD=ZZZ
		/SEQ=T/REST=OVR.BAL/UID=1/PWD=XXX
	*/

	type Public Number ER
	type Public String RM,TRANF(),TRANT()

	type String list,tbl,name,val,i,str,CID,SEQ,REST,UID,PWD,AUID,CNT,SPV,DUID,DPWD,K3
	set list=",SEQ,REST,UID,PWD,"
	
	if (CUVAR.AUTOAUTH = 1) do {
		set TSPV("*") = %UserID_"|"_%UserClass
	}
	
	set CID(1)=TRANF("ACCT"),CID(2)=TRANT("ACCT")
	set SEQ=1,(DUID,DPWD)="",(CNT,ER)=0

	/* PARSE SPVOVR STRING

	 1. Validate Keywords and Values
	 2. Build REST and SPV arrays

	 The SPVOVR string is parsed twice to allow the keywords to be
	 specified in any order, and so that UID and PWD only have to be
	 entered once. Although a UID and PWD can be specified for each
	 restriction.  The expected order would be SEQ/REST/UID/PWD. See
	 example in section header. For each restriction found w/o a UID
	 and/or PWD the first UID/PWD found will be used as a default.
	 CNT is represent the restriction count within each SEQ.
	 CNT is incr for each SPVREST found, however if a 2nd UID or PWD is
	 found for the current CNT value, then CNT is bumped then.
	*/

	for i=1:1:$L(SPVOVR,"/") do { quit:ER
		set str=SPVOVR.piece("/",i) 
		set name=str.piece("=",1) quit:name=""
		set val=str.piece("=",2,9) quit:val=""

		// Invalid keyword - ~p1
		if list'[(","_name_",") do Runtime.setErrMSG("TTX",1385,name) quit
		if name="SEQ" do { quit
			if "TF"[val set SEQ=$S(val="T":2,1:1)
			else  do Runtime.setErrMSG("TTX",1385,str)
		}
		if name="REST" do { quit
			set tbl=val.piece(".",1)
			if "*,RFLG,OVR,"'[(","_tbl_",") do Runtime.setErrMSG("TTX",1385,str)
			else  do spv(SEQ,.CNT,val,,1)
		}
		// default user id
		if name="UID" do spv(SEQ,.CNT,"UID",val) if DUID="" set DUID=val
		// default password		 
		if name="PWD" do spv(SEQ,.CNT,"PWD",val) if DPWD="" set DPWD=val		 
	}
	if ER!'(REST.exists()) quit
	// Invalid keyword - ~p1
	if DUID="" do { quit:ER
		if CUVAR.AUTOAUTH = 2 do {
			set DUID = %UserID
			set DPWD = "#AutoAuth"
			set AUID(DUID) = %UserClass
		}
		else  do Runtime.setErrMSG("TTX",1385,"UID") quit
	}
	if DPWD="" do Runtime.setErrMSG("TTX",1385,"PWD") quit

	// BUILD TSPV ARRAY

	set (CNT,K3)=""
	for SEQ=1:1:2 do {  quit:ER
		for  set CNT=SPV(SEQ,CNT).order() quit:CNT=""  do { quit:ER
			set (REST,UID,PWD)=""

			for  set K3=SPV(SEQ,CNT,K3).order() quit:K3=""  do { quit:ER
				if K3="PWD" set PWD=SPV(SEQ,CNT,K3)
				else  if K3="UID" set UID=SPV(SEQ,CNT,K3)
				else  set REST=K3
			}

			if REST="" quit
			if UID="" do {
				if CUVAR.AUTOAUTH = 2 do {
					set UID = %UserID
					set AUID(UID) = %UserClass
					set PWD = "#AutoAuth"
				}
				else set UID=DUID
			}
			
			if PWD="" set PWD=DPWD

			if '(AUID(UID).exists()) do { quit:ER
				if '$$VALIDATE^SCADRV1(PWD,UID) set ER=1 quit

				type RecordSCAU scau=Db.getRecord("SCAU","UID")
				set AUID(UID)=scau.%ucls
			}
			
			if REST = "*" set TSPV(SEQ) = UID_"|"_AUID(UID)
			else  do {
				set tbl=REST.piece(".",1),val=REST.piece(".",2)
				set TSPV(SEQ,CID(SEQ),tbl,val)=UID_"|"_AUID(UID)
			}
		}
	}
	quit


spv(Number seq,		// sequence 1 or 2
	Number cnt,	// counter
	String k3,	// third key
	String val,	// value
	Boolean ovr)	// Use REST() array
	// Build REST() array

	type Public String REST(),SPV()

	type Number dup=0

	if ovr.get() do { quit:dup
		if REST(seq,k3).exists() set dup=1
		else  set cnt=cnt+1,REST(seq,k3)=cnt
	}
	else  if SPV(seq,cnt,k3).exists() set cnt=cnt+1
	set SPV(seq,cnt,k3)=val.get()
	quit


QUALIN(String array(),	// Input Array
	String qual)	// Output data
	/*
	 Create QUAL from ARRAY

	 Returns:  qual = data from array
	*/

	type String N
	set (N,qual)=""
	for  set N=array(N).order() quit:N=""  set qual=qual_N_"="_array(N)_"/"
	if qual.extract(qual.length())="/" set qual=qual.extract(1,$L(qual)-1)
	quit


SPODBC(String VERSN,	// Version
	String FQUAL,	// FQUAL
	String TQUAL,	// TQUAL
	String GQUAL,	// Global Qualifier String
	String SPVOVR)	// Supervisory override

	/*
	 Stored Procedure/ODBC Entry Point

	 This function is intended to provide a capability to invoke a
	 true MRPC from the EXECUTE procedure facility within the PROFILE
	 ODBC driver.  This is needed in order to get the normal response
	 argument that is part of the MRPC structure returned to the calling
	 ODBC client.
	*/

	type Public Boolean ER
	type Public String RM(),stfflg
	type Number vzstfflg
	type String ERRMSG,PTR,RETURN
	
	set vzstfflg=stfflg.get()
	set ERRMSG=""

	do PROC(.RETURN,VERSN.get(),FQUAL.get(),TQUAL.get(),GQUAL.get(),SPVOVR.get())

	if RM="",ERRMSG="" quit RETURN

	// Error message not in LV
	if ERRMSG="" set ER=1 quit ""

	// Error message in LV
	set PTR=$$LV2V^MSG(ERRMSG,.RM)
	set ER=1

	// Application error response
	if RM(1)="ER" set RM=RM(5).get()
	else  set RM=ERRMSG

	quit ""


FINDH(Number CID,		// PROFILE account number
	String MRPC29,		// Reversal ID
	Number BRCD,		// Branch Code
	Number PSTDYS,		// Number of days to search into an account's history
	RecordHIST hist,	// Returned HIST object
	RecordSTFHOST stfhost,	// Returned STFHOST object
	RecordTTXFDT ttxfdt)	// Returned TTXFDT object
	/*
	Find history entry matching CID, MRPC29 (ETC^TAMT), UID, and BRCD
		
	RETURNS:
		$$	Record Type (HIST, STFHOST, or TTXFDT)
			Indicates which of the three possible object
			types is returned.
	*/

	type Public Number %STFHOST
	type Public Date EFD

	type String DATE,RECTYP,UID

	set RECTYP=""
	if +CID=0 quit ""
	if 'Db.isDefined("ACN","CID") quit ""

	set UID=%UserID

	// Check in STFHOST for stored transaction
	if %STFHOST do {
		type DbSet ds1=Db.selectDbSet("STFHOST","CID=:CID AND MRPC29=:MRPC29 AND UID=:UID AND BRCD=:BRCD","STFSEQ DESC")
		while ds1.next() do { quit:'RECTYP.isNull()
			// Accept to avoid warning related to run-time possibility
			// of record on file.  This section does the loading.
			#ACCEPT DATE=8/28/02; PGM=Dan Russell; CR=Erik Scheetz
			set stfhost=ds1.getRecord("STFHOST")
			set RECTYP="STFHOST"
		}
	}

	if 'RECTYP.isNull() quit RECTYP

	// Check in HIST
	set DATE=%SystemDate-PSTDYS
	type DbSet ds2=Db.selectDbSet("HIST","CID=:CID AND TJD NOT <:DATE AND MRPC29=:MRPC29 AND UID=:UID AND BRCD=:BRCD","TSEQ DESC")
	while ds2.next() do { quit		// Take first hit
		set hist=ds2.getRecord("HIST")
		if 'hist.etc.isNull() set RECTYP="HIST" quit

		// May be future dated transaction - Find TTXFDT entry
		type DbSet ds3=Db.selectDbSet("TTXFDT","CID=:CID AND TJD=:EFD AND BRCD=:BRCD AND UID=:UID AND MRPC29=:MRPC29","TSEQ DESC")
		while ds3.next() do { quit
			set ttxfdt=ds3.getRecord("TTXFDT")
			set RECTYP="TTXFDT"
		}
	}

	quit RECTYP


REVERSE(RecordTTX ttx())	// Record TTX	
	// Locate Original transactions and create E/C or REVERSE info	

	type Public Number ER
	type Public String RM,RSPCD,TRANF(),TRANG(),TRANT()
	type Public Date EFD

	type String BRCD,CID,ETC,HTJD,ITC,ITC1,KEY,MRPC29,REC,RECTYP,seq,STFSEQ
	type String TMPTSO,TRAN,TRC,TRN,TRSEQ,TSEQ,TSO,UID
	type Date FDT

	// Catch record not on file errors associated with the various attempts
	// to load records in this section that may fail
	catch error {
		if error.type="%PSL-E-RECNOFL" set ER=1
        }

	//? Review these after PSL rewrite
	// Bug in TTXP2
	set FDT=EFD
	// Bug in TTXFDT filer
	set REC=""

	// Find Profile account
	if TRANF("CLS").get()'="M" set KEY="F",ITC1=0
	else  set KEY="T",ITC1=1

	set CID=$$TRAN(KEY,"ACCT")
	set BRCD=TRANG("BRCD")

	set MRPC29=TRANG("MRPC29").get()
	if MRPC29="" do {
		type Number TAMT
		set TAMT=$$TRAN(KEY,"TAMT")
		if TAMT="" set TAMT=TRANG("TAMT")
		set MRPC29=$$TRAN(KEY,"ETC")_"^"_TAMT
	}

	/* Find original transaction, use TSEQ to get original TR's
	   RECTYP and the corresponding object will be returned from
	   call to FINDH.
	*/
	type RecordHIST hist
	type RecordSTFHOST stfhost
	type RecordTTXFDT ttxfdt
	set RECTYP=$$FINDH(CID,MRPC29,BRCD,2,.hist,.stfhost,.ttxfdt)

	// Unable to locate transaction in account history
	if RECTYP="" do Runtime.setErrMSG("HIST",2793) quit

	// ASSERT: data contains either a HIST or TR record 

	// Set HTJD, used to decide whether to EC or REV
	if RECTYP="HIST" set HTJD=hist.tjd
	else  set HTJD=%SystemDate

	// Check if transaction has already been reversed or error corrected
	if RECTYP="HIST" set ITC=hist.itc,TSO=hist.tso
	else  if RECTYP="STFHOST" set ITC=stfhost.itc,TSO=stfhost.tso
	else  set ITC=ttxfdt.itc,TSO=ttxfdt.tso

	// Transaction already error-corrected
	if (ITC.extract(6))!(ITC.extract(12)) set RSPCD=2676 do Runtime.setErrMSG("HIST",2676) quit

	set UID=%UserID,EFD=""

	// Transaction found in history
	if RECTYP="HIST" do {
		type String ETC,CID,CLS,TPD
		set TPD=hist.tjd+ITC.extract(8)
		set TRC=hist.trc
		set TSEQ=hist.tseq

		if ITC1=0 set seq=1
		else  set seq=2

		set ttx(seq)=Db.getRecord("TTX","TJD=:TPD,BRCD=:BRCD,UID=:UID,TSEQ=:TRC")
		set CID=ttx(seq).cid
		set TRN(CID,TRC)=TSEQ_"|"_TRC

		if seq=1 set seq=2,TRC=TRC+1
		else  set seq=1,TRC=TRC-1

		// Get second transaction
		set TSEQ=""
		set ttx(seq)=Db.getRecord("TTX","TJD=:TPD,BRCD=:BRCD,UID=:UID,TSEQ=:TRC")

		set CID=ttx(seq).cid

		// Re-define TSEQ for the second transaction in the set
		set ETC=ttx(seq).etc

		type Public Cache %CACHE()
		type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")
		set CLS=trn.cls

		if HTJD'=%SystemDate,CLS'="M" do {
			type RecordHIST hist2
			type String RECTYP2
			if MRPC29["^" do {
				type Number TAMT
				set TAMT=$S(KEY="F":TRANT("TAMT").get(),1:TRANF("TAMT").get())
				if TAMT="" set TAMT=TRANG("TAMT")
				set MRPC29=ETC_"^"_TAMT
			}
			set RECTYP2=$$FINDH(CID,MRPC29,BRCD,2,.hist2)
			if RECTYP2="HIST" set TSEQ=hist2.tseq
			else  set TSEQ=""
		}
		set TRN(CID,TRC)=TSEQ.get()_"|"_TRC
	}

	// Transaction was found in TTXFDT
	else  if RECTYP="TTXFDT" do {
		// Get first transaction
		type String CID,MAXSEQ,MINSEQ
		set TRSEQ=ttxfdt.tseq
		set seq=TRSEQ.extract(TRSEQ.length())

		// TTXFDT stores secondary transactions
		if seq=3 set seq=2

		// Move TTXFDT into TTX
		set ttx(seq)=ttxfdt.copy()

		set CID=ttx(seq).cid
		set TRN(CID,TRSEQ)=""

		// Get second transaction
		set EFD=ttx(seq).efd
		if seq=1 set seq=2
		else  set seq=1

		// Find offset transaction, using transaction code
		if KEY="F" set ETC=$$TRAN("T","ETC")
		else  set ETC=$$TRAN("F","ETC")
		set MINSEQ=(TRSEQ\1000)*1000
		set MAXSEQ=MINSEQ+1000
		type DbSet ds=Db.selectDbSet("TTXFDT","TJD=:EFD AND BRCD=:BRCD AND UID=:UID AND TSEQ BETWEEN :MINSEQ AND :MAXSEQ AND TSEQ<>:TRSEQ AND ETC=:ETC")
		if ds.isEmpty() set ER=1 quit
		if ds.next() do {
			type RecordTTXFDT ttxfdt2
			set ttxfdt2=ds.getRecord("TTXFDT")
			set TRSEQ=ttxfdt2.tseq

			set ttx(seq)=ttxfdt2.copy()
			set CID=ttx(seq).cid
			set TRN(CID,TRSEQ)=""
		}
	}

	// Transaction was found in store and forward
	else  if RECTYP="STFHOST"  do {
		set TRSEQ=stfhost.trseq
		set seq=TRSEQ
		do STF2TTX(.stfhost,.ttx(seq))
		set TRSEQ=$S(TRSEQ=1:2,1:1)

		type RecordSTFHOST stfhost2=Db.getRecord("STFHOST","STFSEQ=:STFSEQ,TRSEQ=:TRSEQ")
		set seq=TRSEQ
		do STF2TTX(.stfhost2,.ttx(seq))
	}
	
	quit:ER

	// Modify original transactions with reversal information
	for seq=1,2 do {
		type Number CID,FLG

		if '(ttx(seq).exists()) quit

		set CID=ttx(seq).cid

		// Update Internal Transaction Code
		set ITC=ttx(seq).itc
		if (ITC.extract(6))!(ITC.extract(12)) set ER=1 quit
		set FLG=$S(HTJD=%SystemDate:6,1:12)
		set ITC=$$ITC^TTXEXT(ITC,FLG,1)		// Error-correct or reversal flag
		set ttx(seq).itc=ITC

		// Negate the amount field
		set ttx(seq).tamt=$$TAMT^TRNUTL(ttx(seq).tamt)

		// Add reversal fields to TSO
		if RECTYP="HIST",TRN(CID).exists() do {
			set TRC=TRN(CID,"").order()
			if HTJD=%SystemDate set TMPTSO("EC")=TRN(CID,TRC).piece("|",2)
			else  set TMPTSO("REV")=+TRN(CID,TRC)
		}
		if RECTYP="TTXFDT" do {
			set TMPTSO("FDTSEQ")=TRN(CID,"").order()
			set TMPTSO("EC")=TMPTSO("FDTSEQ")
		}
		if RECTYP="STFHOST" set TMPTSO("EC")="STF"_STFSEQ_"-"_seq

		do IN^UTSO(.TMPTSO,.TSO)

		set ttx(seq).tso=TSO
	}

	quit


GETGL(String ETC,	// External transaction code
	String ITC)	// Internal transaction code
	/*
	 EXTDR or EXTCR transaction record.  This is used for
	 future dated eft records.
	*/

	type Public Number ER
	type Public String RM

	type String TCID,UID

	catch error {
		// Invalid teller ID
		if error.type="%PSL-E-RECNOFL" do Runtime.setErrMSG("TTX",3533)
        }

	if ETC="" quit ""

	type Public Cache %CACHE()
	type RecordTRN trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")
	// Invalid transaction code ~p1
	if 'trn.getMode() do Runtime.setErrMSG("TRN",1498,ETC) quit ""

	set TCID=trn.acn		// G/L offset
	if TCID="" do { quit:ER ""
		type String SRCTYP,KEY
		set SRCTYP="BOFF"
		set KEY="EFT"

		type Public Cache %CACHE()
		type RecordUTBLSRC utblsrc=%CACHE("UTBLSRC").getRecord("UTBLSRC","SRCTYP=:SRCTYP,KEY=:KEY")

		set UID=utblsrc.uid

		// Invalid teller ID
		if UID="" do Runtime.setErrMSG("TTX",3533) quit

		type RecordSCAU scau=Db.getRecord("SCAU","UID")
		// Invalid teller ID
		if 'scau.getMode() do Runtime.setErrMSG("TTX",3533) quit

		if ITC set TCID=scau.tsdr		// DR suspense
		else  set TCID=scau.tscr		// CR suspense
	}

	quit TCID

STF2TTX(RecordSTFHOST stfhost,
	RecordTTX ttx)

	// copy STFHOST transaction columns to TTX record

	type Public String BRCD

	set ttx.tjd=%SystemDate
	set ttx.brcd=BRCD
	set ttx.uid=%UserID
	set ttx.tseq=""

	set ttx.cid=stfhost.cid
	set ttx.itc=stfhost.itc
	set ttx.etc=stfhost.etc
	set ttx.tamt=stfhost.tamt
	set ttx.efd=stfhost.stfefd
	set ttx.tlo=""
	set ttx.tso=""
	set ttx.tcmt=stfhost.tcmt
	set ttx.cdt=stfhost.cdt
	set ttx.tim=""
	set ttx.brcde=""
	set ttx.trc=stfhost.trc
	set ttx.uidt=""
	set ttx.spr=stfhost.spr
	set ttx.tsb=stfhost.tsb
	set ttx.lnerc=stfhost.xhs16
	set ttx.crcd=stfhost.crcd
	set ttx.rate=stfhost.rate
	set ttx.vdt=stfhost.vdt
	set ttx.cc=stfhost.ben
	set ttx.dir=stfhost.dir
	set ttx.chktyp=""
	set ttx.endbal=stfhost.endbal
	set ttx.mult=stfhost.mult
	set ttx.bseamt=stfhost.bseamt
	set ttx.custcd=stfhost.custcd
	set ttx.tresref=stfhost.tresref
	set ttx.rty=""
	set ttx.msd=""
	set ttx.glsc=stfhost.glsc
	set ttx.udprin=stfhost.udprin
	set ttx.bcrcd=""
	set ttx.xpdo=""
	set ttx.sysbase=stfhost.sysbase
	set ttx.cmpsav=stfhost.cmpsav

	quit

PRETTX
	/*
	 Pre processor for Teller System transactions

	 This section can be customized by copying MRPC029 to ZMRPC029.
	*/

	quit


PREEFT
	/*
	 Pre processor for Teller System transactions

	 This section can be customized by copying MRPC029 to ZMRPC029.
	*/

	quit

vSIG()	quit "60641^44893^Shriram Deshpande^57417"	// Signature - LTD^TIME^USER^SIZE
