public UTLLIST(String IF,String OF,String PROMPT,String HDG,String IFKEYS,Number COUNT)
  /*
	ORIG: kellyp - 03/23/2005
	DESC: Utility to create a list

   ---- Comments --------------------------------------------------------

	This utility builds a list of Data-Qwik prompts, prompts user for
	the data and returns data values.
	
	Input files are specified as either:

	   A file syntax of [FILE] which specifies a database table
	   A file syntax of FILE which specifies a local array name

	ARGUMENTS:
	   . IF    	Input file/array name	/REQ/MECH=VAL
	      Format can be "[FILE]", "ARRAY", or "ARRAY(".

	   . OF		Output array name	/REQ/MECH=VAL
	      Format can be "ARRAY" or "ARRAY(".
	   	
	   . PROMPT	User prompt		/NOREQ/MECH=VAL
	      The prompt that appears before each user selection.
	   
	   . HDG	Screen heading		/NOREQ/MECH=VAL
	      The label that will appear at the top of the screen.
	   
	   . IFKEYS	Key values to IF table	/NOREQ/MECH=VAL
	      A comma-delimited list of the input table's dynamic key 
	      values, up to the key desired for user selection, 
	      appearing in the same order as in the table definition.  
	      Static numeric and  static literal keys should not be 
	      included.
	   
	   . COUNT	Selection count		/NOREQ/MECH=REF
	      The number of user selections added to OF.

	RETURNS
	   @OF - Array specified by OF, populated with user selections
	   COUNT - Number of records selected

	Sample Calls: @DBSUTL6 - Delete Files (^DBSUTL6)

   ---- Revision History ------------------------------------------------

	08/02/06 - KELLYP - CR 22048
		Modified INIT section to eliminate DYNAMIC warning.
   
   	07/14/06 - RussellDS - CR22121
   		Removed $C(255) reference and replaced with use of
   		PSL.maxCharValue to make Unicode compliant.

	03/30/05 - KELLYP - CR 13666
		Converted to PSL.  Major revisions to procedure include
		removing support for table-oriented output (only output
		arrays are permitted) and removing support for global-
		oriented input tables.  Input tables are still permitted
		but the "[TABLE]" syntax must be used and the keys must
		be passed in using the new IFKEYS argument. 

   ----------------------------------------------------------------------
 */

	type public Boolean ER
	type public Number %TO
	type public String %fkey,VFMQ

	type Boolean DBIF,MORE
	type Number I,%IPMODE,J,OLNTB
	type String IFDATA(),QU,%READ,SOF(),%TAB(),TABLE,TMP(),X

	if %fkey("").order().isNull() do ZBINIT^%TRMVT()
	if '%TO.exists() set %TO=CUVAR.%to

	do INIT quit:ER
	
	do KILL
	
	set MORE=1
	
	while MORE do { quit:VFMQ="Q"
	
		set %TAB("TMP")="/DES="_PROMPT_"/TYP=T/LEN=20/TBL="_TABLE_QU_"/XPP=D PP^UTLLIST"
		
		if 'HDG.get().isNull() set HDG=HDG.justify(80,0)
		if  set %READ="@HDG,,TMP*"_(18-(OLNTB.get()\1000))
		else  set %READ="TMP*"_(20-(OLNTB.get()\1000))
		
		set MORE=0
		
		if %IPMODE.get()'["NOINT" set %TAB("MORE")=".MORE1"
		set %READ=%READ_",MORE"

		do ^UTLREAD
		
		if VFMQ="Q" do { quit
			do KILL
			set MORE=0
			}

		set J=+SOF("").order(-1)
		for I=1:1:TMP("").order(-1) set SOF(J+I)=TMP(I)
		}

	do EXIT
	
	quit


EXIT	// Populate the Output File

	type public Boolean DBOF
	type public Number COUNT
	type public String OF(),SOF()

	type Number I	
	type String X

	set X=OF.piece("(",1)
		
	kill @X

	set COUNT=0
		
	// Populate the output array
	for I=1:1:SOF("").order(-1) do {
			
		if SOF(I).isNull() quit
			
		set COUNT=COUNT+1
		
		set X=OF_""""_SOF(I)_""")"
	
		set @X=""
		}
	
	quit


PP	// Selection post-processor

	type public Boolean ER
	type public String %fkey,I(),OF,TMP(),X

	type Boolean NOT
	type Number LSTNOD
	type String N,XCT

	if "SHOW LIST"=X.piece(" ",1,2) do { quit
		set X=X.piece(" ",3)_"?"
		set I(3)=OF
		}
	
	if X.isNull() quit
	if "?!"[X.extract(X.length()) quit
	if (%fkey="FND")!(%fkey="SEL") quit
	
	if X.extract(1)="'" set NOT=1
	else  set NOT=0

	// Wildcard was entered
	if X?.E1"*".E do { quit
		do WILD
		set X=""
		}
	
	// Range of values was entered
	I X["-",'X.piece("-",2).isNull() do { quit
		do RANGE
		set X=""
		}

	set LSTNOD=TMP("").order(-1)
	set N=X.extract(1+NOT,999)
	
	// Remove a single entry
	if NOT do { quit

		type Boolean FOUND

		set FOUND=0

		for I=1:1:LSTNOD do { quit:FOUND
			if TMP(I)'=N quit
			set FOUND=1
			set TMP(I)=""
			set X=""
			}
		
		// Record ~p1 is not in the save list
		if 'FOUND do Runtime.setErrMSG("DBTBL1","2340",N) quit:ER
		}
	
	quit

WILD	// Wildcard entry was used

	type public Boolean ER,NOT
	type public String IFDATA(),X

	type String END,START

	// Invalid syntax/name
	if '((X.extract(X.length())="*")&(X.extract(1,X.length()-1)'?.E1"*".E)) do Runtime.setErrMSG("DBTBL1","1480") quit:ER

	// Set up wildcard range's initial start and end values
	
	// Only a wildcard was entered
	if X.extract(1+NOT)="*" do {
		// Set START to first entry since SELECT will bump START back to null before looping
		set START=IFDATA("").order()
		// Set END to next to last entry since SELECT will bump END to last entry before looping
		set END=IFDATA("").order(-1)
		set END=IFDATA(END).order(-1)
		}
	// Text and wildcard were entered, select all entries beginning with text entered
	else  do {
		set START=X.extract(1+NOT,X.length()-1)
		set END=START_$C(PSL.maxCharValue)
		}

	do SELECT
	
	quit


RANGE	// Select a range of entries

	type public Boolean NOT
	type public String X
	
	type String END,START

	// Set up range's initial start and end values
	set START=X.extract(1+NOT,999).piece("-",1)
	set END=X.piece("-",2,99)
	
	do SELECT
	
	quit


SELECT	// Fetch or delete the range of entries

	type public Boolean NOT
	type public String END,ER,IFDATA(),RM,START,TMP()
	
	type Number CNT,NOD
	type String ENTRY,FIRST,LAST
	
	set CNT=0
	
	// Bump the START and END values for the loop
	set ENTRY=IFDATA(START).order(-1)
	set END=IFDATA(END).order()
	
	// Loop through the list of possible values and add or delete
	// all entries that fall between START and END (inclusive).
	for  set ENTRY=IFDATA(ENTRY).order() quit:(ENTRY=END)  do {
		
		set NOD=""
		
		set CNT=CNT+1
		
		// Delete entry from range
		if NOT do {
			for  set NOD=TMP(NOD).order() quit:NOD.isNull()  do {
				if 'TMP(NOD)=ENTRY quit
				set TMP(NOD)=""
				}
			}
		else  do {
			// Add entry from range
			set NOD=TMP(NOD).order(-1)+1
			set TMP(NOD)=ENTRY
			}

		if CNT=1 set FIRST=ENTRY,LAST=ENTRY
		else  set LAST=ENTRY
		}		

	// I18N=ON
	set ER="W"
	
	// Zero records selected
	if 'CNT set RM=$$^MSG(2990) quit
	
	// ~p1 records deleted (~p2 - ~p3)
	if NOT set RM=$$^MSG(3073,CNT,FIRST,LAST)
	
	// ~p1 records added (~p2 - ~p3)
	else  set RM=$$^MSG(3072,CNT,FIRST,LAST)

	quit


KILL	// Kill storage array(s)

	type public String OF()

	type String X

	// Kill the array specified by OF but not OF itself
	set X=OF.piece("(",1)
	
	kill @X
	
	quit


INIT	// Initialization

	type public Boolean DBIF,ER
	type public String IF,IFDATA(),IFKEYS,OF,PROMPT,QU,TABLE

	type Number I
	type String END,X
	
	set ER=""
	set QU=""
	set IFKEYS=IFKEYS.get()
	
	// Determine if IF is a DB table
	if IF.extract(1)="[" set DBIF=1
	else  set DBIF=0

	if 'DBIF do {	// Input file is an array
		
		/*
		 Need to normalize the IF array reference.  The input
		 array can be specified as:
		
			ARR   Selection is on VAR1 in ARR(VAR1)
			ARR(   Selection is on VAR1 in ARR(VAR1)		
		*/
		
		set X=IF
		
		set END=X.extract(X.length())
		if END'="(" set X=X_"("

		set X=X_"I)"
		
		set I=""
		
		// Set up data array (used for consistency)
		for  set I=@X.order() quit:I.isNull()  do {
			set IFDATA(I)=""
			}
		
		set TABLE="IFDATA("
		
		if PROMPT.isNull() do {
			// Get table description from array name
			set PROMPT=IF.piece(")",1)
			do TRANSLAT
			}
		}
	else  do { quit:ER	// Input file is a table
		
                type String ACCKEYS,BTMKEY,FSN(),WHERE
 
 		set TABLE=IF.extract(2,IF.length()-1)

		do fsn^DBSDD(.FSN(),TABLE) quit:ER

		type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:TABLE",1)
		
		// Invalid table name - ~p1
		if 'dbtbl1.getMode() do Runtime.setErrMSG("DBTBL1","1484",IF) quit:ER
		
		// Get keys from fsn call because the literal keys are stripped out
		set ACCKEYS=FSN(TABLE).piece("|",3)
		set BTMKEY=ACCKEYS.piece(",",ACCKEYS.length(","))
		
		if PROMPT.isNull() do {
			// Get table description from DBTBL1 table 
			set PROMPT=dbtbl1.des
			do TRANSLAT
			}

                // Only one key to table, none should be passed in
                if ACCKEYS.length(",")=1 do { quit:ER
                	// Missing look-up table definition
                	if 'IFKEYS.isNull() do Runtime.setErrMSG("DBTBL1","1763") quit:ER
                	set WHERE=""
                	}
                // N keys to table, N-1 should be passed in
                else  do { quit:ER
                	// Missing look-up table definition
                	if ACCKEYS.length(",")'=(IFKEYS.length(",")+1) do Runtime.setErrMSG("DBTBL1","1763") quit:ER	
                	
                	// Set up query for table lookup
                	set QU=":QU """
                	
			set WHERE=""
			for I=1:1:IFKEYS.length(",") do {
				set WHERE=WHERE_ACCKEYS.piece(",",I)_"='"_IFKEYS.piece(",",I)_"' AND "
				set QU=QU_IF_ACCKEYS.piece(",",I)_"="_IFKEYS.piece(",",I)_" & "
				}
			
			// Strip off last " AND " from WHERE clause
	                set WHERE=WHERE.extract(1,WHERE.length()-5)
	                
	                // Strip off last " & " from query and add ending quote
	                set QU=QU.extract(1,QU.length()-3)_""""
                	}

		#ACCEPT DATE=08/02/06;PGM=KELLYP;CR=18140
                type ResultSet rs=Db.select(BTMKEY,TABLE,WHERE,BTMKEY_" ASC")
                
                // Missing look-up table definition
                if rs.isEmpty() do Runtime.setErrMSG("DBTBL1","1763") quit:ER
                
                // Populate the IFDATA array for selection searches (e.g., range or wildcard)
                while rs.next() set IFDATA(rs.getCol(1))=""
                
                // Restore original value of TABLE for lookup table purposes
                set TABLE=IF
                }

	/*
	 Need to normalize the OF array reference.  The output
	 array can be specified as:
		
		ARR   Selected data stored in VAR1 in ARR(VAR1)
		ARR(  Selected data stored in VAR1 in ARR(VAR1)
	*/
		
	set END=OF.extract(OF.length())
	if END'="(" set OF=OF_"("
	
	quit

TRANSLAT // Translate the prompt to Upper and lower case

	type public String PROMPT

	set PROMPT=PROMPT.extract(1)_PROMPT.extract(2,30).lowerCase()

	quit

 
 

vSIG()	quit "60479^60365^Pat Kelly^10010"	// Signature - LTD^TIME^USER^SIZE
