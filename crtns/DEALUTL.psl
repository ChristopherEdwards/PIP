DEALUTL  
	/* DESC: DEAL UTILITIES
	
	---- Revision History ------------------------------------------------
	
	03/21/06 - RussellDS - CR20234
		   Modified BUILDTR section to correct logic on when we return
		   an error or not.
	
	02/17/2005 - KinI - CR 19642
		    Modified BRTEQ and SRTEQ sections to type RECP parameter
		    correctly.
	
	09/10/2005 - KinI - CR16664
		     Converted to PSL.
		     - Removed KEYSIN, LOADDEAL and REPLACE sections as unused/
		       unneeded.
		     - Recoded IFCOND section to correct the logic and make it
		       functional in P04.  
		     - Removed JD from agrument list in BUILDTR section as it 
		       has never been passed here.
		     - Removed revision history prior to 2004.
	-----------------------------------------------------------------------		     
	*/

	quit


public	BUILDTR(RecordDEAL1 deal1,  // Deal Record	
	        Number BRCD,	    // Branch Code
	        String %UID,	    // User Id
	        String KEYS,	    // Keys for any file referenced in DEAL1 record
	        String BUYSELL,	    // A buy ("B") or sell ("S") indicator
	        RecordTTX ttx())    // Transaction object - empty on entry
	
	/*
	 This subroutine builds ttx object by accessing the Deal Accounting 
	 Entry file (DEALENT) and retrieving the information necessary to spawn 
	 transactions.

	 Called from BCHDEALEOD.
	 
	 RETURNS:
		Compound error message
		Upon Success:	 0
		Upon Error:	 -1|Error Text	
	*/
	
	type public Number TRSEQ = 1
	type public Boolean ER
	type public String INDEX, OFFTYPE, RM
	type Number SEQ

	// No Branch Code
	if BRCD.get().isNull() set RM=$$ERROR(-1,$$^MSG(3570)) quit RM
	
	// User not defined
	if %UID.get().isNull() set RM=$$ERROR(-1,$$^MSG(2862)) quit RM
	
	// Invalid deal type
	type ResultSet rs1 = Db.select("DEALTYPE", "DEALENT", "DEALTYPE=:deal1.type")
	if rs1.isEmpty() set RM=$$ERROR(-1,$$^MSG(7576)) quit RM
	
	// KEYSOUT section takes keys to files and pull those out into variables
	// e.g., KEYS="NOINT="_deal1.noint_",CO="_CUVAR.CO_",CRCDB="_deal1.crcdb_",CRCDS="_deal1.crcds
	do KEYSOUT(KEYS)

	set ER=0
	set OFFTYPE=$S(INDEX.exists():INDEX,1:"TRADE")

	type public ResultSet rs=Db.select("SEQ","DEALENT","DEALTYPE=:deal1.type AND BUYSELL=:BUYSELL AND OFFTYPE=:OFFTYPE")

	// Because there are no entries, it doesn't mean it's an error, just that
	// this particular DEALTYPE/OFFTYPE doesn't generate transactions
	while rs.next() do { quit:ER 
		set SEQ=rs.getCol("SEQ")
		
		do TTX(SEQ,BUYSELL,OFFTYPE,KEYS,.ttx(),.deal1)
		}
		
	if ER quit $$ERROR(-1,RM)
	
	quit 0
	

TTX(Number SEQ,		// Deal Sequence Number
    String BUYSELL,	// A buy ("B") or sell ("S") indicator
    String OFFTYPE,	// Offset Type
    String KEYS,	// Keys for any file referenced in deal
    RecordTTX ttx(),	// Transaction Object Array 
    RecordDEAL1 deal1)	// Deal Record
    
	// Build transaction from deal accounting entry table
	type public Boolean ER
	type public String RM
	type public Number TRSEQ
	type Date OFFORIGIN, POSTDATE	
	type String CRCD, ETC, RC, TCMT, TSO, UTLO, x()
	type Number CID, TAMT
	
	type RecordDEALENT dealent=Db.getRecord("DEALENT","DEALTYPE=:deal1.type,BUYSELL=:BUYSELL,OFFTYPE=:OFFTYPE,SEQ=:SEQ",1)

	// dealent.crcd should contain either "CRCDS" or "CRCDB" which is 
	// validated at the data entry
	if dealent.crcd["CRCDS" set CRCD=deal1.crcds
	if dealent.crcd["CRCDB" set CRCD=deal1.crcdb
	
        type RecordCRCD crcd=Db.getRecord("CRCD","CO=:CUVAR.CO,CRCD=:CRCD",1)	
     	
	// Determine if we should process this record
	if '$$IFCOND(dealent.condition,.deal1,.crcd) quit
	
	// Determine where to get the offset event
	type RecordSTBLDEALOFF stbldealoff=Db.getRecord("STBLDEALOFF","OFFTYPE=:dealent.offevent",1)	

	// Invalid Offset event	
	if 'stbldealoff.getMode() do Runtime.setErrMSG("STBLDEALOFF",7578) quit:ER

	// Need to get OFFORIGIN date based on the field saved in stbldealoff.desc:
	// if stbldealoff.desc=[DEAL1]SDT, use deal1.sdt in processing
	if stbldealoff.desc["SDT" set OFFORIGIN=deal1.sdt
	if stbldealoff.desc["TDT" set OFFORIGIN=deal1.tdt
	if stbldealoff.desc["VDT" set OFFORIGIN=deal1.vdt
	
	// Error loading date offset record	
	if OFFORIGIN.get().isNull() do Runtime.setErrMSG("STBLDEALOFF",7571) quit:ER

	set RC=$$GENERAL(dealent.offset,.crcd)	
	if +RC set ER=1,RM=RC.piece("|",2) quit
	
	// If it's a negative number of days, count backwards from the input date	
	if dealent.offset<0 set POSTDATE=$$PRBD^UNBD(OFFORIGIN,dealent.offset)  // Get prior business date
	else  do {
		if OFFTYPE'="VALUE" set POSTDATE=$$NBD^UNBD(OFFORIGIN,dealent.offset,0)
		else  set POSTDATE=$$NBD^UNBD(OFFORIGIN,dealent.offset,0,crcd.calendar)
		}
		
	if POSTDATE.get()>%SystemDate quit

	type RecordCIF cif=Db.getRecord("CIF","ACN=:deal1.acn",1)

	// Invalid CIF ~p1
	if 'cif.getMode() do Runtime.setErrMSG("ACN",7575,deal1.acn) quit:ER

	if cif.rescd=0 set RC=$$CID(dealent.cid,.crcd)      // resident	
	if cif.rescd=1 set RC=$$CID(dealent.cidnres,.crcd)  // non-res
	// If neither condition above is true, set to resident status
	if ((cif.rescd'=0)&(cif.rescd'=1)) set RC=$$CID(dealent.cid,.crcd)

	if +RC set ER=1,RM=RC.piece("|",2) quit
	
	set CID=RC.piece("|",2)
	
	type RecordCUVAR cuvar=Db.getRecord("CUVAR")
	
	if CID="" set CID=cuvar.glts	// G/L Transaction Suspense
		
	type RecordGLAD glad=Db.getRecord("GLAD","ACN=:CID",1)
	
	if (CID=cuvar.glts) ! (glad.getMode()) set RC=$$TRNCODE(dealent.drcr,CID,"G")
	else  set RC=$$TRNCODE(dealent.drcr,CID,dealent.type)

	if +RC set ER=1,RM=RC.piece("|",2) quit
	
	set ETC=RC.piece("|",2)
	
	type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC",1)

	//set TAMT=$$^UNUMSTR(dealent.originamt,KEYS) if ER.get() set RM="-1|"_RM quit
	type Number XAMT = 0
	if dealent.originamt="DEAL1.AMTS" set XAMT=deal1.amts
	if dealent.originamt="DEAL1.AMTB" set XAMT=deal1.amtb
	if dealent.originamt="DEAL1.AMTBASE" set XAMT=deal1.amtbase
	set TAMT=XAMT
	
	set TCMT=RC.piece("|",2)

	set RC=$$GENERAL(dealent.crcd,.crcd)

	if +RC set ER=1,RM=RC.piece("|",2) quit
	set CRCD=RC.piece("|",2)

	type RecordUTBLRADR utblradr=Db.getRecord("UTBLRADR","KEY=:deal1.trader",1)

	set ttx(TRSEQ) = Class.new("RecordTTX")
	
	set ttx(TRSEQ).cid=CID		
	set ttx(TRSEQ).itc=trn.itc		
	set ttx(TRSEQ).etc=ETC		
	set ttx(TRSEQ).tamt=TAMT	
	set ttx(TRSEQ).efd=POSTDATE	// Effective date
	
	if 'UTLO.get() do ^UTLO	
	set ttx(TRSEQ).tlo=UTLO		// Transaction Location

	set TSO=""
	set TSO=$$FIELDIN^UTSO(.TSO,"DEALID",deal1.noint)

	if dealent.crcd["CRCDS" do {
		set x("ZSTAT")=deal1.ds1s
		set x("ZARES")=deal1.ds2s
		}

	if dealent.crcd["CRCDB" do {
		set x("ZSTAT")=deal1.ds1
		set x("ZARES")=deal1.ds2
		}
		
	do IN^UTSO(.x,.TSO) 

	set ttx(TRSEQ).tso=TSO
	set ttx(TRSEQ).tcmt=TCMT	
	set ttx(TRSEQ).cdt=+$H			// Date of transaction
	set ttx(TRSEQ).tim=$H.piece(",",2)	// Time of transaction
	set ttx(TRSEQ).brcd=utblradr.brcd	
	set ttx(TRSEQ).UID=%UserID		
	set ttx(TRSEQ).crcd=CRCD		
	set ttx(TRSEQ).vdt=POSTDATE		// Value Date
	set ttx(TRSEQ).cc=utblradr.tdrctr		

	set TRSEQ=TRSEQ + 1
	
	quit

	
GENERAL(ITEM,			// The item in question	
	RecordCRCD crcd)	// CRCD Record
	
	/* Return either the value of the item passed or the data that item
	   references.
	   RETURNS:
			0|value 	Upon Success
		       -1|message	Upon Error
	*/
	
	// Invalid Data item
	if ITEM.isNull() quit $$ERROR(-1,$$^MSG(1298))

	// They passed in actual text
	if (ITEM'["[")&(ITEM'[".") quit ITEM	

	quit $$LOADFIELD(ITEM,.crcd)


CID(String CID,		// Account Number
    RecordCRCD crcd)	// CRCD Record
    
	/* Looks for an account number based on what's in passed CID
	   CID could be an actual account # or a column where the account
	   number is stored (e.g., DEAL1.NOSTROB or CRCD.SPTSETGL).

	   RETURNS: Compound error message
			Upon Success:	 0|Account number
			Upon Error:	-1|Error Text
	*/
	
	type String RC,RM
	
	set RM=""
	if 'CID.exists() quit -1
	if +CID quit ("0|"_CID)	

	set RC=$$LOADFIELD(CID,.crcd)

	// Error loading account: ~p1
	if +RC set RM=$$^MSG(7570,+$P(RC,"|",2)) quit $$ERROR(-1,RM)

	quit RC
	
	
TRNCODE(String DRCR,	// The debit/credit indicator, could also be a tran code
	Number CID,	// The account number, could be an IBS or GL account
	String TYPE)	// The GL ("G") or IBS ("I")account indicator

	/* Determines ETC to use
	   RETURNS: Compound error message
			Upon Success:	 0|External tran code
			Upon Error:	-1|Error Text
	*/
	
	type public String CRCD, RM
	type String ETC
	
	// Invalid Debit/Credit indicator
	if DRCR.get().isNull() quit $$ERROR(-1,$$^MSG(7577))
	
	// Invalid Account
	if CID.get().isNull() quit $$ERROR(-1,$$^MSG(1259))
	
	// No Type indicator
	if TYPE.get().isNull() quit $$ERROR(-1,$$^MSG(7581))
	
	// Trim all the spaces
	set DRCR=DRCR.trim()
	
	if DRCR="DR" set DRCR=0	
	if DRCR="CR" set DRCR=1	

	//if give us an actual tran code, or a tran code indicator
	
	if DRCR.length()=1 do { quit RM		// Debit/Credit Indicator

		// Invalid Indicator 
		if "01"'[DRCR set RM="-1|$$^MSG(8428)"

		if TYPE="G" set ETC=$S(DRCR=1:"MCR",DRCR=0:"MDR") set RM="0|"_ETC quit
		else  do { quit
	
			type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)

			// Account invalid.  Product type missing
			if acn.type.isNull() set RM="-1|$$^MSG(8429)" quit

			if acn.crcd.isNull() set CRCD=%SystemCurrency

			type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:acn.type",1)
			set ETC=$S(DRCR=0:prodctl.crtrgp,1:prodctl.drtrgp)

			set RM="0|"_ETC quit
			}
		}
		
	// Invalid transaction code ~p1	
	if 'ETC(DRCR).exists() quit "-1|$$^MSG(1498,DRCR)"
	
	quit "0|"_ETC
	

LOADFIELD(String ITEM,		// Data item to load
          RecordCRCD crcd)	// CRCD Record needed in case any CRCD column should be loaded
	
	/* Loads a reference to another item which is stored in another table.
	   Also called from DEALENT screen.
	   
	   ITEM could be something like DEAL1.SDT or [DEAL1]VDT
	   
	   RETURNS:
		Upon Success: 0|Value of item
		Upon Failure: -1|Error text
	*/

	type public String CO, RM
	type Boolean ER
	type String COUNTER, DI, FIELD, FILE, FROM, LIBS, PK, RVAL, TEMPKEY, VAL, WHERE

	// No Data Item passed
	if ITEM.get().isNull() quit $$ERROR(-1,$$^MSG(7580))
	
	// New data item format
	if ITEM["." do {		
		set FILE=ITEM.piece(".",1)
		set FIELD=ITEM.piece(".",2)
		}
	
	// Old data item format
	if ITEM["[" do {
		set FILE=ITEM.piece("]",1) 
		set FILE=FILE.extract(2,13)
		set FIELD=ITEM.piece("]",2)
		set FIELD=FIELD.piece("|",1)
		}
	
	// Unsupported Nomenclature
	if 'FILE.exists() quit $$ERROR(-1,$$^MSG(7583))
	
	set LIBS="SYSDEV"
	
	type RecordDBTBL1 dbtbl1=Db.getRecord("DBTBL1","%LIBS=:LIBS,FID=:FILE",1)	
	// File not found in ~p1
	if 'dbtbl1.getMode() quit $$ERROR(-1,$$^MSG(7574,"SYSDEV"))
	
	// Field ~p1 not found in file ~p2
	if '($$VER^DBSDD(FILE_"."_FIELD)) quit $$ERROR(-1,$$^MSG(7573,FIELD,FILE))
	
	// Go through the file's keys and see if they're all loaded 
	
	// Error in key structure of file
	if dbtbl1.acckeys.isNull() quit $$ERROR(-1,$$^MSG(7569))
	
	set TEMPKEY=""
	set ER=0
	for COUNTER=1:1 do {  quit:(TEMPKEY="")!(ER'=0)
		set TEMPKEY=dbtbl1.acckeys.piece(",",COUNTER)
		if TEMPKEY="" quit
		// check if variable is set for this key
		if '@TEMPKEY.exists() set ER=1
		}
	
	/*
	 For example, if we deal with DEAL1 file, there is NOINT key that is
	 supposed to have a value pulled from KEYS string that done in KEYSOUT 
	 section.
	*/
	// Key ~p1 not defined - cannot load data
	if ER=1 quit $$ERROR(-1,$$^MSG(7579,TEMPKEY))
	
	/* Okay, if we've gotten this far, then all the keys are defined	
	   Now load the data.
	   
	   Assuming that there is single key table referenced in DEALENT column
	   such as DEAL1 (e.g., DEALENT.CID="[DEAL1]NOSTROB"), we will load the 
	   data from that table dynamically. 

	   However, multiple keys table can NOT be referenced when setting the
	   access keys via indirection:	dbtbl1.acckeys_"="_@PK.
	   If for example, PK="CO,CRCD", the error will be generated.
	   
	   Considering that, if CRCD, multiple keys table is used for DEALENT 
	   column setting, this case will be handled separately.
	*/
	
	set DI=FIELD
	set FROM=FILE
	set PK=dbtbl1.acckeys
	
	// Multiple primary keys table
	if (PK.find(",")) , (FROM="CRCD") set WHERE="CO="_"'"_CO_"'"_" AND CRCD="_"'"_crcd.crcd_"'"
		
	// Single primary key table
        else  if PK.find(",")=0 set WHERE=dbtbl1.acckeys_"="_@PK

	// Single key table or CRCD table has to be referenced when setting 
	// DEALENT entries. If neither condition is met, return the error.
	else  set ER=1
	
	#ACCEPT Date=01/09/2006; PGM=KinI
	type ResultSet rs=Db.select(DI,FROM,WHERE)
	if rs.next() set VAL=rs.getRow().toString()

	set RVAL=VAL.piece($C(9),1)	
			
	if ER=1 quit $$ERROR(-1,RM)  do {

		// Error retrieving data item
		if RM.isNull() set RM=$$^MSG(7572) 
		}
		
	set RM="0|"_RVAL
	
	quit RM		
	
	
ERROR(String CODE,	// Error Code
      String MESSAGE)	// Error Message

	// Generates a error string

	type Public String RM
	
	set RM.piece("|",1)=CODE.get()
	set RM.piece("|",2)=MESSAGE.get()
	
	quit RM

	
IFCOND(String STRING,		// The input "if" condition
       RecordDEAL1 deal1,	// Deal record
       RecordCRCD crcd)		// CRCD record
       
	/*  Evaluates a textual if condition, parses out database references, 
	    and returns a true/false value.
	        
	    We should assume that DEALENT.CONDITION query will contain DEAL1 or
	    CRCD file references otherwise it will make the code below unusable
	    (per original design KEYS string composed in BCHDEALEOD contains
	    the keys to these two files only). 

	    Although the documentation on DEALENT.CONDITION can refer to 
	    reference to a DQ query definition, there is no code to actually 
	    allows that now, so it's not considered here.  If we have to, it 
	    would be a matter of loading query into the STRING variable.
	    
	    RETURNS:
			0	Evaluates fals, results in quitting the process
			1	Evaluates true
	*/

	type public Boolean ER
	
	type Boolean return
	type Number N
	type String INPUT(), INSTANT, PSLQRY(), tok
	
	// Strip initial "IF" if there is any
	if STRING.upperCase().beginsWith("IF ") set STRING=STRING.extract(4,STRING.length())
		
	if STRING.isNull() quit 1
	
	if STRING.find("CRCD") do {
		set INPUT("FROM")="CRCD"
		set INPUT("WHERE")=$$WHERE^SQLCONV(STRING,"CRCD")
		set INSTANT="CRCD=crcd"
		}
		
	if STRING.find("DEAL1") do {
		set INPUT("FROM")="DEAL1"
		set INPUT("WHERE")=$$WHERE^SQLCONV(STRING, "DEAL1")
		set INSTANT="DEAL1=deal1"
		}

	do ^UCQRYBLD(.INPUT(),INSTANT,,,.PSLQRY())
	if ER quit 0		
	
	set N=""
	for  set N=PSLQRY(N).order() quit:N.isNull()  do { quit:'return
		
		type String X
		
		set X=PSLQRY(N)
		
		// Tokenize to remove quoted strings
		set X=$$TOKEN^%ZS(X, .tok)
		
		// If STRING contains DEAL1 references, replace all 
		// deal1.colname references with their values
		if STRING.find("DEAL1") for  quit:'X.isLike("%deal1.%")  do {
		
			type Number I
			type String COL, X1, X2
		
			set X1=X.piece("deal1.", 1)
			set X2=X.piece("deal1.", 2, 999)
			for I=1:1:X2.length() quit:X2.extract(I)'?1AN
			if I=X2.length() set COL=X2
			else  set COL=X2.extract(1, I - 1)
			set X2=X2.extract(I, X2.length())
			
			set X=X1_$$DEALCOL(deal1, COL)_X2
		}
		
		// If STRING contains CRCD references, replace all 
		// crcd.colname references with their values
		if STRING.find("CRCD") for  quit:'X.isLike("%crcd.%")  do {
		
			type Number I
			type String COL, X1, X2
		
			set X1=X.piece("crcd.", 1)
			set X2=X.piece("crcd.", 2, 999)
			for I=1:1:X2.length() quit:X2.extract(I)'?1AN
			if I=X2.length() set COL=X2
			else  set COL=X2.extract(1, I - 1)
			set X2=X2.extract(I, X2.length())
			
			set X=X1_$$CRCDCOL(crcd, COL)_X2
		}
		
		set X=$$UNTOK^%ZS(X, tok)
			
		if @X set return = 1
		else  set return = 0
	}
	
	quit return
	
	
DEALCOL(RecordDEAL1 deal1,	// DEAL1 record
        String COLNAME)		// Column name
       
       /* Need to use column indirection to get column value to return
          to be used as replacement for column reference.
       */
       
	type String value
       
	set value = deal1.@COLNAME
       
	if value.isNumber() quit value
	else  quit value.addQuotes()

	quit value	// formal quit


CRCDCOL(RecordCRCD crcd,	// CRCD record
        String COLNAME)		// Column name
        
	/* Need to use column indirection to get column value to return
          to be used as replacement for column reference.
	*/
       
	type String value
       
	set value = crcd.@COLNAME
       
	if value.isNumber() quit value
	else  quit value.addQuotes()        
        
        quit value	// formal quit
        

KEYSOUT(String STRING)	// A string which contains keys
	
	/* This function will take a string which contains keys to files and 
	   pull those out into variables.
	   
	   OUTPUTS:
	   Variables containing the values stored in the keys.
	   
	   set STRING="NOINT="_1_",CO="_"SCA"_",CRCDB="_"USD"_",CRCDS="_"CAD"
	   do KEYSOUT^DEALUTL(STRING)
	   GTM>zwr
		CO="SCA"
		CRCDB="USD"
		CRCDS="CAD"
		NOINT=1	   
	*/
		
	type public String VARIABLE
	type String TEMP, TEMP1, VALUE
	type Number XSEQ
	
	if STRING.get()="" quit
	
	set TEMP=""
	set XSEQ=1

	for  do {  quit:TEMP=""
		set TEMP=STRING.piece(",",XSEQ)
	
		if TEMP="" quit
		
		set VARIABLE=TEMP.piece("=",1)
		set TEMP1=TEMP.piece("=",2)
		set VALUE=TEMP1.piece(",",1)
		set @VARIABLE=VALUE
		set XSEQ=XSEQ+1
		}
	
	quit		
	
	
public	BRTEQ(Number RATE,	// Exchange Rate
              Number RATEBASE,	// Exchange Rate (System Base)
              Boolean RECP)	// Reciprocal Rate Indicator
	
	// Used for DEAL1.BRTEQ, Buy Rate System Equivalent computation

	if 'RECP quit RATEBASE/RATE

	quit RATEBASE*RATE


public	SRTEQ(Number RATE, 	// Exchange Rate
              Number RATEBASE,  // Exchange Rate (System Base)
              Boolean RECP)	// Reciprocal Rate Indicator
      
	// Used for DEAL1.SRTEQ, Sell Rate System Equivalent computation

	if 'RECP quit RATEBASE/RATE

	quit RATEBASE*RATE


public	SWCMP(String M202D,	// Acknowledged Date of SWIFT for MT202
              String M202F,	// Message 202 Flag
              String M210D,	// Achnowledged Date of SWIFT for MT210
              String M210F,	// Message 210 Flag
              String M300D,	// Achnowledged Date of SWIFT for MT300
              String M300F)	// Message 300 Flag

	// Used for DEAL1.SWACK, SWIFT Messages Completed flag computation
	// Check if all messages are successfully transmitted

	type String X	
	
	set X=$$SWACK(M202D,M202F)
	set X=X&($$SWACK(M210D,M210F))
	set X=X&($$SWACK(M300D,M300F))
	
	quit X

	
SWACK(Date dt,		// Achnowledged Date of SWIFT
      String flg)	// SWIFT Message Flag
      
	// Check if message is complete 

	if flg.get()'=1 quit 1
	quit dt.get()	
	
	
 #OPTION ResultClass ON
Public String vSIG()	quit "60346^62197^Dan Russell^17979"	// Signature - LTD^TIME^USER^SIZE
