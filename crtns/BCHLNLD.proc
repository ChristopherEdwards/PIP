BCHLNLD //Batch BCHLNBLDB - Back-office billing driver
 ;;Copyright(c)2007 Sanchez Computer Associates, Inc.  All Rights Reserved - 01/31/2007 12:45 - shetyes
 //
 // ********** This is a DATA-QWIK generated Routine **********
 // Level 33  - BCHLNBLDB Batch Definition
 // ***********************************************************
 //
 //
 type public Number ER
 type public String %FN,RM
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 type Number %BatchExit,%BatchRestart,vBCHSTS
 type String vCONTEXT,vINPUT,vSYSVAR,vRESULT
 set %BatchExit=0,%BatchRestart=0,ER=0,RM=""
 do INIT^BCHUTL(.vSYSVAR)
 set vBCHSTS=$$STATUS^BCHUTL("BCHLNBLDB")
 if vBCHSTS=1 set ER=1,RM=$$^MSG(3410) quit
 if vBCHSTS=2 set ER=1,RM=$$^MSG(3414) quit
 if vBCHSTS=0 set %BatchRestart=1
 do vOPEN(.vINPUT,.%BatchExit) if %BatchExit do EXIT^BCHUTL("BCHLNBLDB") quit
 do JOBMGR^BCHUTL(%FN,"BCHLNBLDB",.vINPUT)
 do ^JOBMGR(.vINPUT)
 do EXIT^BCHUTL("BCHLNBLDB")
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vPROC(CID) //
 type public Number ER
 type public String ET,%EVENT,%FN,%INTRPT(),RM,vCONTEXT
 catch vERROR {
 type public Number ER
 type public String RM
 
 do Runtime.rollback()
 
 do LOG^UTLEXC("BCHLNBLDB","*","",CID.get(), vERROR.thrownAt, vERROR.type)
 
 // DBFILER errors do not log on a call to ZE^UTLERR
 if vERROR.type="%PSL-E-DBFILER" do {
  type String ET = vERROR.type
  do ^UTLERR
 }
 else  do ZE^UTLERR
 
 set ER = 1
 set RM = vERROR.description
 }
 if ('%INTRPT.get().isNull())!(%INTRPT.data() > 1) do INTRPT^BCHUTL(%EVENT.get())
 if %BatchRestart,$$CHKLOG^BCHUTL(%SystemDate,%FN,"BCHLNBLDB",CID.get()) do { quit
 do LOG^BCHUTL(%SystemDate,%FN,"BCHLNBLDB",CID.get(),"Record already processed")
 }
 do Runtime.start("BA")
 set vCONTEXT=""
 set (ET,RM)=""
 set ER=0
 do vEXEC(.vCONTEXT,CID)
 if ER.get() do { quit
 type String et
 set et=$S(ET.get().isNull():RM.get(),1:ET)
 
 do Runtime.rollback()
 do LOG^UTLEXC("BCHLNBLDB","*","",CID.get(),"",et)
 }
 do UPDLOG^BCHUTL(%SystemDate,%FN,"BCHLNBLDB",CID.get(),vCONTEXT)
 do Runtime.commit()
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vEXEC(vCONTEXT,CID) //
	type RecordLN ln=Db.getRecord("LN","CID=:CID")

	do EXEC(.ln,11)

	quit

	
public EXEC(RecordLN ln,
	    Number CTL)
	
	/* 
	  ARGUMENTS:
	     .  ln	Loan Record			/REQ/TYP=RecordLN/REF:RW
	     .  CTL	Control				/NOREQ/TYP=N	
			Position 1 - 0: Do not process transactions
	     			     1: Process transactions locally
	 			 2 - 0: Not called from DAYEND process
	     			     1: Called from DAYEND process
	*/

	type Number AVGBC, BAL, BALCMP, BLDS, BSEQ, CC, DAYS, DPMT, I, INT, IRN
	type Number LCHG, PMT, PPA, RATE, SCHSEQ, SEQ, TBA, UNAPF
	type Date BLDD, BNDT, JD, LCAD, LGD, NJD, SCHND
	type String BLOFF, DIST1FRE, FEE, FRE, GLSC, GRP, ICPF, LCBO, OFST, P
	type String PMTGRC, PTYPE, UAVB, X
	
	type public Boolean ER 

	if ln.stat=4 quit		// Account closed

	do ln.setAuditFlag(1)

	do INITACN(.ln) if ER quit
	
	type RecordLNBIL1 lnbil1
	
	type RecordTTX ttx=Class.new("RecordTTX")

	// Generate bill record
	do { if ER quit
		set lnbil1=Db.getRecord("LNBIL1","CID=:CID,SCHSEQ=:BLDS",1)

		/*
		 Bill has already been generated and we got here as a result 
		 of backdated transaction processing which will fix the bill
		 on its own; no need to regenerate the bill
		*/
		if lnbil1.getMode(),(BLDS'>BSEQ) quit

		// BILL DATE ERROR
		if BLDS'=(BSEQ+1) do Runtime.setErrMSG("LN",3893) quit:ER
		
		// Set MFCOFF() and OFFST() equal to zero to get amt for 
		// each account.
		if MFCOFF(CRCD,TYPE,GLSC,CC).exists() do {
			set MFCOFF(CRCD,TYPE,GLSC,CC,0)=0
			set MFCOFF(CRCD,TYPE,GLSC,CC,1)=0
			}
		
		set FEE=""
		for  set FEE=OFFST(CRCD,FEE).order() quit:FEE=""  do {
			if 'OFFST(CRCD,FEE,GLSC,CC).exists() quit
			set OFFST(CRCD,FEE,GLSC,CC,0)=0
			set OFFST(CRCD,FEE,GLSC,CC,1)=0				
			}
			
		do EXEC^LNBLDE(.ln,.ttx,CID,TJD,1_$E(CTL,2),.lnbil1) if ER quit

		/*
 		Build global with the standard information required for posting
		the offset, track the existence of the global with an array 
		using the significant keys of the global.  After creating the 
		entry, fall into the code which follows to update the global 
		with the amount of the transaction.
		*/

		if MFCOFF(CRCD,TYPE,GLSC,CC).exists() do {

		    set LITERAL="MFCOFF"
		    if 'Db.isDefined("TMPBCHOFF","TJD,""BCHLNBLDB"",%ProcessID,LITERAL,CRCD,TYPE,GLSC,CC") do {
			set X=MFCOFF(CRCD,TYPE,GLSC,CC)
			do BDOFFSET^BCHSOURC("BCHLNBLDB","MFCOFF",CRCD,TYPE,GLSC,CC,X.piece("|",1),X.piece("|",3),X.piece("|",2),X.piece("|",4),X.piece("|",6))
			}

		    set DRAMT=MFCOFF(CRCD,TYPE,GLSC,CC,0).get()
		    set CRAMT=MFCOFF(CRCD,TYPE,GLSC,CC,1).get()
		    if DRAMT do UPOFFSET^BCHSOURC("BCHLNBLDB","MFCOFF",CRCD,TYPE,GLSC,CC,0,DRAMT)
		    if CRAMT do UPOFFSET^BCHSOURC("BCHLNBLDB","MFCOFF",CRCD,TYPE,GLSC,CC,1,CRAMT)
		   }

		set FEE=""
		for  set FEE=OFFST(CRCD,FEE).order() quit:FEE=""  do {
			if 'OFFST(CRCD,FEE,GLSC,CC).exists() quit

			set LITERAL="OFFST"
			if 'Db.isDefined("TMPBCHOFF","TJD,""BCHLNBLDB"",%ProcessID,LITERAL,CRCD,FEE,GLSC,CC") do {	
				set X=OFFST(CRCD,FEE,GLSC,CC)
				do BDOFFSET^BCHSOURC("BCHLNBLDB","OFFST",CRCD,FEE,GLSC,CC,X.piece("|",1),X.piece("|",3),X.piece("|",2),X.piece("|",4),X.piece("|",6))			
				}

			set DRAMT=OFFST(CRCD,FEE,GLSC,CC,0).get()
			set CRAMT=OFFST(CRCD,FEE,GLSC,CC,1).get()
			if DRAMT do UPOFFSET^BCHSOURC("BCHLNBLDB","OFFST",CRCD,FEE,GLSC,CC,0,DRAMT)
			if CRAMT do UPOFFSET^BCHSOURC("BCHLNBLDB","OFFST",CRCD,FEE,GLSC,CC,1,CRAMT)
			}			
	}		

	/*
	Set an entry into the DAYENDLNNOT table to signal the system to produce
	the Rate/Pmt Adjustment Notice or/and Projected Activity Rep.
        Before setting level 3 of the DAYENDLNNOT, verify if there were 
	scheduled interest rate change dates since the last scheduled payment 
	change date. If yes - set all rate changes into the DAYENDLNNOT1 table.
	*/

	type Boolean FL
	type Date JD, ICHND
	
	set FL=0		// "rate change within pmt change period" flag
	set PCM=ln.pcm
	set INTFRE=ln.intfre
	set ICHND=ln.ichnd
	set JD=ICHND

	if (PRPMT'=PMT),(PCM=5)!(PCM="5N"),(INTFRE'=""),(BLDT'="") do {
		for  set ICHLD=$$NJD^UFRE(JD,INTFRE,,1) quit:ER  set JD=ICHLD quit:ICHLD'>BLDT  do {
			if ICHLD>BNDT quit
			set FL=1
			if PCBD(CID,"ICHND",ICHLD,CID).exists() do {
				set NRATE=PCBD(CID,"ICHND",ICHLD,CID).get().piece("|",3)						
				set PRATE=PCBD(CID,"ICHND",ICHLD,CID).get().piece("|",6)
				}
			else  do {
				set DATA=Db.getOneRow("NRATE,IRN","LNVRCHG","ICHLD,CID")	
				set NRATE=+DATA.piece($C(9),1)
				set PRATE=+DATA.piece($C(9),2)
				}

			if ('NRATE),('PRATE) quit
			
			type RecordDAYENDLNNOT1 lnnot1=Db.getRecord("DAYENDLNNOT1","DT=:TJD,CID=:CID,ID=3,ICDT=:ICHLD",1)

			set lnnot1.oldrate=PRATE.get()
			set lnnot1.newrate=NRATE.get()
			
			do lnnot1.bypassSave()
			}	

		if FL=1 do {			
			type RecordDAYENDLNNOT lnnot3=Db.getRecord("DAYENDLNNOT","DT=:TJD,CID=:CID,ID=3",1)
	
			set lnnot3.oldpmt=PRPMT.get()
			set lnnot3.newpmt=PMT.get()
			
			do lnnot3.bypassSave()
			}
		else  do {
			type RecordDAYENDLNNOT lnnot2=Db.getRecord("DAYENDLNNOT","DT=:TJD,CID=:CID,ID=2",1)

			set lnnot2.oldpmt=PRPMT.get()
			set lnnot2.newpmt=PMT.get()
			
			do lnnot2.bypassSave()
			}
			
		if ln.genprjrep=1 do {			
			type RecordDAYENDLNNOT lnnot4=Db.getRecord("DAYENDLNNOT","DT=:TJD,CID=:CID,ID=4",1)

			do lnnot4.bypassSave()
			}
		}
		
	do BLP(.ln,.lnbil1,.ttx)  // Create bill print file entry

	set ln.pmt=lnbil1.ctab
	
	do ln.bypassSave() 

	quit


BLP(RecordLN ln,
    RecordLNBIL1 lnbil1,
    RecordTTX ttx)	
	
	do ln.setAuditFlag(1)

	do INITDI(.ln)
	
	type Number IDF
	
	do AVB(.ln,.lnbil1,.ttx)

	do AVLBAL^LNCO(.ln,CID) // define AVLBAL

	do LC(.ln)
	
	set IDF=$$^SCARND(IRN/$$DY^UIC(ln.iacm,%TD),0,"","",8)
	
	do TTBP(.ln)
	
	type Number BLPUNPR, BLPUNIN, BLPAMT
	
	type RecordLNBLP lblp = Db.getRecord("LNBLP","BILDT=:BNDT,TYPE=:TYPE,CID=:CID",1)
	
	set BLPUNPR=UNPR+CUPR S:BLPUNPR<0 BLPUNPR=""
	set BLPUNIN=UNIN+CUIN S:BLPUNIN<0 BLPUNIN=""
	set BLPAMT=ln.tba-lnbil1.casd I BLPAMT<0 set BLPAMT=""
	set ICPF=ln.icpf
	set lblp.tseq=Db.currVal("HIST","CID")  //Last History Sequence on Bill
	set lblp.avgbc=UAVB(1).get().piece("|",1)  //Average Bal.
	set lblp.fdacp=UAVB(2).get().piece("|",15)-UAVB(2).get().piece("|",10)	//Finance Charges Accrued During Period
	set lblp.lblb=BALCMP			//Account Bal. on Billing Date
	set lblp.unpr=BLPUNPR			//Principal Bal. Before Billing
	set lblp.unin=BLPUNIN			//Interest Due Before Billing
	set lblp.dseq=ICPF			//Next Payment Sequence #
	set lblp.ppa=PPA			//Partial Payment Balance
	set lblp.apd=BLPAMT			//Amount Past Due
	set lblp.irn=IRN			//Interest Rate
	set lblp.schseq=BLDS			//Schedule Payment Due Seqence #
	set lblp.teb=TTB			//Escrow Balance Data
	set lblp.tep=TTP			//Escrow Payment Data
	set lblp.apr=RATE			//Annual Percentage Rate
	set lblp.ptd=DIST1LD			//Payment Paid Through Date
	set lblp.yob=$$DAT^%ZM(BNDT,"YEAR")	//Bill Date - Calendar Year
	set lblp.iytd=IYTD			//Interest Year-to-date
	set lblp.ipy=IPY			//Interest Year-to-date - Prior
	set lblp.pytd=PYTD			//Principal Year-to-date
	set lblp.ppy=PPY                        //Principal Year-to-date - Prior
	set lblp.dif=IDF			//Daily Interest Factor
 	set lblp.mfc=MFCB			//Minimum Finanace Charge
	set lblp.crlmt=CRLMT			//Credit Limit
	set lblp.avlbal=AVLBAL			//Available Balance
	set lblp.schdue=BLDD			//Payment Due Date Billed
	set lblp.lcdd=LGD			//Date Late Charge may be Ass.
	set lblp.dic=DAYS			//Days in Cycle
	set lblp.lchg=LCHG			//Total Late Charge Due
	set lblp.mchg=$$MCND^LNCO3(CTL,.ln,CID)	//Total Miscellaneous Charges Due
	set lblp.tpy=TPY			//Escrow Payment - Prior Year
	set lblp.unapf=UNAPF			//Unapplied Funds
	set lblp.udbal=UDBAL			//Undisbursed Balance

	do lblp.bypassSave()

	// Are there are enough unapplied funds for a full payment?
	if UNAPF,DPMT,UNAPF'<(DPMT-PPA) do {
		type RecordDAYENDUF dayenduf=Db.getRecord("DAYENDUF","BNDT=:TJD,CID=:CID",1)
		do dayenduf.bypassSave()
		}

	// Bump billing dates
	set ln.bldt=ln.bndt
	set ln.bndt=$$BNDT(ln.bndt,.ln)

	quit
	

BNDT(Date EFD,
     RecordLN ln)	
     
	// Find next bill date

	if ln.bloff="1P" set JD=EFD set NJD=$$NJD^UFRE(JD,FRE) quit NJD

	set JD=EFD+ln.bloff
	set NJD=$$NJD^UFRE(JD,FRE) 

	quit NJD-ln.bloff
		

AVB(RecordLN ln,
    RecordLNBIL1 lnbil1,
    RecordTTX ttx)	

	// Call UAVB to capture average and/or weighted interest rate
	
	type Number CTL, LBLPSEQ
	type String FRE
	type Date NJD, BILDT

	set %FD=ln.bldt+1
	set %TD=ln.bndt
	set PTYPE=PTYPE(GRP,TYPE) if '$TR(PTYPE,"|","") quit
	set CTL=""
	
	set BILDT=ln.bldt
	type RecordLNBLP lblp=Db.getRecord("LNBLP","BILDT=:BILDT,TYPE=:TYPE,CID=:CID",1)
	if lblp.getMode() = 1 do {
		set %BAL=lblp.lblb
		set LBLPSEQ=lblp.tseq
		}
	else  set %BAL="",LBLPSEQ=""

	if PTYPE.piece("|",2) set CTL=1 do AVB1(.ln,.ttx) set RATE=$$^SCARND(%WIRN,0,"","",5) quit
	if PTYPE.piece("|",3) set CTL=IDP_1 do AVB1(.ln) do:'NOAPR.get() APR(.ln,.lnbil1)  quit

	do AVB1(.ln,.ttx)

	quit

	
AVB1(RecordLN ln,
     RecordTTX ttx)

	set (ER,%AVB,%WIRN,%APRC,AVGBC)=""
	
	type RecordLN ln2
	set ln2=ln.copy()
	
	do INIT^UAVB(.ln2,CID,%FD,%TD,CTL,+LBLPSEQ,%BAL) if ER quit

	set %AVB=+UAVB(1)
	set %WIRN=+UAVB(2)
	set %APRC=UAVB(2).piece("|",2)
	if PTYPE.piece("|",1) set AVGBC=%AVB
	
	quit
	
	
APR(RecordLN ln,
    RecordLNBIL1 lnbil1)	

	// Calculate a periodic Reg Z APR for statement production

	type String CF()
	type Boolean PIACM
	
	set SCHLD=ln.schld
	
	// Determine the interest charged (%INT).
	if 'IDP do {
		type String PC
		set %INT=""
		set PC=$$SUB^BILFUNCS("I",.lnbil1)
		set %INT=PC.piece("#",3)
		}	

	if IDP do {
		set %LD=ln.bldt+1,%ND=ln.bndt
		set %BAL=%AVB,IRN=+UAVB(2).get()
		set %INT=$$^UIC(%BAL,%LD,%ND,ln.iacm,IRN,0,DIST1AF,DIST1FRE,ICPF,SCHND,SCHLD)
		set %INT=$$^SCARND(%INT+.005,0,CID.get())
		}
	
	set %APRC=%APRC.get()
	set %AVB=%AVB.get()
	set MFCB=ln.mfcb
	
	set RATE=$S(UAVB(2).get():+UAVB(2),1:ln.irn)
	
	/* 
	
	There must be a value for %AVB to call into $$UIRR.
	
	If there is a value for %APRC, then Minimum Finance Charge data
	does not matter, and $$^UIRR must be called.  If there is no value
	for %APRC, then Minimum Finance Charge data must be evaluated.
	
	If MFCB on the loan does not have a value, then %INT value on the
	bill could not have changed, so no call to $$^UIRR is necessary.
	If MFCB on the loan does have a value, then %INT value on the bill
	would have changed to the loan's MFCB value, if the original %INT
	value on the bill was less than the loan's MFCB value.
	
	If MFCB on the loan does have a value and %INT value on the bill is
	greater than the loan's MFCB value, then a Minimum Finance Charge was
	not assessed on this bill, so no call to $$^UIRR is necessary.
	If MFCB on the loan does have a value and %INT value on the bill is
	equal to the loan's MFCB value, then $$^UIRR must be called.
	
	
	RATE = Weighted Interest Rate (if calculated by INIT^UAVB)
	       Otherwise it will be Loan Nominal Interest Rate
		*** Refer to previous line of code:
		set RATE=$S($G(UAVB(2)):+UAVB(2),1:ln.irn) ***
	IRR = Internal Rate of Return
	
	Determine if call into $^UIRR to calculate IRR is necessary.
	If not calling $UIRR, then use RATE from previous line.
	
	   %AVB  = Average Balance from INIT^UAVB call
	   %APRC = Sum of Reg Z loan tran charges from INIT^UAVB call
	   %INT  = Amount of interest charged on bill
	   MFCB  = On loan, value of Minimum Finance Charge per bill
	
	   If no %AVB, then stop and use RATE from above.
	   If no %APRC AND no MFCB, then stop and use RATE from above.
	   If no %APRC AND there is MFCB, then do comparison between
	      %INT and MFCB.  %INT will either be greater than MFCB,
	      or %INT will be equal to MFCB.  If %INT was less than
	      MFCB, then %INT would have been reset equal to MFCB.
	      If %INT is greater than MFCB, then stop and use RATE
	      from above.
	
	*/
	
	if '%AVB quit
	if '%APRC,'MFCB quit
	if '%APRC,MFCB,%INT>MFCB quit
	
	set CF(0)=-%AVB
	set CF(1)=(%AVB+%APRC+%INT)_"|1"
	set PIACM=ln.piacm
	set RATE=$$^UIRR(.CF,DIST1FRE,PIACM,ln.iacm,SCHLD)

	quit

	
TTBP(RecordLN ln)

	type RecordLNBIL0 lnbil0=Db.getRecord("LNBIL0","CID")

	set (TTB,TTP,TPY)=""
	if lnbil0.pe01da>0 S A=lnbil0.pe01da do TRTYP(A,.ln)
	if lnbil0.pe02da>0 S A=lnbil0.pe02da do TRTYP(A,.ln)
	if lnbil0.pe03da>0 S A=lnbil0.pe03da do TRTYP(A,.ln)
	if lnbil0.pe04da>0 S A=lnbil0.pe04da do TRTYP(A,.ln)
	if lnbil0.pe05da>0 S A=lnbil0.pe05da do TRTYP(A,.ln)
	if lnbil0.pe06da>0 S A=lnbil0.pe06da do TRTYP(A,.ln)
	if lnbil0.pe07da>0 S A=lnbil0.pe07da do TRTYP(A,.ln)
	if lnbil0.pe08da>0 S A=lnbil0.pe08da do TRTYP(A,.ln)
	if lnbil0.pe09da>0 S A=lnbil0.pe09da do TRTYP(A,.ln)
	if lnbil0.pe10da>0 S A=lnbil0.pe10da do TRTYP(A,.ln)
	if lnbil0.pe11da>0 S A=lnbil0.pe11da do TRTYP(A,.ln)
	if lnbil0.pe12da>0 S A=lnbil0.pe12da do TRTYP(A,.ln)
	if lnbil0.pe13da>0 S A=lnbil0.pe13da do TRTYP(A,.ln)
	if lnbil0.pe14da>0 S A=lnbil0.pe14da do TRTYP(A,.ln)
	if lnbil0.pe15da>0 S A=lnbil0.pe15da do TRTYP(A,.ln)
	if lnbil0.pe16da>0 S A=lnbil0.pe16da do TRTYP(A,.ln)
	if lnbil0.pe17da>0 S A=lnbil0.pe17da do TRTYP(A,.ln)
	if lnbil0.pe18da>0 S A=lnbil0.pe18da do TRTYP(A,.ln)
	if lnbil0.pe19da>0 S A=lnbil0.pe19da do TRTYP(A,.ln)
	if lnbil0.pe20da>0 S A=lnbil0.pe20da do TRTYP(A,.ln)

	quit


TRTYP(ESCCID,RecordLN ln)
	
	set TYP=""
	for  set TYP=Db.nextKey("TRTYPE","ESCCID,TYP") quit:TYP=""  do {

		type RecordTRTYPE trtyp=Db.getRecord("TRTYPE","ESCCID,TYP")

		set x=trtyp.trtype
		set TRTYPE=trtyp.trtype
		set x=$TR(x,"0123456789","")

		type RecordLNTRS y
		if 'LNTRS(x).data() do {
			set y=Db.getRecord("LNTRS","TRTYPE")
			set p=y.etyp
			set LNTRS(x)=p
			}
		set p=LNTRS(x)
		
		type RecordDEP dep=Db.getRecord("DEP","ESCCID")

		set TTB.piece(",",p)=TTB.piece(",",p)+dep.bal
		set TTP.piece(",",p)=TTP.piece(",",p)+trtyp.remytd

		if TJD-1-DAYS<BTY
		set TPY.piece(",",p)=TPY.piece(",",p)+trtyp.rempy
		}
	quit	 


LC(RecordLN ln)	// Calculate Late Charge Grace Date and Late Charge Action Date


	do ln.setAuditFlag(1)
	if PMTGRC="" set (LGD,LCAD)=""
	
	// Save current LCAD if in future

	if ln.lcad > (TJD-1) do {
		type RecordDAYENDLCHG lchg=Db.getRecord("DAYENDLCHG","TJD=:ln.lcad,CID=:CID",1)
		
		set lchg.lcefd=ln.lcefd
		do lchg.bypassSave()
		}
	
	// Taken care of in Notice Processing		
	if ln.lchgnoto=1 set (LCAD,LGD)=ln.lcad quit
		
	do LCAD(BLDD,LCBO,PMTGRC,DIST1FRE,0)

	set ln.lcad=LCAD
	set ln.lcefd=BLDD

	quit

	
LCAD(Date LCEFD,	// Late charge effective date
     String LCBO,	// Business day option
     String PMTGRC,	// Grace period
     String D1FRE,	// Payment frequency
     Boolean FLG)	// Reset flag	

	// Utility returns LCAD, LGD and LC array

	if PMTGRC.get()="" set PMTGRC="0D"
	if LCBO.get()="" set LCBO="A"

	set FLG=FLG.get()
	set CTL=CTL.get()
	set LCAD=LCAD.get()
	
	if LC(LCEFD,LCBO,PMTGRC).exists() set LCAD=+LC(LCEFD,LCBO,PMTGRC),LGD=LC(LCEFD,LCBO,PMTGRC).piece("|",2)	
	else  do {
		if PMTGRC["D" set LCAD=LCEFD+PMTGRC
		else  do {
			set NJD=LCEFD,FRE=D1FRE
			for I=1:1:+PMTGRC set JD=NJD,NJD=$$NJD^UFRE(JD,FRE) I ER Q
			set LCAD=NJD-PMTGRC.piece("-",2)
			}
		// Bump LGD so that it falls on a business day 
		set LGD=LCAD
		set OFST=$S(LCBO="A":-1,1:1)
		for I=1:1 set:'BUS(LGD).data() BUS(LGD)='$$BD^UNBD(LGD,CUVAR.LCNBDC) quit:'BUS(LGD)  set LGD=LGD+OFST
		if LGD>LCAD set LCAD=LGD
		}

	if CTL,'FLG,TJD+1>LCAD set LCAD=TJD do {
			set LCAD=TJD   
			
			type RecordDAYENDLCHG lchg=Db.getRecord("DAYENDLCHG","TJD=:TJD,CID=:CID",1)
			
			set lchg.lcefd=LCEFD
			do lchg.bypassSave()
			}

	if 'LC(LCEFD,LCBO,PMTGRC).exists() set LC(LCEFD,LCBO,PMTGRC)=LCAD_"|"_LGD

	quit
	

EXIT

	type public Boolean ER

	set ER=0  // return to queueing system
	quit
	

LOGERR

	type public Boolean ER
	
	set ER=1
	// Loan Account Billing
	do LOG^UTLEXC($T(+0),"*",$$^MSG(3894),CID.get(),%ZTSEQ.get(),RM.get())
	kill RM,%ZTSEQ

	quit

	
INITACN(RecordLN ln)
	
	type public Boolean ER
	
	do INITDI(.ln)
	
	set DAYS=BNDT-BLDT
	// Find due date (BLDD) and due sequence (BLDS) for this bill record
	set FRE=DIST1FRE
	set BLDD=BNDT+BLOFF
	if BLOFF="1P" set JD=BNDT,NJD=$$NJD^UFRE(JD,FRE) set BLDD=NJD

	// Billing due date of ~p1 precedes scheduled due date of ~p2
	if BLDD<SCHND set ER=1,RM=$$^MSG(353,$$DAT^%ZM(BLDD,%MSKD.get()),$$DAT^%ZM(SCHND,%MSKD.get())) Q

	set BLDS=SCHSEQ+1
	if BLDD>SCHND set JD=SCHND for BLDS=BLDS+1:1 set NJD=$$NJD^UFRE(JD,FRE) quit:ER  quit:NJD'<BLDD  set JD=NJD
	
	if 'PTYPE(GRP,TYPE).exists() do PTYPE
	
	// Beginning of the Tax year
	set BTY=$$BOTY^SCADAT(TJD,1)

	quit
	
INITDI(RecordLN ln)	// Init data items
	
	set LCEFD=ln.lcefd	
	set PMTGRC=ln.pmtgrc
	set IDP=ln.idp
	set GRP=ln.grp
	set TYPE=ln.type
	set CRCD=ln.crcd
	set (BAL,BALCMP)=ln.bal
	set UDBAL=ln.udbal
	if ln.aruf set BALCMP=BALCMP-ln.udbal
	set CRLMT=ln.crlmt
	set IYTD=ln.iytd
	set ITYTD=ln.itytd
	set IPY=ln.ipy
	set IPTY=ln.ipty
	set PYTD=ln.pytd
	set PENTYTD=ln.pentytd
	set PPY=ln.ppy
	set PENPTY=ln.penpty
	set LCHG=ln.lchg
	set UNAPF=ln.unapf
	set (IRN,RATE)=ln.irn
	set ICPF=ln.icpf
	set PMT=ln.pmt
	set PRPMT=ln.pmt	// Save for the DAYENDLNNOT table
	set PPA=ln.ppa
	set SCHND=ln.schnd
	set CUIN=ln.cuin
	set UNIN=ln.unin
	set CUPR=ln.cupr
	set UNPR=ln.unpr
	set SCHSEQ=ln.schseq
	set DIST1FRE=ln.dist1fre
	set DIST1LD=ln.dist1ld
	set DIST1AF=ln.dist1af
	set DPMT=ln.dpmt
	set TBA=ln.tba
	set LCBO=ln.lcbo
	set BNDT=ln.bndt
	set BLDT=ln.bldt			
	set BSEQ=ln.bseq
	set BLOFF=ln.bloff
	set MFCB=ln.mfcb
	set CC=ln.cc
	set GLSC=ln.glsc
	set (IRN,RATE)=$$TEASRT^LNBLDE(.ln,BLDT+BLOFF)
	set REPF=ln.genprjrep
        set MCP=ln.pcm	

	quit						
	
	
PTYPE	// Create PTYPE array

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE")
	
	set KEY=prodctl.bfp
	if KEY="" set KEY=1
	
	type RecordUTBLPTYPE ptype=Db.getRecord("UTBLPTYPE","GRP,KEY")

	set PTYPE(GRP,TYPE)=ptype.abpf_"|"_ptype.aypf_"|"_ptype.apr

	if $TR(PTYPE(GRP,TYPE),"|","")="" set PTYPE(GRP,TYPE)=$S(GRP="RC":"^LNB2",1:"^LNB1")

	quit

	
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXEC(vINPUT,vRETURN) //
 type String vRECORD,CID
 for  set vRECORD=vINPUT.piece("|",1),vINPUT=vINPUT.extract(vRECORD.length()+2,99999) quit:vRECORD.isNull()  do {
 set CID=vRECORD.piece($C(9),1)
 do vPROC(CID)
 }
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXEC(vINPUT,vRETURN) //
 type public String vBUFOVFL
 type String vRECORD,vrow,CID
 type Number vcur,vlen
 set vINPUT=vBUFOVFL.get()
 set vBUFOVFL="",vlen=0
 type public ResultSet vRESULT
 for  do { quit:'vcur
 set vcur=vRESULT.next() if 'vcur quit
 set vrow=vRESULT.getRow()_"|",vlen=vlen+vrow.length()
 if vlen>32767 set vBUFOVFL=vrow,vcur=0 quit
 set vINPUT=vINPUT_vrow if vlen+13>32767 set vcur=0 quit
 }
 set vINPUT=vINPUT.extract(1,vINPUT.length()-1)
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHPOST(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vOPEN(String vINPUT, Boolean %BatchExit) //
	do SOURCE^BCHSOURC("MFC","ALL",.%UserID,.BRCD,.%UserClass) 
	if ER set %BatchExit=1 quit

 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 type public ResultSet vRESULT=Db.select("CID","LN","BNDT=(:TJD-1)")
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 if vRESULT.isEmpty() set %BatchExit=1 quit
 #ACCEPT Date=08/01/03;PGM=Allan Mattson;CR=20967
 set %BatchExit=0
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHRINIT(vINPUT,vRETURN) //
	set TPD=%SystemDate
	do SOURCE^BCHSOURC("MFC","ALL",.%UserID,.BRCD,.%UserClass)
	set JOB=%ProcessID
  
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vTHREXIT(vINPUT,vRETURN) //
 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHINIT(vINPUT,vRETURN) //
 	set TPD=%SystemDate
	
	quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
private vSCHEXIT(vINPUT,vRETURN) //
	// File accumulated loan fee offsets and min finance chg offsets
	do OFFSET^TTXBLD(TPD,BRCD,%UserID,"BCHLNBLDB")

	quit

 #ACCEPT Date=07/15/03;PGM=Allan Mattson;CR=20967
 quit
vVERSION() // Compiler Version ID
 quit "V7-0.02"
