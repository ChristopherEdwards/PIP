MRPC003(return,versn,ETC,CID,%EffectiveDate,SELECT,QUAL,MSCINP)	//Public;Transaction Qualifiers and SQL
	/*
	   ORIG: MATTSON - 09/17/93

	   This extrinsic function returns a list of transaction qualifiers
	   (service class TSSP) and the SQL select columns for a specified
	   account based upon the transaction code.

	   [SCATBL5]RPCID=3

	   KEYWORDS: Client/Server, Transaction Processing

	   ARGUMENTS:
	   	. return 	Data (see below)  		/TYP=T/REQ
	         						/MECH=REFNAM:W

	   	. versn  	^MRPC003 version number 	/TYP=N/REQ
	     			Current version = 2  		/MECH=VAL

	   	. ETC  		PROFILE transaction code 	/TYP=T/REQ
	         						/MECH=VAL

	   	. CID  		Account number   		/TYP=N/REQ
	         						/MECH=VAL

	   	. EFD  		Effective date   		/TYP=D/NOREQ
	         						/MECH=VAL

	   	. SELECT 	Select statement  		/TYP=T/NOREQ
		  		Returns columns used to
 	     			populate datawindow
	     			in teller screen

	   	. QUAL  	SQL qualifiers   		/TYP=T/NOREQ
	     			Generally /USING for
	     			host variables in SELECT

	   	. MSCINP 	Miscellaneous input  		/TYP=T/NOREQ
	     			Used for misc transactions
	     			that require input, e.g.,
	     			fees that need source account
	     			and count.  Values depend
	     			on transaction

	   RETURNS:
	   	. $$ Error message   				/TYP=T
	    		Null = No error

	   RELATED:
	   	. $$^PBSMRPC - MRPC Service Class Driver

	   Data is returned as up to six LV records, with each record other
	   than the SQL return having a similar format.  The first comma
	   separated field indicates the record type; subsequent comma
	   separated fields are mnemonic=value.  For the SQL return, the first
	   character is an "S" followed by a comma, with the remainder of the
	   record being tab separated values.

	   	. D = defaults
	       		fields are mnemonic=value[,...]
	   	. E = ETC tran code
	       		default tran code from the product if ETC is *CR or *DR
	   	. M = miscellaneous
	     	  P = payment system info
	     	  Q = qualifiers
	       		fields are mnemonic=required[,...]
	   	. S = select
	        	fields are value<tab>value[...]

	  ---- Revision History ------------------------------------------------
	01/23/07 - MBUIM - CR 25008
		   Retrofited the CR below
	  
		   01/22/07 - MbuiM - CR 24961
		   Modified START section to add a + infront of variable REQD.  
		   The response value for whether the TCMT and/or support 
		   qualifier is required or not is sometimes returned as null,
		   instead of a 0 or 1. When using Profile-Direct Teller errors
		   were occurring when calling MRPC003 to retrieve default 
		   amounts and/or transaction support qualifiers.
		   Also modified variable req as it would be possible for the
		   required field (variable req) not to be 0 or 1.
		   
	10/10/06 - ChhabriS - 23553
		   Retrofited the below mentioned CR from ICGWeb01_Dev_Profile
		   view.

		04/14/06 - Ed Sigda - 20290
	            o Modified code to support version 4.  This version will
	              be similar to version 3 with the exception that all 
	              entries in TRNSD will be return.  Version 3 only returns 
	              entries if the STBLTSD (UTBLZTSD) entry has a pre-processor.
	            o Modified code in version 3&4 section to defined variable
	              FLD based on the correct type of qualifier, otherwise, 
	              entries in the MFREQ loop section would duplicate using 
	              an "M" qualifier type.
	            o Modified code in version 3&4 section to execute the 
	              STBLTSD Function Query to determine whether the field
	              should be displayed.
  
	04/24/06 - TITOVE - CR 20881
		   Modified START section, added setting of CRT flag to ensure
		   we do not check for function restrictions while executing
		   PROT^UACN call initiated by Teller processing.

	03/22/06 - RussellDS - CR20142
		   Modified SRVFEE section to avoid PSL optimization problem with
		   acn due to use of indirection on call to service fee program.
		   
		   Cleaned up PSL warnings.
	  
	09/21/05 - RussellDS - CR16911
		   Correct call to fee program in SRVFEE section - was not passing
		   parameters to match new call signature.
		   
		   Removed old revision history.

        07/27/05 - SkariahV- CR16679
	           Removed #WARN and #OPTIMIZE directives.
	
	07/07/04 - Erik Scheetz - 10782
		Removed type-casting from START section and replaced with
		extrinsic functions.  Added RPASEQ, IRCBLN and IRCBDEP sections
		until compiler type-casting is complete.

		Remove the second loading of the trn object in the START 
		section.  The compiler was not building the vobj array 
		for trn, causing many problems when trn is passed to 
		another tag. (SCHWARTZC)
		
		Added #warn, #optimized and cleaned up compiler warnings
		(SCHWARTZC)

	*/
	
	
	type String RETURN
	
	set versn=versn.get()
	
	// Version number of client message is not compatible with server
	if versn=1 quit $$V1(.return,versn,ETC,CID,%EffectiveDate,%ProcessMode.get())

	/* Version 4 is ok
	Version number of client message is not compatible with server */
	if versn>4 quit $$ERRMSG^PBSUTL($$^MSG(2951))

	do Runtime.start("BA","","STACK")
	set RETURN=$$START(%ProcessMode.get())
	do Runtime.rollback("STACK")
	quit RETURN

START(%ProcessMode)	//

	type Public String %TOKEN,ER,ET,ETC,MSCINP,QUAL,return,RM,SELECT
	type Public Number CID,versn

	type String CRCD,DATA,DFT(),fld
	type Number i,IRCB,MFT(),MFREQ,pobs(),PP(),qlf
	type Number req,RETURN,retval,sort(),x

	if '%ProcessMode.exists() set %ProcessMode=0
	if '%EffectiveDate set %EffectiveDate=%SystemDate
	set ER=0

	type RecordACN acn=Db.getRecord("ACN","CID=:CID",1)

	// Set ETC value if user requests it by entering *CR or *DR.
	if $E(ETC)="*" set ETC=$$GETETC(ETC,acn.type)

	type Public Cache %CACHE()
	type RecordTRN trn
	
	do {
		catch error	{
			set ETC=""
			}

		set trn=%CACHE("TRN").getRecord("TRN","ETC=:ETC")
		}
	// Invalid transaction code ~p1
	if ETC="" do Runtime.setErrMSG("TRN",1498) quit $$ERRMSG^PBSUTL(RM)

	// Check for record level protection on the account.
	if (trn.cls '= "M") do { if ER quit $$ERRMSG^PBSUTL(RM)
	
		// Protect %ProcessMode value, but it has to be 1 for UACN call
		type Number %ProcessMode, CRT
		
		set %ProcessMode = 1
		
		// Teller processing call flag
		set CRT = 1
		
		do PROT^UACN
		}

	set PP(ETC)=trn.pop

	if "DL"[trn.cls  do { if ER quit $$ERRMSG^PBSUTL(RM.get(),ET.get())

		do ETCCID^TTXEXT(.trn,CID) quit:ER
	
		// Record not found
		if 'acn.getMode() do Runtime.setErrMSG("ACN",2335) quit

		set CRCD=acn.crcd
		
		if acn.cls="L" set IRCB=$$IRCBLN(.acn)

		else   set IRCB=$$IRCBDEP(.acn)
		}

	// Load STBLTSD and UTBLZTSD data into MFT array
	do MFT^CRTMF

	// Process MFT array to determine which qualifiers are valid to prompt
	set MFREQ=$$PROC(trn.cls,.MFT)

	// Load valid TSSP qualifiers into pobs array
	// e.g. pobs("TSSP","MSC","CK")="Check Number"
	do POBS^TTXRPC(.pobs)

	set (fld,qlf,return)=""

	// For misc transactions, only handle service fee default amount
	if trn.cls="M" do { if ER quit $$ERRMSG^PBSUTL($G(RM),$G(ET))

		if trn.grp'="FEE" quit
		if $G(MSCINP)="" quit
		set DFT("AMT")=$$SRVFEE(.trn,MSCINP)
		if DFT("AMT") set sort("D","AMT")=DFT("AMT")
		}

	else  if $G(PP(ETC))'="" do { if ER quit $$ERRMSG^PBSUTL($G(RM))
		#ACCEPT DATE=08/26/02;PGM=Teliv
		xecute PP(ETC)
		if 'DFT("AMT").exists() quit
		set sort("D","AMT")=DFT("AMT")
		}

	// Implement Variable Amount field
	type String VARTAMT

	set VARTAMT=trn.vartamt

	if $G(VARTAMT)'="" do {
		// Bypass code review error of hardcoded languange phrase
		// I18N=OFF
		type String SQLCMD,VARFID,VARDI

		set VARFID=$P(VARTAMT,".",1) 
		set VARDI=$P(VARTAMT,".",2)
		set SQLCMD="D SELECT^SQL("_$C(34)
		set SQLCMD=SQLCMD_VARDI_" FROM "_VARFID_" WHERE CID=:CID"
		set SQLCMD=SQLCMD_$C(34)_",,,.VARTAMT"_")"
	
		// I18N=ON
		#ACCEPT DATE=08/26/02;PGM=Teliv
		xecute SQLCMD
		set sort("D","AMT")=VARTAMT
		}

	type Date VDT
	type Boolean PCFD21

	// Value Date to Next Accrual Calc Date
	set PCFD21=trn.pcfd21

	// Value Date to next Accrual Calc Period
	// if Interest rate Calc Base is 6
	if PCFD21,IRCB=6 set VDT=$$VALNACP^DEPLBB(.acn,%EffectiveDate) quit:ER
	else  set VDT=""

	if VDT do {
		set VDT=$$DAT^%ZM(VDT)
		set sort("V","VDT")=VDT
		}

	// Check to see if IRA and withholding required
	if trn.cls="D",'$E(trn.itc) do { if ER quit $$ERRMSG^PBSUTL(RM.get(),ET.get())

		type Number RPASEQ

		// Close Acct and Prohibit Further Proc
		if trn.pcfd5=1 quit

		// don't set support fields for PRA w/h manual adj.
		if ("^DEPBW"]trn.pgm)!("^DEPBW"]trn.pgmec) quit

		set RPASEQ=$$RPASEQ(.acn)
		if RPASEQ="" quit

		type RecordIRATYPE iratype=Db.getRecord("IRATYPE","ACN=:acn.acn,RPASEQ=:RPASEQ",1)

		// Record not found
		if 'iratype.getMode() do Runtime.setErrMSG("IRATYPE",2335) quit

		if 'iratype.rspwind quit

		// Withholding required indicator
		type RecordCUVAR cuvar=Db.getRecord("CUVAR")
		if cuvar.rpanet do {
			set sort("Q",61)=1 
			set sort("Q",62)=1
			}
		}

	for i=1:1 set x=$P(MFREQ,",",i) quit:x=""  do {
		
		type String acro
		
		set qlf=$P(x,"/",1)
		set req=$P(x,"/",2)

		if req["REQ" set req=1
		
		type RecordSTBLTSD stbltsd=Db.getRecord("STBLTSD","SEQ=:qlf",1)
		type RecordUTBLZTSD utblztsd=Db.getRecord("UTBLZTSD","SEQ=:qlf",1)

		if qlf<1000 set acro=stbltsd.acronym

		if qlf>999 set acro=utblztsd.acronym

		if acro="TCMT" set fld="T"
		else  if pobs("TSSP","MSC",acro).exists() set fld="M"
		else  if pobs("TSSP","PSI",acro).exists() set fld="P"
		else  if pobs("TSSP","QLF",acro).exists() set fld="Q"
		else  quit

		if $G(sort(fld,qlf))'="" set sort(fld,qlf)=(+req)_"="_sort(fld,qlf)
		else  set sort(fld,qlf)=+req
		}

	/*
	 Retrieve miscellaeous fields, set defaults, process pre-processers.
	 The goal of the processer is to set a default amount for the variable.
	 If the proceser is not a set of that variable, do not execute the
	 command. It is the responsability of the processer code to assure that
	 the code can be executed and that it does not rely on unreliable
	 variables hanging around (such as dep.cod).
	*/

	if versn=2 do {

		set DATA=trn.mfpre1_$C(9)_trn.mfvar1_$C(9)_trn.mfreq1_$C(9)_trn.mfdft1
		set DATA=DATA_$C(9)_trn.mfpre2_$C(9)_trn.mfvar2_$C(9)_trn.mfreq2
		set DATA=DATA_$C(9)_trn.mfdft2_$C(9)_trn.mfpre3_$C(9)_trn.mfvar3
		set DATA=DATA_$C(9)_trn.mfreq3_$C(9)_trn.mfdft3_$C(9)_trn.mfpre4
		set DATA=DATA_$C(9)_trn.mfvar4_$C(9)_trn.mfreq4_$C(9)_trn.mfdft4
		
		type String MFVAR,VAR,XCODE
		
		if $G(DATA)'="" for i=1:4:16 set XCODE=$P(DATA,$C(9),i) if XCODE'="" do {
			set XCODE=$$LTRIM^%ZS(XCODE)
			set MFVAR=$P(DATA,$C(9),i+1)
			if MFVAR="" quit
		
			// set default value
			set @MFVAR=$P(DATA,$C(9),i+3)
			set VAR=$P($E(XCODE,3,1000),"=",1)

			// Execute the processer if it sets our MFVAR field
			if VAR=$P(DATA,$C(9),i+1) do {
				if $E(XCODE,1,2)'="S " quit
				#ACCEPT DATE=08/26/02;PGM=Teliv
				xecute XCODE
				}
			set sort("M",MFVAR)=(+$P(DATA,$C(9),i+2))_"="_(@MFVAR)
			}
		}

	// TRNSD entries
	if (versn=3)!(versn=4) do {
		// Version 3 - execute post processor if it sets a value.

		type String ACRO,DATA,DEFAULT,FLD,FUNQRY,REQD,VAR,X,XCODE
		type Number SEQ,SUPDATA

		set SEQ=""

		type RecordTRNSD trnsd

		type ResultSet rs=Db.select("SEQ","TRNSD","ETC=:ETC","SEQ")
		if 'rs.isEmpty() while rs.next()  do {
			set SEQ=rs.getCol(1)
			set trnsd=Db.getRecord("TRNSD","ETC=:ETC,SEQ=:SEQ")
			set REQD=(+trnsd.reqd)
			set DEFAULT=trnsd.default
			set SUPDATA=trnsd.supdata

			// Set the preprocessor and acronym
			if SUPDATA<1000 do {
				type RecordSTBLTSD stbltsd=Db.getRecord("STBLTSD","SEQ=:SUPDATA")
				set XCODE=stbltsd.pre
				set ACRO=stbltsd.acronym
				set FUNQRY=stbltsd.funqry
				}
			if SUPDATA>999 do {
				type RecordUTBLZTSD utblztsd=Db.getRecord("UTBLZTSD","SEQ=:SUPDATA")
				set XCODE=utblztsd.pre
                                set ACRO=utblztsd.acronym
				set FUNQRY=utblztsd.funqry
				}

			set XCODE=$$LTRIM^%ZS(XCODE)
			
			if versn=3,XCODE.isNull() quit

			// Query determining whether or not to prompt for this Support Data field.
			#ACCEPT CR=23553;DATE=10/10/06;PGM=Sanjay
			if 'FUNQRY.isNull() set FUNQRY="S X="_FUNQRY xecute FUNQRY if 'X quit

			/*
			Use default value from TRNSD first. If pre-processor
			exists on STBLTSD (UTBLZTSD) entry, and it's defined to
			default the acronym (e.g., S BWPCT=$$WP^DEPBW(CID))
			override the default amount.
			*/

			set @ACRO=DEFAULT
			set VAR=$P($E(XCODE,3,1000),"=",1)

			if VAR=ACRO do {
				if $E(XCODE,1,2)'="S " quit
				#ACCEPT DATE=08/26/02;PGM=Teliv
				xecute XCODE
				}

			// If preprocessor exists, return field.
			if ACRO="TCMT" set FLD="T"
			else  if pobs("TSSP","PSI",ACRO).data() set FLD="P"
			else  if pobs("TSSP","QLF",ACRO).data() set FLD="Q"
			else  set FLD="M"
			set sort(FLD,SUPDATA)=REQD_"="_@ACRO
			}
		}
	set (fld,qlf)=""
	for  set fld=$O(sort(fld)) quit:fld=""  do {
		set retval=""
		for  set qlf=$O(sort(fld,qlf)) do { quit:qlf=""
			if qlf="" do { quit
				set return=return_$$V2LV^MSG(fld_","_$E(retval,1,$L(retval)-1))
				}
			set retval=retval_qlf_"="_sort(fld,qlf)_","
			}
		}

	if $G(SELECT)'="" do {
		type Number I
		type String data,PARAM,SQLPARAM,stmt

		type RecordTOKEN token=Db.getRecord("TOKEN","TOKEN=:%TOKEN")
		set PARAM=token.ctxt
		set SQLPARAM=""
		for I=1:1:$L(PARAM,"/") if $P(PARAM,"/",I)["PROT"!($P(PARAM,"/",I)["DQMODE") set SQLPARAM=SQLPARAM_"/"_$P(PARAM,"/",I)
		set stmt=$P(SELECT," ",2,999)
		do SELECT^SQL(stmt,$G(QUAL)_SQLPARAM,,.data) quit:ER

		set return=return_$$V2LV^MSG("S,"_data)
		}

	if ER quit $$ERRMSG^PBSUTL(RM)
	quit ""

RPASEQ(RecordDEP dep)
	type String RPASEQ
	set RPASEQ=dep.rpaseq
	quit RPASEQ

IRCBLN(RecordLN ln)
	type String IRCB
	set IRCB=ln.ircb
	quit IRCB

IRCBDEP(RecordDEP dep)
        type String IRCB
        set IRCB=dep.ircb
        quit IRCB
 
PROC(cls,mft)	//  Process MFT array from CRTMF

	type Public Number ER
	
	type Number i
	type String %READ=""
	type String x

	for i=1:1 set x=$G(mft(cls,i)) quit:x=""!(ER)  do BLDSCR^CRTMF(x,1)
	quit %READ


SRVFEE(RecordTRN trn,INPUT)	//Private; Handle service fee default calculation

	/*
	   Arguments:
	   . INPUT Input from teller screen /TYP=T/REQ
	    Comma separated list:
	      CID,CNT,ETC-1,TAMT-1
	      CID    = Source account
	      FEECNT = number of items
	      LSTETC = previous tran code (line above)
	      LSTAMT = previous tran amount

	   Returns:
	   . $$ Default amount

	*/

	type Public Date SRVDATE
	type Public Number ER
	type Public String ETC
	
	type Number CHGOPT,CID,FEEAMT,FEECNT,TAMT
	type String DFT,FEEPLN,FID,fsn,LSTETC,LSTAMT,PGM,pplst,TSO,TYPE,val,vdd

	/*
	 Before a call to a service fee program we must trick the system
	 into thinking that we are a interactive process rather then batch.
	 Setting CRT to a value of 1 accomplishes this. This fixes a problem
	 where the default amount was being calculated for a GUI client when
	 that amount should have been 0.
	*/

	type Number CRT=1

	set CID=$P(INPUT,",",1) 
	set FEECNT=$P(INPUT,",",2)
	set LSTETC=$P(INPUT,",",3) 
	set LSTAMT=$P(INPUT,",",4)

	if CID="" quit ""
	if 'FEECNT set FEECNT=1

	// Default amount from tran code
	if trn.amt set DFT=trn.amt

	set FID=$S(trn.cls="L":"LN",1:"DEP")

	set pplst="FEEPLN,TYPE,ANLSYS,SCND,SVCFEECID"

	set val=$$getdata^PBSUTL(FID,pplst,CID,.fsn,.vdd) 
	if ER quit ""
	
	set FEEPLN=$P(val,$C(28),1)
	set TYPE=$P(val,$C(28),2)

	if FEEPLN="" quit ""

	set TAMT=$$FEETYP(0)

	// Find correct posting program
	type ResultSet rs=Db.select("FEEDT","FEEPLN","PLAN=:FEEPLN AND FEEDT<=:%EffectiveDate","FEEDT DESC")
	if 'rs.isEmpty(),rs.next() set SRVDATE=rs.getCol(1)

	set PGM=$$FEEPGM^UFID(FEEPLN,SRVDATE) if ER quit ""

	// Invalid service fee posting program
	if PGM="" quit ""
	
	type RecordACN acn = Db.getRecord("ACN", "CID=:CID")
	
	do CALLPGM(PGM, .acn, ETC, +FEECNT, TAMT, .FEEAMT)"

	if 'FEEAMT.exists() quit ""
	if CHGOPT=1 quit FEEAMT

	// Service fee is calculated at analysis
	quit ""
	
	
CALLPGM(String PGM,
	RecordACN acn,
	String ETC,
	Number FEECNT,
	Number TAMT,
	Number FEEAMT)
	
	/*
	This sub-routine is used to prevent object optimization of acn
	without turning off optimization for the whole routine.  The acn
	reference is optimized because the call to the fee program, which
	would prevent optimization, is hidden from PSL due to the use of
	indirection.  Once PSL provides a better means to control turning
	optimization off on an instance basis, this can be removed, and
	the code returned to the SRVFEE section.
	*/
	
	set PGM = "^"_PGM_"(.acn,1,ETC,FEECNT,1,TAMT)"
	do @PGM
	
	quit


FEETYP(TAMT)	// Find TAMT for fees based on a percent of the previous
	/*
	    transaction amount. Example CECF is 10% of TAMT of CEC.
	    If TAMT returns with zero, then the fee type is based on a percentage
	    that can not be calculated or the fee type is not based on a
	    percentage.
	    If TAMT returns with a value other than 0, then the fee type
	    is based on a percentage of TAMT that is returned.
	*/

	type Public Number LSTAMT
	type Public String LSTETC
	
	if LSTETC="" quit TAMT

	type RecordTRN trn=Db.getRecord("TRN","ETC=:LSTETC")
	if trn.cls'="M" quit TAMT

	quit LSTAMT


GETETC(String ETC,String TYPE)

	/* Retrieve default credit or debit tran code from product type

	Based on Account Class (loan or deposit) type andd currency and
	requested type of ETC, return either DRTGRP or CRTGRP from the
	product file.
	*/
	
	type Public String sort()
	type String DATA = ""

	if TYPE="" quit ""

	type RecordPRODCTL prodctl=Db.getRecord("PRODCTL","TYPE=:TYPE",1)
	if 'prodctl.getMode() quit ""
	
	if ETC="*DR"  set DATA=prodctl.drtrgp
	if ETC="*CR"  set DATA=prodctl.crtrgp

	if DATA'="" do {
		set ETC=DATA 
		set sort("E","ETC")=ETC
		}

	quit DATA


V1(return,versn,ETC,CID,AMT,%ProcessMode)	//Private ; Version 1 code

	/*

	   This extrinsic function returns a list of transaction
	   qualifiers (service class TSSP) for a specified
	   account based upon the transaction code.

	   [SCATBL5]RPCID=3

	   KEYWORDS: Client/Server, Transaction Processing

	   ARGUMENTS:
	       . return 	Transaction qualifiers  	/TYP=T/REQ
	        						/MECH=REFNAM:W

	       . versn 		^MRPC003 version number  	/TYP=N/REQ
	    			Current version = 1  		/MECH=VAL

	       . ETC 		PROFILE transaction code 	/TYP=T/REQ
	        						/MECH=VAL

	       . CID 		Account number   		/TYP=N/REQ
	        						/MECH=VAL

	       . AMT 		Transaction amount  		/TYP=N/REQ
	        						/MECH=VAL

	   RETURNS:
	       . $$ 	Error message   			/TYP=T
	    		Null = No error

	   RELATED:
	       . $$^PBSMRPC - MRPC Service Class Driver


	*/

	type Public Number ER=0
	type Public String CLS,E(),ITC,ET,MFREQ,MFT(),RM
	
	if '%ProcessMode.exists() set %ProcessMode=0

	// Version number of client message is not compatible with server
	if versn'=1 quit $$ERRMSG^PBSUTL($$^MSG(2951))
	
	type RecordTRN trn=Db.getRecord("TRN","ETC=:ETC")

	do ETCCID^TTXEXT(.trn,CID) if ER quit $$ERRMSG^PBSUTL($G(RM),$G(ET))

	set ITC=trn.itc
	set CLS=trn.cls 
	set E(9)=trn.mff

	// Record not on file
	if "DL"[CLS,'Db.isDefined("ACN","CID=:CID") set ER=1,ET="RECNOF" quit $$ERRMSG^PBSUTL(,ET)

	do CRTMFT^CRTMF

	set MFREQ=$$PROC1(CLS,.MFT)

	type Number i,req
	type String fld,pobs,qlf,x
	
	do POBS^TTXRPC(.pobs)

	set (fld,qlf,return)=""

	for i=1:1 set x=$P(MFREQ,",",i) quit:x=""  do {
		set qlf=$P(x,"#",1)
		set req=$P(x,"#",2)

		if qlf="TCMT" set fld="T"
		else  if pobs("TSSP","MSC",qlf).exists() set fld="M"
		else  if pobs("TSSP","PSI",qlf).exists() set fld="P"
		else  if pobs("TSSP","QLF",qlf).exists() set fld="Q"
		set return=return_$$V2LV^MSG(qlf)_$$V2LV^MSG(+req)_$$V2LV^MSG(fld)
		}

	quit ""


PROC1(cls,mft)	//  Process MFT array from CRTMF

	type Public Number ER
	
	type Number i
	type String %READ=""
	type String x

	for i=1:1 set x=$G(mft(cls,i)) quit:x=""!(ER)  do CRTBLDSCR^CRTMF(x)

	quit %READ

vSIG()	quit "60653^54889^Marie Mbui^19109"	// Signature - LTD^TIME^USER^SIZE
